
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ttcmap.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***************************************************************************/</a>
<a name="ln2">/*                                                                         */</a>
<a name="ln3">/*  ttcmap.c                                                               */</a>
<a name="ln4">/*                                                                         */</a>
<a name="ln5">/*    TrueType character mapping table (cmap) support (body).              */</a>
<a name="ln6">/*                                                                         */</a>
<a name="ln7">/*  Copyright 2002-2015 by                                                 */</a>
<a name="ln8">/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</a>
<a name="ln9">/*                                                                         */</a>
<a name="ln10">/*  This file is part of the FreeType project, and may only be used,       */</a>
<a name="ln11">/*  modified, and distributed under the terms of the FreeType project      */</a>
<a name="ln12">/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</a>
<a name="ln13">/*  this file you indicate that you have read the license and              */</a>
<a name="ln14">/*  understand and accept it fully.                                        */</a>
<a name="ln15">/*                                                                         */</a>
<a name="ln16">/***************************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;ft2build.h&gt;</a>
<a name="ln20">#include FT_INTERNAL_DEBUG_H</a>
<a name="ln21"> </a>
<a name="ln22">#include &quot;sferrors.h&quot;           /* must come before FT_INTERNAL_VALIDATE_H */</a>
<a name="ln23"> </a>
<a name="ln24">#include FT_INTERNAL_VALIDATE_H</a>
<a name="ln25">#include FT_INTERNAL_STREAM_H</a>
<a name="ln26">#include &quot;ttload.h&quot;</a>
<a name="ln27">#include &quot;ttcmap.h&quot;</a>
<a name="ln28">#include &quot;sfntpic.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30"> </a>
<a name="ln31">  /*************************************************************************/</a>
<a name="ln32">  /*                                                                       */</a>
<a name="ln33">  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</a>
<a name="ln34">  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</a>
<a name="ln35">  /* messages during execution.                                            */</a>
<a name="ln36">  /*                                                                       */</a>
<a name="ln37">#undef  FT_COMPONENT</a>
<a name="ln38">#define FT_COMPONENT  trace_ttcmap</a>
<a name="ln39"> </a>
<a name="ln40"> </a>
<a name="ln41">#define TT_PEEK_SHORT   FT_PEEK_SHORT</a>
<a name="ln42">#define TT_PEEK_USHORT  FT_PEEK_USHORT</a>
<a name="ln43">#define TT_PEEK_UINT24  FT_PEEK_UOFF3</a>
<a name="ln44">#define TT_PEEK_LONG    FT_PEEK_LONG</a>
<a name="ln45">#define TT_PEEK_ULONG   FT_PEEK_ULONG</a>
<a name="ln46"> </a>
<a name="ln47">#define TT_NEXT_SHORT   FT_NEXT_SHORT</a>
<a name="ln48">#define TT_NEXT_USHORT  FT_NEXT_USHORT</a>
<a name="ln49">#define TT_NEXT_UINT24  FT_NEXT_UOFF3</a>
<a name="ln50">#define TT_NEXT_LONG    FT_NEXT_LONG</a>
<a name="ln51">#define TT_NEXT_ULONG   FT_NEXT_ULONG</a>
<a name="ln52"> </a>
<a name="ln53"> </a>
<a name="ln54">  /* Too large glyph index return values are caught in `FT_Get_Char_Index' */</a>
<a name="ln55">  /* and `FT_Get_Next_Char' (the latter calls the internal `next' function */</a>
<a name="ln56">  /* again in this case).  To mark character code return values as invalid */</a>
<a name="ln57">  /* it is sufficient to set the corresponding glyph index return value to */</a>
<a name="ln58">  /* zero.                                                                 */</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln62">  tt_cmap_init( TT_CMap   cmap,</a>
<a name="ln63">                FT_Byte*  table )</a>
<a name="ln64">  {</a>
<a name="ln65">    cmap-&gt;data = table;</a>
<a name="ln66">    return FT_Err_Ok;</a>
<a name="ln67">  }</a>
<a name="ln68"> </a>
<a name="ln69"> </a>
<a name="ln70">  /*************************************************************************/</a>
<a name="ln71">  /*************************************************************************/</a>
<a name="ln72">  /*****                                                               *****/</a>
<a name="ln73">  /*****                           FORMAT 0                            *****/</a>
<a name="ln74">  /*****                                                               *****/</a>
<a name="ln75">  /*************************************************************************/</a>
<a name="ln76">  /*************************************************************************/</a>
<a name="ln77"> </a>
<a name="ln78">  /*************************************************************************/</a>
<a name="ln79">  /*                                                                       */</a>
<a name="ln80">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln81">  /* --------------                                                        */</a>
<a name="ln82">  /*                                                                       */</a>
<a name="ln83">  /*   NAME        OFFSET         TYPE          DESCRIPTION                */</a>
<a name="ln84">  /*                                                                       */</a>
<a name="ln85">  /*   format      0              USHORT        must be 0                  */</a>
<a name="ln86">  /*   length      2              USHORT        table length in bytes      */</a>
<a name="ln87">  /*   language    4              USHORT        Mac language code          */</a>
<a name="ln88">  /*   glyph_ids   6              BYTE[256]     array of glyph indices     */</a>
<a name="ln89">  /*               262                                                     */</a>
<a name="ln90">  /*                                                                       */</a>
<a name="ln91"> </a>
<a name="ln92">#ifdef TT_CONFIG_CMAP_FORMAT_0</a>
<a name="ln93"> </a>
<a name="ln94">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln95">  tt_cmap0_validate( FT_Byte*      table,</a>
<a name="ln96">                     FT_Validator  valid )</a>
<a name="ln97">  {</a>
<a name="ln98">    FT_Byte*  p;</a>
<a name="ln99">    FT_UInt   length;</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">    if ( table + 2 + 2 &gt; valid-&gt;limit )</a>
<a name="ln103">      FT_INVALID_TOO_SHORT;</a>
<a name="ln104"> </a>
<a name="ln105">    p      = table + 2;           /* skip format */</a>
<a name="ln106">    length = TT_NEXT_USHORT( p );</a>
<a name="ln107"> </a>
<a name="ln108">    if ( table + length &gt; valid-&gt;limit || length &lt; 262 )</a>
<a name="ln109">      FT_INVALID_TOO_SHORT;</a>
<a name="ln110"> </a>
<a name="ln111">    /* check glyph indices whenever necessary */</a>
<a name="ln112">    if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln113">    {</a>
<a name="ln114">      FT_UInt  n, idx;</a>
<a name="ln115"> </a>
<a name="ln116"> </a>
<a name="ln117">      p = table + 6;</a>
<a name="ln118">      for ( n = 0; n &lt; 256; n++ )</a>
<a name="ln119">      {</a>
<a name="ln120">        idx = *p++;</a>
<a name="ln121">        if ( idx &gt;= TT_VALID_GLYPH_COUNT( valid ) )</a>
<a name="ln122">          FT_INVALID_GLYPH_ID;</a>
<a name="ln123">      }</a>
<a name="ln124">    }</a>
<a name="ln125"> </a>
<a name="ln126">    return FT_Err_Ok;</a>
<a name="ln127">  }</a>
<a name="ln128"> </a>
<a name="ln129"> </a>
<a name="ln130">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln131">  tt_cmap0_char_index( TT_CMap    cmap,</a>
<a name="ln132">                       FT_UInt32  char_code )</a>
<a name="ln133">  {</a>
<a name="ln134">    FT_Byte*  table = cmap-&gt;data;</a>
<a name="ln135"> </a>
<a name="ln136"> </a>
<a name="ln137">    return char_code &lt; 256 ? table[6 + char_code] : 0;</a>
<a name="ln138">  }</a>
<a name="ln139"> </a>
<a name="ln140"> </a>
<a name="ln141">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln142">  tt_cmap0_char_next( TT_CMap     cmap,</a>
<a name="ln143">                      FT_UInt32  *pchar_code )</a>
<a name="ln144">  {</a>
<a name="ln145">    FT_Byte*   table    = cmap-&gt;data;</a>
<a name="ln146">    FT_UInt32  charcode = *pchar_code;</a>
<a name="ln147">    FT_UInt32  result   = 0;</a>
<a name="ln148">    FT_UInt    gindex   = 0;</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">    table += 6;  /* go to glyph IDs */</a>
<a name="ln152">    while ( ++charcode &lt; 256 )</a>
<a name="ln153">    {</a>
<a name="ln154">      gindex = table[charcode];</a>
<a name="ln155">      if ( gindex != 0 )</a>
<a name="ln156">      {</a>
<a name="ln157">        result = charcode;</a>
<a name="ln158">        break;</a>
<a name="ln159">      }</a>
<a name="ln160">    }</a>
<a name="ln161"> </a>
<a name="ln162">    *pchar_code = result;</a>
<a name="ln163">    return gindex;</a>
<a name="ln164">  }</a>
<a name="ln165"> </a>
<a name="ln166"> </a>
<a name="ln167">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln168">  tt_cmap0_get_info( TT_CMap       cmap,</a>
<a name="ln169">                     TT_CMapInfo  *cmap_info )</a>
<a name="ln170">  {</a>
<a name="ln171">    FT_Byte*  p = cmap-&gt;data + 4;</a>
<a name="ln172"> </a>
<a name="ln173"> </a>
<a name="ln174">    cmap_info-&gt;format   = 0;</a>
<a name="ln175">    cmap_info-&gt;language = (FT_ULong)TT_PEEK_USHORT( p );</a>
<a name="ln176"> </a>
<a name="ln177">    return FT_Err_Ok;</a>
<a name="ln178">  }</a>
<a name="ln179"> </a>
<a name="ln180"> </a>
<a name="ln181">  FT_DEFINE_TT_CMAP(</a>
<a name="ln182">    tt_cmap0_class_rec,</a>
<a name="ln183">    sizeof ( TT_CMapRec ),</a>
<a name="ln184"> </a>
<a name="ln185">    (FT_CMap_InitFunc)     tt_cmap_init,</a>
<a name="ln186">    (FT_CMap_DoneFunc)     NULL,</a>
<a name="ln187">    (FT_CMap_CharIndexFunc)tt_cmap0_char_index,</a>
<a name="ln188">    (FT_CMap_CharNextFunc) tt_cmap0_char_next,</a>
<a name="ln189"> </a>
<a name="ln190">    NULL,</a>
<a name="ln191">    NULL,</a>
<a name="ln192">    NULL,</a>
<a name="ln193">    NULL,</a>
<a name="ln194">    NULL,</a>
<a name="ln195"> </a>
<a name="ln196">    0,</a>
<a name="ln197">    (TT_CMap_ValidateFunc)tt_cmap0_validate,</a>
<a name="ln198">    (TT_CMap_Info_GetFunc)tt_cmap0_get_info )</a>
<a name="ln199"> </a>
<a name="ln200">#endif /* TT_CONFIG_CMAP_FORMAT_0 */</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">  /*************************************************************************/</a>
<a name="ln204">  /*************************************************************************/</a>
<a name="ln205">  /*****                                                               *****/</a>
<a name="ln206">  /*****                          FORMAT 2                             *****/</a>
<a name="ln207">  /*****                                                               *****/</a>
<a name="ln208">  /***** This is used for certain CJK encodings that encode text in a  *****/</a>
<a name="ln209">  /***** mixed 8/16 bits encoding along the following lines.           *****/</a>
<a name="ln210">  /*****                                                               *****/</a>
<a name="ln211">  /***** * Certain byte values correspond to an 8-bit character code   *****/</a>
<a name="ln212">  /*****   (typically in the range 0..127 for ASCII compatibility).    *****/</a>
<a name="ln213">  /*****                                                               *****/</a>
<a name="ln214">  /***** * Certain byte values signal the first byte of a 2-byte       *****/</a>
<a name="ln215">  /*****   character code (but these values are also valid as the      *****/</a>
<a name="ln216">  /*****   second byte of a 2-byte character).                         *****/</a>
<a name="ln217">  /*****                                                               *****/</a>
<a name="ln218">  /***** The following charmap lookup and iteration functions all      *****/</a>
<a name="ln219">  /***** assume that the value `charcode' fulfills the following.      *****/</a>
<a name="ln220">  /*****                                                               *****/</a>
<a name="ln221">  /*****   - For one byte characters, `charcode' is simply the         *****/</a>
<a name="ln222">  /*****     character code.                                           *****/</a>
<a name="ln223">  /*****                                                               *****/</a>
<a name="ln224">  /*****   - For two byte characters, `charcode' is the 2-byte         *****/</a>
<a name="ln225">  /*****     character code in big endian format.  More precisely:     *****/</a>
<a name="ln226">  /*****                                                               *****/</a>
<a name="ln227">  /*****       (charcode &gt;&gt; 8)    is the first byte value              *****/</a>
<a name="ln228">  /*****       (charcode &amp; 0xFF)  is the second byte value             *****/</a>
<a name="ln229">  /*****                                                               *****/</a>
<a name="ln230">  /***** Note that not all values of `charcode' are valid according    *****/</a>
<a name="ln231">  /***** to these rules, and the function moderately checks the        *****/</a>
<a name="ln232">  /***** arguments.                                                    *****/</a>
<a name="ln233">  /*****                                                               *****/</a>
<a name="ln234">  /*************************************************************************/</a>
<a name="ln235">  /*************************************************************************/</a>
<a name="ln236"> </a>
<a name="ln237">  /*************************************************************************/</a>
<a name="ln238">  /*                                                                       */</a>
<a name="ln239">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln240">  /* --------------                                                        */</a>
<a name="ln241">  /*                                                                       */</a>
<a name="ln242">  /*   NAME        OFFSET         TYPE            DESCRIPTION              */</a>
<a name="ln243">  /*                                                                       */</a>
<a name="ln244">  /*   format      0              USHORT          must be 2                */</a>
<a name="ln245">  /*   length      2              USHORT          table length in bytes    */</a>
<a name="ln246">  /*   language    4              USHORT          Mac language code        */</a>
<a name="ln247">  /*   keys        6              USHORT[256]     sub-header keys          */</a>
<a name="ln248">  /*   subs        518            SUBHEAD[NSUBS]  sub-headers array        */</a>
<a name="ln249">  /*   glyph_ids   518+NSUB*8     USHORT[]        glyph ID array           */</a>
<a name="ln250">  /*                                                                       */</a>
<a name="ln251">  /* The `keys' table is used to map charcode high-bytes to sub-headers.   */</a>
<a name="ln252">  /* The value of `NSUBS' is the number of sub-headers defined in the      */</a>
<a name="ln253">  /* table and is computed by finding the maximum of the `keys' table.     */</a>
<a name="ln254">  /*                                                                       */</a>
<a name="ln255">  /* Note that for any n, `keys[n]' is a byte offset within the `subs'     */</a>
<a name="ln256">  /* table, i.e., it is the corresponding sub-header index multiplied      */</a>
<a name="ln257">  /* by 8.                                                                 */</a>
<a name="ln258">  /*                                                                       */</a>
<a name="ln259">  /* Each sub-header has the following format.                             */</a>
<a name="ln260">  /*                                                                       */</a>
<a name="ln261">  /*   NAME        OFFSET      TYPE            DESCRIPTION                 */</a>
<a name="ln262">  /*                                                                       */</a>
<a name="ln263">  /*   first       0           USHORT          first valid low-byte        */</a>
<a name="ln264">  /*   count       2           USHORT          number of valid low-bytes   */</a>
<a name="ln265">  /*   delta       4           SHORT           see below                   */</a>
<a name="ln266">  /*   offset      6           USHORT          see below                   */</a>
<a name="ln267">  /*                                                                       */</a>
<a name="ln268">  /* A sub-header defines, for each high-byte, the range of valid          */</a>
<a name="ln269">  /* low-bytes within the charmap.  Note that the range defined by `first' */</a>
<a name="ln270">  /* and `count' must be completely included in the interval [0..255]      */</a>
<a name="ln271">  /* according to the specification.                                       */</a>
<a name="ln272">  /*                                                                       */</a>
<a name="ln273">  /* If a character code is contained within a given sub-header, then      */</a>
<a name="ln274">  /* mapping it to a glyph index is done as follows.                       */</a>
<a name="ln275">  /*                                                                       */</a>
<a name="ln276">  /* * The value of `offset' is read.  This is a _byte_ distance from the  */</a>
<a name="ln277">  /*   location of the `offset' field itself into a slice of the           */</a>
<a name="ln278">  /*   `glyph_ids' table.  Let's call it `slice' (it is a USHORT[], too).  */</a>
<a name="ln279">  /*                                                                       */</a>
<a name="ln280">  /* * The value `slice[char.lo - first]' is read.  If it is 0, there is   */</a>
<a name="ln281">  /*   no glyph for the charcode.  Otherwise, the value of `delta' is      */</a>
<a name="ln282">  /*   added to it (modulo 65536) to form a new glyph index.               */</a>
<a name="ln283">  /*                                                                       */</a>
<a name="ln284">  /* It is up to the validation routine to check that all offsets fall     */</a>
<a name="ln285">  /* within the glyph IDs table (and not within the `subs' table itself or */</a>
<a name="ln286">  /* outside of the CMap).                                                 */</a>
<a name="ln287">  /*                                                                       */</a>
<a name="ln288"> </a>
<a name="ln289">#ifdef TT_CONFIG_CMAP_FORMAT_2</a>
<a name="ln290"> </a>
<a name="ln291">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln292">  tt_cmap2_validate( FT_Byte*      table,</a>
<a name="ln293">                     FT_Validator  valid )</a>
<a name="ln294">  {</a>
<a name="ln295">    FT_Byte*  p;</a>
<a name="ln296">    FT_UInt   length;</a>
<a name="ln297"> </a>
<a name="ln298">    FT_UInt   n, max_subs;</a>
<a name="ln299">    FT_Byte*  keys;        /* keys table     */</a>
<a name="ln300">    FT_Byte*  subs;        /* sub-headers    */</a>
<a name="ln301">    FT_Byte*  glyph_ids;   /* glyph ID array */</a>
<a name="ln302"> </a>
<a name="ln303"> </a>
<a name="ln304">    if ( table + 2 + 2 &gt; valid-&gt;limit )</a>
<a name="ln305">      FT_INVALID_TOO_SHORT;</a>
<a name="ln306"> </a>
<a name="ln307">    p      = table + 2;           /* skip format */</a>
<a name="ln308">    length = TT_NEXT_USHORT( p );</a>
<a name="ln309"> </a>
<a name="ln310">    if ( table + length &gt; valid-&gt;limit || length &lt; 6 + 512 )</a>
<a name="ln311">      FT_INVALID_TOO_SHORT;</a>
<a name="ln312"> </a>
<a name="ln313">    keys = table + 6;</a>
<a name="ln314"> </a>
<a name="ln315">    /* parse keys to compute sub-headers count */</a>
<a name="ln316">    p        = keys;</a>
<a name="ln317">    max_subs = 0;</a>
<a name="ln318">    for ( n = 0; n &lt; 256; n++ )</a>
<a name="ln319">    {</a>
<a name="ln320">      FT_UInt  idx = TT_NEXT_USHORT( p );</a>
<a name="ln321"> </a>
<a name="ln322"> </a>
<a name="ln323">      /* value must be multiple of 8 */</a>
<a name="ln324">      if ( valid-&gt;level &gt;= FT_VALIDATE_PARANOID &amp;&amp; ( idx &amp; 7 ) != 0 )</a>
<a name="ln325">        FT_INVALID_DATA;</a>
<a name="ln326"> </a>
<a name="ln327">      idx &gt;&gt;= 3;</a>
<a name="ln328"> </a>
<a name="ln329">      if ( idx &gt; max_subs )</a>
<a name="ln330">        max_subs = idx;</a>
<a name="ln331">    }</a>
<a name="ln332"> </a>
<a name="ln333">    FT_ASSERT( p == table + 518 );</a>
<a name="ln334"> </a>
<a name="ln335">    subs      = p;</a>
<a name="ln336">    glyph_ids = subs + ( max_subs + 1 ) * 8;</a>
<a name="ln337">    if ( glyph_ids &gt; valid-&gt;limit )</a>
<a name="ln338">      FT_INVALID_TOO_SHORT;</a>
<a name="ln339"> </a>
<a name="ln340">    /* parse sub-headers */</a>
<a name="ln341">    for ( n = 0; n &lt;= max_subs; n++ )</a>
<a name="ln342">    {</a>
<a name="ln343">      FT_UInt  first_code, code_count, offset;</a>
<a name="ln344">      FT_Int   delta;</a>
<a name="ln345"> </a>
<a name="ln346"> </a>
<a name="ln347">      first_code = TT_NEXT_USHORT( p );</a>
<a name="ln348">      code_count = TT_NEXT_USHORT( p );</a>
<a name="ln349">      delta      = TT_NEXT_SHORT( p );</a>
<a name="ln350">      offset     = TT_NEXT_USHORT( p );</a>
<a name="ln351"> </a>
<a name="ln352">      /* many Dynalab fonts have empty sub-headers */</a>
<a name="ln353">      if ( code_count == 0 )</a>
<a name="ln354">        continue;</a>
<a name="ln355"> </a>
<a name="ln356">      /* check range within 0..255 */</a>
<a name="ln357">      if ( valid-&gt;level &gt;= FT_VALIDATE_PARANOID )</a>
<a name="ln358">      {</a>
<a name="ln359">        if ( first_code &gt;= 256 || first_code + code_count &gt; 256 )</a>
<a name="ln360">          FT_INVALID_DATA;</a>
<a name="ln361">      }</a>
<a name="ln362"> </a>
<a name="ln363">      /* check offset */</a>
<a name="ln364">      if ( offset != 0 )</a>
<a name="ln365">      {</a>
<a name="ln366">        FT_Byte*  ids;</a>
<a name="ln367"> </a>
<a name="ln368"> </a>
<a name="ln369">        ids = p - 2 + offset;</a>
<a name="ln370">        if ( ids &lt; glyph_ids || ids + code_count * 2 &gt; table + length )</a>
<a name="ln371">          FT_INVALID_OFFSET;</a>
<a name="ln372"> </a>
<a name="ln373">        /* check glyph IDs */</a>
<a name="ln374">        if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln375">        {</a>
<a name="ln376">          FT_Byte*  limit = p + code_count * 2;</a>
<a name="ln377">          FT_UInt   idx;</a>
<a name="ln378"> </a>
<a name="ln379"> </a>
<a name="ln380">          for ( ; p &lt; limit; )</a>
<a name="ln381">          {</a>
<a name="ln382">            idx = TT_NEXT_USHORT( p );</a>
<a name="ln383">            if ( idx != 0 )</a>
<a name="ln384">            {</a>
<a name="ln385">              idx = (FT_UInt)( (FT_Int)idx + delta ) &amp; 0xFFFFU;</a>
<a name="ln386">              if ( idx &gt;= TT_VALID_GLYPH_COUNT( valid ) )</a>
<a name="ln387">                FT_INVALID_GLYPH_ID;</a>
<a name="ln388">            }</a>
<a name="ln389">          }</a>
<a name="ln390">        }</a>
<a name="ln391">      }</a>
<a name="ln392">    }</a>
<a name="ln393"> </a>
<a name="ln394">    return FT_Err_Ok;</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397"> </a>
<a name="ln398">  /* return sub header corresponding to a given character code */</a>
<a name="ln399">  /* NULL on invalid charcode                                  */</a>
<a name="ln400">  static FT_Byte*</a>
<a name="ln401">  tt_cmap2_get_subheader( FT_Byte*   table,</a>
<a name="ln402">                          FT_UInt32  char_code )</a>
<a name="ln403">  {</a>
<a name="ln404">    FT_Byte*  result = NULL;</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">    if ( char_code &lt; 0x10000UL )</a>
<a name="ln408">    {</a>
<a name="ln409">      FT_UInt   char_lo = (FT_UInt)( char_code &amp; 0xFF );</a>
<a name="ln410">      FT_UInt   char_hi = (FT_UInt)( char_code &gt;&gt; 8 );</a>
<a name="ln411">      FT_Byte*  p       = table + 6;    /* keys table */</a>
<a name="ln412">      FT_Byte*  subs    = table + 518;  /* subheaders table */</a>
<a name="ln413">      FT_Byte*  sub;</a>
<a name="ln414"> </a>
<a name="ln415"> </a>
<a name="ln416">      if ( char_hi == 0 )</a>
<a name="ln417">      {</a>
<a name="ln418">        /* an 8-bit character code -- we use subHeader 0 in this case */</a>
<a name="ln419">        /* to test whether the character code is in the charmap       */</a>
<a name="ln420">        /*                                                            */</a>
<a name="ln421">        sub = subs;  /* jump to first sub-header */</a>
<a name="ln422"> </a>
<a name="ln423">        /* check that the sub-header for this byte is 0, which */</a>
<a name="ln424">        /* indicates that it is really a valid one-byte value  */</a>
<a name="ln425">        /* Otherwise, return 0                                 */</a>
<a name="ln426">        /*                                                     */</a>
<a name="ln427">        p += char_lo * 2;</a>
<a name="ln428">        if ( TT_PEEK_USHORT( p ) != 0 )</a>
<a name="ln429">          goto Exit;</a>
<a name="ln430">      }</a>
<a name="ln431">      else</a>
<a name="ln432">      {</a>
<a name="ln433">        /* a 16-bit character code */</a>
<a name="ln434"> </a>
<a name="ln435">        /* jump to key entry  */</a>
<a name="ln436">        p  += char_hi * 2;</a>
<a name="ln437">        /* jump to sub-header */</a>
<a name="ln438">        sub = subs + ( FT_PAD_FLOOR( TT_PEEK_USHORT( p ), 8 ) );</a>
<a name="ln439"> </a>
<a name="ln440">        /* check that the high byte isn't a valid one-byte value */</a>
<a name="ln441">        if ( sub == subs )</a>
<a name="ln442">          goto Exit;</a>
<a name="ln443">      }</a>
<a name="ln444">      result = sub;</a>
<a name="ln445">    }</a>
<a name="ln446"> </a>
<a name="ln447">  Exit:</a>
<a name="ln448">    return result;</a>
<a name="ln449">  }</a>
<a name="ln450"> </a>
<a name="ln451"> </a>
<a name="ln452">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln453">  tt_cmap2_char_index( TT_CMap    cmap,</a>
<a name="ln454">                       FT_UInt32  char_code )</a>
<a name="ln455">  {</a>
<a name="ln456">    FT_Byte*  table   = cmap-&gt;data;</a>
<a name="ln457">    FT_UInt   result  = 0;</a>
<a name="ln458">    FT_Byte*  subheader;</a>
<a name="ln459"> </a>
<a name="ln460"> </a>
<a name="ln461">    subheader = tt_cmap2_get_subheader( table, char_code );</a>
<a name="ln462">    if ( subheader )</a>
<a name="ln463">    {</a>
<a name="ln464">      FT_Byte*  p   = subheader;</a>
<a name="ln465">      FT_UInt   idx = (FT_UInt)(char_code &amp; 0xFF);</a>
<a name="ln466">      FT_UInt   start, count;</a>
<a name="ln467">      FT_Int    delta;</a>
<a name="ln468">      FT_UInt   offset;</a>
<a name="ln469"> </a>
<a name="ln470"> </a>
<a name="ln471">      start  = TT_NEXT_USHORT( p );</a>
<a name="ln472">      count  = TT_NEXT_USHORT( p );</a>
<a name="ln473">      delta  = TT_NEXT_SHORT ( p );</a>
<a name="ln474">      offset = TT_PEEK_USHORT( p );</a>
<a name="ln475"> </a>
<a name="ln476">      idx -= start;</a>
<a name="ln477">      if ( idx &lt; count &amp;&amp; offset != 0 )</a>
<a name="ln478">      {</a>
<a name="ln479">        p  += offset + 2 * idx;</a>
<a name="ln480">        idx = TT_PEEK_USHORT( p );</a>
<a name="ln481"> </a>
<a name="ln482">        if ( idx != 0 )</a>
<a name="ln483">          result = (FT_UInt)( (FT_Int)idx + delta ) &amp; 0xFFFFU;</a>
<a name="ln484">      }</a>
<a name="ln485">    }</a>
<a name="ln486"> </a>
<a name="ln487">    return result;</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln492">  tt_cmap2_char_next( TT_CMap     cmap,</a>
<a name="ln493">                      FT_UInt32  *pcharcode )</a>
<a name="ln494">  {</a>
<a name="ln495">    FT_Byte*   table    = cmap-&gt;data;</a>
<a name="ln496">    FT_UInt    gindex   = 0;</a>
<a name="ln497">    FT_UInt32  result   = 0;</a>
<a name="ln498">    FT_UInt32  charcode = *pcharcode + 1;</a>
<a name="ln499">    FT_Byte*   subheader;</a>
<a name="ln500"> </a>
<a name="ln501"> </a>
<a name="ln502">    while ( charcode &lt; 0x10000UL )</a>
<a name="ln503">    {</a>
<a name="ln504">      subheader = tt_cmap2_get_subheader( table, charcode );</a>
<a name="ln505">      if ( subheader )</a>
<a name="ln506">      {</a>
<a name="ln507">        FT_Byte*  p       = subheader;</a>
<a name="ln508">        FT_UInt   start   = TT_NEXT_USHORT( p );</a>
<a name="ln509">        FT_UInt   count   = TT_NEXT_USHORT( p );</a>
<a name="ln510">        FT_Int    delta   = TT_NEXT_SHORT ( p );</a>
<a name="ln511">        FT_UInt   offset  = TT_PEEK_USHORT( p );</a>
<a name="ln512">        FT_UInt   char_lo = (FT_UInt)( charcode &amp; 0xFF );</a>
<a name="ln513">        FT_UInt   pos, idx;</a>
<a name="ln514"> </a>
<a name="ln515"> </a>
<a name="ln516">        if ( offset == 0 )</a>
<a name="ln517">          goto Next_SubHeader;</a>
<a name="ln518"> </a>
<a name="ln519">        if ( char_lo &lt; start )</a>
<a name="ln520">        {</a>
<a name="ln521">          char_lo = start;</a>
<a name="ln522">          pos     = 0;</a>
<a name="ln523">        }</a>
<a name="ln524">        else</a>
<a name="ln525">          pos = (FT_UInt)( char_lo - start );</a>
<a name="ln526"> </a>
<a name="ln527">        p       += offset + pos * 2;</a>
<a name="ln528">        charcode = FT_PAD_FLOOR( charcode, 256 ) + char_lo;</a>
<a name="ln529"> </a>
<a name="ln530">        for ( ; pos &lt; count; pos++, charcode++ )</a>
<a name="ln531">        {</a>
<a name="ln532">          idx = TT_NEXT_USHORT( p );</a>
<a name="ln533"> </a>
<a name="ln534">          if ( idx != 0 )</a>
<a name="ln535">          {</a>
<a name="ln536">            gindex = (FT_UInt)( (FT_Int)idx + delta ) &amp; 0xFFFFU;</a>
<a name="ln537">            if ( gindex != 0 )</a>
<a name="ln538">            {</a>
<a name="ln539">              result = charcode;</a>
<a name="ln540">              goto Exit;</a>
<a name="ln541">            }</a>
<a name="ln542">          }</a>
<a name="ln543">        }</a>
<a name="ln544">      }</a>
<a name="ln545"> </a>
<a name="ln546">      /* jump to next sub-header, i.e. higher byte value */</a>
<a name="ln547">    Next_SubHeader:</a>
<a name="ln548">      charcode = FT_PAD_FLOOR( charcode, 256 ) + 256;</a>
<a name="ln549">    }</a>
<a name="ln550"> </a>
<a name="ln551">  Exit:</a>
<a name="ln552">    *pcharcode = result;</a>
<a name="ln553"> </a>
<a name="ln554">    return gindex;</a>
<a name="ln555">  }</a>
<a name="ln556"> </a>
<a name="ln557"> </a>
<a name="ln558">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln559">  tt_cmap2_get_info( TT_CMap       cmap,</a>
<a name="ln560">                     TT_CMapInfo  *cmap_info )</a>
<a name="ln561">  {</a>
<a name="ln562">    FT_Byte*  p = cmap-&gt;data + 4;</a>
<a name="ln563"> </a>
<a name="ln564"> </a>
<a name="ln565">    cmap_info-&gt;format   = 2;</a>
<a name="ln566">    cmap_info-&gt;language = (FT_ULong)TT_PEEK_USHORT( p );</a>
<a name="ln567"> </a>
<a name="ln568">    return FT_Err_Ok;</a>
<a name="ln569">  }</a>
<a name="ln570"> </a>
<a name="ln571"> </a>
<a name="ln572">  FT_DEFINE_TT_CMAP(</a>
<a name="ln573">    tt_cmap2_class_rec,</a>
<a name="ln574">    sizeof ( TT_CMapRec ),</a>
<a name="ln575"> </a>
<a name="ln576">    (FT_CMap_InitFunc)     tt_cmap_init,</a>
<a name="ln577">    (FT_CMap_DoneFunc)     NULL,</a>
<a name="ln578">    (FT_CMap_CharIndexFunc)tt_cmap2_char_index,</a>
<a name="ln579">    (FT_CMap_CharNextFunc) tt_cmap2_char_next,</a>
<a name="ln580"> </a>
<a name="ln581">    NULL,</a>
<a name="ln582">    NULL,</a>
<a name="ln583">    NULL,</a>
<a name="ln584">    NULL,</a>
<a name="ln585">    NULL,</a>
<a name="ln586"> </a>
<a name="ln587">    2,</a>
<a name="ln588">    (TT_CMap_ValidateFunc)tt_cmap2_validate,</a>
<a name="ln589">    (TT_CMap_Info_GetFunc)tt_cmap2_get_info )</a>
<a name="ln590"> </a>
<a name="ln591">#endif /* TT_CONFIG_CMAP_FORMAT_2 */</a>
<a name="ln592"> </a>
<a name="ln593"> </a>
<a name="ln594">  /*************************************************************************/</a>
<a name="ln595">  /*************************************************************************/</a>
<a name="ln596">  /*****                                                               *****/</a>
<a name="ln597">  /*****                           FORMAT 4                            *****/</a>
<a name="ln598">  /*****                                                               *****/</a>
<a name="ln599">  /*************************************************************************/</a>
<a name="ln600">  /*************************************************************************/</a>
<a name="ln601"> </a>
<a name="ln602">  /*************************************************************************/</a>
<a name="ln603">  /*                                                                       */</a>
<a name="ln604">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln605">  /* --------------                                                        */</a>
<a name="ln606">  /*                                                                       */</a>
<a name="ln607">  /*   NAME          OFFSET         TYPE              DESCRIPTION          */</a>
<a name="ln608">  /*                                                                       */</a>
<a name="ln609">  /*   format        0              USHORT            must be 4            */</a>
<a name="ln610">  /*   length        2              USHORT            table length         */</a>
<a name="ln611">  /*                                                  in bytes             */</a>
<a name="ln612">  /*   language      4              USHORT            Mac language code    */</a>
<a name="ln613">  /*                                                                       */</a>
<a name="ln614">  /*   segCountX2    6              USHORT            2*NUM_SEGS           */</a>
<a name="ln615">  /*   searchRange   8              USHORT            2*(1 &lt;&lt; LOG_SEGS)    */</a>
<a name="ln616">  /*   entrySelector 10             USHORT            LOG_SEGS             */</a>
<a name="ln617">  /*   rangeShift    12             USHORT            segCountX2 -         */</a>
<a name="ln618">  /*                                                    searchRange        */</a>
<a name="ln619">  /*                                                                       */</a>
<a name="ln620">  /*   endCount      14             USHORT[NUM_SEGS]  end charcode for     */</a>
<a name="ln621">  /*                                                  each segment; last   */</a>
<a name="ln622">  /*                                                  is 0xFFFF            */</a>
<a name="ln623">  /*                                                                       */</a>
<a name="ln624">  /*   pad           14+NUM_SEGS*2  USHORT            padding              */</a>
<a name="ln625">  /*                                                                       */</a>
<a name="ln626">  /*   startCount    16+NUM_SEGS*2  USHORT[NUM_SEGS]  first charcode for   */</a>
<a name="ln627">  /*                                                  each segment         */</a>
<a name="ln628">  /*                                                                       */</a>
<a name="ln629">  /*   idDelta       16+NUM_SEGS*4  SHORT[NUM_SEGS]   delta for each       */</a>
<a name="ln630">  /*                                                  segment              */</a>
<a name="ln631">  /*   idOffset      16+NUM_SEGS*6  SHORT[NUM_SEGS]   range offset for     */</a>
<a name="ln632">  /*                                                  each segment; can be */</a>
<a name="ln633">  /*                                                  zero                 */</a>
<a name="ln634">  /*                                                                       */</a>
<a name="ln635">  /*   glyphIds      16+NUM_SEGS*8  USHORT[]          array of glyph ID    */</a>
<a name="ln636">  /*                                                  ranges               */</a>
<a name="ln637">  /*                                                                       */</a>
<a name="ln638">  /* Character codes are modelled by a series of ordered (increasing)      */</a>
<a name="ln639">  /* intervals called segments.  Each segment has start and end codes,     */</a>
<a name="ln640">  /* provided by the `startCount' and `endCount' arrays.  Segments must    */</a>
<a name="ln641">  /* not overlap, and the last segment should always contain the value     */</a>
<a name="ln642">  /* 0xFFFF for `endCount'.                                                */</a>
<a name="ln643">  /*                                                                       */</a>
<a name="ln644">  /* The fields `searchRange', `entrySelector' and `rangeShift' are better */</a>
<a name="ln645">  /* ignored (they are traces of over-engineering in the TrueType          */</a>
<a name="ln646">  /* specification).                                                       */</a>
<a name="ln647">  /*                                                                       */</a>
<a name="ln648">  /* Each segment also has a signed `delta', as well as an optional offset */</a>
<a name="ln649">  /* within the `glyphIds' table.                                          */</a>
<a name="ln650">  /*                                                                       */</a>
<a name="ln651">  /* If a segment's idOffset is 0, the glyph index corresponding to any    */</a>
<a name="ln652">  /* charcode within the segment is obtained by adding the value of        */</a>
<a name="ln653">  /* `idDelta' directly to the charcode, modulo 65536.                     */</a>
<a name="ln654">  /*                                                                       */</a>
<a name="ln655">  /* Otherwise, a glyph index is taken from the glyph IDs sub-array for    */</a>
<a name="ln656">  /* the segment, and the value of `idDelta' is added to it.               */</a>
<a name="ln657">  /*                                                                       */</a>
<a name="ln658">  /*                                                                       */</a>
<a name="ln659">  /* Finally, note that a lot of fonts contain an invalid last segment,    */</a>
<a name="ln660">  /* where `start' and `end' are correctly set to 0xFFFF but both `delta'  */</a>
<a name="ln661">  /* and `offset' are incorrect (e.g., `opens___.ttf' which comes with     */</a>
<a name="ln662">  /* OpenOffice.org).  We need special code to deal with them correctly.   */</a>
<a name="ln663">  /*                                                                       */</a>
<a name="ln664"> </a>
<a name="ln665">#ifdef TT_CONFIG_CMAP_FORMAT_4</a>
<a name="ln666"> </a>
<a name="ln667">  typedef struct  TT_CMap4Rec_</a>
<a name="ln668">  {</a>
<a name="ln669">    TT_CMapRec  cmap;</a>
<a name="ln670">    FT_UInt32   cur_charcode;   /* current charcode */</a>
<a name="ln671">    FT_UInt     cur_gindex;     /* current glyph index */</a>
<a name="ln672"> </a>
<a name="ln673">    FT_UInt     num_ranges;</a>
<a name="ln674">    FT_UInt     cur_range;</a>
<a name="ln675">    FT_UInt     cur_start;</a>
<a name="ln676">    FT_UInt     cur_end;</a>
<a name="ln677">    FT_Int      cur_delta;</a>
<a name="ln678">    FT_Byte*    cur_values;</a>
<a name="ln679"> </a>
<a name="ln680">  } TT_CMap4Rec, *TT_CMap4;</a>
<a name="ln681"> </a>
<a name="ln682"> </a>
<a name="ln683">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln684">  tt_cmap4_init( TT_CMap4  cmap,</a>
<a name="ln685">                 FT_Byte*  table )</a>
<a name="ln686">  {</a>
<a name="ln687">    FT_Byte*  p;</a>
<a name="ln688"> </a>
<a name="ln689"> </a>
<a name="ln690">    cmap-&gt;cmap.data    = table;</a>
<a name="ln691"> </a>
<a name="ln692">    p                  = table + 6;</a>
<a name="ln693">    cmap-&gt;num_ranges   = FT_PEEK_USHORT( p ) &gt;&gt; 1;</a>
<a name="ln694">    cmap-&gt;cur_charcode = (FT_UInt32)0xFFFFFFFFUL;</a>
<a name="ln695">    cmap-&gt;cur_gindex   = 0;</a>
<a name="ln696"> </a>
<a name="ln697">    return FT_Err_Ok;</a>
<a name="ln698">  }</a>
<a name="ln699"> </a>
<a name="ln700"> </a>
<a name="ln701">  static FT_Int</a>
<a name="ln702">  tt_cmap4_set_range( TT_CMap4  cmap,</a>
<a name="ln703">                      FT_UInt   range_index )</a>
<a name="ln704">  {</a>
<a name="ln705">    FT_Byte*  table = cmap-&gt;cmap.data;</a>
<a name="ln706">    FT_Byte*  p;</a>
<a name="ln707">    FT_UInt   num_ranges = cmap-&gt;num_ranges;</a>
<a name="ln708"> </a>
<a name="ln709"> </a>
<a name="ln710">    while ( range_index &lt; num_ranges )</a>
<a name="ln711">    {</a>
<a name="ln712">      FT_UInt  offset;</a>
<a name="ln713"> </a>
<a name="ln714"> </a>
<a name="ln715">      p             = table + 14 + range_index * 2;</a>
<a name="ln716">      cmap-&gt;cur_end = FT_PEEK_USHORT( p );</a>
<a name="ln717"> </a>
<a name="ln718">      p              += 2 + num_ranges * 2;</a>
<a name="ln719">      cmap-&gt;cur_start = FT_PEEK_USHORT( p );</a>
<a name="ln720"> </a>
<a name="ln721">      p              += num_ranges * 2;</a>
<a name="ln722">      cmap-&gt;cur_delta = FT_PEEK_SHORT( p );</a>
<a name="ln723"> </a>
<a name="ln724">      p     += num_ranges * 2;</a>
<a name="ln725">      offset = FT_PEEK_USHORT( p );</a>
<a name="ln726"> </a>
<a name="ln727">      /* some fonts have an incorrect last segment; */</a>
<a name="ln728">      /* we have to catch it                        */</a>
<a name="ln729">      if ( range_index     &gt;= num_ranges - 1 &amp;&amp;</a>
<a name="ln730">           cmap-&gt;cur_start == 0xFFFFU        &amp;&amp;</a>
<a name="ln731">           cmap-&gt;cur_end   == 0xFFFFU        )</a>
<a name="ln732">      {</a>
<a name="ln733">        TT_Face   face  = (TT_Face)cmap-&gt;cmap.cmap.charmap.face;</a>
<a name="ln734">        FT_Byte*  limit = face-&gt;cmap_table + face-&gt;cmap_size;</a>
<a name="ln735"> </a>
<a name="ln736"> </a>
<a name="ln737">        if ( offset &amp;&amp; p + offset + 2 &gt; limit )</a>
<a name="ln738">        {</a>
<a name="ln739">          cmap-&gt;cur_delta = 1;</a>
<a name="ln740">          offset          = 0;</a>
<a name="ln741">        }</a>
<a name="ln742">      }</a>
<a name="ln743"> </a>
<a name="ln744">      if ( offset != 0xFFFFU )</a>
<a name="ln745">      {</a>
<a name="ln746">        cmap-&gt;cur_values = offset ? p + offset : NULL;</a>
<a name="ln747">        cmap-&gt;cur_range  = range_index;</a>
<a name="ln748">        return 0;</a>
<a name="ln749">      }</a>
<a name="ln750"> </a>
<a name="ln751">      /* we skip empty segments */</a>
<a name="ln752">      range_index++;</a>
<a name="ln753">    }</a>
<a name="ln754"> </a>
<a name="ln755">    return -1;</a>
<a name="ln756">  }</a>
<a name="ln757"> </a>
<a name="ln758"> </a>
<a name="ln759">  /* search the index of the charcode next to cmap-&gt;cur_charcode; */</a>
<a name="ln760">  /* caller should call tt_cmap4_set_range with proper range      */</a>
<a name="ln761">  /* before calling this function                                 */</a>
<a name="ln762">  /*                                                              */</a>
<a name="ln763">  static void</a>
<a name="ln764">  tt_cmap4_next( TT_CMap4  cmap )</a>
<a name="ln765">  {</a>
<a name="ln766">    FT_UInt  charcode;</a>
<a name="ln767"> </a>
<a name="ln768"> </a>
<a name="ln769">    if ( cmap-&gt;cur_charcode &gt;= 0xFFFFUL )</a>
<a name="ln770">      goto Fail;</a>
<a name="ln771"> </a>
<a name="ln772">    charcode = (FT_UInt)cmap-&gt;cur_charcode + 1;</a>
<a name="ln773"> </a>
<a name="ln774">    if ( charcode &lt; cmap-&gt;cur_start )</a>
<a name="ln775">      charcode = cmap-&gt;cur_start;</a>
<a name="ln776"> </a>
<a name="ln777">    for ( ;; )</a>
<a name="ln778">    {</a>
<a name="ln779">      FT_Byte*  values = cmap-&gt;cur_values;</a>
<a name="ln780">      FT_UInt   end    = cmap-&gt;cur_end;</a>
<a name="ln781">      FT_Int    delta  = cmap-&gt;cur_delta;</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784">      if ( charcode &lt;= end )</a>
<a name="ln785">      {</a>
<a name="ln786">        if ( values )</a>
<a name="ln787">        {</a>
<a name="ln788">          FT_Byte*  p = values + 2 * ( charcode - cmap-&gt;cur_start );</a>
<a name="ln789"> </a>
<a name="ln790"> </a>
<a name="ln791">          do</a>
<a name="ln792">          {</a>
<a name="ln793">            FT_UInt  gindex = FT_NEXT_USHORT( p );</a>
<a name="ln794"> </a>
<a name="ln795"> </a>
<a name="ln796">            if ( gindex != 0 )</a>
<a name="ln797">            {</a>
<a name="ln798">              gindex = (FT_UInt)( (FT_Int)gindex + delta ) &amp; 0xFFFFU;</a>
<a name="ln799">              if ( gindex != 0 )</a>
<a name="ln800">              {</a>
<a name="ln801">                cmap-&gt;cur_charcode = charcode;</a>
<a name="ln802">                cmap-&gt;cur_gindex   = gindex;</a>
<a name="ln803">                return;</a>
<a name="ln804">              }</a>
<a name="ln805">            }</a>
<a name="ln806">          } while ( ++charcode &lt;= end );</a>
<a name="ln807">        }</a>
<a name="ln808">        else</a>
<a name="ln809">        {</a>
<a name="ln810">          do</a>
<a name="ln811">          {</a>
<a name="ln812">            FT_UInt  gindex = (FT_UInt)( (FT_Int)charcode + delta ) &amp; 0xFFFFU;</a>
<a name="ln813"> </a>
<a name="ln814"> </a>
<a name="ln815">            if ( gindex != 0 )</a>
<a name="ln816">            {</a>
<a name="ln817">              cmap-&gt;cur_charcode = charcode;</a>
<a name="ln818">              cmap-&gt;cur_gindex   = gindex;</a>
<a name="ln819">              return;</a>
<a name="ln820">            }</a>
<a name="ln821">          } while ( ++charcode &lt;= end );</a>
<a name="ln822">        }</a>
<a name="ln823">      }</a>
<a name="ln824"> </a>
<a name="ln825">      /* we need to find another range */</a>
<a name="ln826">      if ( tt_cmap4_set_range( cmap, cmap-&gt;cur_range + 1 ) &lt; 0 )</a>
<a name="ln827">        break;</a>
<a name="ln828"> </a>
<a name="ln829">      if ( charcode &lt; cmap-&gt;cur_start )</a>
<a name="ln830">        charcode = cmap-&gt;cur_start;</a>
<a name="ln831">    }</a>
<a name="ln832"> </a>
<a name="ln833">  Fail:</a>
<a name="ln834">    cmap-&gt;cur_charcode = (FT_UInt32)0xFFFFFFFFUL;</a>
<a name="ln835">    cmap-&gt;cur_gindex   = 0;</a>
<a name="ln836">  }</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln840">  tt_cmap4_validate( FT_Byte*      table,</a>
<a name="ln841">                     FT_Validator  valid )</a>
<a name="ln842">  {</a>
<a name="ln843">    FT_Byte*  p;</a>
<a name="ln844">    FT_UInt   length;</a>
<a name="ln845"> </a>
<a name="ln846">    FT_Byte   *ends, *starts, *offsets, *deltas, *glyph_ids;</a>
<a name="ln847">    FT_UInt   num_segs;</a>
<a name="ln848">    FT_Error  error = FT_Err_Ok;</a>
<a name="ln849"> </a>
<a name="ln850"> </a>
<a name="ln851">    if ( table + 2 + 2 &gt; valid-&gt;limit )</a>
<a name="ln852">      FT_INVALID_TOO_SHORT;</a>
<a name="ln853"> </a>
<a name="ln854">    p      = table + 2;           /* skip format */</a>
<a name="ln855">    length = TT_NEXT_USHORT( p );</a>
<a name="ln856"> </a>
<a name="ln857">    /* in certain fonts, the `length' field is invalid and goes */</a>
<a name="ln858">    /* out of bound.  We try to correct this here...            */</a>
<a name="ln859">    if ( table + length &gt; valid-&gt;limit )</a>
<a name="ln860">    {</a>
<a name="ln861">      if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln862">        FT_INVALID_TOO_SHORT;</a>
<a name="ln863"> </a>
<a name="ln864">      length = (FT_UInt)( valid-&gt;limit - table );</a>
<a name="ln865">    }</a>
<a name="ln866"> </a>
<a name="ln867">    if ( length &lt; 16 )</a>
<a name="ln868">      FT_INVALID_TOO_SHORT;</a>
<a name="ln869"> </a>
<a name="ln870">    p        = table + 6;</a>
<a name="ln871">    num_segs = TT_NEXT_USHORT( p );   /* read segCountX2 */</a>
<a name="ln872"> </a>
<a name="ln873">    if ( valid-&gt;level &gt;= FT_VALIDATE_PARANOID )</a>
<a name="ln874">    {</a>
<a name="ln875">      /* check that we have an even value here */</a>
<a name="ln876">      if ( num_segs &amp; 1 )</a>
<a name="ln877">        FT_INVALID_DATA;</a>
<a name="ln878">    }</a>
<a name="ln879"> </a>
<a name="ln880">    num_segs /= 2;</a>
<a name="ln881"> </a>
<a name="ln882">    if ( length &lt; 16 + num_segs * 2 * 4 )</a>
<a name="ln883">      FT_INVALID_TOO_SHORT;</a>
<a name="ln884"> </a>
<a name="ln885">    /* check the search parameters - even though we never use them */</a>
<a name="ln886">    /*                                                             */</a>
<a name="ln887">    if ( valid-&gt;level &gt;= FT_VALIDATE_PARANOID )</a>
<a name="ln888">    {</a>
<a name="ln889">      /* check the values of `searchRange', `entrySelector', `rangeShift' */</a>
<a name="ln890">      FT_UInt  search_range   = TT_NEXT_USHORT( p );</a>
<a name="ln891">      FT_UInt  entry_selector = TT_NEXT_USHORT( p );</a>
<a name="ln892">      FT_UInt  range_shift    = TT_NEXT_USHORT( p );</a>
<a name="ln893"> </a>
<a name="ln894"> </a>
<a name="ln895">      if ( ( search_range | range_shift ) &amp; 1 )  /* must be even values */</a>
<a name="ln896">        FT_INVALID_DATA;</a>
<a name="ln897"> </a>
<a name="ln898">      search_range /= 2;</a>
<a name="ln899">      range_shift  /= 2;</a>
<a name="ln900"> </a>
<a name="ln901">      /* `search range' is the greatest power of 2 that is &lt;= num_segs */</a>
<a name="ln902"> </a>
<a name="ln903">      if ( search_range                &gt; num_segs                 ||</a>
<a name="ln904">           search_range * 2            &lt; num_segs                 ||</a>
<a name="ln905">           search_range + range_shift != num_segs                 ||</a>
<a name="ln906">           search_range               != ( 1U &lt;&lt; entry_selector ) )</a>
<a name="ln907">        FT_INVALID_DATA;</a>
<a name="ln908">    }</a>
<a name="ln909"> </a>
<a name="ln910">    ends      = table   + 14;</a>
<a name="ln911">    starts    = table   + 16 + num_segs * 2;</a>
<a name="ln912">    deltas    = starts  + num_segs * 2;</a>
<a name="ln913">    offsets   = deltas  + num_segs * 2;</a>
<a name="ln914">    glyph_ids = offsets + num_segs * 2;</a>
<a name="ln915"> </a>
<a name="ln916">    /* check last segment; its end count value must be 0xFFFF */</a>
<a name="ln917">    if ( valid-&gt;level &gt;= FT_VALIDATE_PARANOID )</a>
<a name="ln918">    {</a>
<a name="ln919">      p = ends + ( num_segs - 1 ) * 2;</a>
<a name="ln920">      if ( TT_PEEK_USHORT( p ) != 0xFFFFU )</a>
<a name="ln921">        FT_INVALID_DATA;</a>
<a name="ln922">    }</a>
<a name="ln923"> </a>
<a name="ln924">    {</a>
<a name="ln925">      FT_UInt   start, end, offset, n;</a>
<a name="ln926">      FT_UInt   last_start = 0, last_end = 0;</a>
<a name="ln927">      FT_Int    delta;</a>
<a name="ln928">      FT_Byte*  p_start   = starts;</a>
<a name="ln929">      FT_Byte*  p_end     = ends;</a>
<a name="ln930">      FT_Byte*  p_delta   = deltas;</a>
<a name="ln931">      FT_Byte*  p_offset  = offsets;</a>
<a name="ln932"> </a>
<a name="ln933"> </a>
<a name="ln934">      for ( n = 0; n &lt; num_segs; n++ )</a>
<a name="ln935">      {</a>
<a name="ln936">        p      = p_offset;</a>
<a name="ln937">        start  = TT_NEXT_USHORT( p_start );</a>
<a name="ln938">        end    = TT_NEXT_USHORT( p_end );</a>
<a name="ln939">        delta  = TT_NEXT_SHORT( p_delta );</a>
<a name="ln940">        offset = TT_NEXT_USHORT( p_offset );</a>
<a name="ln941"> </a>
<a name="ln942">        if ( start &gt; end )</a>
<a name="ln943">          FT_INVALID_DATA;</a>
<a name="ln944"> </a>
<a name="ln945">        /* this test should be performed at default validation level; */</a>
<a name="ln946">        /* unfortunately, some popular Asian fonts have overlapping   */</a>
<a name="ln947">        /* ranges in their charmaps                                   */</a>
<a name="ln948">        /*                                                            */</a>
<a name="ln949">        if ( start &lt;= last_end &amp;&amp; n &gt; 0 )</a>
<a name="ln950">        {</a>
<a name="ln951">          if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln952">            FT_INVALID_DATA;</a>
<a name="ln953">          else</a>
<a name="ln954">          {</a>
<a name="ln955">            /* allow overlapping segments, provided their start points */</a>
<a name="ln956">            /* and end points, respectively, are in ascending order    */</a>
<a name="ln957">            /*                                                         */</a>
<a name="ln958">            if ( last_start &gt; start || last_end &gt; end )</a>
<a name="ln959">              error |= TT_CMAP_FLAG_UNSORTED;</a>
<a name="ln960">            else</a>
<a name="ln961">              error |= TT_CMAP_FLAG_OVERLAPPING;</a>
<a name="ln962">          }</a>
<a name="ln963">        }</a>
<a name="ln964"> </a>
<a name="ln965">        if ( offset &amp;&amp; offset != 0xFFFFU )</a>
<a name="ln966">        {</a>
<a name="ln967">          p += offset;  /* start of glyph ID array */</a>
<a name="ln968"> </a>
<a name="ln969">          /* check that we point within the glyph IDs table only */</a>
<a name="ln970">          if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln971">          {</a>
<a name="ln972">            if ( p &lt; glyph_ids                                ||</a>
<a name="ln973">                 p + ( end - start + 1 ) * 2 &gt; table + length )</a>
<a name="ln974">              FT_INVALID_DATA;</a>
<a name="ln975">          }</a>
<a name="ln976">          /* Some fonts handle the last segment incorrectly.  In */</a>
<a name="ln977">          /* theory, 0xFFFF might point to an ordinary glyph --  */</a>
<a name="ln978">          /* a cmap 4 is versatile and could be used for any     */</a>
<a name="ln979">          /* encoding, not only Unicode.  However, reality shows */</a>
<a name="ln980">          /* that far too many fonts are sloppy and incorrectly  */</a>
<a name="ln981">          /* set all fields but `start' and `end' for the last   */</a>
<a name="ln982">          /* segment if it contains only a single character.     */</a>
<a name="ln983">          /*                                                     */</a>
<a name="ln984">          /* We thus omit the test here, delaying it to the      */</a>
<a name="ln985">          /* routines that actually access the cmap.             */</a>
<a name="ln986">          else if ( n != num_segs - 1                       ||</a>
<a name="ln987">                    !( start == 0xFFFFU &amp;&amp; end == 0xFFFFU ) )</a>
<a name="ln988">          {</a>
<a name="ln989">            if ( p &lt; glyph_ids                              ||</a>
<a name="ln990">                 p + ( end - start + 1 ) * 2 &gt; valid-&gt;limit )</a>
<a name="ln991">              FT_INVALID_DATA;</a>
<a name="ln992">          }</a>
<a name="ln993"> </a>
<a name="ln994">          /* check glyph indices within the segment range */</a>
<a name="ln995">          if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln996">          {</a>
<a name="ln997">            FT_UInt  i, idx;</a>
<a name="ln998"> </a>
<a name="ln999"> </a>
<a name="ln1000">            for ( i = start; i &lt; end; i++ )</a>
<a name="ln1001">            {</a>
<a name="ln1002">              idx = FT_NEXT_USHORT( p );</a>
<a name="ln1003">              if ( idx != 0 )</a>
<a name="ln1004">              {</a>
<a name="ln1005">                idx = (FT_UInt)( (FT_Int)idx + delta ) &amp; 0xFFFFU;</a>
<a name="ln1006"> </a>
<a name="ln1007">                if ( idx &gt;= TT_VALID_GLYPH_COUNT( valid ) )</a>
<a name="ln1008">                  FT_INVALID_GLYPH_ID;</a>
<a name="ln1009">              }</a>
<a name="ln1010">            }</a>
<a name="ln1011">          }</a>
<a name="ln1012">        }</a>
<a name="ln1013">        else if ( offset == 0xFFFFU )</a>
<a name="ln1014">        {</a>
<a name="ln1015">          /* some fonts (erroneously?) use a range offset of 0xFFFF */</a>
<a name="ln1016">          /* to mean missing glyph in cmap table                    */</a>
<a name="ln1017">          /*                                                        */</a>
<a name="ln1018">          if ( valid-&gt;level &gt;= FT_VALIDATE_PARANOID    ||</a>
<a name="ln1019">               n != num_segs - 1                       ||</a>
<a name="ln1020">               !( start == 0xFFFFU &amp;&amp; end == 0xFFFFU ) )</a>
<a name="ln1021">            FT_INVALID_DATA;</a>
<a name="ln1022">        }</a>
<a name="ln1023"> </a>
<a name="ln1024">        last_start = start;</a>
<a name="ln1025">        last_end   = end;</a>
<a name="ln1026">      }</a>
<a name="ln1027">    }</a>
<a name="ln1028"> </a>
<a name="ln1029">    return error;</a>
<a name="ln1030">  }</a>
<a name="ln1031"> </a>
<a name="ln1032"> </a>
<a name="ln1033">  static FT_UInt</a>
<a name="ln1034">  tt_cmap4_char_map_linear( TT_CMap     cmap,</a>
<a name="ln1035">                            FT_UInt32*  pcharcode,</a>
<a name="ln1036">                            FT_Bool     next )</a>
<a name="ln1037">  {</a>
<a name="ln1038">    TT_Face   face  = (TT_Face)cmap-&gt;cmap.charmap.face;</a>
<a name="ln1039">    FT_Byte*  limit = face-&gt;cmap_table + face-&gt;cmap_size;</a>
<a name="ln1040"> </a>
<a name="ln1041"> </a>
<a name="ln1042">    FT_UInt    num_segs2, start, end, offset;</a>
<a name="ln1043">    FT_Int     delta;</a>
<a name="ln1044">    FT_UInt    i, num_segs;</a>
<a name="ln1045">    FT_UInt32  charcode = *pcharcode;</a>
<a name="ln1046">    FT_UInt    gindex   = 0;</a>
<a name="ln1047">    FT_Byte*   p;</a>
<a name="ln1048">    FT_Byte*   q;</a>
<a name="ln1049"> </a>
<a name="ln1050"> </a>
<a name="ln1051">    p = cmap-&gt;data + 6;</a>
<a name="ln1052">    num_segs2 = FT_PAD_FLOOR( TT_PEEK_USHORT( p ), 2 );</a>
<a name="ln1053"> </a>
<a name="ln1054">    num_segs = num_segs2 &gt;&gt; 1;</a>
<a name="ln1055"> </a>
<a name="ln1056">    if ( !num_segs )</a>
<a name="ln1057">      return 0;</a>
<a name="ln1058"> </a>
<a name="ln1059">    if ( next )</a>
<a name="ln1060">      charcode++;</a>
<a name="ln1061"> </a>
<a name="ln1062">    if ( charcode &gt; 0xFFFFU )</a>
<a name="ln1063">      return 0;</a>
<a name="ln1064"> </a>
<a name="ln1065">    /* linear search */</a>
<a name="ln1066">    p = cmap-&gt;data + 14;               /* ends table   */</a>
<a name="ln1067">    q = cmap-&gt;data + 16 + num_segs2;   /* starts table */</a>
<a name="ln1068"> </a>
<a name="ln1069">    for ( i = 0; i &lt; num_segs; i++ )</a>
<a name="ln1070">    {</a>
<a name="ln1071">      end   = TT_NEXT_USHORT( p );</a>
<a name="ln1072">      start = TT_NEXT_USHORT( q );</a>
<a name="ln1073"> </a>
<a name="ln1074">      if ( charcode &lt; start )</a>
<a name="ln1075">      {</a>
<a name="ln1076">        if ( next )</a>
<a name="ln1077">          charcode = start;</a>
<a name="ln1078">        else</a>
<a name="ln1079">          break;</a>
<a name="ln1080">      }</a>
<a name="ln1081"> </a>
<a name="ln1082">    Again:</a>
<a name="ln1083">      if ( charcode &lt;= end )</a>
<a name="ln1084">      {</a>
<a name="ln1085">        FT_Byte*  r;</a>
<a name="ln1086"> </a>
<a name="ln1087"> </a>
<a name="ln1088">        r       = q - 2 + num_segs2;</a>
<a name="ln1089">        delta   = TT_PEEK_SHORT( r );</a>
<a name="ln1090">        r      += num_segs2;</a>
<a name="ln1091">        offset  = TT_PEEK_USHORT( r );</a>
<a name="ln1092"> </a>
<a name="ln1093">        /* some fonts have an incorrect last segment; */</a>
<a name="ln1094">        /* we have to catch it                        */</a>
<a name="ln1095">        if ( i &gt;= num_segs - 1                  &amp;&amp;</a>
<a name="ln1096">             start == 0xFFFFU &amp;&amp; end == 0xFFFFU )</a>
<a name="ln1097">        {</a>
<a name="ln1098">          if ( offset &amp;&amp; r + offset + 2 &gt; limit )</a>
<a name="ln1099">          {</a>
<a name="ln1100">            delta  = 1;</a>
<a name="ln1101">            offset = 0;</a>
<a name="ln1102">          }</a>
<a name="ln1103">        }</a>
<a name="ln1104"> </a>
<a name="ln1105">        if ( offset == 0xFFFFU )</a>
<a name="ln1106">          continue;</a>
<a name="ln1107"> </a>
<a name="ln1108">        if ( offset )</a>
<a name="ln1109">        {</a>
<a name="ln1110">          r += offset + ( charcode - start ) * 2;</a>
<a name="ln1111"> </a>
<a name="ln1112">          /* if r &gt; limit, the whole segment is invalid */</a>
<a name="ln1113">          if ( next &amp;&amp; r &gt; limit )</a>
<a name="ln1114">            continue;</a>
<a name="ln1115"> </a>
<a name="ln1116">          gindex = TT_PEEK_USHORT( r );</a>
<a name="ln1117">          if ( gindex )</a>
<a name="ln1118">          {</a>
<a name="ln1119">            gindex = (FT_UInt)( (FT_Int)gindex + delta ) &amp; 0xFFFFU;</a>
<a name="ln1120">            if ( gindex &gt;= (FT_UInt)face-&gt;root.num_glyphs )</a>
<a name="ln1121">              gindex = 0;</a>
<a name="ln1122">          }</a>
<a name="ln1123">        }</a>
<a name="ln1124">        else</a>
<a name="ln1125">        {</a>
<a name="ln1126">          gindex = (FT_UInt)( (FT_Int)charcode + delta ) &amp; 0xFFFFU;</a>
<a name="ln1127"> </a>
<a name="ln1128">          if ( next &amp;&amp; gindex &gt;= (FT_UInt)face-&gt;root.num_glyphs )</a>
<a name="ln1129">          {</a>
<a name="ln1130">            /* we have an invalid glyph index; if there is an overflow, */</a>
<a name="ln1131">            /* we can adjust `charcode', otherwise the whole segment is */</a>
<a name="ln1132">            /* invalid                                                  */</a>
<a name="ln1133">            gindex = 0;</a>
<a name="ln1134"> </a>
<a name="ln1135">            if ( (FT_Int)charcode + delta &lt; 0 &amp;&amp;</a>
<a name="ln1136">                 (FT_Int)end + delta &gt;= 0     )</a>
<a name="ln1137">              charcode = (FT_UInt)( -delta );</a>
<a name="ln1138"> </a>
<a name="ln1139">            else if ( (FT_Int)charcode + delta &lt; 0x10000L &amp;&amp;</a>
<a name="ln1140">                      (FT_Int)end + delta &gt;= 0x10000L     )</a>
<a name="ln1141">              charcode = (FT_UInt)( 0x10000L - delta );</a>
<a name="ln1142"> </a>
<a name="ln1143">            else</a>
<a name="ln1144">              continue;</a>
<a name="ln1145">          }</a>
<a name="ln1146">        }</a>
<a name="ln1147"> </a>
<a name="ln1148">        if ( next &amp;&amp; !gindex )</a>
<a name="ln1149">        {</a>
<a name="ln1150">          if ( charcode &gt;= 0xFFFFU )</a>
<a name="ln1151">            break;</a>
<a name="ln1152"> </a>
<a name="ln1153">          charcode++;</a>
<a name="ln1154">          goto Again;</a>
<a name="ln1155">        }</a>
<a name="ln1156"> </a>
<a name="ln1157">        break;</a>
<a name="ln1158">      }</a>
<a name="ln1159">    }</a>
<a name="ln1160"> </a>
<a name="ln1161">    if ( next )</a>
<a name="ln1162">      *pcharcode = charcode;</a>
<a name="ln1163"> </a>
<a name="ln1164">    return gindex;</a>
<a name="ln1165">  }</a>
<a name="ln1166"> </a>
<a name="ln1167"> </a>
<a name="ln1168">  static FT_UInt</a>
<a name="ln1169">  tt_cmap4_char_map_binary( TT_CMap     cmap,</a>
<a name="ln1170">                            FT_UInt32*  pcharcode,</a>
<a name="ln1171">                            FT_Bool     next )</a>
<a name="ln1172">  {</a>
<a name="ln1173">    FT_UInt   num_segs2, start, end, offset;</a>
<a name="ln1174">    FT_Int    delta;</a>
<a name="ln1175">    FT_UInt   max, min, mid, num_segs;</a>
<a name="ln1176">    FT_UInt   charcode = (FT_UInt)*pcharcode;</a>
<a name="ln1177">    FT_UInt   gindex   = 0;</a>
<a name="ln1178">    FT_Byte*  p;</a>
<a name="ln1179"> </a>
<a name="ln1180"> </a>
<a name="ln1181">    p = cmap-&gt;data + 6;</a>
<a name="ln1182">    num_segs2 = FT_PAD_FLOOR( TT_PEEK_USHORT( p ), 2 );</a>
<a name="ln1183"> </a>
<a name="ln1184">    if ( !num_segs2 )</a>
<a name="ln1185">      return 0;</a>
<a name="ln1186"> </a>
<a name="ln1187">    num_segs = num_segs2 &gt;&gt; 1;</a>
<a name="ln1188"> </a>
<a name="ln1189">    /* make compiler happy */</a>
<a name="ln1190">    mid = num_segs;</a>
<a name="ln1191">    end = 0xFFFFU;</a>
<a name="ln1192"> </a>
<a name="ln1193">    if ( next )</a>
<a name="ln1194">      charcode++;</a>
<a name="ln1195"> </a>
<a name="ln1196">    min = 0;</a>
<a name="ln1197">    max = num_segs;</a>
<a name="ln1198"> </a>
<a name="ln1199">    /* binary search */</a>
<a name="ln1200">    while ( min &lt; max )</a>
<a name="ln1201">    {</a>
<a name="ln1202">      mid    = ( min + max ) &gt;&gt; 1;</a>
<a name="ln1203">      p      = cmap-&gt;data + 14 + mid * 2;</a>
<a name="ln1204">      end    = TT_PEEK_USHORT( p );</a>
<a name="ln1205">      p     += 2 + num_segs2;</a>
<a name="ln1206">      start  = TT_PEEK_USHORT( p );</a>
<a name="ln1207"> </a>
<a name="ln1208">      if ( charcode &lt; start )</a>
<a name="ln1209">        max = mid;</a>
<a name="ln1210">      else if ( charcode &gt; end )</a>
<a name="ln1211">        min = mid + 1;</a>
<a name="ln1212">      else</a>
<a name="ln1213">      {</a>
<a name="ln1214">        p     += num_segs2;</a>
<a name="ln1215">        delta  = TT_PEEK_SHORT( p );</a>
<a name="ln1216">        p     += num_segs2;</a>
<a name="ln1217">        offset = TT_PEEK_USHORT( p );</a>
<a name="ln1218"> </a>
<a name="ln1219">        /* some fonts have an incorrect last segment; */</a>
<a name="ln1220">        /* we have to catch it                        */</a>
<a name="ln1221">        if ( mid &gt;= num_segs - 1                &amp;&amp;</a>
<a name="ln1222">             start == 0xFFFFU &amp;&amp; end == 0xFFFFU )</a>
<a name="ln1223">        {</a>
<a name="ln1224">          TT_Face   face  = (TT_Face)cmap-&gt;cmap.charmap.face;</a>
<a name="ln1225">          FT_Byte*  limit = face-&gt;cmap_table + face-&gt;cmap_size;</a>
<a name="ln1226"> </a>
<a name="ln1227"> </a>
<a name="ln1228">          if ( offset &amp;&amp; p + offset + 2 &gt; limit )</a>
<a name="ln1229">          {</a>
<a name="ln1230">            delta  = 1;</a>
<a name="ln1231">            offset = 0;</a>
<a name="ln1232">          }</a>
<a name="ln1233">        }</a>
<a name="ln1234"> </a>
<a name="ln1235">        /* search the first segment containing `charcode' */</a>
<a name="ln1236">        if ( cmap-&gt;flags &amp; TT_CMAP_FLAG_OVERLAPPING )</a>
<a name="ln1237">        {</a>
<a name="ln1238">          FT_UInt  i;</a>
<a name="ln1239"> </a>
<a name="ln1240"> </a>
<a name="ln1241">          /* call the current segment `max' */</a>
<a name="ln1242">          max = mid;</a>
<a name="ln1243"> </a>
<a name="ln1244">          if ( offset == 0xFFFFU )</a>
<a name="ln1245">            mid = max + 1;</a>
<a name="ln1246"> </a>
<a name="ln1247">          /* search in segments before the current segment */</a>
<a name="ln1248">          for ( i = max ; i &gt; 0; i-- )</a>
<a name="ln1249">          {</a>
<a name="ln1250">            FT_UInt   prev_end;</a>
<a name="ln1251">            FT_Byte*  old_p;</a>
<a name="ln1252"> </a>
<a name="ln1253"> </a>
<a name="ln1254">            old_p    = p;</a>
<a name="ln1255">            p        = cmap-&gt;data + 14 + ( i - 1 ) * 2;</a>
<a name="ln1256">            prev_end = TT_PEEK_USHORT( p );</a>
<a name="ln1257"> </a>
<a name="ln1258">            if ( charcode &gt; prev_end )</a>
<a name="ln1259">            {</a>
<a name="ln1260">              p = old_p;</a>
<a name="ln1261">              break;</a>
<a name="ln1262">            }</a>
<a name="ln1263"> </a>
<a name="ln1264">            end    = prev_end;</a>
<a name="ln1265">            p     += 2 + num_segs2;</a>
<a name="ln1266">            start  = TT_PEEK_USHORT( p );</a>
<a name="ln1267">            p     += num_segs2;</a>
<a name="ln1268">            delta  = TT_PEEK_SHORT( p );</a>
<a name="ln1269">            p     += num_segs2;</a>
<a name="ln1270">            offset = TT_PEEK_USHORT( p );</a>
<a name="ln1271"> </a>
<a name="ln1272">            if ( offset != 0xFFFFU )</a>
<a name="ln1273">              mid = i - 1;</a>
<a name="ln1274">          }</a>
<a name="ln1275"> </a>
<a name="ln1276">          /* no luck */</a>
<a name="ln1277">          if ( mid == max + 1 )</a>
<a name="ln1278">          {</a>
<a name="ln1279">            if ( i != max )</a>
<a name="ln1280">            {</a>
<a name="ln1281">              p      = cmap-&gt;data + 14 + max * 2;</a>
<a name="ln1282">              end    = TT_PEEK_USHORT( p );</a>
<a name="ln1283">              p     += 2 + num_segs2;</a>
<a name="ln1284">              start  = TT_PEEK_USHORT( p );</a>
<a name="ln1285">              p     += num_segs2;</a>
<a name="ln1286">              delta  = TT_PEEK_SHORT( p );</a>
<a name="ln1287">              p     += num_segs2;</a>
<a name="ln1288">              offset = TT_PEEK_USHORT( p );</a>
<a name="ln1289">            }</a>
<a name="ln1290"> </a>
<a name="ln1291">            mid = max;</a>
<a name="ln1292"> </a>
<a name="ln1293">            /* search in segments after the current segment */</a>
<a name="ln1294">            for ( i = max + 1; i &lt; num_segs; i++ )</a>
<a name="ln1295">            {</a>
<a name="ln1296">              FT_UInt  next_end, next_start;</a>
<a name="ln1297"> </a>
<a name="ln1298"> </a>
<a name="ln1299">              p          = cmap-&gt;data + 14 + i * 2;</a>
<a name="ln1300">              next_end   = TT_PEEK_USHORT( p );</a>
<a name="ln1301">              p         += 2 + num_segs2;</a>
<a name="ln1302">              next_start = TT_PEEK_USHORT( p );</a>
<a name="ln1303"> </a>
<a name="ln1304">              if ( charcode &lt; next_start )</a>
<a name="ln1305">                break;</a>
<a name="ln1306"> </a>
<a name="ln1307">              end    = next_end;</a>
<a name="ln1308">              start  = next_start;</a>
<a name="ln1309">              p     += num_segs2;</a>
<a name="ln1310">              delta  = TT_PEEK_SHORT( p );</a>
<a name="ln1311">              p     += num_segs2;</a>
<a name="ln1312">              offset = TT_PEEK_USHORT( p );</a>
<a name="ln1313"> </a>
<a name="ln1314">              if ( offset != 0xFFFFU )</a>
<a name="ln1315">                mid = i;</a>
<a name="ln1316">            }</a>
<a name="ln1317">            i--;</a>
<a name="ln1318"> </a>
<a name="ln1319">            /* still no luck */</a>
<a name="ln1320">            if ( mid == max )</a>
<a name="ln1321">            {</a>
<a name="ln1322">              mid = i;</a>
<a name="ln1323"> </a>
<a name="ln1324">              break;</a>
<a name="ln1325">            }</a>
<a name="ln1326">          }</a>
<a name="ln1327"> </a>
<a name="ln1328">          /* end, start, delta, and offset are for the i'th segment */</a>
<a name="ln1329">          if ( mid != i )</a>
<a name="ln1330">          {</a>
<a name="ln1331">            p      = cmap-&gt;data + 14 + mid * 2;</a>
<a name="ln1332">            end    = TT_PEEK_USHORT( p );</a>
<a name="ln1333">            p     += 2 + num_segs2;</a>
<a name="ln1334">            start  = TT_PEEK_USHORT( p );</a>
<a name="ln1335">            p     += num_segs2;</a>
<a name="ln1336">            delta  = TT_PEEK_SHORT( p );</a>
<a name="ln1337">            p     += num_segs2;</a>
<a name="ln1338">            offset = TT_PEEK_USHORT( p );</a>
<a name="ln1339">          }</a>
<a name="ln1340">        }</a>
<a name="ln1341">        else</a>
<a name="ln1342">        {</a>
<a name="ln1343">          if ( offset == 0xFFFFU )</a>
<a name="ln1344">            break;</a>
<a name="ln1345">        }</a>
<a name="ln1346"> </a>
<a name="ln1347">        if ( offset )</a>
<a name="ln1348">        {</a>
<a name="ln1349">          p += offset + ( charcode - start ) * 2;</a>
<a name="ln1350">          gindex = TT_PEEK_USHORT( p );</a>
<a name="ln1351">          if ( gindex != 0 )</a>
<a name="ln1352">            gindex = (FT_UInt)( (FT_Int)gindex + delta ) &amp; 0xFFFFU;</a>
<a name="ln1353">        }</a>
<a name="ln1354">        else</a>
<a name="ln1355">          gindex = (FT_UInt)( (FT_Int)charcode + delta ) &amp; 0xFFFFU;</a>
<a name="ln1356"> </a>
<a name="ln1357">        break;</a>
<a name="ln1358">      }</a>
<a name="ln1359">    }</a>
<a name="ln1360"> </a>
<a name="ln1361">    if ( next )</a>
<a name="ln1362">    {</a>
<a name="ln1363">      TT_CMap4  cmap4 = (TT_CMap4)cmap;</a>
<a name="ln1364"> </a>
<a name="ln1365"> </a>
<a name="ln1366">      /* if `charcode' is not in any segment, then `mid' is */</a>
<a name="ln1367">      /* the segment nearest to `charcode'                  */</a>
<a name="ln1368"> </a>
<a name="ln1369">      if ( charcode &gt; end )</a>
<a name="ln1370">      {</a>
<a name="ln1371">        mid++;</a>
<a name="ln1372">        if ( mid == num_segs )</a>
<a name="ln1373">          return 0;</a>
<a name="ln1374">      }</a>
<a name="ln1375"> </a>
<a name="ln1376">      if ( tt_cmap4_set_range( cmap4, mid ) )</a>
<a name="ln1377">      {</a>
<a name="ln1378">        if ( gindex )</a>
<a name="ln1379">          *pcharcode = charcode;</a>
<a name="ln1380">      }</a>
<a name="ln1381">      else</a>
<a name="ln1382">      {</a>
<a name="ln1383">        cmap4-&gt;cur_charcode = charcode;</a>
<a name="ln1384"> </a>
<a name="ln1385">        if ( gindex )</a>
<a name="ln1386">          cmap4-&gt;cur_gindex = gindex;</a>
<a name="ln1387">        else</a>
<a name="ln1388">        {</a>
<a name="ln1389">          cmap4-&gt;cur_charcode = charcode;</a>
<a name="ln1390">          tt_cmap4_next( cmap4 );</a>
<a name="ln1391">          gindex = cmap4-&gt;cur_gindex;</a>
<a name="ln1392">        }</a>
<a name="ln1393"> </a>
<a name="ln1394">        if ( gindex )</a>
<a name="ln1395">          *pcharcode = cmap4-&gt;cur_charcode;</a>
<a name="ln1396">      }</a>
<a name="ln1397">    }</a>
<a name="ln1398"> </a>
<a name="ln1399">    return gindex;</a>
<a name="ln1400">  }</a>
<a name="ln1401"> </a>
<a name="ln1402"> </a>
<a name="ln1403">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln1404">  tt_cmap4_char_index( TT_CMap    cmap,</a>
<a name="ln1405">                       FT_UInt32  char_code )</a>
<a name="ln1406">  {</a>
<a name="ln1407">    if ( char_code &gt;= 0x10000UL )</a>
<a name="ln1408">      return 0;</a>
<a name="ln1409"> </a>
<a name="ln1410">    if ( cmap-&gt;flags &amp; TT_CMAP_FLAG_UNSORTED )</a>
<a name="ln1411">      return tt_cmap4_char_map_linear( cmap, &amp;char_code, 0 );</a>
<a name="ln1412">    else</a>
<a name="ln1413">      return tt_cmap4_char_map_binary( cmap, &amp;char_code, 0 );</a>
<a name="ln1414">  }</a>
<a name="ln1415"> </a>
<a name="ln1416"> </a>
<a name="ln1417">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln1418">  tt_cmap4_char_next( TT_CMap     cmap,</a>
<a name="ln1419">                      FT_UInt32  *pchar_code )</a>
<a name="ln1420">  {</a>
<a name="ln1421">    FT_UInt  gindex;</a>
<a name="ln1422"> </a>
<a name="ln1423"> </a>
<a name="ln1424">    if ( *pchar_code &gt;= 0xFFFFU )</a>
<a name="ln1425">      return 0;</a>
<a name="ln1426"> </a>
<a name="ln1427">    if ( cmap-&gt;flags &amp; TT_CMAP_FLAG_UNSORTED )</a>
<a name="ln1428">      gindex = tt_cmap4_char_map_linear( cmap, pchar_code, 1 );</a>
<a name="ln1429">    else</a>
<a name="ln1430">    {</a>
<a name="ln1431">      TT_CMap4  cmap4 = (TT_CMap4)cmap;</a>
<a name="ln1432"> </a>
<a name="ln1433"> </a>
<a name="ln1434">      /* no need to search */</a>
<a name="ln1435">      if ( *pchar_code == cmap4-&gt;cur_charcode )</a>
<a name="ln1436">      {</a>
<a name="ln1437">        tt_cmap4_next( cmap4 );</a>
<a name="ln1438">        gindex = cmap4-&gt;cur_gindex;</a>
<a name="ln1439">        if ( gindex )</a>
<a name="ln1440">          *pchar_code = cmap4-&gt;cur_charcode;</a>
<a name="ln1441">      }</a>
<a name="ln1442">      else</a>
<a name="ln1443">        gindex = tt_cmap4_char_map_binary( cmap, pchar_code, 1 );</a>
<a name="ln1444">    }</a>
<a name="ln1445"> </a>
<a name="ln1446">    return gindex;</a>
<a name="ln1447">  }</a>
<a name="ln1448"> </a>
<a name="ln1449"> </a>
<a name="ln1450">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln1451">  tt_cmap4_get_info( TT_CMap       cmap,</a>
<a name="ln1452">                     TT_CMapInfo  *cmap_info )</a>
<a name="ln1453">  {</a>
<a name="ln1454">    FT_Byte*  p = cmap-&gt;data + 4;</a>
<a name="ln1455"> </a>
<a name="ln1456"> </a>
<a name="ln1457">    cmap_info-&gt;format   = 4;</a>
<a name="ln1458">    cmap_info-&gt;language = (FT_ULong)TT_PEEK_USHORT( p );</a>
<a name="ln1459"> </a>
<a name="ln1460">    return FT_Err_Ok;</a>
<a name="ln1461">  }</a>
<a name="ln1462"> </a>
<a name="ln1463"> </a>
<a name="ln1464">  FT_DEFINE_TT_CMAP(</a>
<a name="ln1465">    tt_cmap4_class_rec,</a>
<a name="ln1466">    sizeof ( TT_CMap4Rec ),</a>
<a name="ln1467">    (FT_CMap_InitFunc)     tt_cmap4_init,</a>
<a name="ln1468">    (FT_CMap_DoneFunc)     NULL,</a>
<a name="ln1469">    (FT_CMap_CharIndexFunc)tt_cmap4_char_index,</a>
<a name="ln1470">    (FT_CMap_CharNextFunc) tt_cmap4_char_next,</a>
<a name="ln1471"> </a>
<a name="ln1472">    NULL,</a>
<a name="ln1473">    NULL,</a>
<a name="ln1474">    NULL,</a>
<a name="ln1475">    NULL,</a>
<a name="ln1476">    NULL,</a>
<a name="ln1477"> </a>
<a name="ln1478">    4,</a>
<a name="ln1479">    (TT_CMap_ValidateFunc)tt_cmap4_validate,</a>
<a name="ln1480">    (TT_CMap_Info_GetFunc)tt_cmap4_get_info )</a>
<a name="ln1481"> </a>
<a name="ln1482">#endif /* TT_CONFIG_CMAP_FORMAT_4 */</a>
<a name="ln1483"> </a>
<a name="ln1484"> </a>
<a name="ln1485">  /*************************************************************************/</a>
<a name="ln1486">  /*************************************************************************/</a>
<a name="ln1487">  /*****                                                               *****/</a>
<a name="ln1488">  /*****                          FORMAT 6                             *****/</a>
<a name="ln1489">  /*****                                                               *****/</a>
<a name="ln1490">  /*************************************************************************/</a>
<a name="ln1491">  /*************************************************************************/</a>
<a name="ln1492"> </a>
<a name="ln1493">  /*************************************************************************/</a>
<a name="ln1494">  /*                                                                       */</a>
<a name="ln1495">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln1496">  /* --------------                                                        */</a>
<a name="ln1497">  /*                                                                       */</a>
<a name="ln1498">  /*   NAME        OFFSET          TYPE             DESCRIPTION            */</a>
<a name="ln1499">  /*                                                                       */</a>
<a name="ln1500">  /*   format       0              USHORT           must be 6              */</a>
<a name="ln1501">  /*   length       2              USHORT           table length in bytes  */</a>
<a name="ln1502">  /*   language     4              USHORT           Mac language code      */</a>
<a name="ln1503">  /*                                                                       */</a>
<a name="ln1504">  /*   first        6              USHORT           first segment code     */</a>
<a name="ln1505">  /*   count        8              USHORT           segment size in chars  */</a>
<a name="ln1506">  /*   glyphIds     10             USHORT[count]    glyph IDs              */</a>
<a name="ln1507">  /*                                                                       */</a>
<a name="ln1508">  /* A very simplified segment mapping.                                    */</a>
<a name="ln1509">  /*                                                                       */</a>
<a name="ln1510"> </a>
<a name="ln1511">#ifdef TT_CONFIG_CMAP_FORMAT_6</a>
<a name="ln1512"> </a>
<a name="ln1513">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln1514">  tt_cmap6_validate( FT_Byte*      table,</a>
<a name="ln1515">                     FT_Validator  valid )</a>
<a name="ln1516">  {</a>
<a name="ln1517">    FT_Byte*  p;</a>
<a name="ln1518">    FT_UInt   length, count;</a>
<a name="ln1519"> </a>
<a name="ln1520"> </a>
<a name="ln1521">    if ( table + 10 &gt; valid-&gt;limit )</a>
<a name="ln1522">      FT_INVALID_TOO_SHORT;</a>
<a name="ln1523"> </a>
<a name="ln1524">    p      = table + 2;</a>
<a name="ln1525">    length = TT_NEXT_USHORT( p );</a>
<a name="ln1526"> </a>
<a name="ln1527">    p      = table + 8;             /* skip language and start index */</a>
<a name="ln1528">    count  = TT_NEXT_USHORT( p );</a>
<a name="ln1529"> </a>
<a name="ln1530">    if ( table + length &gt; valid-&gt;limit || length &lt; 10 + count * 2 )</a>
<a name="ln1531">      FT_INVALID_TOO_SHORT;</a>
<a name="ln1532"> </a>
<a name="ln1533">    /* check glyph indices */</a>
<a name="ln1534">    if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln1535">    {</a>
<a name="ln1536">      FT_UInt  gindex;</a>
<a name="ln1537"> </a>
<a name="ln1538"> </a>
<a name="ln1539">      for ( ; count &gt; 0; count-- )</a>
<a name="ln1540">      {</a>
<a name="ln1541">        gindex = TT_NEXT_USHORT( p );</a>
<a name="ln1542">        if ( gindex &gt;= TT_VALID_GLYPH_COUNT( valid ) )</a>
<a name="ln1543">          FT_INVALID_GLYPH_ID;</a>
<a name="ln1544">      }</a>
<a name="ln1545">    }</a>
<a name="ln1546"> </a>
<a name="ln1547">    return FT_Err_Ok;</a>
<a name="ln1548">  }</a>
<a name="ln1549"> </a>
<a name="ln1550"> </a>
<a name="ln1551">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln1552">  tt_cmap6_char_index( TT_CMap    cmap,</a>
<a name="ln1553">                       FT_UInt32  char_code )</a>
<a name="ln1554">  {</a>
<a name="ln1555">    FT_Byte*  table  = cmap-&gt;data;</a>
<a name="ln1556">    FT_UInt   result = 0;</a>
<a name="ln1557">    FT_Byte*  p      = table + 6;</a>
<a name="ln1558">    FT_UInt   start  = TT_NEXT_USHORT( p );</a>
<a name="ln1559">    FT_UInt   count  = TT_NEXT_USHORT( p );</a>
<a name="ln1560">    FT_UInt   idx    = (FT_UInt)( char_code - start );</a>
<a name="ln1561"> </a>
<a name="ln1562"> </a>
<a name="ln1563">    if ( idx &lt; count )</a>
<a name="ln1564">    {</a>
<a name="ln1565">      p += 2 * idx;</a>
<a name="ln1566">      result = TT_PEEK_USHORT( p );</a>
<a name="ln1567">    }</a>
<a name="ln1568"> </a>
<a name="ln1569">    return result;</a>
<a name="ln1570">  }</a>
<a name="ln1571"> </a>
<a name="ln1572"> </a>
<a name="ln1573">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln1574">  tt_cmap6_char_next( TT_CMap     cmap,</a>
<a name="ln1575">                      FT_UInt32  *pchar_code )</a>
<a name="ln1576">  {</a>
<a name="ln1577">    FT_Byte*   table     = cmap-&gt;data;</a>
<a name="ln1578">    FT_UInt32  result    = 0;</a>
<a name="ln1579">    FT_UInt32  char_code = *pchar_code + 1;</a>
<a name="ln1580">    FT_UInt    gindex    = 0;</a>
<a name="ln1581"> </a>
<a name="ln1582">    FT_Byte*   p         = table + 6;</a>
<a name="ln1583">    FT_UInt    start     = TT_NEXT_USHORT( p );</a>
<a name="ln1584">    FT_UInt    count     = TT_NEXT_USHORT( p );</a>
<a name="ln1585">    FT_UInt    idx;</a>
<a name="ln1586"> </a>
<a name="ln1587"> </a>
<a name="ln1588">    if ( char_code &gt;= 0x10000UL )</a>
<a name="ln1589">      return 0;</a>
<a name="ln1590"> </a>
<a name="ln1591">    if ( char_code &lt; start )</a>
<a name="ln1592">      char_code = start;</a>
<a name="ln1593"> </a>
<a name="ln1594">    idx = (FT_UInt)( char_code - start );</a>
<a name="ln1595">    p  += 2 * idx;</a>
<a name="ln1596"> </a>
<a name="ln1597">    for ( ; idx &lt; count; idx++ )</a>
<a name="ln1598">    {</a>
<a name="ln1599">      gindex = TT_NEXT_USHORT( p );</a>
<a name="ln1600">      if ( gindex != 0 )</a>
<a name="ln1601">      {</a>
<a name="ln1602">        result = char_code;</a>
<a name="ln1603">        break;</a>
<a name="ln1604">      }</a>
<a name="ln1605"> </a>
<a name="ln1606">      if ( char_code &gt;= 0xFFFFU )</a>
<a name="ln1607">        return 0;</a>
<a name="ln1608"> </a>
<a name="ln1609">      char_code++;</a>
<a name="ln1610">    }</a>
<a name="ln1611"> </a>
<a name="ln1612">    *pchar_code = result;</a>
<a name="ln1613">    return gindex;</a>
<a name="ln1614">  }</a>
<a name="ln1615"> </a>
<a name="ln1616"> </a>
<a name="ln1617">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln1618">  tt_cmap6_get_info( TT_CMap       cmap,</a>
<a name="ln1619">                     TT_CMapInfo  *cmap_info )</a>
<a name="ln1620">  {</a>
<a name="ln1621">    FT_Byte*  p = cmap-&gt;data + 4;</a>
<a name="ln1622"> </a>
<a name="ln1623"> </a>
<a name="ln1624">    cmap_info-&gt;format   = 6;</a>
<a name="ln1625">    cmap_info-&gt;language = (FT_ULong)TT_PEEK_USHORT( p );</a>
<a name="ln1626"> </a>
<a name="ln1627">    return FT_Err_Ok;</a>
<a name="ln1628">  }</a>
<a name="ln1629"> </a>
<a name="ln1630"> </a>
<a name="ln1631">  FT_DEFINE_TT_CMAP(</a>
<a name="ln1632">    tt_cmap6_class_rec,</a>
<a name="ln1633">    sizeof ( TT_CMapRec ),</a>
<a name="ln1634"> </a>
<a name="ln1635">    (FT_CMap_InitFunc)     tt_cmap_init,</a>
<a name="ln1636">    (FT_CMap_DoneFunc)     NULL,</a>
<a name="ln1637">    (FT_CMap_CharIndexFunc)tt_cmap6_char_index,</a>
<a name="ln1638">    (FT_CMap_CharNextFunc) tt_cmap6_char_next,</a>
<a name="ln1639"> </a>
<a name="ln1640">    NULL,</a>
<a name="ln1641">    NULL,</a>
<a name="ln1642">    NULL,</a>
<a name="ln1643">    NULL,</a>
<a name="ln1644">    NULL,</a>
<a name="ln1645"> </a>
<a name="ln1646">    6,</a>
<a name="ln1647">    (TT_CMap_ValidateFunc)tt_cmap6_validate,</a>
<a name="ln1648">    (TT_CMap_Info_GetFunc)tt_cmap6_get_info )</a>
<a name="ln1649"> </a>
<a name="ln1650">#endif /* TT_CONFIG_CMAP_FORMAT_6 */</a>
<a name="ln1651"> </a>
<a name="ln1652"> </a>
<a name="ln1653">  /*************************************************************************/</a>
<a name="ln1654">  /*************************************************************************/</a>
<a name="ln1655">  /*****                                                               *****/</a>
<a name="ln1656">  /*****                          FORMAT 8                             *****/</a>
<a name="ln1657">  /*****                                                               *****/</a>
<a name="ln1658">  /***** It is hard to completely understand what the OpenType spec    *****/</a>
<a name="ln1659">  /***** says about this format, but here is my conclusion.            *****/</a>
<a name="ln1660">  /*****                                                               *****/</a>
<a name="ln1661">  /***** The purpose of this format is to easily map UTF-16 text to    *****/</a>
<a name="ln1662">  /***** glyph indices.  Basically, the `char_code' must be in one of  *****/</a>
<a name="ln1663">  /***** the following formats.                                        *****/</a>
<a name="ln1664">  /*****                                                               *****/</a>
<a name="ln1665">  /*****   - A 16-bit value that isn't part of the Unicode Surrogates  *****/</a>
<a name="ln1666">  /*****     Area (i.e. U+D800-U+DFFF).                                *****/</a>
<a name="ln1667">  /*****                                                               *****/</a>
<a name="ln1668">  /*****   - A 32-bit value, made of two surrogate values, i.e.. if    *****/</a>
<a name="ln1669">  /*****     `char_code = (char_hi &lt;&lt; 16) | char_lo', then both        *****/</a>
<a name="ln1670">  /*****     `char_hi' and `char_lo' must be in the Surrogates Area.   *****/</a>
<a name="ln1671">  /*****      Area.                                                    *****/</a>
<a name="ln1672">  /*****                                                               *****/</a>
<a name="ln1673">  /***** The `is32' table embedded in the charmap indicates whether a  *****/</a>
<a name="ln1674">  /***** given 16-bit value is in the surrogates area or not.          *****/</a>
<a name="ln1675">  /*****                                                               *****/</a>
<a name="ln1676">  /***** So, for any given `char_code', we can assert the following.   *****/</a>
<a name="ln1677">  /*****                                                               *****/</a>
<a name="ln1678">  /*****   If `char_hi == 0' then we must have `is32[char_lo] == 0'.   *****/</a>
<a name="ln1679">  /*****                                                               *****/</a>
<a name="ln1680">  /*****   If `char_hi != 0' then we must have both                    *****/</a>
<a name="ln1681">  /*****   `is32[char_hi] != 0' and `is32[char_lo] != 0'.              *****/</a>
<a name="ln1682">  /*****                                                               *****/</a>
<a name="ln1683">  /*************************************************************************/</a>
<a name="ln1684">  /*************************************************************************/</a>
<a name="ln1685"> </a>
<a name="ln1686">  /*************************************************************************/</a>
<a name="ln1687">  /*                                                                       */</a>
<a name="ln1688">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln1689">  /* --------------                                                        */</a>
<a name="ln1690">  /*                                                                       */</a>
<a name="ln1691">  /*   NAME        OFFSET         TYPE        DESCRIPTION                  */</a>
<a name="ln1692">  /*                                                                       */</a>
<a name="ln1693">  /*   format      0              USHORT      must be 8                    */</a>
<a name="ln1694">  /*   reserved    2              USHORT      reserved                     */</a>
<a name="ln1695">  /*   length      4              ULONG       length in bytes              */</a>
<a name="ln1696">  /*   language    8              ULONG       Mac language code            */</a>
<a name="ln1697">  /*   is32        12             BYTE[8192]  32-bitness bitmap            */</a>
<a name="ln1698">  /*   count       8204           ULONG       number of groups             */</a>
<a name="ln1699">  /*                                                                       */</a>
<a name="ln1700">  /* This header is followed by `count' groups of the following format:    */</a>
<a name="ln1701">  /*                                                                       */</a>
<a name="ln1702">  /*   start       0              ULONG       first charcode               */</a>
<a name="ln1703">  /*   end         4              ULONG       last charcode                */</a>
<a name="ln1704">  /*   startId     8              ULONG       start glyph ID for the group */</a>
<a name="ln1705">  /*                                                                       */</a>
<a name="ln1706"> </a>
<a name="ln1707">#ifdef TT_CONFIG_CMAP_FORMAT_8</a>
<a name="ln1708"> </a>
<a name="ln1709">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln1710">  tt_cmap8_validate( FT_Byte*      table,</a>
<a name="ln1711">                     FT_Validator  valid )</a>
<a name="ln1712">  {</a>
<a name="ln1713">    FT_Byte*   p = table + 4;</a>
<a name="ln1714">    FT_Byte*   is32;</a>
<a name="ln1715">    FT_UInt32  length;</a>
<a name="ln1716">    FT_UInt32  num_groups;</a>
<a name="ln1717"> </a>
<a name="ln1718"> </a>
<a name="ln1719">    if ( table + 16 + 8192 &gt; valid-&gt;limit )</a>
<a name="ln1720">      FT_INVALID_TOO_SHORT;</a>
<a name="ln1721"> </a>
<a name="ln1722">    length = TT_NEXT_ULONG( p );</a>
<a name="ln1723">    if ( length &gt; (FT_UInt32)( valid-&gt;limit - table ) || length &lt; 8192 + 16 )</a>
<a name="ln1724">      FT_INVALID_TOO_SHORT;</a>
<a name="ln1725"> </a>
<a name="ln1726">    is32       = table + 12;</a>
<a name="ln1727">    p          = is32  + 8192;          /* skip `is32' array */</a>
<a name="ln1728">    num_groups = TT_NEXT_ULONG( p );</a>
<a name="ln1729"> </a>
<a name="ln1730">    /* p + num_groups * 12 &gt; valid-&gt;limit ? */</a>
<a name="ln1731">    if ( num_groups &gt; (FT_UInt32)( valid-&gt;limit - p ) / 12 )</a>
<a name="ln1732">      FT_INVALID_TOO_SHORT;</a>
<a name="ln1733"> </a>
<a name="ln1734">    /* check groups, they must be in increasing order */</a>
<a name="ln1735">    {</a>
<a name="ln1736">      FT_UInt32  n, start, end, start_id, count, last = 0;</a>
<a name="ln1737"> </a>
<a name="ln1738"> </a>
<a name="ln1739">      for ( n = 0; n &lt; num_groups; n++ )</a>
<a name="ln1740">      {</a>
<a name="ln1741">        FT_UInt   hi, lo;</a>
<a name="ln1742"> </a>
<a name="ln1743"> </a>
<a name="ln1744">        start    = TT_NEXT_ULONG( p );</a>
<a name="ln1745">        end      = TT_NEXT_ULONG( p );</a>
<a name="ln1746">        start_id = TT_NEXT_ULONG( p );</a>
<a name="ln1747"> </a>
<a name="ln1748">        if ( start &gt; end )</a>
<a name="ln1749">          FT_INVALID_DATA;</a>
<a name="ln1750"> </a>
<a name="ln1751">        if ( n &gt; 0 &amp;&amp; start &lt;= last )</a>
<a name="ln1752">          FT_INVALID_DATA;</a>
<a name="ln1753"> </a>
<a name="ln1754">        if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln1755">        {</a>
<a name="ln1756">          FT_UInt32  d = end - start;</a>
<a name="ln1757"> </a>
<a name="ln1758"> </a>
<a name="ln1759">          /* start_id + end - start &gt;= TT_VALID_GLYPH_COUNT( valid ) ? */</a>
<a name="ln1760">          if ( d &gt; TT_VALID_GLYPH_COUNT( valid )             ||</a>
<a name="ln1761">               start_id &gt;= TT_VALID_GLYPH_COUNT( valid ) - d )</a>
<a name="ln1762">            FT_INVALID_GLYPH_ID;</a>
<a name="ln1763"> </a>
<a name="ln1764">          count = (FT_UInt32)( end - start + 1 );</a>
<a name="ln1765"> </a>
<a name="ln1766">          if ( start &amp; ~0xFFFFU )</a>
<a name="ln1767">          {</a>
<a name="ln1768">            /* start_hi != 0; check that is32[i] is 1 for each i in */</a>
<a name="ln1769">            /* the `hi' and `lo' of the range [start..end]          */</a>
<a name="ln1770">            for ( ; count &gt; 0; count--, start++ )</a>
<a name="ln1771">            {</a>
<a name="ln1772">              hi = (FT_UInt)( start &gt;&gt; 16 );</a>
<a name="ln1773">              lo = (FT_UInt)( start &amp; 0xFFFFU );</a>
<a name="ln1774"> </a>
<a name="ln1775">              if ( (is32[hi &gt;&gt; 3] &amp; ( 0x80 &gt;&gt; ( hi &amp; 7 ) ) ) == 0 )</a>
<a name="ln1776">                FT_INVALID_DATA;</a>
<a name="ln1777"> </a>
<a name="ln1778">              if ( (is32[lo &gt;&gt; 3] &amp; ( 0x80 &gt;&gt; ( lo &amp; 7 ) ) ) == 0 )</a>
<a name="ln1779">                FT_INVALID_DATA;</a>
<a name="ln1780">            }</a>
<a name="ln1781">          }</a>
<a name="ln1782">          else</a>
<a name="ln1783">          {</a>
<a name="ln1784">            /* start_hi == 0; check that is32[i] is 0 for each i in */</a>
<a name="ln1785">            /* the range [start..end]                               */</a>
<a name="ln1786"> </a>
<a name="ln1787">            /* end_hi cannot be != 0! */</a>
<a name="ln1788">            if ( end &amp; ~0xFFFFU )</a>
<a name="ln1789">              FT_INVALID_DATA;</a>
<a name="ln1790"> </a>
<a name="ln1791">            for ( ; count &gt; 0; count--, start++ )</a>
<a name="ln1792">            {</a>
<a name="ln1793">              lo = (FT_UInt)( start &amp; 0xFFFFU );</a>
<a name="ln1794"> </a>
<a name="ln1795">              if ( (is32[lo &gt;&gt; 3] &amp; ( 0x80 &gt;&gt; ( lo &amp; 7 ) ) ) != 0 )</a>
<a name="ln1796">                FT_INVALID_DATA;</a>
<a name="ln1797">            }</a>
<a name="ln1798">          }</a>
<a name="ln1799">        }</a>
<a name="ln1800"> </a>
<a name="ln1801">        last = end;</a>
<a name="ln1802">      }</a>
<a name="ln1803">    }</a>
<a name="ln1804"> </a>
<a name="ln1805">    return FT_Err_Ok;</a>
<a name="ln1806">  }</a>
<a name="ln1807"> </a>
<a name="ln1808"> </a>
<a name="ln1809">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln1810">  tt_cmap8_char_index( TT_CMap    cmap,</a>
<a name="ln1811">                       FT_UInt32  char_code )</a>
<a name="ln1812">  {</a>
<a name="ln1813">    FT_Byte*   table      = cmap-&gt;data;</a>
<a name="ln1814">    FT_UInt    result     = 0;</a>
<a name="ln1815">    FT_Byte*   p          = table + 8204;</a>
<a name="ln1816">    FT_UInt32  num_groups = TT_NEXT_ULONG( p );</a>
<a name="ln1817">    FT_UInt32  start, end, start_id;</a>
<a name="ln1818"> </a>
<a name="ln1819"> </a>
<a name="ln1820">    for ( ; num_groups &gt; 0; num_groups-- )</a>
<a name="ln1821">    {</a>
<a name="ln1822">      start    = TT_NEXT_ULONG( p );</a>
<a name="ln1823">      end      = TT_NEXT_ULONG( p );</a>
<a name="ln1824">      start_id = TT_NEXT_ULONG( p );</a>
<a name="ln1825"> </a>
<a name="ln1826">      if ( char_code &lt; start )</a>
<a name="ln1827">        break;</a>
<a name="ln1828"> </a>
<a name="ln1829">      if ( char_code &lt;= end )</a>
<a name="ln1830">      {</a>
<a name="ln1831">        if ( start_id &gt; 0xFFFFFFFFUL - ( char_code - start ) )</a>
<a name="ln1832">          return 0;</a>
<a name="ln1833"> </a>
<a name="ln1834">        result = (FT_UInt)( start_id + ( char_code - start ) );</a>
<a name="ln1835">        break;</a>
<a name="ln1836">      }</a>
<a name="ln1837">    }</a>
<a name="ln1838">    return result;</a>
<a name="ln1839">  }</a>
<a name="ln1840"> </a>
<a name="ln1841"> </a>
<a name="ln1842">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln1843">  tt_cmap8_char_next( TT_CMap     cmap,</a>
<a name="ln1844">                      FT_UInt32  *pchar_code )</a>
<a name="ln1845">  {</a>
<a name="ln1846">    FT_Face    face       = cmap-&gt;cmap.charmap.face;</a>
<a name="ln1847">    FT_UInt32  result     = 0;</a>
<a name="ln1848">    FT_UInt32  char_code;</a>
<a name="ln1849">    FT_UInt    gindex     = 0;</a>
<a name="ln1850">    FT_Byte*   table      = cmap-&gt;data;</a>
<a name="ln1851">    FT_Byte*   p          = table + 8204;</a>
<a name="ln1852">    FT_UInt32  num_groups = TT_NEXT_ULONG( p );</a>
<a name="ln1853">    FT_UInt32  start, end, start_id;</a>
<a name="ln1854"> </a>
<a name="ln1855"> </a>
<a name="ln1856">    if ( *pchar_code &gt;= 0xFFFFFFFFUL )</a>
<a name="ln1857">      return 0;</a>
<a name="ln1858"> </a>
<a name="ln1859">    char_code = *pchar_code + 1;</a>
<a name="ln1860"> </a>
<a name="ln1861">    p = table + 8208;</a>
<a name="ln1862"> </a>
<a name="ln1863">    for ( ; num_groups &gt; 0; num_groups-- )</a>
<a name="ln1864">    {</a>
<a name="ln1865">      start    = TT_NEXT_ULONG( p );</a>
<a name="ln1866">      end      = TT_NEXT_ULONG( p );</a>
<a name="ln1867">      start_id = TT_NEXT_ULONG( p );</a>
<a name="ln1868"> </a>
<a name="ln1869">      if ( char_code &lt; start )</a>
<a name="ln1870">        char_code = start;</a>
<a name="ln1871"> </a>
<a name="ln1872">    Again:</a>
<a name="ln1873">      if ( char_code &lt;= end )</a>
<a name="ln1874">      {</a>
<a name="ln1875">        /* ignore invalid group */</a>
<a name="ln1876">        if ( start_id &gt; 0xFFFFFFFFUL - ( char_code - start ) )</a>
<a name="ln1877">          continue;</a>
<a name="ln1878"> </a>
<a name="ln1879">        gindex = (FT_UInt)( start_id + ( char_code - start ) );</a>
<a name="ln1880"> </a>
<a name="ln1881">        /* does first element of group point to `.notdef' glyph? */</a>
<a name="ln1882">        if ( gindex == 0 )</a>
<a name="ln1883">        {</a>
<a name="ln1884">          if ( char_code &gt;= 0xFFFFFFFFUL )</a>
<a name="ln1885">            break;</a>
<a name="ln1886"> </a>
<a name="ln1887">          char_code++;</a>
<a name="ln1888">          goto Again;</a>
<a name="ln1889">        }</a>
<a name="ln1890"> </a>
<a name="ln1891">        /* if `gindex' is invalid, the remaining values */</a>
<a name="ln1892">        /* in this group are invalid, too               */</a>
<a name="ln1893">        if ( gindex &gt;= (FT_UInt)face-&gt;num_glyphs )</a>
<a name="ln1894">          continue;</a>
<a name="ln1895"> </a>
<a name="ln1896">        result = char_code;</a>
<a name="ln1897">        break;</a>
<a name="ln1898">      }</a>
<a name="ln1899">    }</a>
<a name="ln1900"> </a>
<a name="ln1901">    *pchar_code = result;</a>
<a name="ln1902">    return gindex;</a>
<a name="ln1903">  }</a>
<a name="ln1904"> </a>
<a name="ln1905"> </a>
<a name="ln1906">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln1907">  tt_cmap8_get_info( TT_CMap       cmap,</a>
<a name="ln1908">                     TT_CMapInfo  *cmap_info )</a>
<a name="ln1909">  {</a>
<a name="ln1910">    FT_Byte*  p = cmap-&gt;data + 8;</a>
<a name="ln1911"> </a>
<a name="ln1912"> </a>
<a name="ln1913">    cmap_info-&gt;format   = 8;</a>
<a name="ln1914">    cmap_info-&gt;language = (FT_ULong)TT_PEEK_ULONG( p );</a>
<a name="ln1915"> </a>
<a name="ln1916">    return FT_Err_Ok;</a>
<a name="ln1917">  }</a>
<a name="ln1918"> </a>
<a name="ln1919"> </a>
<a name="ln1920">  FT_DEFINE_TT_CMAP(</a>
<a name="ln1921">    tt_cmap8_class_rec,</a>
<a name="ln1922">    sizeof ( TT_CMapRec ),</a>
<a name="ln1923"> </a>
<a name="ln1924">    (FT_CMap_InitFunc)     tt_cmap_init,</a>
<a name="ln1925">    (FT_CMap_DoneFunc)     NULL,</a>
<a name="ln1926">    (FT_CMap_CharIndexFunc)tt_cmap8_char_index,</a>
<a name="ln1927">    (FT_CMap_CharNextFunc) tt_cmap8_char_next,</a>
<a name="ln1928"> </a>
<a name="ln1929">    NULL,</a>
<a name="ln1930">    NULL,</a>
<a name="ln1931">    NULL,</a>
<a name="ln1932">    NULL,</a>
<a name="ln1933">    NULL,</a>
<a name="ln1934"> </a>
<a name="ln1935">    8,</a>
<a name="ln1936">    (TT_CMap_ValidateFunc)tt_cmap8_validate,</a>
<a name="ln1937">    (TT_CMap_Info_GetFunc)tt_cmap8_get_info )</a>
<a name="ln1938"> </a>
<a name="ln1939">#endif /* TT_CONFIG_CMAP_FORMAT_8 */</a>
<a name="ln1940"> </a>
<a name="ln1941"> </a>
<a name="ln1942">  /*************************************************************************/</a>
<a name="ln1943">  /*************************************************************************/</a>
<a name="ln1944">  /*****                                                               *****/</a>
<a name="ln1945">  /*****                          FORMAT 10                            *****/</a>
<a name="ln1946">  /*****                                                               *****/</a>
<a name="ln1947">  /*************************************************************************/</a>
<a name="ln1948">  /*************************************************************************/</a>
<a name="ln1949"> </a>
<a name="ln1950">  /*************************************************************************/</a>
<a name="ln1951">  /*                                                                       */</a>
<a name="ln1952">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln1953">  /* --------------                                                        */</a>
<a name="ln1954">  /*                                                                       */</a>
<a name="ln1955">  /*   NAME      OFFSET  TYPE               DESCRIPTION                    */</a>
<a name="ln1956">  /*                                                                       */</a>
<a name="ln1957">  /*   format     0      USHORT             must be 10                     */</a>
<a name="ln1958">  /*   reserved   2      USHORT             reserved                       */</a>
<a name="ln1959">  /*   length     4      ULONG              length in bytes                */</a>
<a name="ln1960">  /*   language   8      ULONG              Mac language code              */</a>
<a name="ln1961">  /*                                                                       */</a>
<a name="ln1962">  /*   start     12      ULONG              first char in range            */</a>
<a name="ln1963">  /*   count     16      ULONG              number of chars in range       */</a>
<a name="ln1964">  /*   glyphIds  20      USHORT[count]      glyph indices covered          */</a>
<a name="ln1965">  /*                                                                       */</a>
<a name="ln1966"> </a>
<a name="ln1967">#ifdef TT_CONFIG_CMAP_FORMAT_10</a>
<a name="ln1968"> </a>
<a name="ln1969">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln1970">  tt_cmap10_validate( FT_Byte*      table,</a>
<a name="ln1971">                      FT_Validator  valid )</a>
<a name="ln1972">  {</a>
<a name="ln1973">    FT_Byte*  p = table + 4;</a>
<a name="ln1974">    FT_ULong  length, count;</a>
<a name="ln1975"> </a>
<a name="ln1976"> </a>
<a name="ln1977">    if ( table + 20 &gt; valid-&gt;limit )</a>
<a name="ln1978">      FT_INVALID_TOO_SHORT;</a>
<a name="ln1979"> </a>
<a name="ln1980">    length = TT_NEXT_ULONG( p );</a>
<a name="ln1981">    p      = table + 16;</a>
<a name="ln1982">    count  = TT_NEXT_ULONG( p );</a>
<a name="ln1983"> </a>
<a name="ln1984">    if ( length &gt; (FT_ULong)( valid-&gt;limit - table ) ||</a>
<a name="ln1985">         /* length &lt; 20 + count * 2 ? */</a>
<a name="ln1986">         length &lt; 20                                 ||</a>
<a name="ln1987">         ( length - 20 ) / 2 &lt; count                 )</a>
<a name="ln1988">      FT_INVALID_TOO_SHORT;</a>
<a name="ln1989"> </a>
<a name="ln1990">    /* check glyph indices */</a>
<a name="ln1991">    if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln1992">    {</a>
<a name="ln1993">      FT_UInt  gindex;</a>
<a name="ln1994"> </a>
<a name="ln1995"> </a>
<a name="ln1996">      for ( ; count &gt; 0; count-- )</a>
<a name="ln1997">      {</a>
<a name="ln1998">        gindex = TT_NEXT_USHORT( p );</a>
<a name="ln1999">        if ( gindex &gt;= TT_VALID_GLYPH_COUNT( valid ) )</a>
<a name="ln2000">          FT_INVALID_GLYPH_ID;</a>
<a name="ln2001">      }</a>
<a name="ln2002">    }</a>
<a name="ln2003"> </a>
<a name="ln2004">    return FT_Err_Ok;</a>
<a name="ln2005">  }</a>
<a name="ln2006"> </a>
<a name="ln2007"> </a>
<a name="ln2008">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln2009">  tt_cmap10_char_index( TT_CMap    cmap,</a>
<a name="ln2010">                        FT_UInt32  char_code )</a>
<a name="ln2011">  {</a>
<a name="ln2012">    FT_Byte*   table  = cmap-&gt;data;</a>
<a name="ln2013">    FT_UInt    result = 0;</a>
<a name="ln2014">    FT_Byte*   p      = table + 12;</a>
<a name="ln2015">    FT_UInt32  start  = TT_NEXT_ULONG( p );</a>
<a name="ln2016">    FT_UInt32  count  = TT_NEXT_ULONG( p );</a>
<a name="ln2017">    FT_UInt32  idx;</a>
<a name="ln2018"> </a>
<a name="ln2019"> </a>
<a name="ln2020">    if ( char_code &lt; start )</a>
<a name="ln2021">      return 0;</a>
<a name="ln2022"> </a>
<a name="ln2023">    idx = char_code - start;</a>
<a name="ln2024"> </a>
<a name="ln2025">    if ( idx &lt; count )</a>
<a name="ln2026">    {</a>
<a name="ln2027">      p     += 2 * idx;</a>
<a name="ln2028">      result = TT_PEEK_USHORT( p );</a>
<a name="ln2029">    }</a>
<a name="ln2030"> </a>
<a name="ln2031">    return result;</a>
<a name="ln2032">  }</a>
<a name="ln2033"> </a>
<a name="ln2034"> </a>
<a name="ln2035">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln2036">  tt_cmap10_char_next( TT_CMap     cmap,</a>
<a name="ln2037">                       FT_UInt32  *pchar_code )</a>
<a name="ln2038">  {</a>
<a name="ln2039">    FT_Byte*   table     = cmap-&gt;data;</a>
<a name="ln2040">    FT_UInt32  char_code;</a>
<a name="ln2041">    FT_UInt    gindex    = 0;</a>
<a name="ln2042">    FT_Byte*   p         = table + 12;</a>
<a name="ln2043">    FT_UInt32  start     = TT_NEXT_ULONG( p );</a>
<a name="ln2044">    FT_UInt32  count     = TT_NEXT_ULONG( p );</a>
<a name="ln2045">    FT_UInt32  idx;</a>
<a name="ln2046"> </a>
<a name="ln2047"> </a>
<a name="ln2048">    if ( *pchar_code &gt;= 0xFFFFFFFFUL )</a>
<a name="ln2049">      return 0;</a>
<a name="ln2050"> </a>
<a name="ln2051">    char_code = *pchar_code + 1;</a>
<a name="ln2052"> </a>
<a name="ln2053">    if ( char_code &lt; start )</a>
<a name="ln2054">      char_code = start;</a>
<a name="ln2055"> </a>
<a name="ln2056">    idx = char_code - start;</a>
<a name="ln2057">    p  += 2 * idx;</a>
<a name="ln2058"> </a>
<a name="ln2059">    for ( ; idx &lt; count; idx++ )</a>
<a name="ln2060">    {</a>
<a name="ln2061">      gindex = TT_NEXT_USHORT( p );</a>
<a name="ln2062">      if ( gindex != 0 )</a>
<a name="ln2063">        break;</a>
<a name="ln2064"> </a>
<a name="ln2065">      if ( char_code &gt;= 0xFFFFFFFFUL )</a>
<a name="ln2066">        return 0;</a>
<a name="ln2067"> </a>
<a name="ln2068">      char_code++;</a>
<a name="ln2069">    }</a>
<a name="ln2070"> </a>
<a name="ln2071">    *pchar_code = char_code;</a>
<a name="ln2072">    return gindex;</a>
<a name="ln2073">  }</a>
<a name="ln2074"> </a>
<a name="ln2075"> </a>
<a name="ln2076">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2077">  tt_cmap10_get_info( TT_CMap       cmap,</a>
<a name="ln2078">                      TT_CMapInfo  *cmap_info )</a>
<a name="ln2079">  {</a>
<a name="ln2080">    FT_Byte*  p = cmap-&gt;data + 8;</a>
<a name="ln2081"> </a>
<a name="ln2082"> </a>
<a name="ln2083">    cmap_info-&gt;format   = 10;</a>
<a name="ln2084">    cmap_info-&gt;language = (FT_ULong)TT_PEEK_ULONG( p );</a>
<a name="ln2085"> </a>
<a name="ln2086">    return FT_Err_Ok;</a>
<a name="ln2087">  }</a>
<a name="ln2088"> </a>
<a name="ln2089"> </a>
<a name="ln2090">  FT_DEFINE_TT_CMAP(</a>
<a name="ln2091">    tt_cmap10_class_rec,</a>
<a name="ln2092">    sizeof ( TT_CMapRec ),</a>
<a name="ln2093"> </a>
<a name="ln2094">    (FT_CMap_InitFunc)     tt_cmap_init,</a>
<a name="ln2095">    (FT_CMap_DoneFunc)     NULL,</a>
<a name="ln2096">    (FT_CMap_CharIndexFunc)tt_cmap10_char_index,</a>
<a name="ln2097">    (FT_CMap_CharNextFunc) tt_cmap10_char_next,</a>
<a name="ln2098"> </a>
<a name="ln2099">    NULL,</a>
<a name="ln2100">    NULL,</a>
<a name="ln2101">    NULL,</a>
<a name="ln2102">    NULL,</a>
<a name="ln2103">    NULL,</a>
<a name="ln2104"> </a>
<a name="ln2105">    10,</a>
<a name="ln2106">    (TT_CMap_ValidateFunc)tt_cmap10_validate,</a>
<a name="ln2107">    (TT_CMap_Info_GetFunc)tt_cmap10_get_info )</a>
<a name="ln2108"> </a>
<a name="ln2109">#endif /* TT_CONFIG_CMAP_FORMAT_10 */</a>
<a name="ln2110"> </a>
<a name="ln2111"> </a>
<a name="ln2112">  /*************************************************************************/</a>
<a name="ln2113">  /*************************************************************************/</a>
<a name="ln2114">  /*****                                                               *****/</a>
<a name="ln2115">  /*****                          FORMAT 12                            *****/</a>
<a name="ln2116">  /*****                                                               *****/</a>
<a name="ln2117">  /*************************************************************************/</a>
<a name="ln2118">  /*************************************************************************/</a>
<a name="ln2119"> </a>
<a name="ln2120">  /*************************************************************************/</a>
<a name="ln2121">  /*                                                                       */</a>
<a name="ln2122">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln2123">  /* --------------                                                        */</a>
<a name="ln2124">  /*                                                                       */</a>
<a name="ln2125">  /*   NAME        OFFSET     TYPE       DESCRIPTION                       */</a>
<a name="ln2126">  /*                                                                       */</a>
<a name="ln2127">  /*   format      0          USHORT     must be 12                        */</a>
<a name="ln2128">  /*   reserved    2          USHORT     reserved                          */</a>
<a name="ln2129">  /*   length      4          ULONG      length in bytes                   */</a>
<a name="ln2130">  /*   language    8          ULONG      Mac language code                 */</a>
<a name="ln2131">  /*   count       12         ULONG      number of groups                  */</a>
<a name="ln2132">  /*               16                                                      */</a>
<a name="ln2133">  /*                                                                       */</a>
<a name="ln2134">  /* This header is followed by `count' groups of the following format:    */</a>
<a name="ln2135">  /*                                                                       */</a>
<a name="ln2136">  /*   start       0          ULONG      first charcode                    */</a>
<a name="ln2137">  /*   end         4          ULONG      last charcode                     */</a>
<a name="ln2138">  /*   startId     8          ULONG      start glyph ID for the group      */</a>
<a name="ln2139">  /*                                                                       */</a>
<a name="ln2140"> </a>
<a name="ln2141">#ifdef TT_CONFIG_CMAP_FORMAT_12</a>
<a name="ln2142"> </a>
<a name="ln2143">  typedef struct  TT_CMap12Rec_</a>
<a name="ln2144">  {</a>
<a name="ln2145">    TT_CMapRec  cmap;</a>
<a name="ln2146">    FT_Bool     valid;</a>
<a name="ln2147">    FT_ULong    cur_charcode;</a>
<a name="ln2148">    FT_UInt     cur_gindex;</a>
<a name="ln2149">    FT_ULong    cur_group;</a>
<a name="ln2150">    FT_ULong    num_groups;</a>
<a name="ln2151"> </a>
<a name="ln2152">  } TT_CMap12Rec, *TT_CMap12;</a>
<a name="ln2153"> </a>
<a name="ln2154"> </a>
<a name="ln2155">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2156">  tt_cmap12_init( TT_CMap12  cmap,</a>
<a name="ln2157">                  FT_Byte*   table )</a>
<a name="ln2158">  {</a>
<a name="ln2159">    cmap-&gt;cmap.data  = table;</a>
<a name="ln2160"> </a>
<a name="ln2161">    table           += 12;</a>
<a name="ln2162">    cmap-&gt;num_groups = FT_PEEK_ULONG( table );</a>
<a name="ln2163"> </a>
<a name="ln2164">    cmap-&gt;valid      = 0;</a>
<a name="ln2165"> </a>
<a name="ln2166">    return FT_Err_Ok;</a>
<a name="ln2167">  }</a>
<a name="ln2168"> </a>
<a name="ln2169"> </a>
<a name="ln2170">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2171">  tt_cmap12_validate( FT_Byte*      table,</a>
<a name="ln2172">                      FT_Validator  valid )</a>
<a name="ln2173">  {</a>
<a name="ln2174">    FT_Byte*  p;</a>
<a name="ln2175">    FT_ULong  length;</a>
<a name="ln2176">    FT_ULong  num_groups;</a>
<a name="ln2177"> </a>
<a name="ln2178"> </a>
<a name="ln2179">    if ( table + 16 &gt; valid-&gt;limit )</a>
<a name="ln2180">      FT_INVALID_TOO_SHORT;</a>
<a name="ln2181"> </a>
<a name="ln2182">    p      = table + 4;</a>
<a name="ln2183">    length = TT_NEXT_ULONG( p );</a>
<a name="ln2184"> </a>
<a name="ln2185">    p          = table + 12;</a>
<a name="ln2186">    num_groups = TT_NEXT_ULONG( p );</a>
<a name="ln2187"> </a>
<a name="ln2188">    if ( length &gt; (FT_ULong)( valid-&gt;limit - table ) ||</a>
<a name="ln2189">         /* length &lt; 16 + 12 * num_groups ? */</a>
<a name="ln2190">         length &lt; 16                                 ||</a>
<a name="ln2191">         ( length - 16 ) / 12 &lt; num_groups           )</a>
<a name="ln2192">      FT_INVALID_TOO_SHORT;</a>
<a name="ln2193"> </a>
<a name="ln2194">    /* check groups, they must be in increasing order */</a>
<a name="ln2195">    {</a>
<a name="ln2196">      FT_ULong  n, start, end, start_id, last = 0;</a>
<a name="ln2197"> </a>
<a name="ln2198"> </a>
<a name="ln2199">      for ( n = 0; n &lt; num_groups; n++ )</a>
<a name="ln2200">      {</a>
<a name="ln2201">        start    = TT_NEXT_ULONG( p );</a>
<a name="ln2202">        end      = TT_NEXT_ULONG( p );</a>
<a name="ln2203">        start_id = TT_NEXT_ULONG( p );</a>
<a name="ln2204"> </a>
<a name="ln2205">        if ( start &gt; end )</a>
<a name="ln2206">          FT_INVALID_DATA;</a>
<a name="ln2207"> </a>
<a name="ln2208">        if ( n &gt; 0 &amp;&amp; start &lt;= last )</a>
<a name="ln2209">          FT_INVALID_DATA;</a>
<a name="ln2210"> </a>
<a name="ln2211">        if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln2212">        {</a>
<a name="ln2213">          FT_UInt32  d = end - start;</a>
<a name="ln2214"> </a>
<a name="ln2215"> </a>
<a name="ln2216">          /* start_id + end - start &gt;= TT_VALID_GLYPH_COUNT( valid ) ? */</a>
<a name="ln2217">          if ( d &gt; TT_VALID_GLYPH_COUNT( valid )             ||</a>
<a name="ln2218">               start_id &gt;= TT_VALID_GLYPH_COUNT( valid ) - d )</a>
<a name="ln2219">            FT_INVALID_GLYPH_ID;</a>
<a name="ln2220">        }</a>
<a name="ln2221"> </a>
<a name="ln2222">        last = end;</a>
<a name="ln2223">      }</a>
<a name="ln2224">    }</a>
<a name="ln2225"> </a>
<a name="ln2226">    return FT_Err_Ok;</a>
<a name="ln2227">  }</a>
<a name="ln2228"> </a>
<a name="ln2229"> </a>
<a name="ln2230">  /* search the index of the charcode next to cmap-&gt;cur_charcode */</a>
<a name="ln2231">  /* cmap-&gt;cur_group should be set up properly by caller         */</a>
<a name="ln2232">  /*                                                             */</a>
<a name="ln2233">  static void</a>
<a name="ln2234">  tt_cmap12_next( TT_CMap12  cmap )</a>
<a name="ln2235">  {</a>
<a name="ln2236">    FT_Face   face = cmap-&gt;cmap.cmap.charmap.face;</a>
<a name="ln2237">    FT_Byte*  p;</a>
<a name="ln2238">    FT_ULong  start, end, start_id, char_code;</a>
<a name="ln2239">    FT_ULong  n;</a>
<a name="ln2240">    FT_UInt   gindex;</a>
<a name="ln2241"> </a>
<a name="ln2242"> </a>
<a name="ln2243">    if ( cmap-&gt;cur_charcode &gt;= 0xFFFFFFFFUL )</a>
<a name="ln2244">      goto Fail;</a>
<a name="ln2245"> </a>
<a name="ln2246">    char_code = cmap-&gt;cur_charcode + 1;</a>
<a name="ln2247"> </a>
<a name="ln2248">    for ( n = cmap-&gt;cur_group; n &lt; cmap-&gt;num_groups; n++ )</a>
<a name="ln2249">    {</a>
<a name="ln2250">      p        = cmap-&gt;cmap.data + 16 + 12 * n;</a>
<a name="ln2251">      start    = TT_NEXT_ULONG( p );</a>
<a name="ln2252">      end      = TT_NEXT_ULONG( p );</a>
<a name="ln2253">      start_id = TT_PEEK_ULONG( p );</a>
<a name="ln2254"> </a>
<a name="ln2255">      if ( char_code &lt; start )</a>
<a name="ln2256">        char_code = start;</a>
<a name="ln2257"> </a>
<a name="ln2258">    Again:</a>
<a name="ln2259">      if ( char_code &lt;= end )</a>
<a name="ln2260">      {</a>
<a name="ln2261">        /* ignore invalid group */</a>
<a name="ln2262">        if ( start_id &gt; 0xFFFFFFFFUL - ( char_code - start ) )</a>
<a name="ln2263">          continue;</a>
<a name="ln2264"> </a>
<a name="ln2265">        gindex = (FT_UInt)( start_id + ( char_code - start ) );</a>
<a name="ln2266"> </a>
<a name="ln2267">        /* does first element of group point to `.notdef' glyph? */</a>
<a name="ln2268">        if ( gindex == 0 )</a>
<a name="ln2269">        {</a>
<a name="ln2270">          if ( char_code &gt;= 0xFFFFFFFFUL )</a>
<a name="ln2271">            goto Fail;</a>
<a name="ln2272"> </a>
<a name="ln2273">          char_code++;</a>
<a name="ln2274">          goto Again;</a>
<a name="ln2275">        }</a>
<a name="ln2276"> </a>
<a name="ln2277">        /* if `gindex' is invalid, the remaining values */</a>
<a name="ln2278">        /* in this group are invalid, too               */</a>
<a name="ln2279">        if ( gindex &gt;= (FT_UInt)face-&gt;num_glyphs )</a>
<a name="ln2280">          continue;</a>
<a name="ln2281"> </a>
<a name="ln2282">        cmap-&gt;cur_charcode = char_code;</a>
<a name="ln2283">        cmap-&gt;cur_gindex   = gindex;</a>
<a name="ln2284">        cmap-&gt;cur_group    = n;</a>
<a name="ln2285"> </a>
<a name="ln2286">        return;</a>
<a name="ln2287">      }</a>
<a name="ln2288">    }</a>
<a name="ln2289"> </a>
<a name="ln2290">  Fail:</a>
<a name="ln2291">    cmap-&gt;valid = 0;</a>
<a name="ln2292">  }</a>
<a name="ln2293"> </a>
<a name="ln2294"> </a>
<a name="ln2295">  static FT_UInt</a>
<a name="ln2296">  tt_cmap12_char_map_binary( TT_CMap     cmap,</a>
<a name="ln2297">                             FT_UInt32*  pchar_code,</a>
<a name="ln2298">                             FT_Bool     next )</a>
<a name="ln2299">  {</a>
<a name="ln2300">    FT_UInt    gindex     = 0;</a>
<a name="ln2301">    FT_Byte*   p          = cmap-&gt;data + 12;</a>
<a name="ln2302">    FT_UInt32  num_groups = TT_PEEK_ULONG( p );</a>
<a name="ln2303">    FT_UInt32  char_code  = *pchar_code;</a>
<a name="ln2304">    FT_UInt32  start, end, start_id;</a>
<a name="ln2305">    FT_UInt32  max, min, mid;</a>
<a name="ln2306"> </a>
<a name="ln2307"> </a>
<a name="ln2308">    if ( !num_groups )</a>
<a name="ln2309">      return 0;</a>
<a name="ln2310"> </a>
<a name="ln2311">    /* make compiler happy */</a>
<a name="ln2312">    mid = num_groups;</a>
<a name="ln2313">    end = 0xFFFFFFFFUL;</a>
<a name="ln2314"> </a>
<a name="ln2315">    if ( next )</a>
<a name="ln2316">    {</a>
<a name="ln2317">      if ( char_code &gt;= 0xFFFFFFFFUL )</a>
<a name="ln2318">        return 0;</a>
<a name="ln2319"> </a>
<a name="ln2320">      char_code++;</a>
<a name="ln2321">    }</a>
<a name="ln2322"> </a>
<a name="ln2323">    min = 0;</a>
<a name="ln2324">    max = num_groups;</a>
<a name="ln2325"> </a>
<a name="ln2326">    /* binary search */</a>
<a name="ln2327">    while ( min &lt; max )</a>
<a name="ln2328">    {</a>
<a name="ln2329">      mid = ( min + max ) &gt;&gt; 1;</a>
<a name="ln2330">      p   = cmap-&gt;data + 16 + 12 * mid;</a>
<a name="ln2331"> </a>
<a name="ln2332">      start = TT_NEXT_ULONG( p );</a>
<a name="ln2333">      end   = TT_NEXT_ULONG( p );</a>
<a name="ln2334"> </a>
<a name="ln2335">      if ( char_code &lt; start )</a>
<a name="ln2336">        max = mid;</a>
<a name="ln2337">      else if ( char_code &gt; end )</a>
<a name="ln2338">        min = mid + 1;</a>
<a name="ln2339">      else</a>
<a name="ln2340">      {</a>
<a name="ln2341">        start_id = TT_PEEK_ULONG( p );</a>
<a name="ln2342"> </a>
<a name="ln2343">        /* reject invalid glyph index */</a>
<a name="ln2344">        if ( start_id &gt; 0xFFFFFFFFUL - ( char_code - start ) )</a>
<a name="ln2345">          gindex = 0;</a>
<a name="ln2346">        else</a>
<a name="ln2347">          gindex = (FT_UInt)( start_id + ( char_code - start ) );</a>
<a name="ln2348">        break;</a>
<a name="ln2349">      }</a>
<a name="ln2350">    }</a>
<a name="ln2351"> </a>
<a name="ln2352">    if ( next )</a>
<a name="ln2353">    {</a>
<a name="ln2354">      FT_Face    face   = cmap-&gt;cmap.charmap.face;</a>
<a name="ln2355">      TT_CMap12  cmap12 = (TT_CMap12)cmap;</a>
<a name="ln2356"> </a>
<a name="ln2357"> </a>
<a name="ln2358">      /* if `char_code' is not in any group, then `mid' is */</a>
<a name="ln2359">      /* the group nearest to `char_code'                  */</a>
<a name="ln2360"> </a>
<a name="ln2361">      if ( char_code &gt; end )</a>
<a name="ln2362">      {</a>
<a name="ln2363">        mid++;</a>
<a name="ln2364">        if ( mid == num_groups )</a>
<a name="ln2365">          return 0;</a>
<a name="ln2366">      }</a>
<a name="ln2367"> </a>
<a name="ln2368">      cmap12-&gt;valid        = 1;</a>
<a name="ln2369">      cmap12-&gt;cur_charcode = char_code;</a>
<a name="ln2370">      cmap12-&gt;cur_group    = mid;</a>
<a name="ln2371"> </a>
<a name="ln2372">      if ( gindex &gt;= (FT_UInt)face-&gt;num_glyphs )</a>
<a name="ln2373">        gindex = 0;</a>
<a name="ln2374"> </a>
<a name="ln2375">      if ( !gindex )</a>
<a name="ln2376">      {</a>
<a name="ln2377">        tt_cmap12_next( cmap12 );</a>
<a name="ln2378"> </a>
<a name="ln2379">        if ( cmap12-&gt;valid )</a>
<a name="ln2380">          gindex = cmap12-&gt;cur_gindex;</a>
<a name="ln2381">      }</a>
<a name="ln2382">      else</a>
<a name="ln2383">        cmap12-&gt;cur_gindex = gindex;</a>
<a name="ln2384"> </a>
<a name="ln2385">      *pchar_code = cmap12-&gt;cur_charcode;</a>
<a name="ln2386">    }</a>
<a name="ln2387"> </a>
<a name="ln2388">    return gindex;</a>
<a name="ln2389">  }</a>
<a name="ln2390"> </a>
<a name="ln2391"> </a>
<a name="ln2392">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln2393">  tt_cmap12_char_index( TT_CMap    cmap,</a>
<a name="ln2394">                        FT_UInt32  char_code )</a>
<a name="ln2395">  {</a>
<a name="ln2396">    return tt_cmap12_char_map_binary( cmap, &amp;char_code, 0 );</a>
<a name="ln2397">  }</a>
<a name="ln2398"> </a>
<a name="ln2399"> </a>
<a name="ln2400">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln2401">  tt_cmap12_char_next( TT_CMap     cmap,</a>
<a name="ln2402">                       FT_UInt32  *pchar_code )</a>
<a name="ln2403">  {</a>
<a name="ln2404">    TT_CMap12  cmap12 = (TT_CMap12)cmap;</a>
<a name="ln2405">    FT_UInt    gindex;</a>
<a name="ln2406"> </a>
<a name="ln2407"> </a>
<a name="ln2408">    /* no need to search */</a>
<a name="ln2409">    if ( cmap12-&gt;valid &amp;&amp; cmap12-&gt;cur_charcode == *pchar_code )</a>
<a name="ln2410">    {</a>
<a name="ln2411">      tt_cmap12_next( cmap12 );</a>
<a name="ln2412">      if ( cmap12-&gt;valid )</a>
<a name="ln2413">      {</a>
<a name="ln2414">        gindex      = cmap12-&gt;cur_gindex;</a>
<a name="ln2415">        *pchar_code = (FT_UInt32)cmap12-&gt;cur_charcode;</a>
<a name="ln2416">      }</a>
<a name="ln2417">      else</a>
<a name="ln2418">        gindex = 0;</a>
<a name="ln2419">    }</a>
<a name="ln2420">    else</a>
<a name="ln2421">      gindex = tt_cmap12_char_map_binary( cmap, pchar_code, 1 );</a>
<a name="ln2422"> </a>
<a name="ln2423">    return gindex;</a>
<a name="ln2424">  }</a>
<a name="ln2425"> </a>
<a name="ln2426"> </a>
<a name="ln2427">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2428">  tt_cmap12_get_info( TT_CMap       cmap,</a>
<a name="ln2429">                      TT_CMapInfo  *cmap_info )</a>
<a name="ln2430">  {</a>
<a name="ln2431">    FT_Byte*  p = cmap-&gt;data + 8;</a>
<a name="ln2432"> </a>
<a name="ln2433"> </a>
<a name="ln2434">    cmap_info-&gt;format   = 12;</a>
<a name="ln2435">    cmap_info-&gt;language = (FT_ULong)TT_PEEK_ULONG( p );</a>
<a name="ln2436"> </a>
<a name="ln2437">    return FT_Err_Ok;</a>
<a name="ln2438">  }</a>
<a name="ln2439"> </a>
<a name="ln2440"> </a>
<a name="ln2441">  FT_DEFINE_TT_CMAP(</a>
<a name="ln2442">    tt_cmap12_class_rec,</a>
<a name="ln2443">    sizeof ( TT_CMap12Rec ),</a>
<a name="ln2444"> </a>
<a name="ln2445">    (FT_CMap_InitFunc)     tt_cmap12_init,</a>
<a name="ln2446">    (FT_CMap_DoneFunc)     NULL,</a>
<a name="ln2447">    (FT_CMap_CharIndexFunc)tt_cmap12_char_index,</a>
<a name="ln2448">    (FT_CMap_CharNextFunc) tt_cmap12_char_next,</a>
<a name="ln2449"> </a>
<a name="ln2450">    NULL,</a>
<a name="ln2451">    NULL,</a>
<a name="ln2452">    NULL,</a>
<a name="ln2453">    NULL,</a>
<a name="ln2454">    NULL,</a>
<a name="ln2455"> </a>
<a name="ln2456">    12,</a>
<a name="ln2457">    (TT_CMap_ValidateFunc)tt_cmap12_validate,</a>
<a name="ln2458">    (TT_CMap_Info_GetFunc)tt_cmap12_get_info )</a>
<a name="ln2459"> </a>
<a name="ln2460">#endif /* TT_CONFIG_CMAP_FORMAT_12 */</a>
<a name="ln2461"> </a>
<a name="ln2462"> </a>
<a name="ln2463">  /*************************************************************************/</a>
<a name="ln2464">  /*************************************************************************/</a>
<a name="ln2465">  /*****                                                               *****/</a>
<a name="ln2466">  /*****                          FORMAT 13                            *****/</a>
<a name="ln2467">  /*****                                                               *****/</a>
<a name="ln2468">  /*************************************************************************/</a>
<a name="ln2469">  /*************************************************************************/</a>
<a name="ln2470"> </a>
<a name="ln2471">  /*************************************************************************/</a>
<a name="ln2472">  /*                                                                       */</a>
<a name="ln2473">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln2474">  /* --------------                                                        */</a>
<a name="ln2475">  /*                                                                       */</a>
<a name="ln2476">  /*   NAME        OFFSET     TYPE       DESCRIPTION                       */</a>
<a name="ln2477">  /*                                                                       */</a>
<a name="ln2478">  /*   format      0          USHORT     must be 13                        */</a>
<a name="ln2479">  /*   reserved    2          USHORT     reserved                          */</a>
<a name="ln2480">  /*   length      4          ULONG      length in bytes                   */</a>
<a name="ln2481">  /*   language    8          ULONG      Mac language code                 */</a>
<a name="ln2482">  /*   count       12         ULONG      number of groups                  */</a>
<a name="ln2483">  /*               16                                                      */</a>
<a name="ln2484">  /*                                                                       */</a>
<a name="ln2485">  /* This header is followed by `count' groups of the following format:    */</a>
<a name="ln2486">  /*                                                                       */</a>
<a name="ln2487">  /*   start       0          ULONG      first charcode                    */</a>
<a name="ln2488">  /*   end         4          ULONG      last charcode                     */</a>
<a name="ln2489">  /*   glyphId     8          ULONG      glyph ID for the whole group      */</a>
<a name="ln2490">  /*                                                                       */</a>
<a name="ln2491"> </a>
<a name="ln2492">#ifdef TT_CONFIG_CMAP_FORMAT_13</a>
<a name="ln2493"> </a>
<a name="ln2494">  typedef struct  TT_CMap13Rec_</a>
<a name="ln2495">  {</a>
<a name="ln2496">    TT_CMapRec  cmap;</a>
<a name="ln2497">    FT_Bool     valid;</a>
<a name="ln2498">    FT_ULong    cur_charcode;</a>
<a name="ln2499">    FT_UInt     cur_gindex;</a>
<a name="ln2500">    FT_ULong    cur_group;</a>
<a name="ln2501">    FT_ULong    num_groups;</a>
<a name="ln2502"> </a>
<a name="ln2503">  } TT_CMap13Rec, *TT_CMap13;</a>
<a name="ln2504"> </a>
<a name="ln2505"> </a>
<a name="ln2506">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2507">  tt_cmap13_init( TT_CMap13  cmap,</a>
<a name="ln2508">                  FT_Byte*   table )</a>
<a name="ln2509">  {</a>
<a name="ln2510">    cmap-&gt;cmap.data  = table;</a>
<a name="ln2511"> </a>
<a name="ln2512">    table           += 12;</a>
<a name="ln2513">    cmap-&gt;num_groups = FT_PEEK_ULONG( table );</a>
<a name="ln2514"> </a>
<a name="ln2515">    cmap-&gt;valid      = 0;</a>
<a name="ln2516"> </a>
<a name="ln2517">    return FT_Err_Ok;</a>
<a name="ln2518">  }</a>
<a name="ln2519"> </a>
<a name="ln2520"> </a>
<a name="ln2521">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2522">  tt_cmap13_validate( FT_Byte*      table,</a>
<a name="ln2523">                      FT_Validator  valid )</a>
<a name="ln2524">  {</a>
<a name="ln2525">    FT_Byte*  p;</a>
<a name="ln2526">    FT_ULong  length;</a>
<a name="ln2527">    FT_ULong  num_groups;</a>
<a name="ln2528"> </a>
<a name="ln2529"> </a>
<a name="ln2530">    if ( table + 16 &gt; valid-&gt;limit )</a>
<a name="ln2531">      FT_INVALID_TOO_SHORT;</a>
<a name="ln2532"> </a>
<a name="ln2533">    p      = table + 4;</a>
<a name="ln2534">    length = TT_NEXT_ULONG( p );</a>
<a name="ln2535"> </a>
<a name="ln2536">    p          = table + 12;</a>
<a name="ln2537">    num_groups = TT_NEXT_ULONG( p );</a>
<a name="ln2538"> </a>
<a name="ln2539">    if ( length &gt; (FT_ULong)( valid-&gt;limit - table ) ||</a>
<a name="ln2540">         /* length &lt; 16 + 12 * num_groups ? */</a>
<a name="ln2541">         length &lt; 16                                 ||</a>
<a name="ln2542">         ( length - 16 ) / 12 &lt; num_groups           )</a>
<a name="ln2543">      FT_INVALID_TOO_SHORT;</a>
<a name="ln2544"> </a>
<a name="ln2545">    /* check groups, they must be in increasing order */</a>
<a name="ln2546">    {</a>
<a name="ln2547">      FT_ULong  n, start, end, glyph_id, last = 0;</a>
<a name="ln2548"> </a>
<a name="ln2549"> </a>
<a name="ln2550">      for ( n = 0; n &lt; num_groups; n++ )</a>
<a name="ln2551">      {</a>
<a name="ln2552">        start    = TT_NEXT_ULONG( p );</a>
<a name="ln2553">        end      = TT_NEXT_ULONG( p );</a>
<a name="ln2554">        glyph_id = TT_NEXT_ULONG( p );</a>
<a name="ln2555"> </a>
<a name="ln2556">        if ( start &gt; end )</a>
<a name="ln2557">          FT_INVALID_DATA;</a>
<a name="ln2558"> </a>
<a name="ln2559">        if ( n &gt; 0 &amp;&amp; start &lt;= last )</a>
<a name="ln2560">          FT_INVALID_DATA;</a>
<a name="ln2561"> </a>
<a name="ln2562">        if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT )</a>
<a name="ln2563">        {</a>
<a name="ln2564">          if ( glyph_id &gt;= TT_VALID_GLYPH_COUNT( valid ) )</a>
<a name="ln2565">            FT_INVALID_GLYPH_ID;</a>
<a name="ln2566">        }</a>
<a name="ln2567"> </a>
<a name="ln2568">        last = end;</a>
<a name="ln2569">      }</a>
<a name="ln2570">    }</a>
<a name="ln2571"> </a>
<a name="ln2572">    return FT_Err_Ok;</a>
<a name="ln2573">  }</a>
<a name="ln2574"> </a>
<a name="ln2575"> </a>
<a name="ln2576">  /* search the index of the charcode next to cmap-&gt;cur_charcode */</a>
<a name="ln2577">  /* cmap-&gt;cur_group should be set up properly by caller         */</a>
<a name="ln2578">  /*                                                             */</a>
<a name="ln2579">  static void</a>
<a name="ln2580">  tt_cmap13_next( TT_CMap13  cmap )</a>
<a name="ln2581">  {</a>
<a name="ln2582">    FT_Face   face = cmap-&gt;cmap.cmap.charmap.face;</a>
<a name="ln2583">    FT_Byte*  p;</a>
<a name="ln2584">    FT_ULong  start, end, glyph_id, char_code;</a>
<a name="ln2585">    FT_ULong  n;</a>
<a name="ln2586">    FT_UInt   gindex;</a>
<a name="ln2587"> </a>
<a name="ln2588"> </a>
<a name="ln2589">    if ( cmap-&gt;cur_charcode &gt;= 0xFFFFFFFFUL )</a>
<a name="ln2590">      goto Fail;</a>
<a name="ln2591"> </a>
<a name="ln2592">    char_code = cmap-&gt;cur_charcode + 1;</a>
<a name="ln2593"> </a>
<a name="ln2594">    for ( n = cmap-&gt;cur_group; n &lt; cmap-&gt;num_groups; n++ )</a>
<a name="ln2595">    {</a>
<a name="ln2596">      p        = cmap-&gt;cmap.data + 16 + 12 * n;</a>
<a name="ln2597">      start    = TT_NEXT_ULONG( p );</a>
<a name="ln2598">      end      = TT_NEXT_ULONG( p );</a>
<a name="ln2599">      glyph_id = TT_PEEK_ULONG( p );</a>
<a name="ln2600"> </a>
<a name="ln2601">      if ( char_code &lt; start )</a>
<a name="ln2602">        char_code = start;</a>
<a name="ln2603"> </a>
<a name="ln2604">      if ( char_code &lt;= end )</a>
<a name="ln2605">      {</a>
<a name="ln2606">        gindex = (FT_UInt)glyph_id;</a>
<a name="ln2607"> </a>
<a name="ln2608">        if ( gindex &amp;&amp; gindex &lt; (FT_UInt)face-&gt;num_glyphs )</a>
<a name="ln2609">        {</a>
<a name="ln2610">          cmap-&gt;cur_charcode = char_code;</a>
<a name="ln2611">          cmap-&gt;cur_gindex   = gindex;</a>
<a name="ln2612">          cmap-&gt;cur_group    = n;</a>
<a name="ln2613"> </a>
<a name="ln2614">          return;</a>
<a name="ln2615">        }</a>
<a name="ln2616">      }</a>
<a name="ln2617">    }</a>
<a name="ln2618"> </a>
<a name="ln2619">  Fail:</a>
<a name="ln2620">    cmap-&gt;valid = 0;</a>
<a name="ln2621">  }</a>
<a name="ln2622"> </a>
<a name="ln2623"> </a>
<a name="ln2624">  static FT_UInt</a>
<a name="ln2625">  tt_cmap13_char_map_binary( TT_CMap     cmap,</a>
<a name="ln2626">                             FT_UInt32*  pchar_code,</a>
<a name="ln2627">                             FT_Bool     next )</a>
<a name="ln2628">  {</a>
<a name="ln2629">    FT_UInt    gindex     = 0;</a>
<a name="ln2630">    FT_Byte*   p          = cmap-&gt;data + 12;</a>
<a name="ln2631">    FT_UInt32  num_groups = TT_PEEK_ULONG( p );</a>
<a name="ln2632">    FT_UInt32  char_code  = *pchar_code;</a>
<a name="ln2633">    FT_UInt32  start, end;</a>
<a name="ln2634">    FT_UInt32  max, min, mid;</a>
<a name="ln2635"> </a>
<a name="ln2636"> </a>
<a name="ln2637">    if ( !num_groups )</a>
<a name="ln2638">      return 0;</a>
<a name="ln2639"> </a>
<a name="ln2640">    /* make compiler happy */</a>
<a name="ln2641">    mid = num_groups;</a>
<a name="ln2642">    end = 0xFFFFFFFFUL;</a>
<a name="ln2643"> </a>
<a name="ln2644">    if ( next )</a>
<a name="ln2645">    {</a>
<a name="ln2646">      if ( char_code &gt;= 0xFFFFFFFFUL )</a>
<a name="ln2647">        return 0;</a>
<a name="ln2648"> </a>
<a name="ln2649">      char_code++;</a>
<a name="ln2650">    }</a>
<a name="ln2651"> </a>
<a name="ln2652">    min = 0;</a>
<a name="ln2653">    max = num_groups;</a>
<a name="ln2654"> </a>
<a name="ln2655">    /* binary search */</a>
<a name="ln2656">    while ( min &lt; max )</a>
<a name="ln2657">    {</a>
<a name="ln2658">      mid = ( min + max ) &gt;&gt; 1;</a>
<a name="ln2659">      p   = cmap-&gt;data + 16 + 12 * mid;</a>
<a name="ln2660"> </a>
<a name="ln2661">      start = TT_NEXT_ULONG( p );</a>
<a name="ln2662">      end   = TT_NEXT_ULONG( p );</a>
<a name="ln2663"> </a>
<a name="ln2664">      if ( char_code &lt; start )</a>
<a name="ln2665">        max = mid;</a>
<a name="ln2666">      else if ( char_code &gt; end )</a>
<a name="ln2667">        min = mid + 1;</a>
<a name="ln2668">      else</a>
<a name="ln2669">      {</a>
<a name="ln2670">        gindex = (FT_UInt)TT_PEEK_ULONG( p );</a>
<a name="ln2671"> </a>
<a name="ln2672">        break;</a>
<a name="ln2673">      }</a>
<a name="ln2674">    }</a>
<a name="ln2675"> </a>
<a name="ln2676">    if ( next )</a>
<a name="ln2677">    {</a>
<a name="ln2678">      FT_Face    face   = cmap-&gt;cmap.charmap.face;</a>
<a name="ln2679">      TT_CMap13  cmap13 = (TT_CMap13)cmap;</a>
<a name="ln2680"> </a>
<a name="ln2681"> </a>
<a name="ln2682">      /* if `char_code' is not in any group, then `mid' is */</a>
<a name="ln2683">      /* the group nearest to `char_code'                  */</a>
<a name="ln2684"> </a>
<a name="ln2685">      if ( char_code &gt; end )</a>
<a name="ln2686">      {</a>
<a name="ln2687">        mid++;</a>
<a name="ln2688">        if ( mid == num_groups )</a>
<a name="ln2689">          return 0;</a>
<a name="ln2690">      }</a>
<a name="ln2691"> </a>
<a name="ln2692">      cmap13-&gt;valid        = 1;</a>
<a name="ln2693">      cmap13-&gt;cur_charcode = char_code;</a>
<a name="ln2694">      cmap13-&gt;cur_group    = mid;</a>
<a name="ln2695"> </a>
<a name="ln2696">      if ( gindex &gt;= (FT_UInt)face-&gt;num_glyphs )</a>
<a name="ln2697">        gindex = 0;</a>
<a name="ln2698"> </a>
<a name="ln2699">      if ( !gindex )</a>
<a name="ln2700">      {</a>
<a name="ln2701">        tt_cmap13_next( cmap13 );</a>
<a name="ln2702"> </a>
<a name="ln2703">        if ( cmap13-&gt;valid )</a>
<a name="ln2704">          gindex = cmap13-&gt;cur_gindex;</a>
<a name="ln2705">      }</a>
<a name="ln2706">      else</a>
<a name="ln2707">        cmap13-&gt;cur_gindex = gindex;</a>
<a name="ln2708"> </a>
<a name="ln2709">      *pchar_code = cmap13-&gt;cur_charcode;</a>
<a name="ln2710">    }</a>
<a name="ln2711"> </a>
<a name="ln2712">    return gindex;</a>
<a name="ln2713">  }</a>
<a name="ln2714"> </a>
<a name="ln2715"> </a>
<a name="ln2716">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln2717">  tt_cmap13_char_index( TT_CMap    cmap,</a>
<a name="ln2718">                        FT_UInt32  char_code )</a>
<a name="ln2719">  {</a>
<a name="ln2720">    return tt_cmap13_char_map_binary( cmap, &amp;char_code, 0 );</a>
<a name="ln2721">  }</a>
<a name="ln2722"> </a>
<a name="ln2723"> </a>
<a name="ln2724">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln2725">  tt_cmap13_char_next( TT_CMap     cmap,</a>
<a name="ln2726">                       FT_UInt32  *pchar_code )</a>
<a name="ln2727">  {</a>
<a name="ln2728">    TT_CMap13  cmap13 = (TT_CMap13)cmap;</a>
<a name="ln2729">    FT_UInt    gindex;</a>
<a name="ln2730"> </a>
<a name="ln2731"> </a>
<a name="ln2732">    /* no need to search */</a>
<a name="ln2733">    if ( cmap13-&gt;valid &amp;&amp; cmap13-&gt;cur_charcode == *pchar_code )</a>
<a name="ln2734">    {</a>
<a name="ln2735">      tt_cmap13_next( cmap13 );</a>
<a name="ln2736">      if ( cmap13-&gt;valid )</a>
<a name="ln2737">      {</a>
<a name="ln2738">        gindex      = cmap13-&gt;cur_gindex;</a>
<a name="ln2739">        *pchar_code = cmap13-&gt;cur_charcode;</a>
<a name="ln2740">      }</a>
<a name="ln2741">      else</a>
<a name="ln2742">        gindex = 0;</a>
<a name="ln2743">    }</a>
<a name="ln2744">    else</a>
<a name="ln2745">      gindex = tt_cmap13_char_map_binary( cmap, pchar_code, 1 );</a>
<a name="ln2746"> </a>
<a name="ln2747">    return gindex;</a>
<a name="ln2748">  }</a>
<a name="ln2749"> </a>
<a name="ln2750"> </a>
<a name="ln2751">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2752">  tt_cmap13_get_info( TT_CMap       cmap,</a>
<a name="ln2753">                      TT_CMapInfo  *cmap_info )</a>
<a name="ln2754">  {</a>
<a name="ln2755">    FT_Byte*  p = cmap-&gt;data + 8;</a>
<a name="ln2756"> </a>
<a name="ln2757"> </a>
<a name="ln2758">    cmap_info-&gt;format   = 13;</a>
<a name="ln2759">    cmap_info-&gt;language = (FT_ULong)TT_PEEK_ULONG( p );</a>
<a name="ln2760"> </a>
<a name="ln2761">    return FT_Err_Ok;</a>
<a name="ln2762">  }</a>
<a name="ln2763"> </a>
<a name="ln2764"> </a>
<a name="ln2765">  FT_DEFINE_TT_CMAP(</a>
<a name="ln2766">    tt_cmap13_class_rec,</a>
<a name="ln2767">    sizeof ( TT_CMap13Rec ),</a>
<a name="ln2768"> </a>
<a name="ln2769">    (FT_CMap_InitFunc)     tt_cmap13_init,</a>
<a name="ln2770">    (FT_CMap_DoneFunc)     NULL,</a>
<a name="ln2771">    (FT_CMap_CharIndexFunc)tt_cmap13_char_index,</a>
<a name="ln2772">    (FT_CMap_CharNextFunc) tt_cmap13_char_next,</a>
<a name="ln2773"> </a>
<a name="ln2774">    NULL,</a>
<a name="ln2775">    NULL,</a>
<a name="ln2776">    NULL,</a>
<a name="ln2777">    NULL,</a>
<a name="ln2778">    NULL,</a>
<a name="ln2779"> </a>
<a name="ln2780">    13,</a>
<a name="ln2781">    (TT_CMap_ValidateFunc)tt_cmap13_validate,</a>
<a name="ln2782">    (TT_CMap_Info_GetFunc)tt_cmap13_get_info )</a>
<a name="ln2783"> </a>
<a name="ln2784">#endif /* TT_CONFIG_CMAP_FORMAT_13 */</a>
<a name="ln2785"> </a>
<a name="ln2786"> </a>
<a name="ln2787">  /*************************************************************************/</a>
<a name="ln2788">  /*************************************************************************/</a>
<a name="ln2789">  /*****                                                               *****/</a>
<a name="ln2790">  /*****                           FORMAT 14                           *****/</a>
<a name="ln2791">  /*****                                                               *****/</a>
<a name="ln2792">  /*************************************************************************/</a>
<a name="ln2793">  /*************************************************************************/</a>
<a name="ln2794"> </a>
<a name="ln2795">  /*************************************************************************/</a>
<a name="ln2796">  /*                                                                       */</a>
<a name="ln2797">  /* TABLE OVERVIEW                                                        */</a>
<a name="ln2798">  /* --------------                                                        */</a>
<a name="ln2799">  /*                                                                       */</a>
<a name="ln2800">  /*   NAME         OFFSET  TYPE    DESCRIPTION                            */</a>
<a name="ln2801">  /*                                                                       */</a>
<a name="ln2802">  /*   format         0     USHORT  must be 14                             */</a>
<a name="ln2803">  /*   length         2     ULONG   table length in bytes                  */</a>
<a name="ln2804">  /*   numSelector    6     ULONG   number of variation sel. records       */</a>
<a name="ln2805">  /*                                                                       */</a>
<a name="ln2806">  /* Followed by numSelector records, each of which looks like             */</a>
<a name="ln2807">  /*                                                                       */</a>
<a name="ln2808">  /*   varSelector    0     UINT24  Unicode codepoint of sel.              */</a>
<a name="ln2809">  /*   defaultOff     3     ULONG   offset to a default UVS table          */</a>
<a name="ln2810">  /*                                describing any variants to be found in */</a>
<a name="ln2811">  /*                                the normal Unicode subtable.           */</a>
<a name="ln2812">  /*   nonDefOff      7     ULONG   offset to a non-default UVS table      */</a>
<a name="ln2813">  /*                                describing any variants not in the     */</a>
<a name="ln2814">  /*                                standard cmap, with GIDs here          */</a>
<a name="ln2815">  /* (either offset may be 0 NULL)                                         */</a>
<a name="ln2816">  /*                                                                       */</a>
<a name="ln2817">  /* Selectors are sorted by code point.                                   */</a>
<a name="ln2818">  /*                                                                       */</a>
<a name="ln2819">  /* A default Unicode Variation Selector (UVS) subtable is just a list of */</a>
<a name="ln2820">  /* ranges of code points which are to be found in the standard cmap.  No */</a>
<a name="ln2821">  /* glyph IDs (GIDs) here.                                                */</a>
<a name="ln2822">  /*                                                                       */</a>
<a name="ln2823">  /*   numRanges      0     ULONG   number of ranges following             */</a>
<a name="ln2824">  /*                                                                       */</a>
<a name="ln2825">  /* A range looks like                                                    */</a>
<a name="ln2826">  /*                                                                       */</a>
<a name="ln2827">  /*   uniStart       0     UINT24  code point of the first character in   */</a>
<a name="ln2828">  /*                                this range                             */</a>
<a name="ln2829">  /*   additionalCnt  3     UBYTE   count of additional characters in this */</a>
<a name="ln2830">  /*                                range (zero means a range of a single  */</a>
<a name="ln2831">  /*                                character)                             */</a>
<a name="ln2832">  /*                                                                       */</a>
<a name="ln2833">  /* Ranges are sorted by `uniStart'.                                      */</a>
<a name="ln2834">  /*                                                                       */</a>
<a name="ln2835">  /* A non-default Unicode Variation Selector (UVS) subtable is a list of  */</a>
<a name="ln2836">  /* mappings from codepoint to GID.                                       */</a>
<a name="ln2837">  /*                                                                       */</a>
<a name="ln2838">  /*   numMappings    0     ULONG   number of mappings                     */</a>
<a name="ln2839">  /*                                                                       */</a>
<a name="ln2840">  /* A range looks like                                                    */</a>
<a name="ln2841">  /*                                                                       */</a>
<a name="ln2842">  /*   uniStart       0     UINT24  code point of the first character in   */</a>
<a name="ln2843">  /*                                this range                             */</a>
<a name="ln2844">  /*   GID            3     USHORT  and its GID                            */</a>
<a name="ln2845">  /*                                                                       */</a>
<a name="ln2846">  /* Ranges are sorted by `uniStart'.                                      */</a>
<a name="ln2847"> </a>
<a name="ln2848">#ifdef TT_CONFIG_CMAP_FORMAT_14</a>
<a name="ln2849"> </a>
<a name="ln2850">  typedef struct  TT_CMap14Rec_</a>
<a name="ln2851">  {</a>
<a name="ln2852">    TT_CMapRec  cmap;</a>
<a name="ln2853">    FT_ULong    num_selectors;</a>
<a name="ln2854"> </a>
<a name="ln2855">    /* This array is used to store the results of various</a>
<a name="ln2856">     * cmap 14 query functions.  The data is overwritten</a>
<a name="ln2857">     * on each call to these functions.</a>
<a name="ln2858">     */</a>
<a name="ln2859">    FT_UInt32   max_results;</a>
<a name="ln2860">    FT_UInt32*  results;</a>
<a name="ln2861">    FT_Memory   memory;</a>
<a name="ln2862"> </a>
<a name="ln2863">  } TT_CMap14Rec, *TT_CMap14;</a>
<a name="ln2864"> </a>
<a name="ln2865"> </a>
<a name="ln2866">  FT_CALLBACK_DEF( void )</a>
<a name="ln2867">  tt_cmap14_done( TT_CMap14  cmap )</a>
<a name="ln2868">  {</a>
<a name="ln2869">    FT_Memory  memory = cmap-&gt;memory;</a>
<a name="ln2870"> </a>
<a name="ln2871"> </a>
<a name="ln2872">    cmap-&gt;max_results = 0;</a>
<a name="ln2873">    if ( memory != NULL &amp;&amp; cmap-&gt;results != NULL )</a>
<a name="ln2874">      FT_FREE( cmap-&gt;results );</a>
<a name="ln2875">  }</a>
<a name="ln2876"> </a>
<a name="ln2877"> </a>
<a name="ln2878">  static FT_Error</a>
<a name="ln2879">  tt_cmap14_ensure( TT_CMap14  cmap,</a>
<a name="ln2880">                    FT_UInt32  num_results,</a>
<a name="ln2881">                    FT_Memory  memory )</a>
<a name="ln2882">  {</a>
<a name="ln2883">    FT_UInt32  old_max = cmap-&gt;max_results;</a>
<a name="ln2884">    FT_Error   error   = FT_Err_Ok;</a>
<a name="ln2885"> </a>
<a name="ln2886"> </a>
<a name="ln2887">    if ( num_results &gt; cmap-&gt;max_results )</a>
<a name="ln2888">    {</a>
<a name="ln2889">       cmap-&gt;memory = memory;</a>
<a name="ln2890"> </a>
<a name="ln2891">       if ( FT_QRENEW_ARRAY( cmap-&gt;results, old_max, num_results ) )</a>
<a name="ln2892">         return error;</a>
<a name="ln2893"> </a>
<a name="ln2894">       cmap-&gt;max_results = num_results;</a>
<a name="ln2895">    }</a>
<a name="ln2896"> </a>
<a name="ln2897">    return error;</a>
<a name="ln2898">  }</a>
<a name="ln2899"> </a>
<a name="ln2900"> </a>
<a name="ln2901">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2902">  tt_cmap14_init( TT_CMap14  cmap,</a>
<a name="ln2903">                  FT_Byte*   table )</a>
<a name="ln2904">  {</a>
<a name="ln2905">    cmap-&gt;cmap.data = table;</a>
<a name="ln2906"> </a>
<a name="ln2907">    table               += 6;</a>
<a name="ln2908">    cmap-&gt;num_selectors  = FT_PEEK_ULONG( table );</a>
<a name="ln2909">    cmap-&gt;max_results    = 0;</a>
<a name="ln2910">    cmap-&gt;results        = NULL;</a>
<a name="ln2911"> </a>
<a name="ln2912">    return FT_Err_Ok;</a>
<a name="ln2913">  }</a>
<a name="ln2914"> </a>
<a name="ln2915"> </a>
<a name="ln2916">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln2917">  tt_cmap14_validate( FT_Byte*      table,</a>
<a name="ln2918">                      FT_Validator  valid )</a>
<a name="ln2919">  {</a>
<a name="ln2920">    FT_Byte*  p;</a>
<a name="ln2921">    FT_ULong  length;</a>
<a name="ln2922">    FT_ULong  num_selectors;</a>
<a name="ln2923"> </a>
<a name="ln2924"> </a>
<a name="ln2925">    if ( table + 2 + 4 + 4 &gt; valid-&gt;limit )</a>
<a name="ln2926">      FT_INVALID_TOO_SHORT;</a>
<a name="ln2927"> </a>
<a name="ln2928">    p             = table + 2;</a>
<a name="ln2929">    length        = TT_NEXT_ULONG( p );</a>
<a name="ln2930">    num_selectors = TT_NEXT_ULONG( p );</a>
<a name="ln2931"> </a>
<a name="ln2932">    if ( length &gt; (FT_ULong)( valid-&gt;limit - table ) ||</a>
<a name="ln2933">         /* length &lt; 10 + 11 * num_selectors ? */</a>
<a name="ln2934">         length &lt; 10                                 ||</a>
<a name="ln2935">         ( length - 10 ) / 11 &lt; num_selectors        )</a>
<a name="ln2936">      FT_INVALID_TOO_SHORT;</a>
<a name="ln2937"> </a>
<a name="ln2938">    /* check selectors, they must be in increasing order */</a>
<a name="ln2939">    {</a>
<a name="ln2940">      /* we start lastVarSel at 1 because a variant selector value of 0</a>
<a name="ln2941">       * isn't valid.</a>
<a name="ln2942">       */</a>
<a name="ln2943">      FT_ULong  n, lastVarSel = 1;</a>
<a name="ln2944"> </a>
<a name="ln2945"> </a>
<a name="ln2946">      for ( n = 0; n &lt; num_selectors; n++ )</a>
<a name="ln2947">      {</a>
<a name="ln2948">        FT_ULong  varSel    = TT_NEXT_UINT24( p );</a>
<a name="ln2949">        FT_ULong  defOff    = TT_NEXT_ULONG( p );</a>
<a name="ln2950">        FT_ULong  nondefOff = TT_NEXT_ULONG( p );</a>
<a name="ln2951"> </a>
<a name="ln2952"> </a>
<a name="ln2953">        if ( defOff &gt;= length || nondefOff &gt;= length )</a>
<a name="ln2954">          FT_INVALID_TOO_SHORT;</a>
<a name="ln2955"> </a>
<a name="ln2956">        if ( varSel &lt; lastVarSel )</a>
<a name="ln2957">          FT_INVALID_DATA;</a>
<a name="ln2958"> </a>
<a name="ln2959">        lastVarSel = varSel + 1;</a>
<a name="ln2960"> </a>
<a name="ln2961">        /* check the default table (these glyphs should be reached     */</a>
<a name="ln2962">        /* through the normal Unicode cmap, no GIDs, just check order) */</a>
<a name="ln2963">        if ( defOff != 0 )</a>
<a name="ln2964">        {</a>
<a name="ln2965">          FT_Byte*  defp      = table + defOff;</a>
<a name="ln2966">          FT_ULong  numRanges = TT_NEXT_ULONG( defp );</a>
<a name="ln2967">          FT_ULong  i;</a>
<a name="ln2968">          FT_ULong  lastBase  = 0;</a>
<a name="ln2969"> </a>
<a name="ln2970"> </a>
<a name="ln2971">          /* defp + numRanges * 4 &gt; valid-&gt;limit ? */</a>
<a name="ln2972">          if ( numRanges &gt; (FT_ULong)( valid-&gt;limit - defp ) / 4 )</a>
<a name="ln2973">            FT_INVALID_TOO_SHORT;</a>
<a name="ln2974"> </a>
<a name="ln2975">          for ( i = 0; i &lt; numRanges; ++i )</a>
<a name="ln2976">          {</a>
<a name="ln2977">            FT_ULong  base = TT_NEXT_UINT24( defp );</a>
<a name="ln2978">            FT_ULong  cnt  = FT_NEXT_BYTE( defp );</a>
<a name="ln2979"> </a>
<a name="ln2980"> </a>
<a name="ln2981">            if ( base + cnt &gt;= 0x110000UL )              /* end of Unicode */</a>
<a name="ln2982">              FT_INVALID_DATA;</a>
<a name="ln2983"> </a>
<a name="ln2984">            if ( base &lt; lastBase )</a>
<a name="ln2985">              FT_INVALID_DATA;</a>
<a name="ln2986"> </a>
<a name="ln2987">            lastBase = base + cnt + 1U;</a>
<a name="ln2988">          }</a>
<a name="ln2989">        }</a>
<a name="ln2990"> </a>
<a name="ln2991">        /* and the non-default table (these glyphs are specified here) */</a>
<a name="ln2992">        if ( nondefOff != 0 )</a>
<a name="ln2993">        {</a>
<a name="ln2994">          FT_Byte*  ndp         = table + nondefOff;</a>
<a name="ln2995">          FT_ULong  numMappings = TT_NEXT_ULONG( ndp );</a>
<a name="ln2996">          FT_ULong  i, lastUni  = 0;</a>
<a name="ln2997"> </a>
<a name="ln2998"> </a>
<a name="ln2999">          /* numMappings * 4 &gt; (FT_ULong)( valid-&gt;limit - ndp ) ? */</a>
<a name="ln3000">          if ( numMappings &gt; ( (FT_ULong)( valid-&gt;limit - ndp ) ) / 4 )</a>
<a name="ln3001">            FT_INVALID_TOO_SHORT;</a>
<a name="ln3002"> </a>
<a name="ln3003">          for ( i = 0; i &lt; numMappings; ++i )</a>
<a name="ln3004">          {</a>
<a name="ln3005">            FT_ULong  uni = TT_NEXT_UINT24( ndp );</a>
<a name="ln3006">            FT_ULong  gid = TT_NEXT_USHORT( ndp );</a>
<a name="ln3007"> </a>
<a name="ln3008"> </a>
<a name="ln3009">            if ( uni &gt;= 0x110000UL )                     /* end of Unicode */</a>
<a name="ln3010">              FT_INVALID_DATA;</a>
<a name="ln3011"> </a>
<a name="ln3012">            if ( uni &lt; lastUni )</a>
<a name="ln3013">              FT_INVALID_DATA;</a>
<a name="ln3014"> </a>
<a name="ln3015">            lastUni = uni + 1U;</a>
<a name="ln3016"> </a>
<a name="ln3017">            if ( valid-&gt;level &gt;= FT_VALIDATE_TIGHT    &amp;&amp;</a>
<a name="ln3018">                 gid &gt;= TT_VALID_GLYPH_COUNT( valid ) )</a>
<a name="ln3019">              FT_INVALID_GLYPH_ID;</a>
<a name="ln3020">          }</a>
<a name="ln3021">        }</a>
<a name="ln3022">      }</a>
<a name="ln3023">    }</a>
<a name="ln3024"> </a>
<a name="ln3025">    return FT_Err_Ok;</a>
<a name="ln3026">  }</a>
<a name="ln3027"> </a>
<a name="ln3028"> </a>
<a name="ln3029">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln3030">  tt_cmap14_char_index( TT_CMap    cmap,</a>
<a name="ln3031">                        FT_UInt32  char_code )</a>
<a name="ln3032">  {</a>
<a name="ln3033">    FT_UNUSED( cmap );</a>
<a name="ln3034">    FT_UNUSED( char_code );</a>
<a name="ln3035"> </a>
<a name="ln3036">    /* This can't happen */</a>
<a name="ln3037">    return 0;</a>
<a name="ln3038">  }</a>
<a name="ln3039"> </a>
<a name="ln3040"> </a>
<a name="ln3041">  FT_CALLBACK_DEF( FT_UInt32 )</a>
<a name="ln3042">  tt_cmap14_char_next( TT_CMap     cmap,</a>
<a name="ln3043">                       FT_UInt32  *pchar_code )</a>
<a name="ln3044">  {</a>
<a name="ln3045">    FT_UNUSED( cmap );</a>
<a name="ln3046"> </a>
<a name="ln3047">    /* This can't happen */</a>
<a name="ln3048">    *pchar_code = 0;</a>
<a name="ln3049">    return 0;</a>
<a name="ln3050">  }</a>
<a name="ln3051"> </a>
<a name="ln3052"> </a>
<a name="ln3053">  FT_CALLBACK_DEF( FT_Error )</a>
<a name="ln3054">  tt_cmap14_get_info( TT_CMap       cmap,</a>
<a name="ln3055">                      TT_CMapInfo  *cmap_info )</a>
<a name="ln3056">  {</a>
<a name="ln3057">    FT_UNUSED( cmap );</a>
<a name="ln3058"> </a>
<a name="ln3059">    cmap_info-&gt;format   = 14;</a>
<a name="ln3060">    /* subtable 14 does not define a language field */</a>
<a name="ln3061">    cmap_info-&gt;language = 0xFFFFFFFFUL;</a>
<a name="ln3062"> </a>
<a name="ln3063">    return FT_Err_Ok;</a>
<a name="ln3064">  }</a>
<a name="ln3065"> </a>
<a name="ln3066"> </a>
<a name="ln3067">  static FT_UInt</a>
<a name="ln3068">  tt_cmap14_char_map_def_binary( FT_Byte    *base,</a>
<a name="ln3069">                                 FT_UInt32   char_code )</a>
<a name="ln3070">  {</a>
<a name="ln3071">    FT_UInt32  numRanges = TT_PEEK_ULONG( base );</a>
<a name="ln3072">    FT_UInt32  max, min;</a>
<a name="ln3073"> </a>
<a name="ln3074"> </a>
<a name="ln3075">    min = 0;</a>
<a name="ln3076">    max = numRanges;</a>
<a name="ln3077"> </a>
<a name="ln3078">    base += 4;</a>
<a name="ln3079"> </a>
<a name="ln3080">    /* binary search */</a>
<a name="ln3081">    while ( min &lt; max )</a>
<a name="ln3082">    {</a>
<a name="ln3083">      FT_UInt32  mid   = ( min + max ) &gt;&gt; 1;</a>
<a name="ln3084">      FT_Byte*   p     = base + 4 * mid;</a>
<a name="ln3085">      FT_ULong   start = TT_NEXT_UINT24( p );</a>
<a name="ln3086">      FT_UInt    cnt   = FT_NEXT_BYTE( p );</a>
<a name="ln3087"> </a>
<a name="ln3088"> </a>
<a name="ln3089">      if ( char_code &lt; start )</a>
<a name="ln3090">        max = mid;</a>
<a name="ln3091">      else if ( char_code &gt; start+cnt )</a>
<a name="ln3092">        min = mid + 1;</a>
<a name="ln3093">      else</a>
<a name="ln3094">        return TRUE;</a>
<a name="ln3095">    }</a>
<a name="ln3096"> </a>
<a name="ln3097">    return FALSE;</a>
<a name="ln3098">  }</a>
<a name="ln3099"> </a>
<a name="ln3100"> </a>
<a name="ln3101">  static FT_UInt</a>
<a name="ln3102">  tt_cmap14_char_map_nondef_binary( FT_Byte    *base,</a>
<a name="ln3103">                                    FT_UInt32   char_code )</a>
<a name="ln3104">  {</a>
<a name="ln3105">    FT_UInt32  numMappings = TT_PEEK_ULONG( base );</a>
<a name="ln3106">    FT_UInt32  max, min;</a>
<a name="ln3107"> </a>
<a name="ln3108"> </a>
<a name="ln3109">    min = 0;</a>
<a name="ln3110">    max = numMappings;</a>
<a name="ln3111"> </a>
<a name="ln3112">    base += 4;</a>
<a name="ln3113"> </a>
<a name="ln3114">    /* binary search */</a>
<a name="ln3115">    while ( min &lt; max )</a>
<a name="ln3116">    {</a>
<a name="ln3117">      FT_UInt32  mid = ( min + max ) &gt;&gt; 1;</a>
<a name="ln3118">      FT_Byte*   p   = base + 5 * mid;</a>
<a name="ln3119">      FT_UInt32  uni = (FT_UInt32)TT_NEXT_UINT24( p );</a>
<a name="ln3120"> </a>
<a name="ln3121"> </a>
<a name="ln3122">      if ( char_code &lt; uni )</a>
<a name="ln3123">        max = mid;</a>
<a name="ln3124">      else if ( char_code &gt; uni )</a>
<a name="ln3125">        min = mid + 1;</a>
<a name="ln3126">      else</a>
<a name="ln3127">        return TT_PEEK_USHORT( p );</a>
<a name="ln3128">    }</a>
<a name="ln3129"> </a>
<a name="ln3130">    return 0;</a>
<a name="ln3131">  }</a>
<a name="ln3132"> </a>
<a name="ln3133"> </a>
<a name="ln3134">  static FT_Byte*</a>
<a name="ln3135">  tt_cmap14_find_variant( FT_Byte    *base,</a>
<a name="ln3136">                          FT_UInt32   variantCode )</a>
<a name="ln3137">  {</a>
<a name="ln3138">    FT_UInt32  numVar = TT_PEEK_ULONG( base );</a>
<a name="ln3139">    FT_UInt32  max, min;</a>
<a name="ln3140"> </a>
<a name="ln3141"> </a>
<a name="ln3142">    min = 0;</a>
<a name="ln3143">    max = numVar;</a>
<a name="ln3144"> </a>
<a name="ln3145">    base += 4;</a>
<a name="ln3146"> </a>
<a name="ln3147">    /* binary search */</a>
<a name="ln3148">    while ( min &lt; max )</a>
<a name="ln3149">    {</a>
<a name="ln3150">      FT_UInt32  mid    = ( min + max ) &gt;&gt; 1;</a>
<a name="ln3151">      FT_Byte*   p      = base + 11 * mid;</a>
<a name="ln3152">      FT_ULong   varSel = TT_NEXT_UINT24( p );</a>
<a name="ln3153"> </a>
<a name="ln3154"> </a>
<a name="ln3155">      if ( variantCode &lt; varSel )</a>
<a name="ln3156">        max = mid;</a>
<a name="ln3157">      else if ( variantCode &gt; varSel )</a>
<a name="ln3158">        min = mid + 1;</a>
<a name="ln3159">      else</a>
<a name="ln3160">        return p;</a>
<a name="ln3161">    }</a>
<a name="ln3162"> </a>
<a name="ln3163">    return NULL;</a>
<a name="ln3164">  }</a>
<a name="ln3165"> </a>
<a name="ln3166"> </a>
<a name="ln3167">  FT_CALLBACK_DEF( FT_UInt )</a>
<a name="ln3168">  tt_cmap14_char_var_index( TT_CMap    cmap,</a>
<a name="ln3169">                            TT_CMap    ucmap,</a>
<a name="ln3170">                            FT_UInt32  charcode,</a>
<a name="ln3171">                            FT_UInt32  variantSelector )</a>
<a name="ln3172">  {</a>
<a name="ln3173">    FT_Byte*  p = tt_cmap14_find_variant( cmap-&gt;data + 6, variantSelector );</a>
<a name="ln3174">    FT_ULong  defOff;</a>
<a name="ln3175">    FT_ULong  nondefOff;</a>
<a name="ln3176"> </a>
<a name="ln3177"> </a>
<a name="ln3178">    if ( !p )</a>
<a name="ln3179">      return 0;</a>
<a name="ln3180"> </a>
<a name="ln3181">    defOff    = TT_NEXT_ULONG( p );</a>
<a name="ln3182">    nondefOff = TT_PEEK_ULONG( p );</a>
<a name="ln3183"> </a>
<a name="ln3184">    if ( defOff != 0                                                    &amp;&amp;</a>
<a name="ln3185">         tt_cmap14_char_map_def_binary( cmap-&gt;data + defOff, charcode ) )</a>
<a name="ln3186">    {</a>
<a name="ln3187">      /* This is the default variant of this charcode.  GID not stored */</a>
<a name="ln3188">      /* here; stored in the normal Unicode charmap instead.           */</a>
<a name="ln3189">      return ucmap-&gt;cmap.clazz-&gt;char_index( &amp;ucmap-&gt;cmap, charcode );</a>
<a name="ln3190">    }</a>
<a name="ln3191"> </a>
<a name="ln3192">    if ( nondefOff != 0 )</a>
<a name="ln3193">      return tt_cmap14_char_map_nondef_binary( cmap-&gt;data + nondefOff,</a>
<a name="ln3194">                                               charcode );</a>
<a name="ln3195"> </a>
<a name="ln3196">    return 0;</a>
<a name="ln3197">  }</a>
<a name="ln3198"> </a>
<a name="ln3199"> </a>
<a name="ln3200">  FT_CALLBACK_DEF( FT_Int )</a>
<a name="ln3201">  tt_cmap14_char_var_isdefault( TT_CMap    cmap,</a>
<a name="ln3202">                                FT_UInt32  charcode,</a>
<a name="ln3203">                                FT_UInt32  variantSelector )</a>
<a name="ln3204">  {</a>
<a name="ln3205">    FT_Byte*  p = tt_cmap14_find_variant( cmap-&gt;data + 6, variantSelector );</a>
<a name="ln3206">    FT_ULong  defOff;</a>
<a name="ln3207">    FT_ULong  nondefOff;</a>
<a name="ln3208"> </a>
<a name="ln3209"> </a>
<a name="ln3210">    if ( !p )</a>
<a name="ln3211">      return -1;</a>
<a name="ln3212"> </a>
<a name="ln3213">    defOff    = TT_NEXT_ULONG( p );</a>
<a name="ln3214">    nondefOff = TT_NEXT_ULONG( p );</a>
<a name="ln3215"> </a>
<a name="ln3216">    if ( defOff != 0                                                    &amp;&amp;</a>
<a name="ln3217">         tt_cmap14_char_map_def_binary( cmap-&gt;data + defOff, charcode ) )</a>
<a name="ln3218">      return 1;</a>
<a name="ln3219"> </a>
<a name="ln3220">    if ( nondefOff != 0                                            &amp;&amp;</a>
<a name="ln3221">         tt_cmap14_char_map_nondef_binary( cmap-&gt;data + nondefOff,</a>
<a name="ln3222">                                           charcode ) != 0         )</a>
<a name="ln3223">      return 0;</a>
<a name="ln3224"> </a>
<a name="ln3225">    return -1;</a>
<a name="ln3226">  }</a>
<a name="ln3227"> </a>
<a name="ln3228"> </a>
<a name="ln3229">  FT_CALLBACK_DEF( FT_UInt32* )</a>
<a name="ln3230">  tt_cmap14_variants( TT_CMap    cmap,</a>
<a name="ln3231">                      FT_Memory  memory )</a>
<a name="ln3232">  {</a>
<a name="ln3233">    TT_CMap14   cmap14 = (TT_CMap14)cmap;</a>
<a name="ln3234">    FT_UInt32   count  = cmap14-&gt;num_selectors;</a>
<a name="ln3235">    FT_Byte*    p      = cmap-&gt;data + 10;</a>
<a name="ln3236">    FT_UInt32*  result;</a>
<a name="ln3237">    FT_UInt32   i;</a>
<a name="ln3238"> </a>
<a name="ln3239"> </a>
<a name="ln3240">    if ( tt_cmap14_ensure( cmap14, ( count + 1 ), memory ) )</a>
<a name="ln3241">      return NULL;</a>
<a name="ln3242"> </a>
<a name="ln3243">    result = cmap14-&gt;results;</a>
<a name="ln3244">    for ( i = 0; i &lt; count; ++i )</a>
<a name="ln3245">    {</a>
<a name="ln3246">      result[i] = (FT_UInt32)TT_NEXT_UINT24( p );</a>
<a name="ln3247">      p        += 8;</a>
<a name="ln3248">    }</a>
<a name="ln3249">    result[i] = 0;</a>
<a name="ln3250"> </a>
<a name="ln3251">    return result;</a>
<a name="ln3252">  }</a>
<a name="ln3253"> </a>
<a name="ln3254"> </a>
<a name="ln3255">  FT_CALLBACK_DEF( FT_UInt32 * )</a>
<a name="ln3256">  tt_cmap14_char_variants( TT_CMap    cmap,</a>
<a name="ln3257">                           FT_Memory  memory,</a>
<a name="ln3258">                           FT_UInt32  charCode )</a>
<a name="ln3259">  {</a>
<a name="ln3260">    TT_CMap14   cmap14 = (TT_CMap14)  cmap;</a>
<a name="ln3261">    FT_UInt32   count  = cmap14-&gt;num_selectors;</a>
<a name="ln3262">    FT_Byte*    p      = cmap-&gt;data + 10;</a>
<a name="ln3263">    FT_UInt32*  q;</a>
<a name="ln3264"> </a>
<a name="ln3265"> </a>
<a name="ln3266">    if ( tt_cmap14_ensure( cmap14, ( count + 1 ), memory ) )</a>
<a name="ln3267">      return NULL;</a>
<a name="ln3268"> </a>
<a name="ln3269">    for ( q = cmap14-&gt;results; count &gt; 0; --count )</a>
<a name="ln3270">    {</a>
<a name="ln3271">      FT_UInt32  varSel    = TT_NEXT_UINT24( p );</a>
<a name="ln3272">      FT_ULong   defOff    = TT_NEXT_ULONG( p );</a>
<a name="ln3273">      FT_ULong   nondefOff = TT_NEXT_ULONG( p );</a>
<a name="ln3274"> </a>
<a name="ln3275"> </a>
<a name="ln3276">      if ( ( defOff != 0                                               &amp;&amp;</a>
<a name="ln3277">             tt_cmap14_char_map_def_binary( cmap-&gt;data + defOff,</a>
<a name="ln3278">                                            charCode )                 ) ||</a>
<a name="ln3279">           ( nondefOff != 0                                            &amp;&amp;</a>
<a name="ln3280">             tt_cmap14_char_map_nondef_binary( cmap-&gt;data + nondefOff,</a>
<a name="ln3281">                                               charCode ) != 0         ) )</a>
<a name="ln3282">      {</a>
<a name="ln3283">        q[0] = varSel;</a>
<a name="ln3284">        q++;</a>
<a name="ln3285">      }</a>
<a name="ln3286">    }</a>
<a name="ln3287">    q[0] = 0;</a>
<a name="ln3288"> </a>
<a name="ln3289">    return cmap14-&gt;results;</a>
<a name="ln3290">  }</a>
<a name="ln3291"> </a>
<a name="ln3292"> </a>
<a name="ln3293">  static FT_UInt</a>
<a name="ln3294">  tt_cmap14_def_char_count( FT_Byte  *p )</a>
<a name="ln3295">  {</a>
<a name="ln3296">    FT_UInt32  numRanges = (FT_UInt32)TT_NEXT_ULONG( p );</a>
<a name="ln3297">    FT_UInt    tot       = 0;</a>
<a name="ln3298"> </a>
<a name="ln3299"> </a>
<a name="ln3300">    p += 3;  /* point to the first `cnt' field */</a>
<a name="ln3301">    for ( ; numRanges &gt; 0; numRanges-- )</a>
<a name="ln3302">    {</a>
<a name="ln3303">      tot += 1 + p[0];</a>
<a name="ln3304">      p   += 4;</a>
<a name="ln3305">    }</a>
<a name="ln3306"> </a>
<a name="ln3307">    return tot;</a>
<a name="ln3308">  }</a>
<a name="ln3309"> </a>
<a name="ln3310"> </a>
<a name="ln3311">  static FT_UInt32*</a>
<a name="ln3312">  tt_cmap14_get_def_chars( TT_CMap    cmap,</a>
<a name="ln3313">                           FT_Byte*   p,</a>
<a name="ln3314">                           FT_Memory  memory )</a>
<a name="ln3315">  {</a>
<a name="ln3316">    TT_CMap14   cmap14 = (TT_CMap14) cmap;</a>
<a name="ln3317">    FT_UInt32   numRanges;</a>
<a name="ln3318">    FT_UInt     cnt;</a>
<a name="ln3319">    FT_UInt32*  q;</a>
<a name="ln3320"> </a>
<a name="ln3321"> </a>
<a name="ln3322">    cnt       = tt_cmap14_def_char_count( p );</a>
<a name="ln3323">    numRanges = (FT_UInt32)TT_NEXT_ULONG( p );</a>
<a name="ln3324"> </a>
<a name="ln3325">    if ( tt_cmap14_ensure( cmap14, ( cnt + 1 ), memory ) )</a>
<a name="ln3326">      return NULL;</a>
<a name="ln3327"> </a>
<a name="ln3328">    for ( q = cmap14-&gt;results; numRanges &gt; 0; --numRanges )</a>
<a name="ln3329">    {</a>
<a name="ln3330">      FT_UInt32  uni = (FT_UInt32)TT_NEXT_UINT24( p );</a>
<a name="ln3331"> </a>
<a name="ln3332"> </a>
<a name="ln3333">      cnt = FT_NEXT_BYTE( p ) + 1;</a>
<a name="ln3334">      do</a>
<a name="ln3335">      {</a>
<a name="ln3336">        q[0]  = uni;</a>
<a name="ln3337">        uni  += 1;</a>
<a name="ln3338">        q    += 1;</a>
<a name="ln3339"> </a>
<a name="ln3340">      } while ( --cnt != 0 );</a>
<a name="ln3341">    }</a>
<a name="ln3342">    q[0] = 0;</a>
<a name="ln3343"> </a>
<a name="ln3344">    return cmap14-&gt;results;</a>
<a name="ln3345">  }</a>
<a name="ln3346"> </a>
<a name="ln3347"> </a>
<a name="ln3348">  static FT_UInt32*</a>
<a name="ln3349">  tt_cmap14_get_nondef_chars( TT_CMap     cmap,</a>
<a name="ln3350">                              FT_Byte    *p,</a>
<a name="ln3351">                              FT_Memory   memory )</a>
<a name="ln3352">  {</a>
<a name="ln3353">    TT_CMap14   cmap14 = (TT_CMap14) cmap;</a>
<a name="ln3354">    FT_UInt32   numMappings;</a>
<a name="ln3355">    FT_UInt     i;</a>
<a name="ln3356">    FT_UInt32  *ret;</a>
<a name="ln3357"> </a>
<a name="ln3358"> </a>
<a name="ln3359">    numMappings = (FT_UInt32)TT_NEXT_ULONG( p );</a>
<a name="ln3360"> </a>
<a name="ln3361">    if ( tt_cmap14_ensure( cmap14, ( numMappings + 1 ), memory ) )</a>
<a name="ln3362">      return NULL;</a>
<a name="ln3363"> </a>
<a name="ln3364">    ret = cmap14-&gt;results;</a>
<a name="ln3365">    for ( i = 0; i &lt; numMappings; ++i )</a>
<a name="ln3366">    {</a>
<a name="ln3367">      ret[i] = (FT_UInt32)TT_NEXT_UINT24( p );</a>
<a name="ln3368">      p += 2;</a>
<a name="ln3369">    }</a>
<a name="ln3370">    ret[i] = 0;</a>
<a name="ln3371"> </a>
<a name="ln3372">    return ret;</a>
<a name="ln3373">  }</a>
<a name="ln3374"> </a>
<a name="ln3375"> </a>
<a name="ln3376">  FT_CALLBACK_DEF( FT_UInt32 * )</a>
<a name="ln3377">  tt_cmap14_variant_chars( TT_CMap    cmap,</a>
<a name="ln3378">                           FT_Memory  memory,</a>
<a name="ln3379">                           FT_UInt32  variantSelector )</a>
<a name="ln3380">  {</a>
<a name="ln3381">    FT_Byte    *p  = tt_cmap14_find_variant( cmap-&gt;data + 6,</a>
<a name="ln3382">                                             variantSelector );</a>
<a name="ln3383">    FT_Int      i;</a>
<a name="ln3384">    FT_ULong    defOff;</a>
<a name="ln3385">    FT_ULong    nondefOff;</a>
<a name="ln3386"> </a>
<a name="ln3387"> </a>
<a name="ln3388">    if ( !p )</a>
<a name="ln3389">      return NULL;</a>
<a name="ln3390"> </a>
<a name="ln3391">    defOff    = TT_NEXT_ULONG( p );</a>
<a name="ln3392">    nondefOff = TT_NEXT_ULONG( p );</a>
<a name="ln3393"> </a>
<a name="ln3394">    if ( defOff == 0 &amp;&amp; nondefOff == 0 )</a>
<a name="ln3395">      return NULL;</a>
<a name="ln3396"> </a>
<a name="ln3397">    if ( defOff == 0 )</a>
<a name="ln3398">      return tt_cmap14_get_nondef_chars( cmap, cmap-&gt;data + nondefOff,</a>
<a name="ln3399">                                         memory );</a>
<a name="ln3400">    else if ( nondefOff == 0 )</a>
<a name="ln3401">      return tt_cmap14_get_def_chars( cmap, cmap-&gt;data + defOff,</a>
<a name="ln3402">                                      memory );</a>
<a name="ln3403">    else</a>
<a name="ln3404">    {</a>
<a name="ln3405">      /* Both a default and a non-default glyph set?  That's probably not */</a>
<a name="ln3406">      /* good font design, but the spec allows for it...                  */</a>
<a name="ln3407">      TT_CMap14  cmap14 = (TT_CMap14) cmap;</a>
<a name="ln3408">      FT_UInt32  numRanges;</a>
<a name="ln3409">      FT_UInt32  numMappings;</a>
<a name="ln3410">      FT_UInt32  duni;</a>
<a name="ln3411">      FT_UInt32  dcnt;</a>
<a name="ln3412">      FT_UInt32  nuni;</a>
<a name="ln3413">      FT_Byte*   dp;</a>
<a name="ln3414">      FT_UInt    di, ni, k;</a>
<a name="ln3415"> </a>
<a name="ln3416">      FT_UInt32  *ret;</a>
<a name="ln3417"> </a>
<a name="ln3418"> </a>
<a name="ln3419">      p  = cmap-&gt;data + nondefOff;</a>
<a name="ln3420">      dp = cmap-&gt;data + defOff;</a>
<a name="ln3421"> </a>
<a name="ln3422">      numMappings = (FT_UInt32)TT_NEXT_ULONG( p );</a>
<a name="ln3423">      dcnt        = tt_cmap14_def_char_count( dp );</a>
<a name="ln3424">      numRanges   = (FT_UInt32)TT_NEXT_ULONG( dp );</a>
<a name="ln3425"> </a>
<a name="ln3426">      if ( numMappings == 0 )</a>
<a name="ln3427">        return tt_cmap14_get_def_chars( cmap, cmap-&gt;data + defOff,</a>
<a name="ln3428">                                        memory );</a>
<a name="ln3429">      if ( dcnt == 0 )</a>
<a name="ln3430">        return tt_cmap14_get_nondef_chars( cmap, cmap-&gt;data + nondefOff,</a>
<a name="ln3431">                                           memory );</a>
<a name="ln3432"> </a>
<a name="ln3433">      if ( tt_cmap14_ensure( cmap14, ( dcnt + numMappings + 1 ), memory ) )</a>
<a name="ln3434">        return NULL;</a>
<a name="ln3435"> </a>
<a name="ln3436">      ret  = cmap14-&gt;results;</a>
<a name="ln3437">      duni = (FT_UInt32)TT_NEXT_UINT24( dp );</a>
<a name="ln3438">      dcnt = FT_NEXT_BYTE( dp );</a>
<a name="ln3439">      di   = 1;</a>
<a name="ln3440">      nuni = (FT_UInt32)TT_NEXT_UINT24( p );</a>
<a name="ln3441">      p   += 2;</a>
<a name="ln3442">      ni   = 1;</a>
<a name="ln3443">      i    = 0;</a>
<a name="ln3444"> </a>
<a name="ln3445">      for ( ;; )</a>
<a name="ln3446">      {</a>
<a name="ln3447">        if ( nuni &gt; duni + dcnt )</a>
<a name="ln3448">        {</a>
<a name="ln3449">          for ( k = 0; k &lt;= dcnt; ++k )</a>
<a name="ln3450">            ret[i++] = duni + k;</a>
<a name="ln3451"> </a>
<a name="ln3452">          ++di;</a>
<a name="ln3453"> </a>
<a name="ln3454">          if ( di &gt; numRanges )</a>
<a name="ln3455">            break;</a>
<a name="ln3456"> </a>
<a name="ln3457">          duni = (FT_UInt32)TT_NEXT_UINT24( dp );</a>
<a name="ln3458">          dcnt = FT_NEXT_BYTE( dp );</a>
<a name="ln3459">        }</a>
<a name="ln3460">        else</a>
<a name="ln3461">        {</a>
<a name="ln3462">          if ( nuni &lt; duni )</a>
<a name="ln3463">            ret[i++] = nuni;</a>
<a name="ln3464">          /* If it is within the default range then ignore it -- */</a>
<a name="ln3465">          /* that should not have happened                       */</a>
<a name="ln3466">          ++ni;</a>
<a name="ln3467">          if ( ni &gt; numMappings )</a>
<a name="ln3468">            break;</a>
<a name="ln3469"> </a>
<a name="ln3470">          nuni = (FT_UInt32)TT_NEXT_UINT24( p );</a>
<a name="ln3471">          p += 2;</a>
<a name="ln3472">        }</a>
<a name="ln3473">      }</a>
<a name="ln3474"> </a>
<a name="ln3475">      if ( ni &lt;= numMappings )</a>
<a name="ln3476">      {</a>
<a name="ln3477">        /* If we get here then we have run out of all default ranges.   */</a>
<a name="ln3478">        /* We have read one non-default mapping which we haven't stored */</a>
<a name="ln3479">        /* and there may be others that need to be read.                */</a>
<a name="ln3480">        ret[i++] = nuni;</a>
<a name="ln3481">        while ( ni &lt; numMappings )</a>
<a name="ln3482">        {</a>
<a name="ln3483">          ret[i++] = (FT_UInt32)TT_NEXT_UINT24( p );</a>
<a name="ln3484">          p += 2;</a>
<a name="ln3485">          ++ni;</a>
<a name="ln3486">        }</a>
<a name="ln3487">      }</a>
<a name="ln3488">      else if ( di &lt;= numRanges )</a>
<a name="ln3489">      {</a>
<a name="ln3490">        /* If we get here then we have run out of all non-default     */</a>
<a name="ln3491">        /* mappings.  We have read one default range which we haven't */</a>
<a name="ln3492">        /* stored and there may be others that need to be read.       */</a>
<a name="ln3493">        for ( k = 0; k &lt;= dcnt; ++k )</a>
<a name="ln3494">          ret[i++] = duni + k;</a>
<a name="ln3495"> </a>
<a name="ln3496">        while ( di &lt; numRanges )</a>
<a name="ln3497">        {</a>
<a name="ln3498">          duni = (FT_UInt32)TT_NEXT_UINT24( dp );</a>
<a name="ln3499">          dcnt = FT_NEXT_BYTE( dp );</a>
<a name="ln3500"> </a>
<a name="ln3501">          for ( k = 0; k &lt;= dcnt; ++k )</a>
<a name="ln3502">            ret[i++] = duni + k;</a>
<a name="ln3503">          ++di;</a>
<a name="ln3504">        }</a>
<a name="ln3505">      }</a>
<a name="ln3506"> </a>
<a name="ln3507">      ret[i] = 0;</a>
<a name="ln3508"> </a>
<a name="ln3509">      return ret;</a>
<a name="ln3510">    }</a>
<a name="ln3511">  }</a>
<a name="ln3512"> </a>
<a name="ln3513"> </a>
<a name="ln3514">  FT_DEFINE_TT_CMAP(</a>
<a name="ln3515">    tt_cmap14_class_rec,</a>
<a name="ln3516">    sizeof ( TT_CMap14Rec ),</a>
<a name="ln3517"> </a>
<a name="ln3518">    (FT_CMap_InitFunc)     tt_cmap14_init,</a>
<a name="ln3519">    (FT_CMap_DoneFunc)     tt_cmap14_done,</a>
<a name="ln3520">    (FT_CMap_CharIndexFunc)tt_cmap14_char_index,</a>
<a name="ln3521">    (FT_CMap_CharNextFunc) tt_cmap14_char_next,</a>
<a name="ln3522"> </a>
<a name="ln3523">    /* Format 14 extension functions */</a>
<a name="ln3524">    (FT_CMap_CharVarIndexFunc)    tt_cmap14_char_var_index,</a>
<a name="ln3525">    (FT_CMap_CharVarIsDefaultFunc)tt_cmap14_char_var_isdefault,</a>
<a name="ln3526">    (FT_CMap_VariantListFunc)     tt_cmap14_variants,</a>
<a name="ln3527">    (FT_CMap_CharVariantListFunc) tt_cmap14_char_variants,</a>
<a name="ln3528">    (FT_CMap_VariantCharListFunc) tt_cmap14_variant_chars,</a>
<a name="ln3529"> </a>
<a name="ln3530">    14,</a>
<a name="ln3531">    (TT_CMap_ValidateFunc)tt_cmap14_validate,</a>
<a name="ln3532">    (TT_CMap_Info_GetFunc)tt_cmap14_get_info )</a>
<a name="ln3533"> </a>
<a name="ln3534">#endif /* TT_CONFIG_CMAP_FORMAT_14 */</a>
<a name="ln3535"> </a>
<a name="ln3536"> </a>
<a name="ln3537">#ifndef FT_CONFIG_OPTION_PIC</a>
<a name="ln3538"> </a>
<a name="ln3539">  static const TT_CMap_Class  tt_cmap_classes[] =</a>
<a name="ln3540">  {</a>
<a name="ln3541">#define TTCMAPCITEM( a )  &amp;a,</a>
<a name="ln3542">#include &quot;ttcmapc.h&quot;</a>
<a name="ln3543">    NULL,</a>
<a name="ln3544">  };</a>
<a name="ln3545"> </a>
<a name="ln3546">#else /*FT_CONFIG_OPTION_PIC*/</a>
<a name="ln3547"> </a>
<a name="ln3548">  void</a>
<a name="ln3549">  FT_Destroy_Class_tt_cmap_classes( FT_Library      library,</a>
<a name="ln3550">                                    TT_CMap_Class*  clazz )</a>
<a name="ln3551">  {</a>
<a name="ln3552">    FT_Memory  memory = library-&gt;memory;</a>
<a name="ln3553"> </a>
<a name="ln3554"> </a>
<a name="ln3555">    if ( clazz )</a>
<a name="ln3556">      FT_FREE( clazz );</a>
<a name="ln3557">  }</a>
<a name="ln3558"> </a>
<a name="ln3559"> </a>
<a name="ln3560">  FT_Error</a>
<a name="ln3561">  FT_Create_Class_tt_cmap_classes( FT_Library       library,</a>
<a name="ln3562">                                   TT_CMap_Class**  output_class )</a>
<a name="ln3563">  {</a>
<a name="ln3564">    TT_CMap_Class*     clazz  = NULL;</a>
<a name="ln3565">    TT_CMap_ClassRec*  recs;</a>
<a name="ln3566">    FT_Error           error;</a>
<a name="ln3567">    FT_Memory          memory = library-&gt;memory;</a>
<a name="ln3568"> </a>
<a name="ln3569">    int  i = 0;</a>
<a name="ln3570"> </a>
<a name="ln3571"> </a>
<a name="ln3572">#define TTCMAPCITEM( a ) i++;</a>
<a name="ln3573">#include &quot;ttcmapc.h&quot;</a>
<a name="ln3574"> </a>
<a name="ln3575">    /* allocate enough space for both the pointers */</a>
<a name="ln3576">    /* plus terminator and the class instances     */</a>
<a name="ln3577">    if ( FT_ALLOC( clazz, sizeof ( *clazz ) * ( i + 1 ) +</a>
<a name="ln3578">                          sizeof ( TT_CMap_ClassRec ) * i ) )</a>
<a name="ln3579">      return error;</a>
<a name="ln3580"> </a>
<a name="ln3581">    /* the location of the class instances follows the array of pointers */</a>
<a name="ln3582">    recs = (TT_CMap_ClassRec*)( (char*)clazz +</a>
<a name="ln3583">                                sizeof ( *clazz ) * ( i + 1 ) );</a>
<a name="ln3584">    i    = 0;</a>
<a name="ln3585"> </a>
<a name="ln3586">#undef TTCMAPCITEM</a>
<a name="ln3587">#define  TTCMAPCITEM( a )             \</a>
<a name="ln3588">    FT_Init_Class_ ## a( &amp;recs[i] );  \</a>
<a name="ln3589">    clazz[i] = &amp;recs[i];              \</a>
<a name="ln3590">    i++;</a>
<a name="ln3591">#include &quot;ttcmapc.h&quot;</a>
<a name="ln3592"> </a>
<a name="ln3593">    clazz[i] = NULL;</a>
<a name="ln3594"> </a>
<a name="ln3595">    *output_class = clazz;</a>
<a name="ln3596">    return FT_Err_Ok;</a>
<a name="ln3597">  }</a>
<a name="ln3598"> </a>
<a name="ln3599">#endif /*FT_CONFIG_OPTION_PIC*/</a>
<a name="ln3600"> </a>
<a name="ln3601"> </a>
<a name="ln3602">  /* parse the `cmap' table and build the corresponding TT_CMap objects */</a>
<a name="ln3603">  /* in the current face                                                */</a>
<a name="ln3604">  /*                                                                    */</a>
<a name="ln3605">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln3606">  tt_face_build_cmaps( TT_Face  face )</a>
<a name="ln3607">  {</a>
<a name="ln3608">    FT_Byte*           table = face-&gt;cmap_table;</a>
<a name="ln3609">    FT_Byte*           limit = table + face-&gt;cmap_size;</a>
<a name="ln3610">    FT_UInt volatile   num_cmaps;</a>
<a name="ln3611">    FT_Byte* volatile  p     = table;</a>
<a name="ln3612">    FT_Library         library = FT_FACE_LIBRARY( face );</a>
<a name="ln3613"> </a>
<a name="ln3614">    FT_UNUSED( library );</a>
<a name="ln3615"> </a>
<a name="ln3616"> </a>
<a name="ln3617">    if ( !p || p + 4 &gt; limit )</a>
<a name="ln3618">      return FT_THROW( Invalid_Table );</a>
<a name="ln3619"> </a>
<a name="ln3620">    /* only recognize format 0 */</a>
<a name="ln3621">    if ( TT_NEXT_USHORT( p ) != 0 )</a>
<a name="ln3622">    {</a>
<a name="ln3623">      FT_ERROR(( &quot;tt_face_build_cmaps:&quot;</a>
<a name="ln3624">                 &quot; unsupported `cmap' table format = %d\n&quot;,</a>
<a name="ln3625">                 TT_PEEK_USHORT( p - 2 ) ));</a>
<a name="ln3626">      return FT_THROW( Invalid_Table );</a>
<a name="ln3627">    }</a>
<a name="ln3628"> </a>
<a name="ln3629">    num_cmaps = TT_NEXT_USHORT( p );</a>
<a name="ln3630"> </a>
<a name="ln3631">    for ( ; num_cmaps &gt; 0 &amp;&amp; p + 8 &lt;= limit; num_cmaps-- )</a>
<a name="ln3632">    {</a>
<a name="ln3633">      FT_CharMapRec  charmap;</a>
<a name="ln3634">      FT_UInt32      offset;</a>
<a name="ln3635"> </a>
<a name="ln3636"> </a>
<a name="ln3637">      charmap.platform_id = TT_NEXT_USHORT( p );</a>
<a name="ln3638">      charmap.encoding_id = TT_NEXT_USHORT( p );</a>
<a name="ln3639">      charmap.face        = FT_FACE( face );</a>
<a name="ln3640">      charmap.encoding    = FT_ENCODING_NONE;  /* will be filled later */</a>
<a name="ln3641">      offset              = TT_NEXT_ULONG( p );</a>
<a name="ln3642"> </a>
<a name="ln3643">      if ( offset &amp;&amp; offset &lt;= face-&gt;cmap_size - 2 )</a>
<a name="ln3644">      {</a>
<a name="ln3645">        FT_Byte* volatile              cmap   = table + offset;</a>
<a name="ln3646">        volatile FT_UInt               format = TT_PEEK_USHORT( cmap );</a>
<a name="ln3647">        const TT_CMap_Class* volatile  pclazz = TT_CMAP_CLASSES_GET;</a>
<a name="ln3648">        TT_CMap_Class volatile         clazz;</a>
<a name="ln3649"> </a>
<a name="ln3650"> </a>
<a name="ln3651">        for ( ; *pclazz; pclazz++ )</a>
<a name="ln3652">        {</a>
<a name="ln3653">          clazz = *pclazz;</a>
<a name="ln3654">          if ( clazz-&gt;format == format )</a>
<a name="ln3655">          {</a>
<a name="ln3656">            volatile TT_ValidatorRec  valid;</a>
<a name="ln3657">            volatile FT_Error         error = FT_Err_Ok;</a>
<a name="ln3658"> </a>
<a name="ln3659"> </a>
<a name="ln3660">            ft_validator_init( FT_VALIDATOR( &amp;valid ), cmap, limit,</a>
<a name="ln3661">                               FT_VALIDATE_DEFAULT );</a>
<a name="ln3662"> </a>
<a name="ln3663">            valid.num_glyphs = (FT_UInt)face-&gt;max_profile.numGlyphs;</a>
<a name="ln3664"> </a>
<a name="ln3665">            if ( ft_setjmp( FT_VALIDATOR( &amp;valid )-&gt;jump_buffer) == 0 )</a>
<a name="ln3666">            {</a>
<a name="ln3667">              /* validate this cmap sub-table */</a>
<a name="ln3668">              error = clazz-&gt;validate( cmap, FT_VALIDATOR( &amp;valid ) );</a>
<a name="ln3669">            }</a>
<a name="ln3670"> </a>
<a name="ln3671">            if ( valid.validator.error == 0 )</a>
<a name="ln3672">            {</a>
<a name="ln3673">              FT_CMap  ttcmap;</a>
<a name="ln3674"> </a>
<a name="ln3675"> </a>
<a name="ln3676">              /* It might make sense to store the single variation         */</a>
<a name="ln3677">              /* selector cmap somewhere special.  But it would have to be */</a>
<a name="ln3678">              /* in the public FT_FaceRec, and we can't change that.       */</a>
<a name="ln3679"> </a>
<a name="ln3680">              if ( !FT_CMap_New( (FT_CMap_Class)clazz,</a>
<a name="ln3681">                                 cmap, &amp;charmap, &amp;ttcmap ) )</a>
<a name="ln3682">              {</a>
<a name="ln3683">                /* it is simpler to directly set `flags' than adding */</a>
<a name="ln3684">                /* a parameter to FT_CMap_New                        */</a>
<a name="ln3685">                ((TT_CMap)ttcmap)-&gt;flags = (FT_Int)error;</a>
<a name="ln3686">              }</a>
<a name="ln3687">            }</a>
<a name="ln3688">            else</a>
<a name="ln3689">            {</a>
<a name="ln3690">              FT_TRACE0(( &quot;tt_face_build_cmaps:&quot;</a>
<a name="ln3691">                          &quot; broken cmap sub-table ignored\n&quot; ));</a>
<a name="ln3692">            }</a>
<a name="ln3693">            break;</a>
<a name="ln3694">          }</a>
<a name="ln3695">        }</a>
<a name="ln3696"> </a>
<a name="ln3697">        if ( *pclazz == NULL )</a>
<a name="ln3698">        {</a>
<a name="ln3699">          FT_TRACE0(( &quot;tt_face_build_cmaps:&quot;</a>
<a name="ln3700">                      &quot; unsupported cmap sub-table ignored\n&quot; ));</a>
<a name="ln3701">        }</a>
<a name="ln3702">      }</a>
<a name="ln3703">    }</a>
<a name="ln3704"> </a>
<a name="ln3705">    return FT_Err_Ok;</a>
<a name="ln3706">  }</a>
<a name="ln3707"> </a>
<a name="ln3708"> </a>
<a name="ln3709">  FT_LOCAL( FT_Error )</a>
<a name="ln3710">  tt_get_cmap_info( FT_CharMap    charmap,</a>
<a name="ln3711">                    TT_CMapInfo  *cmap_info )</a>
<a name="ln3712">  {</a>
<a name="ln3713">    FT_CMap        cmap  = (FT_CMap)charmap;</a>
<a name="ln3714">    TT_CMap_Class  clazz = (TT_CMap_Class)cmap-&gt;clazz;</a>
<a name="ln3715"> </a>
<a name="ln3716"> </a>
<a name="ln3717">    return clazz-&gt;get_cmap_info( charmap, cmap_info );</a>
<a name="ln3718">  }</a>
<a name="ln3719"> </a>
<a name="ln3720"> </a>
<a name="ln3721">/* END */</a>

</code></pre>
<div class="balloon" rel="1389"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'cmap4->cur_charcode' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
