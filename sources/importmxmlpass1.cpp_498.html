
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>importmxmlpass1.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Linux Music Score Editor</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2015 Werner Schweer and others</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2.</a>
<a name="ln9">//</a>
<a name="ln10">//  This program is distributed in the hope that it will be useful,</a>
<a name="ln11">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">//  GNU General Public License for more details.</a>
<a name="ln14">//</a>
<a name="ln15">//  You should have received a copy of the GNU General Public License</a>
<a name="ln16">//  along with this program; if not, write to the Free Software</a>
<a name="ln17">//  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</a>
<a name="ln18">//=============================================================================</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;libmscore/box.h&quot;</a>
<a name="ln21">#include &quot;libmscore/chordrest.h&quot;</a>
<a name="ln22">#include &quot;libmscore/instrtemplate.h&quot;</a>
<a name="ln23">#include &quot;libmscore/measure.h&quot;</a>
<a name="ln24">#include &quot;libmscore/page.h&quot;</a>
<a name="ln25">#include &quot;libmscore/part.h&quot;</a>
<a name="ln26">#include &quot;libmscore/staff.h&quot;</a>
<a name="ln27">#include &quot;libmscore/stringdata.h&quot;</a>
<a name="ln28">#include &quot;libmscore/sym.h&quot;</a>
<a name="ln29">#include &quot;libmscore/symbol.h&quot;</a>
<a name="ln30">#include &quot;libmscore/timesig.h&quot;</a>
<a name="ln31">#include &quot;libmscore/style.h&quot;</a>
<a name="ln32">#include &quot;libmscore/spanner.h&quot;</a>
<a name="ln33">#include &quot;libmscore/bracketItem.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">#include &quot;importmxmllogger.h&quot;</a>
<a name="ln36">#include &quot;importmxmlnoteduration.h&quot;</a>
<a name="ln37">#include &quot;importmxmlpass1.h&quot;</a>
<a name="ln38">#include &quot;importmxmlpass2.h&quot;</a>
<a name="ln39">#include &quot;preferences.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">namespace Ms {</a>
<a name="ln42"> </a>
<a name="ln43">//---------------------------------------------------------</a>
<a name="ln44">//   allocateStaves</a>
<a name="ln45">//---------------------------------------------------------</a>
<a name="ln46"> </a>
<a name="ln47">/**</a>
<a name="ln48"> Allocate MuseScore staff to MusicXML voices.</a>
<a name="ln49"> For each staff, allocate at most VOICES voices to the staff.</a>
<a name="ln50"> */</a>
<a name="ln51"> </a>
<a name="ln52">// for regular (non-overlapping) voices:</a>
<a name="ln53">// 1) assign voice to a staff (allocateStaves)</a>
<a name="ln54">// 2) assign voice numbers (allocateVoices)</a>
<a name="ln55">// due to cross-staving, it is not a priori clear to which staff</a>
<a name="ln56">// a voice has to be assigned</a>
<a name="ln57">// allocate ordered by number of chordrests in the MusicXML voice</a>
<a name="ln58">//</a>
<a name="ln59">// for overlapping voices:</a>
<a name="ln60">// 1) assign voice to staves it is found in (allocateStaves)</a>
<a name="ln61">// 2) assign voice numbers (allocateVoices)</a>
<a name="ln62"> </a>
<a name="ln63">static void allocateStaves(VoiceList&amp; vcLst)</a>
<a name="ln64">      {</a>
<a name="ln65">      // initialize</a>
<a name="ln66">      int voicesAllocated[MAX_STAVES]; // number of voices allocated on each staff</a>
<a name="ln67">      for (int i = 0; i &lt; MAX_STAVES; ++i)</a>
<a name="ln68">            voicesAllocated[i] = 0;</a>
<a name="ln69"> </a>
<a name="ln70">      // handle regular (non-overlapping) voices</a>
<a name="ln71">      // note: outer loop executed vcLst.size() times, as each inner loop handles exactly one item</a>
<a name="ln72">      for (int i = 0; i &lt; vcLst.size(); ++i) {</a>
<a name="ln73">            // find the regular voice containing the highest number of chords and rests that has not been handled yet</a>
<a name="ln74">            int max = 0;</a>
<a name="ln75">            QString key;</a>
<a name="ln76">            for (VoiceList::const_iterator j = vcLst.constBegin(); j != vcLst.constEnd(); ++j) {</a>
<a name="ln77">                  if (!j.value().overlaps() &amp;&amp; j.value().numberChordRests() &gt; max &amp;&amp; j.value().staff() == -1) {</a>
<a name="ln78">                        max = j.value().numberChordRests();</a>
<a name="ln79">                        key = j.key();</a>
<a name="ln80">                        }</a>
<a name="ln81">                  }</a>
<a name="ln82">            if (key != &quot;&quot;) {</a>
<a name="ln83">                  int prefSt = vcLst.value(key).preferredStaff();</a>
<a name="ln84">                  if (voicesAllocated[prefSt] &lt; VOICES) {</a>
<a name="ln85">                        vcLst[key].setStaff(prefSt);</a>
<a name="ln86">                        voicesAllocated[prefSt]++;</a>
<a name="ln87">                        }</a>
<a name="ln88">                  else</a>
<a name="ln89">                        // out of voices: mark as used but not allocated</a>
<a name="ln90">                        vcLst[key].setStaff(-2);</a>
<a name="ln91">                  }</a>
<a name="ln92">            }</a>
<a name="ln93"> </a>
<a name="ln94">      // handle overlapping voices</a>
<a name="ln95">      // for every staff allocate remaining voices (if space allows)</a>
<a name="ln96">      // the ones with the highest number of chords and rests get allocated first</a>
<a name="ln97">      for (int h = 0; h &lt; MAX_STAVES; ++h) {</a>
<a name="ln98">            // note: middle loop executed vcLst.size() times, as each inner loop handles exactly one item</a>
<a name="ln99">            for (int i = 0; i &lt; vcLst.size(); ++i) {</a>
<a name="ln100">                  // find the overlapping voice containing the highest number of chords and rests that has not been handled yet</a>
<a name="ln101">                  int max = 0;</a>
<a name="ln102">                  QString key;</a>
<a name="ln103">                  for (VoiceList::const_iterator j = vcLst.constBegin(); j != vcLst.constEnd(); ++j) {</a>
<a name="ln104">                        if (j.value().overlaps() &amp;&amp; j.value().numberChordRests(h) &gt; max &amp;&amp; j.value().staffAlloc(h) == -1) {</a>
<a name="ln105">                              max = j.value().numberChordRests(h);</a>
<a name="ln106">                              key = j.key();</a>
<a name="ln107">                              }</a>
<a name="ln108">                        }</a>
<a name="ln109">                  if (key != &quot;&quot;) {</a>
<a name="ln110">                        int prefSt = h;</a>
<a name="ln111">                        if (voicesAllocated[prefSt] &lt; VOICES) {</a>
<a name="ln112">                              vcLst[key].setStaffAlloc(prefSt, 1);</a>
<a name="ln113">                              voicesAllocated[prefSt]++;</a>
<a name="ln114">                              }</a>
<a name="ln115">                        else</a>
<a name="ln116">                              // out of voices: mark as used but not allocated</a>
<a name="ln117">                              vcLst[key].setStaffAlloc(prefSt, -2);</a>
<a name="ln118">                        }</a>
<a name="ln119">                  }</a>
<a name="ln120">            }</a>
<a name="ln121">      }</a>
<a name="ln122"> </a>
<a name="ln123">//---------------------------------------------------------</a>
<a name="ln124">//   allocateVoices</a>
<a name="ln125">//---------------------------------------------------------</a>
<a name="ln126"> </a>
<a name="ln127">/**</a>
<a name="ln128"> Allocate MuseScore voice to MusicXML voices.</a>
<a name="ln129"> For each staff, the voices are number 1, 2, 3, 4</a>
<a name="ln130"> in the same order they are numbered in the MusicXML file.</a>
<a name="ln131"> */</a>
<a name="ln132"> </a>
<a name="ln133">static void allocateVoices(VoiceList&amp; vcLst)</a>
<a name="ln134">      {</a>
<a name="ln135">      int nextVoice[MAX_STAVES]; // number of voices allocated on each staff</a>
<a name="ln136">      for (int i = 0; i &lt; MAX_STAVES; ++i)</a>
<a name="ln137">            nextVoice[i] = 0;</a>
<a name="ln138">      // handle regular (non-overlapping) voices</a>
<a name="ln139">      // a voice is allocated on one specific staff</a>
<a name="ln140">      for (VoiceList::const_iterator i = vcLst.constBegin(); i != vcLst.constEnd(); ++i) {</a>
<a name="ln141">            int staff = i.value().staff();</a>
<a name="ln142">            QString key   = i.key();</a>
<a name="ln143">            if (staff &gt;= 0) {</a>
<a name="ln144">                  vcLst[key].setVoice(nextVoice[staff]);</a>
<a name="ln145">                  nextVoice[staff]++;</a>
<a name="ln146">                  }</a>
<a name="ln147">            }</a>
<a name="ln148">      // handle overlapping voices</a>
<a name="ln149">      // each voice may be in every staff</a>
<a name="ln150">      for (VoiceList::const_iterator i = vcLst.constBegin(); i != vcLst.constEnd(); ++i) {</a>
<a name="ln151">            for (int j = 0; j &lt; MAX_STAVES; ++j) {</a>
<a name="ln152">                  int staffAlloc = i.value().staffAlloc(j);</a>
<a name="ln153">                  QString key   = i.key();</a>
<a name="ln154">                  if (staffAlloc &gt;= 0) {</a>
<a name="ln155">                        vcLst[key].setVoice(j, nextVoice[j]);</a>
<a name="ln156">                        nextVoice[j]++;</a>
<a name="ln157">                        }</a>
<a name="ln158">                  }</a>
<a name="ln159">            }</a>
<a name="ln160">      }</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">//---------------------------------------------------------</a>
<a name="ln164">//   copyOverlapData</a>
<a name="ln165">//---------------------------------------------------------</a>
<a name="ln166"> </a>
<a name="ln167">/**</a>
<a name="ln168"> Copy the overlap data from the overlap detector to the voice list.</a>
<a name="ln169"> */</a>
<a name="ln170"> </a>
<a name="ln171">static void copyOverlapData(VoiceOverlapDetector&amp; vod, VoiceList&amp; vcLst)</a>
<a name="ln172">      {</a>
<a name="ln173">      for (VoiceList::const_iterator i = vcLst.constBegin(); i != vcLst.constEnd(); ++i) {</a>
<a name="ln174">            QString key = i.key();</a>
<a name="ln175">            if (vod.stavesOverlap(key))</a>
<a name="ln176">                  vcLst[key].setOverlap(true);</a>
<a name="ln177">            }</a>
<a name="ln178">      }</a>
<a name="ln179"> </a>
<a name="ln180">//---------------------------------------------------------</a>
<a name="ln181">//   MusicXMLParserPass1</a>
<a name="ln182">//---------------------------------------------------------</a>
<a name="ln183"> </a>
<a name="ln184">MusicXMLParserPass1::MusicXMLParserPass1(Score* score, MxmlLogger* logger)</a>
<a name="ln185">      : _divs(0), _score(score), _logger(logger)</a>
<a name="ln186">      {</a>
<a name="ln187">      // nothing</a>
<a name="ln188">      }</a>
<a name="ln189"> </a>
<a name="ln190">//---------------------------------------------------------</a>
<a name="ln191">//   initPartState</a>
<a name="ln192">//---------------------------------------------------------</a>
<a name="ln193"> </a>
<a name="ln194">/**</a>
<a name="ln195"> Initialize members as required for reading the MusicXML part element.</a>
<a name="ln196"> TODO: factor out part reading into a separate class</a>
<a name="ln197"> TODO: preferably use automatically initialized variables</a>
<a name="ln198"> Note that Qt automatically initializes new elements in QVector (tuplets).</a>
<a name="ln199"> */</a>
<a name="ln200"> </a>
<a name="ln201">void MusicXMLParserPass1::initPartState(const QString&amp; /* partId */)</a>
<a name="ln202">      {</a>
<a name="ln203">      _timeSigDura = Fraction(0, 0);       // invalid</a>
<a name="ln204">      _octaveShifts.clear();</a>
<a name="ln205">      _firstInstrSTime = Fraction(0, 1);</a>
<a name="ln206">      _firstInstrId = &quot;&quot;;</a>
<a name="ln207">      }</a>
<a name="ln208"> </a>
<a name="ln209">//---------------------------------------------------------</a>
<a name="ln210">//   determineMeasureLength</a>
<a name="ln211">//---------------------------------------------------------</a>
<a name="ln212"> </a>
<a name="ln213">/**</a>
<a name="ln214"> Determine the length in ticks of each measure in all parts.</a>
<a name="ln215"> Return false on error.</a>
<a name="ln216"> */</a>
<a name="ln217"> </a>
<a name="ln218">bool MusicXMLParserPass1::determineMeasureLength(QVector&lt;Fraction&gt;&amp; ml) const</a>
<a name="ln219">      {</a>
<a name="ln220">      ml.clear();</a>
<a name="ln221"> </a>
<a name="ln222">      // determine number of measures: max number of measures in any part</a>
<a name="ln223">      int nMeasures = 0;</a>
<a name="ln224">      foreach (const MusicXmlPart &amp;part, _parts) {</a>
<a name="ln225">            if (part.nMeasures() &gt; nMeasures)</a>
<a name="ln226">                  nMeasures = part.nMeasures();</a>
<a name="ln227">            }</a>
<a name="ln228"> </a>
<a name="ln229">      // determine max length of a specific measure in all parts</a>
<a name="ln230">      for (int i = 0; i &lt; nMeasures; ++i) {</a>
<a name="ln231">            Fraction maxMeasDur;</a>
<a name="ln232">            foreach (const MusicXmlPart &amp;part, _parts) {</a>
<a name="ln233">                  if (i &lt; part.nMeasures()) {</a>
<a name="ln234">                        Fraction measDurPartJ = part.measureDuration(i);</a>
<a name="ln235">                        if (measDurPartJ &gt; maxMeasDur)</a>
<a name="ln236">                              maxMeasDur = measDurPartJ;</a>
<a name="ln237">                        }</a>
<a name="ln238">                  }</a>
<a name="ln239">            //qDebug(&quot;determineMeasureLength() measure %d %s (%d)&quot;, i, qPrintable(maxMeasDur.print()), maxMeasDur.ticks());</a>
<a name="ln240">            ml.append(maxMeasDur);</a>
<a name="ln241">            }</a>
<a name="ln242">      return true;</a>
<a name="ln243">      }</a>
<a name="ln244"> </a>
<a name="ln245">//---------------------------------------------------------</a>
<a name="ln246">//   getVoiceList</a>
<a name="ln247">//---------------------------------------------------------</a>
<a name="ln248"> </a>
<a name="ln249">/**</a>
<a name="ln250"> Get the VoiceList for part \a id.</a>
<a name="ln251"> Return an empty VoiceList on error.</a>
<a name="ln252"> */</a>
<a name="ln253"> </a>
<a name="ln254">VoiceList MusicXMLParserPass1::getVoiceList(const QString id) const</a>
<a name="ln255">      {</a>
<a name="ln256">      if (_parts.contains(id))</a>
<a name="ln257">            return _parts.value(id).voicelist;</a>
<a name="ln258">      return VoiceList();</a>
<a name="ln259">      }</a>
<a name="ln260"> </a>
<a name="ln261">//---------------------------------------------------------</a>
<a name="ln262">//   getInstrList</a>
<a name="ln263">//---------------------------------------------------------</a>
<a name="ln264"> </a>
<a name="ln265">/**</a>
<a name="ln266"> Get the MusicXmlInstrList for part \a id.</a>
<a name="ln267"> Return an empty MusicXmlInstrList on error.</a>
<a name="ln268"> */</a>
<a name="ln269"> </a>
<a name="ln270">MusicXmlInstrList MusicXMLParserPass1::getInstrList(const QString id) const</a>
<a name="ln271">      {</a>
<a name="ln272">      if (_parts.contains(id))</a>
<a name="ln273">            return _parts.value(id)._instrList;</a>
<a name="ln274">      return MusicXmlInstrList();</a>
<a name="ln275">      }</a>
<a name="ln276"> </a>
<a name="ln277">//---------------------------------------------------------</a>
<a name="ln278">//   determineMeasureLength</a>
<a name="ln279">//---------------------------------------------------------</a>
<a name="ln280"> </a>
<a name="ln281">/**</a>
<a name="ln282"> Set default notehead, line and stem direction</a>
<a name="ln283"> for instrument \a instrId in part \a id.</a>
<a name="ln284"> */</a>
<a name="ln285"> </a>
<a name="ln286">void MusicXMLParserPass1::setDrumsetDefault(const QString&amp; id,</a>
<a name="ln287">                                            const QString&amp; instrId,</a>
<a name="ln288">                                            const NoteHead::Group hg,</a>
<a name="ln289">                                            const int line,</a>
<a name="ln290">                                            const Direction sd)</a>
<a name="ln291">      {</a>
<a name="ln292">      if (_drumsets.contains(id)</a>
<a name="ln293">          &amp;&amp; _drumsets[id].contains(instrId)) {</a>
<a name="ln294">            _drumsets[id][instrId].notehead = hg;</a>
<a name="ln295">            _drumsets[id][instrId].line = line;</a>
<a name="ln296">            _drumsets[id][instrId].stemDirection = sd;</a>
<a name="ln297">            }</a>
<a name="ln298">      }</a>
<a name="ln299"> </a>
<a name="ln300"> </a>
<a name="ln301">//---------------------------------------------------------</a>
<a name="ln302">//   determineStaffMoveVoice</a>
<a name="ln303">//---------------------------------------------------------</a>
<a name="ln304"> </a>
<a name="ln305">/**</a>
<a name="ln306"> For part \a id, determine MuseScore (ms) staffmove, track and voice from MusicXML (mx) staff and voice</a>
<a name="ln307"> MusicXML staff is 0 for the first staff, 1 for the second.</a>
<a name="ln308"> Note: track is the first track of the ms staff in the score, add ms voice for elements in a voice</a>
<a name="ln309"> Return true if OK, false on error</a>
<a name="ln310"> TODO: finalize</a>
<a name="ln311"> */</a>
<a name="ln312"> </a>
<a name="ln313">bool MusicXMLParserPass1::determineStaffMoveVoice(const QString&amp; id, const int mxStaff, const QString&amp; mxVoice,</a>
<a name="ln314">                                                  int&amp; msMove, int&amp; msTrack, int&amp; msVoice) const</a>
<a name="ln315">      {</a>
<a name="ln316">      VoiceList voicelist = getVoiceList(id);</a>
<a name="ln317">      msMove = 0; // TODO</a>
<a name="ln318">      msTrack = 0; // TODO</a>
<a name="ln319">      msVoice = 0; // TODO</a>
<a name="ln320"> </a>
<a name="ln321"> </a>
<a name="ln322">      // Musicxml voices are counted for all staffs of an</a>
<a name="ln323">      // instrument. They are not limited. In mscore voices are associated</a>
<a name="ln324">      // with a staff. Every staff can have at most VOICES voices.</a>
<a name="ln325"> </a>
<a name="ln326">      // The following lines map musicXml voices to mscore voices.</a>
<a name="ln327">      // If a voice crosses two staffs, this is expressed with the</a>
<a name="ln328">      // &quot;move&quot; parameter in mscore.</a>
<a name="ln329"> </a>
<a name="ln330">      // Musicxml voices are unique within a part, but not across parts.</a>
<a name="ln331"> </a>
<a name="ln332">      //qDebug(&quot;voice mapper before: voice='%s' staff=%d&quot;, qPrintable(mxVoice), mxStaff);</a>
<a name="ln333">      int s; // staff mapped by voice mapper</a>
<a name="ln334">      int v; // voice mapped by voice mapper</a>
<a name="ln335">      if (voicelist.value(mxVoice).overlaps()) {</a>
<a name="ln336">            // for overlapping voices, the staff does not change</a>
<a name="ln337">            // and the voice is mapped and staff-dependent</a>
<a name="ln338">            s = mxStaff;</a>
<a name="ln339">            v = voicelist.value(mxVoice).voice(s);</a>
<a name="ln340">            }</a>
<a name="ln341">      else {</a>
<a name="ln342">            // for non-overlapping voices, both staff and voice are</a>
<a name="ln343">            // set by the voice mapper</a>
<a name="ln344">            s = voicelist.value(mxVoice).staff();</a>
<a name="ln345">            v = voicelist.value(mxVoice).voice();</a>
<a name="ln346">            }</a>
<a name="ln347"> </a>
<a name="ln348">      //qDebug(&quot;voice mapper mapped: s=%d v=%d&quot;, s, v);</a>
<a name="ln349">      if (s &lt; 0 || v &lt; 0) {</a>
<a name="ln350">            qDebug(&quot;too many voices (staff=%d voice='%s' -&gt; s=%d v=%d)&quot;,</a>
<a name="ln351">                   mxStaff + 1, qPrintable(mxVoice), s, v);</a>
<a name="ln352">            return false;</a>
<a name="ln353">            }</a>
<a name="ln354"> </a>
<a name="ln355">      msMove  = mxStaff - s;</a>
<a name="ln356">      msVoice = v;</a>
<a name="ln357"> </a>
<a name="ln358">      // make score-relative instead on part-relative</a>
<a name="ln359">      Part* part = _partMap.value(id);</a>
<a name="ln360">      Q_ASSERT(part);</a>
<a name="ln361">      int scoreRelStaff = _score-&gt;staffIdx(part); // zero-based number of parts first staff in the score</a>
<a name="ln362">      msTrack = (scoreRelStaff + s) * VOICES;</a>
<a name="ln363"> </a>
<a name="ln364">      //qDebug(&quot;voice mapper after: scoreRelStaff=%d partRelStaff=%d msMove=%d msTrack=%d msVoice=%d&quot;,</a>
<a name="ln365">      //       scoreRelStaff, s, msMove, msTrack, msVoice);</a>
<a name="ln366">      // note: relStaff is the staff number relative to the parts first staff</a>
<a name="ln367">      //       voice is the voice number in the staff</a>
<a name="ln368"> </a>
<a name="ln369">      return true;</a>
<a name="ln370">      }</a>
<a name="ln371"> </a>
<a name="ln372">//---------------------------------------------------------</a>
<a name="ln373">//   hasPart</a>
<a name="ln374">//---------------------------------------------------------</a>
<a name="ln375"> </a>
<a name="ln376">/**</a>
<a name="ln377"> Check if part \a id is found.</a>
<a name="ln378"> */</a>
<a name="ln379"> </a>
<a name="ln380">bool MusicXMLParserPass1::hasPart(const QString&amp; id) const</a>
<a name="ln381">      {</a>
<a name="ln382">      return _parts.contains(id);</a>
<a name="ln383">      }</a>
<a name="ln384"> </a>
<a name="ln385">//---------------------------------------------------------</a>
<a name="ln386">//   trackForPart</a>
<a name="ln387">//---------------------------------------------------------</a>
<a name="ln388"> </a>
<a name="ln389">/**</a>
<a name="ln390"> Return the (score relative) track number for the first staff of part \a id.</a>
<a name="ln391"> */</a>
<a name="ln392"> </a>
<a name="ln393">int MusicXMLParserPass1::trackForPart(const QString&amp; id) const</a>
<a name="ln394">      {</a>
<a name="ln395">      Part* part = _partMap.value(id);</a>
<a name="ln396">      Q_ASSERT(part);</a>
<a name="ln397">      int scoreRelStaff = _score-&gt;staffIdx(part); // zero-based number of parts first staff in the score</a>
<a name="ln398">      return scoreRelStaff * VOICES;</a>
<a name="ln399">      }</a>
<a name="ln400"> </a>
<a name="ln401">//---------------------------------------------------------</a>
<a name="ln402">//   getMeasureStart</a>
<a name="ln403">//---------------------------------------------------------</a>
<a name="ln404"> </a>
<a name="ln405">/**</a>
<a name="ln406"> Return the measure start time for measure \a i.</a>
<a name="ln407"> */</a>
<a name="ln408"> </a>
<a name="ln409">Fraction MusicXMLParserPass1::getMeasureStart(const int i) const</a>
<a name="ln410">      {</a>
<a name="ln411">      if (0 &lt;= i &amp;&amp; i &lt; _measureStart.size())</a>
<a name="ln412">            return _measureStart.at(i);</a>
<a name="ln413">      else</a>
<a name="ln414">            return Fraction(0, 0);       // invalid</a>
<a name="ln415">      }</a>
<a name="ln416"> </a>
<a name="ln417">//---------------------------------------------------------</a>
<a name="ln418">//   octaveShift</a>
<a name="ln419">//---------------------------------------------------------</a>
<a name="ln420"> </a>
<a name="ln421">/**</a>
<a name="ln422"> Return the octave shift for part \a id in \a staff at \a f.</a>
<a name="ln423"> */</a>
<a name="ln424"> </a>
<a name="ln425">int MusicXMLParserPass1::octaveShift(const QString&amp; id, const int staff, const Fraction f) const</a>
<a name="ln426">      {</a>
<a name="ln427">      if (_parts.contains(id))</a>
<a name="ln428">            return _parts.value(id).octaveShift(staff, f);</a>
<a name="ln429"> </a>
<a name="ln430">      return 0;</a>
<a name="ln431">      }</a>
<a name="ln432"> </a>
<a name="ln433">//---------------------------------------------------------</a>
<a name="ln434">//   skipLogCurrElem</a>
<a name="ln435">//---------------------------------------------------------</a>
<a name="ln436"> </a>
<a name="ln437">/**</a>
<a name="ln438"> Skip the current element, log debug as info.</a>
<a name="ln439"> */</a>
<a name="ln440"> </a>
<a name="ln441">void MusicXMLParserPass1::skipLogCurrElem()</a>
<a name="ln442">      {</a>
<a name="ln443">      _logger-&gt;logDebugInfo(QString(&quot;skipping '%1'&quot;).arg(_e.name().toString()), &amp;_e);</a>
<a name="ln444">      _e.skipCurrentElement();</a>
<a name="ln445">      }</a>
<a name="ln446"> </a>
<a name="ln447">//---------------------------------------------------------</a>
<a name="ln448">//   addBreak</a>
<a name="ln449">//---------------------------------------------------------</a>
<a name="ln450"> </a>
<a name="ln451">static void addBreak(Score* const score, MeasureBase* const mb, const LayoutBreak::Type type)</a>
<a name="ln452">      {</a>
<a name="ln453">      LayoutBreak* lb = new LayoutBreak(score);</a>
<a name="ln454">      lb-&gt;setLayoutBreakType(type);</a>
<a name="ln455">      mb-&gt;add(lb);</a>
<a name="ln456">      }</a>
<a name="ln457"> </a>
<a name="ln458">//---------------------------------------------------------</a>
<a name="ln459">//   addBreakToPreviousMeasureBase</a>
<a name="ln460">//---------------------------------------------------------</a>
<a name="ln461"> </a>
<a name="ln462">static void addBreakToPreviousMeasureBase(Score* const score, MeasureBase* const mb, const LayoutBreak::Type type)</a>
<a name="ln463">      {</a>
<a name="ln464">      const auto pm = mb-&gt;prev();</a>
<a name="ln465">      if (pm &amp;&amp; preferences.getBool(PREF_IMPORT_MUSICXML_IMPORTBREAKS))</a>
<a name="ln466">            addBreak(score, pm, type);</a>
<a name="ln467">      }</a>
<a name="ln468"> </a>
<a name="ln469">//---------------------------------------------------------</a>
<a name="ln470">//   addText</a>
<a name="ln471">//---------------------------------------------------------</a>
<a name="ln472"> </a>
<a name="ln473">/**</a>
<a name="ln474"> Add text \a strTxt to VBox \a vbx using Tid \a stl.</a>
<a name="ln475"> */</a>
<a name="ln476"> </a>
<a name="ln477">static void addText(VBox* vbx, Score* s, const QString strTxt, const Tid stl)</a>
<a name="ln478">      {</a>
<a name="ln479">      if (!strTxt.isEmpty()) {</a>
<a name="ln480">            Text* text = new Text(s, stl);</a>
<a name="ln481">            text-&gt;setXmlText(strTxt);</a>
<a name="ln482">            vbx-&gt;add(text);</a>
<a name="ln483">            }</a>
<a name="ln484">      }</a>
<a name="ln485"> </a>
<a name="ln486">//---------------------------------------------------------</a>
<a name="ln487">//   addText2</a>
<a name="ln488">//---------------------------------------------------------</a>
<a name="ln489"> </a>
<a name="ln490">/**</a>
<a name="ln491"> Add text \a strTxt to VBox \a vbx using Tid \a stl.</a>
<a name="ln492"> Also sets Align and Yoff.</a>
<a name="ln493"> */</a>
<a name="ln494"> </a>
<a name="ln495">static void addText2(VBox* vbx, Score* s, const QString strTxt, const Tid stl, const Align align, const double yoffs)</a>
<a name="ln496">      {</a>
<a name="ln497">      if (!strTxt.isEmpty()) {</a>
<a name="ln498">            Text* text = new Text(s, stl);</a>
<a name="ln499">            text-&gt;setXmlText(strTxt);</a>
<a name="ln500">            text-&gt;setAlign(align);</a>
<a name="ln501">            text-&gt;setOffset(QPointF(0.0, yoffs));</a>
<a name="ln502">            vbx-&gt;add(text);</a>
<a name="ln503">            }</a>
<a name="ln504">      }</a>
<a name="ln505"> </a>
<a name="ln506">//---------------------------------------------------------</a>
<a name="ln507">//   findYMinYMaxInWords</a>
<a name="ln508">//---------------------------------------------------------</a>
<a name="ln509"> </a>
<a name="ln510">static void findYMinYMaxInWords(const std::vector&lt;const CreditWords*&gt;&amp; words, int&amp; miny, int&amp; maxy)</a>
<a name="ln511">      {</a>
<a name="ln512">      miny = 0;</a>
<a name="ln513">      maxy = 0;</a>
<a name="ln514"> </a>
<a name="ln515">      if (words.empty())</a>
<a name="ln516">            return;</a>
<a name="ln517"> </a>
<a name="ln518">      miny = words.at(0)-&gt;defaultY;</a>
<a name="ln519">      maxy = words.at(0)-&gt;defaultY;</a>
<a name="ln520">      for (const auto w : words) {</a>
<a name="ln521">            if (w-&gt;defaultY &lt; miny) miny = w-&gt;defaultY;</a>
<a name="ln522">            if (w-&gt;defaultY &gt; maxy) maxy = w-&gt;defaultY;</a>
<a name="ln523">            }</a>
<a name="ln524">      }</a>
<a name="ln525"> </a>
<a name="ln526">//---------------------------------------------------------</a>
<a name="ln527">//   alignForCreditWords</a>
<a name="ln528">//---------------------------------------------------------</a>
<a name="ln529"> </a>
<a name="ln530">static Align alignForCreditWords(const CreditWords* const w, const int pageWidth)</a>
<a name="ln531">      {</a>
<a name="ln532">      Align align = Align::LEFT;</a>
<a name="ln533">      if (w-&gt;defaultX &gt; (pageWidth / 3)) {</a>
<a name="ln534">            if (w-&gt;defaultX &lt; (2 * pageWidth / 3))</a>
<a name="ln535">                  align = Align::HCENTER;</a>
<a name="ln536">            else</a>
<a name="ln537">                  align = Align::RIGHT;</a>
<a name="ln538">            }</a>
<a name="ln539">      return align;</a>
<a name="ln540">      }</a>
<a name="ln541"> </a>
<a name="ln542">//---------------------------------------------------------</a>
<a name="ln543">//   createAndAddVBoxForCreditWords</a>
<a name="ln544">//---------------------------------------------------------</a>
<a name="ln545"> </a>
<a name="ln546">static VBox* createAndAddVBoxForCreditWords(Score* const score, const int miny = 0, const int maxy = 75)</a>
<a name="ln547">      {</a>
<a name="ln548">      auto vbox = new VBox(score);</a>
<a name="ln549">      qreal vboxHeight = 10;                         // default height in tenths</a>
<a name="ln550">      double diff = maxy - miny;                     // calculate height in tenths</a>
<a name="ln551">      if (diff &gt; vboxHeight)                         // and size is reasonable</a>
<a name="ln552">            vboxHeight = diff;</a>
<a name="ln553">      vboxHeight /= 10;                              // height in spatium</a>
<a name="ln554">      vboxHeight += 2.5;                             // guesstimated correction for last line</a>
<a name="ln555"> </a>
<a name="ln556">      vbox-&gt;setBoxHeight(Spatium(vboxHeight));</a>
<a name="ln557">      score-&gt;measures()-&gt;add(vbox);</a>
<a name="ln558">      return vbox;</a>
<a name="ln559">      }</a>
<a name="ln560"> </a>
<a name="ln561">//---------------------------------------------------------</a>
<a name="ln562">//   addCreditWords</a>
<a name="ln563">//---------------------------------------------------------</a>
<a name="ln564"> </a>
<a name="ln565">static VBox* addCreditWords(Score* const score, const CreditWordsList&amp; crWords,</a>
<a name="ln566">                            const int pageNr, const QSize pageSize,</a>
<a name="ln567">                            const bool top)</a>
<a name="ln568">      {</a>
<a name="ln569">      VBox* vbox = nullptr;</a>
<a name="ln570"> </a>
<a name="ln571">      std::vector&lt;const CreditWords*&gt; topwords;</a>
<a name="ln572">      for (const auto w : crWords) {</a>
<a name="ln573">            if (w-&gt;page == pageNr) {</a>
<a name="ln574">                  if ((w-&gt;defaultY &gt; (pageSize.height() / 2)) == top)</a>
<a name="ln575">                        topwords.push_back(w);</a>
<a name="ln576">                  }</a>
<a name="ln577">            }</a>
<a name="ln578"> </a>
<a name="ln579">      int miny = 0;</a>
<a name="ln580">      int maxy = 0;</a>
<a name="ln581">      findYMinYMaxInWords(topwords, miny, maxy);</a>
<a name="ln582"> </a>
<a name="ln583">      for (const auto w : topwords) {</a>
<a name="ln584">            const auto align = alignForCreditWords(w, pageSize.width());</a>
<a name="ln585">            double yoffs = (maxy - w-&gt;defaultY) * score-&gt;spatium() / 10;</a>
<a name="ln586">            if (!vbox)</a>
<a name="ln587">                  vbox = createAndAddVBoxForCreditWords(score, miny, maxy);</a>
<a name="ln588">            addText2(vbox, score, w-&gt;words, Tid::DEFAULT, align, yoffs);</a>
<a name="ln589">            }</a>
<a name="ln590"> </a>
<a name="ln591">      return vbox;</a>
<a name="ln592">      }</a>
<a name="ln593"> </a>
<a name="ln594">//---------------------------------------------------------</a>
<a name="ln595">//   createMeasuresAndVboxes</a>
<a name="ln596">//---------------------------------------------------------</a>
<a name="ln597"> </a>
<a name="ln598">static void createDefaultHeader(Score* const score)</a>
<a name="ln599">      {</a>
<a name="ln600">      QString strTitle;</a>
<a name="ln601">      QString strSubTitle;</a>
<a name="ln602">      QString strComposer;</a>
<a name="ln603">      QString strPoet;</a>
<a name="ln604">      QString strTranslator;</a>
<a name="ln605"> </a>
<a name="ln606">      if (!(score-&gt;metaTag(&quot;movementTitle&quot;).isEmpty() &amp;&amp; score-&gt;metaTag(&quot;workTitle&quot;).isEmpty())) {</a>
<a name="ln607">            strTitle = score-&gt;metaTag(&quot;movementTitle&quot;);</a>
<a name="ln608">            if (strTitle.isEmpty())</a>
<a name="ln609">                  strTitle = score-&gt;metaTag(&quot;workTitle&quot;);</a>
<a name="ln610">            }</a>
<a name="ln611">      if (!(score-&gt;metaTag(&quot;movementNumber&quot;).isEmpty() &amp;&amp; score-&gt;metaTag(&quot;workNumber&quot;).isEmpty())) {</a>
<a name="ln612">            strSubTitle = score-&gt;metaTag(&quot;movementNumber&quot;);</a>
<a name="ln613">            if (strSubTitle.isEmpty())</a>
<a name="ln614">                  strSubTitle = score-&gt;metaTag(&quot;workNumber&quot;);</a>
<a name="ln615">            }</a>
<a name="ln616">      QString metaComposer = score-&gt;metaTag(&quot;composer&quot;);</a>
<a name="ln617">      QString metaPoet = score-&gt;metaTag(&quot;poet&quot;);</a>
<a name="ln618">      QString metaTranslator = score-&gt;metaTag(&quot;translator&quot;);</a>
<a name="ln619">      if (!metaComposer.isEmpty()) strComposer = metaComposer;</a>
<a name="ln620">      if (metaPoet.isEmpty()) metaPoet = score-&gt;metaTag(&quot;lyricist&quot;);</a>
<a name="ln621">      if (!metaPoet.isEmpty()) strPoet = metaPoet;</a>
<a name="ln622">      if (!metaTranslator.isEmpty()) strTranslator = metaTranslator;</a>
<a name="ln623"> </a>
<a name="ln624">      const auto vbox = createAndAddVBoxForCreditWords(score);</a>
<a name="ln625">      addText(vbox, score, strTitle.toHtmlEscaped(),      Tid::TITLE);</a>
<a name="ln626">      addText(vbox, score, strSubTitle.toHtmlEscaped(),   Tid::SUBTITLE);</a>
<a name="ln627">      addText(vbox, score, strComposer.toHtmlEscaped(),   Tid::COMPOSER);</a>
<a name="ln628">      addText(vbox, score, strPoet.toHtmlEscaped(),       Tid::POET);</a>
<a name="ln629">      addText(vbox, score, strTranslator.toHtmlEscaped(), Tid::TRANSLATOR);</a>
<a name="ln630">      }</a>
<a name="ln631"> </a>
<a name="ln632">//---------------------------------------------------------</a>
<a name="ln633">//   createMeasuresAndVboxes</a>
<a name="ln634">//---------------------------------------------------------</a>
<a name="ln635"> </a>
<a name="ln636">/**</a>
<a name="ln637"> Create required measures with correct number, start tick and length for Score \a score.</a>
<a name="ln638"> */</a>
<a name="ln639"> </a>
<a name="ln640">static void createMeasuresAndVboxes(Score* const score,</a>
<a name="ln641">                                    const QVector&lt;Fraction&gt;&amp; ml, const QVector&lt;Fraction&gt;&amp; ms,</a>
<a name="ln642">                                    const std::set&lt;int&gt;&amp; systemStartMeasureNrs,</a>
<a name="ln643">                                    const std::set&lt;int&gt;&amp; pageStartMeasureNrs,</a>
<a name="ln644">                                    const CreditWordsList&amp; crWords,</a>
<a name="ln645">                                    const QSize pageSize)</a>
<a name="ln646">      {</a>
<a name="ln647">      if (crWords.empty())</a>
<a name="ln648">            createDefaultHeader(score);</a>
<a name="ln649"> </a>
<a name="ln650">      int pageNr = 0;</a>
<a name="ln651">      for (int i = 0; i &lt; ml.size(); ++i) {</a>
<a name="ln652"> </a>
<a name="ln653">            VBox* vbox = nullptr;</a>
<a name="ln654"> </a>
<a name="ln655">            // add a header vbox if the this measure is the first in the score or the first on a new page</a>
<a name="ln656">            if (pageStartMeasureNrs.count(i) || i == 0) {</a>
<a name="ln657">                  ++pageNr;</a>
<a name="ln658">                  vbox = addCreditWords(score, crWords, pageNr, pageSize, true);</a>
<a name="ln659">                  }</a>
<a name="ln660"> </a>
<a name="ln661">            // create and add the measure</a>
<a name="ln662">            Measure* measure  = new Measure(score);</a>
<a name="ln663">            measure-&gt;setTick(ms.at(i));</a>
<a name="ln664">            measure-&gt;setTicks(ml.at(i));</a>
<a name="ln665">            measure-&gt;setNo(i);</a>
<a name="ln666">            score-&gt;measures()-&gt;add(measure);</a>
<a name="ln667"> </a>
<a name="ln668">            // add break to previous measure or vbox</a>
<a name="ln669">            MeasureBase* mb = vbox;</a>
<a name="ln670">            if (!mb) mb = measure;</a>
<a name="ln671">            if (pageStartMeasureNrs.count(i))</a>
<a name="ln672">                  addBreakToPreviousMeasureBase(score, mb, LayoutBreak::Type::PAGE);</a>
<a name="ln673">            else if (systemStartMeasureNrs.count(i))</a>
<a name="ln674">                  addBreakToPreviousMeasureBase(score, mb, LayoutBreak::Type::LINE);</a>
<a name="ln675"> </a>
<a name="ln676">            // add a footer vbox if the next measure is on a new page or end of score has been reached</a>
<a name="ln677">            if (pageStartMeasureNrs.count(i+1) || i == (ml.size() - 1))</a>
<a name="ln678">                  addCreditWords(score, crWords, pageNr, pageSize, false);</a>
<a name="ln679">            }</a>
<a name="ln680">      }</a>
<a name="ln681"> </a>
<a name="ln682">//---------------------------------------------------------</a>
<a name="ln683">//   determineMeasureStart</a>
<a name="ln684">//---------------------------------------------------------</a>
<a name="ln685"> </a>
<a name="ln686">/**</a>
<a name="ln687"> Determine the start ticks of each measure</a>
<a name="ln688"> i.e. the sum of all previous measures length</a>
<a name="ln689"> or start tick measure equals start tick previous measure plus length previous measure</a>
<a name="ln690"> */</a>
<a name="ln691"> </a>
<a name="ln692">static void determineMeasureStart(const QVector&lt;Fraction&gt;&amp; ml, QVector&lt;Fraction&gt;&amp; ms)</a>
<a name="ln693">      {</a>
<a name="ln694">      ms.resize(ml.size());</a>
<a name="ln695">      if (!(ms.size() &gt; 0))</a>
<a name="ln696">            return;  // no parts read</a>
<a name="ln697"> </a>
<a name="ln698">      // first measure starts at t = 0</a>
<a name="ln699">      ms[0] = Fraction(0, 1);</a>
<a name="ln700">      // all others start at start time previous measure plus length previous measure</a>
<a name="ln701">      for (int i = 1; i &lt; ml.size(); i++)</a>
<a name="ln702">            ms[i] = ms.at(i - 1) + ml.at(i - 1);</a>
<a name="ln703">      //for (int i = 0; i &lt; ms.size(); i++)</a>
<a name="ln704">      //      qDebug(&quot;measurestart ms[%d] %s&quot;, i + 1, qPrintable(ms.at(i).print()));</a>
<a name="ln705">      }</a>
<a name="ln706"> </a>
<a name="ln707">//---------------------------------------------------------</a>
<a name="ln708">//   dumpCredits</a>
<a name="ln709">//---------------------------------------------------------</a>
<a name="ln710"> </a>
<a name="ln711">static void dumpCredits(const CreditWordsList&amp; credits)</a>
<a name="ln712">      {</a>
<a name="ln713">#if 0</a>
<a name="ln714">      for (const auto w : credits) {</a>
<a name="ln715">            qDebug(&quot;credit-words pg=%d defx=%g defy=%g just=%s hal=%s val=%s words='%s'&quot;,</a>
<a name="ln716">                   w-&gt;page,</a>
<a name="ln717">                   w-&gt;defaultX,</a>
<a name="ln718">                   w-&gt;defaultY,</a>
<a name="ln719">                   qPrintable(w-&gt;justify),</a>
<a name="ln720">                   qPrintable(w-&gt;hAlign),</a>
<a name="ln721">                   qPrintable(w-&gt;vAlign),</a>
<a name="ln722">                   qPrintable(w-&gt;words));</a>
<a name="ln723">            }</a>
<a name="ln724">#else</a>
<a name="ln725">      Q_UNUSED(credits);</a>
<a name="ln726">#endif</a>
<a name="ln727">      }</a>
<a name="ln728"> </a>
<a name="ln729">//---------------------------------------------------------</a>
<a name="ln730">//   fixupSigmap</a>
<a name="ln731">//---------------------------------------------------------</a>
<a name="ln732"> </a>
<a name="ln733">/**</a>
<a name="ln734"> To enable error handling in pass2, ensure sigmap contains a valid entry at tick = 0.</a>
<a name="ln735"> Required by TimeSigMap::tickValues(), called (indirectly) by Segment::add().</a>
<a name="ln736"> */</a>
<a name="ln737"> </a>
<a name="ln738">static void fixupSigmap(MxmlLogger* logger, Score* score, const QVector&lt;Fraction&gt;&amp; measureLength)</a>
<a name="ln739">      {</a>
<a name="ln740">      auto it = score-&gt;sigmap()-&gt;find(0);</a>
<a name="ln741"> </a>
<a name="ln742">      if (it == score-&gt;sigmap()-&gt;end()) {</a>
<a name="ln743">            // no valid timesig at tick = 0</a>
<a name="ln744">            logger-&gt;logDebugInfo(&quot;no valid time signature at tick = 0&quot;);</a>
<a name="ln745">            // use length of first measure instead time signature.</a>
<a name="ln746">            // if there is no first measure, we probably don't care,</a>
<a name="ln747">            // but set a default anyway.</a>
<a name="ln748">            Fraction tsig = measureLength.isEmpty() ? Fraction(4, 4) : measureLength.at(0);</a>
<a name="ln749">            score-&gt;sigmap()-&gt;add(0, tsig);</a>
<a name="ln750">            }</a>
<a name="ln751">      }</a>
<a name="ln752"> </a>
<a name="ln753">//---------------------------------------------------------</a>
<a name="ln754">//   parse</a>
<a name="ln755">//---------------------------------------------------------</a>
<a name="ln756"> </a>
<a name="ln757">/**</a>
<a name="ln758"> Parse MusicXML in \a device and extract pass 1 data.</a>
<a name="ln759"> */</a>
<a name="ln760"> </a>
<a name="ln761">Score::FileError MusicXMLParserPass1::parse(QIODevice* device)</a>
<a name="ln762">      {</a>
<a name="ln763">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::parse device&quot;);</a>
<a name="ln764">      _parts.clear();</a>
<a name="ln765">      _e.setDevice(device);</a>
<a name="ln766">      auto res = parse();</a>
<a name="ln767">      if (res != Score::FileError::FILE_NO_ERROR)</a>
<a name="ln768">            return res;</a>
<a name="ln769"> </a>
<a name="ln770">      // Determine the start tick of each measure in the part</a>
<a name="ln771">      determineMeasureLength(_measureLength);</a>
<a name="ln772">      determineMeasureStart(_measureLength, _measureStart);</a>
<a name="ln773">      // Fixup timesig at tick = 0 if necessary</a>
<a name="ln774">      fixupSigmap(_logger, _score, _measureLength);</a>
<a name="ln775">      // Debug: dump the credits read</a>
<a name="ln776">      dumpCredits(_credits);</a>
<a name="ln777">      // Create the measures</a>
<a name="ln778">      createMeasuresAndVboxes(_score, _measureLength, _measureStart, _systemStartMeasureNrs, _pageStartMeasureNrs, _credits, _pageSize);</a>
<a name="ln779"> </a>
<a name="ln780">      return res;</a>
<a name="ln781">      }</a>
<a name="ln782"> </a>
<a name="ln783">//---------------------------------------------------------</a>
<a name="ln784">//   parse</a>
<a name="ln785">//---------------------------------------------------------</a>
<a name="ln786"> </a>
<a name="ln787">/**</a>
<a name="ln788"> Start the parsing process, after verifying the top-level node is score-partwise</a>
<a name="ln789"> */</a>
<a name="ln790"> </a>
<a name="ln791">Score::FileError MusicXMLParserPass1::parse()</a>
<a name="ln792">      {</a>
<a name="ln793">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::parse&quot;);</a>
<a name="ln794"> </a>
<a name="ln795">      bool found = false;</a>
<a name="ln796">      while (_e.readNextStartElement()) {</a>
<a name="ln797">            if (_e.name() == &quot;score-partwise&quot;) {</a>
<a name="ln798">                  found = true;</a>
<a name="ln799">                  scorePartwise();</a>
<a name="ln800">                  }</a>
<a name="ln801">            else {</a>
<a name="ln802">                  _logger-&gt;logError(QString(&quot;this is not a MusicXML score-partwise file (top-level node '%1')&quot;)</a>
<a name="ln803">                                    .arg(_e.name().toString()), &amp;_e);</a>
<a name="ln804">                  _e.skipCurrentElement();</a>
<a name="ln805">                  return Score::FileError::FILE_BAD_FORMAT;</a>
<a name="ln806">                  }</a>
<a name="ln807">            }</a>
<a name="ln808"> </a>
<a name="ln809">      if (!found) {</a>
<a name="ln810">            _logger-&gt;logError(&quot;this is not a MusicXML score-partwise file, node &lt;score-partwise&gt; not found&quot;, &amp;_e);</a>
<a name="ln811">            return Score::FileError::FILE_BAD_FORMAT;</a>
<a name="ln812">            }</a>
<a name="ln813"> </a>
<a name="ln814">      return Score::FileError::FILE_NO_ERROR;</a>
<a name="ln815">      }</a>
<a name="ln816"> </a>
<a name="ln817">//---------------------------------------------------------</a>
<a name="ln818">//   allStaffGroupsIdentical</a>
<a name="ln819">//---------------------------------------------------------</a>
<a name="ln820"> </a>
<a name="ln821">/**</a>
<a name="ln822"> Return true if all staves in Part \a p have the same staff group</a>
<a name="ln823"> */</a>
<a name="ln824"> </a>
<a name="ln825">static bool allStaffGroupsIdentical(Part const* const p)</a>
<a name="ln826">      {</a>
<a name="ln827">      for (int i = 1; i &lt; p-&gt;nstaves(); ++i) {</a>
<a name="ln828">            if (p-&gt;staff(0)-&gt;constStaffType(Fraction(0,1))-&gt;group() != p-&gt;staff(i)-&gt;constStaffType(Fraction(0,1))-&gt;group())</a>
<a name="ln829">                  return false;</a>
<a name="ln830">            }</a>
<a name="ln831">      return true;</a>
<a name="ln832">      }</a>
<a name="ln833"> </a>
<a name="ln834">//---------------------------------------------------------</a>
<a name="ln835">//   scorePartwise</a>
<a name="ln836">//---------------------------------------------------------</a>
<a name="ln837"> </a>
<a name="ln838">/**</a>
<a name="ln839"> Parse the MusicXML top-level (XPath /score-partwise) node.</a>
<a name="ln840"> */</a>
<a name="ln841"> </a>
<a name="ln842">void MusicXMLParserPass1::scorePartwise()</a>
<a name="ln843">      {</a>
<a name="ln844">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;score-partwise&quot;);</a>
<a name="ln845">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::scorePartwise&quot;, &amp;_e);</a>
<a name="ln846"> </a>
<a name="ln847">      MusicXmlPartGroupList partGroupList;</a>
<a name="ln848"> </a>
<a name="ln849">      while (_e.readNextStartElement()) {</a>
<a name="ln850">            if (_e.name() == &quot;part&quot;)</a>
<a name="ln851">                  part();</a>
<a name="ln852">            else if (_e.name() == &quot;part-list&quot;)</a>
<a name="ln853">                  partList(partGroupList);</a>
<a name="ln854">            else if (_e.name() == &quot;work&quot;) {</a>
<a name="ln855">                  while (_e.readNextStartElement()) {</a>
<a name="ln856">                        if (_e.name() == &quot;work-number&quot;)</a>
<a name="ln857">                              _score-&gt;setMetaTag(&quot;workNumber&quot;, _e.readElementText());</a>
<a name="ln858">                        else if (_e.name() == &quot;work-title&quot;)</a>
<a name="ln859">                              _score-&gt;setMetaTag(&quot;workTitle&quot;, _e.readElementText());</a>
<a name="ln860">                        else</a>
<a name="ln861">                              skipLogCurrElem();</a>
<a name="ln862">                        }</a>
<a name="ln863">                  }</a>
<a name="ln864">            else if (_e.name() == &quot;identification&quot;)</a>
<a name="ln865">                  identification();</a>
<a name="ln866">            else if (_e.name() == &quot;defaults&quot;)</a>
<a name="ln867">                  defaults();</a>
<a name="ln868">            else if (_e.name() == &quot;movement-number&quot;)</a>
<a name="ln869">                  _score-&gt;setMetaTag(&quot;movementNumber&quot;, _e.readElementText());</a>
<a name="ln870">            else if (_e.name() == &quot;movement-title&quot;)</a>
<a name="ln871">                  _score-&gt;setMetaTag(&quot;movementTitle&quot;, _e.readElementText());</a>
<a name="ln872">            else if (_e.name() == &quot;credit&quot;)</a>
<a name="ln873">                  credit(_credits);</a>
<a name="ln874">            else</a>
<a name="ln875">                  skipLogCurrElem();</a>
<a name="ln876">            }</a>
<a name="ln877"> </a>
<a name="ln878">      // add brackets where required</a>
<a name="ln879"> </a>
<a name="ln880">      /*</a>
<a name="ln881">       qDebug(&quot;partGroupList&quot;);</a>
<a name="ln882">       for (size_t i = 0; i &lt; partGroupList.size(); i++) {</a>
<a name="ln883">       MusicXmlPartGroup* pg = partGroupList[i];</a>
<a name="ln884">       qDebug(&quot;part-group span %d start %d type %hhd barlinespan %d&quot;,</a>
<a name="ln885">       pg-&gt;span, pg-&gt;start, pg-&gt;type, pg-&gt;barlineSpan);</a>
<a name="ln886">       }</a>
<a name="ln887">       */</a>
<a name="ln888"> </a>
<a name="ln889">      // set of (typically multi-staff) parts containing one or more explicit brackets</a>
<a name="ln890">      // spanning only that part: these won't get an implicit brace later</a>
<a name="ln891">      // e.g. a two-staff piano part with an explicit brace</a>
<a name="ln892">      QSet&lt;Part const* const&gt; partSet;</a>
<a name="ln893"> </a>
<a name="ln894">      // handle the explicit brackets</a>
<a name="ln895">      const QList&lt;Part*&gt;&amp; il = _score-&gt;parts();</a>
<a name="ln896">      for (size_t i = 0; i &lt; partGroupList.size(); i++) {</a>
<a name="ln897">            MusicXmlPartGroup* pg = partGroupList[i];</a>
<a name="ln898">            // add part to set</a>
<a name="ln899">            if (pg-&gt;span == 1)</a>
<a name="ln900">                  partSet &lt;&lt; il.at(pg-&gt;start);</a>
<a name="ln901">            // determine span in staves</a>
<a name="ln902">            int stavesSpan = 0;</a>
<a name="ln903">            for (int j = 0; j &lt; pg-&gt;span; j++)</a>
<a name="ln904">                  stavesSpan += il.at(pg-&gt;start + j)-&gt;nstaves();</a>
<a name="ln905">            // add bracket and set the span</a>
<a name="ln906">            // TODO: use group-symbol default-x to determine horizontal order of brackets</a>
<a name="ln907">            Staff* staff = il.at(pg-&gt;start)-&gt;staff(0);</a>
<a name="ln908">            if (pg-&gt;type == BracketType::NO_BRACKET)</a>
<a name="ln909">                  staff-&gt;setBracketType(0, BracketType::NO_BRACKET);</a>
<a name="ln910">            else {</a>
<a name="ln911">                  staff-&gt;addBracket(new BracketItem(staff-&gt;score(), pg-&gt;type, stavesSpan));</a>
<a name="ln912">                  }</a>
<a name="ln913">            if (pg-&gt;barlineSpan)</a>
<a name="ln914">                  staff-&gt;setBarLineSpan(pg-&gt;span);</a>
<a name="ln915">            }</a>
<a name="ln916"> </a>
<a name="ln917">      // handle the implicit brackets:</a>
<a name="ln918">      // multi-staff parts w/o explicit brackets get a brace</a>
<a name="ln919">      foreach(Part const* const p, il) {</a>
<a name="ln920">            if (p-&gt;nstaves() &gt; 1 &amp;&amp; !partSet.contains(p)) {</a>
<a name="ln921">                  p-&gt;staff(0)-&gt;addBracket(new BracketItem(p-&gt;score(), BracketType::BRACE, p-&gt;nstaves()));</a>
<a name="ln922">                  if (allStaffGroupsIdentical(p)) {</a>
<a name="ln923">                        // span only if the same types</a>
<a name="ln924">                        p-&gt;staff(0)-&gt;setBarLineSpan(p-&gt;nstaves());</a>
<a name="ln925">                        }</a>
<a name="ln926">                  }</a>
<a name="ln927">            }</a>
<a name="ln928">      }</a>
<a name="ln929"> </a>
<a name="ln930">//---------------------------------------------------------</a>
<a name="ln931">//   identification</a>
<a name="ln932">//---------------------------------------------------------</a>
<a name="ln933"> </a>
<a name="ln934">/**</a>
<a name="ln935"> Parse the /score-partwise/identification node:</a>
<a name="ln936"> read the metadata.</a>
<a name="ln937"> */</a>
<a name="ln938"> </a>
<a name="ln939">void MusicXMLParserPass1::identification()</a>
<a name="ln940">      {</a>
<a name="ln941">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;identification&quot;);</a>
<a name="ln942">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::identification&quot;, &amp;_e);</a>
<a name="ln943"> </a>
<a name="ln944">      while (_e.readNextStartElement()) {</a>
<a name="ln945">            if (_e.name() == &quot;creator&quot;) {</a>
<a name="ln946">                  // type is an arbitrary label</a>
<a name="ln947">                  QString strType = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln948">                  _score-&gt;setMetaTag(strType, _e.readElementText());</a>
<a name="ln949">                  }</a>
<a name="ln950">            else if (_e.name() == &quot;rights&quot;)</a>
<a name="ln951">                  _score-&gt;setMetaTag(&quot;copyright&quot;, _e.readElementText());</a>
<a name="ln952">            else if (_e.name() == &quot;encoding&quot;) {</a>
<a name="ln953">                  // TODO</a>
<a name="ln954">                  _e.skipCurrentElement(); // skip but don't log</a>
<a name="ln955">                  // _score-&gt;setMetaTag(&quot;encoding&quot;, _e.readElementText()); works with DOM but not with pull parser</a>
<a name="ln956">                  // temporarily fake the encoding tag (compliant with DOM parser) to help the autotester</a>
<a name="ln957">                  if (MScore::debugMode)</a>
<a name="ln958">                        _score-&gt;setMetaTag(&quot;encoding&quot;, &quot;MuseScore 0.7.02007-09-10&quot;);</a>
<a name="ln959">                  }</a>
<a name="ln960">            else if (_e.name() == &quot;source&quot;)</a>
<a name="ln961">                  _score-&gt;setMetaTag(&quot;source&quot;, _e.readElementText());</a>
<a name="ln962">            else if (_e.name() == &quot;miscellaneous&quot;)</a>
<a name="ln963">                  // TODO</a>
<a name="ln964">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln965">            else</a>
<a name="ln966">                  skipLogCurrElem();</a>
<a name="ln967">            }</a>
<a name="ln968">      }</a>
<a name="ln969"> </a>
<a name="ln970">//---------------------------------------------------------</a>
<a name="ln971">//   text2syms</a>
<a name="ln972">//---------------------------------------------------------</a>
<a name="ln973"> </a>
<a name="ln974">/**</a>
<a name="ln975"> Convert SMuFL code points to MuseScore &lt;sym&gt;...&lt;/sym&gt;</a>
<a name="ln976"> */</a>
<a name="ln977"> </a>
<a name="ln978">static QString text2syms(const QString&amp; t)</a>
<a name="ln979">      {</a>
<a name="ln980">      //QTime time;</a>
<a name="ln981">      //time.start();</a>
<a name="ln982"> </a>
<a name="ln983">      // first create a map from symbol (Unicode) text to symId</a>
<a name="ln984">      // note that this takes about 1 msec on a Core i5,</a>
<a name="ln985">      // caching does not gain much</a>
<a name="ln986"> </a>
<a name="ln987">      ScoreFont* sf = ScoreFont::fallbackFont();</a>
<a name="ln988">      QMap&lt;QString, SymId&gt; map;</a>
<a name="ln989">      int maxStringSize = 0;        // maximum string size found</a>
<a name="ln990"> </a>
<a name="ln991">      for (int i = int(SymId::noSym); i &lt; int(SymId::lastSym); ++i) {</a>
<a name="ln992">            SymId id((SymId(i)));</a>
<a name="ln993">            QString string(sf-&gt;toString(id));</a>
<a name="ln994">            // insert all syms except space to prevent matching all regular spaces</a>
<a name="ln995">            if (id != SymId::space)</a>
<a name="ln996">                  map.insert(string, id);</a>
<a name="ln997">            if (string.size() &gt; maxStringSize)</a>
<a name="ln998">                  maxStringSize = string.size();</a>
<a name="ln999">            }</a>
<a name="ln1000">      //qDebug(&quot;text2syms map count %d maxsz %d filling time elapsed: %d ms&quot;,</a>
<a name="ln1001">      //       map.size(), maxStringSize, time.elapsed());</a>
<a name="ln1002"> </a>
<a name="ln1003">      // then look for matches</a>
<a name="ln1004">      QString in = t;</a>
<a name="ln1005">      QString res;</a>
<a name="ln1006"> </a>
<a name="ln1007">      while (in != &quot;&quot;) {</a>
<a name="ln1008">            // try to find the largest match possible</a>
<a name="ln1009">            int maxMatch = qMin(in.size(), maxStringSize);</a>
<a name="ln1010">            QString sym;</a>
<a name="ln1011">            while (maxMatch &gt; 0) {</a>
<a name="ln1012">                  QString toBeMatched = in.left(maxMatch);</a>
<a name="ln1013">                  if (map.contains(toBeMatched)) {</a>
<a name="ln1014">                        sym = Sym::id2name(map.value(toBeMatched));</a>
<a name="ln1015">                        break;</a>
<a name="ln1016">                        }</a>
<a name="ln1017">                  maxMatch--;</a>
<a name="ln1018">                  }</a>
<a name="ln1019">            if (maxMatch &gt; 0) {</a>
<a name="ln1020">                  // found a match, add sym to res and remove match from string in</a>
<a name="ln1021">                  res += &quot;&lt;sym&gt;&quot;;</a>
<a name="ln1022">                  res += sym;</a>
<a name="ln1023">                  res += &quot;&lt;/sym&gt;&quot;;</a>
<a name="ln1024">                  in.remove(0, maxMatch);</a>
<a name="ln1025">                  }</a>
<a name="ln1026">            else {</a>
<a name="ln1027">                  // not found, move one char from res to in</a>
<a name="ln1028">                  res += in.left(1);</a>
<a name="ln1029">                  in.remove(0, 1);</a>
<a name="ln1030">                  }</a>
<a name="ln1031">            }</a>
<a name="ln1032"> </a>
<a name="ln1033">      //qDebug(&quot;text2syms total time elapsed: %d ms, res '%s'&quot;, time.elapsed(), qPrintable(res));</a>
<a name="ln1034">      return res;</a>
<a name="ln1035">      }</a>
<a name="ln1036"> </a>
<a name="ln1037">//---------------------------------------------------------</a>
<a name="ln1038">//   decodeEntities</a>
<a name="ln1039">//---------------------------------------------------------</a>
<a name="ln1040"> </a>
<a name="ln1041">/**</a>
<a name="ln1042"> Decode &amp;#...; in string \a src into UNICODE (utf8) character.</a>
<a name="ln1043"> */</a>
<a name="ln1044"> </a>
<a name="ln1045">static QString decodeEntities( const QString&amp; src )</a>
<a name="ln1046">      {</a>
<a name="ln1047">      QString ret(src);</a>
<a name="ln1048">      QRegExp re(&quot;&amp;#([0-9]+);&quot;);</a>
<a name="ln1049">      re.setMinimal(true);</a>
<a name="ln1050"> </a>
<a name="ln1051">      int pos = 0;</a>
<a name="ln1052">      while ( (pos = re.indexIn(src, pos)) != -1 ) {</a>
<a name="ln1053">            ret = ret.replace(re.cap(0), QChar(re.cap(1).toInt(0,10)));</a>
<a name="ln1054">            pos += re.matchedLength();</a>
<a name="ln1055">            }</a>
<a name="ln1056">      return ret;</a>
<a name="ln1057">      }</a>
<a name="ln1058"> </a>
<a name="ln1059">//---------------------------------------------------------</a>
<a name="ln1060">//   nextPartOfFormattedString</a>
<a name="ln1061">//---------------------------------------------------------</a>
<a name="ln1062"> </a>
<a name="ln1063">// TODO: probably should be shared between pass 1 and 2</a>
<a name="ln1064"> </a>
<a name="ln1065">/**</a>
<a name="ln1066"> Read the next part of a MusicXML formatted string and convert to MuseScore internal encoding.</a>
<a name="ln1067"> */</a>
<a name="ln1068"> </a>
<a name="ln1069">static QString nextPartOfFormattedString(QXmlStreamReader&amp; e)</a>
<a name="ln1070">      {</a>
<a name="ln1071">      //QString lang       = e.attribute(QString(&quot;xml:lang&quot;), &quot;it&quot;);</a>
<a name="ln1072">      QString fontWeight = e.attributes().value(&quot;font-weight&quot;).toString();</a>
<a name="ln1073">      QString fontSize   = e.attributes().value(&quot;font-size&quot;).toString();</a>
<a name="ln1074">      QString fontStyle  = e.attributes().value(&quot;font-style&quot;).toString();</a>
<a name="ln1075">      QString underline  = e.attributes().value(&quot;underline&quot;).toString();</a>
<a name="ln1076">      QString fontFamily = e.attributes().value(&quot;font-family&quot;).toString();</a>
<a name="ln1077">      // TODO: color, enclosure, yoffset in only part of the text, ...</a>
<a name="ln1078"> </a>
<a name="ln1079">      QString txt        = e.readElementText();</a>
<a name="ln1080">      // replace HTML entities</a>
<a name="ln1081">      txt = decodeEntities(txt);</a>
<a name="ln1082">      QString syms       = text2syms(txt);</a>
<a name="ln1083"> </a>
<a name="ln1084">      QString importedtext;</a>
<a name="ln1085"> </a>
<a name="ln1086">      if (!fontSize.isEmpty()) {</a>
<a name="ln1087">            bool ok = true;</a>
<a name="ln1088">            float size = fontSize.toFloat(&amp;ok);</a>
<a name="ln1089">            if (ok)</a>
<a name="ln1090">                  importedtext += QString(&quot;&lt;font size=\&quot;%1\&quot;/&gt;&quot;).arg(size);</a>
<a name="ln1091">            }</a>
<a name="ln1092">      if (!fontFamily.isEmpty() &amp;&amp; txt == syms) {</a>
<a name="ln1093">            // add font family only if no &lt;sym&gt; replacement made</a>
<a name="ln1094">            importedtext += QString(&quot;&lt;font face=\&quot;%1\&quot;/&gt;&quot;).arg(fontFamily);</a>
<a name="ln1095">            }</a>
<a name="ln1096">      if (fontWeight == &quot;bold&quot;)</a>
<a name="ln1097">            importedtext += &quot;&lt;b&gt;&quot;;</a>
<a name="ln1098">      if (fontStyle == &quot;italic&quot;)</a>
<a name="ln1099">            importedtext += &quot;&lt;i&gt;&quot;;</a>
<a name="ln1100">      if (!underline.isEmpty()) {</a>
<a name="ln1101">            bool ok = true;</a>
<a name="ln1102">            int lines = underline.toInt(&amp;ok);</a>
<a name="ln1103">            if (ok &amp;&amp; (lines &gt; 0))  // 1,2, or 3 underlines are imported as single underline</a>
<a name="ln1104">                  importedtext += &quot;&lt;u&gt;&quot;;</a>
<a name="ln1105">            else</a>
<a name="ln1106">                  underline = &quot;&quot;;</a>
<a name="ln1107">            }</a>
<a name="ln1108">      if (txt == syms) {</a>
<a name="ln1109">            txt.replace(QString(&quot;\r&quot;), QString(&quot;&quot;)); // convert Windows line break \r\n -&gt; \n</a>
<a name="ln1110">            importedtext += txt.toHtmlEscaped();</a>
<a name="ln1111">            }</a>
<a name="ln1112">      else {</a>
<a name="ln1113">            // &lt;sym&gt; replacement made, should be no need for line break or other conversions</a>
<a name="ln1114">            importedtext += syms;</a>
<a name="ln1115">            }</a>
<a name="ln1116">      if (underline != &quot;&quot;)</a>
<a name="ln1117">            importedtext += &quot;&lt;/u&gt;&quot;;</a>
<a name="ln1118">      if (fontStyle == &quot;italic&quot;)</a>
<a name="ln1119">            importedtext += &quot;&lt;/i&gt;&quot;;</a>
<a name="ln1120">      if (fontWeight == &quot;bold&quot;)</a>
<a name="ln1121">            importedtext += &quot;&lt;/b&gt;&quot;;</a>
<a name="ln1122">      //qDebug(&quot;importedtext '%s'&quot;, qPrintable(importedtext));</a>
<a name="ln1123">      return importedtext;</a>
<a name="ln1124">      }</a>
<a name="ln1125"> </a>
<a name="ln1126">//---------------------------------------------------------</a>
<a name="ln1127">//   credit</a>
<a name="ln1128">//---------------------------------------------------------</a>
<a name="ln1129"> </a>
<a name="ln1130">/**</a>
<a name="ln1131"> Parse the /score-partwise/credit node:</a>
<a name="ln1132"> read the credits for later handling by doCredits().</a>
<a name="ln1133"> */</a>
<a name="ln1134"> </a>
<a name="ln1135">void MusicXMLParserPass1::credit(CreditWordsList&amp; credits)</a>
<a name="ln1136">      {</a>
<a name="ln1137">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;credit&quot;);</a>
<a name="ln1138">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::credit&quot;, &amp;_e);</a>
<a name="ln1139"> </a>
<a name="ln1140">      const auto page = _e.attributes().value(&quot;page&quot;).toString().toInt();       // ignoring errors implies incorrect conversion defaults to the first page</a>
<a name="ln1141">      // multiple credit-words elements may be present,</a>
<a name="ln1142">      // which are appended</a>
<a name="ln1143">      // use the position info from the first one</a>
<a name="ln1144">      // font information is ignored, credits will be styled</a>
<a name="ln1145">      bool creditWordsRead = false;</a>
<a name="ln1146">      double defaultx = 0;</a>
<a name="ln1147">      double defaulty = 0;</a>
<a name="ln1148">      QString justify;</a>
<a name="ln1149">      QString halign;</a>
<a name="ln1150">      QString valign;</a>
<a name="ln1151">      QString crwords;</a>
<a name="ln1152">      while (_e.readNextStartElement()) {</a>
<a name="ln1153">            if (_e.name() == &quot;credit-words&quot;) {</a>
<a name="ln1154">                  // IMPORT_LAYOUT</a>
<a name="ln1155">                  if (!creditWordsRead) {</a>
<a name="ln1156">                        defaultx = _e.attributes().value(&quot;default-x&quot;).toString().toDouble();</a>
<a name="ln1157">                        defaulty = _e.attributes().value(&quot;default-y&quot;).toString().toDouble();</a>
<a name="ln1158">                        justify  = _e.attributes().value(&quot;justify&quot;).toString();</a>
<a name="ln1159">                        halign   = _e.attributes().value(&quot;halign&quot;).toString();</a>
<a name="ln1160">                        valign   = _e.attributes().value(&quot;valign&quot;).toString();</a>
<a name="ln1161">                        creditWordsRead = true;</a>
<a name="ln1162">                        }</a>
<a name="ln1163">                  crwords += nextPartOfFormattedString(_e);</a>
<a name="ln1164">                  }</a>
<a name="ln1165">            else if (_e.name() == &quot;credit-type&quot;)</a>
<a name="ln1166">                  _e.skipCurrentElement();        // skip but don't log</a>
<a name="ln1167">            else</a>
<a name="ln1168">                  skipLogCurrElem();</a>
<a name="ln1169">            }</a>
<a name="ln1170">      if (crwords != &quot;&quot;) {</a>
<a name="ln1171">            CreditWords* cw = new CreditWords(page, defaultx, defaulty, justify, halign, valign, crwords);</a>
<a name="ln1172">            credits.append(cw);</a>
<a name="ln1173">            }</a>
<a name="ln1174"> </a>
<a name="ln1175">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;credit&quot;);</a>
<a name="ln1176">      }</a>
<a name="ln1177"> </a>
<a name="ln1178">//---------------------------------------------------------</a>
<a name="ln1179">//   mustSetSize</a>
<a name="ln1180">//---------------------------------------------------------</a>
<a name="ln1181"> </a>
<a name="ln1182">/**</a>
<a name="ln1183"> Determine if i is a style type for which the default size must be set</a>
<a name="ln1184"> */</a>
<a name="ln1185"> </a>
<a name="ln1186">// The MusicXML specification does not specify to which kinds of text</a>
<a name="ln1187">// the word-font setting applies. Setting all sizes to the size specified</a>
<a name="ln1188">// gives bad results, e.g. for measure numbers, so a selection is made.</a>
<a name="ln1189">// Some tweaking may still be required.</a>
<a name="ln1190">#if 0</a>
<a name="ln1191">static bool mustSetSize(const int i)</a>
<a name="ln1192">      {</a>
<a name="ln1193">      return</a>
<a name="ln1194">            i == int(Tid::TITLE)</a>
<a name="ln1195">            || i == int(Tid::SUBTITLE)</a>
<a name="ln1196">            || i == int(Tid::COMPOSER)</a>
<a name="ln1197">            || i == int(Tid::POET)</a>
<a name="ln1198">            || i == int(Tid::INSTRUMENT_LONG)</a>
<a name="ln1199">            || i == int(Tid::INSTRUMENT_SHORT)</a>
<a name="ln1200">            || i == int(Tid::INSTRUMENT_EXCERPT)</a>
<a name="ln1201">            || i == int(Tid::TEMPO)</a>
<a name="ln1202">            || i == int(Tid::METRONOME)</a>
<a name="ln1203">            || i == int(Tid::TRANSLATOR)</a>
<a name="ln1204">            || i == int(Tid::SYSTEM)</a>
<a name="ln1205">            || i == int(Tid::STAFF)</a>
<a name="ln1206">            || i == int(Tid::REPEAT_LEFT)</a>
<a name="ln1207">            || i == int(Tid::REPEAT_RIGHT)</a>
<a name="ln1208">            || i == int(Tid::TEXTLINE)</a>
<a name="ln1209">            || i == int(Tid::GLISSANDO)</a>
<a name="ln1210">            || i == int(Tid::INSTRUMENT_CHANGE);</a>
<a name="ln1211">      }</a>
<a name="ln1212">#endif</a>
<a name="ln1213"> </a>
<a name="ln1214">//---------------------------------------------------------</a>
<a name="ln1215">//   updateStyles</a>
<a name="ln1216">//---------------------------------------------------------</a>
<a name="ln1217"> </a>
<a name="ln1218">/**</a>
<a name="ln1219"> Update the style definitions to match the MusicXML word-font and lyric-font.</a>
<a name="ln1220"> */</a>
<a name="ln1221"> </a>
<a name="ln1222">static void updateStyles(Score* score,</a>
<a name="ln1223">                         const QString&amp; wordFamily, const QString&amp; wordSize,</a>
<a name="ln1224">                         const QString&amp; lyricFamily, const QString&amp; lyricSize)</a>
<a name="ln1225">      {</a>
<a name="ln1226">      const auto dblWordSize = wordSize.toDouble();   // note conversion error results in value 0.0</a>
<a name="ln1227">      const auto dblLyricSize = lyricSize.toDouble(); // but avoid comparing (double) floating point number with exact value later</a>
<a name="ln1228">      const auto epsilon = 0.001;                     // use epsilon instead</a>
<a name="ln1229"> </a>
<a name="ln1230">      // loop over all text styles (except the empty, always hidden, first one)</a>
<a name="ln1231">      // set all text styles to the MusicXML defaults</a>
<a name="ln1232">      for (const auto tid : allTextStyles()) {</a>
<a name="ln1233"> </a>
<a name="ln1234">            // exclude lyrics odd and even lines (handled separately)</a>
<a name="ln1235">            // and Roman numeral analysis (special case, leave untouched)</a>
<a name="ln1236">            if (tid == Tid::LYRICS_ODD || tid == Tid::LYRICS_EVEN || tid == Tid::HARMONY_ROMAN)</a>
<a name="ln1237">                  continue;</a>
<a name="ln1238">            const TextStyle* ts = textStyle(tid);</a>
<a name="ln1239">            for (const StyledProperty&amp; a :* ts) {</a>
<a name="ln1240">                  if (a.pid == Pid::FONT_FACE &amp;&amp; wordFamily != &quot;&quot;)</a>
<a name="ln1241">                        score-&gt;style().set(a.sid, wordFamily);</a>
<a name="ln1242">                  else if (a.pid == Pid::FONT_SIZE &amp;&amp; dblWordSize &gt; epsilon)</a>
<a name="ln1243">                        score-&gt;style().set(a.sid, dblWordSize);</a>
<a name="ln1244">                  }</a>
<a name="ln1245">            }</a>
<a name="ln1246"> </a>
<a name="ln1247">      // handle lyrics odd and even lines separately</a>
<a name="ln1248">      if (lyricFamily != &quot;&quot;) {</a>
<a name="ln1249">            score-&gt;style().set(Sid::lyricsOddFontFace, lyricFamily);</a>
<a name="ln1250">            score-&gt;style().set(Sid::lyricsEvenFontFace, lyricFamily);</a>
<a name="ln1251">            }</a>
<a name="ln1252">      if (dblLyricSize &gt; epsilon) {</a>
<a name="ln1253">            score-&gt;style().set(Sid::lyricsOddFontSize, QVariant(dblLyricSize));</a>
<a name="ln1254">            score-&gt;style().set(Sid::lyricsEvenFontSize, QVariant(dblLyricSize));</a>
<a name="ln1255">            }</a>
<a name="ln1256">      }</a>
<a name="ln1257"> </a>
<a name="ln1258">//---------------------------------------------------------</a>
<a name="ln1259">//   setPageFormat</a>
<a name="ln1260">//---------------------------------------------------------</a>
<a name="ln1261"> </a>
<a name="ln1262">static void setPageFormat(Score* score, const PageFormat&amp; pf)</a>
<a name="ln1263">      {</a>
<a name="ln1264">      score-&gt;style().set(Sid::pageWidth, pf.size.width());</a>
<a name="ln1265">      score-&gt;style().set(Sid::pageHeight, pf.size.height());</a>
<a name="ln1266">      score-&gt;style().set(Sid::pagePrintableWidth, pf.printableWidth);</a>
<a name="ln1267">      score-&gt;style().set(Sid::pageEvenLeftMargin, pf.evenLeftMargin);</a>
<a name="ln1268">      score-&gt;style().set(Sid::pageOddLeftMargin, pf.oddLeftMargin);</a>
<a name="ln1269">      score-&gt;style().set(Sid::pageEvenTopMargin, pf.evenTopMargin);</a>
<a name="ln1270">      score-&gt;style().set(Sid::pageEvenBottomMargin, pf.evenBottomMargin);</a>
<a name="ln1271">      score-&gt;style().set(Sid::pageOddTopMargin, pf.oddTopMargin);</a>
<a name="ln1272">      score-&gt;style().set(Sid::pageOddBottomMargin, pf.oddBottomMargin);</a>
<a name="ln1273">      score-&gt;style().set(Sid::pageTwosided, pf.twosided);</a>
<a name="ln1274">      }</a>
<a name="ln1275"> </a>
<a name="ln1276">//---------------------------------------------------------</a>
<a name="ln1277">//   defaults</a>
<a name="ln1278">//---------------------------------------------------------</a>
<a name="ln1279"> </a>
<a name="ln1280">/**</a>
<a name="ln1281"> Parse the /score-partwise/defaults node:</a>
<a name="ln1282"> read the general score layout settings.</a>
<a name="ln1283"> */</a>
<a name="ln1284"> </a>
<a name="ln1285">void MusicXMLParserPass1::defaults()</a>
<a name="ln1286">      {</a>
<a name="ln1287">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;defaults&quot;);</a>
<a name="ln1288">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::defaults&quot;, &amp;_e);</a>
<a name="ln1289"> </a>
<a name="ln1290">      double millimeter = _score-&gt;spatium()/10.0;</a>
<a name="ln1291">      double tenths = 1.0;</a>
<a name="ln1292">      QString lyricFontFamily;</a>
<a name="ln1293">      QString lyricFontSize;</a>
<a name="ln1294">      QString wordFontFamily;</a>
<a name="ln1295">      QString wordFontSize;</a>
<a name="ln1296"> </a>
<a name="ln1297">      while (_e.readNextStartElement()) {</a>
<a name="ln1298">            if (_e.name() == &quot;appearance&quot;)</a>
<a name="ln1299">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1300">            else if (_e.name() == &quot;scaling&quot;) {</a>
<a name="ln1301">                  while (_e.readNextStartElement()) {</a>
<a name="ln1302">                        if (_e.name() == &quot;millimeters&quot;)</a>
<a name="ln1303">                              millimeter = _e.readElementText().toDouble();</a>
<a name="ln1304">                        else if (_e.name() == &quot;tenths&quot;)</a>
<a name="ln1305">                              tenths = _e.readElementText().toDouble();</a>
<a name="ln1306">                        else</a>
<a name="ln1307">                              skipLogCurrElem();</a>
<a name="ln1308">                        }</a>
<a name="ln1309">                  double _spatium = DPMM * (millimeter * 10.0 / tenths);</a>
<a name="ln1310">                  if (preferences.getBool(PREF_IMPORT_MUSICXML_IMPORTLAYOUT))</a>
<a name="ln1311">                        _score-&gt;setSpatium(_spatium);</a>
<a name="ln1312">                  }</a>
<a name="ln1313">            else if (_e.name() == &quot;page-layout&quot;) {</a>
<a name="ln1314">                  PageFormat pf;</a>
<a name="ln1315">                  pageLayout(pf, millimeter / (tenths * INCH));</a>
<a name="ln1316">                  if (preferences.getBool(PREF_IMPORT_MUSICXML_IMPORTLAYOUT))</a>
<a name="ln1317">                        setPageFormat(_score, pf);</a>
<a name="ln1318">                  }</a>
<a name="ln1319">            else if (_e.name() == &quot;system-layout&quot;) {</a>
<a name="ln1320">                  while (_e.readNextStartElement()) {</a>
<a name="ln1321">                        if (_e.name() == &quot;system-dividers&quot;)</a>
<a name="ln1322">                              _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1323">                        else if (_e.name() == &quot;system-margins&quot;)</a>
<a name="ln1324">                              _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1325">                        else if (_e.name() == &quot;system-distance&quot;) {</a>
<a name="ln1326">                              Spatium val(_e.readElementText().toDouble() / 10.0);</a>
<a name="ln1327">                              if (preferences.getBool(PREF_IMPORT_MUSICXML_IMPORTLAYOUT)) {</a>
<a name="ln1328">                                    _score-&gt;style().set(Sid::minSystemDistance, val);</a>
<a name="ln1329">                                    //qDebug(&quot;system distance %f&quot;, val.val());</a>
<a name="ln1330">                                    }</a>
<a name="ln1331">                              }</a>
<a name="ln1332">                        else if (_e.name() == &quot;top-system-distance&quot;)</a>
<a name="ln1333">                              _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1334">                        else</a>
<a name="ln1335">                              skipLogCurrElem();</a>
<a name="ln1336">                        }</a>
<a name="ln1337">                  }</a>
<a name="ln1338">            else if (_e.name() == &quot;staff-layout&quot;) {</a>
<a name="ln1339">                  while (_e.readNextStartElement()) {</a>
<a name="ln1340">                        if (_e.name() == &quot;staff-distance&quot;) {</a>
<a name="ln1341">                              Spatium val(_e.readElementText().toDouble() / 10.0);</a>
<a name="ln1342">                              if (preferences.getBool(PREF_IMPORT_MUSICXML_IMPORTLAYOUT))</a>
<a name="ln1343">                                    _score-&gt;style().set(Sid::staffDistance, val);</a>
<a name="ln1344">                              }</a>
<a name="ln1345">                        else</a>
<a name="ln1346">                              skipLogCurrElem();</a>
<a name="ln1347">                        }</a>
<a name="ln1348">                  }</a>
<a name="ln1349">            else if (_e.name() == &quot;music-font&quot;)</a>
<a name="ln1350">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1351">            else if (_e.name() == &quot;word-font&quot;) {</a>
<a name="ln1352">                  wordFontFamily = _e.attributes().value(&quot;font-family&quot;).toString();</a>
<a name="ln1353">                  wordFontSize = _e.attributes().value(&quot;font-size&quot;).toString();</a>
<a name="ln1354">                  _e.skipCurrentElement();</a>
<a name="ln1355">                  }</a>
<a name="ln1356">            else if (_e.name() == &quot;lyric-font&quot;) {</a>
<a name="ln1357">                  lyricFontFamily = _e.attributes().value(&quot;font-family&quot;).toString();</a>
<a name="ln1358">                  lyricFontSize = _e.attributes().value(&quot;font-size&quot;).toString();</a>
<a name="ln1359">                  _e.skipCurrentElement();</a>
<a name="ln1360">                  }</a>
<a name="ln1361">            else if (_e.name() == &quot;lyric-language&quot;)</a>
<a name="ln1362">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1363">            else</a>
<a name="ln1364">                  skipLogCurrElem();</a>
<a name="ln1365">            }</a>
<a name="ln1366"> </a>
<a name="ln1367">      /*</a>
<a name="ln1368">      qDebug(&quot;word font family '%s' size '%s' lyric font family '%s' size '%s'&quot;,</a>
<a name="ln1369">             qPrintable(wordFontFamily), qPrintable(wordFontSize),</a>
<a name="ln1370">             qPrintable(lyricFontFamily), qPrintable(lyricFontSize));</a>
<a name="ln1371">      */</a>
<a name="ln1372">      updateStyles(_score, wordFontFamily, wordFontSize, lyricFontFamily, lyricFontSize);</a>
<a name="ln1373"> </a>
<a name="ln1374">      _score-&gt;setDefaultsRead(true); // TODO only if actually succeeded ?</a>
<a name="ln1375">      }</a>
<a name="ln1376"> </a>
<a name="ln1377">//---------------------------------------------------------</a>
<a name="ln1378">//   pageLayout</a>
<a name="ln1379">//---------------------------------------------------------</a>
<a name="ln1380"> </a>
<a name="ln1381">/**</a>
<a name="ln1382"> Parse the /score-partwise/defaults/page-layout node: read the page layout.</a>
<a name="ln1383"> Note that MuseScore does not support a separate value for left and right margins</a>
<a name="ln1384"> for odd and even pages. Only odd and even left margins are used, together  with</a>
<a name="ln1385"> the printable width, which is calculated from the left and right margins in the</a>
<a name="ln1386"> MusicXML file.</a>
<a name="ln1387"> */</a>
<a name="ln1388"> </a>
<a name="ln1389">void MusicXMLParserPass1::pageLayout(PageFormat&amp; pf, const qreal conversion)</a>
<a name="ln1390">      {</a>
<a name="ln1391">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;page-layout&quot;);</a>
<a name="ln1392">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::pageLayout&quot;, &amp;_e);</a>
<a name="ln1393"> </a>
<a name="ln1394">      qreal _oddRightMargin  = 0.0;</a>
<a name="ln1395">      qreal _evenRightMargin = 0.0;</a>
<a name="ln1396">      QSizeF size;</a>
<a name="ln1397"> </a>
<a name="ln1398">      while (_e.readNextStartElement()) {</a>
<a name="ln1399">            if (_e.name() == &quot;page-margins&quot;) {</a>
<a name="ln1400">                  QString type = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln1401">                  if (type == &quot;&quot;)</a>
<a name="ln1402">                        type = &quot;both&quot;;</a>
<a name="ln1403">                  qreal lm = 0.0, rm = 0.0, tm = 0.0, bm = 0.0;</a>
<a name="ln1404">                  while (_e.readNextStartElement()) {</a>
<a name="ln1405">                        if (_e.name() == &quot;left-margin&quot;)</a>
<a name="ln1406">                              lm = _e.readElementText().toDouble() * conversion;</a>
<a name="ln1407">                        else if (_e.name() == &quot;right-margin&quot;)</a>
<a name="ln1408">                              rm = _e.readElementText().toDouble() * conversion;</a>
<a name="ln1409">                        else if (_e.name() == &quot;top-margin&quot;)</a>
<a name="ln1410">                              tm = _e.readElementText().toDouble() * conversion;</a>
<a name="ln1411">                        else if (_e.name() == &quot;bottom-margin&quot;)</a>
<a name="ln1412">                              bm = _e.readElementText().toDouble() * conversion;</a>
<a name="ln1413">                        else</a>
<a name="ln1414">                              skipLogCurrElem();</a>
<a name="ln1415">                        }</a>
<a name="ln1416">                  pf.twosided = type == &quot;odd&quot; || type == &quot;even&quot;;</a>
<a name="ln1417">                  if (type == &quot;odd&quot; || type == &quot;both&quot;) {</a>
<a name="ln1418">                        pf.oddLeftMargin = lm;</a>
<a name="ln1419">                        _oddRightMargin = rm;</a>
<a name="ln1420">                        pf.oddTopMargin = tm;</a>
<a name="ln1421">                        pf.oddBottomMargin = bm;</a>
<a name="ln1422">                        }</a>
<a name="ln1423">                  if (type == &quot;even&quot; || type == &quot;both&quot;) {</a>
<a name="ln1424">                        pf.evenLeftMargin = lm;</a>
<a name="ln1425">                        _evenRightMargin = rm;</a>
<a name="ln1426">                        pf.evenTopMargin = tm;</a>
<a name="ln1427">                        pf.evenBottomMargin = bm;</a>
<a name="ln1428">                        }</a>
<a name="ln1429">                  }</a>
<a name="ln1430">            else if (_e.name() == &quot;page-height&quot;) {</a>
<a name="ln1431">                  double val = _e.readElementText().toDouble();</a>
<a name="ln1432">                  size.rheight() = val * conversion;</a>
<a name="ln1433">                  // set pageHeight and pageWidth for use by doCredits()</a>
<a name="ln1434">                  _pageSize.setHeight(static_cast&lt;int&gt;(val + 0.5));</a>
<a name="ln1435">                  }</a>
<a name="ln1436">            else if (_e.name() == &quot;page-width&quot;) {</a>
<a name="ln1437">                  double val = _e.readElementText().toDouble();</a>
<a name="ln1438">                  size.rwidth() = val * conversion;</a>
<a name="ln1439">                  // set pageHeight and pageWidth for use by doCredits()</a>
<a name="ln1440">                  _pageSize.setWidth(static_cast&lt;int&gt;(val + 0.5));</a>
<a name="ln1441">                  }</a>
<a name="ln1442">            else</a>
<a name="ln1443">                  skipLogCurrElem();</a>
<a name="ln1444">            }</a>
<a name="ln1445">      pf.size = size;</a>
<a name="ln1446">      qreal w1 = size.width() - pf.oddLeftMargin - _oddRightMargin;</a>
<a name="ln1447">      qreal w2 = size.width() - pf.evenLeftMargin - _evenRightMargin;</a>
<a name="ln1448">      pf.printableWidth = qMax(w1, w2);   // silently adjust right margins</a>
<a name="ln1449">      }</a>
<a name="ln1450"> </a>
<a name="ln1451">//---------------------------------------------------------</a>
<a name="ln1452">//   partList</a>
<a name="ln1453">//---------------------------------------------------------</a>
<a name="ln1454"> </a>
<a name="ln1455">/**</a>
<a name="ln1456"> Parse the /score-partwise/part-list:</a>
<a name="ln1457"> create the parts and for each part set id and name.</a>
<a name="ln1458"> Also handle the part-groups.</a>
<a name="ln1459"> */</a>
<a name="ln1460"> </a>
<a name="ln1461">void MusicXMLParserPass1::partList(MusicXmlPartGroupList&amp; partGroupList)</a>
<a name="ln1462">      {</a>
<a name="ln1463">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;part-list&quot;);</a>
<a name="ln1464">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::partList&quot;, &amp;_e);</a>
<a name="ln1465"> </a>
<a name="ln1466">      int scoreParts = 0; // number of score-parts read sofar</a>
<a name="ln1467">      MusicXmlPartGroupMap partGroups;</a>
<a name="ln1468"> </a>
<a name="ln1469">      while (_e.readNextStartElement()) {</a>
<a name="ln1470">            if (_e.name() == &quot;part-group&quot;)</a>
<a name="ln1471">                  partGroup(scoreParts, partGroupList, partGroups);</a>
<a name="ln1472">            else if (_e.name() == &quot;score-part&quot;) {</a>
<a name="ln1473">                  scorePart();</a>
<a name="ln1474">                  scoreParts++;</a>
<a name="ln1475">                  }</a>
<a name="ln1476">            else</a>
<a name="ln1477">                  skipLogCurrElem();</a>
<a name="ln1478">            }</a>
<a name="ln1479">      }</a>
<a name="ln1480"> </a>
<a name="ln1481">//---------------------------------------------------------</a>
<a name="ln1482">//   createPart</a>
<a name="ln1483">//---------------------------------------------------------</a>
<a name="ln1484"> </a>
<a name="ln1485">/**</a>
<a name="ln1486"> Create the part, set its \a id and insert it in PartMap \a pm.</a>
<a name="ln1487"> Part name (if any) will be set later.</a>
<a name="ln1488"> */</a>
<a name="ln1489"> </a>
<a name="ln1490">static void createPart(Score* score, const QString&amp; id, PartMap&amp; pm)</a>
<a name="ln1491">      {</a>
<a name="ln1492">      Part* part = new Part(score);</a>
<a name="ln1493">      pm.insert(id, part);</a>
<a name="ln1494">      part-&gt;setId(id);</a>
<a name="ln1495">      score-&gt;appendPart(part);</a>
<a name="ln1496">      Staff* staff = new Staff(score);</a>
<a name="ln1497">      staff-&gt;setPart(part);</a>
<a name="ln1498">      part-&gt;staves()-&gt;push_back(staff);</a>
<a name="ln1499">      score-&gt;staves().push_back(staff);</a>
<a name="ln1500">      // TODO TBD tuplets.resize(VOICES); // part now contains one staff, thus VOICES voices</a>
<a name="ln1501">      }</a>
<a name="ln1502"> </a>
<a name="ln1503">//---------------------------------------------------------</a>
<a name="ln1504">//   partGroupStart</a>
<a name="ln1505">//---------------------------------------------------------</a>
<a name="ln1506"> </a>
<a name="ln1507">typedef std::map&lt;int,MusicXmlPartGroup*&gt; MusicXmlPartGroupMap;</a>
<a name="ln1508"> </a>
<a name="ln1509">/**</a>
<a name="ln1510"> Store part-group start with number \a n, first part \a p and symbol / \a s in the partGroups</a>
<a name="ln1511"> map \a pgs for later reference, as at this time insufficient information is available to be able</a>
<a name="ln1512"> to generate the brackets.</a>
<a name="ln1513"> */</a>
<a name="ln1514"> </a>
<a name="ln1515">static void partGroupStart(MusicXmlPartGroupMap&amp; pgs, int n, int p, QString s, bool barlineSpan)</a>
<a name="ln1516">      {</a>
<a name="ln1517">      //qDebug(&quot;partGroupStart number=%d part=%d symbol=%s&quot;, n, p, qPrintable(s));</a>
<a name="ln1518"> </a>
<a name="ln1519">      if (pgs.count(n) &gt; 0) {</a>
<a name="ln1520">            qDebug(&quot;part-group number=%d already active&quot;, n);</a>
<a name="ln1521">            return;</a>
<a name="ln1522">            }</a>
<a name="ln1523"> </a>
<a name="ln1524">      BracketType bracketType = BracketType::NO_BRACKET;</a>
<a name="ln1525">      if (s == &quot;&quot;)</a>
<a name="ln1526">            ;        // ignore (handle as NO_BRACKET)</a>
<a name="ln1527">      else if (s == &quot;none&quot;)</a>
<a name="ln1528">            ;        // already set to NO_BRACKET</a>
<a name="ln1529">      else if (s == &quot;brace&quot;)</a>
<a name="ln1530">            bracketType = BracketType::BRACE;</a>
<a name="ln1531">      else if (s == &quot;bracket&quot;)</a>
<a name="ln1532">            bracketType = BracketType::NORMAL;</a>
<a name="ln1533">      else if (s == &quot;line&quot;)</a>
<a name="ln1534">            bracketType = BracketType::LINE;</a>
<a name="ln1535">      else if (s == &quot;square&quot;)</a>
<a name="ln1536">            bracketType = BracketType::SQUARE;</a>
<a name="ln1537">      else {</a>
<a name="ln1538">            qDebug(&quot;part-group symbol=%s not supported&quot;, qPrintable(s));</a>
<a name="ln1539">            return;</a>
<a name="ln1540">            }</a>
<a name="ln1541"> </a>
<a name="ln1542">      MusicXmlPartGroup* pg = new MusicXmlPartGroup;</a>
<a name="ln1543">      pg-&gt;span = 0;</a>
<a name="ln1544">      pg-&gt;start = p;</a>
<a name="ln1545">      pg-&gt;barlineSpan = barlineSpan,</a>
<a name="ln1546">      pg-&gt;type = bracketType;</a>
<a name="ln1547">      pgs[n] = pg;</a>
<a name="ln1548">      }</a>
<a name="ln1549"> </a>
<a name="ln1550">//---------------------------------------------------------</a>
<a name="ln1551">//   partGroupStop</a>
<a name="ln1552">//---------------------------------------------------------</a>
<a name="ln1553"> </a>
<a name="ln1554">/**</a>
<a name="ln1555"> Handle part-group stop with number \a n and part \a p.</a>
<a name="ln1556"> </a>
<a name="ln1557"> For part group n, the start part, span (in parts) and type are now known.</a>
<a name="ln1558"> To generate brackets, the span in staves must also be known.</a>
<a name="ln1559"> */</a>
<a name="ln1560"> </a>
<a name="ln1561">static void partGroupStop(MusicXmlPartGroupMap&amp; pgs, int n, int p,</a>
<a name="ln1562">                          MusicXmlPartGroupList&amp; pgl)</a>
<a name="ln1563">      {</a>
<a name="ln1564">      if (pgs.count(n) == 0) {</a>
<a name="ln1565">            qDebug(&quot;part-group number=%d not active&quot;, n);</a>
<a name="ln1566">            return;</a>
<a name="ln1567">            }</a>
<a name="ln1568"> </a>
<a name="ln1569">      pgs[n]-&gt;span = p - pgs[n]-&gt;start;</a>
<a name="ln1570">      //qDebug(&quot;partgroupstop number=%d start=%d span=%d type=%hhd&quot;,</a>
<a name="ln1571">      //       n, pgs[n]-&gt;start, pgs[n]-&gt;span, pgs[n]-&gt;type);</a>
<a name="ln1572">      pgl.push_back(pgs[n]);</a>
<a name="ln1573">      pgs.erase(n);</a>
<a name="ln1574">      }</a>
<a name="ln1575"> </a>
<a name="ln1576">//---------------------------------------------------------</a>
<a name="ln1577">//   partGroup</a>
<a name="ln1578">//---------------------------------------------------------</a>
<a name="ln1579"> </a>
<a name="ln1580">/**</a>
<a name="ln1581"> Parse the /score-partwise/part-list/part-group node.</a>
<a name="ln1582"> */</a>
<a name="ln1583"> </a>
<a name="ln1584">void MusicXMLParserPass1::partGroup(const int scoreParts,</a>
<a name="ln1585">                                    MusicXmlPartGroupList&amp; partGroupList,</a>
<a name="ln1586">                                    MusicXmlPartGroupMap&amp; partGroups)</a>
<a name="ln1587">      {</a>
<a name="ln1588">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;part-group&quot;);</a>
<a name="ln1589">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::partGroup&quot;, &amp;_e);</a>
<a name="ln1590">      bool barlineSpan = true;</a>
<a name="ln1591">      int number = _e.attributes().value(&quot;number&quot;).toInt();</a>
<a name="ln1592">      if (number &gt; 0) number--;</a>
<a name="ln1593">      QString symbol = &quot;&quot;;</a>
<a name="ln1594">      QString type = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln1595"> </a>
<a name="ln1596">      while (_e.readNextStartElement()) {</a>
<a name="ln1597">            if (_e.name() == &quot;group-name&quot;)</a>
<a name="ln1598">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1599">            else if (_e.name() == &quot;group-abbreviation&quot;)</a>
<a name="ln1600">                  symbol = _e.readElementText();</a>
<a name="ln1601">            else if (_e.name() == &quot;group-symbol&quot;)</a>
<a name="ln1602">                  symbol = _e.readElementText();</a>
<a name="ln1603">            else if (_e.name() == &quot;group-barline&quot;) {</a>
<a name="ln1604">                  if (_e.readElementText() == &quot;no&quot;)</a>
<a name="ln1605">                        barlineSpan = false;</a>
<a name="ln1606">                  }</a>
<a name="ln1607">            else</a>
<a name="ln1608">                  skipLogCurrElem();</a>
<a name="ln1609">            }</a>
<a name="ln1610"> </a>
<a name="ln1611">      if (type == &quot;start&quot;)</a>
<a name="ln1612">            partGroupStart(partGroups, number, scoreParts, symbol, barlineSpan);</a>
<a name="ln1613">      else if (type == &quot;stop&quot;)</a>
<a name="ln1614">            partGroupStop(partGroups, number, scoreParts, partGroupList);</a>
<a name="ln1615">      else</a>
<a name="ln1616">            _logger-&gt;logError(QString(&quot;part-group type '%1' not supported&quot;).arg(type), &amp;_e);</a>
<a name="ln1617">      }</a>
<a name="ln1618"> </a>
<a name="ln1619">//---------------------------------------------------------</a>
<a name="ln1620">//   findInstrument</a>
<a name="ln1621">//---------------------------------------------------------</a>
<a name="ln1622"> </a>
<a name="ln1623">/**</a>
<a name="ln1624"> Find the first InstrumentTemplate with musicXMLid instrSound</a>
<a name="ln1625"> and a non-empty set of channels.</a>
<a name="ln1626"> */</a>
<a name="ln1627"> </a>
<a name="ln1628">#if 0 // not used</a>
<a name="ln1629">static const InstrumentTemplate* findInstrument(const QString&amp; instrSound)</a>
<a name="ln1630">      {</a>
<a name="ln1631">      const InstrumentTemplate* instr = nullptr;</a>
<a name="ln1632"> </a>
<a name="ln1633">      for (const InstrumentGroup* group : instrumentGroups) {</a>
<a name="ln1634">            for (const InstrumentTemplate* templ : group-&gt;instrumentTemplates) {</a>
<a name="ln1635">                  if (templ-&gt;musicXMLid == instrSound &amp;&amp; !templ-&gt;channel.isEmpty()) {</a>
<a name="ln1636">                        return templ;</a>
<a name="ln1637">                        }</a>
<a name="ln1638">                  }</a>
<a name="ln1639">            }</a>
<a name="ln1640">      return instr;</a>
<a name="ln1641">      }</a>
<a name="ln1642">#endif</a>
<a name="ln1643"> </a>
<a name="ln1644">//---------------------------------------------------------</a>
<a name="ln1645">//   scorePart</a>
<a name="ln1646">//---------------------------------------------------------</a>
<a name="ln1647"> </a>
<a name="ln1648">/**</a>
<a name="ln1649"> Parse the /score-partwise/part-list/score-part node:</a>
<a name="ln1650"> create the part and sets id and name.</a>
<a name="ln1651"> Note that a part is created even if no part-name is present</a>
<a name="ln1652"> which is invalid MusicXML but is (sometimes ?) generated by NWC2MusicXML.</a>
<a name="ln1653"> */</a>
<a name="ln1654"> </a>
<a name="ln1655">void MusicXMLParserPass1::scorePart()</a>
<a name="ln1656">      {</a>
<a name="ln1657">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;score-part&quot;);</a>
<a name="ln1658">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::scorePart&quot;, &amp;_e);</a>
<a name="ln1659">      QString id = _e.attributes().value(&quot;id&quot;).toString();</a>
<a name="ln1660"> </a>
<a name="ln1661">      if (_parts.contains(id)) {</a>
<a name="ln1662">            _logger-&gt;logError(QString(&quot;duplicate part id '%1'&quot;).arg(id), &amp;_e);</a>
<a name="ln1663">            skipLogCurrElem();</a>
<a name="ln1664">            return;</a>
<a name="ln1665">            }</a>
<a name="ln1666">      else {</a>
<a name="ln1667">            _parts.insert(id, MusicXmlPart(id));</a>
<a name="ln1668">            _drumsets.insert(id, MusicXMLDrumset());</a>
<a name="ln1669">            createPart(_score, id, _partMap);</a>
<a name="ln1670">            }</a>
<a name="ln1671"> </a>
<a name="ln1672">      while (_e.readNextStartElement()) {</a>
<a name="ln1673">            if (_e.name() == &quot;part-name&quot;) {</a>
<a name="ln1674">                  // Element part-name contains the displayed (full) part name</a>
<a name="ln1675">                  // It is displayed by default, but can be suppressed (print-object=”no”)</a>
<a name="ln1676">                  // As of MusicXML 3.0, formatting is deprecated, with part-name in plain text</a>
<a name="ln1677">                  // and the formatted version in the part-name-display element</a>
<a name="ln1678">                  _parts[id].setPrintName(!(_e.attributes().value(&quot;print-object&quot;) == &quot;no&quot;));</a>
<a name="ln1679">                  QString name = _e.readElementText();</a>
<a name="ln1680">                  _parts[id].setName(name);</a>
<a name="ln1681">                  }</a>
<a name="ln1682">            else if (_e.name() == &quot;part-name-display&quot;) {</a>
<a name="ln1683">                  // TODO</a>
<a name="ln1684">                  _e.skipCurrentElement(); // skip but don't log</a>
<a name="ln1685">                  }</a>
<a name="ln1686">            else if (_e.name() == &quot;part-abbreviation&quot;) {</a>
<a name="ln1687">                  // Element part-name contains the displayed (abbreviated) part name</a>
<a name="ln1688">                  // It is displayed by default, but can be suppressed (print-object=”no”)</a>
<a name="ln1689">                  // As of MusicXML 3.0, formatting is deprecated, with part-name in plain text</a>
<a name="ln1690">                  // and the formatted version in the part-abbreviation-display element</a>
<a name="ln1691">                  _parts[id].setPrintAbbr(!(_e.attributes().value(&quot;print-object&quot;) == &quot;no&quot;));</a>
<a name="ln1692">                  QString name = _e.readElementText();</a>
<a name="ln1693">                  _parts[id].setAbbr(name);</a>
<a name="ln1694">                  }</a>
<a name="ln1695">            else if (_e.name() == &quot;part-abbreviation-display&quot;)</a>
<a name="ln1696">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1697">            else if (_e.name() == &quot;score-instrument&quot;)</a>
<a name="ln1698">                  scoreInstrument(id);</a>
<a name="ln1699">            else if (_e.name() == &quot;midi-device&quot;) {</a>
<a name="ln1700">                  if (!_e.attributes().hasAttribute(&quot;port&quot;)) {</a>
<a name="ln1701">                        _e.readElementText(); // empty string</a>
<a name="ln1702">                        continue;</a>
<a name="ln1703">                        }</a>
<a name="ln1704">                  QString instrId = _e.attributes().value(&quot;id&quot;).toString();</a>
<a name="ln1705">                  QString port = _e.attributes().value(&quot;port&quot;).toString();</a>
<a name="ln1706">                  // If instrId is missing, the device assignment affects all</a>
<a name="ln1707">                  // score-instrument elements in the score-part</a>
<a name="ln1708">                  if (instrId.isEmpty()) {</a>
<a name="ln1709">                        for (auto it = _drumsets[id].cbegin(); it != _drumsets[id].cend(); ++it)</a>
<a name="ln1710">                              _drumsets[id][it.key()].midiPort = port.toInt() - 1;</a>
<a name="ln1711">                        }</a>
<a name="ln1712">                  else if (_drumsets[id].contains(instrId))</a>
<a name="ln1713">                        _drumsets[id][instrId].midiPort = port.toInt() - 1;</a>
<a name="ln1714"> </a>
<a name="ln1715">                  _e.readElementText(); // empty string</a>
<a name="ln1716">                  }</a>
<a name="ln1717">            else if (_e.name() == &quot;midi-instrument&quot;)</a>
<a name="ln1718">                  midiInstrument(id);</a>
<a name="ln1719">            else</a>
<a name="ln1720">                  skipLogCurrElem();</a>
<a name="ln1721">            }</a>
<a name="ln1722"> </a>
<a name="ln1723">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;score-part&quot;);</a>
<a name="ln1724">      }</a>
<a name="ln1725"> </a>
<a name="ln1726">//---------------------------------------------------------</a>
<a name="ln1727">//   scoreInstrument</a>
<a name="ln1728">//---------------------------------------------------------</a>
<a name="ln1729"> </a>
<a name="ln1730">/**</a>
<a name="ln1731"> Parse the /score-partwise/part-list/score-part/score-instrument node.</a>
<a name="ln1732"> */</a>
<a name="ln1733"> </a>
<a name="ln1734">void MusicXMLParserPass1::scoreInstrument(const QString&amp; partId)</a>
<a name="ln1735">      {</a>
<a name="ln1736">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;score-instrument&quot;);</a>
<a name="ln1737">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::scoreInstrument&quot;, &amp;_e);</a>
<a name="ln1738">      QString instrId = _e.attributes().value(&quot;id&quot;).toString();</a>
<a name="ln1739"> </a>
<a name="ln1740">      while (_e.readNextStartElement()) {</a>
<a name="ln1741">            if (_e.name() == &quot;ensemble&quot;)</a>
<a name="ln1742">                  skipLogCurrElem();</a>
<a name="ln1743">            else if (_e.name() == &quot;instrument-name&quot;) {</a>
<a name="ln1744">                  QString instrName = _e.readElementText();</a>
<a name="ln1745">                  /*</a>
<a name="ln1746">                  qDebug(&quot;partId '%s' instrId '%s' instrName '%s'&quot;,</a>
<a name="ln1747">                         qPrintable(partId),</a>
<a name="ln1748">                         qPrintable(instrId),</a>
<a name="ln1749">                         qPrintable(instrName)</a>
<a name="ln1750">                         );</a>
<a name="ln1751">                   */</a>
<a name="ln1752">                  _drumsets[partId].insert(instrId, MusicXMLDrumInstrument(instrName));</a>
<a name="ln1753">                  // Element instrument-name is typically not displayed in the score,</a>
<a name="ln1754">                  // but used only internally</a>
<a name="ln1755">                  if (_drumsets[partId].contains(instrId))</a>
<a name="ln1756">                        _drumsets[partId][instrId].name = instrName;</a>
<a name="ln1757">                  }</a>
<a name="ln1758">            else if (_e.name() == &quot;instrument-sound&quot;) {</a>
<a name="ln1759">                  QString instrSound = _e.readElementText();</a>
<a name="ln1760">                  if (_drumsets[partId].contains(instrId))</a>
<a name="ln1761">                        _drumsets[partId][instrId].sound = instrSound;</a>
<a name="ln1762">                  }</a>
<a name="ln1763">            else if (_e.name() == &quot;virtual-instrument&quot;) {</a>
<a name="ln1764">                  while (_e.readNextStartElement()) {</a>
<a name="ln1765">                        if (_e.name() == &quot;virtual-library&quot;) {</a>
<a name="ln1766">                              QString virtualLibrary = _e.readElementText();</a>
<a name="ln1767">                              if (_drumsets[partId].contains(instrId))</a>
<a name="ln1768">                                    _drumsets[partId][instrId].virtLib = virtualLibrary;</a>
<a name="ln1769">                              }</a>
<a name="ln1770">                        else if (_e.name() == &quot;virtual-name&quot;) {</a>
<a name="ln1771">                              QString virtualName = _e.readElementText();</a>
<a name="ln1772">                              if (_drumsets[partId].contains(instrId))</a>
<a name="ln1773">                                    _drumsets[partId][instrId].virtName = virtualName;</a>
<a name="ln1774">                              }</a>
<a name="ln1775">                        else</a>
<a name="ln1776">                              skipLogCurrElem();</a>
<a name="ln1777">                        }</a>
<a name="ln1778">                  }</a>
<a name="ln1779">            else</a>
<a name="ln1780">                  skipLogCurrElem();</a>
<a name="ln1781">            }</a>
<a name="ln1782">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;score-instrument&quot;);</a>
<a name="ln1783">      }</a>
<a name="ln1784"> </a>
<a name="ln1785">//---------------------------------------------------------</a>
<a name="ln1786">//   midiInstrument</a>
<a name="ln1787">//---------------------------------------------------------</a>
<a name="ln1788"> </a>
<a name="ln1789">/**</a>
<a name="ln1790"> Parse the /score-partwise/part-list/score-part/midi-instrument node.</a>
<a name="ln1791"> */</a>
<a name="ln1792"> </a>
<a name="ln1793">void MusicXMLParserPass1::midiInstrument(const QString&amp; partId)</a>
<a name="ln1794">      {</a>
<a name="ln1795">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;midi-instrument&quot;);</a>
<a name="ln1796">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::midiInstrument&quot;, &amp;_e);</a>
<a name="ln1797">      QString instrId = _e.attributes().value(&quot;id&quot;).toString();</a>
<a name="ln1798"> </a>
<a name="ln1799">      while (_e.readNextStartElement()) {</a>
<a name="ln1800">            if (_e.name() == &quot;midi-bank&quot;)</a>
<a name="ln1801">                  skipLogCurrElem();</a>
<a name="ln1802">            else if (_e.name() == &quot;midi-channel&quot;) {</a>
<a name="ln1803">                  int channel = _e.readElementText().toInt();</a>
<a name="ln1804">                  if (channel &lt; 1) {</a>
<a name="ln1805">                        _logger-&gt;logError(QString(&quot;incorrect midi-channel: %1&quot;).arg(channel), &amp;_e);</a>
<a name="ln1806">                        channel = 1;</a>
<a name="ln1807">                        }</a>
<a name="ln1808">                  else if (channel &gt; 16) {</a>
<a name="ln1809">                        _logger-&gt;logError(QString(&quot;incorrect midi-channel: %1&quot;).arg(channel), &amp;_e);</a>
<a name="ln1810">                        channel = 16;</a>
<a name="ln1811">                        }</a>
<a name="ln1812">                  if (_drumsets[partId].contains(instrId))</a>
<a name="ln1813">                        _drumsets[partId][instrId].midiChannel = channel - 1;</a>
<a name="ln1814">                  }</a>
<a name="ln1815">            else if (_e.name() == &quot;midi-program&quot;) {</a>
<a name="ln1816">                  int program = _e.readElementText().toInt();</a>
<a name="ln1817">                  // Bug fix for Cubase 6.5.5 which generates &lt;midi-program&gt;0&lt;/midi-program&gt;</a>
<a name="ln1818">                  // Check program number range</a>
<a name="ln1819">                  if (program &lt; 1) {</a>
<a name="ln1820">                        _logger-&gt;logError(QString(&quot;incorrect midi-program: %1&quot;).arg(program), &amp;_e);</a>
<a name="ln1821">                        program = 1;</a>
<a name="ln1822">                        }</a>
<a name="ln1823">                  else if (program &gt; 128) {</a>
<a name="ln1824">                        _logger-&gt;logError(QString(&quot;incorrect midi-program: %1&quot;).arg(program), &amp;_e);</a>
<a name="ln1825">                        program = 128;</a>
<a name="ln1826">                        }</a>
<a name="ln1827">                  if (_drumsets[partId].contains(instrId))</a>
<a name="ln1828">                        _drumsets[partId][instrId].midiProgram = program - 1;</a>
<a name="ln1829">                  }</a>
<a name="ln1830">            else if (_e.name() == &quot;midi-unpitched&quot;) {</a>
<a name="ln1831">                  if (_drumsets[partId].contains(instrId))</a>
<a name="ln1832">                        _drumsets[partId][instrId].pitch = _e.readElementText().toInt() - 1;</a>
<a name="ln1833">                  }</a>
<a name="ln1834">            else if (_e.name() == &quot;volume&quot;) {</a>
<a name="ln1835">                  double vol = _e.readElementText().toDouble();</a>
<a name="ln1836">                  if (vol &gt;= 0 &amp;&amp; vol &lt;= 100) {</a>
<a name="ln1837">                        if (_drumsets[partId].contains(instrId))</a>
<a name="ln1838">                              _drumsets[partId][instrId].midiVolume = static_cast&lt;int&gt;((vol / 100) * 127);</a>
<a name="ln1839">                        }</a>
<a name="ln1840">                  else</a>
<a name="ln1841">                        _logger-&gt;logError(QString(&quot;incorrect midi-volume: %1&quot;).arg(vol), &amp;_e);</a>
<a name="ln1842">                  }</a>
<a name="ln1843">            else if (_e.name() == &quot;pan&quot;) {</a>
<a name="ln1844">                  double pan = _e.readElementText().toDouble();</a>
<a name="ln1845">                  if (pan &gt;= -90 &amp;&amp; pan &lt;= 90) {</a>
<a name="ln1846">                        if (_drumsets[partId].contains(instrId))</a>
<a name="ln1847">                              _drumsets[partId][instrId].midiPan = static_cast&lt;int&gt;(((pan + 90) / 180) * 127);</a>
<a name="ln1848">                        }</a>
<a name="ln1849">                  else</a>
<a name="ln1850">                        _logger-&gt;logError(QString(&quot;incorrect midi-volume: %g1&quot;).arg(pan), &amp;_e);</a>
<a name="ln1851">                  }</a>
<a name="ln1852">            else</a>
<a name="ln1853">                  skipLogCurrElem();</a>
<a name="ln1854">            }</a>
<a name="ln1855">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;midi-instrument&quot;);</a>
<a name="ln1856">      }</a>
<a name="ln1857"> </a>
<a name="ln1858">//---------------------------------------------------------</a>
<a name="ln1859">//   setNumberOfStavesForPart</a>
<a name="ln1860">//---------------------------------------------------------</a>
<a name="ln1861"> </a>
<a name="ln1862">/**</a>
<a name="ln1863"> Set number of staves for part \a partId to the max value</a>
<a name="ln1864"> of the current value \a staves.</a>
<a name="ln1865"> */</a>
<a name="ln1866"> </a>
<a name="ln1867">static void setNumberOfStavesForPart(Part* const part, const int staves)</a>
<a name="ln1868">      {</a>
<a name="ln1869">      Q_ASSERT(part);</a>
<a name="ln1870">      if (staves &gt; part-&gt;nstaves())</a>
<a name="ln1871">            part-&gt;setStaves(staves);</a>
<a name="ln1872">      }</a>
<a name="ln1873"> </a>
<a name="ln1874">//---------------------------------------------------------</a>
<a name="ln1875">//   part</a>
<a name="ln1876">//---------------------------------------------------------</a>
<a name="ln1877"> </a>
<a name="ln1878">/**</a>
<a name="ln1879"> Parse the /score-partwise/part node:</a>
<a name="ln1880"> read the parts data to determine measure timing and octave shifts.</a>
<a name="ln1881"> Assign voices and staves.</a>
<a name="ln1882"> */</a>
<a name="ln1883"> </a>
<a name="ln1884">void MusicXMLParserPass1::part()</a>
<a name="ln1885">      {</a>
<a name="ln1886">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;part&quot;);</a>
<a name="ln1887">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::part&quot;, &amp;_e);</a>
<a name="ln1888">      const QString id = _e.attributes().value(&quot;id&quot;).toString();</a>
<a name="ln1889"> </a>
<a name="ln1890">      if (!_parts.contains(id)) {</a>
<a name="ln1891">            _logger-&gt;logError(QString(&quot;cannot find part '%1'&quot;).arg(id), &amp;_e);</a>
<a name="ln1892">            skipLogCurrElem();</a>
<a name="ln1893">            }</a>
<a name="ln1894"> </a>
<a name="ln1895">      initPartState(id);</a>
<a name="ln1896"> </a>
<a name="ln1897">      VoiceOverlapDetector vod;</a>
<a name="ln1898">      Fraction time;  // current time within part</a>
<a name="ln1899">      Fraction mdur;  // measure duration</a>
<a name="ln1900"> </a>
<a name="ln1901">      int measureNr = 0;</a>
<a name="ln1902">      while (_e.readNextStartElement()) {</a>
<a name="ln1903">            if (_e.name() == &quot;measure&quot;) {</a>
<a name="ln1904">                  measure(id, time, mdur, vod, measureNr);</a>
<a name="ln1905">                  time += mdur;</a>
<a name="ln1906">                  ++measureNr;</a>
<a name="ln1907">                  }</a>
<a name="ln1908">            else</a>
<a name="ln1909">                  skipLogCurrElem();</a>
<a name="ln1910">            }</a>
<a name="ln1911"> </a>
<a name="ln1912">      // Bug fix for Cubase 6.5.5..9.5.10 which generate &lt;staff&gt;2&lt;/staff&gt; in a single staff part</a>
<a name="ln1913">      setNumberOfStavesForPart(_partMap.value(id), _parts[id].maxStaff());</a>
<a name="ln1914">      // allocate MuseScore staff to MusicXML voices</a>
<a name="ln1915">      allocateStaves(_parts[id].voicelist);</a>
<a name="ln1916">      // allocate MuseScore voice to MusicXML voices</a>
<a name="ln1917">      allocateVoices(_parts[id].voicelist);</a>
<a name="ln1918">      // calculate the octave shifts</a>
<a name="ln1919">      _parts[id].calcOctaveShifts();</a>
<a name="ln1920">      // set first instrument for multi-instrument part starting with rest</a>
<a name="ln1921">      if (_firstInstrId != &quot;&quot; &amp;&amp; _firstInstrSTime &gt; Fraction(0, 1))</a>
<a name="ln1922">            _parts[id]._instrList.setInstrument(_firstInstrId, Fraction(0, 1));</a>
<a name="ln1923">      // determine the lyric numbers for this part</a>
<a name="ln1924">      _parts[id].lyricNumberHandler().determineLyricNos();</a>
<a name="ln1925"> </a>
<a name="ln1926">      // debug: print results</a>
<a name="ln1927">      //qDebug(&quot;%s&quot;, qPrintable(_parts[id].toString()));</a>
<a name="ln1928"> </a>
<a name="ln1929">      //qDebug(&quot;lyric numbers: %s&quot;, qPrintable(_parts[id].lyricNumberHandler().toString()));</a>
<a name="ln1930"> </a>
<a name="ln1931">      /*</a>
<a name="ln1932">      qDebug(&quot;instrument map:&quot;);</a>
<a name="ln1933">      for (auto&amp; instr: _parts[id]._instrList) {</a>
<a name="ln1934">            qDebug(&quot;%s %s&quot;, qPrintable(instr.first.print()), qPrintable(instr.second));</a>
<a name="ln1935">            }</a>
<a name="ln1936">      */</a>
<a name="ln1937"> </a>
<a name="ln1938">      /*</a>
<a name="ln1939">      qDebug(&quot;voiceMapperStats: new staff&quot;);</a>
<a name="ln1940">      VoiceList&amp; vl = _parts[id].voicelist;</a>
<a name="ln1941">      for (auto i = vl.constBegin(); i != vl.constEnd(); ++i) {</a>
<a name="ln1942">            qDebug(&quot;voiceMapperStats: voice %s staff data %s&quot;,</a>
<a name="ln1943">                   qPrintable(i.key()), qPrintable(i.value().toString()));</a>
<a name="ln1944">            }</a>
<a name="ln1945">      */</a>
<a name="ln1946">      }</a>
<a name="ln1947"> </a>
<a name="ln1948">//---------------------------------------------------------</a>
<a name="ln1949">//   measureDurationAsFraction</a>
<a name="ln1950">//---------------------------------------------------------</a>
<a name="ln1951"> </a>
<a name="ln1952">/**</a>
<a name="ln1953"> Determine a suitable measure duration value given the time signature</a>
<a name="ln1954"> by setting the duration denominator to be greater than or equal</a>
<a name="ln1955"> to the time signature denominator</a>
<a name="ln1956"> */</a>
<a name="ln1957"> </a>
<a name="ln1958">static Fraction measureDurationAsFraction(const Fraction length, const int tsigtype)</a>
<a name="ln1959">      {</a>
<a name="ln1960">      if (tsigtype &lt;= 0)</a>
<a name="ln1961">            // invalid tsigtype</a>
<a name="ln1962">            return length;</a>
<a name="ln1963"> </a>
<a name="ln1964">      Fraction res = length;</a>
<a name="ln1965">      while (res.denominator() &lt; tsigtype) {</a>
<a name="ln1966">            res.setNumerator(res.numerator() * 2);</a>
<a name="ln1967">            res.setDenominator(res.denominator() * 2);</a>
<a name="ln1968">            }</a>
<a name="ln1969">      return res;</a>
<a name="ln1970">      }</a>
<a name="ln1971"> </a>
<a name="ln1972">//---------------------------------------------------------</a>
<a name="ln1973">//   measure</a>
<a name="ln1974">//---------------------------------------------------------</a>
<a name="ln1975"> </a>
<a name="ln1976">/**</a>
<a name="ln1977"> Parse the /score-partwise/part/measure node:</a>
<a name="ln1978"> read the measures data as required to determine measure timing, octave shifts</a>
<a name="ln1979"> and assign voices and staves.</a>
<a name="ln1980"> */</a>
<a name="ln1981"> </a>
<a name="ln1982">void MusicXMLParserPass1::measure(const QString&amp; partId,</a>
<a name="ln1983">                                  const Fraction cTime,</a>
<a name="ln1984">                                  Fraction&amp; mdur,</a>
<a name="ln1985">                                  VoiceOverlapDetector&amp; vod,</a>
<a name="ln1986">                                  const int measureNr)</a>
<a name="ln1987">      {</a>
<a name="ln1988">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;measure&quot;);</a>
<a name="ln1989">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::measure&quot;, &amp;_e);</a>
<a name="ln1990">      QString number = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln1991"> </a>
<a name="ln1992">      Fraction mTime; // current time stamp within measure</a>
<a name="ln1993">      Fraction mDura; // current total measure duration</a>
<a name="ln1994">      vod.newMeasure();</a>
<a name="ln1995">      MxmlTupletStates tupletStates;</a>
<a name="ln1996"> </a>
<a name="ln1997">      while (_e.readNextStartElement()) {</a>
<a name="ln1998">            if (_e.name() == &quot;attributes&quot;)</a>
<a name="ln1999">                  attributes(partId, cTime + mTime);</a>
<a name="ln2000">            else if (_e.name() == &quot;barline&quot;)</a>
<a name="ln2001">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2002">            else if (_e.name() == &quot;note&quot;) {</a>
<a name="ln2003">                  Fraction missingPrev;</a>
<a name="ln2004">                  Fraction dura;</a>
<a name="ln2005">                  Fraction missingCurr;</a>
<a name="ln2006">                  // note: chord and grace note handling done in note()</a>
<a name="ln2007">                  note(partId, cTime + mTime, missingPrev, dura, missingCurr, vod, tupletStates);</a>
<a name="ln2008">                  if (missingPrev.isValid()) {</a>
<a name="ln2009">                        mTime += missingPrev;</a>
<a name="ln2010">                        }</a>
<a name="ln2011">                  if (dura.isValid()) {</a>
<a name="ln2012">                        mTime += dura;</a>
<a name="ln2013">                        }</a>
<a name="ln2014">                  if (missingCurr.isValid()) {</a>
<a name="ln2015">                        mTime += missingCurr;</a>
<a name="ln2016">                        }</a>
<a name="ln2017">                  if (mTime &gt; mDura)</a>
<a name="ln2018">                        mDura = mTime;</a>
<a name="ln2019">                  }</a>
<a name="ln2020">            else if (_e.name() == &quot;forward&quot;) {</a>
<a name="ln2021">                  Fraction dura;</a>
<a name="ln2022">                  forward(dura);</a>
<a name="ln2023">                  if (dura.isValid()) {</a>
<a name="ln2024">                        mTime += dura;</a>
<a name="ln2025">                        if (mTime &gt; mDura)</a>
<a name="ln2026">                              mDura = mTime;</a>
<a name="ln2027">                        }</a>
<a name="ln2028">                  }</a>
<a name="ln2029">            else if (_e.name() == &quot;backup&quot;) {</a>
<a name="ln2030">                  Fraction dura;</a>
<a name="ln2031">                  backup(dura);</a>
<a name="ln2032">                  if (dura.isValid()) {</a>
<a name="ln2033">                        if (dura &lt;= mTime)</a>
<a name="ln2034">                              mTime -= dura;</a>
<a name="ln2035">                        else {</a>
<a name="ln2036">                              _logger-&gt;logError(&quot;backup beyond measure start&quot;, &amp;_e);</a>
<a name="ln2037">                              mTime.set(0, 1);</a>
<a name="ln2038">                              }</a>
<a name="ln2039">                        }</a>
<a name="ln2040">                  }</a>
<a name="ln2041">            else if (_e.name() == &quot;direction&quot;)</a>
<a name="ln2042">                  direction(partId, cTime + mTime);</a>
<a name="ln2043">            else if (_e.name() == &quot;harmony&quot;)</a>
<a name="ln2044">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2045">            else if (_e.name() == &quot;print&quot;)</a>
<a name="ln2046">                  print(measureNr);</a>
<a name="ln2047">            else if (_e.name() == &quot;sound&quot;)</a>
<a name="ln2048">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2049">            else</a>
<a name="ln2050">                  skipLogCurrElem();</a>
<a name="ln2051"> </a>
<a name="ln2052">            /*</a>
<a name="ln2053">             qDebug(&quot;mTime %s (%s) mDura %s (%s)&quot;,</a>
<a name="ln2054">             qPrintable(mTime.print()),</a>
<a name="ln2055">             qPrintable(mTime.reduced().print()),</a>
<a name="ln2056">             qPrintable(mDura.print()),</a>
<a name="ln2057">             qPrintable(mDura.reduced().print()));</a>
<a name="ln2058">             */</a>
<a name="ln2059">            }</a>
<a name="ln2060"> </a>
<a name="ln2061">      // debug vod</a>
<a name="ln2062">      // vod.dump();</a>
<a name="ln2063">      // copy overlap data from vod to voicelist</a>
<a name="ln2064">      copyOverlapData(vod, _parts[partId].voicelist);</a>
<a name="ln2065"> </a>
<a name="ln2066">      // measure duration fixups</a>
<a name="ln2067">      mDura.reduce();</a>
<a name="ln2068"> </a>
<a name="ln2069">      // fix for PDFtoMusic Pro v1.3.0d Build BF4E and PlayScore / ReadScoreLib Version 3.11</a>
<a name="ln2070">      // which sometimes generate empty measures</a>
<a name="ln2071">      // if no valid length found and length according to time signature is known,</a>
<a name="ln2072">      // use length according to time signature</a>
<a name="ln2073">      if (mDura.isZero() &amp;&amp; _timeSigDura.isValid() &amp;&amp; _timeSigDura &gt; Fraction(0, 1))</a>
<a name="ln2074">            mDura = _timeSigDura;</a>
<a name="ln2075">      // if no valid length found and time signature is unknown, use default</a>
<a name="ln2076">      if (mDura.isZero() &amp;&amp; !_timeSigDura.isValid())</a>
<a name="ln2077">            mDura = Fraction(4, 4);</a>
<a name="ln2078"> </a>
<a name="ln2079">      // if necessary, round up to an integral number of 1/64s,</a>
<a name="ln2080">      // to comply with MuseScores actual measure length constraints</a>
<a name="ln2081">      // TODO: calculate in fraction</a>
<a name="ln2082">      int length = mDura.ticks();</a>
<a name="ln2083">      int correctedLength = length;</a>
<a name="ln2084">      if ((length % (MScore::division/16)) != 0) {</a>
<a name="ln2085">            correctedLength = ((length / (MScore::division/16)) + 1) * (MScore::division/16);</a>
<a name="ln2086">            mDura = Fraction::fromTicks(correctedLength);</a>
<a name="ln2087">            }</a>
<a name="ln2088"> </a>
<a name="ln2089">      // set measure duration to a suitable value given the time signature</a>
<a name="ln2090">      if (_timeSigDura.isValid() &amp;&amp; _timeSigDura &gt; Fraction(0, 1)) {</a>
<a name="ln2091">            int btp = _timeSigDura.denominator();</a>
<a name="ln2092">            if (btp &gt; 0)</a>
<a name="ln2093">                  mDura = measureDurationAsFraction(mDura, btp);</a>
<a name="ln2094">            }</a>
<a name="ln2095"> </a>
<a name="ln2096">      // set return value(s)</a>
<a name="ln2097">      mdur = mDura;</a>
<a name="ln2098"> </a>
<a name="ln2099">      // set measure number and duration</a>
<a name="ln2100">      /*</a>
<a name="ln2101">      qDebug(&quot;part %s measure %s dura %s (%d)&quot;,</a>
<a name="ln2102">             qPrintable(partId), qPrintable(number), qPrintable(mdur.print()), mdur.ticks());</a>
<a name="ln2103">       */</a>
<a name="ln2104">      _parts[partId].addMeasureNumberAndDuration(number, mdur);</a>
<a name="ln2105">      }</a>
<a name="ln2106"> </a>
<a name="ln2107">//---------------------------------------------------------</a>
<a name="ln2108">//   print</a>
<a name="ln2109">//---------------------------------------------------------</a>
<a name="ln2110"> </a>
<a name="ln2111">void MusicXMLParserPass1::print(const int measureNr)</a>
<a name="ln2112">      {</a>
<a name="ln2113">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;print&quot;);</a>
<a name="ln2114">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::print&quot;, &amp;_e);</a>
<a name="ln2115"> </a>
<a name="ln2116">      const QString newPage = _e.attributes().value(&quot;new-page&quot;).toString();</a>
<a name="ln2117">      const QString newSystem = _e.attributes().value(&quot;new-system&quot;).toString();</a>
<a name="ln2118">      if (newPage == &quot;yes&quot;)</a>
<a name="ln2119">            _pageStartMeasureNrs.insert(measureNr);</a>
<a name="ln2120">      if (newSystem == &quot;yes&quot;)</a>
<a name="ln2121">            _systemStartMeasureNrs.insert(measureNr);</a>
<a name="ln2122"> </a>
<a name="ln2123">      _e.skipCurrentElement();        // skip but don't log</a>
<a name="ln2124">      }</a>
<a name="ln2125"> </a>
<a name="ln2126">//---------------------------------------------------------</a>
<a name="ln2127">//   attributes</a>
<a name="ln2128">//---------------------------------------------------------</a>
<a name="ln2129"> </a>
<a name="ln2130">/**</a>
<a name="ln2131"> Parse the /score-partwise/part/measure/attributes node.</a>
<a name="ln2132"> */</a>
<a name="ln2133"> </a>
<a name="ln2134">void MusicXMLParserPass1::attributes(const QString&amp; partId, const Fraction cTime)</a>
<a name="ln2135">      {</a>
<a name="ln2136">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;attributes&quot;);</a>
<a name="ln2137">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::attributes&quot;, &amp;_e);</a>
<a name="ln2138"> </a>
<a name="ln2139">      while (_e.readNextStartElement()) {</a>
<a name="ln2140">            if (_e.name() == &quot;clef&quot;)</a>
<a name="ln2141">                  clef(partId);</a>
<a name="ln2142">            else if (_e.name() == &quot;divisions&quot;)</a>
<a name="ln2143">                  divisions();</a>
<a name="ln2144">            else if (_e.name() == &quot;key&quot;)</a>
<a name="ln2145">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2146">            else if (_e.name() == &quot;instruments&quot;)</a>
<a name="ln2147">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2148">            else if (_e.name() == &quot;staff-details&quot;)</a>
<a name="ln2149">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2150">            else if (_e.name() == &quot;staves&quot;)</a>
<a name="ln2151">                  staves(partId);</a>
<a name="ln2152">            else if (_e.name() == &quot;time&quot;)</a>
<a name="ln2153">                  time(cTime);</a>
<a name="ln2154">            else if (_e.name() == &quot;transpose&quot;)</a>
<a name="ln2155">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2156">            else</a>
<a name="ln2157">                  skipLogCurrElem();</a>
<a name="ln2158">            }</a>
<a name="ln2159">      }</a>
<a name="ln2160"> </a>
<a name="ln2161">//---------------------------------------------------------</a>
<a name="ln2162">//   clef</a>
<a name="ln2163">//---------------------------------------------------------</a>
<a name="ln2164"> </a>
<a name="ln2165">/**</a>
<a name="ln2166"> Parse the /score-partwise/part/measure/attributes/clef node.</a>
<a name="ln2167"> TODO: Store the clef type, to simplify staff type setting in pass 2.</a>
<a name="ln2168"> */</a>
<a name="ln2169"> </a>
<a name="ln2170">void MusicXMLParserPass1::clef(const QString&amp; /* partId */)</a>
<a name="ln2171">      {</a>
<a name="ln2172">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;clef&quot;);</a>
<a name="ln2173">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::clef&quot;, &amp;_e);</a>
<a name="ln2174"> </a>
<a name="ln2175">      QString number = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln2176">      int n = 0;</a>
<a name="ln2177">      if (number != &quot;&quot;) {</a>
<a name="ln2178">            n = number.toInt();</a>
<a name="ln2179">            if (n &lt;= 0) {</a>
<a name="ln2180">                  _logger-&gt;logError(QString(&quot;invalid number %1&quot;).arg(number), &amp;_e);</a>
<a name="ln2181">                  n = 0;</a>
<a name="ln2182">                  }</a>
<a name="ln2183">            else</a>
<a name="ln2184">                  n--;              // make zero-based</a>
<a name="ln2185">            }</a>
<a name="ln2186"> </a>
<a name="ln2187">      while (_e.readNextStartElement()) {</a>
<a name="ln2188">            if (_e.name() == &quot;line&quot;)</a>
<a name="ln2189">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2190">            else if (_e.name() == &quot;sign&quot;)</a>
<a name="ln2191">                  QString sign = _e.readElementText();</a>
<a name="ln2192">            else</a>
<a name="ln2193">                  skipLogCurrElem();</a>
<a name="ln2194">            }</a>
<a name="ln2195">      }</a>
<a name="ln2196"> </a>
<a name="ln2197">//---------------------------------------------------------</a>
<a name="ln2198">//   determineTimeSig</a>
<a name="ln2199">//---------------------------------------------------------</a>
<a name="ln2200"> </a>
<a name="ln2201">/**</a>
<a name="ln2202"> Determine the time signature based on \a beats, \a beatType and \a timeSymbol.</a>
<a name="ln2203"> Sets return parameters \a st, \a bts, \a btp.</a>
<a name="ln2204"> Return true if OK, false on error.</a>
<a name="ln2205"> */</a>
<a name="ln2206"> </a>
<a name="ln2207">// TODO: share between pass 1 and pass 2</a>
<a name="ln2208"> </a>
<a name="ln2209">static bool determineTimeSig(MxmlLogger* logger, const QXmlStreamReader* const xmlreader,</a>
<a name="ln2210">                             const QString beats, const QString beatType, const QString timeSymbol,</a>
<a name="ln2211">                             TimeSigType&amp; st, int&amp; bts, int&amp; btp)</a>
<a name="ln2212">      {</a>
<a name="ln2213">      // initialize</a>
<a name="ln2214">      st  = TimeSigType::NORMAL;</a>
<a name="ln2215">      bts = 0;             // the beats (max 4 separated by &quot;+&quot;) as integer</a>
<a name="ln2216">      btp = 0;             // beat-type as integer</a>
<a name="ln2217">      // determine if timesig is valid</a>
<a name="ln2218">      if (beats == &quot;2&quot; &amp;&amp; beatType == &quot;2&quot; &amp;&amp; timeSymbol == &quot;cut&quot;) {</a>
<a name="ln2219">            st = TimeSigType::ALLA_BREVE;</a>
<a name="ln2220">            bts = 2;</a>
<a name="ln2221">            btp = 2;</a>
<a name="ln2222">            return true;</a>
<a name="ln2223">            }</a>
<a name="ln2224">      else if (beats == &quot;4&quot; &amp;&amp; beatType == &quot;4&quot; &amp;&amp; timeSymbol == &quot;common&quot;) {</a>
<a name="ln2225">            st = TimeSigType::FOUR_FOUR;</a>
<a name="ln2226">            bts = 4;</a>
<a name="ln2227">            btp = 4;</a>
<a name="ln2228">            return true;</a>
<a name="ln2229">            }</a>
<a name="ln2230">      else {</a>
<a name="ln2231">            if (!timeSymbol.isEmpty() &amp;&amp; timeSymbol != &quot;normal&quot;) {</a>
<a name="ln2232">                  logger-&gt;logError(QString(&quot;time symbol '%1' not recognized with beats=%2 and beat-type=%3&quot;)</a>
<a name="ln2233">                                   .arg(timeSymbol).arg(beats).arg(beatType), xmlreader);</a>
<a name="ln2234">                  return false;</a>
<a name="ln2235">                  }</a>
<a name="ln2236"> </a>
<a name="ln2237">            btp = beatType.toInt();</a>
<a name="ln2238">            QStringList list = beats.split(&quot;+&quot;);</a>
<a name="ln2239">            for (int i = 0; i &lt; list.size(); i++)</a>
<a name="ln2240">                  bts += list.at(i).toInt();</a>
<a name="ln2241">            }</a>
<a name="ln2242"> </a>
<a name="ln2243">      // determine if bts and btp are valid</a>
<a name="ln2244">      if (bts &lt;= 0 || btp &lt;=0) {</a>
<a name="ln2245">            logger-&gt;logError(QString(&quot;beats=%1 and/or beat-type=%2 not recognized&quot;)</a>
<a name="ln2246">                             .arg(beats).arg(beatType), xmlreader);</a>
<a name="ln2247">            return false;</a>
<a name="ln2248">            }</a>
<a name="ln2249"> </a>
<a name="ln2250">      return true;</a>
<a name="ln2251">      }</a>
<a name="ln2252"> </a>
<a name="ln2253">//---------------------------------------------------------</a>
<a name="ln2254">//   time</a>
<a name="ln2255">//---------------------------------------------------------</a>
<a name="ln2256"> </a>
<a name="ln2257">/**</a>
<a name="ln2258"> Parse the /score-partwise/part/measure/attributes/time node.</a>
<a name="ln2259"> */</a>
<a name="ln2260"> </a>
<a name="ln2261">void MusicXMLParserPass1::time(const Fraction cTime)</a>
<a name="ln2262">      {</a>
<a name="ln2263">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;time&quot;);</a>
<a name="ln2264"> </a>
<a name="ln2265">      QString beats;</a>
<a name="ln2266">      QString beatType;</a>
<a name="ln2267">      QString timeSymbol = _e.attributes().value(&quot;symbol&quot;).toString();</a>
<a name="ln2268"> </a>
<a name="ln2269">      while (_e.readNextStartElement()) {</a>
<a name="ln2270">            if (_e.name() == &quot;beats&quot;)</a>
<a name="ln2271">                  beats = _e.readElementText();</a>
<a name="ln2272">            else if (_e.name() == &quot;beat-type&quot;)</a>
<a name="ln2273">                  beatType = _e.readElementText();</a>
<a name="ln2274">            else</a>
<a name="ln2275">                  skipLogCurrElem();</a>
<a name="ln2276">            }</a>
<a name="ln2277"> </a>
<a name="ln2278">      if (beats != &quot;&quot; &amp;&amp; beatType != &quot;&quot;) {</a>
<a name="ln2279">            // determine if timesig is valid</a>
<a name="ln2280">            TimeSigType st  = TimeSigType::NORMAL;</a>
<a name="ln2281">            int bts = 0;       // total beats as integer (beats may contain multiple numbers, separated by &quot;+&quot;)</a>
<a name="ln2282">            int btp = 0;       // beat-type as integer</a>
<a name="ln2283">            if (determineTimeSig(_logger, &amp;_e, beats, beatType, timeSymbol, st, bts, btp)) {</a>
<a name="ln2284">                  _timeSigDura = Fraction(bts, btp);</a>
<a name="ln2285">                  _score-&gt;sigmap()-&gt;add(cTime.ticks(), _timeSigDura);</a>
<a name="ln2286">                  }</a>
<a name="ln2287">            }</a>
<a name="ln2288">      }</a>
<a name="ln2289"> </a>
<a name="ln2290">//---------------------------------------------------------</a>
<a name="ln2291">//   divisions</a>
<a name="ln2292">//---------------------------------------------------------</a>
<a name="ln2293"> </a>
<a name="ln2294">/**</a>
<a name="ln2295"> Parse the /score-partwise/part/measure/attributes/divisions node.</a>
<a name="ln2296"> */</a>
<a name="ln2297"> </a>
<a name="ln2298">void MusicXMLParserPass1::divisions()</a>
<a name="ln2299">      {</a>
<a name="ln2300">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;divisions&quot;);</a>
<a name="ln2301"> </a>
<a name="ln2302">      _divs = _e.readElementText().toInt();</a>
<a name="ln2303">      if (!(_divs &gt; 0))</a>
<a name="ln2304">            _logger-&gt;logError(&quot;illegal divisions&quot;, &amp;_e);</a>
<a name="ln2305">      }</a>
<a name="ln2306"> </a>
<a name="ln2307">//---------------------------------------------------------</a>
<a name="ln2308">//   staves</a>
<a name="ln2309">//---------------------------------------------------------</a>
<a name="ln2310"> </a>
<a name="ln2311">/**</a>
<a name="ln2312"> Parse the /score-partwise/part/measure/attributes/staves node.</a>
<a name="ln2313"> */</a>
<a name="ln2314"> </a>
<a name="ln2315">void MusicXMLParserPass1::staves(const QString&amp; partId)</a>
<a name="ln2316">      {</a>
<a name="ln2317">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;staves&quot;);</a>
<a name="ln2318">      _logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::staves&quot;, &amp;_e);</a>
<a name="ln2319"> </a>
<a name="ln2320">      int staves = _e.readElementText().toInt();</a>
<a name="ln2321">      if (!(staves &gt; 0 &amp;&amp; staves &lt;= MAX_STAVES)) {</a>
<a name="ln2322">            _logger-&gt;logError(&quot;illegal staves&quot;, &amp;_e);</a>
<a name="ln2323">            return;</a>
<a name="ln2324">            }</a>
<a name="ln2325"> </a>
<a name="ln2326">      setNumberOfStavesForPart(_partMap.value(partId), staves);</a>
<a name="ln2327">      }</a>
<a name="ln2328"> </a>
<a name="ln2329">//---------------------------------------------------------</a>
<a name="ln2330">//   direction</a>
<a name="ln2331">//---------------------------------------------------------</a>
<a name="ln2332"> </a>
<a name="ln2333">/**</a>
<a name="ln2334"> Parse the /score-partwise/part/measure/direction node</a>
<a name="ln2335"> to be able to handle octave-shifts, as these must be interpreted</a>
<a name="ln2336"> in musical order instead of in MusicXML file order.</a>
<a name="ln2337"> */</a>
<a name="ln2338"> </a>
<a name="ln2339">void MusicXMLParserPass1::direction(const QString&amp; partId, const Fraction cTime)</a>
<a name="ln2340">      {</a>
<a name="ln2341">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;direction&quot;);</a>
<a name="ln2342"> </a>
<a name="ln2343">      // note: file order is direction-type first, then staff</a>
<a name="ln2344">      // this means staff is still unknown when direction-type is handled</a>
<a name="ln2345"> </a>
<a name="ln2346">      QList&lt;MxmlOctaveShiftDesc&gt; starts;</a>
<a name="ln2347">      QList&lt;MxmlOctaveShiftDesc&gt; stops;</a>
<a name="ln2348">      int staff = 0;</a>
<a name="ln2349"> </a>
<a name="ln2350">      while (_e.readNextStartElement()) {</a>
<a name="ln2351">            if (_e.name() == &quot;direction-type&quot;)</a>
<a name="ln2352">                  directionType(cTime, starts, stops);</a>
<a name="ln2353">            else if (_e.name() == &quot;staff&quot;) {</a>
<a name="ln2354">                  int nstaves = getPart(partId)-&gt;nstaves();</a>
<a name="ln2355">                  QString strStaff = _e.readElementText();</a>
<a name="ln2356">                  staff = strStaff.toInt() - 1;</a>
<a name="ln2357">                  if (0 &lt;= staff &amp;&amp; staff &lt; nstaves)</a>
<a name="ln2358">                        ;  //qDebug(&quot;direction staff %d&quot;, staff + 1);</a>
<a name="ln2359">                  else {</a>
<a name="ln2360">                        _logger-&gt;logError(QString(&quot;invalid staff %1&quot;).arg(strStaff), &amp;_e);</a>
<a name="ln2361">                        staff = 0;</a>
<a name="ln2362">                        }</a>
<a name="ln2363">                  }</a>
<a name="ln2364">            else</a>
<a name="ln2365">                  _e.skipCurrentElement();</a>
<a name="ln2366">            }</a>
<a name="ln2367"> </a>
<a name="ln2368">      // handle the stops first</a>
<a name="ln2369">      foreach (auto desc, stops) {</a>
<a name="ln2370">            if (_octaveShifts.contains(desc.num)) {</a>
<a name="ln2371">                  MxmlOctaveShiftDesc prevDesc = _octaveShifts.value(desc.num);</a>
<a name="ln2372">                  if (prevDesc.tp == MxmlOctaveShiftDesc::Type::UP</a>
<a name="ln2373">                      || prevDesc.tp == MxmlOctaveShiftDesc::Type::DOWN) {</a>
<a name="ln2374">                        // a complete pair</a>
<a name="ln2375">                        _parts[partId].addOctaveShift(staff, prevDesc.size, prevDesc.time);</a>
<a name="ln2376">                        _parts[partId].addOctaveShift(staff, -prevDesc.size, desc.time);</a>
<a name="ln2377">                        }</a>
<a name="ln2378">                  else</a>
<a name="ln2379">                        _logger-&gt;logError(&quot;double octave-shift stop&quot;, &amp;_e);</a>
<a name="ln2380">                  _octaveShifts.remove(desc.num);</a>
<a name="ln2381">                  }</a>
<a name="ln2382">            else</a>
<a name="ln2383">                  _octaveShifts.insert(desc.num, desc);</a>
<a name="ln2384">            }</a>
<a name="ln2385"> </a>
<a name="ln2386">      // then handle the starts</a>
<a name="ln2387">      foreach (auto desc, starts) {</a>
<a name="ln2388">            if (_octaveShifts.contains(desc.num)) {</a>
<a name="ln2389">                  MxmlOctaveShiftDesc prevDesc = _octaveShifts.value(desc.num);</a>
<a name="ln2390">                  if (prevDesc.tp == MxmlOctaveShiftDesc::Type::STOP) {</a>
<a name="ln2391">                        // a complete pair</a>
<a name="ln2392">                        _parts[partId].addOctaveShift(staff, desc.size, desc.time);</a>
<a name="ln2393">                        _parts[partId].addOctaveShift(staff, -desc.size, prevDesc.time);</a>
<a name="ln2394">                        }</a>
<a name="ln2395">                  else</a>
<a name="ln2396">                        _logger-&gt;logError(&quot;double octave-shift start&quot;, &amp;_e);</a>
<a name="ln2397">                  _octaveShifts.remove(desc.num);</a>
<a name="ln2398">                  }</a>
<a name="ln2399">            else</a>
<a name="ln2400">                  _octaveShifts.insert(desc.num, desc);</a>
<a name="ln2401">            }</a>
<a name="ln2402">      }</a>
<a name="ln2403"> </a>
<a name="ln2404">//---------------------------------------------------------</a>
<a name="ln2405">//   directionType</a>
<a name="ln2406">//---------------------------------------------------------</a>
<a name="ln2407"> </a>
<a name="ln2408">/**</a>
<a name="ln2409"> Parse the /score-partwise/part/measure/direction/direction-type node.</a>
<a name="ln2410"> */</a>
<a name="ln2411"> </a>
<a name="ln2412">void MusicXMLParserPass1::directionType(const Fraction cTime,</a>
<a name="ln2413">                                        QList&lt;MxmlOctaveShiftDesc&gt;&amp; starts,</a>
<a name="ln2414">                                        QList&lt;MxmlOctaveShiftDesc&gt;&amp; stops)</a>
<a name="ln2415">      {</a>
<a name="ln2416">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;direction-type&quot;);</a>
<a name="ln2417"> </a>
<a name="ln2418">      while (_e.readNextStartElement()) {</a>
<a name="ln2419">            if (_e.name() == &quot;octave-shift&quot;) {</a>
<a name="ln2420">                  QString number = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln2421">                  int n = 0;</a>
<a name="ln2422">                  if (number != &quot;&quot;) {</a>
<a name="ln2423">                        n = number.toInt();</a>
<a name="ln2424">                        if (n &lt;= 0)</a>
<a name="ln2425">                              _logger-&gt;logError(QString(&quot;invalid number %1&quot;).arg(number), &amp;_e);</a>
<a name="ln2426">                        else</a>
<a name="ln2427">                              n--;  // make zero-based</a>
<a name="ln2428">                        }</a>
<a name="ln2429"> </a>
<a name="ln2430">                  if (0 &lt;= n &amp;&amp; n &lt; MAX_NUMBER_LEVEL) {</a>
<a name="ln2431">                        short size = _e.attributes().value(&quot;size&quot;).toShort();</a>
<a name="ln2432">                        QString type = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln2433">                        //qDebug(&quot;octave-shift type '%s' size %d number %d&quot;, qPrintable(type), size, n);</a>
<a name="ln2434">                        MxmlOctaveShiftDesc osDesc;</a>
<a name="ln2435">                        handleOctaveShift(cTime, type, size, osDesc);</a>
<a name="ln2436">                        osDesc.num = n;</a>
<a name="ln2437">                        if (osDesc.tp == MxmlOctaveShiftDesc::Type::UP</a>
<a name="ln2438">                            || osDesc.tp == MxmlOctaveShiftDesc::Type::DOWN)</a>
<a name="ln2439">                              starts.append(osDesc);</a>
<a name="ln2440">                        else if (osDesc.tp == MxmlOctaveShiftDesc::Type::STOP)</a>
<a name="ln2441">                              stops.append(osDesc);</a>
<a name="ln2442">                        }</a>
<a name="ln2443">                  else {</a>
<a name="ln2444">                        _logger-&gt;logError(QString(&quot;invalid octave-shift number %1&quot;).arg(number), &amp;_e);</a>
<a name="ln2445">                        }</a>
<a name="ln2446">                  _e.skipCurrentElement();</a>
<a name="ln2447">                  }</a>
<a name="ln2448">            else</a>
<a name="ln2449">                  _e.skipCurrentElement();</a>
<a name="ln2450">            }</a>
<a name="ln2451"> </a>
<a name="ln2452">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;direction-type&quot;);</a>
<a name="ln2453">      }</a>
<a name="ln2454"> </a>
<a name="ln2455">//---------------------------------------------------------</a>
<a name="ln2456">//   handleOctaveShift</a>
<a name="ln2457">//---------------------------------------------------------</a>
<a name="ln2458"> </a>
<a name="ln2459">void MusicXMLParserPass1::handleOctaveShift(const Fraction cTime,</a>
<a name="ln2460">                                            const QString&amp; type, short size,</a>
<a name="ln2461">                                            MxmlOctaveShiftDesc&amp; desc)</a>
<a name="ln2462">      {</a>
<a name="ln2463">      MxmlOctaveShiftDesc::Type tp = MxmlOctaveShiftDesc::Type::NONE;</a>
<a name="ln2464">      short sz = 0;</a>
<a name="ln2465"> </a>
<a name="ln2466">      switch (size) {</a>
<a name="ln2467">            case   8: sz =  1; break;</a>
<a name="ln2468">            case  15: sz =  2; break;</a>
<a name="ln2469">            default:</a>
<a name="ln2470">                  _logger-&gt;logError(QString(&quot;invalid octave-shift size %1&quot;).arg(size), &amp;_e);</a>
<a name="ln2471">                  return;</a>
<a name="ln2472">            }</a>
<a name="ln2473"> </a>
<a name="ln2474">      if (!cTime.isValid() || cTime &lt; Fraction(0, 1))</a>
<a name="ln2475">            _logger-&gt;logError(&quot;invalid current time&quot;, &amp;_e);</a>
<a name="ln2476"> </a>
<a name="ln2477">      if (type == &quot;up&quot;)</a>
<a name="ln2478">            tp = MxmlOctaveShiftDesc::Type::UP;</a>
<a name="ln2479">      else if (type == &quot;down&quot;) {</a>
<a name="ln2480">            tp = MxmlOctaveShiftDesc::Type::DOWN;</a>
<a name="ln2481">            sz *= -1;</a>
<a name="ln2482">            }</a>
<a name="ln2483">      else if (type == &quot;stop&quot;)</a>
<a name="ln2484">            tp = MxmlOctaveShiftDesc::Type::STOP;</a>
<a name="ln2485">      else {</a>
<a name="ln2486">            _logger-&gt;logError(QString(&quot;invalid octave-shift type '%1'&quot;).arg(type), &amp;_e);</a>
<a name="ln2487">            return;</a>
<a name="ln2488">            }</a>
<a name="ln2489"> </a>
<a name="ln2490">      desc = MxmlOctaveShiftDesc(tp, sz, cTime);</a>
<a name="ln2491">      }</a>
<a name="ln2492"> </a>
<a name="ln2493">//---------------------------------------------------------</a>
<a name="ln2494">//   setFirstInstr</a>
<a name="ln2495">//---------------------------------------------------------</a>
<a name="ln2496"> </a>
<a name="ln2497">void MusicXMLParserPass1::setFirstInstr(const QString&amp; id, const Fraction stime)</a>
<a name="ln2498">      {</a>
<a name="ln2499">      // check for valid arguments</a>
<a name="ln2500">      if (id == &quot;&quot; || !stime.isValid() || stime &lt; Fraction(0, 1))</a>
<a name="ln2501">            return;</a>
<a name="ln2502"> </a>
<a name="ln2503">      // check for no instrument found yet or new earliest start time</a>
<a name="ln2504">      // note: compare using &lt;= to catch instrument at t=0</a>
<a name="ln2505">      if (_firstInstrId == &quot;&quot; || stime &lt;= _firstInstrSTime) {</a>
<a name="ln2506">            _firstInstrId = id;</a>
<a name="ln2507">            _firstInstrSTime = stime;</a>
<a name="ln2508">            }</a>
<a name="ln2509">      }</a>
<a name="ln2510"> </a>
<a name="ln2511">//---------------------------------------------------------</a>
<a name="ln2512">//   notations</a>
<a name="ln2513">//---------------------------------------------------------</a>
<a name="ln2514"> </a>
<a name="ln2515">/**</a>
<a name="ln2516"> Parse the /score-partwise/part/measure/note/notations node.</a>
<a name="ln2517"> */</a>
<a name="ln2518"> </a>
<a name="ln2519">void MusicXMLParserPass1::notations(MxmlStartStop&amp; tupletStartStop)</a>
<a name="ln2520">      {</a>
<a name="ln2521">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;notations&quot;);</a>
<a name="ln2522">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::note&quot;, &amp;_e);</a>
<a name="ln2523"> </a>
<a name="ln2524">      while (_e.readNextStartElement()) {</a>
<a name="ln2525">            if (_e.name() == &quot;tuplet&quot;) {</a>
<a name="ln2526">                  QString tupletType       = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln2527"> </a>
<a name="ln2528">                  // ignore possible children (currently not supported)</a>
<a name="ln2529">                  _e.skipCurrentElement();</a>
<a name="ln2530"> </a>
<a name="ln2531">                  if (tupletType == &quot;start&quot;)</a>
<a name="ln2532">                        tupletStartStop = MxmlStartStop::START;</a>
<a name="ln2533">                  else if (tupletType == &quot;stop&quot;)</a>
<a name="ln2534">                        tupletStartStop = MxmlStartStop::STOP;</a>
<a name="ln2535">                  else if (tupletType != &quot;&quot; &amp;&amp; tupletType != &quot;start&quot; &amp;&amp; tupletType != &quot;stop&quot;) {</a>
<a name="ln2536">                        _logger-&gt;logError(QString(&quot;unknown tuplet type '%1'&quot;).arg(tupletType), &amp;_e);</a>
<a name="ln2537">                        }</a>
<a name="ln2538">                  }</a>
<a name="ln2539">            else {</a>
<a name="ln2540">                  _e.skipCurrentElement();        // skip but don't log</a>
<a name="ln2541">                  }</a>
<a name="ln2542">            }</a>
<a name="ln2543"> </a>
<a name="ln2544">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;notations&quot;);</a>
<a name="ln2545">      }</a>
<a name="ln2546"> </a>
<a name="ln2547">//---------------------------------------------------------</a>
<a name="ln2548">//   smallestTypeAndCount</a>
<a name="ln2549">//---------------------------------------------------------</a>
<a name="ln2550"> </a>
<a name="ln2551">/**</a>
<a name="ln2552"> Determine the smallest note type and the number of those</a>
<a name="ln2553"> present in a ChordRest.</a>
<a name="ln2554"> For a note without dots the type equals the note type</a>
<a name="ln2555"> and count is one.</a>
<a name="ln2556"> For a single dotted note the type equals half the note type</a>
<a name="ln2557"> and count is three.</a>
<a name="ln2558"> A double dotted note is similar.</a>
<a name="ln2559"> Note: code assumes when duration().type() is incremented,</a>
<a name="ln2560"> the note length is divided by two, checked by tupletAssert().</a>
<a name="ln2561"> */</a>
<a name="ln2562"> </a>
<a name="ln2563">static void smallestTypeAndCount(const TDuration durType, int&amp; type, int&amp; count)</a>
<a name="ln2564">      {</a>
<a name="ln2565">      type = int(durType.type());</a>
<a name="ln2566">      count = 1;</a>
<a name="ln2567">      switch (durType.dots()) {</a>
<a name="ln2568">            case 0:</a>
<a name="ln2569">                  // nothing to do</a>
<a name="ln2570">                  break;</a>
<a name="ln2571">            case 1:</a>
<a name="ln2572">                  type += 1;       // next-smaller type</a>
<a name="ln2573">                  count = 3;</a>
<a name="ln2574">                  break;</a>
<a name="ln2575">            case 2:</a>
<a name="ln2576">                  type += 2;       // next-next-smaller type</a>
<a name="ln2577">                  count = 7;</a>
<a name="ln2578">                  break;</a>
<a name="ln2579">            default:</a>
<a name="ln2580">                  qDebug(&quot;smallestTypeAndCount() does not support more than 2 dots&quot;);</a>
<a name="ln2581">            }</a>
<a name="ln2582">      }</a>
<a name="ln2583"> </a>
<a name="ln2584">//---------------------------------------------------------</a>
<a name="ln2585">//   matchTypeAndCount</a>
<a name="ln2586">//---------------------------------------------------------</a>
<a name="ln2587"> </a>
<a name="ln2588">/**</a>
<a name="ln2589"> Given two note types and counts, if the types are not equal,</a>
<a name="ln2590"> make them equal by successively doubling the count of the</a>
<a name="ln2591"> largest type.</a>
<a name="ln2592"> */</a>
<a name="ln2593"> </a>
<a name="ln2594">static void matchTypeAndCount(int&amp; type1, int&amp; count1, int&amp; type2, int&amp; count2)</a>
<a name="ln2595">      {</a>
<a name="ln2596">      while (type1 &lt; type2) {</a>
<a name="ln2597">            type1++;</a>
<a name="ln2598">            count1 *= 2;</a>
<a name="ln2599">            }</a>
<a name="ln2600">      while (type2 &lt; type1) {</a>
<a name="ln2601">            type2++;</a>
<a name="ln2602">            count2 *= 2;</a>
<a name="ln2603">            }</a>
<a name="ln2604">      }</a>
<a name="ln2605"> </a>
<a name="ln2606">//---------------------------------------------------------</a>
<a name="ln2607">//   addDurationToTuplet</a>
<a name="ln2608">//---------------------------------------------------------</a>
<a name="ln2609"> </a>
<a name="ln2610">/**</a>
<a name="ln2611"> Add duration to tuplet duration</a>
<a name="ln2612"> Determine type and number of smallest notes in the tuplet</a>
<a name="ln2613"> */</a>
<a name="ln2614"> </a>
<a name="ln2615">void MxmlTupletState::addDurationToTuplet(const Fraction duration, const Fraction timeMod)</a>
<a name="ln2616">      {</a>
<a name="ln2617">      /*</a>
<a name="ln2618">      qDebug(&quot;1 duration %s timeMod %s -&gt; state.tupletType %d state.tupletCount %d state.actualNotes %d state.normalNotes %d&quot;,</a>
<a name="ln2619">             qPrintable(duration.print()),</a>
<a name="ln2620">             qPrintable(timeMod.print()),</a>
<a name="ln2621">             m_tupletType,</a>
<a name="ln2622">             m_tupletCount,</a>
<a name="ln2623">             m_actualNotes,</a>
<a name="ln2624">             m_normalNotes</a>
<a name="ln2625">             );</a>
<a name="ln2626">      */</a>
<a name="ln2627">      if (m_duration &lt;= Fraction(0, 1)) {</a>
<a name="ln2628">            // first note: init variables</a>
<a name="ln2629">            m_actualNotes = timeMod.denominator();</a>
<a name="ln2630">            m_normalNotes = timeMod.numerator();</a>
<a name="ln2631">            smallestTypeAndCount(duration / timeMod, m_tupletType, m_tupletCount);</a>
<a name="ln2632">            }</a>
<a name="ln2633">      else {</a>
<a name="ln2634">            int noteType = 0;</a>
<a name="ln2635">            int noteCount = 0;</a>
<a name="ln2636">            smallestTypeAndCount(duration / timeMod, noteType, noteCount);</a>
<a name="ln2637">            // match the types</a>
<a name="ln2638">            matchTypeAndCount(m_tupletType, m_tupletCount, noteType, noteCount);</a>
<a name="ln2639">            m_tupletCount += noteCount;</a>
<a name="ln2640">            }</a>
<a name="ln2641">      m_duration += duration;</a>
<a name="ln2642">      /*</a>
<a name="ln2643">      qDebug(&quot;2 duration %s -&gt; state.tupletType %d state.tupletCount %d state.actualNotes %d state.normalNotes %d&quot;,</a>
<a name="ln2644">             qPrintable(duration.print()),</a>
<a name="ln2645">             m_tupletType,</a>
<a name="ln2646">             m_tupletCount,</a>
<a name="ln2647">             m_actualNotes,</a>
<a name="ln2648">             m_normalNotes</a>
<a name="ln2649">             );</a>
<a name="ln2650">      */</a>
<a name="ln2651">      }</a>
<a name="ln2652"> </a>
<a name="ln2653">//---------------------------------------------------------</a>
<a name="ln2654">//   determineTupletFractionAndFullDuration</a>
<a name="ln2655">//---------------------------------------------------------</a>
<a name="ln2656"> </a>
<a name="ln2657">/**</a>
<a name="ln2658"> Split duration into two factors where fullDuration is note sized</a>
<a name="ln2659"> (i.e. the denominator is a power of 2), 1/2 &lt; fraction &lt;= 1/1</a>
<a name="ln2660"> and fraction * fullDuration equals duration.</a>
<a name="ln2661"> */</a>
<a name="ln2662"> </a>
<a name="ln2663">void determineTupletFractionAndFullDuration(const Fraction duration, Fraction&amp; fraction, Fraction&amp; fullDuration)</a>
<a name="ln2664">      {</a>
<a name="ln2665">      fraction = duration;</a>
<a name="ln2666">      fullDuration = Fraction(1, 1);</a>
<a name="ln2667">      // move denominator's powers of 2 from fraction to fullDuration</a>
<a name="ln2668">      while (fraction.denominator() % 2 == 0) {</a>
<a name="ln2669">            fraction *= 2;</a>
<a name="ln2670">            fraction.reduce();</a>
<a name="ln2671">            fullDuration *= Fraction(1, 2);</a>
<a name="ln2672">            }</a>
<a name="ln2673">      // move numerator's powers of 2 from fraction to fullDuration</a>
<a name="ln2674">      while ( fraction.numerator() % 2 == 0) {</a>
<a name="ln2675">            fraction *= Fraction(1, 2);</a>
<a name="ln2676">            fraction.reduce();</a>
<a name="ln2677">            fullDuration *= 2;</a>
<a name="ln2678">            fullDuration.reduce();</a>
<a name="ln2679">            }</a>
<a name="ln2680">      // make sure 1/2 &lt; fraction &lt;= 1/1</a>
<a name="ln2681">      while (fraction &lt;= Fraction(1, 2)) {</a>
<a name="ln2682">            fullDuration *= Fraction(1, 2);</a>
<a name="ln2683">            fraction *= 2;</a>
<a name="ln2684">            }</a>
<a name="ln2685">      fullDuration.reduce();</a>
<a name="ln2686">      fraction.reduce();</a>
<a name="ln2687"> </a>
<a name="ln2688">      /*</a>
<a name="ln2689">      Examples (note result when denominator is not a power of two):</a>
<a name="ln2690">      3:2 tuplet of 1/4 results in fraction 1/1 and fullDuration 1/2</a>
<a name="ln2691">      2:3 tuplet of 1/4 results in fraction 3/1 and fullDuration 1/4</a>
<a name="ln2692">      4:3 tuplet of 1/4 results in fraction 3/1 and fullDuration 1/4</a>
<a name="ln2693">      3:4 tuplet of 1/4 results in fraction 1/1 and fullDuration 1/1</a>
<a name="ln2694"> </a>
<a name="ln2695">       Bring back fraction in 1/2 .. 1/1 range.</a>
<a name="ln2696">       */</a>
<a name="ln2697"> </a>
<a name="ln2698">      if (fraction &gt; Fraction(1, 1) &amp;&amp; fraction.denominator() == 1) {</a>
<a name="ln2699">            fullDuration *= fraction;</a>
<a name="ln2700">            fullDuration.reduce();</a>
<a name="ln2701">            fraction = Fraction(1, 1);</a>
<a name="ln2702">            }</a>
<a name="ln2703"> </a>
<a name="ln2704">      /*</a>
<a name="ln2705">      qDebug(&quot;duration %s fraction %s fullDuration %s&quot;,</a>
<a name="ln2706">             qPrintable(duration.toString()),</a>
<a name="ln2707">             qPrintable(fraction.toString()),</a>
<a name="ln2708">             qPrintable(fullDuration.toString())</a>
<a name="ln2709">             );</a>
<a name="ln2710">      */</a>
<a name="ln2711">      }</a>
<a name="ln2712"> </a>
<a name="ln2713">//---------------------------------------------------------</a>
<a name="ln2714">//   isTupletFilled</a>
<a name="ln2715">//---------------------------------------------------------</a>
<a name="ln2716"> </a>
<a name="ln2717">/**</a>
<a name="ln2718"> Determine if the tuplet is completely filled,</a>
<a name="ln2719"> because either (1) it is at least the same duration</a>
<a name="ln2720"> as the specified number of the specified normal type notes</a>
<a name="ln2721"> or (2) the duration adds up to a normal note duration.</a>
<a name="ln2722"> </a>
<a name="ln2723"> Example (1): a 3:2 tuplet with a 1/4 and a 1/8 note</a>
<a name="ln2724"> is filled if normal type is 1/8,</a>
<a name="ln2725"> it is not filled if normal type is 1/4.</a>
<a name="ln2726"> </a>
<a name="ln2727"> Example (2): a 3:2 tuplet with a 1/4 and a 1/8 note is filled.</a>
<a name="ln2728"> */</a>
<a name="ln2729"> </a>
<a name="ln2730">static bool isTupletFilled(const MxmlTupletState&amp; state, const TDuration normalType, const Fraction timeMod)</a>
<a name="ln2731">      {</a>
<a name="ln2732">      Q_UNUSED(timeMod);</a>
<a name="ln2733">      bool res { false };</a>
<a name="ln2734">      const auto actualNotes = state.m_actualNotes;</a>
<a name="ln2735">      /*</a>
<a name="ln2736">      const auto normalNotes = state.m_normalNotes;</a>
<a name="ln2737">      qDebug(&quot;duration %s normalType %s timeMod %s normalNotes %d actualNotes %d&quot;,</a>
<a name="ln2738">             qPrintable(state.m_duration.toString()),</a>
<a name="ln2739">             qPrintable(normalType.fraction().toString()),</a>
<a name="ln2740">             qPrintable(timeMod.toString()),</a>
<a name="ln2741">             normalNotes,</a>
<a name="ln2742">             actualNotes</a>
<a name="ln2743">             );</a>
<a name="ln2744">      */</a>
<a name="ln2745"> </a>
<a name="ln2746">      auto tupletType = state.m_tupletType;</a>
<a name="ln2747">      auto tupletCount = state.m_tupletCount;</a>
<a name="ln2748"> </a>
<a name="ln2749">      if (normalType.isValid()) {</a>
<a name="ln2750">            int matchedNormalType  = int(normalType.type());</a>
<a name="ln2751">            int matchedNormalCount = actualNotes;</a>
<a name="ln2752">            // match the types</a>
<a name="ln2753">            matchTypeAndCount(tupletType, tupletCount, matchedNormalType, matchedNormalCount);</a>
<a name="ln2754">            // ... result scenario (1)</a>
<a name="ln2755">            res = tupletCount &gt;= matchedNormalCount;</a>
<a name="ln2756">            /*</a>
<a name="ln2757">            qDebug(&quot;normalType valid tupletType %d tupletCount %d matchedNormalType %d matchedNormalCount %d res %d&quot;,</a>
<a name="ln2758">                   tupletType,</a>
<a name="ln2759">                   tupletCount,</a>
<a name="ln2760">                   matchedNormalType,</a>
<a name="ln2761">                   matchedNormalCount,</a>
<a name="ln2762">                   res</a>
<a name="ln2763">                   );</a>
<a name="ln2764">             */</a>
<a name="ln2765">            }</a>
<a name="ln2766">      else {</a>
<a name="ln2767">            // ... result scenario (2)</a>
<a name="ln2768">            res = tupletCount &gt;= actualNotes;</a>
<a name="ln2769">            /*</a>
<a name="ln2770">            qDebug(&quot;normalType not valid tupletCount %d actualNotes %d res %d&quot;,</a>
<a name="ln2771">                   tupletCount,</a>
<a name="ln2772">                   actualNotes,</a>
<a name="ln2773">                   res</a>
<a name="ln2774">                   );</a>
<a name="ln2775">             */</a>
<a name="ln2776">            }</a>
<a name="ln2777">      return res;</a>
<a name="ln2778">      }</a>
<a name="ln2779"> </a>
<a name="ln2780">//---------------------------------------------------------</a>
<a name="ln2781">//   missingTupletDuration</a>
<a name="ln2782">//---------------------------------------------------------</a>
<a name="ln2783"> </a>
<a name="ln2784">Fraction missingTupletDuration(const Fraction duration)</a>
<a name="ln2785">      {</a>
<a name="ln2786">      Fraction tupletFraction;</a>
<a name="ln2787">      Fraction tupletFullDuration;</a>
<a name="ln2788"> </a>
<a name="ln2789">      determineTupletFractionAndFullDuration(duration, tupletFraction, tupletFullDuration);</a>
<a name="ln2790">      auto missing = (Fraction(1, 1) - tupletFraction) * tupletFullDuration;</a>
<a name="ln2791"> </a>
<a name="ln2792">      return missing;</a>
<a name="ln2793">      }</a>
<a name="ln2794"> </a>
<a name="ln2795">//---------------------------------------------------------</a>
<a name="ln2796">//   determineTupletAction</a>
<a name="ln2797">//---------------------------------------------------------</a>
<a name="ln2798"> </a>
<a name="ln2799">/**</a>
<a name="ln2800"> Update tuplet state using parse result tupletDesc.</a>
<a name="ln2801"> Tuplets with &lt;actual-notes&gt; and &lt;normal-notes&gt; but without &lt;tuplet&gt;</a>
<a name="ln2802"> are handled correctly.</a>
<a name="ln2803"> TODO Nested tuplets are not (yet) supported.</a>
<a name="ln2804"> */</a>
<a name="ln2805"> </a>
<a name="ln2806">MxmlTupletFlags MxmlTupletState::determineTupletAction(const Fraction noteDuration,</a>
<a name="ln2807">                                                       const Fraction timeMod,</a>
<a name="ln2808">                                                       const MxmlStartStop tupletStartStop,</a>
<a name="ln2809">                                                       const TDuration normalType,</a>
<a name="ln2810">                                                       Fraction&amp; missingPreviousDuration,</a>
<a name="ln2811">                                                       Fraction&amp; missingCurrentDuration</a>
<a name="ln2812">                                                       )</a>
<a name="ln2813">      {</a>
<a name="ln2814">      const auto actualNotes = timeMod.denominator();</a>
<a name="ln2815">      const auto normalNotes = timeMod.numerator();</a>
<a name="ln2816">      MxmlTupletFlags res = MxmlTupletFlag::NONE;</a>
<a name="ln2817"> </a>
<a name="ln2818">      // check for unexpected termination of previous tuplet</a>
<a name="ln2819">      if (m_inTuplet &amp;&amp; timeMod == Fraction(1, 1)) {</a>
<a name="ln2820">            // recover by simply stopping the current tuplet first</a>
<a name="ln2821">            if (!isTupletFilled(*this, normalType, timeMod)) {</a>
<a name="ln2822">                  missingPreviousDuration = missingTupletDuration(m_duration);</a>
<a name="ln2823">                  //qDebug(&quot;tuplet incomplete, missing %s&quot;, qPrintable(missingPreviousDuration.print()));</a>
<a name="ln2824">                  }</a>
<a name="ln2825">            *this = {};</a>
<a name="ln2826">            res |= MxmlTupletFlag::STOP_PREVIOUS;</a>
<a name="ln2827">            }</a>
<a name="ln2828"> </a>
<a name="ln2829">      // check for obvious errors</a>
<a name="ln2830">      if (m_inTuplet &amp;&amp; tupletStartStop == MxmlStartStop::START) {</a>
<a name="ln2831">            qDebug(&quot;tuplet already started&quot;);</a>
<a name="ln2832">            // recover by simply stopping the current tuplet first</a>
<a name="ln2833">            if (!isTupletFilled(*this, normalType, timeMod)) {</a>
<a name="ln2834">                  missingPreviousDuration = missingTupletDuration(m_duration);</a>
<a name="ln2835">                  //qDebug(&quot;tuplet incomplete, missing %s&quot;, qPrintable(missingPreviousDuration.print()));</a>
<a name="ln2836">                  }</a>
<a name="ln2837">            *this = {};</a>
<a name="ln2838">            res |= MxmlTupletFlag::STOP_PREVIOUS;</a>
<a name="ln2839">            }</a>
<a name="ln2840">      if (tupletStartStop == MxmlStartStop::STOP &amp;&amp; !m_inTuplet) {</a>
<a name="ln2841">            qDebug(&quot;tuplet stop but no tuplet started&quot;);       // TODO</a>
<a name="ln2842">            // recovery handled later (automatically, no special case needed)</a>
<a name="ln2843">            }</a>
<a name="ln2844"> </a>
<a name="ln2845">      // Tuplet are either started by the tuplet start</a>
<a name="ln2846">      // or when the time modification is first found.</a>
<a name="ln2847">      if (!m_inTuplet) {</a>
<a name="ln2848">            if (tupletStartStop == MxmlStartStop::START</a>
<a name="ln2849">                || (!m_inTuplet &amp;&amp; (actualNotes != 1 || normalNotes != 1))) {</a>
<a name="ln2850">                  if (tupletStartStop != MxmlStartStop::START) {</a>
<a name="ln2851">                        m_implicit = true;</a>
<a name="ln2852">                        }</a>
<a name="ln2853">                  else {</a>
<a name="ln2854">                        m_implicit = false;</a>
<a name="ln2855">                        }</a>
<a name="ln2856">                  // create a new tuplet</a>
<a name="ln2857">                  m_inTuplet = true;</a>
<a name="ln2858">                  res |= MxmlTupletFlag::START_NEW;</a>
<a name="ln2859">                  }</a>
<a name="ln2860">            }</a>
<a name="ln2861"> </a>
<a name="ln2862">      // Add chord to the current tuplet.</a>
<a name="ln2863">      // Must also check for actual/normal notes to prevent</a>
<a name="ln2864">      // adding one chord too much if tuplet stop is missing.</a>
<a name="ln2865">      if (m_inTuplet &amp;&amp; !(actualNotes == 1 &amp;&amp; normalNotes == 1)) {</a>
<a name="ln2866">            addDurationToTuplet(noteDuration, timeMod);</a>
<a name="ln2867">            res |= MxmlTupletFlag::ADD_CHORD;</a>
<a name="ln2868">            }</a>
<a name="ln2869"> </a>
<a name="ln2870">      // Tuplets are stopped by the tuplet stop</a>
<a name="ln2871">      // or when the tuplet is filled completely</a>
<a name="ln2872">      // (either with knowledge of the normal type</a>
<a name="ln2873">      // or as a last resort calculated based on</a>
<a name="ln2874">      // actual and normal notes plus total duration)</a>
<a name="ln2875">      // or when the time-modification is not found.</a>
<a name="ln2876"> </a>
<a name="ln2877">      if (m_inTuplet) {</a>
<a name="ln2878">            if (tupletStartStop == MxmlStartStop::STOP</a>
<a name="ln2879">                || (m_implicit &amp;&amp; isTupletFilled(*this, normalType, timeMod))</a>
<a name="ln2880">                || (actualNotes == 1 &amp;&amp; normalNotes == 1)) {       // incorrect ??? check scenario incomplete tuplet w/o start</a>
<a name="ln2881">                  if (actualNotes &gt; normalNotes &amp;&amp; !isTupletFilled(*this, normalType, timeMod)) {</a>
<a name="ln2882">                        missingCurrentDuration = missingTupletDuration(m_duration);</a>
<a name="ln2883">                        qDebug(&quot;current tuplet incomplete, missing %s&quot;, qPrintable(missingCurrentDuration.print()));</a>
<a name="ln2884">                        }</a>
<a name="ln2885"> </a>
<a name="ln2886">                  *this = {};</a>
<a name="ln2887">                  res |= MxmlTupletFlag::STOP_CURRENT;</a>
<a name="ln2888">                  }</a>
<a name="ln2889">            }</a>
<a name="ln2890"> </a>
<a name="ln2891">      return res;</a>
<a name="ln2892">      }</a>
<a name="ln2893"> </a>
<a name="ln2894">//---------------------------------------------------------</a>
<a name="ln2895">//   note</a>
<a name="ln2896">//---------------------------------------------------------</a>
<a name="ln2897"> </a>
<a name="ln2898">/**</a>
<a name="ln2899"> Parse the /score-partwise/part/measure/note node.</a>
<a name="ln2900"> */</a>
<a name="ln2901"> </a>
<a name="ln2902">void MusicXMLParserPass1::note(const QString&amp; partId,</a>
<a name="ln2903">                               const Fraction sTime,</a>
<a name="ln2904">                               Fraction&amp; missingPrev,</a>
<a name="ln2905">                               Fraction&amp; dura,</a>
<a name="ln2906">                               Fraction&amp; missingCurr,</a>
<a name="ln2907">                               VoiceOverlapDetector&amp; vod,</a>
<a name="ln2908">                               MxmlTupletStates&amp; tupletStates)</a>
<a name="ln2909">      {</a>
<a name="ln2910">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln2911">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::note&quot;, &amp;_e);</a>
<a name="ln2912"> </a>
<a name="ln2913">      if (_e.attributes().value(&quot;print-spacing&quot;) == &quot;no&quot;) {</a>
<a name="ln2914">            notePrintSpacingNo(dura);</a>
<a name="ln2915">            return;</a>
<a name="ln2916">            }</a>
<a name="ln2917"> </a>
<a name="ln2918">      //float alter = 0;</a>
<a name="ln2919">      bool chord = false;</a>
<a name="ln2920">      bool grace = false;</a>
<a name="ln2921">      //int octave = -1;</a>
<a name="ln2922">      bool bRest = false;</a>
<a name="ln2923">      int staff = 1;</a>
<a name="ln2924">      //int step = 0;</a>
<a name="ln2925">      QString type;</a>
<a name="ln2926">      QString voice = &quot;1&quot;;</a>
<a name="ln2927">      QString instrId;</a>
<a name="ln2928">      MxmlStartStop tupletStartStop { MxmlStartStop::NONE };</a>
<a name="ln2929"> </a>
<a name="ln2930">      mxmlNoteDuration mnd(_divs, _logger);</a>
<a name="ln2931"> </a>
<a name="ln2932">      while (_e.readNextStartElement()) {</a>
<a name="ln2933">            if (mnd.readProperties(_e)) {</a>
<a name="ln2934">                  // element handled</a>
<a name="ln2935">                  }</a>
<a name="ln2936">            else if (_e.name() == &quot;accidental&quot;)</a>
<a name="ln2937">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2938">            else if (_e.name() == &quot;beam&quot;)</a>
<a name="ln2939">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2940">            else if (_e.name() == &quot;chord&quot;) {</a>
<a name="ln2941">                  chord = true;</a>
<a name="ln2942">                  _e.readNext();</a>
<a name="ln2943">                  }</a>
<a name="ln2944">            else if (_e.name() == &quot;cue&quot;)</a>
<a name="ln2945">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2946">            else if (_e.name() == &quot;grace&quot;) {</a>
<a name="ln2947">                  grace = true;</a>
<a name="ln2948">                  _e.readNext();</a>
<a name="ln2949">                  }</a>
<a name="ln2950">            else if (_e.name() == &quot;instrument&quot;) {</a>
<a name="ln2951">                  instrId = _e.attributes().value(&quot;id&quot;).toString();</a>
<a name="ln2952">                  _e.readNext();</a>
<a name="ln2953">                  }</a>
<a name="ln2954">            else if (_e.name() == &quot;lyric&quot;) {</a>
<a name="ln2955">                  const auto number = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln2956">                  _parts[partId].lyricNumberHandler().addNumber(number);</a>
<a name="ln2957">                  _e.skipCurrentElement();</a>
<a name="ln2958">                  }</a>
<a name="ln2959">            else if (_e.name() == &quot;notations&quot;)</a>
<a name="ln2960">                  notations(tupletStartStop);</a>
<a name="ln2961">            else if (_e.name() == &quot;notehead&quot;)</a>
<a name="ln2962">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2963">            else if (_e.name() == &quot;pitch&quot;)</a>
<a name="ln2964">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2965">            else if (_e.name() == &quot;rest&quot;) {</a>
<a name="ln2966">                  bRest = true;</a>
<a name="ln2967">                  rest();</a>
<a name="ln2968">                  }</a>
<a name="ln2969">            else if (_e.name() == &quot;staff&quot;) {</a>
<a name="ln2970">                  auto ok = false;</a>
<a name="ln2971">                  auto strStaff = _e.readElementText();</a>
<a name="ln2972">                  staff = strStaff.toInt(&amp;ok);</a>
<a name="ln2973">                  _parts[partId].setMaxStaff(staff);</a>
<a name="ln2974">                  Part* part = _partMap.value(partId);</a>
<a name="ln2975">                  Q_ASSERT(part);</a>
<a name="ln2976">                  if (!ok || staff &lt;= 0 || staff &gt; part-&gt;nstaves())</a>
<a name="ln2977">                        _logger-&gt;logError(QString(&quot;illegal staff '%1'&quot;).arg(strStaff), &amp;_e);</a>
<a name="ln2978">                  }</a>
<a name="ln2979">            else if (_e.name() == &quot;stem&quot;)</a>
<a name="ln2980">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2981">            else if (_e.name() == &quot;tie&quot;)</a>
<a name="ln2982">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2983">            else if (_e.name() == &quot;type&quot;)</a>
<a name="ln2984">                  type = _e.readElementText();</a>
<a name="ln2985">            else if (_e.name() == &quot;unpitched&quot;)</a>
<a name="ln2986">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln2987">            else if (_e.name() == &quot;voice&quot;)</a>
<a name="ln2988">                  voice = _e.readElementText();</a>
<a name="ln2989">            else</a>
<a name="ln2990">                  skipLogCurrElem();</a>
<a name="ln2991">            }</a>
<a name="ln2992"> </a>
<a name="ln2993">      // convert staff to zero-based</a>
<a name="ln2994">      staff--;</a>
<a name="ln2995"> </a>
<a name="ln2996">      // multi-instrument handling</a>
<a name="ln2997">      setFirstInstr(instrId, sTime);</a>
<a name="ln2998">      QString prevInstrId = _parts[partId]._instrList.instrument(sTime);</a>
<a name="ln2999">      bool mustInsert = instrId != prevInstrId;</a>
<a name="ln3000">      /*</a>
<a name="ln3001">      qDebug(&quot;tick %s (%d) staff %d voice '%s' previnst='%s' instrument '%s' mustInsert %d&quot;,</a>
<a name="ln3002">             qPrintable(sTime.print()),</a>
<a name="ln3003">             sTime.ticks(),</a>
<a name="ln3004">             staff + 1,</a>
<a name="ln3005">             qPrintable(voice),</a>
<a name="ln3006">             qPrintable(prevInstrId),</a>
<a name="ln3007">             qPrintable(instrId),</a>
<a name="ln3008">             mustInsert</a>
<a name="ln3009">             );</a>
<a name="ln3010">      */</a>
<a name="ln3011">      if (mustInsert)</a>
<a name="ln3012">            _parts[partId]._instrList.setInstrument(instrId, sTime);</a>
<a name="ln3013"> </a>
<a name="ln3014">      // check for timing error(s) and set dura</a>
<a name="ln3015">      // keep in this order as checkTiming() might change dura</a>
<a name="ln3016">      auto errorStr = mnd.checkTiming(type, bRest, grace);</a>
<a name="ln3017">      dura = mnd.dura();</a>
<a name="ln3018">      if (errorStr != &quot;&quot;)</a>
<a name="ln3019">            _logger-&gt;logError(errorStr, &amp;_e);</a>
<a name="ln3020"> </a>
<a name="ln3021">      // don't count chord or grace note duration</a>
<a name="ln3022">      // note that this does not check the MusicXML requirement that notes in a chord</a>
<a name="ln3023">      // cannot have a duration longer than the first note in the chord</a>
<a name="ln3024">      missingPrev.set(0, 1);</a>
<a name="ln3025">      if (chord || grace)</a>
<a name="ln3026">            dura.set(0, 1);</a>
<a name="ln3027"> </a>
<a name="ln3028">      if (!chord &amp;&amp; !grace) {</a>
<a name="ln3029">            // do tuplet</a>
<a name="ln3030">            auto timeMod = mnd.timeMod();</a>
<a name="ln3031">            auto&amp; tupletState = tupletStates[voice];</a>
<a name="ln3032">            tupletState.determineTupletAction(mnd.dura(), timeMod, tupletStartStop, mnd.normalType(), missingPrev, missingCurr);</a>
<a name="ln3033">            }</a>
<a name="ln3034"> </a>
<a name="ln3035">      // store result</a>
<a name="ln3036">      if (dura.isValid() &amp;&amp; dura &gt; Fraction(0, 1)) {</a>
<a name="ln3037">            // count the chords</a>
<a name="ln3038">            if (!_parts.value(partId).voicelist.contains(voice)) {</a>
<a name="ln3039">                  VoiceDesc vs;</a>
<a name="ln3040">                  _parts[partId].voicelist.insert(voice, vs);</a>
<a name="ln3041">                  }</a>
<a name="ln3042">            _parts[partId].voicelist[voice].incrChordRests(staff);</a>
<a name="ln3043">            // determine note length for voice overlap detection</a>
<a name="ln3044">            vod.addNote((sTime + missingPrev).ticks(), (sTime + missingPrev + dura).ticks(), voice, staff);</a>
<a name="ln3045">            }</a>
<a name="ln3046"> </a>
<a name="ln3047">      if (!(_e.isEndElement() &amp;&amp; _e.name() == &quot;note&quot;))</a>
<a name="ln3048">            qDebug(&quot;name %s line %lld&quot;, qPrintable(_e.name().toString()), _e.lineNumber());</a>
<a name="ln3049">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln3050">      }</a>
<a name="ln3051"> </a>
<a name="ln3052">//---------------------------------------------------------</a>
<a name="ln3053">//   notePrintSpacingNo</a>
<a name="ln3054">//---------------------------------------------------------</a>
<a name="ln3055"> </a>
<a name="ln3056">/**</a>
<a name="ln3057"> Parse the /score-partwise/part/measure/note node for a note with print-spacing=&quot;no&quot;.</a>
<a name="ln3058"> These are handled like a forward: only moving the time forward.</a>
<a name="ln3059"> */</a>
<a name="ln3060"> </a>
<a name="ln3061">void MusicXMLParserPass1::notePrintSpacingNo(Fraction&amp; dura)</a>
<a name="ln3062">      {</a>
<a name="ln3063">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln3064">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::notePrintSpacingNo&quot;, &amp;_e);</a>
<a name="ln3065"> </a>
<a name="ln3066">      bool chord = false;</a>
<a name="ln3067">      bool grace = false;</a>
<a name="ln3068"> </a>
<a name="ln3069">      while (_e.readNextStartElement()) {</a>
<a name="ln3070">            if (_e.name() == &quot;chord&quot;) {</a>
<a name="ln3071">                  chord = true;</a>
<a name="ln3072">                  _e.readNext();</a>
<a name="ln3073">                  }</a>
<a name="ln3074">            else if (_e.name() == &quot;duration&quot;)</a>
<a name="ln3075">                  duration(dura);</a>
<a name="ln3076">            else if (_e.name() == &quot;grace&quot;) {</a>
<a name="ln3077">                  grace = true;</a>
<a name="ln3078">                  _e.readNext();</a>
<a name="ln3079">                  }</a>
<a name="ln3080">            else</a>
<a name="ln3081">                  _e.skipCurrentElement();        // skip but don't log</a>
<a name="ln3082">            }</a>
<a name="ln3083"> </a>
<a name="ln3084">      // don't count chord or grace note duration</a>
<a name="ln3085">      // note that this does not check the MusicXML requirement that notes in a chord</a>
<a name="ln3086">      // cannot have a duration longer than the first note in the chord</a>
<a name="ln3087">      if (chord || grace)</a>
<a name="ln3088">            dura.set(0, 1);</a>
<a name="ln3089"> </a>
<a name="ln3090">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln3091">      }</a>
<a name="ln3092"> </a>
<a name="ln3093">//---------------------------------------------------------</a>
<a name="ln3094">//   duration</a>
<a name="ln3095">//---------------------------------------------------------</a>
<a name="ln3096"> </a>
<a name="ln3097">/**</a>
<a name="ln3098"> Parse the /score-partwise/part/measure/note/duration node.</a>
<a name="ln3099"> */</a>
<a name="ln3100"> </a>
<a name="ln3101">void MusicXMLParserPass1::duration(Fraction&amp; dura)</a>
<a name="ln3102">      {</a>
<a name="ln3103">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;duration&quot;);</a>
<a name="ln3104">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::duration&quot;, &amp;_e);</a>
<a name="ln3105"> </a>
<a name="ln3106">      dura.set(0, 0);  // invalid unless set correctly</a>
<a name="ln3107">      int intDura = _e.readElementText().toInt();</a>
<a name="ln3108">      if (intDura &gt; 0) {</a>
<a name="ln3109">            if (_divs &gt; 0) {</a>
<a name="ln3110">                  dura.set(intDura, 4 * _divs);</a>
<a name="ln3111">                  dura.reduce(); // prevent overflow in later Fraction operations</a>
<a name="ln3112">                  }</a>
<a name="ln3113">            else</a>
<a name="ln3114">                  _logger-&gt;logError(&quot;illegal or uninitialized divisions&quot;, &amp;_e);</a>
<a name="ln3115">            }</a>
<a name="ln3116">      else</a>
<a name="ln3117">            _logger-&gt;logError(&quot;illegal duration&quot;, &amp;_e);</a>
<a name="ln3118">      //qDebug(&quot;duration %s valid %d&quot;, qPrintable(dura.print()), dura.isValid());</a>
<a name="ln3119">      }</a>
<a name="ln3120"> </a>
<a name="ln3121">//---------------------------------------------------------</a>
<a name="ln3122">//   forward</a>
<a name="ln3123">//---------------------------------------------------------</a>
<a name="ln3124"> </a>
<a name="ln3125">/**</a>
<a name="ln3126"> Parse the /score-partwise/part/measure/note/forward node.</a>
<a name="ln3127"> */</a>
<a name="ln3128"> </a>
<a name="ln3129">void MusicXMLParserPass1::forward(Fraction&amp; dura)</a>
<a name="ln3130">      {</a>
<a name="ln3131">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;forward&quot;);</a>
<a name="ln3132">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::forward&quot;, &amp;_e);</a>
<a name="ln3133"> </a>
<a name="ln3134">      while (_e.readNextStartElement()) {</a>
<a name="ln3135">            if (_e.name() == &quot;duration&quot;)</a>
<a name="ln3136">                  duration(dura);</a>
<a name="ln3137">            else if (_e.name() == &quot;staff&quot;)</a>
<a name="ln3138">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln3139">            else if (_e.name() == &quot;voice&quot;)</a>
<a name="ln3140">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln3141">            else</a>
<a name="ln3142">                  skipLogCurrElem();</a>
<a name="ln3143">            }</a>
<a name="ln3144">      }</a>
<a name="ln3145"> </a>
<a name="ln3146">//---------------------------------------------------------</a>
<a name="ln3147">//   backup</a>
<a name="ln3148">//---------------------------------------------------------</a>
<a name="ln3149"> </a>
<a name="ln3150">/**</a>
<a name="ln3151"> Parse the /score-partwise/part/measure/note/backup node.</a>
<a name="ln3152"> */</a>
<a name="ln3153"> </a>
<a name="ln3154">void MusicXMLParserPass1::backup(Fraction&amp; dura)</a>
<a name="ln3155">      {</a>
<a name="ln3156">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;backup&quot;);</a>
<a name="ln3157">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::backup&quot;, &amp;_e);</a>
<a name="ln3158"> </a>
<a name="ln3159">      while (_e.readNextStartElement()) {</a>
<a name="ln3160">            if (_e.name() == &quot;duration&quot;)</a>
<a name="ln3161">                  duration(dura);</a>
<a name="ln3162">            else</a>
<a name="ln3163">                  skipLogCurrElem();</a>
<a name="ln3164">            }</a>
<a name="ln3165">      }</a>
<a name="ln3166"> </a>
<a name="ln3167">//---------------------------------------------------------</a>
<a name="ln3168">//   timeModification</a>
<a name="ln3169">//---------------------------------------------------------</a>
<a name="ln3170"> </a>
<a name="ln3171">/**</a>
<a name="ln3172"> Parse the /score-partwise/part/measure/note/time-modification node.</a>
<a name="ln3173"> */</a>
<a name="ln3174"> </a>
<a name="ln3175">void MusicXMLParserPass1::timeModification(Fraction&amp; timeMod)</a>
<a name="ln3176">      {</a>
<a name="ln3177">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;time-modification&quot;);</a>
<a name="ln3178">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::timeModification&quot;, &amp;_e);</a>
<a name="ln3179"> </a>
<a name="ln3180">      int intActual = 0;</a>
<a name="ln3181">      int intNormal = 0;</a>
<a name="ln3182">      QString strActual;</a>
<a name="ln3183">      QString strNormal;</a>
<a name="ln3184"> </a>
<a name="ln3185">      while (_e.readNextStartElement()) {</a>
<a name="ln3186">            if (_e.name() == &quot;actual-notes&quot;)</a>
<a name="ln3187">                  strActual = _e.readElementText();</a>
<a name="ln3188">            else if (_e.name() == &quot;normal-notes&quot;)</a>
<a name="ln3189">                  strNormal = _e.readElementText();</a>
<a name="ln3190">            else</a>
<a name="ln3191">                  skipLogCurrElem();</a>
<a name="ln3192">            }</a>
<a name="ln3193"> </a>
<a name="ln3194">      intActual = strActual.toInt();</a>
<a name="ln3195">      intNormal = strNormal.toInt();</a>
<a name="ln3196">      if (intActual &gt; 0 &amp;&amp; intNormal &gt; 0)</a>
<a name="ln3197">            timeMod.set(intNormal, intActual);</a>
<a name="ln3198">      else {</a>
<a name="ln3199">            timeMod.set(1, 1);</a>
<a name="ln3200">            _logger-&gt;logError(QString(&quot;illegal time-modification: actual-notes %1 normal-notes %2&quot;)</a>
<a name="ln3201">                              .arg(strActual).arg(strNormal), &amp;_e);</a>
<a name="ln3202">            }</a>
<a name="ln3203">      }</a>
<a name="ln3204"> </a>
<a name="ln3205">//---------------------------------------------------------</a>
<a name="ln3206">//   rest</a>
<a name="ln3207">//---------------------------------------------------------</a>
<a name="ln3208"> </a>
<a name="ln3209">/**</a>
<a name="ln3210"> Parse the /score-partwise/part/measure/note/rest node.</a>
<a name="ln3211"> */</a>
<a name="ln3212"> </a>
<a name="ln3213">void MusicXMLParserPass1::rest()</a>
<a name="ln3214">      {</a>
<a name="ln3215">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;rest&quot;);</a>
<a name="ln3216">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::rest&quot;, &amp;_e);</a>
<a name="ln3217"> </a>
<a name="ln3218">      while (_e.readNextStartElement()) {</a>
<a name="ln3219">            if (_e.name() == &quot;display-octave&quot;)</a>
<a name="ln3220">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln3221">            else if (_e.name() == &quot;display-step&quot;)</a>
<a name="ln3222">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln3223">            else</a>
<a name="ln3224">                  skipLogCurrElem();</a>
<a name="ln3225">            }</a>
<a name="ln3226">      }</a>
<a name="ln3227"> </a>
<a name="ln3228">} // namespace Ms</a>

</code></pre>
<div class="balloon" rel="533"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v636/" target="_blank">V636</a> The 'pageWidth / 3' expression was implicitly cast from 'int' type to 'double' type. Consider utilizing an explicit type cast to avoid the loss of a fractional part. An example: double A = (double)(X) / Y;.</p></div>
<div class="balloon" rel="534"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v636/" target="_blank">V636</a> The '2 * pageWidth / 3' expression was implicitly cast from 'int' type to 'double' type. Consider utilizing an explicit type cast to avoid the loss of a fractional part. An example: double A = (double)(X) / Y;.</p></div>
<div class="balloon" rel="574"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v636/" target="_blank">V636</a> The 'pageSize.height() / 2' expression was implicitly cast from 'int' type to 'double' type. Consider utilizing an explicit type cast to avoid the loss of a fractional part. An example: double A = (double)(X) / Y;.</p></div>
<div class="balloon" rel="1538"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1760"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'instrSound' should be used inside '_drumsets[partId].contains' function.</p></div>
<div class="balloon" rel="2849"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !m_inTuplet.</p></div>
<div class="balloon" rel="2883"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
