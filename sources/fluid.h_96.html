
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fluid.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/*</a>
<a name="ln2"> *</a>
<a name="ln3"> * Copyright (C) 2003  Peter Hanappe and others.</a>
<a name="ln4"> *</a>
<a name="ln5"> * This library is free software; you can redistribute it and/or</a>
<a name="ln6"> * modify it under the terms of the GNU Library General Public License</a>
<a name="ln7"> * as published by the Free Software Foundation; either version 2 of</a>
<a name="ln8"> * the License, or (at your option) any later version.</a>
<a name="ln9"> *</a>
<a name="ln10"> * This library is distributed in the hope that it will be useful, but</a>
<a name="ln11"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13"> * Library General Public License for more details.</a>
<a name="ln14"> *</a>
<a name="ln15"> * You should have received a copy of the GNU Library General Public</a>
<a name="ln16"> * License along with this library; if not, write to the Free</a>
<a name="ln17"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA</a>
<a name="ln18"> * 02111-1307, USA</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21"> </a>
<a name="ln22">#ifndef __FLUID_S_H__</a>
<a name="ln23">#define __FLUID_S_H__</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;synthesizer/synthesizer.h&quot;</a>
<a name="ln26">#include &quot;synthesizer/midipatch.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">namespace FluidS {</a>
<a name="ln29"> </a>
<a name="ln30">using namespace Ms;</a>
<a name="ln31"> </a>
<a name="ln32">class Voice;</a>
<a name="ln33">class SFont;</a>
<a name="ln34">class Preset;</a>
<a name="ln35">class Sample;</a>
<a name="ln36">class Channel;</a>
<a name="ln37">struct Mod;</a>
<a name="ln38">class Fluid;</a>
<a name="ln39"> </a>
<a name="ln40">#define FLUID_NUM_PROGRAMS      129</a>
<a name="ln41"> </a>
<a name="ln42">enum fluid_loop {</a>
<a name="ln43">      FLUID_UNLOOPED            = 0,</a>
<a name="ln44">      FLUID_LOOP_DURING_RELEASE = 1,</a>
<a name="ln45">      FLUID_NOTUSED             = 2,</a>
<a name="ln46">      FLUID_LOOP_UNTIL_RELEASE  = 3</a>
<a name="ln47">      };</a>
<a name="ln48"> </a>
<a name="ln49">enum fluid_synth_status {</a>
<a name="ln50">      FLUID_SYNTH_CLEAN,</a>
<a name="ln51">      FLUID_SYNTH_PLAYING,</a>
<a name="ln52">      FLUID_SYNTH_QUIET,</a>
<a name="ln53">      FLUID_SYNTH_STOPPED</a>
<a name="ln54">      };</a>
<a name="ln55"> </a>
<a name="ln56">//---------------------------------------------------------</a>
<a name="ln57">//   BankOffset</a>
<a name="ln58">//---------------------------------------------------------</a>
<a name="ln59"> </a>
<a name="ln60">struct BankOffset {</a>
<a name="ln61">      int sfont_id;</a>
<a name="ln62">      int offset;</a>
<a name="ln63">      };</a>
<a name="ln64"> </a>
<a name="ln65">enum fluid_midi_control_change {</a>
<a name="ln66">      BANK_SELECT_MSB = 0x00,</a>
<a name="ln67">      MODULATION_MSB = 0x01,</a>
<a name="ln68">      BREATH_MSB = 0x02,</a>
<a name="ln69">      FOOT_MSB = 0x04,</a>
<a name="ln70">      PORTAMENTO_TIME_MSB = 0x05,</a>
<a name="ln71">      DATA_ENTRY_MSB = 0x06,</a>
<a name="ln72">      VOLUME_MSB = 0x07,</a>
<a name="ln73">      BALANCE_MSB = 0x08,</a>
<a name="ln74">      PAN_MSB = 0x0A,</a>
<a name="ln75">      EXPRESSION_MSB = 0x0B,</a>
<a name="ln76">      EFFECTS1_MSB = 0x0C,</a>
<a name="ln77">      EFFECTS2_MSB = 0x0D,</a>
<a name="ln78">      GPC1_MSB = 0x10, /* general purpose controller */</a>
<a name="ln79">      GPC2_MSB = 0x11,</a>
<a name="ln80">      GPC3_MSB = 0x12,</a>
<a name="ln81">      GPC4_MSB = 0x13,</a>
<a name="ln82">      BANK_SELECT_LSB = 0x20,</a>
<a name="ln83">      MODULATION_WHEEL_LSB = 0x21,</a>
<a name="ln84">      BREATH_LSB = 0x22,</a>
<a name="ln85">      FOOT_LSB = 0x24,</a>
<a name="ln86">      PORTAMENTO_TIME_LSB = 0x25,</a>
<a name="ln87">      DATA_ENTRY_LSB = 0x26,</a>
<a name="ln88">      VOLUME_LSB = 0x27,</a>
<a name="ln89">      BALANCE_LSB = 0x28,</a>
<a name="ln90">      PAN_LSB = 0x2A,</a>
<a name="ln91">      EXPRESSION_LSB = 0x2B,</a>
<a name="ln92">      EFFECTS1_LSB = 0x2C,</a>
<a name="ln93">      EFFECTS2_LSB = 0x2D,</a>
<a name="ln94">      GPC1_LSB = 0x30,</a>
<a name="ln95">      GPC2_LSB = 0x31,</a>
<a name="ln96">      GPC3_LSB = 0x32,</a>
<a name="ln97">      GPC4_LSB = 0x33,</a>
<a name="ln98">      SUSTAIN_SWITCH = 0x40,</a>
<a name="ln99">      PORTAMENTO_SWITCH = 0x41,</a>
<a name="ln100">      SOSTENUTO_SWITCH = 0x42,</a>
<a name="ln101">      SOFT_PEDAL_SWITCH = 0x43,</a>
<a name="ln102">      LEGATO_SWITCH = 0x45,</a>
<a name="ln103">      HOLD2_SWITCH = 0x45,</a>
<a name="ln104">      SOUND_CTRL1 = 0x46,</a>
<a name="ln105">      SOUND_CTRL2 = 0x47,</a>
<a name="ln106">      SOUND_CTRL3 = 0x48,</a>
<a name="ln107">      SOUND_CTRL4 = 0x49,</a>
<a name="ln108">      SOUND_CTRL5 = 0x4A,</a>
<a name="ln109">      SOUND_CTRL6 = 0x4B,</a>
<a name="ln110">      SOUND_CTRL7 = 0x4C,</a>
<a name="ln111">      SOUND_CTRL8 = 0x4D,</a>
<a name="ln112">      SOUND_CTRL9 = 0x4E,</a>
<a name="ln113">      SOUND_CTRL10 = 0x4F,</a>
<a name="ln114">      GPC5 = 0x50,</a>
<a name="ln115">      GPC6 = 0x51,</a>
<a name="ln116">      GPC7 = 0x52,</a>
<a name="ln117">      GPC8 = 0x53,</a>
<a name="ln118">      PORTAMENTO_CTRL = 0x54,</a>
<a name="ln119">      EFFECTS_DEPTH1 = 0x5B,</a>
<a name="ln120">      EFFECTS_DEPTH2 = 0x5C,</a>
<a name="ln121">      EFFECTS_DEPTH3 = 0x5D,</a>
<a name="ln122">      EFFECTS_DEPTH4 = 0x5E,</a>
<a name="ln123">      EFFECTS_DEPTH5 = 0x5F,</a>
<a name="ln124">      DATA_ENTRY_INCR = 0x60,</a>
<a name="ln125">      DATA_ENTRY_DECR = 0x61,</a>
<a name="ln126">      NRPN_LSB = 0x62,</a>
<a name="ln127">      NRPN_MSB = 0x63,</a>
<a name="ln128">      RPN_LSB = 0x64,</a>
<a name="ln129">      RPN_MSB = 0x65,</a>
<a name="ln130">      ALL_SOUND_OFF = 0x78,</a>
<a name="ln131">      ALL_CTRL_OFF = 0x79,</a>
<a name="ln132">      LOCAL_CONTROL = 0x7A,</a>
<a name="ln133">      ALL_NOTES_OFF = 0x7B,</a>
<a name="ln134">      OMNI_OFF = 0x7C,</a>
<a name="ln135">      OMNI_ON = 0x7D,</a>
<a name="ln136">      POLY_OFF = 0x7E,</a>
<a name="ln137">      POLY_ON = 0x7F</a>
<a name="ln138">      };</a>
<a name="ln139"> </a>
<a name="ln140">/**</a>
<a name="ln141"> * Generator (effect) numbers (SoundFont 2.01 specifications section 8.1.3)</a>
<a name="ln142"> */</a>
<a name="ln143">enum fluid_gen_type {</a>
<a name="ln144">  GEN_STARTADDROFS,		/**&lt; Sample start address offset (0-32767) */</a>
<a name="ln145">  GEN_ENDADDROFS,		      /**&lt; Sample end address offset (-32767-0) */</a>
<a name="ln146">  GEN_STARTLOOPADDROFS,		/**&lt; Sample loop start address offset (-32767-32767) */</a>
<a name="ln147">  GEN_ENDLOOPADDROFS,		/**&lt; Sample loop end address offset (-32767-32767) */</a>
<a name="ln148">  GEN_STARTADDRCOARSEOFS,	/**&lt; Sample start address coarse offset (X 32768) */</a>
<a name="ln149">  GEN_MODLFOTOPITCH,		/**&lt; Modulation LFO to pitch */</a>
<a name="ln150">  GEN_VIBLFOTOPITCH,		/**&lt; Vibrato LFO to pitch */</a>
<a name="ln151">  GEN_MODENVTOPITCH,		/**&lt; Modulation envelope to pitch */</a>
<a name="ln152">  GEN_FILTERFC,			/**&lt; Filter cutoff */</a>
<a name="ln153">  GEN_FILTERQ,			/**&lt; Filter Q */</a>
<a name="ln154">  GEN_MODLFOTOFILTERFC,		/**&lt; Modulation LFO to filter cutoff */</a>
<a name="ln155">  GEN_MODENVTOFILTERFC,		/**&lt; Modulation envelope to filter cutoff */</a>
<a name="ln156">  GEN_ENDADDRCOARSEOFS,		/**&lt; Sample end address coarse offset (X 32768) */</a>
<a name="ln157">  GEN_MODLFOTOVOL,		/**&lt; Modulation LFO to volume */</a>
<a name="ln158">  GEN_UNUSED1,			/**&lt; Unused */</a>
<a name="ln159">  GEN_CHORUSSEND,		      /**&lt; Chorus send amount */</a>
<a name="ln160">  GEN_REVERBSEND,		      /**&lt; Reverb send amount */</a>
<a name="ln161">  GEN_PAN,			      /**&lt; Stereo panning */</a>
<a name="ln162">  GEN_UNUSED2,			/**&lt; Unused */</a>
<a name="ln163">  GEN_UNUSED3,			/**&lt; Unused */</a>
<a name="ln164">  GEN_UNUSED4,			/**&lt; Unused */</a>
<a name="ln165">  GEN_MODLFODELAY,		/**&lt; Modulation LFO delay */</a>
<a name="ln166">  GEN_MODLFOFREQ,		      /**&lt; Modulation LFO frequency */</a>
<a name="ln167">  GEN_VIBLFODELAY,		/**&lt; Vibrato LFO delay */</a>
<a name="ln168">  GEN_VIBLFOFREQ,		      /**&lt; Vibrato LFO frequency */</a>
<a name="ln169">  GEN_MODENVDELAY,		/**&lt; Modulation envelope delay */</a>
<a name="ln170">  GEN_MODENVATTACK,		/**&lt; Modulation envelope attack */</a>
<a name="ln171">  GEN_MODENVHOLD,		      /**&lt; Modulation envelope hold */</a>
<a name="ln172">  GEN_MODENVDECAY,		/**&lt; Modulation envelope decay */</a>
<a name="ln173">  GEN_MODENVSUSTAIN,		/**&lt; Modulation envelope sustain */</a>
<a name="ln174">  GEN_MODENVRELEASE,		/**&lt; Modulation envelope release */</a>
<a name="ln175">  GEN_KEYTOMODENVHOLD,		/**&lt; Key to modulation envelope hold */</a>
<a name="ln176">  GEN_KEYTOMODENVDECAY,		/**&lt; Key to modulation envelope decay */</a>
<a name="ln177">  GEN_VOLENVDELAY,		/**&lt; Volume envelope delay */</a>
<a name="ln178">  GEN_VOLENVATTACK,		/**&lt; Volume envelope attack */</a>
<a name="ln179">  GEN_VOLENVHOLD,		      /**&lt; Volume envelope hold */</a>
<a name="ln180">  GEN_VOLENVDECAY,		/**&lt; Volume envelope decay */</a>
<a name="ln181">  GEN_VOLENVSUSTAIN,		/**&lt; Volume envelope sustain */</a>
<a name="ln182">  GEN_VOLENVRELEASE,		/**&lt; Volume envelope release */</a>
<a name="ln183">  GEN_KEYTOVOLENVHOLD,		/**&lt; Key to volume envelope hold */</a>
<a name="ln184">  GEN_KEYTOVOLENVDECAY,		/**&lt; Key to volume envelope decay */</a>
<a name="ln185">  GEN_INSTRUMENT,		      /**&lt; Instrument ID (shouldn't be set by user) */</a>
<a name="ln186">  GEN_RESERVED1,		      /**&lt; Reserved */</a>
<a name="ln187">  GEN_KEYRANGE,			/**&lt; MIDI note range */</a>
<a name="ln188">  GEN_VELRANGE,			/**&lt; MIDI velocity range */</a>
<a name="ln189">  GEN_STARTLOOPADDRCOARSEOFS,	/**&lt; Sample start loop address coarse offset (X 32768) */</a>
<a name="ln190">  GEN_KEYNUM,			/**&lt; Fixed MIDI note number */</a>
<a name="ln191">  GEN_VELOCITY,			/**&lt; Fixed MIDI velocity value */</a>
<a name="ln192">  GEN_ATTENUATION,		/**&lt; Initial volume attenuation */</a>
<a name="ln193">  GEN_RESERVED2,		      /**&lt; Reserved */</a>
<a name="ln194">  GEN_ENDLOOPADDRCOARSEOFS,	/**&lt; Sample end loop address coarse offset (X 32768) */</a>
<a name="ln195">  GEN_COARSETUNE,		      /**&lt; Coarse tuning */</a>
<a name="ln196">  GEN_FINETUNE,			/**&lt; Fine tuning */</a>
<a name="ln197">  GEN_SAMPLEID,			/**&lt; Sample ID (shouldn't be set by user) */</a>
<a name="ln198">  GEN_SAMPLEMODE,		      /**&lt; Sample mode flags */</a>
<a name="ln199">  GEN_RESERVED3,		      /**&lt; Reserved */</a>
<a name="ln200">  GEN_SCALETUNE,		      /**&lt; Scale tuning */</a>
<a name="ln201">  GEN_EXCLUSIVECLASS,		/**&lt; Exclusive class number */</a>
<a name="ln202">  GEN_OVERRIDEROOTKEY,		/**&lt; Sample root note override */</a>
<a name="ln203"> </a>
<a name="ln204">  /* the initial pitch is not a &quot;standard&quot; generator. It is not</a>
<a name="ln205">   * mentioned in the list of generator in the SF2 specifications. It</a>
<a name="ln206">   * is used, however, as the destination for the default pitch wheel</a>
<a name="ln207">   * modulator. */</a>
<a name="ln208">  GEN_PITCH,			/**&lt; Pitch (NOTE: Not a real SoundFont generator) */</a>
<a name="ln209">  GEN_LAST			      /**&lt; Value defines the count of generators (#fluid_gen_type) */</a>
<a name="ln210">      };</a>
<a name="ln211"> </a>
<a name="ln212">//---------------------------------------------------------</a>
<a name="ln213">//   Channel</a>
<a name="ln214">//---------------------------------------------------------</a>
<a name="ln215"> </a>
<a name="ln216">class Channel {</a>
<a name="ln217">      Fluid* synth;</a>
<a name="ln218"> </a>
<a name="ln219">      unsigned int sfontnum;</a>
<a name="ln220">      unsigned int banknum;</a>
<a name="ln221">      unsigned int prognum;</a>
<a name="ln222">      Preset* _preset;</a>
<a name="ln223"> </a>
<a name="ln224">   public:</a>
<a name="ln225">      int channum;</a>
<a name="ln226">      short channel_pressure;</a>
<a name="ln227">      short pitch_bend;</a>
<a name="ln228">      short pitch_wheel_sensitivity;</a>
<a name="ln229"> </a>
<a name="ln230">      short cc[128];                // controller values</a>
<a name="ln231">      short key_pressure[128];      // MIDI polyphonic key pressure from [0;127]</a>
<a name="ln232"> </a>
<a name="ln233">      /* cached values of last MSB values of MSB/LSB controllers */</a>
<a name="ln234">      unsigned char bank_msb;</a>
<a name="ln235">      int interp_method;</a>
<a name="ln236"> </a>
<a name="ln237">      /* NRPN system */</a>
<a name="ln238">      short nrpn_select;</a>
<a name="ln239"> </a>
<a name="ln240">      /* The values of the generators, set by NRPN messages, or by</a>
<a name="ln241">       * fluid_synth_set_gen(), are cached in the channel so they can be</a>
<a name="ln242">       * applied to future notes. They are copied to a voice's generators</a>
<a name="ln243">       * in fluid_voice_init(), which calls fluid_gen_init().  */</a>
<a name="ln244"> </a>
<a name="ln245">      float gen[GEN_LAST];</a>
<a name="ln246"> </a>
<a name="ln247">      /* By default, the NRPN values are relative to the values of the</a>
<a name="ln248">       * generators set in the SoundFont. For example, if the NRPN</a>
<a name="ln249">       * specifies an attack of 100 msec then 100 msec will be added to the</a>
<a name="ln250">       * combined attack time of the sound font and the modulators.</a>
<a name="ln251">       *</a>
<a name="ln252">       * However, it is useful to be able to specify the generator value</a>
<a name="ln253">       * absolutely, completely ignoring the generators of the sound font</a>
<a name="ln254">       * and the values of modulators. The gen_abs field, is a boolean</a>
<a name="ln255">       * flag indicating whether the NRPN value is absolute or not.</a>
<a name="ln256">       */</a>
<a name="ln257">      char gen_abs[GEN_LAST];</a>
<a name="ln258"> </a>
<a name="ln259">   public:</a>
<a name="ln260">      Channel(Fluid* synth, int num);</a>
<a name="ln261"> </a>
<a name="ln262">      bool sustained() const              { return cc[SUSTAIN_SWITCH] &gt;= 64; }</a>
<a name="ln263">      void setGen(int n, float v, char a) { gen[n] = v; gen_abs[n] = a; }</a>
<a name="ln264">      float getGen(int n) const           { return gen[n]; }</a>
<a name="ln265">      char getGenAbs(int n) const         { return gen_abs[n]; }</a>
<a name="ln266">      void init();</a>
<a name="ln267">      void initCtrl();</a>
<a name="ln268">      void setCC(int n, int val)          { cc[n] = val; }</a>
<a name="ln269">      void reset();</a>
<a name="ln270">      void setPreset(Preset* p);</a>
<a name="ln271">      Preset* preset() const              { return _preset;  }</a>
<a name="ln272">      unsigned int getSfontnum() const    { return sfontnum; }</a>
<a name="ln273">      void setSfontnum(unsigned int s)    { sfontnum = s;    }</a>
<a name="ln274">      unsigned int getBanknum() const     { return banknum;  }</a>
<a name="ln275">      void setBanknum(unsigned int b)     { banknum = b;     }</a>
<a name="ln276">      void setPrognum(int p)              { prognum = p;     }</a>
<a name="ln277">      int getPrognum() const              { return prognum;  }</a>
<a name="ln278">      void setcc(int ctrl, int val);</a>
<a name="ln279">      void pitchBend(int val);</a>
<a name="ln280">      int getPitchBend() const            { return pitch_bend; }</a>
<a name="ln281">      void pitchWheelSens(int val);</a>
<a name="ln282">      int getCC(int num);</a>
<a name="ln283">      int getNum() const                  { return channum;    }</a>
<a name="ln284">      void setInterpMethod(int m)         { interp_method = m; }</a>
<a name="ln285">      int getInterpMethod() const         { return interp_method; }</a>
<a name="ln286">      void setChannelPressure(int val);</a>
<a name="ln287">      int channelPressure() const         { return channel_pressure; }</a>
<a name="ln288">      void setKeyPressure(int key, int val);</a>
<a name="ln289">      int keyPressure(int key) const      { return key_pressure[key]; }</a>
<a name="ln290">      };</a>
<a name="ln291"> </a>
<a name="ln292">// subsystems:</a>
<a name="ln293">enum {</a>
<a name="ln294">      FLUID_GROUP  = 0,</a>
<a name="ln295">      };</a>
<a name="ln296"> </a>
<a name="ln297">//---------------------------------------------------------</a>
<a name="ln298">//   Fluid</a>
<a name="ln299">//---------------------------------------------------------</a>
<a name="ln300"> </a>
<a name="ln301">class Fluid : public Synthesizer {</a>
<a name="ln302">      QList&lt;SFont*&gt; sfonts;               // the loaded soundfonts</a>
<a name="ln303">      QList&lt;MidiPatch*&gt; patches;</a>
<a name="ln304"> </a>
<a name="ln305">      QList&lt;Voice*&gt; freeVoices;           // unused synthesis processes</a>
<a name="ln306">      QList&lt;Voice*&gt; activeVoices;         // active synthesis processes</a>
<a name="ln307">      QString _error;                     // last error message</a>
<a name="ln308"> </a>
<a name="ln309">      static bool initialized;</a>
<a name="ln310"> </a>
<a name="ln311">      double sample_rate;                 // The sample rate</a>
<a name="ln312">      float _masterTuning;                // usually 440.0</a>
<a name="ln313">      double _tuning[128];                // the pitch of every key, in cents</a>
<a name="ln314"> </a>
<a name="ln315">      int _loadProgress = 0;</a>
<a name="ln316">      bool _loadWasCanceled = false;</a>
<a name="ln317"> </a>
<a name="ln318">      QMutex mutex;</a>
<a name="ln319">      void updatePatchList();</a>
<a name="ln320"> </a>
<a name="ln321">      //the variable is used to stop loading samples from the sf files</a>
<a name="ln322">      bool _globalTerminate = false;</a>
<a name="ln323"> </a>
<a name="ln324">   protected:</a>
<a name="ln325">      int _state;                         // the synthesizer state</a>
<a name="ln326"> </a>
<a name="ln327">      unsigned int sfont_id;</a>
<a name="ln328"> </a>
<a name="ln329">      QList&lt;Channel*&gt; channel;            // the channels</a>
<a name="ln330"> </a>
<a name="ln331">      unsigned int noteid;                // the id is incremented for every new note. it's used for noteoff's</a>
<a name="ln332"> </a>
<a name="ln333">      SFont* get_sfont_by_name(const QString&amp; name);</a>
<a name="ln334">      SFont* get_sfont_by_id(int id);</a>
<a name="ln335">      SFont* get_sfont(int idx) const     { return sfonts[idx];   }</a>
<a name="ln336">      bool sfunload(int id);</a>
<a name="ln337">      int sfload(const QString&amp; filename);</a>
<a name="ln338"> </a>
<a name="ln339">   public:</a>
<a name="ln340">      Fluid();</a>
<a name="ln341">      ~Fluid();</a>
<a name="ln342">      virtual void init(float sampleRate);</a>
<a name="ln343"> </a>
<a name="ln344">      virtual const char* name() const { return &quot;Fluid&quot;; }</a>
<a name="ln345"> </a>
<a name="ln346">      virtual void play(const PlayEvent&amp;);</a>
<a name="ln347">      virtual const QList&lt;MidiPatch*&gt;&amp; getPatchInfo() const { return patches; }</a>
<a name="ln348"> </a>
<a name="ln349">      // get/set synthesizer state (parameter set)</a>
<a name="ln350">      virtual SynthesizerGroup state() const;</a>
<a name="ln351">      virtual bool setState(const SynthesizerGroup&amp;);</a>
<a name="ln352"> </a>
<a name="ln353">      virtual void allSoundsOff(int);</a>
<a name="ln354">      virtual void allNotesOff(int);</a>
<a name="ln355"> </a>
<a name="ln356">      int loadProgress()            { return _loadProgress; }</a>
<a name="ln357">      void setLoadProgress(int val) { _loadProgress = val; }</a>
<a name="ln358">      bool loadWasCanceled()        { return _loadWasCanceled; }</a>
<a name="ln359">      void setLoadWasCanceled(bool status)     { _loadWasCanceled = status; }</a>
<a name="ln360"> </a>
<a name="ln361">      Preset* get_preset(unsigned int sfontnum, unsigned int banknum, unsigned int prognum);</a>
<a name="ln362">      Preset* find_preset(unsigned int banknum, unsigned int prognum);</a>
<a name="ln363">      void modulate_voices(int chan, bool is_cc, int ctrl);</a>
<a name="ln364">      void modulate_voices_all(int chan);</a>
<a name="ln365">      void damp_voices(int chan);</a>
<a name="ln366">      int kill_voice(Voice * voice);</a>
<a name="ln367">      void print_voice();</a>
<a name="ln368"> </a>
<a name="ln369">      /** This function assures that every MIDI channels has a valid preset</a>
<a name="ln370">       *  (NULL is okay). This function is called after a SoundFont is</a>
<a name="ln371">       *  unloaded or reloaded. */</a>
<a name="ln372">      void update_presets();</a>
<a name="ln373"> </a>
<a name="ln374">      int get_cc(int chan, int num) const { return channel[chan]-&gt;cc[num]; }</a>
<a name="ln375"> </a>
<a name="ln376">      void system_reset();</a>
<a name="ln377">      void program_change(int chan, int prognum);</a>
<a name="ln378"> </a>
<a name="ln379">      void set_gen2(int chan, int param, float value, int absolute, int normalized);</a>
<a name="ln380">      float get_gen(int chan, int param);</a>
<a name="ln381">      void set_gen(int chan, int param, float value);</a>
<a name="ln382">      void set_interp_method(int chan, int interp_method);</a>
<a name="ln383"> </a>
<a name="ln384">      Preset* get_channel_preset(int chan) const { return channel[chan]-&gt;preset(); }</a>
<a name="ln385"> </a>
<a name="ln386">      virtual bool loadSoundFonts(const QStringList&amp; s);</a>
<a name="ln387">      virtual bool addSoundFont(const QString&amp; s);</a>
<a name="ln388">      virtual bool removeSoundFont(const QString&amp; s);</a>
<a name="ln389">      QStringList soundFonts() const;</a>
<a name="ln390">      std::vector&lt;SoundFontInfo&gt; soundFontsInfo() const override;</a>
<a name="ln391"> </a>
<a name="ln392">      void start_voice(Voice* voice);</a>
<a name="ln393">      Voice* alloc_voice(unsigned id, Sample* sample, int chan, int key, int vel, double vt);</a>
<a name="ln394">      void free_voice_by_kill();</a>
<a name="ln395"> </a>
<a name="ln396">      virtual void process(unsigned len, float* out, float* effect1, float* effect2);</a>
<a name="ln397"> </a>
<a name="ln398">      bool program_select(int chan, unsigned sfont_id, unsigned bank_num, unsigned preset_num);</a>
<a name="ln399">      void get_program(int chan, unsigned* sfont_id, unsigned* bank_num, unsigned* preset_num);</a>
<a name="ln400">//      void sfont_select(int chan, unsigned int sfont_id)    { channel[chan]-&gt;setSfontnum(sfont_id); }</a>
<a name="ln401">//      void bank_select(int chan, unsigned int bank)         { channel[chan]-&gt;setBanknum(bank); }</a>
<a name="ln402"> </a>
<a name="ln403">      void get_pitch_wheel_sens(int chan, int* pval);</a>
<a name="ln404">      void pitch_wheel_sens(int chan, int val);</a>
<a name="ln405">      void get_pitch_bend(int chan, int* ppitch_bend);</a>
<a name="ln406"> </a>
<a name="ln407">      void freeVoice(Voice* v);</a>
<a name="ln408"> </a>
<a name="ln409">      double getPitch(int k) const   { return _tuning[k]; }</a>
<a name="ln410">      float ct2hz_real(float cents)  { return powf(2.0f, (cents - 6900.0f) / 1200.0f) * _masterTuning; }</a>
<a name="ln411"> </a>
<a name="ln412">      float act2hz(float c)          { return 8.176 * pow(2.0, (double) c / 1200.0); }</a>
<a name="ln413">      float ct2hz(float cents)       { return act2hz(qBound(1500.0f, cents, 13500.0f)); }</a>
<a name="ln414"> </a>
<a name="ln415">      virtual double masterTuning() const     { return _masterTuning; }</a>
<a name="ln416">      virtual void setMasterTuning(double f)  { _masterTuning = f;    }</a>
<a name="ln417"> </a>
<a name="ln418">      QString error() const { return _error; }</a>
<a name="ln419"> </a>
<a name="ln420">      virtual SynthesizerGui* gui();</a>
<a name="ln421"> </a>
<a name="ln422">      static QFileInfoList sfFiles();</a>
<a name="ln423"> </a>
<a name="ln424">      bool globalTerminate() { return _globalTerminate; }</a>
<a name="ln425">      void setGlobalTerminate(bool terminate = true) { _globalTerminate = terminate; }</a>
<a name="ln426"> </a>
<a name="ln427">      friend class Voice;</a>
<a name="ln428">      friend class Preset;</a>
<a name="ln429">      };</a>
<a name="ln430"> </a>
<a name="ln431">  /*</a>
<a name="ln432">   *</a>
<a name="ln433">   * Chorus</a>
<a name="ln434">   *</a>
<a name="ln435">   */</a>
<a name="ln436"> </a>
<a name="ln437">enum fluid_chorus_mod {</a>
<a name="ln438">      FLUID_CHORUS_MOD_SINE = 0,</a>
<a name="ln439">      FLUID_CHORUS_MOD_TRIANGLE = 1</a>
<a name="ln440">      };</a>
<a name="ln441"> </a>
<a name="ln442">/* Those are the default settings for the chorus. */</a>
<a name="ln443">#define FLUID_CHORUS_DEFAULT_N      3</a>
<a name="ln444">#define FLUID_CHORUS_DEFAULT_LEVEL  2.0f</a>
<a name="ln445">#define FLUID_CHORUS_DEFAULT_SPEED  0.3f</a>
<a name="ln446">#define FLUID_CHORUS_DEFAULT_DEPTH  8.0f</a>
<a name="ln447">#define FLUID_CHORUS_DEFAULT_TYPE   FLUID_CHORUS_MOD_SINE</a>
<a name="ln448"> </a>
<a name="ln449"> </a>
<a name="ln450">  /*</a>
<a name="ln451">   *</a>
<a name="ln452">   * Synthesis parameters</a>
<a name="ln453">   *</a>
<a name="ln454">   */</a>
<a name="ln455"> </a>
<a name="ln456">  /* Flags to choose the interpolation method */</a>
<a name="ln457">enum fluid_interp {</a>
<a name="ln458">      /* no interpolation: Fastest, but questionable audio quality */</a>
<a name="ln459">      FLUID_INTERP_NONE     = 0,</a>
<a name="ln460">      /* Straight-line interpolation: A bit slower, reasonable audio quality */</a>
<a name="ln461">      FLUID_INTERP_LINEAR   = 1,</a>
<a name="ln462">      /* Fourth-order interpolation: Requires 50 % of the whole DSP processing time, good quality</a>
<a name="ln463">       * Default. */</a>
<a name="ln464">      FLUID_INTERP_DEFAULT  = 4,</a>
<a name="ln465">      FLUID_INTERP_4THORDER = 4,</a>
<a name="ln466">      FLUID_INTERP_7THORDER = 7,</a>
<a name="ln467">      FLUID_INTERP_HIGHEST  = 7</a>
<a name="ln468">      };</a>
<a name="ln469"> </a>
<a name="ln470">#define fluid_sample_refcount(_sample) ((_sample)-&gt;refcount)</a>
<a name="ln471"> </a>
<a name="ln472"> </a>
<a name="ln473">/** Sample types */</a>
<a name="ln474"> </a>
<a name="ln475">enum {</a>
<a name="ln476">      FLUID_SAMPLETYPE_MONO =	      1,</a>
<a name="ln477">      FLUID_SAMPLETYPE_RIGHT =	2,</a>
<a name="ln478">      FLUID_SAMPLETYPE_LEFT =	      4,</a>
<a name="ln479">      FLUID_SAMPLETYPE_LINKED =	8,</a>
<a name="ln480">      FLUID_SAMPLETYPE_OGG_VORBIS = 0x10,</a>
<a name="ln481">      FLUID_SAMPLETYPE_ROM =	      0x8000</a>
<a name="ln482">      };</a>
<a name="ln483"> </a>
<a name="ln484">/* Sets the sound data of the sample</a>
<a name="ln485"> *     Warning : if copy_data is FALSE, data should have 8 unused frames at start</a>
<a name="ln486"> *     and 8 unused frames at the end.</a>
<a name="ln487"> */</a>
<a name="ln488">int fluid_sample_set_sound_data(Sample* sample, short *data,</a>
<a name="ln489">			       unsigned int nbframes, short copy_data, int rootkey);</a>
<a name="ln490"> </a>
<a name="ln491">/*</a>
<a name="ln492"> *</a>
<a name="ln493"> *  Utility functions</a>
<a name="ln494"> */</a>
<a name="ln495"> </a>
<a name="ln496">  /* Maximum number of modulators in a voice */</a>
<a name="ln497">#define FLUID_NUM_MOD           64</a>
<a name="ln498"> </a>
<a name="ln499">/**</a>
<a name="ln500"> * SoundFont generator structure.</a>
<a name="ln501"> */</a>
<a name="ln502">class Generator {</a>
<a name="ln503">   public:</a>
<a name="ln504">      unsigned char flags; /**&lt; Is the generator set or not (#fluid_gen_flags) */</a>
<a name="ln505">      double val;          /**&lt; The nominal value           */</a>
<a name="ln506">      double mod;          /**&lt; Change by modulators        */</a>
<a name="ln507">      double nrpn;         /**&lt; Change by NRPN messages     */</a>
<a name="ln508"> </a>
<a name="ln509">      void set_mod(double _val)  { mod  = _val; }</a>
<a name="ln510">      void set_nrpn(double _val) { nrpn = _val; }</a>
<a name="ln511">      };</a>
<a name="ln512"> </a>
<a name="ln513">/**</a>
<a name="ln514"> * Enum value for 'flags' field of #_Generator (not really flags).</a>
<a name="ln515"> */</a>
<a name="ln516">enum fluid_gen_flags {</a>
<a name="ln517">      GEN_UNUSED,		/**&lt; Generator value is not set */</a>
<a name="ln518">      GEN_SET,		/**&lt; Generator value is set     */</a>
<a name="ln519">      GEN_ABS_NRPN	/**&lt; DOCME                      */</a>
<a name="ln520">      };</a>
<a name="ln521"> </a>
<a name="ln522">void fluid_gen_set_default_values(Generator* gen);</a>
<a name="ln523">  /*</a>
<a name="ln524">   *  The interface to the synthesizer's voices</a>
<a name="ln525">   *  Examples on using them can be found in fluid_defsfont.c</a>
<a name="ln526">   */</a>
<a name="ln527"> </a>
<a name="ln528">  /* for fluid_voice_add_mod */</a>
<a name="ln529">enum fluid_voice_add_mod {</a>
<a name="ln530">      FLUID_VOICE_OVERWRITE,</a>
<a name="ln531">      FLUID_VOICE_ADD,</a>
<a name="ln532">      FLUID_VOICE_DEFAULT</a>
<a name="ln533">      };</a>
<a name="ln534"> </a>
<a name="ln535">/* Disable FPE exception check */</a>
<a name="ln536">#define fluid_check_fpe(expl)</a>
<a name="ln537"> </a>
<a name="ln538">unsigned int fluid_check_fpe_i386(char * explanation_in_case_of_fpe);</a>
<a name="ln539"> </a>
<a name="ln540">/*</a>
<a name="ln541"> * interpolation data</a>
<a name="ln542"> */</a>
<a name="ln543">struct fluid_interp_coeff_t {</a>
<a name="ln544">      float a0, a1, a2, a3;</a>
<a name="ln545">      };</a>
<a name="ln546"> </a>
<a name="ln547">/* Flags telling the polarity of a modulator.  Compare with SF2.01</a>
<a name="ln548">   section 8.2. Note: The numbers of the bits are different!  (for</a>
<a name="ln549">   example: in the flags of a SF modulator, the polarity bit is bit</a>
<a name="ln550">   nr. 9) */</a>
<a name="ln551"> </a>
<a name="ln552">enum fluid_mod_flags {</a>
<a name="ln553">      FLUID_MOD_POSITIVE = 0,</a>
<a name="ln554">      FLUID_MOD_NEGATIVE = 1,</a>
<a name="ln555">      FLUID_MOD_UNIPOLAR = 0,</a>
<a name="ln556">      FLUID_MOD_BIPOLAR  = 2,</a>
<a name="ln557">      FLUID_MOD_LINEAR   = 0,</a>
<a name="ln558">      FLUID_MOD_CONCAVE  = 4,</a>
<a name="ln559">      FLUID_MOD_CONVEX   = 8,</a>
<a name="ln560">      FLUID_MOD_SWITCH   = 12,</a>
<a name="ln561">      FLUID_MOD_GC       = 0,</a>
<a name="ln562">      FLUID_MOD_CC       = 16</a>
<a name="ln563">      };</a>
<a name="ln564"> </a>
<a name="ln565">//---------------------------------------------------------</a>
<a name="ln566">//   Mod</a>
<a name="ln567">//---------------------------------------------------------</a>
<a name="ln568"> </a>
<a name="ln569">struct Mod</a>
<a name="ln570">      {</a>
<a name="ln571">      unsigned char dest;</a>
<a name="ln572">      unsigned char src1;</a>
<a name="ln573">      unsigned char flags1;</a>
<a name="ln574">      unsigned char src2;</a>
<a name="ln575">      unsigned char flags2;</a>
<a name="ln576">      double amount;</a>
<a name="ln577"> </a>
<a name="ln578">      void clone(Mod* mod) const;</a>
<a name="ln579">      void dump() const;</a>
<a name="ln580">      int has_source(bool cc, int ctrl) {</a>
<a name="ln581">            return (((src1 == ctrl) &amp;&amp; (flags1 &amp; FLUID_MOD_CC)    &amp;&amp; cc)</a>
<a name="ln582">                || (((src1 == ctrl) &amp;&amp; (!(flags1 &amp; FLUID_MOD_CC)) &amp;&amp; !cc)))</a>
<a name="ln583">                || (((src2 == ctrl) &amp;&amp; (flags2 &amp; FLUID_MOD_CC)    &amp;&amp; cc)</a>
<a name="ln584">                || (((src2 == ctrl) &amp;&amp; (!(flags2 &amp; FLUID_MOD_CC)) &amp;&amp; !cc)));</a>
<a name="ln585">            }</a>
<a name="ln586">      void set_source1(int src, int flags);</a>
<a name="ln587">      void set_source2(int src, int flags);</a>
<a name="ln588">      void set_dest(int val)                    { dest = val;    }</a>
<a name="ln589">      void set_amount(double val)               { amount = val;  }</a>
<a name="ln590">      int get_source1() const                   { return src1;   }</a>
<a name="ln591">      int get_flags1() const                    { return flags1; }</a>
<a name="ln592">      int get_source2() const                   { return src2;   }</a>
<a name="ln593">      int get_flags2() const                    { return flags2; }</a>
<a name="ln594">      int get_dest() const                      { return dest;   }</a>
<a name="ln595">      double get_amount() const                 { return amount; }</a>
<a name="ln596">      float get_value(Channel* chan, Voice* voice);</a>
<a name="ln597">      };</a>
<a name="ln598"> </a>
<a name="ln599">/* Flags telling the source of a modulator.  This corresponds to</a>
<a name="ln600"> * SF2.01 section 8.2.1 */</a>
<a name="ln601"> </a>
<a name="ln602">enum fluid_mod_src {</a>
<a name="ln603">      FLUID_MOD_NONE             = 0,</a>
<a name="ln604">      FLUID_MOD_VELOCITY         = 2,</a>
<a name="ln605">      FLUID_MOD_KEY              = 3,</a>
<a name="ln606">      FLUID_MOD_KEYPRESSURE      = 10,          // polyphonic aftertouch</a>
<a name="ln607">      FLUID_MOD_CHANNELPRESSURE  = 13,          // channel aftertouch</a>
<a name="ln608">      FLUID_MOD_PITCHWHEEL       = 14,</a>
<a name="ln609">      FLUID_MOD_PITCHWHEELSENS   = 16</a>
<a name="ln610">      };</a>
<a name="ln611"> </a>
<a name="ln612">/* Determines, if two modulators are 'identical' (all parameters</a>
<a name="ln613">   except the amount match) */</a>
<a name="ln614">bool test_identity(const Mod * mod1, const Mod * mod2);</a>
<a name="ln615"> </a>
<a name="ln616">void fluid_dump_modulator(Mod * mod);</a>
<a name="ln617"> </a>
<a name="ln618">#define fluid_mod_has_source(mod,cc,ctrl)  \</a>
<a name="ln619">( ((((mod)-&gt;src1 == ctrl) &amp;&amp; (((mod)-&gt;flags1 &amp; FLUID_MOD_CC) != 0) &amp;&amp; (cc != 0)) \</a>
<a name="ln620">   || ((((mod)-&gt;src1 == ctrl) &amp;&amp; (((mod)-&gt;flags1 &amp; FLUID_MOD_CC) == 0) &amp;&amp; (cc == 0)))) \</a>
<a name="ln621">|| ((((mod)-&gt;src2 == ctrl) &amp;&amp; (((mod)-&gt;flags2 &amp; FLUID_MOD_CC) != 0) &amp;&amp; (cc != 0)) \</a>
<a name="ln622">    || ((((mod)-&gt;src2 == ctrl) &amp;&amp; (((mod)-&gt;flags2 &amp; FLUID_MOD_CC) == 0) &amp;&amp; (cc == 0)))))</a>
<a name="ln623"> </a>
<a name="ln624">#define fluid_mod_has_dest(mod,gen)  ((mod)-&gt;dest == gen)</a>
<a name="ln625"> </a>
<a name="ln626">/*</a>
<a name="ln627"> *  phase</a>
<a name="ln628"> */</a>
<a name="ln629"> </a>
<a name="ln630">#define FLUID_INTERP_BITS        8</a>
<a name="ln631">#define FLUID_INTERP_BITS_MASK   0xff000000</a>
<a name="ln632">#define FLUID_INTERP_BITS_SHIFT  24</a>
<a name="ln633">#define FLUID_INTERP_MAX         256</a>
<a name="ln634"> </a>
<a name="ln635">#define FLUID_FRACT_MAX ((double)4294967296.0)</a>
<a name="ln636"> </a>
<a name="ln637">//---------------------------------------------------------</a>
<a name="ln638">//   Phase</a>
<a name="ln639">/* Purpose:</a>
<a name="ln640">* Playing pointer for voice playback</a>
<a name="ln641">*</a>
<a name="ln642">* When a sample is played back at a different pitch, the playing pointer in the</a>
<a name="ln643">* source sample will not advance exactly one sample per output sample.</a>
<a name="ln644">* This playing pointer is implemented using Phase.</a>
<a name="ln645">* It is a 64 bit number. The higher 32 bits contain the 'index' (number of</a>
<a name="ln646">* the current sample), the lower 32 bits the fractional part.</a>
<a name="ln647">* Access is possible in two ways:</a>
<a name="ln648">* -through the 64 bit part 'b64', if the architecture supports 64 bit integers</a>
<a name="ln649">* -through 'index' and 'fract'</a>
<a name="ln650">* Note: b64 and index / fract share the same memory location!</a>
<a name="ln651">*/</a>
<a name="ln652"> </a>
<a name="ln653">struct Phase {</a>
<a name="ln654">      qint64 data;</a>
<a name="ln655"> </a>
<a name="ln656">      void operator+=(const Phase&amp; p) { data += p.data; }</a>
<a name="ln657">      void setInt(qint32 b)           { data = qint64(b) &lt;&lt; 32; }</a>
<a name="ln658">      void setFloat(double b)          {</a>
<a name="ln659">             data = (((qint64)(b)) &lt;&lt; 32) | (quint32) (((double)(b) - (int)(b)) * (double)FLUID_FRACT_MAX);</a>
<a name="ln660">            }</a>
<a name="ln661"> </a>
<a name="ln662">      void operator-=(const Phase&amp; b) { data -= b.data;  }</a>
<a name="ln663">      void operator-=(int b)          { data -= (qint64(b) &lt;&lt; 32);  }</a>
<a name="ln664">      int index() const               { return data &gt;&gt; 32; }</a>
<a name="ln665">      quint32 fract() const           { return quint32(data &amp; 0xffffffff); }</a>
<a name="ln666">      quint32 index_round() const     { return quint32((data+0x80000000) &gt;&gt; 32); }</a>
<a name="ln667"> </a>
<a name="ln668">      Phase() {}</a>
<a name="ln669">      Phase(qint64 v) : data(v) {}</a>
<a name="ln670">      };</a>
<a name="ln671"> </a>
<a name="ln672">/* Purpose:</a>
<a name="ln673"> * Takes the fractional part of the argument phase and</a>
<a name="ln674"> * calculates the corresponding position in the interpolation table.</a>
<a name="ln675"> * The fractional position of the playing pointer is calculated with a quite high</a>
<a name="ln676"> * resolution (32 bits). It would be unpractical to keep a set of interpolation</a>
<a name="ln677"> * coefficients for each possible fractional part...</a>
<a name="ln678"> */</a>
<a name="ln679">#define fluid_phase_fract_to_tablerow(_x) \</a>
<a name="ln680">  ((int)(((_x).fract() &amp; FLUID_INTERP_BITS_MASK) &gt;&gt; FLUID_INTERP_BITS_SHIFT))</a>
<a name="ln681"> </a>
<a name="ln682">#define fluid_phase_double(_x) \</a>
<a name="ln683">  ((double)((_x).index()) + ((double)((_x).fract()) / FLUID_FRACT_MAX))</a>
<a name="ln684"> </a>
<a name="ln685">/* Purpose:</a>
<a name="ln686"> * The playing pointer is _phase. How many output samples are produced, until the point _p1 in the sample is reached,</a>
<a name="ln687"> * if _phase advances in steps of _incr?</a>
<a name="ln688"> */</a>
<a name="ln689">#define fluid_phase_steps(_phase,_idx,_incr) \</a>
<a name="ln690">  (int)(((double)(_idx) - fluid_phase_double(_phase)) / (double)_incr)</a>
<a name="ln691"> </a>
<a name="ln692">/* Purpose:</a>
<a name="ln693"> * Creates the expression a.index++.</a>
<a name="ln694">*/</a>
<a name="ln695">#define fluid_phase_index_plusplus(a) (((a)._index)++)</a>
<a name="ln696"> </a>
<a name="ln697">}  // namespace Fluid</a>
<a name="ln698"> </a>
<a name="ln699">#endif  // __FLUID_S_H__</a>

</code></pre>
<div class="balloon" rel="668"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: data.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
