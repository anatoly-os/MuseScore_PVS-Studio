
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>slur.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2016 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;measure.h&quot;</a>
<a name="ln14">#include &quot;score.h&quot;</a>
<a name="ln15">#include &quot;system.h&quot;</a>
<a name="ln16">#include &quot;undo.h&quot;</a>
<a name="ln17">#include &quot;chord.h&quot;</a>
<a name="ln18">#include &quot;stem.h&quot;</a>
<a name="ln19">#include &quot;slur.h&quot;</a>
<a name="ln20">#include &quot;tie.h&quot;</a>
<a name="ln21">#include &quot;part.h&quot;</a>
<a name="ln22">#include &quot;navigate.h&quot;</a>
<a name="ln23">#include &quot;articulation.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">namespace Ms {</a>
<a name="ln26"> </a>
<a name="ln27">//---------------------------------------------------------</a>
<a name="ln28">//   draw</a>
<a name="ln29">//---------------------------------------------------------</a>
<a name="ln30"> </a>
<a name="ln31">void SlurSegment::draw(QPainter* painter) const</a>
<a name="ln32">      {</a>
<a name="ln33">      QPen pen(curColor());</a>
<a name="ln34">      qreal mag = staff() ? staff()-&gt;mag(slur()-&gt;tick()) : 1.0;</a>
<a name="ln35"> </a>
<a name="ln36">      switch (slurTie()-&gt;lineType()) {</a>
<a name="ln37">            case 0:</a>
<a name="ln38">                  painter-&gt;setBrush(QBrush(pen.color()));</a>
<a name="ln39">                  pen.setCapStyle(Qt::RoundCap);</a>
<a name="ln40">                  pen.setJoinStyle(Qt::RoundJoin);</a>
<a name="ln41">                  pen.setWidthF(score()-&gt;styleP(Sid::SlurEndWidth) * mag);</a>
<a name="ln42">                  break;</a>
<a name="ln43">            case 1:</a>
<a name="ln44">                  painter-&gt;setBrush(Qt::NoBrush);</a>
<a name="ln45">                  pen.setWidthF(score()-&gt;styleP(Sid::SlurDottedWidth) * mag);</a>
<a name="ln46">                  pen.setStyle(Qt::DotLine);</a>
<a name="ln47">                  break;</a>
<a name="ln48">            case 2:</a>
<a name="ln49">                  painter-&gt;setBrush(Qt::NoBrush);</a>
<a name="ln50">                  pen.setWidthF(score()-&gt;styleP(Sid::SlurDottedWidth) * mag);</a>
<a name="ln51">                  pen.setStyle(Qt::DashLine);</a>
<a name="ln52">                  break;</a>
<a name="ln53">            case 3:</a>
<a name="ln54">                  painter-&gt;setBrush(Qt::NoBrush);</a>
<a name="ln55">                  pen.setWidthF(score()-&gt;styleP(Sid::SlurDottedWidth) * mag);</a>
<a name="ln56">                  pen.setStyle(Qt::CustomDashLine);</a>
<a name="ln57">                  QVector&lt;qreal&gt; dashes { 5.0, 5.0 };</a>
<a name="ln58">                  pen.setDashPattern(dashes);</a>
<a name="ln59">                  break;</a>
<a name="ln60">            }</a>
<a name="ln61">      painter-&gt;setPen(pen);</a>
<a name="ln62">      painter-&gt;drawPath(path);</a>
<a name="ln63">      }</a>
<a name="ln64"> </a>
<a name="ln65">//---------------------------------------------------------</a>
<a name="ln66">//   searchCR</a>
<a name="ln67">//---------------------------------------------------------</a>
<a name="ln68"> </a>
<a name="ln69">static ChordRest* searchCR(Segment* segment, int startTrack, int endTrack)</a>
<a name="ln70">      {</a>
<a name="ln71">      // for (Segment* s = segment; s; s = s-&gt;next1MM(SegmentType::ChordRest)) {</a>
<a name="ln72">      for (Segment* s = segment; s; s = s-&gt;next(SegmentType::ChordRest)) {     // restrict search to measure</a>
<a name="ln73">            if (startTrack &gt; endTrack) {</a>
<a name="ln74">                  for (int t = startTrack-1; t &gt;= endTrack; --t) {</a>
<a name="ln75">                        if (s-&gt;element(t))</a>
<a name="ln76">                              return toChordRest(s-&gt;element(t));</a>
<a name="ln77">                        }</a>
<a name="ln78">                  }</a>
<a name="ln79">            else {</a>
<a name="ln80">                  for (int t = startTrack; t &lt; endTrack; ++t) {</a>
<a name="ln81">                        if (s-&gt;element(t))</a>
<a name="ln82">                              return toChordRest(s-&gt;element(t));</a>
<a name="ln83">                        }</a>
<a name="ln84">                  }</a>
<a name="ln85">            }</a>
<a name="ln86">      return 0;</a>
<a name="ln87">      }</a>
<a name="ln88"> </a>
<a name="ln89">//---------------------------------------------------------</a>
<a name="ln90">//   edit</a>
<a name="ln91">//    return true if event is accepted</a>
<a name="ln92">//---------------------------------------------------------</a>
<a name="ln93"> </a>
<a name="ln94">bool SlurSegment::edit(EditData&amp; ed)</a>
<a name="ln95">      {</a>
<a name="ln96">      Slur* sl = slur();</a>
<a name="ln97"> </a>
<a name="ln98">      if (ed.key == Qt::Key_X) {</a>
<a name="ln99">            sl-&gt;undoChangeProperty(Pid::SLUR_DIRECTION, QVariant::fromValue&lt;Direction&gt;(sl-&gt;up() ? Direction::DOWN : Direction::UP));</a>
<a name="ln100">            sl-&gt;layout();</a>
<a name="ln101">            return true;</a>
<a name="ln102">            }</a>
<a name="ln103">      if (ed.key == Qt::Key_Home) {</a>
<a name="ln104">            ups(ed.curGrip).off = QPointF();          //TODO</a>
<a name="ln105">            sl-&gt;layout();</a>
<a name="ln106">            return true;</a>
<a name="ln107">            }</a>
<a name="ln108"> </a>
<a name="ln109">      if (!((ed.modifiers &amp; Qt::ShiftModifier) &amp;&amp; (isSingleType() || (isBeginType() &amp;&amp; ed.curGrip == Grip::START) || (isEndType() &amp;&amp; ed.curGrip == Grip::END))))</a>
<a name="ln110">            return false;</a>
<a name="ln111"> </a>
<a name="ln112">      ChordRest* cr = 0;</a>
<a name="ln113">      ChordRest* e;</a>
<a name="ln114">      ChordRest* e1;</a>
<a name="ln115">      if (ed.curGrip == Grip::START) {</a>
<a name="ln116">            e  = sl-&gt;startCR();</a>
<a name="ln117">            e1 = sl-&gt;endCR();</a>
<a name="ln118">            }</a>
<a name="ln119">      else {</a>
<a name="ln120">            e  = sl-&gt;endCR();</a>
<a name="ln121">            e1 = sl-&gt;startCR();</a>
<a name="ln122">            }</a>
<a name="ln123"> </a>
<a name="ln124">      if (ed.key == Qt::Key_Left)</a>
<a name="ln125">            cr = prevChordRest(e);</a>
<a name="ln126">      else if (ed.key == Qt::Key_Right)</a>
<a name="ln127">            cr = nextChordRest(e);</a>
<a name="ln128">      else if (ed.key == Qt::Key_Up) {</a>
<a name="ln129">            Part* part     = e-&gt;part();</a>
<a name="ln130">            int startTrack = part-&gt;startTrack();</a>
<a name="ln131">            int endTrack   = e-&gt;track();</a>
<a name="ln132">            cr = searchCR(e-&gt;segment(), endTrack, startTrack);</a>
<a name="ln133">            }</a>
<a name="ln134">      else if (ed.key == Qt::Key_Down) {</a>
<a name="ln135">            int startTrack = e-&gt;track() + 1;</a>
<a name="ln136">            Part* part     = e-&gt;part();</a>
<a name="ln137">            int endTrack   = part-&gt;endTrack();</a>
<a name="ln138">            cr = searchCR(e-&gt;segment(), startTrack, endTrack);</a>
<a name="ln139">            }</a>
<a name="ln140">      if (cr &amp;&amp; cr != e1)</a>
<a name="ln141">            changeAnchor(ed, cr);</a>
<a name="ln142">      return true;</a>
<a name="ln143">      }</a>
<a name="ln144"> </a>
<a name="ln145">//---------------------------------------------------------</a>
<a name="ln146">//   changeAnchor</a>
<a name="ln147">//---------------------------------------------------------</a>
<a name="ln148"> </a>
<a name="ln149">void SlurSegment::changeAnchor(EditData&amp; ed, Element* element)</a>
<a name="ln150">      {</a>
<a name="ln151">      ChordRest* cr = element-&gt;isChordRest() ? toChordRest(element) : nullptr;</a>
<a name="ln152">      ChordRest* scr = spanner()-&gt;startCR();</a>
<a name="ln153">      ChordRest* ecr = spanner()-&gt;endCR();</a>
<a name="ln154">      if (!cr || !scr || !ecr)</a>
<a name="ln155">            return;</a>
<a name="ln156"> </a>
<a name="ln157">      // save current start/end elements</a>
<a name="ln158">      for (ScoreElement* e : spanner()-&gt;linkList()) {</a>
<a name="ln159">            Spanner* sp = toSpanner(e);</a>
<a name="ln160">            score()-&gt;undoStack()-&gt;push1(new ChangeStartEndSpanner(sp, sp-&gt;startElement(), sp-&gt;endElement()));</a>
<a name="ln161">            }</a>
<a name="ln162"> </a>
<a name="ln163">      if (ed.curGrip == Grip::START) {</a>
<a name="ln164">            spanner()-&gt;undoChangeProperty(Pid::SPANNER_TICK, cr-&gt;tick());</a>
<a name="ln165">            Fraction ticks = ecr-&gt;tick() - cr-&gt;tick();</a>
<a name="ln166">            spanner()-&gt;undoChangeProperty(Pid::SPANNER_TICKS, ticks);</a>
<a name="ln167">            int diff = cr-&gt;track() - spanner()-&gt;track();</a>
<a name="ln168">            for (auto e : spanner()-&gt;linkList()) {</a>
<a name="ln169">                  Spanner* s = toSpanner(e);</a>
<a name="ln170">                  s-&gt;undoChangeProperty(Pid::TRACK, s-&gt;track() + diff);</a>
<a name="ln171">                  }</a>
<a name="ln172">            scr = cr;</a>
<a name="ln173">            }</a>
<a name="ln174">      else {</a>
<a name="ln175">            Fraction ticks = cr-&gt;tick() - scr-&gt;tick();</a>
<a name="ln176">            spanner()-&gt;undoChangeProperty(Pid::SPANNER_TICKS, ticks);</a>
<a name="ln177">            int diff = cr-&gt;track() - spanner()-&gt;track();</a>
<a name="ln178">            for (auto e : spanner()-&gt;linkList()) {</a>
<a name="ln179">                  Spanner* s = toSpanner(e);</a>
<a name="ln180">                  s-&gt;undoChangeProperty(Pid::SPANNER_TRACK2, s-&gt;track() + diff);</a>
<a name="ln181">                  }</a>
<a name="ln182">            ecr = cr;</a>
<a name="ln183">            }</a>
<a name="ln184"> </a>
<a name="ln185">      // update start/end elements (which could be grace notes)</a>
<a name="ln186">      for (ScoreElement* lsp : spanner()-&gt;linkList()) {</a>
<a name="ln187">            Spanner* sp = static_cast&lt;Spanner*&gt;(lsp);</a>
<a name="ln188">            if (sp == spanner()) {</a>
<a name="ln189">                  score()-&gt;undo(new ChangeSpannerElements(sp, scr, ecr));</a>
<a name="ln190">                  }</a>
<a name="ln191">            else {</a>
<a name="ln192">                  Element* se = 0;</a>
<a name="ln193">                  Element* ee = 0;</a>
<a name="ln194">                  if (scr) {</a>
<a name="ln195">                        QList&lt;ScoreElement*&gt; sel = scr-&gt;linkList();</a>
<a name="ln196">                        for (ScoreElement* lcr : sel) {</a>
<a name="ln197">                              Element* le = toElement(lcr);</a>
<a name="ln198">                              if (le-&gt;score() == sp-&gt;score() &amp;&amp; le-&gt;track() == sp-&gt;track()) {</a>
<a name="ln199">                                    se = le;</a>
<a name="ln200">                                    break;</a>
<a name="ln201">                                    }</a>
<a name="ln202">                              }</a>
<a name="ln203">                        }</a>
<a name="ln204">                  if (ecr) {</a>
<a name="ln205">                        QList&lt;ScoreElement*&gt; sel = ecr-&gt;linkList();</a>
<a name="ln206">                        for (ScoreElement* lcr : sel) {</a>
<a name="ln207">                              Element* le = toElement(lcr);</a>
<a name="ln208">                              if (le-&gt;score() == sp-&gt;score() &amp;&amp; le-&gt;track() == sp-&gt;track2()) {</a>
<a name="ln209">                                    ee = le;</a>
<a name="ln210">                                    break;</a>
<a name="ln211">                                    }</a>
<a name="ln212">                              }</a>
<a name="ln213">                        }</a>
<a name="ln214">                  score()-&gt;undo(new ChangeStartEndSpanner(sp, se, ee));</a>
<a name="ln215">                  sp-&gt;layout();</a>
<a name="ln216">                  }</a>
<a name="ln217">            }</a>
<a name="ln218"> </a>
<a name="ln219">      const size_t segments  = spanner()-&gt;spannerSegments().size();</a>
<a name="ln220">      ups(ed.curGrip).off = QPointF();</a>
<a name="ln221">      spanner()-&gt;layout();</a>
<a name="ln222">      if (spanner()-&gt;spannerSegments().size() != segments) {</a>
<a name="ln223">            const std::vector&lt;SpannerSegment*&gt;&amp; ss = spanner()-&gt;spannerSegments();</a>
<a name="ln224">            SlurSegment* newSegment = toSlurSegment(ed.curGrip == Grip::END ? ss.back() : ss.front());</a>
<a name="ln225">            ed.view-&gt;startEdit(newSegment, ed.curGrip);</a>
<a name="ln226">            triggerLayout();</a>
<a name="ln227">            }</a>
<a name="ln228">      }</a>
<a name="ln229"> </a>
<a name="ln230">//---------------------------------------------------------</a>
<a name="ln231">//   computeBezier</a>
<a name="ln232">//    compute help points of slur bezier segment</a>
<a name="ln233">//---------------------------------------------------------</a>
<a name="ln234"> </a>
<a name="ln235">void SlurSegment::computeBezier(QPointF p6o)</a>
<a name="ln236">      {</a>
<a name="ln237">      qreal _spatium  = spatium();</a>
<a name="ln238">      qreal shoulderW;              // height as fraction of slur-length</a>
<a name="ln239">      qreal shoulderH;</a>
<a name="ln240">      //</a>
<a name="ln241">      // pp1 and pp2 are the end points of the slur</a>
<a name="ln242">      //</a>
<a name="ln243">      QPointF pp1 = ups(Grip::START).p + ups(Grip::START).off;</a>
<a name="ln244">      QPointF pp2 = ups(Grip::END).p   + ups(Grip::END).off;</a>
<a name="ln245"> </a>
<a name="ln246">      QPointF p2 = pp2 - pp1;</a>
<a name="ln247">      if ((p2.x() == 0.0) &amp;&amp; (p2.y() == 0.0)) {</a>
<a name="ln248">            Measure* m1 = slur()-&gt;startCR()-&gt;segment()-&gt;measure();</a>
<a name="ln249">            Measure* m2 = slur()-&gt;endCR()-&gt;segment()-&gt;measure();</a>
<a name="ln250">            qDebug(&quot;zero slur at tick %d(%d) track %d in measure %d-%d  tick %d ticks %d&quot;,</a>
<a name="ln251">               m1-&gt;tick().ticks(), tick().ticks(), track(), m1-&gt;no(), m2-&gt;no(), slur()-&gt;tick().ticks(), slur()-&gt;ticks().ticks());</a>
<a name="ln252">            slur()-&gt;setBroken(true);</a>
<a name="ln253">            return;</a>
<a name="ln254">            }</a>
<a name="ln255"> </a>
<a name="ln256">      qreal sinb = atan(p2.y() / p2.x());</a>
<a name="ln257">      QTransform t;</a>
<a name="ln258">      t.rotateRadians(-sinb);</a>
<a name="ln259">      p2  = t.map(p2);</a>
<a name="ln260">      p6o = t.map(p6o);</a>
<a name="ln261"> </a>
<a name="ln262">      double smallH = 0.5;</a>
<a name="ln263">      qreal d = p2.x() / _spatium;</a>
<a name="ln264">      if (d &lt;= 2.0) {</a>
<a name="ln265">            shoulderH = d * 0.5 * smallH * _spatium;</a>
<a name="ln266">            shoulderW = .6;</a>
<a name="ln267">            }</a>
<a name="ln268">      else {</a>
<a name="ln269">            qreal dd = log10(1.0 + (d - 2.0) * .5) * 2.0;</a>
<a name="ln270">            if (dd &gt; 3.0)</a>
<a name="ln271">                  dd = 3.0;</a>
<a name="ln272">            shoulderH = (dd + smallH) * _spatium + _extraHeight;</a>
<a name="ln273">            if (d &gt; 18.0)</a>
<a name="ln274">                  shoulderW = 0.7; // 0.8;</a>
<a name="ln275">            else if (d &gt; 10)</a>
<a name="ln276">                  shoulderW = 0.6; // 0.7;</a>
<a name="ln277">            else</a>
<a name="ln278">                  shoulderW = 0.5; // 0.6;</a>
<a name="ln279">            }</a>
<a name="ln280"> </a>
<a name="ln281">      shoulderH -= p6o.y();</a>
<a name="ln282"> </a>
<a name="ln283">      if (!slur()-&gt;up())</a>
<a name="ln284">            shoulderH = -shoulderH;</a>
<a name="ln285"> </a>
<a name="ln286">      qreal c    = p2.x();</a>
<a name="ln287">      qreal c1   = (c - c * shoulderW) * .5 + p6o.x();</a>
<a name="ln288">      qreal c2   = c1 + c * shoulderW       + p6o.x();</a>
<a name="ln289"> </a>
<a name="ln290">      QPointF p5 = QPointF(c * .5, 0.0);</a>
<a name="ln291"> </a>
<a name="ln292">      QPointF p3(c1, -shoulderH);</a>
<a name="ln293">      QPointF p4(c2, -shoulderH);</a>
<a name="ln294"> </a>
<a name="ln295">      qreal w = score()-&gt;styleP(Sid::SlurMidWidth) - score()-&gt;styleP(Sid::SlurEndWidth);</a>
<a name="ln296">      if (staff())</a>
<a name="ln297">            w *= staff()-&gt;mag(slur()-&gt;tick());</a>
<a name="ln298">      if ((c2 - c1) &lt;= _spatium)</a>
<a name="ln299">            w *= .5;</a>
<a name="ln300">      QPointF th(0.0, w);    // thickness of slur</a>
<a name="ln301"> </a>
<a name="ln302">      QPointF p3o = p6o + t.map(ups(Grip::BEZIER1).off);</a>
<a name="ln303">      QPointF p4o = p6o + t.map(ups(Grip::BEZIER2).off);</a>
<a name="ln304"> </a>
<a name="ln305">      if (!p6o.isNull()) {</a>
<a name="ln306">            QPointF p6i = t.inverted().map(p6o);</a>
<a name="ln307">            ups(Grip::BEZIER1).off += p6i ;</a>
<a name="ln308">            ups(Grip::BEZIER2).off += p6i;</a>
<a name="ln309">            }</a>
<a name="ln310"> </a>
<a name="ln311">      //-----------------------------------calculate p6</a>
<a name="ln312">      QPointF pp3  = p3 + p3o;</a>
<a name="ln313">      QPointF pp4  = p4 + p4o;</a>
<a name="ln314">      QPointF ppp4 = pp4 - pp3;</a>
<a name="ln315"> </a>
<a name="ln316">      qreal r2 = atan(ppp4.y() / ppp4.x());</a>
<a name="ln317">      t.reset();</a>
<a name="ln318">      t.rotateRadians(-r2);</a>
<a name="ln319">      QPointF p6  = QPointF(t.map(ppp4).x() * .5, 0.0);</a>
<a name="ln320"> </a>
<a name="ln321">      t.rotateRadians(2 * r2);</a>
<a name="ln322">      p6 = t.map(p6) + pp3 - p6o;</a>
<a name="ln323">      //-----------------------------------</a>
<a name="ln324"> </a>
<a name="ln325">      path = QPainterPath();</a>
<a name="ln326">      path.moveTo(QPointF());</a>
<a name="ln327">      path.cubicTo(p3 + p3o - th, p4 + p4o - th, p2);</a>
<a name="ln328">      if (slur()-&gt;lineType() == 0)</a>
<a name="ln329">            path.cubicTo(p4 +p4o + th, p3 + p3o + th, QPointF());</a>
<a name="ln330"> </a>
<a name="ln331">      th = QPointF(0.0, 3.0 * w);</a>
<a name="ln332">      shapePath = QPainterPath();</a>
<a name="ln333">      shapePath.moveTo(QPointF());</a>
<a name="ln334">      shapePath.cubicTo(p3 + p3o - th, p4 + p4o - th, p2);</a>
<a name="ln335">      shapePath.cubicTo(p4 +p4o + th, p3 + p3o + th, QPointF());</a>
<a name="ln336"> </a>
<a name="ln337">      // translate back</a>
<a name="ln338">      t.reset();</a>
<a name="ln339">      t.translate(pp1.x(), pp1.y());</a>
<a name="ln340">      t.rotateRadians(sinb);</a>
<a name="ln341">      path                  = t.map(path);</a>
<a name="ln342">      shapePath             = t.map(shapePath);</a>
<a name="ln343">      ups(Grip::BEZIER1).p  = t.map(p3);</a>
<a name="ln344">      ups(Grip::BEZIER2).p  = t.map(p4);</a>
<a name="ln345">      ups(Grip::END).p      = t.map(p2) - ups(Grip::END).off;</a>
<a name="ln346">      ups(Grip::DRAG).p     = t.map(p5);</a>
<a name="ln347">      ups(Grip::SHOULDER).p = t.map(p6);</a>
<a name="ln348"> </a>
<a name="ln349">      _shape.clear();</a>
<a name="ln350">      QPointF start = pp1;</a>
<a name="ln351">      int nbShapes  = 32;  // (pp2.x() - pp1.x()) / _spatium;</a>
<a name="ln352">      qreal minH    = qAbs(3 * w);</a>
<a name="ln353">      const CubicBezier b(pp1, ups(Grip::BEZIER1).pos(), ups(Grip::BEZIER2).pos(), ups(Grip::END).pos());</a>
<a name="ln354">      for (int i = 1; i &lt;= nbShapes; i++) {</a>
<a name="ln355">            const QPointF point = b.pointAtPercent(i/float(nbShapes));</a>
<a name="ln356">            QRectF re     = QRectF(start, point).normalized();</a>
<a name="ln357">            if (re.height() &lt; minH) {</a>
<a name="ln358">                  qreal d1 = (minH - re.height()) * .5;</a>
<a name="ln359">                  re.adjust(0.0, -d1, 0.0, d1);</a>
<a name="ln360">                  }</a>
<a name="ln361">            _shape.add(re);</a>
<a name="ln362">            start = point;</a>
<a name="ln363">            }</a>
<a name="ln364">      }</a>
<a name="ln365"> </a>
<a name="ln366">//---------------------------------------------------------</a>
<a name="ln367">//   layoutSegment</a>
<a name="ln368">//---------------------------------------------------------</a>
<a name="ln369"> </a>
<a name="ln370">void SlurSegment::layoutSegment(const QPointF&amp; p1, const QPointF&amp; p2)</a>
<a name="ln371">      {</a>
<a name="ln372">      setPos(QPointF());</a>
<a name="ln373">      ups(Grip::START).p = p1;</a>
<a name="ln374">      ups(Grip::END).p   = p2;</a>
<a name="ln375">      _extraHeight = 0.0;</a>
<a name="ln376">      computeBezier();</a>
<a name="ln377"> </a>
<a name="ln378">      if (autoplace() &amp;&amp; system()) {</a>
<a name="ln379">            bool up = slur()-&gt;up();</a>
<a name="ln380">            Segment* ls = system()-&gt;lastMeasure()-&gt;last();</a>
<a name="ln381">            Segment* fs = system()-&gt;firstMeasure()-&gt;first();</a>
<a name="ln382">            Segment* ss = slur()-&gt;startSegment();</a>
<a name="ln383">            Segment* es = slur()-&gt;endSegment();</a>
<a name="ln384">            QPointF pp1 = ups(Grip::START).p;</a>
<a name="ln385">            QPointF pp2 = ups(Grip::END).p;</a>
<a name="ln386">            qreal slurMaxMove = spatium();</a>
<a name="ln387">            bool intersection = false;</a>
<a name="ln388">            qreal gdist = 0.0;</a>
<a name="ln389">            qreal minDistance = score()-&gt;styleS(Sid::SlurMinDistance).val() * spatium();</a>
<a name="ln390">            for (int tries = 1; true; ++tries) {</a>
<a name="ln391">                  for (Segment* s = fs; s &amp;&amp; s != ls; s = s-&gt;next1()) {</a>
<a name="ln392">                        if (!s-&gt;enabled())</a>
<a name="ln393">                              continue;</a>
<a name="ln394">                        // skip start and end segments on assumption start and end points were placed well already</a>
<a name="ln395">                        // this avoids overcorrection on collision with own ledger lines and accidentals</a>
<a name="ln396">                        // it also avoids issues where slur appears to be attached to a note in a different voice</a>
<a name="ln397">                        if (s == ss || s == es)</a>
<a name="ln398">                              continue;</a>
<a name="ln399">                        // allow slurs to cross barlines</a>
<a name="ln400">                        if (s-&gt;segmentType() &amp; SegmentType::BarLineType)</a>
<a name="ln401">                              continue;</a>
<a name="ln402">                        qreal x1 = s-&gt;x() + s-&gt;measure()-&gt;x();</a>
<a name="ln403">                        qreal x2 = x1 + s-&gt;width();</a>
<a name="ln404">                        if (pp1.x() &gt; x2)</a>
<a name="ln405">                              continue;</a>
<a name="ln406">                        if (pp2.x() &lt; x1)</a>
<a name="ln407">                              break;</a>
<a name="ln408">                        const Shape&amp; segShape = s-&gt;staffShape(staffIdx()).translated(s-&gt;pos() + s-&gt;measure()-&gt;pos());</a>
<a name="ln409">                        if (!intersection)</a>
<a name="ln410">                              intersection = segShape.intersects(_shape);</a>
<a name="ln411">                        if (up) {</a>
<a name="ln412">                              //QPointF pt = QPointF(s-&gt;x() + s-&gt;measure()-&gt;x(), s-&gt;staffShape(staffIdx()).top() + s-&gt;y() + s-&gt;measure()-&gt;y());</a>
<a name="ln413">                              qreal dist = _shape.minVerticalDistance(segShape);</a>
<a name="ln414">                              if (dist &gt; 0.0)</a>
<a name="ln415">                                    gdist = qMax(gdist, dist);</a>
<a name="ln416">                              }</a>
<a name="ln417">                        else {</a>
<a name="ln418">                              //QPointF pt = QPointF(s-&gt;x() + s-&gt;measure()-&gt;x(), s-&gt;staffShape(staffIdx()).bottom() + s-&gt;y() + s-&gt;measure()-&gt;y());</a>
<a name="ln419">                              qreal dist = segShape.minVerticalDistance(_shape);</a>
<a name="ln420">                              if (dist &gt; 0.0)</a>
<a name="ln421">                                    gdist = qMax(gdist, dist);</a>
<a name="ln422">                              }</a>
<a name="ln423">                        }</a>
<a name="ln424">                  if (!intersection || gdist &lt;= slurMaxMove || tries &gt;= 2)</a>
<a name="ln425">                        break;</a>
<a name="ln426">                  // slur would be moved too far</a>
<a name="ln427">                  // try again with a steeper curve</a>
<a name="ln428">                  _extraHeight += gdist;</a>
<a name="ln429">                  computeBezier();</a>
<a name="ln430">                  intersection = false;</a>
<a name="ln431">                  gdist = 0.0;</a>
<a name="ln432">                  }</a>
<a name="ln433">            if (intersection &amp;&amp; gdist &gt; 0.0) {</a>
<a name="ln434">                  qreal min = minDistance + gdist;</a>
<a name="ln435">                  rypos() += up ? -min : min;</a>
<a name="ln436">                  }</a>
<a name="ln437">            }</a>
<a name="ln438">      setbbox(path.boundingRect());</a>
<a name="ln439">      }</a>
<a name="ln440"> </a>
<a name="ln441">//---------------------------------------------------------</a>
<a name="ln442">//   isEdited</a>
<a name="ln443">//---------------------------------------------------------</a>
<a name="ln444"> </a>
<a name="ln445">bool SlurSegment::isEdited() const</a>
<a name="ln446">      {</a>
<a name="ln447">      for (int i = 0; i &lt; int(Grip::GRIPS); ++i) {</a>
<a name="ln448">            if (!_ups[i].off.isNull())</a>
<a name="ln449">                  return true;</a>
<a name="ln450">            }</a>
<a name="ln451">      return false;</a>
<a name="ln452">      }</a>
<a name="ln453"> </a>
<a name="ln454">//---------------------------------------------------------</a>
<a name="ln455">//   fixArticulations</a>
<a name="ln456">//---------------------------------------------------------</a>
<a name="ln457"> </a>
<a name="ln458">static qreal fixArticulations(qreal yo, Chord* c, qreal _up, bool stemSide = false)</a>
<a name="ln459">      {</a>
<a name="ln460">      //</a>
<a name="ln461">      // handle special case of tenuto and staccato</a>
<a name="ln462">      // yo = current offset of slur from chord position</a>
<a name="ln463">      // return unchanged position, or position of outmost &quot;close&quot; articulation</a>
<a name="ln464">      //</a>
<a name="ln465">#if 1</a>
<a name="ln466">      for (Articulation* a : c-&gt;articulations()) {</a>
<a name="ln467">            if (!a-&gt;layoutCloseToNote() || !a-&gt;addToSkyline())</a>
<a name="ln468">                  continue;</a>
<a name="ln469">            // skip if articulation on stem side but slur is not or vice versa</a>
<a name="ln470">            if ((a-&gt;up() == c-&gt;up()) != stemSide)</a>
<a name="ln471">                  continue;</a>
<a name="ln472">            if (a-&gt;up())</a>
<a name="ln473">                  yo = qMin(yo, a-&gt;y() + (a-&gt;height() + c-&gt;score()-&gt;spatium() * .3) * _up);</a>
<a name="ln474">            else</a>
<a name="ln475">                  yo = qMax(yo, a-&gt;y() + (a-&gt;height() + c-&gt;score()-&gt;spatium() * .3) * _up);</a>
<a name="ln476">            }</a>
<a name="ln477">      return yo;</a>
<a name="ln478">#else</a>
<a name="ln479">      const QVector&lt;Articulation*&gt;&amp; al = c-&gt;articulations();</a>
<a name="ln480">      if (al.size() &gt;= 2) {</a>
<a name="ln481">            Articulation* a = al.at(1);</a>
<a name="ln482">            if (a-&gt;up() == c-&gt;up() &amp;&amp; !stemSide)</a>
<a name="ln483">                  return yo;</a>
<a name="ln484">            else if (a-&gt;layoutCloseToNote())</a>
<a name="ln485">                  return a-&gt;y() + (a-&gt;height() + c-&gt;score()-&gt;spatium() * .3) * _up;</a>
<a name="ln486">            }</a>
<a name="ln487">      else if (al.size() &gt;= 1) {</a>
<a name="ln488">            Articulation* a = al.at(0);</a>
<a name="ln489">            if (a-&gt;up() == c-&gt;up() &amp;&amp; !stemSide)</a>
<a name="ln490">                  return yo;</a>
<a name="ln491">            else if (a-&gt;layoutCloseToNote())</a>
<a name="ln492">                  return a-&gt;y() + (a-&gt;height() + c-&gt;score()-&gt;spatium() * .3) * _up;</a>
<a name="ln493">            }</a>
<a name="ln494">      return yo;</a>
<a name="ln495">#endif</a>
<a name="ln496">      }</a>
<a name="ln497"> </a>
<a name="ln498">//---------------------------------------------------------</a>
<a name="ln499">//   slurPos</a>
<a name="ln500">//    Calculate position of start- and endpoint of slur</a>
<a name="ln501">//    relative to System() position.</a>
<a name="ln502">//---------------------------------------------------------</a>
<a name="ln503"> </a>
<a name="ln504">void Slur::slurPosChord(SlurPos* sp)</a>
<a name="ln505">      {</a>
<a name="ln506">      Chord* stChord;</a>
<a name="ln507">      Chord* enChord ;</a>
<a name="ln508">      if (startChord()-&gt;isGraceAfter()){     // grace notes after, coming in reverse order</a>
<a name="ln509">            stChord = endChord();</a>
<a name="ln510">            enChord = startChord();</a>
<a name="ln511">            _up = false;</a>
<a name="ln512">            }</a>
<a name="ln513">      else {</a>
<a name="ln514">            stChord = startChord();</a>
<a name="ln515">            enChord = endChord();</a>
<a name="ln516">            }</a>
<a name="ln517">      Note* _startNote = stChord-&gt;downNote();</a>
<a name="ln518">      Note* _endNote   = enChord-&gt;downNote();</a>
<a name="ln519">      qreal hw         = _startNote-&gt;bboxRightPos();</a>
<a name="ln520">      qreal __up       = _up ? -1.0 : 1.0;</a>
<a name="ln521">      qreal _spatium = spatium();</a>
<a name="ln522"> </a>
<a name="ln523">      Measure* measure = endChord()-&gt;measure();</a>
<a name="ln524">      sp-&gt;system1 = measure-&gt;system();</a>
<a name="ln525">      if (!sp-&gt;system1) {             // DEBUG</a>
<a name="ln526">            qDebug(&quot;no system1&quot;);</a>
<a name="ln527">            return;</a>
<a name="ln528">            }</a>
<a name="ln529">      Q_ASSERT(sp-&gt;system1);</a>
<a name="ln530">      sp-&gt;system2 = sp-&gt;system1;</a>
<a name="ln531">      QPointF pp(sp-&gt;system1-&gt;pagePos());</a>
<a name="ln532"> </a>
<a name="ln533">      qreal xo;</a>
<a name="ln534">      qreal yo;</a>
<a name="ln535"> </a>
<a name="ln536">      //------p1</a>
<a name="ln537">      if (_up) {</a>
<a name="ln538">            xo = _startNote-&gt;x() + hw * 1.12;</a>
<a name="ln539">            yo = _startNote-&gt;pos().y() + hw * .3 * __up;</a>
<a name="ln540">            }</a>
<a name="ln541">      else {</a>
<a name="ln542">            xo = _startNote-&gt;x() + hw * 0.4;</a>
<a name="ln543">            yo = _startNote-&gt;pos().y() + _spatium * .75 * __up;</a>
<a name="ln544">            }</a>
<a name="ln545">      sp-&gt;p1 = stChord-&gt;pagePos() - pp + QPointF(xo, yo);</a>
<a name="ln546"> </a>
<a name="ln547">      //------p2</a>
<a name="ln548">      if ((enChord-&gt;notes().size() &gt; 1) || (enChord-&gt;stem() &amp;&amp; !enChord-&gt;up() &amp;&amp; !_up)) {</a>
<a name="ln549">            xo = _endNote-&gt;x() - hw * 0.12;</a>
<a name="ln550">            yo = _endNote-&gt;pos().y() + hw * .3 * __up;</a>
<a name="ln551">            }</a>
<a name="ln552">      else {</a>
<a name="ln553">            xo = _endNote-&gt;x() + hw * 0.15;</a>
<a name="ln554">            yo = _endNote-&gt;pos().y() + _spatium * .75 * __up;</a>
<a name="ln555">            }</a>
<a name="ln556">      sp-&gt;p2 = enChord-&gt;pagePos() - pp + QPointF(xo, yo);</a>
<a name="ln557">      }</a>
<a name="ln558"> </a>
<a name="ln559">//---------------------------------------------------------</a>
<a name="ln560">//   slurPos</a>
<a name="ln561">//    calculate position of start- and endpoint of slur</a>
<a name="ln562">//    relative to System() position</a>
<a name="ln563">//---------------------------------------------------------</a>
<a name="ln564"> </a>
<a name="ln565">void Slur::slurPos(SlurPos* sp)</a>
<a name="ln566">      {</a>
<a name="ln567">      qreal _spatium = spatium();</a>
<a name="ln568"> </a>
<a name="ln569">      if (endCR() == 0) {</a>
<a name="ln570">            sp-&gt;p1 = startCR()-&gt;pagePos();</a>
<a name="ln571">            sp-&gt;p1.rx() += startCR()-&gt;width();</a>
<a name="ln572">            sp-&gt;p2 = sp-&gt;p1;</a>
<a name="ln573">            sp-&gt;p2.rx() += 5 * _spatium;</a>
<a name="ln574">            sp-&gt;system1 = startCR()-&gt;measure()-&gt;system();</a>
<a name="ln575">            sp-&gt;system2 = sp-&gt;system1;</a>
<a name="ln576">            return;</a>
<a name="ln577">            }</a>
<a name="ln578"> </a>
<a name="ln579">      bool useTablature  = staff() &amp;&amp; staff()-&gt;isTabStaff(endCR()-&gt;tick());</a>
<a name="ln580">      bool staffHasStems = true;     // assume staff uses stems</a>
<a name="ln581">      const StaffType* stt = 0;</a>
<a name="ln582">      if (useTablature) {</a>
<a name="ln583">            stt           = staff()-&gt;staffType(tick());</a>
<a name="ln584">            staffHasStems = stt-&gt;stemThrough();   // if tab with stems beside, stems do not count for slur pos</a>
<a name="ln585">            }</a>
<a name="ln586"> </a>
<a name="ln587">      // start and end cr, chord, and note</a>
<a name="ln588">      ChordRest* scr = startCR();</a>
<a name="ln589">      ChordRest* ecr = endCR();</a>
<a name="ln590">      Chord* sc      = 0;</a>
<a name="ln591">      Note* note1    = 0;</a>
<a name="ln592">      if (scr-&gt;isChord()) {</a>
<a name="ln593">            sc    = toChord(scr);</a>
<a name="ln594">            note1 = _up ? sc-&gt;upNote() : sc-&gt;downNote();</a>
<a name="ln595">            }</a>
<a name="ln596">      Chord* ec = 0;</a>
<a name="ln597">      Note* note2 = 0;</a>
<a name="ln598">      if (ecr-&gt;isChord()) {</a>
<a name="ln599">            ec   = toChord(ecr);</a>
<a name="ln600">            note2 = _up ? ec-&gt;upNote() : ec-&gt;downNote();</a>
<a name="ln601">            }</a>
<a name="ln602"> </a>
<a name="ln603">      sp-&gt;system1 = scr-&gt;measure()-&gt;system();</a>
<a name="ln604">      sp-&gt;system2 = ecr-&gt;measure()-&gt;system();</a>
<a name="ln605"> </a>
<a name="ln606">      if (sp-&gt;system1 == 0) {</a>
<a name="ln607">            qDebug(&quot;no system1&quot;);</a>
<a name="ln608">            return;</a>
<a name="ln609">            }</a>
<a name="ln610"> </a>
<a name="ln611">      sp-&gt;p1 = scr-&gt;pos() + scr-&gt;segment()-&gt;pos() + scr-&gt;measure()-&gt;pos();</a>
<a name="ln612">      sp-&gt;p2 = ecr-&gt;pos() + ecr-&gt;segment()-&gt;pos() + ecr-&gt;measure()-&gt;pos();</a>
<a name="ln613"> </a>
<a name="ln614">      // adjust for cross-staff</a>
<a name="ln615">      if (scr-&gt;vStaffIdx() != vStaffIdx() &amp;&amp; sp-&gt;system1) {</a>
<a name="ln616">            qreal diff = sp-&gt;system1-&gt;staff(scr-&gt;vStaffIdx())-&gt;y() - sp-&gt;system1-&gt;staff(vStaffIdx())-&gt;y();</a>
<a name="ln617">            sp-&gt;p1.ry() += diff;</a>
<a name="ln618">            }</a>
<a name="ln619">      if (ecr-&gt;vStaffIdx() != vStaffIdx() &amp;&amp; sp-&gt;system2) {</a>
<a name="ln620">            qreal diff = sp-&gt;system2-&gt;staff(ecr-&gt;vStaffIdx())-&gt;y() - sp-&gt;system2-&gt;staff(vStaffIdx())-&gt;y();</a>
<a name="ln621">            sp-&gt;p2.ry() += diff;</a>
<a name="ln622">            }</a>
<a name="ln623"> </a>
<a name="ln624">      // account for centering or other adjustments (other than mirroring)</a>
<a name="ln625">      if (note1 &amp;&amp; !note1-&gt;mirror())</a>
<a name="ln626">            sp-&gt;p1.rx() += note1-&gt;x();</a>
<a name="ln627">      if (note2 &amp;&amp; !note2-&gt;mirror())</a>
<a name="ln628">            sp-&gt;p2.rx() += note2-&gt;x();</a>
<a name="ln629"> </a>
<a name="ln630">      qreal xo, yo;</a>
<a name="ln631"> </a>
<a name="ln632">      Stem* stem1 = sc &amp;&amp; staffHasStems ? sc-&gt;stem() : 0;</a>
<a name="ln633">      Stem* stem2 = ec &amp;&amp; staffHasStems ? ec-&gt;stem() : 0;</a>
<a name="ln634"> </a>
<a name="ln635">      enum class SlurAnchor : char {</a>
<a name="ln636">            NONE, STEM</a>
<a name="ln637">            };</a>
<a name="ln638">      SlurAnchor sa1 = SlurAnchor::NONE;</a>
<a name="ln639">      SlurAnchor sa2 = SlurAnchor::NONE;</a>
<a name="ln640">      // if slur is 'embedded' between either stem or both (as it might happen with voices)</a>
<a name="ln641">      // link corresponding slur end to stem position</a>
<a name="ln642">      if ((scr-&gt;up() == ecr-&gt;up()) &amp;&amp; !scr-&gt;beam() &amp;&amp; !ecr-&gt;beam() &amp;&amp; (_up == scr-&gt;up())) {</a>
<a name="ln643">            // both chords are facing same direction and slur is also in same direction</a>
<a name="ln644">            // and no beams</a>
<a name="ln645">            if (stem1)</a>
<a name="ln646">                  sa1 = SlurAnchor::STEM;</a>
<a name="ln647">            if (stem2)</a>
<a name="ln648">                  sa2 = SlurAnchor::STEM;</a>
<a name="ln649">            }</a>
<a name="ln650">      // also link start of slur to stem if start chord &amp; slur are in same direction and there is a hook</a>
<a name="ln651">      if (scr-&gt;up() == _up &amp;&amp; stem1 &amp;&amp; sc-&gt;hook()) {</a>
<a name="ln652">            sa1 = SlurAnchor::STEM;</a>
<a name="ln653">            // if end chord is in same direction, link end of slur to stem too</a>
<a name="ln654">            if (ecr-&gt;up() == scr-&gt;up() &amp;&amp; stem2 &amp;&amp; (!ecr-&gt;beam() || !ecr-&gt;beam()-&gt;cross()))</a>
<a name="ln655">                  sa2 = SlurAnchor::STEM;</a>
<a name="ln656">            }</a>
<a name="ln657"> </a>
<a name="ln658">      qreal __up = _up ? -1.0 : 1.0;</a>
<a name="ln659">      qreal hw1 = note1 ? note1-&gt;tabHeadWidth(stt) : scr-&gt;width();      // if stt == 0, tabHeadWidth()</a>
<a name="ln660">      qreal hw2 = note2 ? note2-&gt;tabHeadWidth(stt) : ecr-&gt;width();      // defaults to headWidth()</a>
<a name="ln661">      QPointF pt;</a>
<a name="ln662">      switch (sa1) {</a>
<a name="ln663">            case SlurAnchor::STEM:        //sc can't be null</a>
<a name="ln664">                  {</a>
<a name="ln665">                  // place slur starting point at stem end point</a>
<a name="ln666">                  pt = sc-&gt;stemPos() - sc-&gt;pagePos() + sc-&gt;stem()-&gt;p2();</a>
<a name="ln667">                  if (useTablature)                   // in tabs, stems are centred on note:</a>
<a name="ln668">                        pt.rx() = hw1 * 0.5 + (note1 ? note1-&gt;bboxXShift() : 0.0);          // skip half notehead to touch stem, anatoly-os: incorrect. half notehead width is not always the stem position</a>
<a name="ln669">                  // clear the stem (x)</a>
<a name="ln670">                  // allow slight overlap (y) as per Gould</a>
<a name="ln671">                  // don't allow overlap with hook if not disabling the autoplace checks against start/end segments in SlurSegment::layoutSegment()</a>
<a name="ln672">                  qreal yadj = -0.25;     // sc-&gt;hook() ? 0.25 : -0.25;</a>
<a name="ln673">                  yadj *= _spatium * __up;</a>
<a name="ln674">                  pt += QPointF(0.35 * _spatium, yadj);</a>
<a name="ln675">                  // account for articulations</a>
<a name="ln676">                  pt.ry() = fixArticulations(pt.y(), sc, __up, true);</a>
<a name="ln677">                  sp-&gt;p1 += pt;</a>
<a name="ln678">                  }</a>
<a name="ln679">                  break;</a>
<a name="ln680">            case SlurAnchor::NONE:</a>
<a name="ln681">                  break;</a>
<a name="ln682">            }</a>
<a name="ln683">      switch (sa2) {</a>
<a name="ln684">            case SlurAnchor::STEM:        //ec can't be null</a>
<a name="ln685">                  {</a>
<a name="ln686">                  pt = ec-&gt;stemPos() - ec-&gt;pagePos() + ec-&gt;stem()-&gt;p2();</a>
<a name="ln687">                  if (useTablature)</a>
<a name="ln688">                        pt.rx() = hw2 * 0.5;</a>
<a name="ln689">                  // don't allow overlap with beam</a>
<a name="ln690">                  qreal yadj = ec-&gt;beam() ? 0.75 : -0.25;</a>
<a name="ln691">                  yadj *= _spatium * __up;</a>
<a name="ln692">                  pt += QPointF(-0.35 * _spatium, yadj);</a>
<a name="ln693">                  // account for articulations</a>
<a name="ln694">                  pt.ry() = fixArticulations(pt.y(), ec, __up, true);</a>
<a name="ln695">                  sp-&gt;p2 += pt;</a>
<a name="ln696">                  }</a>
<a name="ln697">                  break;</a>
<a name="ln698">            case SlurAnchor::NONE:</a>
<a name="ln699">                  break;</a>
<a name="ln700">            }</a>
<a name="ln701"> </a>
<a name="ln702">      //</a>
<a name="ln703">      // default position:</a>
<a name="ln704">      //    horizontal: middle of notehead</a>
<a name="ln705">      //    vertical:   _spatium * .4 above/below notehead</a>
<a name="ln706">      //</a>
<a name="ln707">      //------p1</a>
<a name="ln708">      // Compute x0, y0 and stemPos</a>
<a name="ln709">      if (sa1 == SlurAnchor::NONE || sa2 == SlurAnchor::NONE) { // need stemPos if sa2 == SlurAnchor::NONE</a>
<a name="ln710">            bool stemPos = false;   // p1 starts at chord stem side</a>
<a name="ln711"> </a>
<a name="ln712">            // default positions</a>
<a name="ln713">            xo = hw1 * .5 + (note1 ? note1-&gt;bboxXShift() : 0.0);</a>
<a name="ln714">            if (note1)</a>
<a name="ln715">                  yo = note1-&gt;pos().y();</a>
<a name="ln716">            else if (_up)</a>
<a name="ln717">                  yo = scr-&gt;bbox().top();</a>
<a name="ln718">            else</a>
<a name="ln719">                  yo = scr-&gt;bbox().top() + scr-&gt;height();</a>
<a name="ln720">            yo += _spatium * .9 * __up;</a>
<a name="ln721"> </a>
<a name="ln722">            // adjustments for stem and/or beam</a>
<a name="ln723"> </a>
<a name="ln724">            if (stem1) { //sc not null</a>
<a name="ln725">                  Beam* beam1 = sc-&gt;beam();</a>
<a name="ln726">                  if (beam1 &amp;&amp; beam1-&gt;cross()) {</a>
<a name="ln727">                        // TODO: stem direction is not finalized, so we cannot use it here</a>
<a name="ln728">                        yo = fixArticulations(yo, sc, __up, false);</a>
<a name="ln729">                        }</a>
<a name="ln730">                  else if (beam1 &amp;&amp; (beam1-&gt;elements().back() != sc) &amp;&amp; (sc-&gt;up() == _up)) {</a>
<a name="ln731">                        // start chord is beamed but not the last chord of beam group</a>
<a name="ln732">                        // and slur direction is same as start chord (stem side)</a>
<a name="ln733"> </a>
<a name="ln734">                        // in these cases, layout start of slur to stem</a>
<a name="ln735"> </a>
<a name="ln736">                        qreal sh = stem1-&gt;height() + _spatium;</a>
<a name="ln737">                        if (_up)</a>
<a name="ln738">                              yo = sc-&gt;downNote()-&gt;pos().y() - sh;</a>
<a name="ln739">                        else</a>
<a name="ln740">                              yo = sc-&gt;upNote()-&gt;pos().y() + sh;</a>
<a name="ln741">                        xo       = stem1-&gt;pos().x();</a>
<a name="ln742"> </a>
<a name="ln743">                        // account for articulations</a>
<a name="ln744">                        yo = fixArticulations(yo, sc, __up, true);</a>
<a name="ln745"> </a>
<a name="ln746">                        // force end of slur to layout to stem as well,</a>
<a name="ln747">                        // if start and end chords have same stem direction</a>
<a name="ln748">                        stemPos = true;</a>
<a name="ln749">                        }</a>
<a name="ln750">                  else {</a>
<a name="ln751">                        // start chord is not beamed or is last chord of beam group</a>
<a name="ln752">                        // or slur direction is opposite that of start chord</a>
<a name="ln753"> </a>
<a name="ln754">                        // at this point slur is in default position relative to note on slur side</a>
<a name="ln755">                        // but we may need to make further adjustments</a>
<a name="ln756"> </a>
<a name="ln757">                        // if stem and slur are both up</a>
<a name="ln758">                        // we need to clear stem horizontally</a>
<a name="ln759">                        if (sc-&gt;up() &amp;&amp; _up)</a>
<a name="ln760">                              xo = hw1 + _spatium * .3;</a>
<a name="ln761"> </a>
<a name="ln762">                        //</a>
<a name="ln763">                        // handle case: stem up   - stem down</a>
<a name="ln764">                        //              stem down - stem up</a>
<a name="ln765">                        //</a>
<a name="ln766">                        if ((sc-&gt;up() != ecr-&gt;up()) &amp;&amp; (sc-&gt;up() == _up)) {</a>
<a name="ln767">                              // start and end chord have opposite direction</a>
<a name="ln768">                              // and slur direction is same as start chord</a>
<a name="ln769">                              // (so slur starts on stem side)</a>
<a name="ln770"> </a>
<a name="ln771">                              // float the start point along the stem to follow direction of movement</a>
<a name="ln772">                              // see for example Gould p. 111</a>
<a name="ln773"> </a>
<a name="ln774">                              // get position of note on slur side for start &amp; end chords</a>
<a name="ln775">                              Note* n1  = sc-&gt;up() ? sc-&gt;upNote() : sc-&gt;downNote();</a>
<a name="ln776">                              Note* n2  = 0;</a>
<a name="ln777">                              if (ec)</a>
<a name="ln778">                                    n2 = ec-&gt;up() ? ec-&gt;upNote() : ec-&gt;downNote();</a>
<a name="ln779"> </a>
<a name="ln780">                              // differential in note positions</a>
<a name="ln781">                              qreal yd  = (n2 ? n2-&gt;pos().y() : ecr-&gt;pos().y()) - n1-&gt;pos().y();</a>
<a name="ln782">                              yd *= .5;</a>
<a name="ln783"> </a>
<a name="ln784">                              // float along stem according to differential</a>
<a name="ln785">                              qreal sh = stem1-&gt;height();</a>
<a name="ln786">                              if (_up &amp;&amp; yd &lt; 0.0)</a>
<a name="ln787">                                    yo = qMax(yo + yd, sc-&gt;downNote()-&gt;pos().y() - sh - _spatium);</a>
<a name="ln788">                              else if (!_up &amp;&amp; yd &gt; 0.0)</a>
<a name="ln789">                                    yo = qMin(yo + yd, sc-&gt;upNote()-&gt;pos().y() + sh + _spatium);</a>
<a name="ln790"> </a>
<a name="ln791">                              // account for articulations</a>
<a name="ln792">                              yo = fixArticulations(yo, sc, __up, true);</a>
<a name="ln793"> </a>
<a name="ln794">                              // we may wish to force end to align to stem as well,</a>
<a name="ln795">                              // if it is in same direction</a>
<a name="ln796">                              // (but it won't be, so this assignment should have no effect)</a>
<a name="ln797">                              stemPos = true;</a>
<a name="ln798">                              }</a>
<a name="ln799">                        else {</a>
<a name="ln800">                              // avoid articulations</a>
<a name="ln801">                              yo = fixArticulations(yo, sc, __up, sc-&gt;up() == _up);</a>
<a name="ln802">                              }</a>
<a name="ln803">                        }</a>
<a name="ln804">                  }</a>
<a name="ln805">            else if (sc) {</a>
<a name="ln806">                  // avoid articulations</a>
<a name="ln807">                  yo = fixArticulations(yo, sc, __up, sc-&gt;up() == _up);</a>
<a name="ln808">                  }</a>
<a name="ln809"> </a>
<a name="ln810">            if (sa1 == SlurAnchor::NONE)</a>
<a name="ln811">                  sp-&gt;p1 += QPointF(xo, yo);</a>
<a name="ln812"> </a>
<a name="ln813">            //------p2</a>
<a name="ln814">            if (sa2 == SlurAnchor::NONE) {</a>
<a name="ln815"> </a>
<a name="ln816">                  // default positions</a>
<a name="ln817">                  xo = hw2 * .5 + (note2 ? note2-&gt;bboxXShift() : 0.0);</a>
<a name="ln818">                  if (note2)</a>
<a name="ln819">                        yo = note2-&gt;pos().y();</a>
<a name="ln820">                  else if (_up)</a>
<a name="ln821">                        yo = endCR()-&gt;bbox().top();</a>
<a name="ln822">                  else</a>
<a name="ln823">                        yo = endCR()-&gt;bbox().top() + endCR()-&gt;height();</a>
<a name="ln824">                  yo += _spatium * .9 * __up;</a>
<a name="ln825"> </a>
<a name="ln826">                  // adjustments for stem and/or beam</a>
<a name="ln827"> </a>
<a name="ln828">                  if (stem2) { //ec can't be null</a>
<a name="ln829">                        Beam* beam2 = ec-&gt;beam();</a>
<a name="ln830">                        if (beam2 &amp;&amp; beam2-&gt;cross()) {</a>
<a name="ln831">                              // TODO: stem direction is not finalized, so we cannot use it here</a>
<a name="ln832">                              yo = fixArticulations(yo, ec, __up, false);</a>
<a name="ln833">                              }</a>
<a name="ln834">                        else if ((stemPos &amp;&amp; (scr-&gt;up() == ec-&gt;up()))</a>
<a name="ln835">                           || (beam2</a>
<a name="ln836">                             &amp;&amp; (!beam2-&gt;elements().empty())</a>
<a name="ln837">                             &amp;&amp; (beam2-&gt;elements().front() != ec)</a>
<a name="ln838">                             &amp;&amp; (ec-&gt;up() == _up)</a>
<a name="ln839">                             &amp;&amp; sc &amp;&amp; (sc-&gt;noteType() == NoteType::NORMAL)</a>
<a name="ln840">                             )</a>
<a name="ln841">                              ) {</a>
<a name="ln842"> </a>
<a name="ln843">                              // slur start was laid out to stem and start and end have same direction</a>
<a name="ln844">                              // OR</a>
<a name="ln845">                              // end chord is beamed but not the first chord of beam group</a>
<a name="ln846">                              // and slur direction is same as end chord (stem side)</a>
<a name="ln847">                              // and start chordrest is not a grace chord</a>
<a name="ln848"> </a>
<a name="ln849">                              // in these cases, layout end of slur to stem</a>
<a name="ln850"> </a>
<a name="ln851">                              qreal sh = stem2-&gt;height() + _spatium;</a>
<a name="ln852">                              if (_up)</a>
<a name="ln853">                                    yo = ec-&gt;downNote()-&gt;pos().y() - sh;</a>
<a name="ln854">                              else</a>
<a name="ln855">                                    yo = ec-&gt;upNote()-&gt;pos().y() + sh;</a>
<a name="ln856">                              xo = stem2-&gt;pos().x();</a>
<a name="ln857"> </a>
<a name="ln858">                              // account for articulations</a>
<a name="ln859">                              yo = fixArticulations(yo, ec, __up, true);</a>
<a name="ln860">                              }</a>
<a name="ln861">                        else</a>
<a name="ln862">                              {</a>
<a name="ln863">                              // slur was not aligned to stem or start and end have different direction</a>
<a name="ln864">                              // AND</a>
<a name="ln865">                              // end chord is not beamed or is first chord of beam group</a>
<a name="ln866">                              // or slur direction is opposite that of end chord</a>
<a name="ln867"> </a>
<a name="ln868">                              // if stem and slur are both down,</a>
<a name="ln869">                              // we need to clear stem horizontally</a>
<a name="ln870">                              if (!ec-&gt;up() &amp;&amp; !_up)</a>
<a name="ln871">                                    xo = -_spatium * .3 + note2-&gt;x();</a>
<a name="ln872"> </a>
<a name="ln873">                              //</a>
<a name="ln874">                              // handle case: stem up   - stem down</a>
<a name="ln875">                              //              stem down - stem up</a>
<a name="ln876">                              //</a>
<a name="ln877">                              if ((scr-&gt;up() != ec-&gt;up()) &amp;&amp; (ec-&gt;up() == _up)) {</a>
<a name="ln878">                                    // start and end chord have opposite direction</a>
<a name="ln879">                                    // and slur direction is same as end chord</a>
<a name="ln880">                                    // (so slur end on stem side)</a>
<a name="ln881"> </a>
<a name="ln882">                                    // float the end point along the stem to follow direction of movement</a>
<a name="ln883">                                    // see for example Gould p. 111</a>
<a name="ln884"> </a>
<a name="ln885">                                    Note* n1 = 0;</a>
<a name="ln886">                                    if (sc)</a>
<a name="ln887">                                          n1 = sc-&gt;up() ? sc-&gt;upNote() : sc-&gt;downNote();</a>
<a name="ln888">                                    Note* n2 = ec-&gt;up() ? ec-&gt;upNote() : ec-&gt;downNote();</a>
<a name="ln889"> </a>
<a name="ln890">                                    qreal yd = n2-&gt;pos().y() - (n1 ? n1-&gt;pos().y() : startCR()-&gt;pos().y());</a>
<a name="ln891">                                    yd *= .5;</a>
<a name="ln892"> </a>
<a name="ln893">                                    qreal mh = stem2-&gt;height();</a>
<a name="ln894">                                    if (_up &amp;&amp; yd &gt; 0.0)</a>
<a name="ln895">                                          yo = qMax(yo - yd, ec-&gt;downNote()-&gt;pos().y() - mh - _spatium);</a>
<a name="ln896">                                    else if (!_up &amp;&amp; yd &lt; 0.0)</a>
<a name="ln897">                                          yo = qMin(yo - yd, ec-&gt;upNote()-&gt;pos().y() + mh + _spatium);</a>
<a name="ln898"> </a>
<a name="ln899">                                    // account for articulations</a>
<a name="ln900">                                    yo = fixArticulations(yo, ec, __up, true);</a>
<a name="ln901">                                    }</a>
<a name="ln902">                              else {</a>
<a name="ln903">                                    // avoid articulations</a>
<a name="ln904">                                    yo = fixArticulations(yo, ec, __up, ec-&gt;up() == _up);</a>
<a name="ln905">                                    }</a>
<a name="ln906"> </a>
<a name="ln907">                              }</a>
<a name="ln908">                        }</a>
<a name="ln909">                  else if (ec) {</a>
<a name="ln910">                        // avoid articulations</a>
<a name="ln911">                        yo = fixArticulations(yo, ec, __up, ec-&gt;up() == _up);</a>
<a name="ln912">                        }</a>
<a name="ln913"> </a>
<a name="ln914">                  sp-&gt;p2 += QPointF(xo, yo);</a>
<a name="ln915">                  }</a>
<a name="ln916">            }</a>
<a name="ln917">      }</a>
<a name="ln918"> </a>
<a name="ln919">//---------------------------------------------------------</a>
<a name="ln920">//   Slur</a>
<a name="ln921">//---------------------------------------------------------</a>
<a name="ln922"> </a>
<a name="ln923">Slur::Slur(Score* s)</a>
<a name="ln924">   : SlurTie(s)</a>
<a name="ln925">      {</a>
<a name="ln926">      setAnchor(Anchor::CHORD);</a>
<a name="ln927">      }</a>
<a name="ln928"> </a>
<a name="ln929">//---------------------------------------------------------</a>
<a name="ln930">//   write</a>
<a name="ln931">//---------------------------------------------------------</a>
<a name="ln932"> </a>
<a name="ln933">void Slur::write(XmlWriter&amp; xml) const</a>
<a name="ln934">      {</a>
<a name="ln935">      if (broken()) {</a>
<a name="ln936">            qDebug(&quot;broken slur not written&quot;);</a>
<a name="ln937">            return;</a>
<a name="ln938">            }</a>
<a name="ln939">      if (!xml.canWrite(this))</a>
<a name="ln940">            return;</a>
<a name="ln941">      xml.stag(this);</a>
<a name="ln942">      SlurTie::writeProperties(xml);</a>
<a name="ln943">      xml.etag();</a>
<a name="ln944">      }</a>
<a name="ln945"> </a>
<a name="ln946">//---------------------------------------------------------</a>
<a name="ln947">//   chordsHaveTie</a>
<a name="ln948">//---------------------------------------------------------</a>
<a name="ln949"> </a>
<a name="ln950">static bool chordsHaveTie(Chord* c1, Chord* c2)</a>
<a name="ln951">      {</a>
<a name="ln952">      size_t n = c1-&gt;notes().size();</a>
<a name="ln953">      for (size_t i1 = 0; i1 &lt; n; ++i1) {</a>
<a name="ln954">            Note* n1 = c1-&gt;notes().at(i1);</a>
<a name="ln955">            size_t n2 = c2-&gt;notes().size();</a>
<a name="ln956">            for (size_t i2 = 0; i2 &lt; n2; ++i2) {</a>
<a name="ln957">                  Note* n3 = c2-&gt;notes().at(i2);</a>
<a name="ln958">                  if (n1-&gt;tieFor() &amp;&amp; n1-&gt;tieFor() == n3-&gt;tieBack())</a>
<a name="ln959">                        return true;</a>
<a name="ln960">                  }</a>
<a name="ln961">            }</a>
<a name="ln962">      return false;</a>
<a name="ln963">      }</a>
<a name="ln964"> </a>
<a name="ln965">//---------------------------------------------------------</a>
<a name="ln966">//   directionMixture</a>
<a name="ln967">//---------------------------------------------------------</a>
<a name="ln968"> </a>
<a name="ln969">static bool isDirectionMixture(Chord* c1, Chord* c2)</a>
<a name="ln970">      {</a>
<a name="ln971">      bool up = c1-&gt;up();</a>
<a name="ln972">      for (Segment* seg = c1-&gt;segment(); seg; seg = seg-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln973">            Element* e = seg-&gt;element(c1-&gt;track());</a>
<a name="ln974">            if (!e || !e-&gt;isChord())</a>
<a name="ln975">                  continue;</a>
<a name="ln976">            Chord* c = toChord(e);</a>
<a name="ln977">            if (c-&gt;up() != up)</a>
<a name="ln978">                  return true;</a>
<a name="ln979">            if (seg == c2-&gt;segment())</a>
<a name="ln980">                  break;</a>
<a name="ln981">            }</a>
<a name="ln982">      return false;</a>
<a name="ln983">      }</a>
<a name="ln984"> </a>
<a name="ln985">//---------------------------------------------------------</a>
<a name="ln986">//   layoutSystem</a>
<a name="ln987">//    layout slurSegment for system</a>
<a name="ln988">//---------------------------------------------------------</a>
<a name="ln989"> </a>
<a name="ln990">SpannerSegment* Slur::layoutSystem(System* system)</a>
<a name="ln991">      {</a>
<a name="ln992">      Fraction stick = system-&gt;firstMeasure()-&gt;tick();</a>
<a name="ln993">      Fraction etick = system-&gt;lastMeasure()-&gt;endTick();</a>
<a name="ln994"> </a>
<a name="ln995">      SlurSegment* slurSegment = toSlurSegment(getNextLayoutSystemSegment(system, [this]() { return new SlurSegment(score()); }));</a>
<a name="ln996"> </a>
<a name="ln997">      SpannerSegmentType sst;</a>
<a name="ln998">      if (tick() &gt;= stick) {</a>
<a name="ln999">            //</a>
<a name="ln1000">            // this is the first call to layoutSystem,</a>
<a name="ln1001">            // processing the first line segment</a>
<a name="ln1002">            //</a>
<a name="ln1003">            if (track2() == -1)</a>
<a name="ln1004">                  setTrack2(track());</a>
<a name="ln1005">            if (startCR() == 0 || startCR()-&gt;measure() == 0) {</a>
<a name="ln1006">                  qDebug(&quot;Slur::layout(): track %d-%d  %p - %p tick %d-%d null start anchor&quot;,</a>
<a name="ln1007">                     track(), track2(), startCR(), endCR(), tick().ticks(), tick2().ticks());</a>
<a name="ln1008">                  return slurSegment;</a>
<a name="ln1009">                  }</a>
<a name="ln1010">            if (endCR() == 0) {     // sanity check</a>
<a name="ln1011">                  setEndElement(startCR());</a>
<a name="ln1012">                  setTick2(tick());</a>
<a name="ln1013">                  }</a>
<a name="ln1014">            switch (_slurDirection) {</a>
<a name="ln1015">                  case Direction::UP:</a>
<a name="ln1016">                        _up = true;</a>
<a name="ln1017">                        break;</a>
<a name="ln1018">                  case Direction::DOWN:</a>
<a name="ln1019">                        _up = false;</a>
<a name="ln1020">                        break;</a>
<a name="ln1021">                  case Direction::AUTO:</a>
<a name="ln1022">                        {</a>
<a name="ln1023">                        //</a>
<a name="ln1024">                        // assumption:</a>
<a name="ln1025">                        // slurs have only chords or rests as start/end elements</a>
<a name="ln1026">                        //</a>
<a name="ln1027">                        if (startCR() == 0 || endCR() == 0) {</a>
<a name="ln1028">                              _up = true;</a>
<a name="ln1029">                              break;</a>
<a name="ln1030">                              }</a>
<a name="ln1031">                        Chord* c1 = startCR()-&gt;isChord() ? toChord(startCR()) : 0;</a>
<a name="ln1032">                        Chord* c2 = endCR()-&gt;isChord()   ? toChord(endCR())   : 0;</a>
<a name="ln1033"> </a>
<a name="ln1034">                        if (c1 &amp;&amp; c1-&gt;beam() &amp;&amp; c1-&gt;beam()-&gt;cross()) {</a>
<a name="ln1035">                              // TODO: stem direction is not finalized, so we cannot use it here</a>
<a name="ln1036">                              _up = true;</a>
<a name="ln1037">                              break;</a>
<a name="ln1038">                              }</a>
<a name="ln1039"> </a>
<a name="ln1040">                        _up = !(startCR()-&gt;up());</a>
<a name="ln1041"> </a>
<a name="ln1042">                        Measure* m1 = startCR()-&gt;measure();</a>
<a name="ln1043">                        if ((endCR()-&gt;tick() - startCR()-&gt;tick()) &gt; m1-&gt;ticks()) // long slurs are always above</a>
<a name="ln1044">                              _up = true;</a>
<a name="ln1045">                        else</a>
<a name="ln1046">                              _up = !startCR()-&gt;up();</a>
<a name="ln1047"> </a>
<a name="ln1048">                        if (c1 &amp;&amp; c2 &amp;&amp; isDirectionMixture(c1, c2) &amp;&amp; !c1-&gt;isGrace()) {</a>
<a name="ln1049">                              // slurs go above if start and end note have different stem directions,</a>
<a name="ln1050">                              // but grace notes are exceptions</a>
<a name="ln1051">                              _up = true;</a>
<a name="ln1052">                              }</a>
<a name="ln1053">                        else if (m1-&gt;hasVoices(startCR()-&gt;staffIdx()) &amp;&amp; c1 &amp;&amp; !c1-&gt;isGrace()) {</a>
<a name="ln1054">                              // in polyphonic passage, slurs go on the stem side</a>
<a name="ln1055">                              _up = startCR()-&gt;up();</a>
<a name="ln1056">                              }</a>
<a name="ln1057">                        else if (c1 &amp;&amp; c2 &amp;&amp; chordsHaveTie(c1, c2)) {</a>
<a name="ln1058">                              // could confuse slur with tie, put slur on stem side</a>
<a name="ln1059">                              _up = startCR()-&gt;up();</a>
<a name="ln1060">                              }</a>
<a name="ln1061">                        }</a>
<a name="ln1062">                        break;</a>
<a name="ln1063">                  }</a>
<a name="ln1064">            sst = tick2() &lt; etick ? SpannerSegmentType::SINGLE : SpannerSegmentType::BEGIN;</a>
<a name="ln1065">            }</a>
<a name="ln1066">      else if (tick() &lt; stick &amp;&amp; tick2() &gt;= etick)</a>
<a name="ln1067">            sst = SpannerSegmentType::MIDDLE;</a>
<a name="ln1068">      else</a>
<a name="ln1069">            sst = SpannerSegmentType::END;</a>
<a name="ln1070">      slurSegment-&gt;setSpannerSegmentType(sst);</a>
<a name="ln1071"> </a>
<a name="ln1072">      SlurPos sPos;</a>
<a name="ln1073">      slurPos(&amp;sPos);</a>
<a name="ln1074"> </a>
<a name="ln1075">      switch (sst) {</a>
<a name="ln1076">            case SpannerSegmentType::SINGLE:</a>
<a name="ln1077">                  slurSegment-&gt;layoutSegment(sPos.p1, sPos.p2);</a>
<a name="ln1078">                  break;</a>
<a name="ln1079">            case SpannerSegmentType::BEGIN:</a>
<a name="ln1080">                  slurSegment-&gt;layoutSegment(sPos.p1, QPointF(system-&gt;bbox().width(), sPos.p1.y()));</a>
<a name="ln1081">                  break;</a>
<a name="ln1082">            case SpannerSegmentType::MIDDLE: {</a>
<a name="ln1083">                  qreal x1 = firstNoteRestSegmentX(system);</a>
<a name="ln1084">                  qreal x2 = system-&gt;bbox().width();</a>
<a name="ln1085">                  qreal y  = staffIdx() &gt; system-&gt;staves()-&gt;size() ? system-&gt;y() : system-&gt;staff(staffIdx())-&gt;y();</a>
<a name="ln1086">                  slurSegment-&gt;layoutSegment(QPointF(x1, y), QPointF(x2, y));</a>
<a name="ln1087">                  }</a>
<a name="ln1088">                  break;</a>
<a name="ln1089">            case SpannerSegmentType::END:</a>
<a name="ln1090">                  slurSegment-&gt;layoutSegment(QPointF(firstNoteRestSegmentX(system), sPos.p2.y()), sPos.p2);</a>
<a name="ln1091">                  break;</a>
<a name="ln1092">            }</a>
<a name="ln1093"> </a>
<a name="ln1094">      return slurSegment;</a>
<a name="ln1095">      }</a>
<a name="ln1096"> </a>
<a name="ln1097">//---------------------------------------------------------</a>
<a name="ln1098">//   layout</a>
<a name="ln1099">//---------------------------------------------------------</a>
<a name="ln1100"> </a>
<a name="ln1101">void Slur::layout()</a>
<a name="ln1102">      {</a>
<a name="ln1103">      if (track2() == -1)</a>
<a name="ln1104">            setTrack2(track());</a>
<a name="ln1105"> </a>
<a name="ln1106">      qreal _spatium = spatium();</a>
<a name="ln1107"> </a>
<a name="ln1108">      if (score() == gscore || tick() == Fraction(-1,1)) {</a>
<a name="ln1109">            //</a>
<a name="ln1110">            // when used in a palette, slur has no parent and</a>
<a name="ln1111">            // tick and tick2 has no meaning so no layout is</a>
<a name="ln1112">            // possible and needed</a>
<a name="ln1113">            //</a>
<a name="ln1114">            SlurSegment* s;</a>
<a name="ln1115">            if (spannerSegments().empty()) {</a>
<a name="ln1116">                  s = new SlurSegment(score());</a>
<a name="ln1117">                  s-&gt;setTrack(track());</a>
<a name="ln1118">                  add(s);</a>
<a name="ln1119">                  }</a>
<a name="ln1120">            else {</a>
<a name="ln1121">                  s = frontSegment();</a>
<a name="ln1122">                  }</a>
<a name="ln1123">            s-&gt;setSpannerSegmentType(SpannerSegmentType::SINGLE);</a>
<a name="ln1124">            s-&gt;layoutSegment(QPointF(0, 0), QPointF(_spatium * 6, 0));</a>
<a name="ln1125">            setbbox(frontSegment()-&gt;bbox());</a>
<a name="ln1126">            return;</a>
<a name="ln1127">            }</a>
<a name="ln1128"> </a>
<a name="ln1129">      if (startCR() == 0 || startCR()-&gt;measure() == 0) {</a>
<a name="ln1130">            qDebug(&quot;track %d-%d  %p - %p tick %d-%d null start anchor&quot;,</a>
<a name="ln1131">               track(), track2(), startCR(), endCR(), tick().ticks(), tick2().ticks());</a>
<a name="ln1132">            return;</a>
<a name="ln1133">            }</a>
<a name="ln1134">      if (endCR() == 0) {     // sanity check</a>
<a name="ln1135">            qDebug(&quot;no end CR for %d&quot;, (tick()+ticks()).ticks());</a>
<a name="ln1136">            setEndElement(startCR());</a>
<a name="ln1137">            setTick2(tick());</a>
<a name="ln1138">            }</a>
<a name="ln1139">      switch (_slurDirection) {</a>
<a name="ln1140">            case Direction::UP:</a>
<a name="ln1141">                  _up = true;</a>
<a name="ln1142">                  break;</a>
<a name="ln1143">            case Direction::DOWN:</a>
<a name="ln1144">                  _up = false;</a>
<a name="ln1145">                  break;</a>
<a name="ln1146">            case Direction::AUTO:</a>
<a name="ln1147">                  {</a>
<a name="ln1148">                  //</a>
<a name="ln1149">                  // assumption:</a>
<a name="ln1150">                  // slurs have only chords or rests as start/end elements</a>
<a name="ln1151">                  //</a>
<a name="ln1152">                  if (startCR() == 0 || endCR() == 0) {</a>
<a name="ln1153">                        _up = true;</a>
<a name="ln1154">                        break;</a>
<a name="ln1155">                        }</a>
<a name="ln1156">                  Measure* m1 = startCR()-&gt;measure();</a>
<a name="ln1157"> </a>
<a name="ln1158">                  Chord* c1 = startCR()-&gt;isChord() ? toChord(startCR()) : 0;</a>
<a name="ln1159">                  Chord* c2 = endCR()-&gt;isChord()   ? toChord(endCR())   : 0;</a>
<a name="ln1160"> </a>
<a name="ln1161">                  _up = !(startCR()-&gt;up());</a>
<a name="ln1162"> </a>
<a name="ln1163">                  if ((endCR()-&gt;tick() - startCR()-&gt;tick()) &gt; m1-&gt;ticks()) {</a>
<a name="ln1164">                        // long slurs are always above</a>
<a name="ln1165">                        _up = true;</a>
<a name="ln1166">                        }</a>
<a name="ln1167">                  else</a>
<a name="ln1168">                        _up = !(startCR()-&gt;up());</a>
<a name="ln1169"> </a>
<a name="ln1170">                  if (c1 &amp;&amp; c2 &amp;&amp; isDirectionMixture(c1, c2) &amp;&amp; (c1-&gt;noteType() == NoteType::NORMAL)) {</a>
<a name="ln1171">                        // slurs go above if start and end note have different stem directions,</a>
<a name="ln1172">                        // but grace notes are exceptions</a>
<a name="ln1173">                        _up = true;</a>
<a name="ln1174">                        }</a>
<a name="ln1175">                  else if (m1-&gt;hasVoices(startCR()-&gt;staffIdx()) &amp;&amp; c1 &amp;&amp; c1-&gt;noteType() == NoteType::NORMAL) {</a>
<a name="ln1176">                        // in polyphonic passage, slurs go on the stem side</a>
<a name="ln1177">                        _up = startCR()-&gt;up();</a>
<a name="ln1178">                        }</a>
<a name="ln1179">                  else if (c1 &amp;&amp; c2 &amp;&amp; chordsHaveTie(c1, c2)) {</a>
<a name="ln1180">                        // could confuse slur with tie, put slur on stem side</a>
<a name="ln1181">                        _up = startCR()-&gt;up();</a>
<a name="ln1182">                        }</a>
<a name="ln1183">                  }</a>
<a name="ln1184">                  break;</a>
<a name="ln1185">            }</a>
<a name="ln1186"> </a>
<a name="ln1187">      SlurPos sPos;</a>
<a name="ln1188">      slurPos(&amp;sPos);</a>
<a name="ln1189"> </a>
<a name="ln1190">      const QList&lt;System*&gt;&amp; sl = score()-&gt;systems();</a>
<a name="ln1191">      ciSystem is = sl.begin();</a>
<a name="ln1192">      while (is != sl.end()) {</a>
<a name="ln1193">            if (*is == sPos.system1)</a>
<a name="ln1194">                  break;</a>
<a name="ln1195">            ++is;</a>
<a name="ln1196">            }</a>
<a name="ln1197">      if (is == sl.end())</a>
<a name="ln1198">            qDebug(&quot;Slur::layout  first system not found&quot;);</a>
<a name="ln1199">      setPos(0, 0);</a>
<a name="ln1200"> </a>
<a name="ln1201">      //---------------------------------------------------------</a>
<a name="ln1202">      //   count number of segments, if no change, all</a>
<a name="ln1203">      //    user offsets (drags) are retained</a>
<a name="ln1204">      //---------------------------------------------------------</a>
<a name="ln1205"> </a>
<a name="ln1206">      unsigned nsegs = 1;</a>
<a name="ln1207">      for (ciSystem iis = is; iis != sl.end(); ++iis) {</a>
<a name="ln1208">            if ((*iis)-&gt;vbox())</a>
<a name="ln1209">                  continue;</a>
<a name="ln1210">            if (*iis == sPos.system2)</a>
<a name="ln1211">                  break;</a>
<a name="ln1212">            ++nsegs;</a>
<a name="ln1213">            }</a>
<a name="ln1214"> </a>
<a name="ln1215">      fixupSegments(nsegs);</a>
<a name="ln1216"> </a>
<a name="ln1217">      for (int i = 0; is != sl.end(); ++i, ++is) {</a>
<a name="ln1218">            System* system  = *is;</a>
<a name="ln1219">            if (system-&gt;vbox()) {</a>
<a name="ln1220">                  --i;</a>
<a name="ln1221">                  continue;</a>
<a name="ln1222">                  }</a>
<a name="ln1223">            SlurSegment* segment = segmentAt(i);</a>
<a name="ln1224">            segment-&gt;setSystem(system);</a>
<a name="ln1225"> </a>
<a name="ln1226">            // case 1: one segment</a>
<a name="ln1227">            if (sPos.system1 == sPos.system2) {</a>
<a name="ln1228">                  segment-&gt;setSpannerSegmentType(SpannerSegmentType::SINGLE);</a>
<a name="ln1229">                  segment-&gt;layoutSegment(sPos.p1, sPos.p2);</a>
<a name="ln1230">                  }</a>
<a name="ln1231">            // case 2: start segment</a>
<a name="ln1232">            else if (i == 0) {</a>
<a name="ln1233">                  segment-&gt;setSpannerSegmentType(SpannerSegmentType::BEGIN);</a>
<a name="ln1234">                  qreal x = system-&gt;bbox().width();</a>
<a name="ln1235">                  segment-&gt;layoutSegment(sPos.p1, QPointF(x, sPos.p1.y()));</a>
<a name="ln1236">                  }</a>
<a name="ln1237">            // case 3: middle segment</a>
<a name="ln1238">            else if (i != 0 &amp;&amp; system != sPos.system2) {</a>
<a name="ln1239">                  segment-&gt;setSpannerSegmentType(SpannerSegmentType::MIDDLE);</a>
<a name="ln1240">                  qreal x1 = firstNoteRestSegmentX(system);</a>
<a name="ln1241">                  qreal x2 = system-&gt;bbox().width();</a>
<a name="ln1242">                  qreal y  = staffIdx() &gt; system-&gt;staves()-&gt;size() ? system-&gt;y() : system-&gt;staff(staffIdx())-&gt;y();</a>
<a name="ln1243">                  segment-&gt;layoutSegment(QPointF(x1, y), QPointF(x2, y));</a>
<a name="ln1244">                  }</a>
<a name="ln1245">            // case 4: end segment</a>
<a name="ln1246">            else {</a>
<a name="ln1247">                  segment-&gt;setSpannerSegmentType(SpannerSegmentType::END);</a>
<a name="ln1248">                  qreal x = firstNoteRestSegmentX(system);</a>
<a name="ln1249">                  segment-&gt;layoutSegment(QPointF(x, sPos.p2.y()), sPos.p2);</a>
<a name="ln1250">                  }</a>
<a name="ln1251">            if (system == sPos.system2)</a>
<a name="ln1252">                  break;</a>
<a name="ln1253">            }</a>
<a name="ln1254">      setbbox(spannerSegments().empty() ? QRectF() : frontSegment()-&gt;bbox());</a>
<a name="ln1255">      }</a>
<a name="ln1256"> </a>
<a name="ln1257">//---------------------------------------------------------</a>
<a name="ln1258">//   setTrack</a>
<a name="ln1259">//---------------------------------------------------------</a>
<a name="ln1260"> </a>
<a name="ln1261">void Slur::setTrack(int n)</a>
<a name="ln1262">      {</a>
<a name="ln1263">      Element::setTrack(n);</a>
<a name="ln1264">      for (SpannerSegment* ss : spannerSegments())</a>
<a name="ln1265">            ss-&gt;setTrack(n);</a>
<a name="ln1266">      }</a>
<a name="ln1267">}</a>
<a name="ln1268"> </a>

</code></pre>
<div class="balloon" rel="194"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'scr' is always true.</p></div>
<div class="balloon" rel="204"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ecr' is always true.</p></div>
<div class="balloon" rel="606"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'sp->system2' should be checked here.</p></div>
<div class="balloon" rel="615"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: sp->system1.</p></div>
<div class="balloon" rel="1027"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: startCR() == 0.</p></div>
<div class="balloon" rel="1152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false: startCR() == 0.</p></div>
<div class="balloon" rel="1238"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: i != 0.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
