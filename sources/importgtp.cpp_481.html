
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>importgtp.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;importgtp.h&quot;</a>
<a name="ln14">#include &quot;importptb.h&quot;</a>
<a name="ln15">#include &quot;globals.h&quot;</a>
<a name="ln16">#include &quot;preferences.h&quot;</a>
<a name="ln17">#include &lt;libmscore/measurebase.h&gt;</a>
<a name="ln18">#include &lt;libmscore/text.h&gt;</a>
<a name="ln19">#include &lt;libmscore/box.h&gt;</a>
<a name="ln20">#include &lt;libmscore/staff.h&gt;</a>
<a name="ln21">#include &lt;libmscore/part.h&gt;</a>
<a name="ln22">#include &lt;libmscore/measure.h&gt;</a>
<a name="ln23">#include &lt;libmscore/timesig.h&gt;</a>
<a name="ln24">#include &lt;libmscore/tremolo.h&gt;</a>
<a name="ln25">#include &lt;libmscore/rest.h&gt;</a>
<a name="ln26">#include &lt;libmscore/chord.h&gt;</a>
<a name="ln27">#include &lt;libmscore/note.h&gt;</a>
<a name="ln28">#include &lt;libmscore/stringdata.h&gt;</a>
<a name="ln29">#include &lt;libmscore/clef.h&gt;</a>
<a name="ln30">#include &lt;libmscore/lyrics.h&gt;</a>
<a name="ln31">#include &lt;libmscore/tempotext.h&gt;</a>
<a name="ln32">#include &lt;libmscore/slur.h&gt;</a>
<a name="ln33">#include &lt;libmscore/tie.h&gt;</a>
<a name="ln34">#include &lt;libmscore/tuplet.h&gt;</a>
<a name="ln35">#include &lt;libmscore/barline.h&gt;</a>
<a name="ln36">#include &lt;libmscore/excerpt.h&gt;</a>
<a name="ln37">#include &lt;libmscore/stafftype.h&gt;</a>
<a name="ln38">#include &lt;libmscore/bracket.h&gt;</a>
<a name="ln39">#include &lt;libmscore/articulation.h&gt;</a>
<a name="ln40">#include &lt;libmscore/keysig.h&gt;</a>
<a name="ln41">#include &lt;libmscore/harmony.h&gt;</a>
<a name="ln42">#include &lt;libmscore/bend.h&gt;</a>
<a name="ln43">#include &lt;libmscore/tremolobar.h&gt;</a>
<a name="ln44">#include &lt;libmscore/segment.h&gt;</a>
<a name="ln45">#include &lt;libmscore/rehearsalmark.h&gt;</a>
<a name="ln46">#include &lt;libmscore/dynamic.h&gt;</a>
<a name="ln47">#include &lt;libmscore/arpeggio.h&gt;</a>
<a name="ln48">#include &lt;libmscore/volta.h&gt;</a>
<a name="ln49">#include &lt;libmscore/fret.h&gt;</a>
<a name="ln50">#include &lt;libmscore/instrtemplate.h&gt;</a>
<a name="ln51">#include &lt;libmscore/glissando.h&gt;</a>
<a name="ln52">#include &lt;libmscore/chordline.h&gt;</a>
<a name="ln53">#include &lt;libmscore/instrtemplate.h&gt;</a>
<a name="ln54">#include &lt;libmscore/hairpin.h&gt;</a>
<a name="ln55">#include &lt;libmscore/ottava.h&gt;</a>
<a name="ln56">#include &lt;libmscore/notedot.h&gt;</a>
<a name="ln57">#include &lt;libmscore/stafftext.h&gt;</a>
<a name="ln58">#include &lt;libmscore/sym.h&gt;</a>
<a name="ln59">#include &lt;libmscore/textline.h&gt;</a>
<a name="ln60">#include &lt;libmscore/letring.h&gt;</a>
<a name="ln61">#include &lt;libmscore/palmmute.h&gt;</a>
<a name="ln62">#include &lt;libmscore/vibrato.h&gt;</a>
<a name="ln63"> </a>
<a name="ln64">namespace Ms {</a>
<a name="ln65"> </a>
<a name="ln66">//---------------------------------------------------------</a>
<a name="ln67">//   errmsg</a>
<a name="ln68">//---------------------------------------------------------</a>
<a name="ln69"> </a>
<a name="ln70">const char* const GuitarPro::errmsg[] = {</a>
<a name="ln71">      &quot;no error&quot;,</a>
<a name="ln72">      &quot;unknown file format&quot;,</a>
<a name="ln73">      &quot;unexpected end of file&quot;,</a>
<a name="ln74">      &quot;bad number of strings&quot;,</a>
<a name="ln75">};</a>
<a name="ln76"> </a>
<a name="ln77">#ifdef _MSC_VER</a>
<a name="ln78">#pragma optimize(&quot;&quot;, off)</a>
<a name="ln79">#endif</a>
<a name="ln80"> </a>
<a name="ln81">//---------------------------------------------------------</a>
<a name="ln82">//   GpBar</a>
<a name="ln83">//---------------------------------------------------------</a>
<a name="ln84"> </a>
<a name="ln85">GpBar::GpBar()</a>
<a name="ln86">      {</a>
<a name="ln87">      barLine = BarLineType::NORMAL;</a>
<a name="ln88">      keysig  = GP_INVALID_KEYSIG;</a>
<a name="ln89">      timesig = Fraction(4,4);</a>
<a name="ln90">      repeatFlags = Repeat::NONE;</a>
<a name="ln91">      repeats = 2;</a>
<a name="ln92">      }</a>
<a name="ln93"> </a>
<a name="ln94">//---------------------------------------------------------</a>
<a name="ln95">//   GuitarPro</a>
<a name="ln96">//---------------------------------------------------------</a>
<a name="ln97"> </a>
<a name="ln98">GuitarPro::GuitarPro(MasterScore* s, int v)</a>
<a name="ln99">      {</a>
<a name="ln100">      score   = s;</a>
<a name="ln101">      version = v;</a>
<a name="ln102">      _codec = QTextCodec::codecForName(preferences.getString(PREF_IMPORT_GUITARPRO_CHARSET).toLatin1());</a>
<a name="ln103">      voltaSequence = 1;</a>
<a name="ln104">      tempo = -1;</a>
<a name="ln105">      }</a>
<a name="ln106"> </a>
<a name="ln107">GuitarPro::~GuitarPro()</a>
<a name="ln108">      {</a>
<a name="ln109">      delete[] slurs;</a>
<a name="ln110">      }</a>
<a name="ln111"> </a>
<a name="ln112">//---------------------------------------------------------</a>
<a name="ln113">//   skip</a>
<a name="ln114">//---------------------------------------------------------</a>
<a name="ln115"> </a>
<a name="ln116">void GuitarPro::skip(qint64 len)</a>
<a name="ln117">      {</a>
<a name="ln118">      f-&gt;seek(f-&gt;pos() + len);</a>
<a name="ln119">      /*char c;</a>
<a name="ln120">      while (len--)</a>
<a name="ln121">            read(&amp;c, 1);*/</a>
<a name="ln122">      }</a>
<a name="ln123"> </a>
<a name="ln124">//---------------------------------------------------------</a>
<a name="ln125">//   createTuningString</a>
<a name="ln126">//---------------------------------------------------------</a>
<a name="ln127"> </a>
<a name="ln128">void GuitarPro::createTuningString(int strings, int tuning[])</a>
<a name="ln129">      {</a>
<a name="ln130">      const char* tune[] = { &quot;C&quot;, &quot;C#&quot;, &quot;D&quot;, &quot;D#&quot;, &quot;E&quot;, &quot;F&quot;, &quot;F#&quot;, &quot;G&quot;, &quot;G#&quot;, &quot;A&quot;, &quot;A#&quot;, &quot;B&quot;};</a>
<a name="ln131">      //TODO-ws  score-&gt;tuning.clear();</a>
<a name="ln132">      std::vector&lt;int&gt; pitch;</a>
<a name="ln133">      for (int i = 0; i &lt; strings; ++i) {</a>
<a name="ln134">            pitch.push_back(tuning[i]);</a>
<a name="ln135">            //score-&gt;tuning += tune[tuning[i] % 12];</a>
<a name="ln136">            }</a>
<a name="ln137">      std::string t;</a>
<a name="ln138">      for (auto i : pitch) {</a>
<a name="ln139">            t += tune[i % 12];</a>
<a name="ln140">            t += &quot; &quot;;</a>
<a name="ln141">            }</a>
<a name="ln142">      tunings.push_back(t);</a>
<a name="ln143">      }</a>
<a name="ln144"> </a>
<a name="ln145">//---------------------------------------------------------</a>
<a name="ln146">//    read</a>
<a name="ln147">//---------------------------------------------------------</a>
<a name="ln148"> </a>
<a name="ln149">void GuitarPro::read(void* p, qint64 len)</a>
<a name="ln150">      {</a>
<a name="ln151">      if (len == 0)</a>
<a name="ln152">            return;</a>
<a name="ln153">      qint64 rv = f-&gt;read((char*)p, len);</a>
<a name="ln154">      if (rv != len) {</a>
<a name="ln155">            Q_ASSERT(rv == len); //to have assert in debug and no warnings from AppVeyor in release</a>
<a name="ln156">            }</a>
<a name="ln157">      curPos += len;</a>
<a name="ln158">      }</a>
<a name="ln159"> </a>
<a name="ln160">//---------------------------------------------------------</a>
<a name="ln161">//   readChar</a>
<a name="ln162">//---------------------------------------------------------</a>
<a name="ln163"> </a>
<a name="ln164">int GuitarPro::readChar()</a>
<a name="ln165">      {</a>
<a name="ln166">      signed char c;</a>
<a name="ln167">      read(&amp;c, 1);</a>
<a name="ln168">      return c;</a>
<a name="ln169">      }</a>
<a name="ln170"> </a>
<a name="ln171">//---------------------------------------------------------</a>
<a name="ln172">//   readUChar</a>
<a name="ln173">//---------------------------------------------------------</a>
<a name="ln174"> </a>
<a name="ln175">int GuitarPro::readUChar()</a>
<a name="ln176">      {</a>
<a name="ln177">      uchar c;</a>
<a name="ln178">      read(&amp;c, 1);</a>
<a name="ln179">      return c;</a>
<a name="ln180">      }</a>
<a name="ln181"> </a>
<a name="ln182">//---------------------------------------------------------</a>
<a name="ln183">//   readPascalString</a>
<a name="ln184">//---------------------------------------------------------</a>
<a name="ln185"> </a>
<a name="ln186">QString GuitarPro::readPascalString(int n)</a>
<a name="ln187">      {</a>
<a name="ln188">      uchar l = readUChar();</a>
<a name="ln189">      std::vector&lt;char&gt; s(l + 1);</a>
<a name="ln190">      //char s[l + 1];</a>
<a name="ln191">      read(&amp;s[0], l);</a>
<a name="ln192">      s[l] = 0;</a>
<a name="ln193">      if (n - l &gt; 0)</a>
<a name="ln194">            skip(n - l);</a>
<a name="ln195">      if (_codec)</a>
<a name="ln196">            return _codec-&gt;toUnicode(&amp;s[0]);</a>
<a name="ln197">      else</a>
<a name="ln198">            return QString(&amp;s[0]);</a>
<a name="ln199">      }</a>
<a name="ln200"> </a>
<a name="ln201">//---------------------------------------------------------</a>
<a name="ln202">//   readWordPascalString</a>
<a name="ln203">//---------------------------------------------------------</a>
<a name="ln204"> </a>
<a name="ln205">QString GuitarPro::readWordPascalString()</a>
<a name="ln206">      {</a>
<a name="ln207">      int l = readInt();</a>
<a name="ln208">      std::vector&lt;char&gt; c(l + 1);</a>
<a name="ln209">      //char c[l+1];</a>
<a name="ln210">      read(&amp;c[0], l);</a>
<a name="ln211">      c[l] = 0;</a>
<a name="ln212">      if (_codec)</a>
<a name="ln213">            return _codec-&gt;toUnicode(&amp;c[0]);</a>
<a name="ln214">      else</a>
<a name="ln215">            return QString::fromLocal8Bit(&amp;c[0]);</a>
<a name="ln216">      }</a>
<a name="ln217"> </a>
<a name="ln218">//---------------------------------------------------------</a>
<a name="ln219">//   readBytePascalString</a>
<a name="ln220">//---------------------------------------------------------</a>
<a name="ln221"> </a>
<a name="ln222">QString GuitarPro::readBytePascalString()</a>
<a name="ln223">      {</a>
<a name="ln224">      int l = readUChar();</a>
<a name="ln225">      std::vector&lt;char&gt; c(l + 1);</a>
<a name="ln226">      //char c[l+1];</a>
<a name="ln227">      read(&amp;c[0], l);</a>
<a name="ln228">      c[l] = 0;</a>
<a name="ln229">      if(_codec)</a>
<a name="ln230">            return  _codec-&gt;toUnicode(&amp;c[0]);</a>
<a name="ln231">      else</a>
<a name="ln232">            return QString::fromLocal8Bit(&amp;c[0]);</a>
<a name="ln233">      }</a>
<a name="ln234"> </a>
<a name="ln235">//---------------------------------------------------------</a>
<a name="ln236">//   readDelphiString</a>
<a name="ln237">//---------------------------------------------------------</a>
<a name="ln238"> </a>
<a name="ln239">QString GuitarPro::readDelphiString()</a>
<a name="ln240">      {</a>
<a name="ln241">      int maxl = readInt();</a>
<a name="ln242">      int l    = readUChar();</a>
<a name="ln243">      if (maxl != l + 1 &amp;&amp; maxl &gt; 255) {</a>
<a name="ln244">            qFatal(&quot;readDelphiString: first word doesn't match second byte&quot;);</a>
<a name="ln245">            l = maxl - 1;</a>
<a name="ln246">            }</a>
<a name="ln247">      std::vector&lt;char&gt; c(l + 1);</a>
<a name="ln248">      //char c[l + 1];</a>
<a name="ln249">      read(&amp;c[0], l);</a>
<a name="ln250">      c[l] = 0;</a>
<a name="ln251">      std::string g(&amp;c[0]);</a>
<a name="ln252">      if (g.find(&quot;2nd &quot;) == 0) {</a>
<a name="ln253">            ;     //?? int k = 1;</a>
<a name="ln254">            }</a>
<a name="ln255">      if (_codec)</a>
<a name="ln256">            return  _codec-&gt;toUnicode(&amp;c[0]);</a>
<a name="ln257">      else</a>
<a name="ln258">            return QString::fromLatin1(&amp;c[0]);</a>
<a name="ln259">      }</a>
<a name="ln260"> </a>
<a name="ln261">//---------------------------------------------------------</a>
<a name="ln262">//   readInt</a>
<a name="ln263">//---------------------------------------------------------</a>
<a name="ln264"> </a>
<a name="ln265">int GuitarPro::readInt()</a>
<a name="ln266">      {</a>
<a name="ln267">      uchar x;</a>
<a name="ln268">      read(&amp;x, 1);</a>
<a name="ln269">      int r = x;</a>
<a name="ln270">      read(&amp;x, 1);</a>
<a name="ln271">      r += x &lt;&lt; 8;</a>
<a name="ln272">      read(&amp;x, 1);</a>
<a name="ln273">      r += x &lt;&lt; 16;</a>
<a name="ln274">      read(&amp;x, 1);</a>
<a name="ln275">      r += x &lt;&lt; 24;</a>
<a name="ln276">      return r;</a>
<a name="ln277">      }</a>
<a name="ln278"> </a>
<a name="ln279">//---------------------------------------------------------</a>
<a name="ln280">//   initGuitarProDrumset</a>
<a name="ln281">//---------------------------------------------------------</a>
<a name="ln282"> </a>
<a name="ln283">void GuitarPro::initGuitarProDrumset()</a>
<a name="ln284">      {</a>
<a name="ln285">      gpDrumset = new Drumset;</a>
<a name="ln286">      for (int i = 0; i &lt; 128; ++i) {</a>
<a name="ln287">            gpDrumset-&gt;drum(i).notehead = NoteHead::Group::HEAD_INVALID;</a>
<a name="ln288">            gpDrumset-&gt;drum(i).line     = 0;</a>
<a name="ln289">            gpDrumset-&gt;drum(i).shortcut = 0;</a>
<a name="ln290">            gpDrumset-&gt;drum(i).voice    = 0;</a>
<a name="ln291">            gpDrumset-&gt;drum(i).stemDirection = Direction::UP;</a>
<a name="ln292">            }</a>
<a name="ln293">      // new drumset determined via guitar pro (third argument specifies position on staff, 10 = C3, 9 = D3, 8 = E3,...)</a>
<a name="ln294">      gpDrumset-&gt;drum(27) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;High Q&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln295">      gpDrumset-&gt;drum(28) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Slap&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln296">      gpDrumset-&gt;drum(29) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Scratch Push&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln297">      gpDrumset-&gt;drum(30) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Scratch Pull&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln298">      gpDrumset-&gt;drum(31) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Sticks&quot;), NoteHead::Group::HEAD_CROSS, 3, Direction::UP);</a>
<a name="ln299">      gpDrumset-&gt;drum(32) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Square Click&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln300">      gpDrumset-&gt;drum(33) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Metronome Click&quot;), NoteHead::Group::HEAD_CROSS, 3, Direction::UP);</a>
<a name="ln301">      gpDrumset-&gt;drum(34) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Metronome Bell&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln302">      gpDrumset-&gt;drum(35) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Acoustic Bass Drum&quot;), NoteHead::Group::HEAD_NORMAL, 7, Direction::UP);</a>
<a name="ln303">      gpDrumset-&gt;drum(36) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Bass Drum 1&quot;), NoteHead::Group::HEAD_NORMAL, 7, Direction::UP);</a>
<a name="ln304">      gpDrumset-&gt;drum(37) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Side Stick&quot;), NoteHead::Group::HEAD_CROSS, 3, Direction::UP);</a>
<a name="ln305">      gpDrumset-&gt;drum(38) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Acoustic Snare&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln306">      gpDrumset-&gt;drum(39) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Hand Clap&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln307">      gpDrumset-&gt;drum(40) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Electric Snare&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln308">      gpDrumset-&gt;drum(41) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Low Floor Tom&quot;), NoteHead::Group::HEAD_NORMAL, 6, Direction::UP);</a>
<a name="ln309">      gpDrumset-&gt;drum(42) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Closed Hi-Hat&quot;), NoteHead::Group::HEAD_CROSS, -1, Direction::UP);</a>
<a name="ln310">      gpDrumset-&gt;drum(43) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;High Floor Tom&quot;), NoteHead::Group::HEAD_NORMAL, 6, Direction::UP);</a>
<a name="ln311">      gpDrumset-&gt;drum(44) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Pedal Hi-Hat&quot;), NoteHead::Group::HEAD_CROSS, 9, Direction::UP);</a>
<a name="ln312">      gpDrumset-&gt;drum(45) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Low Tom&quot;), NoteHead::Group::HEAD_NORMAL, 5, Direction::UP);</a>
<a name="ln313">      gpDrumset-&gt;drum(46) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Open Hi-Hat&quot;), NoteHead::Group::HEAD_XCIRCLE, -1, Direction::UP);</a>
<a name="ln314">      gpDrumset-&gt;drum(47) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Low-Mid Tom&quot;), NoteHead::Group::HEAD_NORMAL, 4, Direction::UP);</a>
<a name="ln315">      gpDrumset-&gt;drum(48) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Hi-Mid Tom&quot;), NoteHead::Group::HEAD_NORMAL, 2, Direction::UP);</a>
<a name="ln316">      gpDrumset-&gt;drum(49) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Crash Cymbal 1&quot;), NoteHead::Group::HEAD_CROSS, -1, Direction::UP);</a>
<a name="ln317">      gpDrumset-&gt;drum(50) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;High Tom&quot;), NoteHead::Group::HEAD_NORMAL, 1, Direction::UP);</a>
<a name="ln318">      gpDrumset-&gt;drum(51) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Ride Cymbal 1&quot;), NoteHead::Group::HEAD_CROSS, 0, Direction::UP);</a>
<a name="ln319">      gpDrumset-&gt;drum(52) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Chinese Cymbal&quot;), NoteHead::Group::HEAD_CROSS, -3, Direction::UP);</a>
<a name="ln320">      gpDrumset-&gt;drum(53) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Ride Bell&quot;), NoteHead::Group::HEAD_DIAMOND, 0, Direction::UP);</a>
<a name="ln321">      gpDrumset-&gt;drum(54) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Tambourine&quot;), NoteHead::Group::HEAD_CROSS, 2, Direction::UP);</a>
<a name="ln322">      gpDrumset-&gt;drum(55) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Splash Cymbal&quot;), NoteHead::Group::HEAD_CROSS, -2, Direction::UP);</a>
<a name="ln323">      gpDrumset-&gt;drum(56) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Cowbell Medium&quot;), NoteHead::Group::HEAD_NORMAL, 0, Direction::UP);</a>
<a name="ln324">      gpDrumset-&gt;drum(57) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Crash Cymbal 2&quot;), NoteHead::Group::HEAD_CROSS, -2, Direction::UP);</a>
<a name="ln325">      gpDrumset-&gt;drum(58) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Vibraslap&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln326">      gpDrumset-&gt;drum(59) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Ride Cymbal 2&quot;), NoteHead::Group::HEAD_DIAMOND, 0, Direction::UP);</a>
<a name="ln327">      gpDrumset-&gt;drum(60) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Hi Bongo&quot;), NoteHead::Group::HEAD_NORMAL, 8, Direction::UP);</a>
<a name="ln328">      gpDrumset-&gt;drum(61) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Low Bongo&quot;), NoteHead::Group::HEAD_NORMAL, 9, Direction::UP);</a>
<a name="ln329">      gpDrumset-&gt;drum(62) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Mute Hi Conga&quot;), NoteHead::Group::HEAD_CROSS, 5, Direction::UP);</a>
<a name="ln330">      gpDrumset-&gt;drum(63) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Open Hi Conga&quot;), NoteHead::Group::HEAD_CROSS, 4, Direction::UP);</a>
<a name="ln331">      gpDrumset-&gt;drum(64) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Low Conga&quot;), NoteHead::Group::HEAD_CROSS, 6, Direction::UP);</a>
<a name="ln332">      gpDrumset-&gt;drum(65) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;High Timbale&quot;), NoteHead::Group::HEAD_CROSS, 8, Direction::UP);</a>
<a name="ln333">      gpDrumset-&gt;drum(66) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Low Timbale&quot;), NoteHead::Group::HEAD_CROSS, 9, Direction::UP);</a>
<a name="ln334">      gpDrumset-&gt;drum(67) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;High Agogo&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln335">      gpDrumset-&gt;drum(68) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Low Agogo&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln336">      gpDrumset-&gt;drum(69) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Cabasa&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln337">      gpDrumset-&gt;drum(70) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Maracas&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln338">      gpDrumset-&gt;drum(71) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Short Whistle&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln339">      gpDrumset-&gt;drum(72) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Long Whistle&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln340">      gpDrumset-&gt;drum(73) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Short Güiro&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln341">      gpDrumset-&gt;drum(74) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Long Güiro&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln342">      gpDrumset-&gt;drum(75) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Claves&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln343">      gpDrumset-&gt;drum(76) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Hi Wood Block&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln344">      gpDrumset-&gt;drum(77) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Low Wood Block&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln345">      gpDrumset-&gt;drum(78) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Mute Cuica&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln346">      gpDrumset-&gt;drum(79) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Open Cuica&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln347">      gpDrumset-&gt;drum(80) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Mute Triangle&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln348">      gpDrumset-&gt;drum(81) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Open Triangle&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln349">      gpDrumset-&gt;drum(82) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Shaker&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln350">      gpDrumset-&gt;drum(83) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Sleigh Bell&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln351">      gpDrumset-&gt;drum(84) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Bell Tree&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln352">      gpDrumset-&gt;drum(85) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Castanets&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln353">      gpDrumset-&gt;drum(86) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Mute Surdo&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln354">      gpDrumset-&gt;drum(87) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Open Surdo&quot;), NoteHead::Group::HEAD_NORMAL, 3, Direction::UP);</a>
<a name="ln355"> </a>
<a name="ln356">      gpDrumset-&gt;drum(91) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Snare (Rim shot)&quot;), NoteHead::Group::HEAD_DIAMOND, 3, Direction::UP);</a>
<a name="ln357">      gpDrumset-&gt;drum(93) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Ride (Edge)&quot;), NoteHead::Group::HEAD_CROSS, 0, Direction::UP);</a>
<a name="ln358"> </a>
<a name="ln359">      //Additional clutch presets (midi by default can't play this)</a>
<a name="ln360">      gpDrumset-&gt;drum(99) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Cowbell Low&quot;), NoteHead::Group::HEAD_TRIANGLE_UP, 1, Direction::UP);</a>
<a name="ln361">      gpDrumset-&gt;drum(102) = DrumInstrument(QT_TRANSLATE_NOOP(&quot;drumset&quot;, &quot;Cowbell High&quot;), NoteHead::Group::HEAD_TRIANGLE_UP, -1, Direction::UP);</a>
<a name="ln362">      }</a>
<a name="ln363"> </a>
<a name="ln364">//---------------------------------------------------------</a>
<a name="ln365">//   addPalmMate</a>
<a name="ln366">//---------------------------------------------------------</a>
<a name="ln367"> </a>
<a name="ln368">void GuitarPro::addPalmMute(Note* note)</a>
<a name="ln369">      {</a>
<a name="ln370">      int track = note-&gt;track();</a>
<a name="ln371">      while (int(_palmMutes.size()) &lt; track + 1)</a>
<a name="ln372">            _palmMutes.push_back(0);</a>
<a name="ln373"> </a>
<a name="ln374">      Chord* chord = note-&gt;chord();</a>
<a name="ln375">      if (_palmMutes[track]) {</a>
<a name="ln376">            PalmMute* pm = _palmMutes[track];</a>
<a name="ln377">            Chord* lastChord = toChord(pm-&gt;endCR());</a>
<a name="ln378">            if (lastChord == note-&gt;chord())</a>
<a name="ln379">                  return;</a>
<a name="ln380">            //</a>
<a name="ln381">            // extend the current palm mute or start a new one</a>
<a name="ln382">            //</a>
<a name="ln383">            Fraction tick = note-&gt;chord()-&gt;segment()-&gt;tick();</a>
<a name="ln384">            if (pm-&gt;tick2() &lt; tick)</a>
<a name="ln385">                  _palmMutes[track] = 0;</a>
<a name="ln386">            else {</a>
<a name="ln387">                  pm-&gt;setTick2(chord-&gt;tick() + chord-&gt;actualTicks());</a>
<a name="ln388">                  pm-&gt;setEndElement(chord);</a>
<a name="ln389">                  }</a>
<a name="ln390"> </a>
<a name="ln391">            }</a>
<a name="ln392">      if (!_palmMutes[track]) {</a>
<a name="ln393">            PalmMute* pm = new PalmMute(score);</a>
<a name="ln394">            _palmMutes[track] = pm;</a>
<a name="ln395">            Segment* segment = chord-&gt;segment();</a>
<a name="ln396">            Fraction tick = segment-&gt;tick();</a>
<a name="ln397"> </a>
<a name="ln398">            pm-&gt;setTick(tick);</a>
<a name="ln399">            pm-&gt;setTick2(tick + chord-&gt;actualTicks());</a>
<a name="ln400">            pm-&gt;setTrack(track);</a>
<a name="ln401">            pm-&gt;setTrack2(track);</a>
<a name="ln402">            pm-&gt;setStartElement(chord);</a>
<a name="ln403">            pm-&gt;setEndElement(chord);</a>
<a name="ln404">            score-&gt;addElement(pm);</a>
<a name="ln405">            }</a>
<a name="ln406">      }</a>
<a name="ln407"> </a>
<a name="ln408">//---------------------------------------------------------</a>
<a name="ln409">//   addLetRing</a>
<a name="ln410">//---------------------------------------------------------</a>
<a name="ln411"> </a>
<a name="ln412">void GuitarPro::addLetRing(Note* note)</a>
<a name="ln413">      {</a>
<a name="ln414">      int track = note-&gt;track();</a>
<a name="ln415">      while (int(_letRings.size()) &lt; track + 1)</a>
<a name="ln416">            _letRings.push_back(0);</a>
<a name="ln417"> </a>
<a name="ln418">      Chord* chord = note-&gt;chord();</a>
<a name="ln419">      if (_letRings[track]) {</a>
<a name="ln420">            LetRing* lr      = _letRings[track];</a>
<a name="ln421">            Chord* lastChord = toChord(lr-&gt;endCR());</a>
<a name="ln422">            if (lastChord == note-&gt;chord())</a>
<a name="ln423">                  return;</a>
<a name="ln424">            //</a>
<a name="ln425">            // extend the current &quot;let ring&quot; or start a new one</a>
<a name="ln426">            //</a>
<a name="ln427">            Fraction tick = note-&gt;chord()-&gt;segment()-&gt;tick();</a>
<a name="ln428">            if (lr-&gt;tick2() &lt; tick)</a>
<a name="ln429">                  _letRings[track] = 0;</a>
<a name="ln430">            else {</a>
<a name="ln431">                  lr-&gt;setTick2(chord-&gt;tick() + chord-&gt;actualTicks());</a>
<a name="ln432">                  lr-&gt;setEndElement(chord);</a>
<a name="ln433">                  }</a>
<a name="ln434">            }</a>
<a name="ln435">      if (!_letRings[track]) {</a>
<a name="ln436">            LetRing* lr = new LetRing(score);</a>
<a name="ln437">            _letRings[track] = lr;</a>
<a name="ln438">            Segment* segment = chord-&gt;segment();</a>
<a name="ln439">            Fraction tick = segment-&gt;tick();</a>
<a name="ln440"> </a>
<a name="ln441">            lr-&gt;setTick(tick);</a>
<a name="ln442">            lr-&gt;setTick2(tick + chord-&gt;actualTicks());</a>
<a name="ln443">            lr-&gt;setTrack(track);</a>
<a name="ln444">            lr-&gt;setTrack2(track);</a>
<a name="ln445">            lr-&gt;setStartElement(chord);</a>
<a name="ln446">            lr-&gt;setEndElement(chord);</a>
<a name="ln447">            score-&gt;addElement(lr);</a>
<a name="ln448">            }</a>
<a name="ln449">      }</a>
<a name="ln450"> </a>
<a name="ln451">//---------------------------------------------------------</a>
<a name="ln452">//   addVibrato</a>
<a name="ln453">//---------------------------------------------------------</a>
<a name="ln454"> </a>
<a name="ln455">void GuitarPro::addVibrato(Note* note, Vibrato::Type type)</a>
<a name="ln456">      {</a>
<a name="ln457">      int track = note-&gt;track();</a>
<a name="ln458">      while (int(_vibratos.size()) &lt; track + 1)</a>
<a name="ln459">            _vibratos.push_back(0);</a>
<a name="ln460"> </a>
<a name="ln461">      Chord* chord = note-&gt;chord();</a>
<a name="ln462">      if (_vibratos[track]) {</a>
<a name="ln463">            Vibrato* v      = _vibratos[track];</a>
<a name="ln464">            if (v-&gt;vibratoType() == type) {</a>
<a name="ln465">                  Chord* lastChord = toChord(v-&gt;endCR());</a>
<a name="ln466">                  if (lastChord == note-&gt;chord())</a>
<a name="ln467">                        return;</a>
<a name="ln468">                  //</a>
<a name="ln469">                  // extend the current &quot;vibrato&quot; or start a new one</a>
<a name="ln470">                  //</a>
<a name="ln471">                  Fraction tick = note-&gt;chord()-&gt;segment()-&gt;tick();</a>
<a name="ln472">                  if (v-&gt;tick2() &lt; tick)</a>
<a name="ln473">                        _vibratos[track] = 0;</a>
<a name="ln474">                  else {</a>
<a name="ln475">                        v-&gt;setTick2(chord-&gt;tick() + chord-&gt;actualTicks());</a>
<a name="ln476">                        v-&gt;setEndElement(chord);</a>
<a name="ln477">                        }</a>
<a name="ln478">                  }</a>
<a name="ln479">            else</a>
<a name="ln480">                  _vibratos[track] = 0;</a>
<a name="ln481">            }</a>
<a name="ln482">      if (!_vibratos[track]) {</a>
<a name="ln483">            Vibrato* v = new Vibrato(score);</a>
<a name="ln484">            v-&gt;setVibratoType(type);</a>
<a name="ln485">            _vibratos[track] = v;</a>
<a name="ln486">            Segment* segment = chord-&gt;segment();</a>
<a name="ln487">            Fraction tick = segment-&gt;tick();</a>
<a name="ln488"> </a>
<a name="ln489">            v-&gt;setTick(tick);</a>
<a name="ln490">            v-&gt;setTick2(tick + chord-&gt;actualTicks());</a>
<a name="ln491">            v-&gt;setTrack(track);</a>
<a name="ln492">            v-&gt;setTrack2(track);</a>
<a name="ln493">            v-&gt;setStartElement(chord);</a>
<a name="ln494">            v-&gt;setEndElement(chord);</a>
<a name="ln495">            score-&gt;addElement(v);</a>
<a name="ln496">            }</a>
<a name="ln497">      }</a>
<a name="ln498"> </a>
<a name="ln499">//---------------------------------------------------------</a>
<a name="ln500">//   addTap</a>
<a name="ln501">//---------------------------------------------------------</a>
<a name="ln502"> </a>
<a name="ln503">void GuitarPro::addTap(Note* note)</a>
<a name="ln504">      {</a>
<a name="ln505">      addTextToNote(&quot;T&quot;, Align::CENTER, note);</a>
<a name="ln506">      }</a>
<a name="ln507"> </a>
<a name="ln508">//---------------------------------------------------------</a>
<a name="ln509">//   addSlap</a>
<a name="ln510">//---------------------------------------------------------</a>
<a name="ln511"> </a>
<a name="ln512">void GuitarPro::addSlap(Note* note)</a>
<a name="ln513">      {</a>
<a name="ln514">      addTextToNote(&quot;S&quot;, Align::CENTER, note);</a>
<a name="ln515">      }</a>
<a name="ln516"> </a>
<a name="ln517">//---------------------------------------------------------</a>
<a name="ln518">//   addPop</a>
<a name="ln519">//---------------------------------------------------------</a>
<a name="ln520"> </a>
<a name="ln521">void GuitarPro::addPop(Note* note)</a>
<a name="ln522">      {</a>
<a name="ln523">      addTextToNote(&quot;P&quot;, Align::CENTER, note);</a>
<a name="ln524">      }</a>
<a name="ln525"> </a>
<a name="ln526">//---------------------------------------------------------</a>
<a name="ln527">//   addTextToNote</a>
<a name="ln528">//---------------------------------------------------------</a>
<a name="ln529"> </a>
<a name="ln530">Text* GuitarPro::addTextToNote(QString string, Align a, Note* note)</a>
<a name="ln531">      {</a>
<a name="ln532">      Text* text = new Text(score);</a>
<a name="ln533">      //TODO-ws	if (textStyle.underline())</a>
<a name="ln534">      //            text-&gt;setFramed(true);</a>
<a name="ln535">      text-&gt;setAlign(a);</a>
<a name="ln536">      bool use_harmony = string[string.size() - 1] == '\\';</a>
<a name="ln537">      if (use_harmony)</a>
<a name="ln538">            string.resize(string.size() - 1);</a>
<a name="ln539">      text-&gt;setPlainText(string);</a>
<a name="ln540">      //      text-&gt;setTextStyleType(use_harmony ? TextStyleType::HARMONY : TextStyleType::TECHNIQUE);</a>
<a name="ln541">      note-&gt;add(text);</a>
<a name="ln542">      return text;</a>
<a name="ln543">      }</a>
<a name="ln544"> </a>
<a name="ln545">void GuitarPro::setupTupletStyle(Tuplet* tuplet)</a>
<a name="ln546">      {</a>
<a name="ln547">      bool real;</a>
<a name="ln548">      switch (tuplet-&gt;ratio().numerator()) {</a>
<a name="ln549">            case 2: real = (tuplet-&gt;ratio().denominator() == 3); break;</a>
<a name="ln550">            case 3:</a>
<a name="ln551">            case 4: real = (tuplet-&gt;ratio().denominator() == 2); break;</a>
<a name="ln552">            case 5:</a>
<a name="ln553">            case 6:</a>
<a name="ln554">            case 7: real = (tuplet-&gt;ratio().denominator() == 4); break;</a>
<a name="ln555">            case 9:</a>
<a name="ln556">            case 10:</a>
<a name="ln557">            case 11:</a>
<a name="ln558">            case 12:</a>
<a name="ln559">            case 13: real = (tuplet-&gt;ratio().denominator() == 8); break;</a>
<a name="ln560">            default: real = false;</a>
<a name="ln561">            }</a>
<a name="ln562">      if (!real) {</a>
<a name="ln563">            tuplet-&gt;setNumberType(TupletNumberType::SHOW_RELATION);</a>
<a name="ln564">            tuplet-&gt;setPropertyFlags(Pid::NUMBER_TYPE, PropertyFlags::UNSTYLED);</a>
<a name="ln565">            }</a>
<a name="ln566">      }</a>
<a name="ln567"> </a>
<a name="ln568">//---------------------------------------------------------</a>
<a name="ln569">//   setTuplet</a>
<a name="ln570">//---------------------------------------------------------</a>
<a name="ln571"> </a>
<a name="ln572">void GuitarPro::setTuplet(Tuplet* tuplet, int tuple)</a>
<a name="ln573">      {</a>
<a name="ln574">      switch (tuple) {</a>
<a name="ln575">            case 3:</a>
<a name="ln576">                  tuplet-&gt;setRatio(Fraction(3,2));</a>
<a name="ln577">                  break;</a>
<a name="ln578">            case 5:</a>
<a name="ln579">                  tuplet-&gt;setRatio(Fraction(5,4));</a>
<a name="ln580">                  break;</a>
<a name="ln581">            case 6:</a>
<a name="ln582">                  tuplet-&gt;setRatio(Fraction(6,4));</a>
<a name="ln583">                  break;</a>
<a name="ln584">            case 7:</a>
<a name="ln585">                  tuplet-&gt;setRatio(Fraction(7,4));</a>
<a name="ln586">                  break;</a>
<a name="ln587">            case 9:</a>
<a name="ln588">                  tuplet-&gt;setRatio(Fraction(9,8));</a>
<a name="ln589">                  break;</a>
<a name="ln590">            case 10:</a>
<a name="ln591">                  tuplet-&gt;setRatio(Fraction(10,8));</a>
<a name="ln592">                  break;</a>
<a name="ln593">            case 11:</a>
<a name="ln594">                  tuplet-&gt;setRatio(Fraction(11,8));</a>
<a name="ln595">                  break;</a>
<a name="ln596">            case 12:</a>
<a name="ln597">                  tuplet-&gt;setRatio(Fraction(12,8));</a>
<a name="ln598">                  break;</a>
<a name="ln599">            case 13:</a>
<a name="ln600">                  tuplet-&gt;setRatio(Fraction(13,8));</a>
<a name="ln601">                  break;</a>
<a name="ln602">            default:</a>
<a name="ln603">                  qFatal(&quot;unsupported tuplet %d\n&quot;, tuple);</a>
<a name="ln604">            }</a>
<a name="ln605">      }</a>
<a name="ln606"> </a>
<a name="ln607">//---------------------------------------------------------</a>
<a name="ln608">//   addDynamic</a>
<a name="ln609">//---------------------------------------------------------</a>
<a name="ln610"> </a>
<a name="ln611">void GuitarPro::addDynamic(Note* note, int d)</a>
<a name="ln612">      {</a>
<a name="ln613">      if (d &lt; 0)</a>
<a name="ln614">            return;</a>
<a name="ln615">      if (!note-&gt;chord()){</a>
<a name="ln616">            qDebug() &lt;&lt; &quot;addDynamics: No chord associated with this note&quot;;</a>
<a name="ln617">            return;</a>
<a name="ln618">            }</a>
<a name="ln619">      Segment* s = nullptr;</a>
<a name="ln620">      if (note-&gt;chord()-&gt;isGrace()) {</a>
<a name="ln621">            Chord* parent = static_cast&lt;Chord*&gt;(note-&gt;chord()-&gt;parent());</a>
<a name="ln622">            s = parent-&gt;segment();</a>
<a name="ln623">            }</a>
<a name="ln624">      else</a>
<a name="ln625">            s = note-&gt;chord()-&gt;segment();</a>
<a name="ln626">      if (!s-&gt;findAnnotation(ElementType::DYNAMIC, note-&gt;staffIdx() * VOICES, note-&gt;staffIdx() * VOICES + VOICES - 1)) {</a>
<a name="ln627">            Dynamic* dyn = new Dynamic(score);</a>
<a name="ln628">            // guitar pro only allows their users to go from ppp to fff</a>
<a name="ln629">            QString map_dyn[] = {&quot;f&quot;,&quot;ppp&quot;,&quot;pp&quot;,&quot;p&quot;,&quot;mp&quot;,&quot;mf&quot;,&quot;f&quot;,&quot;ff&quot;,&quot;fff&quot;};</a>
<a name="ln630">            dyn-&gt;setDynamicType(map_dyn[d]);</a>
<a name="ln631">            dyn-&gt;setTrack(note-&gt;track());</a>
<a name="ln632">            s-&gt;add(dyn);</a>
<a name="ln633">            }</a>
<a name="ln634">      }</a>
<a name="ln635"> </a>
<a name="ln636">//---------------------------------------------------------</a>
<a name="ln637">//   readVolta</a>
<a name="ln638">//---------------------------------------------------------</a>
<a name="ln639"> </a>
<a name="ln640">void GuitarPro::readVolta(GPVolta* gpVolta, Measure* m)</a>
<a name="ln641">      {</a>
<a name="ln642">      /* Volta information is at most eight bits</a>
<a name="ln643">       * signifying which numbers should appear in the</a>
<a name="ln644">       * volta. A single bit 1 represents we should show</a>
<a name="ln645">       * 1, 100 represents 3, 10000 represents 6, 10101</a>
<a name="ln646">       * represents 1,3,5 etc. */</a>
<a name="ln647">      if (gpVolta-&gt;voltaInfo.length() != 0) {</a>
<a name="ln648">            // we have volta information - set up a volta</a>
<a name="ln649">            Ms::Volta* volta = new Ms::Volta(score);</a>
<a name="ln650">            volta-&gt;endings().clear();</a>
<a name="ln651">            QString voltaTextString = &quot;&quot;;</a>
<a name="ln652">            // initialise count to 1 as the first bit processed with represesnt first time volta</a>
<a name="ln653">            int count = 0;</a>
<a name="ln654">            int binaryNumber = 0;</a>
<a name="ln655">            // iterate through the volta information and determine the decimal numbers for voltas</a>
<a name="ln656">            auto iter = gpVolta-&gt;voltaInfo.begin();</a>
<a name="ln657">            while (iter != gpVolta-&gt;voltaInfo.end()) {</a>
<a name="ln658">                  switch (gpVolta-&gt;voltaType) {</a>
<a name="ln659">                        case GP_VOLTA_FLAGS:</a>
<a name="ln660">                              count++;</a>
<a name="ln661">                              if (*iter == 1) {   // we want this number to be displayed in the volta</a>
<a name="ln662">                                    if (voltaTextString == &quot;&quot;)</a>
<a name="ln663">                                          voltaTextString += QString::number(count);</a>
<a name="ln664">                                    else</a>
<a name="ln665">                                          voltaTextString += &quot;,&quot; + QString::number(count);</a>
<a name="ln666">                                    // add the decimal number to the endings field of voltas as well as the text</a>
<a name="ln667">                                    volta-&gt;endings().append(count);</a>
<a name="ln668">                                    }</a>
<a name="ln669">                              ++iter;</a>
<a name="ln670">                              break;</a>
<a name="ln671">                        case GP_VOLTA_BINARY:</a>
<a name="ln672">                              // find the binary number in decimal</a>
<a name="ln673">                              if (*iter == 1) {</a>
<a name="ln674">                                    binaryNumber += pow(2,count);</a>
<a name="ln675">                                    }</a>
<a name="ln676">                              ++iter;</a>
<a name="ln677">                              if (iter == gpVolta-&gt;voltaInfo.end()) {</a>
<a name="ln678">                                    // display all numbers in the volta from voltaSequence to the decimal</a>
<a name="ln679">                                    while (voltaSequence &lt;= binaryNumber) {</a>
<a name="ln680">                                          if (voltaTextString == &quot;&quot;)</a>
<a name="ln681">                                                voltaTextString = QString::number(voltaSequence);</a>
<a name="ln682">                                          else</a>
<a name="ln683">                                                voltaTextString += &quot;,&quot; + QString::number(voltaSequence);</a>
<a name="ln684">                                          volta-&gt;endings().append(voltaSequence);</a>
<a name="ln685">                                          voltaSequence++;</a>
<a name="ln686">                                          }</a>
<a name="ln687">                                    }</a>
<a name="ln688">                              count++;</a>
<a name="ln689">                              break;</a>
<a name="ln690">                        }</a>
<a name="ln691">                  }</a>
<a name="ln692">            volta-&gt;setText(XmlWriter::xmlString(voltaTextString));</a>
<a name="ln693">            volta-&gt;setTick(m-&gt;tick());</a>
<a name="ln694">            volta-&gt;setTick2(m-&gt;tick() + m-&gt;ticks());</a>
<a name="ln695">            score-&gt;addElement(volta);</a>
<a name="ln696">            }</a>
<a name="ln697">      }</a>
<a name="ln698"> </a>
<a name="ln699">//---------------------------------------------------------</a>
<a name="ln700">//   readBend</a>
<a name="ln701">//    bend graph</a>
<a name="ln702">//---------------------------------------------------------</a>
<a name="ln703"> </a>
<a name="ln704">void GuitarPro::readBend(Note* note)</a>
<a name="ln705">      {</a>
<a name="ln706">      readUChar();                        // icon</a>
<a name="ln707">      /*int amplitude =*/ readInt();                          // shown aplitude</a>
<a name="ln708">      int numPoints = readInt();          // the number of points in the bend</a>
<a name="ln709"> </a>
<a name="ln710">      // there are no notes in the bend, exit the function</a>
<a name="ln711">      if (numPoints == 0)</a>
<a name="ln712">            return;</a>
<a name="ln713">      Bend* bend = new Bend(note-&gt;score());</a>
<a name="ln714">      //TODO-ws      bend-&gt;setNote(note);</a>
<a name="ln715">      for (int i = 0; i &lt; numPoints; ++i) {</a>
<a name="ln716">            int bendTime  = readInt();</a>
<a name="ln717">            int bendPitch = readInt();</a>
<a name="ln718">            int bendVibrato = readUChar();</a>
<a name="ln719">            bend-&gt;points().append(PitchValue(bendTime, bendPitch, bendVibrato));</a>
<a name="ln720">            }</a>
<a name="ln721">      //TODO-ws      bend-&gt;setAmplitude(amplitude);</a>
<a name="ln722">      bend-&gt;setTrack(note-&gt;track());</a>
<a name="ln723">      note-&gt;add(bend);</a>
<a name="ln724">      }</a>
<a name="ln725"> </a>
<a name="ln726">//---------------------------------------------------------</a>
<a name="ln727">//   readLyrics</a>
<a name="ln728">//---------------------------------------------------------</a>
<a name="ln729"> </a>
<a name="ln730">void GuitarPro::readLyrics()</a>
<a name="ln731">      {</a>
<a name="ln732">      gpLyrics.lyricTrack = readInt();        // lyric track</a>
<a name="ln733">      gpLyrics.fromBeat = readInt();</a>
<a name="ln734">      gpLyrics.beatCounter = 0;</a>
<a name="ln735"> </a>
<a name="ln736">      QString lyrics = readWordPascalString();</a>
<a name="ln737">      lyrics.replace(QRegExp(&quot;\n&quot;), &quot; &quot;);</a>
<a name="ln738">      lyrics.replace(QRegExp(&quot;\r&quot;), &quot; &quot;);</a>
<a name="ln739">      auto sl = lyrics.split(&quot; &quot;, QString::KeepEmptyParts);</a>
<a name="ln740">      //gpLyrics.lyrics = lyrics.split(&quot; &quot;, QString::KeepEmptyParts);</a>
<a name="ln741">      for (auto&amp; str : sl) {</a>
<a name="ln742">            /*while (str[0] == '-')</a>
<a name="ln743">        {</a>
<a name="ln744">           gpLyrics.lyrics.push_back(&quot;aa&quot;);</a>
<a name="ln745">           str = str.substr(1);</a>
<a name="ln746">        }*/</a>
<a name="ln747">            gpLyrics.lyrics.push_back(str);</a>
<a name="ln748">            }</a>
<a name="ln749"> </a>
<a name="ln750">      for (int i = 0; i &lt; 4; ++i) {</a>
<a name="ln751">            readInt();</a>
<a name="ln752">            readWordPascalString();</a>
<a name="ln753">            }</a>
<a name="ln754">      }</a>
<a name="ln755"> </a>
<a name="ln756">//---------------------------------------------------------</a>
<a name="ln757">//   createSlide</a>
<a name="ln758">//---------------------------------------------------------</a>
<a name="ln759"> </a>
<a name="ln760">void GuitarPro::createSlide(int sl, ChordRest* cr, int staffIdx, Note* /*note*/)</a>
<a name="ln761">      {</a>
<a name="ln762">      // shift / legato slide</a>
<a name="ln763">      if (sl == SHIFT_SLIDE || sl == LEGATO_SLIDE) {</a>
<a name="ln764">            Glissando* s = new Glissando(score);</a>
<a name="ln765">            //s-&gt;setXmlText(&quot;&quot;);</a>
<a name="ln766">            s-&gt;setGlissandoType(GlissandoType::STRAIGHT);</a>
<a name="ln767">            cr-&gt;add(s);</a>
<a name="ln768">            s-&gt;setAnchor(Spanner::Anchor::NOTE);</a>
<a name="ln769">            Segment* prevSeg = cr-&gt;segment()-&gt;prev1(SegmentType::ChordRest);</a>
<a name="ln770">            Element* prevElem = prevSeg-&gt;element(staffIdx);</a>
<a name="ln771">            if (prevElem) {</a>
<a name="ln772">                  if (prevElem-&gt;type() == ElementType::CHORD) {</a>
<a name="ln773">                        Chord* prevChord = static_cast&lt;Chord*&gt;(prevElem);</a>
<a name="ln774">                        /** TODO we should not just take the top note here</a>
<a name="ln775">                        * but the /correct/ note need to check whether GP</a>
<a name="ln776">                        * supports multi-note gliss. I think it can in modern</a>
<a name="ln777">                        * versions */</a>
<a name="ln778">                        s-&gt;setStartElement(prevChord-&gt;upNote());</a>
<a name="ln779">                        s-&gt;setTick(prevSeg-&gt;tick());</a>
<a name="ln780">                        s-&gt;setTrack(staffIdx);</a>
<a name="ln781">                        s-&gt;setParent(prevChord-&gt;upNote());</a>
<a name="ln782">                        s-&gt;setText(&quot;&quot;);</a>
<a name="ln783">                        s-&gt;setGlissandoType(GlissandoType::STRAIGHT);</a>
<a name="ln784">                        if (sl == LEGATO_SLIDE)</a>
<a name="ln785">                              createSlur(true, staffIdx, prevChord);</a>
<a name="ln786">                        }</a>
<a name="ln787">                  }</a>
<a name="ln788"> </a>
<a name="ln789">            Chord* chord = (Chord*) cr;</a>
<a name="ln790">            /* TODO again here, we should not just set the up note but the</a>
<a name="ln791">             * /correct/ note need to check whether GP supports</a>
<a name="ln792">             * multi-note gliss. I think it can in modern versions */</a>
<a name="ln793">            s-&gt;setEndElement(chord-&gt;upNote());</a>
<a name="ln794">            s-&gt;setTick2(chord-&gt;segment()-&gt;tick());</a>
<a name="ln795">            s-&gt;setTrack2(staffIdx);</a>
<a name="ln796">            score-&gt;addElement(s);</a>
<a name="ln797">            if (sl == LEGATO_SLIDE)</a>
<a name="ln798">                  createSlur(false, staffIdx, cr);</a>
<a name="ln799">            }</a>
<a name="ln800">      // slide out downwards (fall)</a>
<a name="ln801">      if (sl &amp; SLIDE_OUT_DOWN) {</a>
<a name="ln802">            ChordLine* cl = new ChordLine(score);</a>
<a name="ln803">            cl-&gt;setChordLineType(ChordLineType::FALL);</a>
<a name="ln804">            cl-&gt;setStraight(true);</a>
<a name="ln805">            //TODO-ws		cl-&gt;setNote(note);</a>
<a name="ln806">            cr-&gt;add(cl);</a>
<a name="ln807">            }</a>
<a name="ln808">      // slide out upwards (doit)</a>
<a name="ln809">      if (sl &amp; SLIDE_OUT_UP) {</a>
<a name="ln810">            ChordLine* cl = new ChordLine(score);</a>
<a name="ln811">            cl-&gt;setChordLineType(ChordLineType::DOIT);</a>
<a name="ln812">            cl-&gt;setStraight(true);</a>
<a name="ln813">            //TODO-ws            cl-&gt;setNote(note);</a>
<a name="ln814">            cr-&gt;add(cl);</a>
<a name="ln815">            }</a>
<a name="ln816">      // slide in from below (plop)</a>
<a name="ln817">      if (sl &amp; SLIDE_IN_BELOW) {</a>
<a name="ln818">            ChordLine* cl = new ChordLine(score);</a>
<a name="ln819">            cl-&gt;setChordLineType(ChordLineType::PLOP);</a>
<a name="ln820">            cl-&gt;setStraight(true);</a>
<a name="ln821">            //TODO-ws		cl-&gt;setNote(note);</a>
<a name="ln822">            cr-&gt;add(cl);</a>
<a name="ln823">            }</a>
<a name="ln824">      // slide in from above (scoop)</a>
<a name="ln825">      if (sl &amp; SLIDE_IN_ABOVE) {</a>
<a name="ln826">            ChordLine* cl = new ChordLine(score);</a>
<a name="ln827">            cl-&gt;setChordLineType(ChordLineType::SCOOP);</a>
<a name="ln828">            cl-&gt;setStraight(true);</a>
<a name="ln829">            //TODO-ws		cl-&gt;setNote(note);</a>
<a name="ln830">            cr-&gt;add(cl);</a>
<a name="ln831">            }</a>
<a name="ln832">      }</a>
<a name="ln833"> </a>
<a name="ln834">//---------------------------------------------------------</a>
<a name="ln835">//   readChannels</a>
<a name="ln836">//---------------------------------------------------------</a>
<a name="ln837"> </a>
<a name="ln838">void GuitarPro::readChannels()</a>
<a name="ln839">      {</a>
<a name="ln840">      for (int i = 0; i &lt; GP_MAX_TRACK_NUMBER * 2; ++i) {</a>
<a name="ln841">            channelDefaults[i].patch   = readInt();</a>
<a name="ln842">            channelDefaults[i].volume  = readUChar() * 8 - 1;</a>
<a name="ln843">            channelDefaults[i].pan     = readUChar() * 8 - 1;</a>
<a name="ln844">            channelDefaults[i].chorus  = readUChar() * 8 - 1;</a>
<a name="ln845">            channelDefaults[i].reverb  = readUChar() * 8 - 1;</a>
<a name="ln846">            channelDefaults[i].phase   = readUChar() * 8 - 1;</a>
<a name="ln847">            channelDefaults[i].tremolo = readUChar() * 8 - 1;</a>
<a name="ln848"> </a>
<a name="ln849">            // defaults of 255, or any value above 127, are set to 0 (Musescore range is 0-127)</a>
<a name="ln850">            if (channelDefaults[i].patch &gt; 127)   { channelDefaults[i].patch = 0; }</a>
<a name="ln851">            if (channelDefaults[i].volume &gt; 127)  { channelDefaults[i].volume = 0; }</a>
<a name="ln852">            if (channelDefaults[i].pan &gt; 127)     { channelDefaults[i].pan = 0; }</a>
<a name="ln853">            if (channelDefaults[i].chorus &gt; 127)  { channelDefaults[i].chorus = 0; }</a>
<a name="ln854">            if (channelDefaults[i].reverb &gt; 127)  { channelDefaults[i].reverb = 0; }</a>
<a name="ln855">            if (channelDefaults[i].phase &gt; 127)   { channelDefaults[i].phase = 0; }</a>
<a name="ln856">            if (channelDefaults[i].tremolo &gt; 127) { channelDefaults[i].tremolo = 0; }</a>
<a name="ln857"> </a>
<a name="ln858">            // skip over blank information included for backwards compatibility with 3.0</a>
<a name="ln859">            skip(2);</a>
<a name="ln860">            }</a>
<a name="ln861">      }</a>
<a name="ln862"> </a>
<a name="ln863">//---------------------------------------------------------</a>
<a name="ln864">//   len2fraction</a>
<a name="ln865">//---------------------------------------------------------</a>
<a name="ln866"> </a>
<a name="ln867">Fraction GuitarPro::len2fraction(int len)</a>
<a name="ln868">      {</a>
<a name="ln869">      Fraction l;</a>
<a name="ln870">      switch(len) {</a>
<a name="ln871">            case -2: l.set(1, 1);    break;</a>
<a name="ln872">            case -1: l.set(1, 2);    break;</a>
<a name="ln873">            case  0: l.set(1, 4);    break;</a>
<a name="ln874">            case  1: l.set(1, 8);    break;</a>
<a name="ln875">            case  2: l.set(1, 16);   break;</a>
<a name="ln876">            case  3: l.set(1, 32);   break;</a>
<a name="ln877">            case  4: l.set(1, 64);   break;</a>
<a name="ln878">            case  5: l.set(1, 128);  break;</a>
<a name="ln879">                  // set to len - in some cases we get whacky numbers for this (40, 28...)</a>
<a name="ln880">            default:</a>
<a name="ln881">                  l.set(1,len);</a>
<a name="ln882">            }</a>
<a name="ln883">      return l;</a>
<a name="ln884">      }</a>
<a name="ln885"> </a>
<a name="ln886">//---------------------------------------------------------</a>
<a name="ln887">//   readMixChange</a>
<a name="ln888">//---------------------------------------------------------</a>
<a name="ln889"> </a>
<a name="ln890">bool GuitarPro::readMixChange(Measure* measure)</a>
<a name="ln891">      {</a>
<a name="ln892">      /*char patch   =*/ readChar();</a>
<a name="ln893">      signed char volume  = readChar();</a>
<a name="ln894">      signed char pan     = readChar();</a>
<a name="ln895">      signed char chorus  = readChar();</a>
<a name="ln896">      signed char reverb  = readChar();</a>
<a name="ln897">      signed char phase   = readChar();</a>
<a name="ln898">      signed char tremolo = readChar();</a>
<a name="ln899">      int temp    = readInt();</a>
<a name="ln900"> </a>
<a name="ln901">      if (volume &gt;= 0)</a>
<a name="ln902">            readChar();</a>
<a name="ln903">      if (pan &gt;= 0)</a>
<a name="ln904">            readChar();</a>
<a name="ln905">      if (chorus &gt;= 0)</a>
<a name="ln906">            readChar();</a>
<a name="ln907">      if (reverb &gt;= 0)</a>
<a name="ln908">            readChar();</a>
<a name="ln909">      if (phase &gt;= 0)</a>
<a name="ln910">            readChar();</a>
<a name="ln911">      if (tremolo &gt;= 0)</a>
<a name="ln912">            readChar();</a>
<a name="ln913">      if (temp &gt;= 0) {</a>
<a name="ln914">            if (temp != previousTempo) {</a>
<a name="ln915">                  previousTempo = temp;</a>
<a name="ln916">                  setTempo(temp, measure);</a>
<a name="ln917">                  }</a>
<a name="ln918">            readChar();</a>
<a name="ln919">            }</a>
<a name="ln920">      return true;</a>
<a name="ln921">      }</a>
<a name="ln922"> </a>
<a name="ln923">//---------------------------------------------------------</a>
<a name="ln924">//   createMeasures</a>
<a name="ln925">//---------------------------------------------------------</a>
<a name="ln926"> </a>
<a name="ln927">void GuitarPro::createMeasures()</a>
<a name="ln928">      {</a>
<a name="ln929">      Fraction tick = Fraction(0,1);</a>
<a name="ln930">      Fraction ts;</a>
<a name="ln931">      qDebug(&quot;measures %d bars.size %d&quot;, measures, bars.size());</a>
<a name="ln932"> </a>
<a name="ln933">      //      for (int i = 0; i &lt; measures; ++i) {</a>
<a name="ln934">      for (int i = 0; i &lt; bars.size(); ++i) {   // ?? (ws)</a>
<a name="ln935">            Fraction nts = bars[i].timesig;</a>
<a name="ln936">            Measure* m = new Measure(score);</a>
<a name="ln937">            m-&gt;setTick(tick);</a>
<a name="ln938">            m-&gt;setTimesig(nts);</a>
<a name="ln939">            m-&gt;setTicks(nts);</a>
<a name="ln940"> </a>
<a name="ln941">            if (i == 0 || ts != nts) {</a>
<a name="ln942">                  for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln943">                        const Staff* staff = score-&gt;staff(staffIdx);</a>
<a name="ln944">                        const StaffType* staffType = staff-&gt;staffType(Fraction(0,1));     // at tick 0</a>
<a name="ln945">                        if (staffType-&gt;genTimesig()) {</a>
<a name="ln946">                              TimeSig* t = new TimeSig(score);</a>
<a name="ln947">                              t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln948">                              t-&gt;setSig(nts);</a>
<a name="ln949">                              Segment* s = m-&gt;getSegment(SegmentType::TimeSig, tick);</a>
<a name="ln950">                              s-&gt;add(t);</a>
<a name="ln951">                              }</a>
<a name="ln952">                        }</a>
<a name="ln953">                  }</a>
<a name="ln954">            if (i == 0 || (bars[i].keysig != GP_INVALID_KEYSIG)) {</a>
<a name="ln955">                  for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln956">                        int keysig = bars[i].keysig != GP_INVALID_KEYSIG ? bars[i].keysig : key;</a>
<a name="ln957">                        if (tick.isZero() || (int)score-&gt;staff(staffIdx)-&gt;key(tick) != (int)Key(keysig)) {</a>
<a name="ln958">                              KeySig* t = new KeySig(score);</a>
<a name="ln959">                              t-&gt;setKey(Key(keysig));</a>
<a name="ln960">                              t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln961">                              Segment* s = m-&gt;getSegment(SegmentType::KeySig, tick);</a>
<a name="ln962">                              s-&gt;add(t);</a>
<a name="ln963">                              }</a>
<a name="ln964">                        }</a>
<a name="ln965">                  }</a>
<a name="ln966">            readVolta(&amp;bars[i].volta, m);</a>
<a name="ln967">            m-&gt;setRepeatEnd(bars[i].repeatFlags == Repeat::END);</a>
<a name="ln968">            m-&gt;setRepeatStart(bars[i].repeatFlags == Repeat::START);</a>
<a name="ln969">            m-&gt;setRepeatJump(bars[i].repeatFlags == Repeat::JUMP);</a>
<a name="ln970">            //            m-&gt;setRepeatFlags(bars[i].repeatFlags);</a>
<a name="ln971">            m-&gt;setRepeatCount(bars[i].repeats);       // supported in gp5</a>
<a name="ln972"> </a>
<a name="ln973">            // reset the volta sequence if we have an opening repeat</a>
<a name="ln974">            if (bars[i].repeatFlags == Repeat::START)</a>
<a name="ln975">                  voltaSequence = 1;</a>
<a name="ln976">            // otherwise, if we see an end repeat symbol, only reset if the bar after it does not contain a volta</a>
<a name="ln977">            else if (bars[i].repeatFlags == Repeat::END &amp;&amp; i &lt; bars.length() - 1) {</a>
<a name="ln978">                  if (bars[i+1].volta.voltaInfo.length() == 0) {</a>
<a name="ln979">                        voltaSequence = 1;      // reset  the volta count</a>
<a name="ln980">                        }</a>
<a name="ln981">                  }</a>
<a name="ln982"> </a>
<a name="ln983">            score-&gt;measures()-&gt;add(m);</a>
<a name="ln984">            tick += nts;</a>
<a name="ln985">            ts = nts;</a>
<a name="ln986">            }</a>
<a name="ln987">      }</a>
<a name="ln988"> </a>
<a name="ln989">//---------------------------------------------------------</a>
<a name="ln990">//   applyBeatEffects</a>
<a name="ln991">//---------------------------------------------------------</a>
<a name="ln992"> </a>
<a name="ln993">void GuitarPro::applyBeatEffects(Chord* chord, int beatEffect)</a>
<a name="ln994">      {</a>
<a name="ln995">      /* tap/slap/pop implemented as text until SMuFL has</a>
<a name="ln996">       * specifications and we can add them to fonts. Note that</a>
<a name="ln997">       * tap/slap/pop are just added to the top note in the chord,</a>
<a name="ln998">       * technically these can be applied to individual notes on the</a>
<a name="ln999">       * UI, but Guitar Pro has no way to express that on the</a>
<a name="ln1000">       * score. To get the same result, we should just add the marking</a>
<a name="ln1001">       * to above the top note.</a>
<a name="ln1002">       */</a>
<a name="ln1003">      if (beatEffect == 1) {</a>
<a name="ln1004">            if (version &gt; 300)</a>
<a name="ln1005">                  addTap(chord-&gt;upNote());</a>
<a name="ln1006">            else</a>
<a name="ln1007">                  addVibrato(chord-&gt;upNote());</a>
<a name="ln1008">            }</a>
<a name="ln1009">      else if (beatEffect == 2)</a>
<a name="ln1010">            addSlap(chord-&gt;upNote());</a>
<a name="ln1011">      else if (beatEffect == 3)</a>
<a name="ln1012">            addPop(chord-&gt;upNote());</a>
<a name="ln1013">      else if (beatEffect == 4) {</a>
<a name="ln1014">            if (version &gt;= 400) {</a>
<a name="ln1015">                  Articulation* a = new Articulation(chord-&gt;score());</a>
<a name="ln1016">                  a-&gt;setSymId(SymId::guitarFadeIn);</a>
<a name="ln1017">                  a-&gt;setAnchor(ArticulationAnchor::TOP_STAFF);</a>
<a name="ln1018">                  a-&gt;setPropertyFlags(Pid::ARTICULATION_ANCHOR, PropertyFlags::UNSTYLED);</a>
<a name="ln1019">                  chord-&gt;add(a);</a>
<a name="ln1020">                  }</a>
<a name="ln1021">            //TODO-ws		else for (auto n : chord-&gt;notes())</a>
<a name="ln1022">            //			n-&gt;setHarmonic(true);</a>
<a name="ln1023">            }</a>
<a name="ln1024">      else if (beatEffect == 5) {</a>
<a name="ln1025">            Articulation* a = new Articulation(chord-&gt;score());</a>
<a name="ln1026">            a-&gt;setSymId(SymId::stringsUpBow);</a>
<a name="ln1027">            chord-&gt;add(a);</a>
<a name="ln1028">            }</a>
<a name="ln1029">      else if (beatEffect == 6) {</a>
<a name="ln1030">            Articulation* art = new Articulation(chord-&gt;score());</a>
<a name="ln1031">            art-&gt;setSymId(SymId::stringsDownBow);</a>
<a name="ln1032">            chord-&gt;add(art);</a>
<a name="ln1033">            }</a>
<a name="ln1034">      else if (beatEffect == 7) {</a>
<a name="ln1035">            addVibrato(chord-&gt;upNote(), Vibrato::Type::VIBRATO_SAWTOOTH);</a>
<a name="ln1036">            }</a>
<a name="ln1037">      }</a>
<a name="ln1038"> </a>
<a name="ln1039">#ifdef _MSC_VER</a>
<a name="ln1040">#pragma optimize(&quot;&quot;, on)</a>
<a name="ln1041">#endif</a>
<a name="ln1042"> </a>
<a name="ln1043">//---------------------------------------------------------</a>
<a name="ln1044">//   read</a>
<a name="ln1045">//---------------------------------------------------------</a>
<a name="ln1046"> </a>
<a name="ln1047">bool GuitarPro1::read(QFile* fp)</a>
<a name="ln1048">      {</a>
<a name="ln1049">      f      = fp;</a>
<a name="ln1050">      curPos = 30;</a>
<a name="ln1051"> </a>
<a name="ln1052">      title  = readDelphiString();</a>
<a name="ln1053">      artist = readDelphiString();</a>
<a name="ln1054">      readDelphiString();</a>
<a name="ln1055"> </a>
<a name="ln1056">      int temp = readInt();</a>
<a name="ln1057">      /*uchar num =*/ readUChar();      // Shuffle rhythm feel</a>
<a name="ln1058"> </a>
<a name="ln1059">      // int octave = 0;</a>
<a name="ln1060">      key    = 0;</a>
<a name="ln1061">      if (version &gt; 102)</a>
<a name="ln1062">            key = readInt();    // key</a>
<a name="ln1063"> </a>
<a name="ln1064">      staves  = version &gt; 102 ? 8 : 1;</a>
<a name="ln1065"> </a>
<a name="ln1066">      slurs = new Slur*[staves];</a>
<a name="ln1067">      for (int i = 0; i &lt; staves; ++i)</a>
<a name="ln1068">            slurs[i] = nullptr;</a>
<a name="ln1069"> </a>
<a name="ln1070">      //int tnumerator   = 4;</a>
<a name="ln1071">      //int tdenominator = 4;</a>
<a name="ln1072"> </a>
<a name="ln1073">      //</a>
<a name="ln1074">      // create a part for every staff</a>
<a name="ln1075">      //</a>
<a name="ln1076">      for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln1077">            Part* part = new Part(score);</a>
<a name="ln1078">            Staff* s   = new Staff(score);</a>
<a name="ln1079">            s-&gt;setPart(part);</a>
<a name="ln1080">            part-&gt;insertStaff(s, 0);</a>
<a name="ln1081">            score-&gt;staves().push_back(s);</a>
<a name="ln1082">            score-&gt;appendPart(part);</a>
<a name="ln1083">            }</a>
<a name="ln1084"> </a>
<a name="ln1085"> </a>
<a name="ln1086">      for (int i = 0; i &lt; staves; ++i) {</a>
<a name="ln1087">            int tuning[GP_MAX_STRING_NUMBER];</a>
<a name="ln1088"> </a>
<a name="ln1089">            int strings  = version &gt; 101 ? readInt() : 6;</a>
<a name="ln1090">            for (int j = 0; j &lt; strings; ++j)</a>
<a name="ln1091">                  tuning[j] = readInt();</a>
<a name="ln1092">            std::vector&lt;int&gt; tuning2(strings);</a>
<a name="ln1093">            //int tuning2[strings];</a>
<a name="ln1094">            for (int k = 0; k &lt; strings; ++k)</a>
<a name="ln1095">                  tuning2[strings-k-1] = tuning[k];</a>
<a name="ln1096"> </a>
<a name="ln1097">            int frets = 32;   // TODO</a>
<a name="ln1098">            StringData stringData(frets, strings, &amp;tuning2[0]);</a>
<a name="ln1099">            createTuningString(strings, &amp;tuning2[0]);</a>
<a name="ln1100">            Part* part = score-&gt;staff(i)-&gt;part();</a>
<a name="ln1101">            Instrument* instr = part-&gt;instrument();</a>
<a name="ln1102">            instr-&gt;setStringData(stringData);</a>
<a name="ln1103">            instr-&gt;setSingleNoteDynamics(false);</a>
<a name="ln1104">            }</a>
<a name="ln1105"> </a>
<a name="ln1106">      measures = readInt();</a>
<a name="ln1107"> </a>
<a name="ln1108">      Fraction ts;</a>
<a name="ln1109">      Fraction tick = {0,1};</a>
<a name="ln1110">      for (int i = 0; i &lt; measures; ++i) {</a>
<a name="ln1111">            Fraction nts = bars[i].timesig;</a>
<a name="ln1112">            Measure* m = new Measure(score);</a>
<a name="ln1113">            m-&gt;setTick(tick);</a>
<a name="ln1114">            m-&gt;setTimesig(nts);</a>
<a name="ln1115">            m-&gt;setTicks(nts);</a>
<a name="ln1116"> </a>
<a name="ln1117">            if (i == 0 || ts != nts) {</a>
<a name="ln1118">                  for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln1119">                        TimeSig* t = new TimeSig(score);</a>
<a name="ln1120">                        t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1121">                        t-&gt;setSig(nts);</a>
<a name="ln1122">                        Segment* s = m-&gt;getSegment(SegmentType::TimeSig, tick);</a>
<a name="ln1123">                        s-&gt;add(t);</a>
<a name="ln1124">                        }</a>
<a name="ln1125">                  }</a>
<a name="ln1126"> </a>
<a name="ln1127">            score-&gt;measures()-&gt;add(m);</a>
<a name="ln1128">            tick += nts;</a>
<a name="ln1129">            ts = nts;</a>
<a name="ln1130">            }</a>
<a name="ln1131"> </a>
<a name="ln1132">      previousTempo = temp;</a>
<a name="ln1133">      Measure* measure = score-&gt;firstMeasure();</a>
<a name="ln1134">      bool mixChange = false;</a>
<a name="ln1135">      for (int bar = 0; bar &lt; measures; ++bar, measure = measure-&gt;nextMeasure()) {</a>
<a name="ln1136">            const GpBar&amp; gpbar = bars[bar];</a>
<a name="ln1137"> </a>
<a name="ln1138">            if (!gpbar.marker.isEmpty()) {</a>
<a name="ln1139">                  RehearsalMark* s = new RehearsalMark(score);</a>
<a name="ln1140">                  s-&gt;setPlainText(gpbar.marker.trimmed());</a>
<a name="ln1141">                  s-&gt;setTrack(0);</a>
<a name="ln1142">                  Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln1143">                  segment-&gt;add(s);</a>
<a name="ln1144">                  }</a>
<a name="ln1145">            std::vector&lt;Tuplet*&gt; tuplets(staves);</a>
<a name="ln1146">            //Tuplet* tuplets[staves];</a>
<a name="ln1147">            for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx)</a>
<a name="ln1148">                  tuplets[staffIdx] = 0;</a>
<a name="ln1149"> </a>
<a name="ln1150">            for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln1151">                  Fraction measureLen = {0,1};</a>
<a name="ln1152">                  int track = staffIdx * VOICES;</a>
<a name="ln1153">                  Fraction fraction  = measure-&gt;tick();</a>
<a name="ln1154">                  int beats = readInt();</a>
<a name="ln1155">                  for (int beat = 0; beat &lt; beats; ++beat) {</a>
<a name="ln1156">                        //                        int pause = 0;</a>
<a name="ln1157">                        uchar beatBits = readUChar();</a>
<a name="ln1158">                        bool dotted = beatBits &amp; BEAT_DOTTED;</a>
<a name="ln1159">                        if (beatBits &amp; BEAT_PAUSE)</a>
<a name="ln1160">                              /*pause =*/ readUChar();</a>
<a name="ln1161">                        int len = readChar();</a>
<a name="ln1162">                        int tuple = 0;</a>
<a name="ln1163">                        if (beatBits &amp; BEAT_TUPLET)</a>
<a name="ln1164">                              tuple = readInt();</a>
<a name="ln1165">                        Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, fraction);</a>
<a name="ln1166">                        if (beatBits &amp; BEAT_CHORD) {</a>
<a name="ln1167">                              int numStrings = score-&gt;staff(staffIdx)-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln1168">                              int header = readUChar();</a>
<a name="ln1169">                              QString name;</a>
<a name="ln1170">                              if ((header &amp; 1) == 0) {</a>
<a name="ln1171">                                    name = readDelphiString();</a>
<a name="ln1172">                                    readChord(segment, track, numStrings, name, false);</a>
<a name="ln1173">                                    }</a>
<a name="ln1174">                              else  {</a>
<a name="ln1175">                                    skip(25);</a>
<a name="ln1176">                                    name = readPascalString(34);</a>
<a name="ln1177">                                    readChord(segment, track, numStrings, name, true);</a>
<a name="ln1178">                                    skip(36);</a>
<a name="ln1179">                                    }</a>
<a name="ln1180">                              }</a>
<a name="ln1181">                        Lyrics* lyrics = 0;</a>
<a name="ln1182">                        if (beatBits &amp; BEAT_LYRICS) {</a>
<a name="ln1183">                              lyrics = new Lyrics(score);</a>
<a name="ln1184">                              lyrics-&gt;setPlainText(readDelphiString());</a>
<a name="ln1185">                              }</a>
<a name="ln1186">                        if (beatBits &amp; BEAT_EFFECTS)</a>
<a name="ln1187">                              readBeatEffects(track, segment);</a>
<a name="ln1188"> </a>
<a name="ln1189">                        if (beatBits &amp; BEAT_MIX_CHANGE) {</a>
<a name="ln1190">                              readMixChange(measure);</a>
<a name="ln1191">                              mixChange = true;</a>
<a name="ln1192">                              }</a>
<a name="ln1193"> </a>
<a name="ln1194">                        int strings = readUChar();   // used strings mask</a>
<a name="ln1195"> </a>
<a name="ln1196">                        Fraction l = len2fraction(len);</a>
<a name="ln1197">                        ChordRest* cr;</a>
<a name="ln1198">                        if (strings)</a>
<a name="ln1199">                              cr = new Chord(score);</a>
<a name="ln1200">                        else</a>
<a name="ln1201">                              cr = new Rest(score);</a>
<a name="ln1202">                        cr-&gt;setTrack(track);</a>
<a name="ln1203">                        if (lyrics)</a>
<a name="ln1204">                              cr-&gt;add(lyrics);</a>
<a name="ln1205"> </a>
<a name="ln1206">                        TDuration d(l);</a>
<a name="ln1207">                        d.setDots(dotted ? 1 : 0);</a>
<a name="ln1208"> </a>
<a name="ln1209">                        if (dotted)</a>
<a name="ln1210">                              l = l + (l * Fraction(1,2));</a>
<a name="ln1211"> </a>
<a name="ln1212">                        if (tuple) {</a>
<a name="ln1213">                              Tuplet* tuplet = tuplets[staffIdx];</a>
<a name="ln1214">                              if ((tuplet == 0) || (tuplet-&gt;elementsDuration() == tuplet-&gt;baseLen().fraction() * tuplet-&gt;ratio().numerator())) {</a>
<a name="ln1215">                                    tuplet = new Tuplet(score);</a>
<a name="ln1216">                                    tuplet-&gt;setTick(fraction);</a>
<a name="ln1217">                                    tuplet-&gt;setTrack(cr-&gt;track());</a>
<a name="ln1218">                                    tuplets[staffIdx] = tuplet;</a>
<a name="ln1219">                                    setTuplet(tuplet, tuple);</a>
<a name="ln1220">                                    tuplet-&gt;setParent(measure);</a>
<a name="ln1221">                                    }</a>
<a name="ln1222">                              tuplet-&gt;setTrack(track);</a>
<a name="ln1223">                              tuplet-&gt;setBaseLen(l);</a>
<a name="ln1224">                              tuplet-&gt;setTicks(l * tuplet-&gt;ratio().denominator());</a>
<a name="ln1225">                              cr-&gt;setTuplet(tuplet);</a>
<a name="ln1226">                              tuplet-&gt;add(cr);  //TODOxxx</a>
<a name="ln1227">                              }</a>
<a name="ln1228"> </a>
<a name="ln1229">                        cr-&gt;setTicks(l);</a>
<a name="ln1230">                        cr-&gt;setDurationType(d);</a>
<a name="ln1231">                        segment-&gt;add(cr);</a>
<a name="ln1232">                        Staff* staff = cr-&gt;staff();</a>
<a name="ln1233">                        int numStrings = staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln1234">                        for (int i = 6; i &gt;= 0; --i) {</a>
<a name="ln1235">                              if (strings &amp; (1 &lt;&lt; i) &amp;&amp; ((6-i) &lt; numStrings)) {</a>
<a name="ln1236">                                    Note* note = new Note(score);</a>
<a name="ln1237">                                    static_cast&lt;Chord*&gt;(cr)-&gt;add(note);</a>
<a name="ln1238">                                    readNote(6-i, note);</a>
<a name="ln1239">                                    note-&gt;setTpcFromPitch();</a>
<a name="ln1240">                                    }</a>
<a name="ln1241">                              }</a>
<a name="ln1242">                        restsForEmptyBeats(segment, measure, cr, l, track, fraction);</a>
<a name="ln1243">                        fraction += cr-&gt;actualTicks();</a>
<a name="ln1244">                        measureLen += cr-&gt;actualTicks();</a>
<a name="ln1245">                        }</a>
<a name="ln1246">                  if (measureLen &lt; measure-&gt;ticks()) {</a>
<a name="ln1247">                        score-&gt;setRest(fraction, track, measure-&gt;ticks() - measureLen, false, nullptr, false);</a>
<a name="ln1248">                        }</a>
<a name="ln1249">                  }</a>
<a name="ln1250">            if (bar == 1 &amp;&amp; !mixChange)</a>
<a name="ln1251">                  setTempo(temp, score-&gt;firstMeasure());</a>
<a name="ln1252">            }</a>
<a name="ln1253"> </a>
<a name="ln1254">      return true;</a>
<a name="ln1255">      }</a>
<a name="ln1256"> </a>
<a name="ln1257">//---------------------------------------------------------</a>
<a name="ln1258">//   setTempo</a>
<a name="ln1259">//---------------------------------------------------------</a>
<a name="ln1260"> </a>
<a name="ln1261">void GuitarPro::setTempo(int temp, Measure* measure)</a>
<a name="ln1262">      {</a>
<a name="ln1263">      if (!last_measure) {</a>
<a name="ln1264">            last_measure = measure;</a>
<a name="ln1265">            last_tempo = temp;</a>
<a name="ln1266">            }</a>
<a name="ln1267">      else if (last_measure == measure) {</a>
<a name="ln1268">            last_tempo = temp;</a>
<a name="ln1269">            }</a>
<a name="ln1270">      else {</a>
<a name="ln1271">            std::swap(last_tempo, temp);</a>
<a name="ln1272">            std::swap(last_measure, measure);</a>
<a name="ln1273"> </a>
<a name="ln1274">            Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln1275">            for (Element* e : segment-&gt;annotations()) {</a>
<a name="ln1276">                  if (e-&gt;isTempoText()) {</a>
<a name="ln1277">                        qDebug(&quot;already there&quot;);</a>
<a name="ln1278">                        return;</a>
<a name="ln1279">                        }</a>
<a name="ln1280">                  }</a>
<a name="ln1281"> </a>
<a name="ln1282">            TempoText* tt = new TempoText(score);</a>
<a name="ln1283">            tt-&gt;setTempo(double(temp) / 60.0);</a>
<a name="ln1284">            tt-&gt;setXmlText(QString(&quot;&lt;sym&gt;metNoteQuarterUp&lt;/sym&gt; = %1&quot;).arg(temp));</a>
<a name="ln1285">            tt-&gt;setTrack(0);</a>
<a name="ln1286"> </a>
<a name="ln1287">            segment-&gt;add(tt);</a>
<a name="ln1288">            score-&gt;setTempo(measure-&gt;tick(), tt-&gt;tempo());</a>
<a name="ln1289">            previousTempo = temp;</a>
<a name="ln1290">            }</a>
<a name="ln1291">      }</a>
<a name="ln1292"> </a>
<a name="ln1293">//---------------------------------------------------------</a>
<a name="ln1294">//   readChord</a>
<a name="ln1295">//---------------------------------------------------------</a>
<a name="ln1296"> </a>
<a name="ln1297">void GuitarPro::readChord(Segment* seg, int track, int numStrings, QString name, bool gpHeader)</a>
<a name="ln1298">      {</a>
<a name="ln1299">      int firstFret = readInt();</a>
<a name="ln1300">      if (firstFret || gpHeader) {</a>
<a name="ln1301">            FretDiagram* fret = new FretDiagram(score);</a>
<a name="ln1302">            fret-&gt;setTrack(track);</a>
<a name="ln1303">            fret-&gt;setStrings(numStrings);</a>
<a name="ln1304">            fret-&gt;setFretOffset(firstFret-1);</a>
<a name="ln1305">            for (int i = 0; i &lt; (gpHeader ? 7 : 6); ++i) {</a>
<a name="ln1306">                  int currentFret =  readInt();</a>
<a name="ln1307">                  // read the frets and add them to the fretboard</a>
<a name="ln1308">                  // subtract 1 extra from numStrings as we count from 0</a>
<a name="ln1309">                  if (i &gt; numStrings - 1) {</a>
<a name="ln1310">                        }</a>
<a name="ln1311">                  else if (currentFret &gt; 0) {</a>
<a name="ln1312">                        fret-&gt;setDot(numStrings - 1 - i, currentFret - firstFret + 1, true);</a>
<a name="ln1313">                        }</a>
<a name="ln1314">                  else if (currentFret == 0) {</a>
<a name="ln1315">                        fret-&gt;setDot(numStrings - 1 - i, 0, true);</a>
<a name="ln1316">                        fret-&gt;setMarker(numStrings - 1 - i, FretMarkerType::CIRCLE);</a>
<a name="ln1317">                        }</a>
<a name="ln1318">                  else if (currentFret == -1) {</a>
<a name="ln1319">                        fret-&gt;setDot(numStrings - 1 - i, 0, true);</a>
<a name="ln1320">                        fret-&gt;setMarker(numStrings - 1 - i, FretMarkerType::CROSS);</a>
<a name="ln1321">                        }</a>
<a name="ln1322">                  }</a>
<a name="ln1323">            seg-&gt;add(fret);</a>
<a name="ln1324">            if (!name.isEmpty()) {</a>
<a name="ln1325">                  Harmony* harmony = new Harmony(seg-&gt;score());</a>
<a name="ln1326">                  harmony-&gt;setHarmony(name);</a>
<a name="ln1327">                  harmony-&gt;setTrack(track);</a>
<a name="ln1328">                  fret-&gt;add(harmony);</a>
<a name="ln1329">                  }</a>
<a name="ln1330">            }</a>
<a name="ln1331">      else if (!name.isEmpty()) {</a>
<a name="ln1332">            Harmony* harmony = new Harmony(seg-&gt;score());</a>
<a name="ln1333">            harmony-&gt;setHarmony(name);</a>
<a name="ln1334">            harmony-&gt;setTrack(track);</a>
<a name="ln1335">            seg-&gt;add(harmony);</a>
<a name="ln1336">            }</a>
<a name="ln1337">      }</a>
<a name="ln1338"> </a>
<a name="ln1339">//---------------------------------------------------------</a>
<a name="ln1340">//   restsForEmptyBeats</a>
<a name="ln1341">//---------------------------------------------------------</a>
<a name="ln1342"> </a>
<a name="ln1343">void GuitarPro::restsForEmptyBeats(Segment* seg, Measure* measure, ChordRest* cr, Fraction&amp; l, int track, const Fraction&amp; tick)</a>
<a name="ln1344">      {</a>
<a name="ln1345">      /* this can happen as Guitar Pro versions 5 and below allows</a>
<a name="ln1346">       * users to create empty segments. Here, we create rests and</a>
<a name="ln1347">       * make them invisible so users get the same visual if they are</a>
<a name="ln1348">       * at a valid tick of the score. */</a>
<a name="ln1349">      if (seg-&gt;empty()) {</a>
<a name="ln1350">            if (tick &lt; measure-&gt;first()-&gt;tick() + measure-&gt;ticks()) {</a>
<a name="ln1351">                  cr = new Rest(score);</a>
<a name="ln1352">                  cr-&gt;setTrack(track);</a>
<a name="ln1353">                  TDuration d(l);</a>
<a name="ln1354">                  cr-&gt;setDurationType(d);</a>
<a name="ln1355">                  cr-&gt;setVisible(false);</a>
<a name="ln1356">                  seg-&gt;add(cr);</a>
<a name="ln1357">                  }</a>
<a name="ln1358">            else</a>
<a name="ln1359">                  measure-&gt;remove(seg);</a>
<a name="ln1360">            }</a>
<a name="ln1361">      }</a>
<a name="ln1362"> </a>
<a name="ln1363">//---------------------------------------------------------</a>
<a name="ln1364">//   createSlur</a>
<a name="ln1365">//---------------------------------------------------------</a>
<a name="ln1366"> </a>
<a name="ln1367">void GuitarPro::createSlur(bool hasSlur, int staffIdx, ChordRest* cr)</a>
<a name="ln1368">      {</a>
<a name="ln1369">      if (hasSlur &amp;&amp; (slurs[staffIdx] == 0)) {</a>
<a name="ln1370">            Slur* slur = new Slur(score);</a>
<a name="ln1371">            slur-&gt;setParent(0);</a>
<a name="ln1372">            slur-&gt;setTrack(cr-&gt;track());</a>
<a name="ln1373">            slur-&gt;setTrack2(cr-&gt;track());</a>
<a name="ln1374">            slur-&gt;setTick(cr-&gt;tick());</a>
<a name="ln1375">            slur-&gt;setTick2(cr-&gt;tick());</a>
<a name="ln1376">            slurs[staffIdx] = slur;</a>
<a name="ln1377">            score-&gt;addElement(slur);</a>
<a name="ln1378">            }</a>
<a name="ln1379">      else if (slurs[staffIdx] &amp;&amp; !hasSlur) {</a>
<a name="ln1380">            Slur* s = slurs[staffIdx];</a>
<a name="ln1381">            slurs[staffIdx] = 0;</a>
<a name="ln1382">            s-&gt;setTick2(cr-&gt;tick());</a>
<a name="ln1383">            s-&gt;setTrack2(cr-&gt;track());</a>
<a name="ln1384">            }</a>
<a name="ln1385">      }</a>
<a name="ln1386"> </a>
<a name="ln1387">//---------------------------------------------------------</a>
<a name="ln1388">//   createOttava</a>
<a name="ln1389">//---------------------------------------------------------</a>
<a name="ln1390"> </a>
<a name="ln1391">void GuitarPro::createOttava(bool hasOttava, int track, ChordRest* cr, QString value)</a>
<a name="ln1392">      {</a>
<a name="ln1393">      if (hasOttava &amp;&amp; (ottava.at(track) == 0)) {</a>
<a name="ln1394">            Ottava* newOttava = new Ottava(score);</a>
<a name="ln1395">            newOttava-&gt;setTrack(track);</a>
<a name="ln1396">            if (!value.compare(&quot;8va&quot;))</a>
<a name="ln1397">                  newOttava-&gt;setOttavaType(OttavaType::OTTAVA_8VA);</a>
<a name="ln1398">            else if (!value.compare(&quot;8vb&quot;))</a>
<a name="ln1399">                  newOttava-&gt;setOttavaType(OttavaType::OTTAVA_8VB);</a>
<a name="ln1400">            else if (!value.compare(&quot;15ma&quot;))</a>
<a name="ln1401">                  newOttava-&gt;setOttavaType(OttavaType::OTTAVA_15MA);</a>
<a name="ln1402">            else if (!value.compare(&quot;15mb&quot;))</a>
<a name="ln1403">                  newOttava-&gt;setOttavaType(OttavaType::OTTAVA_15MB);</a>
<a name="ln1404">            newOttava-&gt;setTick(cr-&gt;tick());</a>
<a name="ln1405">            /* we set the second tick when we encounter the next note</a>
<a name="ln1406">               without an ottava. We also allow the ottava to continue</a>
<a name="ln1407">               over rests, as that's what Guitar Pro does. */</a>
<a name="ln1408">            newOttava-&gt;setTick2(cr-&gt;tick());</a>
<a name="ln1409">            ottava.at(track) = newOttava;</a>
<a name="ln1410">            score-&gt;addElement(newOttava);</a>
<a name="ln1411">            }</a>
<a name="ln1412">      else if (ottava.at(track) &amp;&amp; !hasOttava) {</a>
<a name="ln1413">            Ottava* currentOttava = ottava.at(track);</a>
<a name="ln1414">            ottava.at(track) = 0;</a>
<a name="ln1415">            currentOttava-&gt;setTick2(cr-&gt;tick());</a>
<a name="ln1416">            //ottava.at(track)-&gt;staff()-&gt;updateOttava(ottava.at(track));</a>
<a name="ln1417">            }</a>
<a name="ln1418">      }</a>
<a name="ln1419"> </a>
<a name="ln1420">//---------------------------------------------------------</a>
<a name="ln1421">//   read</a>
<a name="ln1422">//---------------------------------------------------------</a>
<a name="ln1423"> </a>
<a name="ln1424">bool GuitarPro2::read(QFile* fp)</a>
<a name="ln1425">      {</a>
<a name="ln1426">      f      = fp;</a>
<a name="ln1427">      curPos = 30;</a>
<a name="ln1428"> </a>
<a name="ln1429">      title        = readDelphiString();</a>
<a name="ln1430">      subtitle     = readDelphiString();</a>
<a name="ln1431">      artist       = readDelphiString();</a>
<a name="ln1432">      album        = readDelphiString();</a>
<a name="ln1433">      composer     = readDelphiString();</a>
<a name="ln1434">      QString copyright = readDelphiString();</a>
<a name="ln1435">      if (!copyright.isEmpty())</a>
<a name="ln1436">            score-&gt;setMetaTag(&quot;copyright&quot;, QString(&quot;%1&quot;).arg(copyright));</a>
<a name="ln1437"> </a>
<a name="ln1438">      transcriber  = readDelphiString();</a>
<a name="ln1439">      instructions = readDelphiString();</a>
<a name="ln1440">      int n = readInt();</a>
<a name="ln1441">      for (int i = 0; i &lt; n; ++i)</a>
<a name="ln1442">            comments.append(readDelphiString());</a>
<a name="ln1443"> </a>
<a name="ln1444">      /*uchar num =*/ readUChar();      // Shuffle rhythm feel</a>
<a name="ln1445"> </a>
<a name="ln1446">      int temp = readInt();</a>
<a name="ln1447"> </a>
<a name="ln1448">      // int octave = 0;</a>
<a name="ln1449">      /*int key =*/ readInt();    // key</a>
<a name="ln1450"> </a>
<a name="ln1451">      for (int i = 0; i &lt; GP_MAX_TRACK_NUMBER * 2; ++i) {</a>
<a name="ln1452">            channelDefaults[i].patch   = readInt();</a>
<a name="ln1453">            channelDefaults[i].volume  = readUChar() * 8 - 1;</a>
<a name="ln1454">            channelDefaults[i].pan     = readUChar() * 8 - 1;</a>
<a name="ln1455">            channelDefaults[i].chorus  = readUChar() * 8 - 1;</a>
<a name="ln1456">            channelDefaults[i].reverb  = readUChar() * 8 - 1;</a>
<a name="ln1457">            channelDefaults[i].phase   = readUChar() * 8 - 1;</a>
<a name="ln1458">            channelDefaults[i].tremolo = readUChar() * 8 - 1;</a>
<a name="ln1459">            readUChar();      // padding</a>
<a name="ln1460">            readUChar();</a>
<a name="ln1461">            }</a>
<a name="ln1462">      measures   = readInt();</a>
<a name="ln1463">      staves = readInt();</a>
<a name="ln1464"> </a>
<a name="ln1465">      int tnumerator   = 4;</a>
<a name="ln1466">      int tdenominator = 4;</a>
<a name="ln1467">      for (int i = 0; i &lt; measures; ++i) {</a>
<a name="ln1468">            GpBar bar;</a>
<a name="ln1469">            uchar barBits = readUChar();</a>
<a name="ln1470">            if (barBits &amp; SCORE_TIMESIG_NUMERATOR)</a>
<a name="ln1471">                  tnumerator = readUChar();</a>
<a name="ln1472">            if (barBits &amp; SCORE_TIMESIG_DENOMINATOR)</a>
<a name="ln1473">                  tdenominator = readUChar();</a>
<a name="ln1474">            if (barBits &amp; SCORE_REPEAT_START)</a>
<a name="ln1475">                  bar.repeatFlags = bar.repeatFlags | Repeat::START;</a>
<a name="ln1476">            if (barBits &amp; SCORE_REPEAT_END) {</a>
<a name="ln1477">                  bar.repeatFlags = bar.repeatFlags | Repeat::END;</a>
<a name="ln1478">                  bar.repeats = readUChar() + 1;</a>
<a name="ln1479">                  }</a>
<a name="ln1480">            if (barBits &amp; SCORE_VOLTA) {</a>
<a name="ln1481">                  uchar voltaNumber = readUChar();</a>
<a name="ln1482">                  while (voltaNumber &gt; 0) {</a>
<a name="ln1483">                        // volta information is represented as a binary number</a>
<a name="ln1484">                        bar.volta.voltaType = GP_VOLTA_BINARY;</a>
<a name="ln1485">                        bar.volta.voltaInfo.append(voltaNumber &amp; 1);</a>
<a name="ln1486">                        voltaNumber &gt;&gt;= 1;</a>
<a name="ln1487">                        }</a>
<a name="ln1488">                  }</a>
<a name="ln1489">            if (barBits &amp; SCORE_MARKER) {</a>
<a name="ln1490">                  bar.marker = readDelphiString();     // new section?</a>
<a name="ln1491">                  /*int color =*/ readInt();    // color?</a>
<a name="ln1492">                  }</a>
<a name="ln1493">            if (barBits &amp; SCORE_KEYSIG) {</a>
<a name="ln1494">                  bar.keysig = readUChar();</a>
<a name="ln1495">                  /*uchar c    =*/ readUChar();        // minor</a>
<a name="ln1496">                  }</a>
<a name="ln1497">            if (barBits &amp; SCORE_DOUBLE_BAR)</a>
<a name="ln1498">                  bar.barLine = BarLineType::DOUBLE;</a>
<a name="ln1499">            bar.timesig = Fraction(tnumerator, tdenominator);</a>
<a name="ln1500">            bars.append(bar);</a>
<a name="ln1501">            }</a>
<a name="ln1502"> </a>
<a name="ln1503">      //</a>
<a name="ln1504">      // create a part for every staff</a>
<a name="ln1505">      //</a>
<a name="ln1506">      for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln1507">            Part* part = new Part(score);</a>
<a name="ln1508">            Staff* s = new Staff(score);</a>
<a name="ln1509">            s-&gt;setPart(part);</a>
<a name="ln1510">            part-&gt;insertStaff(s, 0);</a>
<a name="ln1511">            score-&gt;staves().push_back(s);</a>
<a name="ln1512">            score-&gt;appendPart(part);</a>
<a name="ln1513">            }</a>
<a name="ln1514"> </a>
<a name="ln1515">      Fraction ts;</a>
<a name="ln1516">      Fraction tick = {0, 1};</a>
<a name="ln1517">      for (int i = 0; i &lt; measures; ++i) {</a>
<a name="ln1518">            Fraction nts = bars[i].timesig;</a>
<a name="ln1519">            Measure* m = new Measure(score);</a>
<a name="ln1520">            m-&gt;setTick(tick);</a>
<a name="ln1521">            m-&gt;setTimesig(nts);</a>
<a name="ln1522">            m-&gt;setTicks(nts);</a>
<a name="ln1523"> </a>
<a name="ln1524">            if (i == 0 || ts != nts) {</a>
<a name="ln1525">                  for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln1526">                        TimeSig* t = new TimeSig(score);</a>
<a name="ln1527">                        t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1528">                        t-&gt;setSig(nts);</a>
<a name="ln1529">                        Segment* s = m-&gt;getSegment(SegmentType::TimeSig, tick);</a>
<a name="ln1530">                        s-&gt;add(t);</a>
<a name="ln1531">                        }</a>
<a name="ln1532">                  }</a>
<a name="ln1533"> </a>
<a name="ln1534">            score-&gt;measures()-&gt;add(m);</a>
<a name="ln1535">            tick += nts;</a>
<a name="ln1536">            ts = nts;</a>
<a name="ln1537">            }</a>
<a name="ln1538"> </a>
<a name="ln1539">      for (int i = 0; i &lt; staves; ++i) {</a>
<a name="ln1540">            int tuning[GP_MAX_STRING_NUMBER];</a>
<a name="ln1541"> </a>
<a name="ln1542">            uchar c      = readUChar();   // simulations bitmask</a>
<a name="ln1543">            if (c &amp; 0x2) {                // 12 stringed guitar</a>
<a name="ln1544">                  }</a>
<a name="ln1545">            if (c &amp; 0x4) {                // banjo track</a>
<a name="ln1546">                  }</a>
<a name="ln1547">            QString name = readPascalString(40);</a>
<a name="ln1548">            int strings  = readInt();</a>
<a name="ln1549">            if (strings &lt;= 0 || strings &gt; GP_MAX_STRING_NUMBER)</a>
<a name="ln1550">                  return false;</a>
<a name="ln1551">            for (int j = 0; j &lt; strings; ++j)</a>
<a name="ln1552">                  tuning[j] = readInt();</a>
<a name="ln1553">            for (int j = strings; j &lt; GP_MAX_STRING_NUMBER; ++j)</a>
<a name="ln1554">                  readInt();</a>
<a name="ln1555">            /*int midiPort     =*/ readInt(); //  - 1;</a>
<a name="ln1556">            int midiChannel  = readInt() - 1;</a>
<a name="ln1557">            /*int midiChannel2 =*/ readInt(); // - 1;</a>
<a name="ln1558">            int frets        = readInt();</a>
<a name="ln1559">            int capo         = readInt();</a>
<a name="ln1560">            /*int color        =*/ readInt();</a>
<a name="ln1561"> </a>
<a name="ln1562">            std::vector&lt;int&gt; tuning2(strings);</a>
<a name="ln1563">            //int tuning2[strings];</a>
<a name="ln1564">            for (int k = 0; k &lt; strings; ++k)</a>
<a name="ln1565">                  tuning2[strings-k-1] = tuning[k];</a>
<a name="ln1566">            StringData stringData(frets, strings, &amp;tuning2[0]);</a>
<a name="ln1567">            Part* part = score-&gt;staff(i)-&gt;part();</a>
<a name="ln1568">            Instrument* instr = part-&gt;instrument();</a>
<a name="ln1569">            instr-&gt;setStringData(stringData);</a>
<a name="ln1570">            instr-&gt;setSingleNoteDynamics(false);</a>
<a name="ln1571">            part-&gt;setPartName(name);</a>
<a name="ln1572">            part-&gt;setPlainLongName(name);</a>
<a name="ln1573">            createTuningString(strings, &amp;tuning2[0]);</a>
<a name="ln1574"> </a>
<a name="ln1575">            //</a>
<a name="ln1576">            // determine clef</a>
<a name="ln1577">            //</a>
<a name="ln1578">            Staff* staff = score-&gt;staff(i);</a>
<a name="ln1579">            int patch = channelDefaults[midiChannel].patch;</a>
<a name="ln1580">            ClefType clefId = ClefType::G;</a>
<a name="ln1581">            if (midiChannel == GP_DEFAULT_PERCUSSION_CHANNEL) {</a>
<a name="ln1582">                  clefId = ClefType::PERC;</a>
<a name="ln1583">                  // instr-&gt;setUseDrumset(DrumsetKind::GUITAR_PRO);</a>
<a name="ln1584">                  instr-&gt;setDrumset(gpDrumset);</a>
<a name="ln1585">                  staff-&gt;setStaffType(Fraction(0,1), *StaffType::preset(StaffTypes::PERC_DEFAULT));</a>
<a name="ln1586">                  }</a>
<a name="ln1587">            else</a>
<a name="ln1588">                  clefId = defaultClef(patch);</a>
<a name="ln1589">            Measure* measure = score-&gt;firstMeasure();</a>
<a name="ln1590">            Clef* clef = new Clef(score);</a>
<a name="ln1591">            clef-&gt;setClefType(clefId);</a>
<a name="ln1592">            clef-&gt;setTrack(i * VOICES);</a>
<a name="ln1593">            Segment* segment = measure-&gt;getSegment(SegmentType::HeaderClef, Fraction(0,1));</a>
<a name="ln1594">            segment-&gt;add(clef);</a>
<a name="ln1595"> </a>
<a name="ln1596">            if (capo &gt; 0) {</a>
<a name="ln1597">                  Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln1598">                  StaffText* st = new StaffText(score);</a>
<a name="ln1599">                  //                  st-&gt;setTextStyleType(TextStyleType::STAFF);</a>
<a name="ln1600">                  st-&gt;setPlainText(QString(&quot;Capo. fret &quot;) + QString::number(capo));</a>
<a name="ln1601">                  st-&gt;setTrack(i * VOICES);</a>
<a name="ln1602">                  s-&gt;add(st);</a>
<a name="ln1603">                  }</a>
<a name="ln1604"> </a>
<a name="ln1605">            Channel* ch = instr-&gt;channel(0);</a>
<a name="ln1606">            if (midiChannel == int(StaffTypes::PERC_DEFAULT)) {</a>
<a name="ln1607">                  ch-&gt;setProgram(0);</a>
<a name="ln1608">                  ch-&gt;setBank(128);</a>
<a name="ln1609">                  }</a>
<a name="ln1610">            else {</a>
<a name="ln1611">                  ch-&gt;setProgram(patch);</a>
<a name="ln1612">                  ch-&gt;setBank(0);</a>
<a name="ln1613">                  }</a>
<a name="ln1614">            ch-&gt;setVolume(channelDefaults[midiChannel].volume);</a>
<a name="ln1615">            ch-&gt;setPan(channelDefaults[midiChannel].pan);</a>
<a name="ln1616">            ch-&gt;setChorus(channelDefaults[midiChannel].chorus);</a>
<a name="ln1617">            ch-&gt;setReverb(channelDefaults[midiChannel].reverb);</a>
<a name="ln1618">            // missing: phase, tremolo</a>
<a name="ln1619">            }</a>
<a name="ln1620"> </a>
<a name="ln1621">      previousTempo = temp;</a>
<a name="ln1622">      Measure* measure = score-&gt;firstMeasure();</a>
<a name="ln1623">      bool mixChange = false;</a>
<a name="ln1624">      for (int bar = 0; bar &lt; measures; ++bar, measure = measure-&gt;nextMeasure()) {</a>
<a name="ln1625">            const GpBar&amp; gpbar = bars[bar];</a>
<a name="ln1626"> </a>
<a name="ln1627">            if (!gpbar.marker.isEmpty()) {</a>
<a name="ln1628">                  RehearsalMark* s = new RehearsalMark(score);</a>
<a name="ln1629">                  s-&gt;setPlainText(gpbar.marker.trimmed());</a>
<a name="ln1630">                  s-&gt;setTrack(0);</a>
<a name="ln1631">                  Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln1632">                  segment-&gt;add(s);</a>
<a name="ln1633">                  }</a>
<a name="ln1634"> </a>
<a name="ln1635">            std::vector&lt;Tuplet*&gt; tuplets(staves);</a>
<a name="ln1636">            // Tuplet* tuplets[staves];</a>
<a name="ln1637">            for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx)</a>
<a name="ln1638">                  tuplets[staffIdx] = 0;</a>
<a name="ln1639"> </a>
<a name="ln1640">            for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln1641">                  Fraction measureLen = {0,1};</a>
<a name="ln1642">                  int track = staffIdx * VOICES;</a>
<a name="ln1643">                  Fraction fraction = measure-&gt;tick();</a>
<a name="ln1644">                  int beats = readInt();</a>
<a name="ln1645">                  for (int beat = 0; beat &lt; beats; ++beat) {</a>
<a name="ln1646">                        //                        int pause = 0;</a>
<a name="ln1647">                        uchar beatBits = readUChar();</a>
<a name="ln1648">                        bool dotted = beatBits &amp; BEAT_DOTTED;</a>
<a name="ln1649">                        if (beatBits &amp; BEAT_PAUSE)</a>
<a name="ln1650">                              /*pause =*/ readUChar();</a>
<a name="ln1651">                        int len = readChar();</a>
<a name="ln1652">                        int tuple = 0;</a>
<a name="ln1653">                        if (beatBits &amp; BEAT_TUPLET)</a>
<a name="ln1654">                              tuple = readInt();</a>
<a name="ln1655">                        Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, fraction);</a>
<a name="ln1656">                        if (beatBits &amp; BEAT_CHORD) {</a>
<a name="ln1657">                              int numStrings = score-&gt;staff(staffIdx)-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln1658">                              int header = readUChar();</a>
<a name="ln1659">                              QString name;</a>
<a name="ln1660">                              if ((header &amp; 1) == 0) {</a>
<a name="ln1661">                                    name = readDelphiString();</a>
<a name="ln1662">                                    readChord(segment, track, numStrings, name, false);</a>
<a name="ln1663">                                    }</a>
<a name="ln1664">                              else  {</a>
<a name="ln1665">                                    skip(25);</a>
<a name="ln1666">                                    name = readPascalString(34);</a>
<a name="ln1667">                                    readChord(segment, track, numStrings, name, true);</a>
<a name="ln1668">                                    skip(36);</a>
<a name="ln1669">                                    }</a>
<a name="ln1670">                              }</a>
<a name="ln1671">                        Lyrics* lyrics = 0;</a>
<a name="ln1672">                        if (beatBits &amp; BEAT_LYRICS) {</a>
<a name="ln1673">                              QString txt = readDelphiString();</a>
<a name="ln1674">                              lyrics = new Lyrics(score);</a>
<a name="ln1675">                              lyrics-&gt;setPlainText(txt);</a>
<a name="ln1676">                              }</a>
<a name="ln1677">                        if (beatBits &amp; BEAT_EFFECTS)</a>
<a name="ln1678">                              readBeatEffects(track, segment);</a>
<a name="ln1679"> </a>
<a name="ln1680">                        if (beatBits &amp; BEAT_MIX_CHANGE) {</a>
<a name="ln1681">                              readMixChange(measure);</a>
<a name="ln1682">                              mixChange = true;</a>
<a name="ln1683">                              }</a>
<a name="ln1684"> </a>
<a name="ln1685">                        int strings = readUChar();   // used strings mask</a>
<a name="ln1686"> </a>
<a name="ln1687">                        Fraction l = len2fraction(len);</a>
<a name="ln1688">                        ChordRest* cr;</a>
<a name="ln1689">                        if (strings)</a>
<a name="ln1690">                              cr = new Chord(score);</a>
<a name="ln1691">                        else</a>
<a name="ln1692">                              cr = new Rest(score);</a>
<a name="ln1693">                        cr-&gt;setTrack(track);</a>
<a name="ln1694">                        if (lyrics)</a>
<a name="ln1695">                              cr-&gt;add(lyrics);</a>
<a name="ln1696"> </a>
<a name="ln1697">                        TDuration d(l);</a>
<a name="ln1698">                        d.setDots(dotted ? 1 : 0);</a>
<a name="ln1699"> </a>
<a name="ln1700">                        if (dotted)</a>
<a name="ln1701">                              l = l + (l * Fraction(1,2));</a>
<a name="ln1702"> </a>
<a name="ln1703">                        if (tuple) {</a>
<a name="ln1704">                              Tuplet* tuplet = tuplets[staffIdx];</a>
<a name="ln1705">                              if ((tuplet == 0) || (tuplet-&gt;elementsDuration() == tuplet-&gt;baseLen().fraction() * tuplet-&gt;ratio().numerator())) {</a>
<a name="ln1706">                                    tuplet = new Tuplet(score);</a>
<a name="ln1707">                                    tuplet-&gt;setTick(fraction);</a>
<a name="ln1708">                                    tuplet-&gt;setTrack(cr-&gt;track());</a>
<a name="ln1709">                                    tuplets[staffIdx] = tuplet;</a>
<a name="ln1710">                                    setTuplet(tuplet, tuple);</a>
<a name="ln1711">                                    tuplet-&gt;setParent(measure);</a>
<a name="ln1712">                                    }</a>
<a name="ln1713">                              tuplet-&gt;setTrack(track);</a>
<a name="ln1714">                              tuplet-&gt;setBaseLen(l);</a>
<a name="ln1715">                              tuplet-&gt;setTicks(l * tuplet-&gt;ratio().denominator());</a>
<a name="ln1716">                              cr-&gt;setTuplet(tuplet);</a>
<a name="ln1717">                              tuplet-&gt;add(cr);</a>
<a name="ln1718">                              }</a>
<a name="ln1719"> </a>
<a name="ln1720">                        cr-&gt;setTicks(l);</a>
<a name="ln1721">                        cr-&gt;setDurationType(d);</a>
<a name="ln1722">                        segment-&gt;add(cr);</a>
<a name="ln1723">                        Staff* staff = cr-&gt;staff();</a>
<a name="ln1724">                        int numStrings = staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln1725">                        for (int i = 6; i &gt;= 0; --i) {</a>
<a name="ln1726">                              if (strings &amp; (1 &lt;&lt; i) &amp;&amp; ((6-i) &lt; numStrings)) {</a>
<a name="ln1727">                                    Note* note = new Note(score);</a>
<a name="ln1728">                                    static_cast&lt;Chord*&gt;(cr)-&gt;add(note);</a>
<a name="ln1729">                                    readNote(6-i, note);</a>
<a name="ln1730">                                    note-&gt;setTpcFromPitch();</a>
<a name="ln1731">                                    }</a>
<a name="ln1732">                              }</a>
<a name="ln1733">                        restsForEmptyBeats(segment, measure, cr, l, track, fraction);</a>
<a name="ln1734">                        fraction += cr-&gt;actualTicks();</a>
<a name="ln1735">                        measureLen += cr-&gt;actualTicks();</a>
<a name="ln1736">                        }</a>
<a name="ln1737">                  if (measureLen &lt; measure-&gt;ticks()) {</a>
<a name="ln1738">                        score-&gt;setRest(fraction, track, measure-&gt;ticks() - measureLen, false, nullptr, false);</a>
<a name="ln1739">                        }</a>
<a name="ln1740">                  }</a>
<a name="ln1741">            if (bar == 1 &amp;&amp; !mixChange)</a>
<a name="ln1742">                  setTempo(temp, score-&gt;firstMeasure());</a>
<a name="ln1743">            }</a>
<a name="ln1744"> </a>
<a name="ln1745">      return true;</a>
<a name="ln1746">      }</a>
<a name="ln1747"> </a>
<a name="ln1748">//---------------------------------------------------------</a>
<a name="ln1749">//   readNote</a>
<a name="ln1750">//---------------------------------------------------------</a>
<a name="ln1751"> </a>
<a name="ln1752">bool GuitarPro1::readNote(int string, Note* note)</a>
<a name="ln1753">      {</a>
<a name="ln1754">      bool slur = false;</a>
<a name="ln1755">      uchar noteBits = readUChar();</a>
<a name="ln1756">      if (noteBits &amp; NOTE_GHOST) {</a>
<a name="ln1757">            if (version == 300)</a>
<a name="ln1758">                  note-&gt;setGhost(true);</a>
<a name="ln1759">            else {</a>
<a name="ln1760">                  note-&gt;setHeadGroup(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1761">                  note-&gt;setGhost(true);</a>
<a name="ln1762">                  }</a>
<a name="ln1763">            }</a>
<a name="ln1764"> </a>
<a name="ln1765">      bool tieNote = false;</a>
<a name="ln1766">      uchar variant = 1;</a>
<a name="ln1767">      if (noteBits &amp; NOTE_DEAD) {</a>
<a name="ln1768">            variant = readUChar();</a>
<a name="ln1769">            if (variant == 1) {     // normal note</a>
<a name="ln1770">                  }</a>
<a name="ln1771">            else if (variant == 2) {</a>
<a name="ln1772">                  tieNote = true;</a>
<a name="ln1773">                  }</a>
<a name="ln1774">            else if (variant == 3) {                 // dead notes</a>
<a name="ln1775">                  note-&gt;setHeadGroup(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1776">                  note-&gt;setGhost(true);</a>
<a name="ln1777">                  }</a>
<a name="ln1778">            else</a>
<a name="ln1779">                  qDebug(&quot;unknown note variant: %d&quot;, variant);</a>
<a name="ln1780">            }</a>
<a name="ln1781"> </a>
<a name="ln1782">      //</a>
<a name="ln1783">      // noteBits:</a>
<a name="ln1784">      //    7 - Right hand or left hand fingering;</a>
<a name="ln1785">      //    6 - Accentuated note</a>
<a name="ln1786">      //    5 - Note type (rest, empty note, normal note);</a>
<a name="ln1787">      //    4 - note dynamic;</a>
<a name="ln1788">      //    3 - Presence of effects linked to the note;</a>
<a name="ln1789">      //    2 - Ghost note;</a>
<a name="ln1790">      //    1 - Dotted note;  ?</a>
<a name="ln1791">      //    0 - Time-independent duration</a>
<a name="ln1792"> </a>
<a name="ln1793">      if (noteBits &amp; 0x1) {               // note != beat</a>
<a name="ln1794">            int a = readUChar();          // length</a>
<a name="ln1795">            int b = readUChar();          // t</a>
<a name="ln1796">            qDebug(&quot;Time independent note len, len %d t %d&quot;, a, b);</a>
<a name="ln1797">            }</a>
<a name="ln1798">      if (noteBits &amp; 0x2) {               // note is dotted</a>
<a name="ln1799">            //readUChar();</a>
<a name="ln1800">            }</a>
<a name="ln1801"> </a>
<a name="ln1802">      // set dynamic information on note if different from previous note</a>
<a name="ln1803">      if (noteBits &amp; NOTE_DYNAMIC) {</a>
<a name="ln1804">            int d = readChar();</a>
<a name="ln1805">            if (previousDynamic != d) {</a>
<a name="ln1806">                  previousDynamic = d;</a>
<a name="ln1807">                  addDynamic(note, d);</a>
<a name="ln1808">                  }</a>
<a name="ln1809">            }</a>
<a name="ln1810"> </a>
<a name="ln1811">      int fretNumber = -1;</a>
<a name="ln1812">      if (noteBits &amp; NOTE_FRET)</a>
<a name="ln1813">            fretNumber = readUChar();</a>
<a name="ln1814"> </a>
<a name="ln1815">      if (noteBits &amp; NOTE_FINGERING) {              // fingering</a>
<a name="ln1816">            int a = readUChar();</a>
<a name="ln1817">            int b = readUChar();</a>
<a name="ln1818">            qDebug(&quot;Fingering=========%d %d&quot;, a, b);</a>
<a name="ln1819">            }</a>
<a name="ln1820">      if (noteBits &amp; BEAT_EFFECTS) {</a>
<a name="ln1821">            uchar modMask1 = readUChar();</a>
<a name="ln1822">            uchar modMask2 = 0;</a>
<a name="ln1823">            if (version &gt;= 400)</a>
<a name="ln1824">                  modMask2 = readUChar();</a>
<a name="ln1825">            if (modMask1 &amp; EFFECT_BEND)</a>
<a name="ln1826">                  readBend(note);</a>
<a name="ln1827">            if (modMask1 &amp; EFFECT_GRACE) {</a>
<a name="ln1828">                  // GP3 grace note</a>
<a name="ln1829">                  int fret = readUChar();            // grace fret</a>
<a name="ln1830">                  int dynamic = readUChar();            // grace dynamic</a>
<a name="ln1831">                  int transition = readUChar();            // grace transition</a>
<a name="ln1832">                  int duration = readUChar();            // grace duration</a>
<a name="ln1833"> </a>
<a name="ln1834">                  int grace_len = MScore::division/8;</a>
<a name="ln1835">                  if (duration == 1)</a>
<a name="ln1836">                        grace_len = MScore::division/8; //32th</a>
<a name="ln1837">                  else if (duration == 2)</a>
<a name="ln1838">                        grace_len = MScore::division/6; //24th</a>
<a name="ln1839">                  else if (duration == 3)</a>
<a name="ln1840">                        grace_len = MScore::division/4; //16th</a>
<a name="ln1841">                  Note* gn = new Note(score);</a>
<a name="ln1842"> </a>
<a name="ln1843">                  if (fret == 255) {</a>
<a name="ln1844">                        gn-&gt;setHeadGroup(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1845">                        gn-&gt;setGhost(true);</a>
<a name="ln1846">                        }</a>
<a name="ln1847">                  if (fret == 255)</a>
<a name="ln1848">                        fret = 0;</a>
<a name="ln1849">                  gn-&gt;setFret(fret);</a>
<a name="ln1850">                  gn-&gt;setString(string);</a>
<a name="ln1851">                  int grace_pitch = note-&gt;staff()-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;getPitch(string, fret, nullptr, Fraction(0,1));</a>
<a name="ln1852">                  gn-&gt;setPitch(grace_pitch);</a>
<a name="ln1853">                  gn-&gt;setTpcFromPitch();</a>
<a name="ln1854"> </a>
<a name="ln1855">                  Chord* gc = nullptr;</a>
<a name="ln1856">                  if (note-&gt;chord()-&gt;graceNotes().size())</a>
<a name="ln1857">                        {</a>
<a name="ln1858">                        gc = note-&gt;chord()-&gt;graceNotes().first();</a>
<a name="ln1859">                        }</a>
<a name="ln1860">                  if (!gc)</a>
<a name="ln1861">                        {</a>
<a name="ln1862">                        gc = new Chord(score);</a>
<a name="ln1863">                        TDuration d;</a>
<a name="ln1864">                        d.setVal(grace_len);</a>
<a name="ln1865">                        if (grace_len == MScore::division / 6)</a>
<a name="ln1866">                              d.setDots(1);</a>
<a name="ln1867">                        gc-&gt;setDurationType(d);</a>
<a name="ln1868">                        gc-&gt;setTicks(d.fraction());</a>
<a name="ln1869">                        gc-&gt;setNoteType(NoteType::ACCIACCATURA);</a>
<a name="ln1870">                        gc-&gt;setMag(note-&gt;chord()-&gt;staff()-&gt;mag(Fraction(0,1)) * score-&gt;styleD(Sid::graceNoteMag));</a>
<a name="ln1871">                        note-&gt;chord()-&gt;add(gc); // sets parent + track</a>
<a name="ln1872">                        addDynamic(gn, dynamic);</a>
<a name="ln1873">                        }</a>
<a name="ln1874"> </a>
<a name="ln1875">                  gc-&gt;add(gn);</a>
<a name="ln1876"> </a>
<a name="ln1877">                  if (transition == 0) {</a>
<a name="ln1878">                        // no transition</a>
<a name="ln1879">                        }</a>
<a name="ln1880">                  else if(transition == 1){</a>
<a name="ln1881">                        //note-&gt;setSlideNote(gn);</a>
<a name="ln1882">                        Glissando* glis = new Glissando(score);</a>
<a name="ln1883">                        glis-&gt;setGlissandoType(GlissandoType::STRAIGHT);</a>
<a name="ln1884">                        gn-&gt;chord()-&gt;add(glis);</a>
<a name="ln1885">                        glis-&gt;setAnchor(Spanner::Anchor::NOTE);</a>
<a name="ln1886">                        glis-&gt;setStartElement(gn);</a>
<a name="ln1887">                        glis-&gt;setTick(gn-&gt;chord()-&gt;tick());</a>
<a name="ln1888">                        glis-&gt;setTrack(gn-&gt;track());</a>
<a name="ln1889">                        glis-&gt;setParent(gn);</a>
<a name="ln1890">                        glis-&gt;setEndElement(note);</a>
<a name="ln1891">                        glis-&gt;setTick2(note-&gt;chord()-&gt;tick());</a>
<a name="ln1892">                        glis-&gt;setTrack2(note-&gt;track());</a>
<a name="ln1893">                        score-&gt;addElement(glis);</a>
<a name="ln1894">                        //HammerOn here??? Maybe version...</a>
<a name="ln1895"> </a>
<a name="ln1896">                        Slur* slur1 = new Slur(score);</a>
<a name="ln1897">                        slur1-&gt;setStartElement(gc);</a>
<a name="ln1898">                        slur1-&gt;setEndElement(note-&gt;chord());</a>
<a name="ln1899">                        slur1-&gt;setTick(gc-&gt;tick());</a>
<a name="ln1900">                        slur1-&gt;setTick2(note-&gt;chord()-&gt;tick());</a>
<a name="ln1901">                        slur1-&gt;setTrack(gc-&gt;track());</a>
<a name="ln1902">                        slur1-&gt;setTrack2(note-&gt;track());</a>
<a name="ln1903">                        score-&gt;addElement(slur1);</a>
<a name="ln1904"> </a>
<a name="ln1905">                        //TODO: Add a 'slide' guitar effect when implemented</a>
<a name="ln1906">                        }</a>
<a name="ln1907">                  else if (transition == 2 &amp;&amp; fretNumber&gt;=0 &amp;&amp; fretNumber&lt;=255 &amp;&amp; fretNumber!=gn-&gt;fret()) {</a>
<a name="ln1908">                        /*QList&lt;PitchValue&gt; points;</a>
<a name="ln1909">                        points.append(PitchValue(0,0, false));</a>
<a name="ln1910">                        points.append(PitchValue(60,(fretNumber-gn-&gt;fret())*100, false));</a>
<a name="ln1911"> </a>
<a name="ln1912">                        Bend* b = new Bend(note-&gt;score());</a>
<a name="ln1913">                        b-&gt;setPoints(points);</a>
<a name="ln1914">                        b-&gt;setTrack(gn-&gt;track());</a>
<a name="ln1915">                        gn-&gt;add(b);*/</a>
<a name="ln1916">                        }</a>
<a name="ln1917">                  else if (transition == 3) {</a>
<a name="ln1918">                        // TODO:</a>
<a name="ln1919">                        //     major: replace with a 'hammer-on' guitar effect when implemented</a>
<a name="ln1920">                        //     minor: make slurs for parts</a>
<a name="ln1921"> </a>
<a name="ln1922">                        ChordRest* cr1 = static_cast&lt;Chord*&gt;(gc);</a>
<a name="ln1923">                        ChordRest* cr2 = static_cast&lt;Chord*&gt;(note-&gt;chord());</a>
<a name="ln1924"> </a>
<a name="ln1925">                        Slur* slur1 = new Slur(score);</a>
<a name="ln1926">                        slur1-&gt;setStartElement(cr1);</a>
<a name="ln1927">                        slur1-&gt;setEndElement(cr2);</a>
<a name="ln1928">                        slur1-&gt;setTick(cr1-&gt;tick());</a>
<a name="ln1929">                        slur1-&gt;setTick2(cr2-&gt;tick());</a>
<a name="ln1930">                        slur1-&gt;setTrack(cr1-&gt;track());</a>
<a name="ln1931">                        slur1-&gt;setTrack2(cr2-&gt;track());</a>
<a name="ln1932">                        score-&gt;addElement(slur1);</a>
<a name="ln1933">                        }</a>
<a name="ln1934">                  }</a>
<a name="ln1935">            if (modMask1 &amp; EFFECT_HAMMER)       // hammer on / pull off</a>
<a name="ln1936">                  slur = true;</a>
<a name="ln1937">            if (modMask1 &amp; EFFECT_LET_RING)     // let ring</a>
<a name="ln1938">                  addLetRing(note);</a>
<a name="ln1939">            if (modMask1 &amp; EFFECT_SLIDE_OLD)</a>
<a name="ln1940">                  slideList.push_back(note);</a>
<a name="ln1941"> </a>
<a name="ln1942">            if (version &gt;= 400) {</a>
<a name="ln1943">                  if (modMask2 &amp; EFFECT_STACATTO) {</a>
<a name="ln1944">                        }</a>
<a name="ln1945">                  if (modMask2 &amp; EFFECT_PALM_MUTE) {</a>
<a name="ln1946">                        //note-&gt;setPalmMute(true);</a>
<a name="ln1947">                        addPalmMute(note);</a>
<a name="ln1948">                        }</a>
<a name="ln1949">                  if (modMask2 &amp; EFFECT_TREMOLO) {</a>
<a name="ln1950">                        readUChar();</a>
<a name="ln1951">                        }</a>
<a name="ln1952">                  if (modMask2 &amp; EFFECT_ARTIFICIAL_HARMONIC) {</a>
<a name="ln1953">                        /*int type =*/  readUChar();</a>
<a name="ln1954">                        //TODO-ws			if (type == 1 || type == 4 || type == 5)</a>
<a name="ln1955">                        //				      note-&gt;setHarmonic(true);</a>
<a name="ln1956">                        }</a>
<a name="ln1957">                  if (modMask2 &amp; EFFECT_TRILL) {</a>
<a name="ln1958">                        //TODO-ws                        note-&gt;setTrillFret(readUChar());      // trill fret</a>
<a name="ln1959">                        readUChar();      // trill length</a>
<a name="ln1960">                        }</a>
<a name="ln1961">                  }</a>
<a name="ln1962">            }</a>
<a name="ln1963">      if (fretNumber == -1) {</a>
<a name="ln1964">            qDebug(&quot;Note: no fret number, tie %d&quot;, tieNote);</a>
<a name="ln1965">            }</a>
<a name="ln1966">      Staff* staff = note-&gt;staff();</a>
<a name="ln1967">      if (fretNumber == 255) {</a>
<a name="ln1968">            fretNumber = 0;</a>
<a name="ln1969">            note-&gt;setHeadGroup(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1970">            note-&gt;setGhost(true);</a>
<a name="ln1971">            }</a>
<a name="ln1972">      // dead note represented as high numbers - fix to zero</a>
<a name="ln1973">      if (fretNumber &gt; 99 || fretNumber == -1)</a>
<a name="ln1974">            fretNumber = 0;</a>
<a name="ln1975">      int pitch = staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;getPitch(string, fretNumber, nullptr, Fraction(0,1));</a>
<a name="ln1976"> </a>
<a name="ln1977">      /* it's possible to specify extraordinarily high pitches by</a>
<a name="ln1978">      specifying fret numbers that don't exist. This is an issue that</a>
<a name="ln1979">      comes from tuxguitar. Just set to maximum pitch. GP6 actually</a>
<a name="ln1980">      sets the fret number to 0 also, so that's what I've opted to do</a>
<a name="ln1981">      here. */</a>
<a name="ln1982">      if (pitch &gt; MAX_PITCH) {</a>
<a name="ln1983">            fretNumber = 0;</a>
<a name="ln1984">            pitch = MAX_PITCH;</a>
<a name="ln1985">            }</a>
<a name="ln1986"> </a>
<a name="ln1987">      note-&gt;setFret(fretNumber);</a>
<a name="ln1988">      note-&gt;setString(string);</a>
<a name="ln1989">      note-&gt;setPitch(pitch);</a>
<a name="ln1990"> </a>
<a name="ln1991">      if (tieNote) {</a>
<a name="ln1992">            bool found = false;</a>
<a name="ln1993">            Chord* chord     = note-&gt;chord();</a>
<a name="ln1994">            Segment* segment = chord-&gt;segment()-&gt;prev1(SegmentType::ChordRest);</a>
<a name="ln1995">            int track        = note-&gt;track();</a>
<a name="ln1996">            std::vector&lt;Chord*&gt; chords;</a>
<a name="ln1997">            Note* true_note = nullptr;</a>
<a name="ln1998">            while (segment) {</a>
<a name="ln1999">                  Element* e = segment-&gt;element(track);</a>
<a name="ln2000">                  if (e) {</a>
<a name="ln2001">                        if (e-&gt;isChord()) {</a>
<a name="ln2002">                              Chord* chord2 = toChord(e);</a>
<a name="ln2003">                              foreach (Note* note2, chord2-&gt;notes()) {</a>
<a name="ln2004">                                    if (note2-&gt;string() == string) {</a>
<a name="ln2005">                                          if (chords.empty()) {</a>
<a name="ln2006">                                                Tie* tie = new Tie(score);</a>
<a name="ln2007">                                                tie-&gt;setEndNote(note);</a>
<a name="ln2008">                                                note2-&gt;add(tie);</a>
<a name="ln2009">                                                }</a>
<a name="ln2010">                                          note-&gt;setFret(note2-&gt;fret());</a>
<a name="ln2011">                                          note-&gt;setPitch(note2-&gt;pitch());</a>
<a name="ln2012">                                          found = true;</a>
<a name="ln2013">                                          true_note = note2;</a>
<a name="ln2014">                                          break;</a>
<a name="ln2015">                                          }</a>
<a name="ln2016">                                    }</a>
<a name="ln2017">                              if (!found)</a>
<a name="ln2018">                                    chords.push_back(chord2);</a>
<a name="ln2019">                              }</a>
<a name="ln2020">                        if (found)</a>
<a name="ln2021">                              break;</a>
<a name="ln2022">                        }</a>
<a name="ln2023">                  segment = segment-&gt;prev1(SegmentType::ChordRest);</a>
<a name="ln2024">                  }</a>
<a name="ln2025"> </a>
<a name="ln2026">            if (chords.size() &amp;&amp; true_note) {</a>
<a name="ln2027">                  Note* end_note = note;</a>
<a name="ln2028">                  for (unsigned int i = 0; i &lt; chords.size(); ++i) {</a>
<a name="ln2029">                        Note* note2 = new Note(score);</a>
<a name="ln2030">                        note2-&gt;setString(true_note-&gt;string());</a>
<a name="ln2031">                        note2-&gt;setFret(true_note-&gt;fret());</a>
<a name="ln2032">                        note2-&gt;setPitch(true_note-&gt;pitch());</a>
<a name="ln2033">                        note2-&gt;setTpcFromPitch();</a>
<a name="ln2034">                        chords[i]-&gt;add(note2);</a>
<a name="ln2035">                        Tie* tie = new Tie(score);</a>
<a name="ln2036">                        tie-&gt;setEndNote(end_note);</a>
<a name="ln2037">                        end_note = note2;</a>
<a name="ln2038">                        note2-&gt;add(tie);</a>
<a name="ln2039">                        }</a>
<a name="ln2040">                  Tie* tie = new Tie(score);</a>
<a name="ln2041">                  tie-&gt;setEndNote(end_note);</a>
<a name="ln2042">                  true_note-&gt;add(tie);</a>
<a name="ln2043">                  }</a>
<a name="ln2044">            }</a>
<a name="ln2045">      return slur;</a>
<a name="ln2046">      }</a>
<a name="ln2047"> </a>
<a name="ln2048">//---------------------------------------------------------</a>
<a name="ln2049">//   readBeatEffects</a>
<a name="ln2050">//---------------------------------------------------------</a>
<a name="ln2051"> </a>
<a name="ln2052">int GuitarPro1::readBeatEffects(int, Segment*)</a>
<a name="ln2053">      {</a>
<a name="ln2054">      uchar fxBits1 = readUChar();</a>
<a name="ln2055">      if (fxBits1 &amp; BEAT_EFFECT) {</a>
<a name="ln2056">            uchar num = readUChar();</a>
<a name="ln2057">            switch(num) {</a>
<a name="ln2058">                  case 0:           // tremolo bar</a>
<a name="ln2059">                        readInt();</a>
<a name="ln2060">                        break;</a>
<a name="ln2061">                  default:</a>
<a name="ln2062">                        readInt();</a>
<a name="ln2063">                        break;</a>
<a name="ln2064">                  }</a>
<a name="ln2065">            }</a>
<a name="ln2066">      if (fxBits1 &amp; BEAT_ARPEGGIO) {</a>
<a name="ln2067">            readUChar();            // down stroke length</a>
<a name="ln2068">            readUChar();            // up stroke length</a>
<a name="ln2069">            }</a>
<a name="ln2070">      return 0;</a>
<a name="ln2071">      }</a>
<a name="ln2072"> </a>
<a name="ln2073">//---------------------------------------------------------</a>
<a name="ln2074">//   read</a>
<a name="ln2075">//---------------------------------------------------------</a>
<a name="ln2076"> </a>
<a name="ln2077">bool GuitarPro3::read(QFile* fp)</a>
<a name="ln2078">      {</a>
<a name="ln2079">      f      = fp;</a>
<a name="ln2080">      curPos = 30;</a>
<a name="ln2081"> </a>
<a name="ln2082">      title        = readDelphiString();</a>
<a name="ln2083">      subtitle     = readDelphiString();</a>
<a name="ln2084">      artist       = readDelphiString();</a>
<a name="ln2085">      album        = readDelphiString();</a>
<a name="ln2086">      composer     = readDelphiString();</a>
<a name="ln2087">      QString copyright = readDelphiString();</a>
<a name="ln2088">      if (!copyright.isEmpty())</a>
<a name="ln2089">            score-&gt;setMetaTag(&quot;copyright&quot;, QString(&quot;%1&quot;).arg(copyright));</a>
<a name="ln2090"> </a>
<a name="ln2091">      transcriber  = readDelphiString();</a>
<a name="ln2092">      instructions = readDelphiString();</a>
<a name="ln2093">      for (int i = 0, n = readInt(); i &lt; n; ++i)</a>
<a name="ln2094">            comments.append(readDelphiString());</a>
<a name="ln2095"> </a>
<a name="ln2096">      /*uchar num =*/ readUChar();      // Shuffle rhythm feel</a>
<a name="ln2097"> </a>
<a name="ln2098">      int temp = readInt();</a>
<a name="ln2099"> </a>
<a name="ln2100">      // int octave = 0;</a>
<a name="ln2101">      key = readInt();    // key</a>
<a name="ln2102"> </a>
<a name="ln2103">      for (int i = 0; i &lt; GP_MAX_TRACK_NUMBER * 2; ++i) {</a>
<a name="ln2104">            channelDefaults[i].patch   = readInt();</a>
<a name="ln2105">            channelDefaults[i].volume  = readUChar() * 8 - 1;</a>
<a name="ln2106">            channelDefaults[i].pan     = readUChar() * 8 - 1;</a>
<a name="ln2107">            channelDefaults[i].chorus  = readUChar() * 8 - 1;</a>
<a name="ln2108">            channelDefaults[i].reverb  = readUChar() * 8 - 1;</a>
<a name="ln2109">            channelDefaults[i].phase   = readUChar() * 8 - 1;</a>
<a name="ln2110">            channelDefaults[i].tremolo = readUChar() * 8 - 1;</a>
<a name="ln2111">            readUChar();      // padding</a>
<a name="ln2112">            readUChar();</a>
<a name="ln2113">            }</a>
<a name="ln2114">      measures   = readInt();</a>
<a name="ln2115">      staves = readInt();</a>
<a name="ln2116"> </a>
<a name="ln2117">      slurs = new Slur*[staves];</a>
<a name="ln2118">      for (int i = 0; i &lt; staves; ++i)</a>
<a name="ln2119">            slurs[i] = nullptr;</a>
<a name="ln2120"> </a>
<a name="ln2121">      //previousDynamic = new int [staves * VOICES];</a>
<a name="ln2122">      // initialise the dynamics to 0</a>
<a name="ln2123">      //for (int i = 0; i &lt; staves * VOICES; i++)</a>
<a name="ln2124">      //      previousDynamic[i] = 0;</a>
<a name="ln2125">      previousDynamic = -1;</a>
<a name="ln2126"> </a>
<a name="ln2127">      int tnumerator   = 4;</a>
<a name="ln2128">      int tdenominator = 4;</a>
<a name="ln2129">      for (int i = 0; i &lt; measures; ++i) {</a>
<a name="ln2130">            GpBar bar;</a>
<a name="ln2131">            uchar barBits = readUChar();</a>
<a name="ln2132">            if (barBits &amp; SCORE_TIMESIG_NUMERATOR)</a>
<a name="ln2133">                  tnumerator = readUChar();</a>
<a name="ln2134">            if (barBits &amp; SCORE_TIMESIG_DENOMINATOR)</a>
<a name="ln2135">                  tdenominator = readUChar();</a>
<a name="ln2136">            if (barBits &amp; SCORE_REPEAT_START)</a>
<a name="ln2137">                  bar.repeatFlags = bar.repeatFlags | Repeat::START;</a>
<a name="ln2138">            if (barBits &amp; SCORE_REPEAT_END) {                // number of repeats</a>
<a name="ln2139">                  bar.repeatFlags = bar.repeatFlags | Repeat::END;</a>
<a name="ln2140">                  bar.repeats = readUChar() + 1;</a>
<a name="ln2141">                  }</a>
<a name="ln2142">            if (barBits &amp; SCORE_VOLTA) {                      // a volta</a>
<a name="ln2143">                  uchar voltaNumber = readUChar();</a>
<a name="ln2144">                  // voltas are represented as a binary number</a>
<a name="ln2145">                  bar.volta.voltaType = GP_VOLTA_BINARY;</a>
<a name="ln2146">                  while (voltaNumber &gt; 0) {</a>
<a name="ln2147">                        bar.volta.voltaInfo.append(voltaNumber &amp; 1);</a>
<a name="ln2148">                        voltaNumber &gt;&gt;= 1;</a>
<a name="ln2149">                        }</a>
<a name="ln2150">                  }</a>
<a name="ln2151">            if (barBits &amp; SCORE_MARKER) {</a>
<a name="ln2152">                  bar.marker = readDelphiString();     // new section?</a>
<a name="ln2153">                  /*int color =*/ readInt();    // color?</a>
<a name="ln2154">                  }</a>
<a name="ln2155">            if (barBits &amp; SCORE_KEYSIG) {</a>
<a name="ln2156">                  int currentKey = readUChar();</a>
<a name="ln2157">                  /* key signatures are specified as</a>
<a name="ln2158">                   * 1# = 1, 2# = 2, ..., 7# = 7</a>
<a name="ln2159">                   * 1b = 255, 2b = 254, ... 7b = 249 */</a>
<a name="ln2160">                  bar.keysig = currentKey &lt;= 7 ? currentKey : -256+currentKey;</a>
<a name="ln2161">                  readUChar();        // specifies major/minor mode</a>
<a name="ln2162">                  }</a>
<a name="ln2163"> </a>
<a name="ln2164">            if (barBits &amp; SCORE_DOUBLE_BAR)</a>
<a name="ln2165">                  bar.barLine = BarLineType::DOUBLE;</a>
<a name="ln2166">            bar.timesig = Fraction(tnumerator, tdenominator);</a>
<a name="ln2167">            bars.append(bar);</a>
<a name="ln2168">            }</a>
<a name="ln2169"> </a>
<a name="ln2170">      //</a>
<a name="ln2171">      // create a part for every staff</a>
<a name="ln2172">      //</a>
<a name="ln2173">      for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln2174">            Part* part = new Part(score);</a>
<a name="ln2175">            Staff* s = new Staff(score);</a>
<a name="ln2176">            s-&gt;setPart(part);</a>
<a name="ln2177">            part-&gt;insertStaff(s, 0);</a>
<a name="ln2178">            score-&gt;staves().push_back(s);</a>
<a name="ln2179">            score-&gt;appendPart(part);</a>
<a name="ln2180">            }</a>
<a name="ln2181"> </a>
<a name="ln2182">      Fraction ts;</a>
<a name="ln2183">      Fraction tick = {0,1};</a>
<a name="ln2184">      for (int i = 0; i &lt; measures; ++i) {</a>
<a name="ln2185">            Fraction nts = bars[i].timesig;</a>
<a name="ln2186">            Measure* m = new Measure(score);</a>
<a name="ln2187">            m-&gt;setTick(tick);</a>
<a name="ln2188">            m-&gt;setTimesig(nts);</a>
<a name="ln2189">            m-&gt;setTicks(nts);</a>
<a name="ln2190"> </a>
<a name="ln2191">            if (i == 0 || ts != nts) {</a>
<a name="ln2192">                  for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln2193">                        TimeSig* t = new TimeSig(score);</a>
<a name="ln2194">                        t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2195">                        t-&gt;setSig(nts);</a>
<a name="ln2196">                        Segment* s = m-&gt;getSegment(SegmentType::TimeSig, tick);</a>
<a name="ln2197">                        s-&gt;add(t);</a>
<a name="ln2198">                        }</a>
<a name="ln2199">                  }</a>
<a name="ln2200">            if (i == 0 &amp;&amp; key) {</a>
<a name="ln2201">                  for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln2202">                        KeySig* t = new KeySig(score);</a>
<a name="ln2203">                        t-&gt;setKey(Key(key));</a>
<a name="ln2204">                        t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2205">                        Segment* s = m-&gt;getSegment(SegmentType::KeySig, tick);</a>
<a name="ln2206">                        s-&gt;add(t);</a>
<a name="ln2207">                        }</a>
<a name="ln2208">                  }</a>
<a name="ln2209"> </a>
<a name="ln2210">            readVolta(&amp;bars[i].volta, m);</a>
<a name="ln2211">            m-&gt;setRepeatEnd(bars[i].repeatFlags == Repeat::END);</a>
<a name="ln2212">            m-&gt;setRepeatStart(bars[i].repeatFlags == Repeat::START);</a>
<a name="ln2213">            m-&gt;setRepeatJump(bars[i].repeatFlags == Repeat::JUMP);</a>
<a name="ln2214">            //            m-&gt;setRepeatFlags(bars[i].repeatFlags);</a>
<a name="ln2215">            m-&gt;setRepeatCount(bars[i].repeats);</a>
<a name="ln2216"> </a>
<a name="ln2217">            // reset the volta sequence if we have an opening repeat</a>
<a name="ln2218">            if (bars[i].repeatFlags == Repeat::START)</a>
<a name="ln2219">                  voltaSequence = 1;</a>
<a name="ln2220">            // otherwise, if we see an end repeat symbol, only reset if the bar after it does not contain a volta</a>
<a name="ln2221">            else if (bars[i].repeatFlags == Repeat::END &amp;&amp; i &lt; bars.length() - 1) {</a>
<a name="ln2222">                  if (bars[i+1].volta.voltaInfo.length() == 0) {</a>
<a name="ln2223">                        voltaSequence = 1;</a>
<a name="ln2224">                        }</a>
<a name="ln2225">                  }</a>
<a name="ln2226"> </a>
<a name="ln2227">            score-&gt;measures()-&gt;add(m);</a>
<a name="ln2228">            tick += nts;</a>
<a name="ln2229">            ts = nts;</a>
<a name="ln2230">            }</a>
<a name="ln2231"> </a>
<a name="ln2232">      for (int i = 0; i &lt; staves; ++i) {</a>
<a name="ln2233">            int tuning[GP_MAX_STRING_NUMBER];</a>
<a name="ln2234"> </a>
<a name="ln2235">            uchar c      = readUChar();   // simulations bitmask</a>
<a name="ln2236">            if (c &amp; 0x2) {                // 12 stringed guitar</a>
<a name="ln2237">                  }</a>
<a name="ln2238">            if (c &amp; 0x4) {                // banjo track</a>
<a name="ln2239">                  }</a>
<a name="ln2240">            QString name = readPascalString(40);</a>
<a name="ln2241">            int strings  = readInt();</a>
<a name="ln2242">            if (strings &lt;= 0 || strings &gt; GP_MAX_STRING_NUMBER)</a>
<a name="ln2243">                  return false;</a>
<a name="ln2244">            for (int j = 0; j &lt; strings; ++j)</a>
<a name="ln2245">                  tuning[j] = readInt();</a>
<a name="ln2246">            for (int j = strings; j &lt; GP_MAX_STRING_NUMBER; ++j)</a>
<a name="ln2247">                  readInt();</a>
<a name="ln2248">            /*int midiPort     =*/ readInt(); // - 1;</a>
<a name="ln2249">            int midiChannel  = readInt() - 1;</a>
<a name="ln2250">            /*int midiChannel2 =*/ readInt(); // - 1;</a>
<a name="ln2251">            int frets        = readInt();</a>
<a name="ln2252">            int capo         = readInt();</a>
<a name="ln2253">            /*int color        =*/ readInt();</a>
<a name="ln2254"> </a>
<a name="ln2255">            std::vector&lt;int&gt; tuning2(strings);</a>
<a name="ln2256">            //int tuning2[strings];</a>
<a name="ln2257">            for (int k = 0; k &lt; strings; ++k)</a>
<a name="ln2258">                  tuning2[strings-k-1] = tuning[k];</a>
<a name="ln2259">            StringData stringData(frets, strings, &amp;tuning2[0]);</a>
<a name="ln2260">            Part* part = score-&gt;staff(i)-&gt;part();</a>
<a name="ln2261">            Instrument* instr = part-&gt;instrument();</a>
<a name="ln2262">            instr-&gt;setStringData(stringData);</a>
<a name="ln2263">            instr-&gt;setSingleNoteDynamics(false);</a>
<a name="ln2264">            part-&gt;setPartName(name);</a>
<a name="ln2265">            part-&gt;setPlainLongName(name);</a>
<a name="ln2266">            createTuningString(strings, &amp;tuning2[0]);</a>
<a name="ln2267">            //</a>
<a name="ln2268">            // determine clef</a>
<a name="ln2269">            //</a>
<a name="ln2270">            Staff* staff = score-&gt;staff(i);</a>
<a name="ln2271">            int patch = channelDefaults[midiChannel].patch;</a>
<a name="ln2272">            ClefType clefId = ClefType::G;</a>
<a name="ln2273">            if (midiChannel == GP_DEFAULT_PERCUSSION_CHANNEL) {</a>
<a name="ln2274">                  clefId = ClefType::PERC;</a>
<a name="ln2275">                  // instr-&gt;setUseDrumset(DrumsetKind::GUITAR_PRO);</a>
<a name="ln2276">                  instr-&gt;setDrumset(gpDrumset);</a>
<a name="ln2277">                  staff-&gt;setStaffType(Fraction(0,1), *StaffType::preset(StaffTypes::PERC_DEFAULT));</a>
<a name="ln2278">                  }</a>
<a name="ln2279">            else</a>
<a name="ln2280">                  clefId = defaultClef(patch);</a>
<a name="ln2281">            Measure* measure = score-&gt;firstMeasure();</a>
<a name="ln2282">            Clef* clef = new Clef(score);</a>
<a name="ln2283">            clef-&gt;setClefType(clefId);</a>
<a name="ln2284">            clef-&gt;setTrack(i * VOICES);</a>
<a name="ln2285">            Segment* segment = measure-&gt;getSegment(SegmentType::HeaderClef, Fraction(0,1));</a>
<a name="ln2286">            segment-&gt;add(clef);</a>
<a name="ln2287"> </a>
<a name="ln2288">            if (capo &gt; 0) {</a>
<a name="ln2289">                  Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln2290">                  StaffText* st = new StaffText(score);</a>
<a name="ln2291">                  //                  st-&gt;setTextStyleType(TextStyleType::STAFF);</a>
<a name="ln2292">                  st-&gt;setPlainText(QString(&quot;Capo. fret &quot;) + QString::number(capo));</a>
<a name="ln2293">                  st-&gt;setTrack(i * VOICES);</a>
<a name="ln2294">                  s-&gt;add(st);</a>
<a name="ln2295">                  }</a>
<a name="ln2296"> </a>
<a name="ln2297">            Channel* ch = instr-&gt;channel(0);</a>
<a name="ln2298">            if (midiChannel == GP_DEFAULT_PERCUSSION_CHANNEL) {</a>
<a name="ln2299">                  ch-&gt;setProgram(0);</a>
<a name="ln2300">                  ch-&gt;setBank(128);</a>
<a name="ln2301">                  }</a>
<a name="ln2302">            else {</a>
<a name="ln2303">                  ch-&gt;setProgram(patch);</a>
<a name="ln2304">                  ch-&gt;setBank(0);</a>
<a name="ln2305">                  }</a>
<a name="ln2306">            ch-&gt;setVolume(channelDefaults[midiChannel].volume);</a>
<a name="ln2307">            ch-&gt;setPan(channelDefaults[midiChannel].pan);</a>
<a name="ln2308">            ch-&gt;setChorus(channelDefaults[midiChannel].chorus);</a>
<a name="ln2309">            ch-&gt;setReverb(channelDefaults[midiChannel].reverb);</a>
<a name="ln2310">            // missing: phase, tremolo</a>
<a name="ln2311">            }</a>
<a name="ln2312"> </a>
<a name="ln2313">      previousTempo = temp;</a>
<a name="ln2314">      Measure* measure = score-&gt;firstMeasure();</a>
<a name="ln2315">      bool mixChange = false;</a>
<a name="ln2316">      for (int bar = 0; bar &lt; measures; ++bar, measure = measure-&gt;nextMeasure()) {</a>
<a name="ln2317">            const GpBar&amp; gpbar = bars[bar];</a>
<a name="ln2318"> </a>
<a name="ln2319">            if (!gpbar.marker.isEmpty()) {</a>
<a name="ln2320">                  RehearsalMark* s = new RehearsalMark(score);</a>
<a name="ln2321">                  s-&gt;setPlainText(gpbar.marker.trimmed());</a>
<a name="ln2322">                  s-&gt;setTrack(0);</a>
<a name="ln2323">                  Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln2324">                  segment-&gt;add(s);</a>
<a name="ln2325">                  }</a>
<a name="ln2326"> </a>
<a name="ln2327">            std::vector&lt;Tuplet*&gt; tuplets(staves);</a>
<a name="ln2328">            //Tuplet* tuplets[staves];</a>
<a name="ln2329">            for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx)</a>
<a name="ln2330">                  tuplets[staffIdx] = 0;</a>
<a name="ln2331"> </a>
<a name="ln2332">            for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln2333">                  Fraction measureLen = {0,1};</a>
<a name="ln2334">                  int track = staffIdx * VOICES;</a>
<a name="ln2335">                  Fraction fraction = measure-&gt;tick();</a>
<a name="ln2336">                  int beats = readInt();</a>
<a name="ln2337">                  if (beats &gt; 200)</a>
<a name="ln2338">                        return false;</a>
<a name="ln2339">                  for (int beat = 0; beat &lt; beats; ++beat) {</a>
<a name="ln2340">                        //                        int pause = 0;</a>
<a name="ln2341">                        uchar beatBits = readUChar();</a>
<a name="ln2342">                        bool dotted = beatBits &amp; BEAT_DOTTED;</a>
<a name="ln2343">                        if (beatBits &amp; BEAT_PAUSE)</a>
<a name="ln2344">                              /*pause =*/ readUChar();</a>
<a name="ln2345"> </a>
<a name="ln2346">                        slide = -1;</a>
<a name="ln2347">                        if (slides.contains(track))</a>
<a name="ln2348">                              slide = slides.take(track);</a>
<a name="ln2349"> </a>
<a name="ln2350">                        int len = readChar();</a>
<a name="ln2351">                        int tuple = 0;</a>
<a name="ln2352">                        if (beatBits &amp; BEAT_TUPLET)</a>
<a name="ln2353">                              tuple = readInt();</a>
<a name="ln2354"> </a>
<a name="ln2355">                        Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, fraction);</a>
<a name="ln2356">                        if (beatBits &amp; BEAT_CHORD) {</a>
<a name="ln2357">                              int numStrings = score-&gt;staff(staffIdx)-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln2358">                              int header = readUChar();</a>
<a name="ln2359">                              QString name;</a>
<a name="ln2360">                              if ((header &amp; 1) == 0) {</a>
<a name="ln2361">                                    name = readDelphiString();</a>
<a name="ln2362">                                    readChord(segment, track, numStrings, name, false);</a>
<a name="ln2363">                                    }</a>
<a name="ln2364">                              else  {</a>
<a name="ln2365">                                    skip(25);</a>
<a name="ln2366">                                    name = readPascalString(34);</a>
<a name="ln2367">                                    readChord(segment, track, numStrings, name, false);</a>
<a name="ln2368">                                    skip(36);</a>
<a name="ln2369">                                    }</a>
<a name="ln2370">                              }</a>
<a name="ln2371">                        Lyrics* lyrics = 0;</a>
<a name="ln2372">                        if (beatBits &amp; BEAT_LYRICS) {</a>
<a name="ln2373">                              QString txt = readDelphiString();</a>
<a name="ln2374">                              lyrics = new Lyrics(score);</a>
<a name="ln2375">                              lyrics-&gt;setPlainText(txt);</a>
<a name="ln2376">                              }</a>
<a name="ln2377">                        int beatEffects = 0;</a>
<a name="ln2378"> </a>
<a name="ln2379">                        if (beatBits &amp; BEAT_EFFECTS) {</a>
<a name="ln2380">                              beatEffects = readBeatEffects(track, segment);</a>
<a name="ln2381">                              }</a>
<a name="ln2382">                        bool vibrato = beatEffects &amp; 0x1 || beatEffects &amp; 0x2;</a>
<a name="ln2383"> </a>
<a name="ln2384">                        if (beatBits &amp; BEAT_MIX_CHANGE) {</a>
<a name="ln2385">                              readMixChange(measure);</a>
<a name="ln2386">                              mixChange = true;</a>
<a name="ln2387">                              }</a>
<a name="ln2388"> </a>
<a name="ln2389">                        int strings = readUChar();   // used strings mask</a>
<a name="ln2390"> </a>
<a name="ln2391">                        Fraction l = len2fraction(len);</a>
<a name="ln2392"> </a>
<a name="ln2393">                        // Some beat effects could add a Chord before this</a>
<a name="ln2394">                        ChordRest* cr = segment-&gt;cr(track);</a>
<a name="ln2395">                        // if (!pause || strings)</a>
<a name="ln2396">                        if (strings) {</a>
<a name="ln2397">                              if(!segment-&gt;cr(track))</a>
<a name="ln2398">                                    cr = new Chord(score);</a>
<a name="ln2399">                              }</a>
<a name="ln2400">                        else</a>
<a name="ln2401">                              {</a>
<a name="ln2402">                              if(segment-&gt;cr(track)){</a>
<a name="ln2403">                                    segment-&gt;remove(segment-&gt;cr(track));</a>
<a name="ln2404">                                    delete cr;</a>
<a name="ln2405">                                    cr = 0;</a>
<a name="ln2406">                                    }</a>
<a name="ln2407">                              cr = new Rest(score);</a>
<a name="ln2408">                              }</a>
<a name="ln2409"> </a>
<a name="ln2410">                        cr-&gt;setTrack(track);</a>
<a name="ln2411">                        if (lyrics)</a>
<a name="ln2412">                              cr-&gt;add(lyrics);</a>
<a name="ln2413"> </a>
<a name="ln2414">                        TDuration d(l);</a>
<a name="ln2415">                        d.setDots(dotted ? 1 : 0);</a>
<a name="ln2416"> </a>
<a name="ln2417">                        if (dotted)</a>
<a name="ln2418">                              l = l + (l * Fraction(1,2));</a>
<a name="ln2419"> </a>
<a name="ln2420">                        if (tuple) {</a>
<a name="ln2421">                              Tuplet* tuplet = tuplets[staffIdx];</a>
<a name="ln2422">                              if ((tuplet == 0) || (tuplet-&gt;elementsDuration() == tuplet-&gt;baseLen().fraction() * tuplet-&gt;ratio().numerator())) {</a>
<a name="ln2423">                                    tuplet = new Tuplet(score);</a>
<a name="ln2424">                                    tuplet-&gt;setTick(fraction);</a>
<a name="ln2425">                                    tuplet-&gt;setTrack(cr-&gt;track());</a>
<a name="ln2426">                                    tuplets[staffIdx] = tuplet;</a>
<a name="ln2427">                                    setTuplet(tuplet, tuple);</a>
<a name="ln2428">                                    tuplet-&gt;setParent(measure);</a>
<a name="ln2429">                                    }</a>
<a name="ln2430">                              tuplet-&gt;setTrack(track);</a>
<a name="ln2431">                              tuplet-&gt;setBaseLen(l);</a>
<a name="ln2432">                              tuplet-&gt;setTicks(l * tuplet-&gt;ratio().denominator());</a>
<a name="ln2433">                              cr-&gt;setTuplet(tuplet);</a>
<a name="ln2434">                              tuplet-&gt;add(cr);</a>
<a name="ln2435">                              }</a>
<a name="ln2436"> </a>
<a name="ln2437">                        cr-&gt;setTicks(l);</a>
<a name="ln2438"> </a>
<a name="ln2439">                        if (cr-&gt;type() == ElementType::REST &amp;&amp; l &gt;= measure-&gt;ticks()) {</a>
<a name="ln2440">                              cr-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln2441">                              cr-&gt;setTicks(measure-&gt;ticks());</a>
<a name="ln2442">                              }</a>
<a name="ln2443">                        else</a>
<a name="ln2444">                              cr-&gt;setDurationType(d);</a>
<a name="ln2445"> </a>
<a name="ln2446">                        if(!segment-&gt;cr(track))</a>
<a name="ln2447">                              segment-&gt;add(cr);</a>
<a name="ln2448"> </a>
<a name="ln2449">                        Staff* staff = cr-&gt;staff();</a>
<a name="ln2450">                        int numStrings = staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln2451">                        bool hasSlur = false;</a>
<a name="ln2452">                        for (int i = 6; i &gt;= 0; --i) {</a>
<a name="ln2453">                              if (strings &amp; (1 &lt;&lt; i) &amp;&amp; ((6-i) &lt; numStrings)) {</a>
<a name="ln2454">                                    Note* note = new Note(score);</a>
<a name="ln2455">                                    toChord(cr)-&gt;add(note);</a>
<a name="ln2456">                                    if (vibrato)</a>
<a name="ln2457">                                          addVibrato(note);</a>
<a name="ln2458">                                    if (dotted) {</a>
<a name="ln2459">                                          NoteDot* dot = new NoteDot(score);</a>
<a name="ln2460">                                          // there is at most one dotted note in this guitar pro version - set 0 index</a>
<a name="ln2461">                                          dot-&gt;setParent(note);</a>
<a name="ln2462">                                          dot-&gt;setTrack(track);  // needed to know the staff it belongs to (and detect tablature)</a>
<a name="ln2463">                                          dot-&gt;setVisible(true);</a>
<a name="ln2464">                                          note-&gt;add(dot);</a>
<a name="ln2465">                                          }</a>
<a name="ln2466">                                    hasSlur = (readNote(6-i, note) || hasSlur);</a>
<a name="ln2467">                                    note-&gt;setTpcFromPitch();</a>
<a name="ln2468">                                    }</a>
<a name="ln2469">                              }</a>
<a name="ln2470">                        if (cr &amp;&amp; cr-&gt;type() == ElementType::CHORD &amp;&amp; static_cast&lt;Chord*&gt;(cr)-&gt;notes().empty()) {</a>
<a name="ln2471">                              if (segment-&gt;cr(track))</a>
<a name="ln2472">                                    segment-&gt;remove(cr);</a>
<a name="ln2473">                              delete cr;</a>
<a name="ln2474">                              cr = new Rest(score);</a>
<a name="ln2475">                              cr-&gt;setTicks(l);</a>
<a name="ln2476">                              cr-&gt;setTrack(track);</a>
<a name="ln2477">                              cr-&gt;setDurationType(d);</a>
<a name="ln2478">                              segment-&gt;add(cr);</a>
<a name="ln2479">                              }</a>
<a name="ln2480">                        createSlur(hasSlur, staffIdx, cr);</a>
<a name="ln2481">                        if (cr &amp;&amp; (cr-&gt;isChord())) {</a>
<a name="ln2482">                              if (beatEffects &gt;= 200) {</a>
<a name="ln2483">                                    beatEffects -= 200;</a>
<a name="ln2484">                                    Articulation* art = new Articulation(score);</a>
<a name="ln2485">                                    art-&gt;setSymId(SymId::guitarFadeOut);</a>
<a name="ln2486">                                    art-&gt;setAnchor(ArticulationAnchor::TOP_STAFF);</a>
<a name="ln2487">                                    art-&gt;setPropertyFlags(Pid::ARTICULATION_ANCHOR, PropertyFlags::UNSTYLED);</a>
<a name="ln2488">                                    if (!score-&gt;addArticulation(cr, art)) {</a>
<a name="ln2489">                                          delete art;</a>
<a name="ln2490">                                          }</a>
<a name="ln2491">                                    }</a>
<a name="ln2492"> </a>
<a name="ln2493">                              applyBeatEffects(static_cast&lt;Chord*&gt;(cr), beatEffects);</a>
<a name="ln2494">                              if (slide &gt; 0)</a>
<a name="ln2495">                                    createSlide(slide, cr, staffIdx);</a>
<a name="ln2496">                              }</a>
<a name="ln2497"> </a>
<a name="ln2498">                        restsForEmptyBeats(segment, measure, cr, l, track, fraction);</a>
<a name="ln2499">                        fraction += cr-&gt;actualTicks();</a>
<a name="ln2500">                        measureLen += cr-&gt;actualTicks();</a>
<a name="ln2501">                        }</a>
<a name="ln2502">                  if (measureLen &lt; measure-&gt;ticks()) {</a>
<a name="ln2503">                        score-&gt;setRest(fraction, track, measure-&gt;ticks() - measureLen, false, nullptr, false);</a>
<a name="ln2504">                        }</a>
<a name="ln2505">                  bool removeRests = true;</a>
<a name="ln2506">                  int counter = 0;</a>
<a name="ln2507">                  Rest* lastRest = nullptr;</a>
<a name="ln2508">                  for (auto seg = measure-&gt;first(); seg; seg = seg-&gt;next())</a>
<a name="ln2509">                        {</a>
<a name="ln2510">                        if (seg-&gt;segmentType() == SegmentType::ChordRest)</a>
<a name="ln2511">                              {</a>
<a name="ln2512">                              auto cr = seg-&gt;cr(track);</a>
<a name="ln2513">                              if (cr &amp;&amp; cr-&gt;type() == ElementType::CHORD)</a>
<a name="ln2514">                                    {</a>
<a name="ln2515">                                    removeRests = false;</a>
<a name="ln2516">                                    break;</a>
<a name="ln2517">                                    }</a>
<a name="ln2518">                              else if (cr) {</a>
<a name="ln2519">                                    ++counter;</a>
<a name="ln2520">                                    lastRest = static_cast&lt;Rest*&gt;(cr);</a>
<a name="ln2521">                                    }</a>
<a name="ln2522">                              }</a>
<a name="ln2523">                        }</a>
<a name="ln2524">                  if (removeRests &amp;&amp; counter &lt; 2) {</a>
<a name="ln2525">                        removeRests = false;</a>
<a name="ln2526">                        if (counter == 1)</a>
<a name="ln2527">                              {</a>
<a name="ln2528">                              lastRest-&gt;setTicks(measure-&gt;timesig());</a>
<a name="ln2529">                              lastRest-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln2530">                              }</a>
<a name="ln2531">                        }</a>
<a name="ln2532">                  if (removeRests)</a>
<a name="ln2533">                        {</a>
<a name="ln2534">                        auto seg = measure-&gt;first();</a>
<a name="ln2535">                        while (seg &amp;&amp; seg != measure-&gt;last())</a>
<a name="ln2536">                              {</a>
<a name="ln2537">                              if (seg-&gt;segmentType() == SegmentType::ChordRest)</a>
<a name="ln2538">                                    {</a>
<a name="ln2539">                                    auto cr = seg-&gt;cr(track);</a>
<a name="ln2540">                                    if (cr) {</a>
<a name="ln2541">                                          seg-&gt;remove(cr);</a>
<a name="ln2542">                                          delete cr;</a>
<a name="ln2543">                                          }</a>
<a name="ln2544">                                    }</a>
<a name="ln2545">                              seg = seg-&gt;next();</a>
<a name="ln2546">                              }</a>
<a name="ln2547">                        auto cr = new Rest(score);</a>
<a name="ln2548">                        cr-&gt;setTicks(measure-&gt;timesig());</a>
<a name="ln2549">                        cr-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln2550">                        cr-&gt;setTrack(track);</a>
<a name="ln2551">                        seg-&gt;add(cr);</a>
<a name="ln2552">                        }</a>
<a name="ln2553">                  }</a>
<a name="ln2554">            if (bar == 1 &amp;&amp; !mixChange)</a>
<a name="ln2555">                  setTempo(temp, score-&gt;firstMeasure());</a>
<a name="ln2556">            }</a>
<a name="ln2557">      for (auto n : slideList) {</a>
<a name="ln2558">            auto segment = n-&gt;chord()-&gt;segment();</a>
<a name="ln2559">            auto measure1 = segment-&gt;measure();</a>
<a name="ln2560">            while ((segment = segment-&gt;next1(SegmentType::ChordRest)) || ((measure1 = measure1-&gt;nextMeasure()) &amp;&amp; (segment = measure1-&gt;first()))) {</a>
<a name="ln2561">                  // bool br = false;</a>
<a name="ln2562">                  auto crest = segment-&gt;cr(n-&gt;track());</a>
<a name="ln2563">                  if (!crest)</a>
<a name="ln2564">                        continue;</a>
<a name="ln2565">                  if (crest-&gt;type() == Ms::ElementType::REST)</a>
<a name="ln2566">                        break;</a>
<a name="ln2567">                  auto cr = static_cast&lt;Chord*&gt;(crest);</a>
<a name="ln2568">                  if (!cr)</a>
<a name="ln2569">                        continue;</a>
<a name="ln2570">                  if (cr-&gt;graceNotes().size())</a>
<a name="ln2571">                        cr = cr-&gt;graceNotes().first();</a>
<a name="ln2572">                  if (cr) {</a>
<a name="ln2573">                        for (auto nt : cr-&gt;notes()) {</a>
<a name="ln2574">                              if (nt-&gt;string() == n-&gt;string()) {</a>
<a name="ln2575">                                    // auto mg = nt-&gt;magS();</a>
<a name="ln2576">                                    Glissando* s = new Glissando(score);</a>
<a name="ln2577">                                    s-&gt;setAnchor(Spanner::Anchor::NOTE);</a>
<a name="ln2578">                                    s-&gt;setStartElement(n);</a>
<a name="ln2579">                                    s-&gt;setTick(n-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln2580">                                    s-&gt;setTrack(n-&gt;track());</a>
<a name="ln2581">                                    s-&gt;setParent(n);</a>
<a name="ln2582">                                    s-&gt;setGlissandoType(GlissandoType::STRAIGHT);</a>
<a name="ln2583">                                    s-&gt;setEndElement(nt);</a>
<a name="ln2584">                                    s-&gt;setTick2(cr-&gt;segment()-&gt;tick());</a>
<a name="ln2585">                                    s-&gt;setTrack2(n-&gt;track());</a>
<a name="ln2586">                                    score-&gt;addElement(s);</a>
<a name="ln2587">                                    break;</a>
<a name="ln2588">                                    }</a>
<a name="ln2589">                              }</a>
<a name="ln2590">                        }</a>
<a name="ln2591">                  break;</a>
<a name="ln2592">                  }</a>
<a name="ln2593">            }</a>
<a name="ln2594">      return true;</a>
<a name="ln2595">      }</a>
<a name="ln2596"> </a>
<a name="ln2597">//---------------------------------------------------------</a>
<a name="ln2598">//   readBeatEffects</a>
<a name="ln2599">//---------------------------------------------------------</a>
<a name="ln2600"> </a>
<a name="ln2601">int GuitarPro3::readBeatEffects(int track, Segment* segment)</a>
<a name="ln2602">      {</a>
<a name="ln2603">      int effects = 0;</a>
<a name="ln2604">      uchar fxBits = readUChar();</a>
<a name="ln2605"> </a>
<a name="ln2606">      if (fxBits &amp; BEAT_EFFECT) {</a>
<a name="ln2607">            effects = readUChar();      // effect 1-tapping, 2-slapping, 3-popping</a>
<a name="ln2608">            readInt(); // we don't need this integer</a>
<a name="ln2609">            }</a>
<a name="ln2610"> </a>
<a name="ln2611">      if (fxBits &amp; BEAT_ARPEGGIO) {</a>
<a name="ln2612">            int strokeup = readUChar();            // up stroke length</a>
<a name="ln2613">            int strokedown = readUChar();            // down stroke length</a>
<a name="ln2614"> </a>
<a name="ln2615">            Arpeggio* a = new Arpeggio(score);</a>
<a name="ln2616">            if ( strokeup &gt; 0 ) {</a>
<a name="ln2617">                  a-&gt;setArpeggioType(ArpeggioType::UP_STRAIGHT);</a>
<a name="ln2618">                  }</a>
<a name="ln2619">            else if( strokedown &gt; 0 ) {</a>
<a name="ln2620">                  a-&gt;setArpeggioType(ArpeggioType::DOWN_STRAIGHT);</a>
<a name="ln2621">                  }</a>
<a name="ln2622">            else {</a>
<a name="ln2623">                  delete a;</a>
<a name="ln2624">                  a = 0;</a>
<a name="ln2625">                  }</a>
<a name="ln2626"> </a>
<a name="ln2627">            if(a) {</a>
<a name="ln2628">                  ChordRest* cr = new Chord(score);</a>
<a name="ln2629">                  cr-&gt;setTrack(track);</a>
<a name="ln2630">                  cr-&gt;add(a);</a>
<a name="ln2631">                  segment-&gt;add(cr);</a>
<a name="ln2632">                  }</a>
<a name="ln2633">            }</a>
<a name="ln2634">      if (fxBits &amp; BEAT_TREMOLO) {</a>
<a name="ln2635">            }</a>
<a name="ln2636">      if (fxBits &amp; BEAT_FADE) {</a>
<a name="ln2637">#if 0</a>
<a name="ln2638">            Articulation* art = new Articulation(score);</a>
<a name="ln2639">            // art-&gt;setArticulationType(ArticulationType::FadeOut);</a>
<a name="ln2640">            art-&gt;setSym(SymId::guitarFadeOut);</a>
<a name="ln2641">            art-&gt;setAnchor(ArticulationAnchor::TOP_STAFF);</a>
<a name="ln2642">            art-&gt;setPropertyFlags(Pid::ARTICULATION_ANCHOR, PropertyFlags::UNSTYLED);</a>
<a name="ln2643">            if (!score-&gt;addArticulation(segment-&gt;cr(track), art)) {</a>
<a name="ln2644">                  delete art;</a>
<a name="ln2645">                  }</a>
<a name="ln2646">#endif</a>
<a name="ln2647">            effects += 200;</a>
<a name="ln2648">            }</a>
<a name="ln2649">      if (fxBits &amp; BEAT_DOTTED) {</a>
<a name="ln2650">            }</a>
<a name="ln2651">      if (fxBits &amp; BEAT_CHORD) {</a>
<a name="ln2652">            }</a>
<a name="ln2653">      if (effects == 0)</a>
<a name="ln2654">            return fxBits;</a>
<a name="ln2655">      return effects;</a>
<a name="ln2656">      }</a>
<a name="ln2657"> </a>
<a name="ln2658">//---------------------------------------------------------</a>
<a name="ln2659">//   readTremoloBar</a>
<a name="ln2660">//---------------------------------------------------------</a>
<a name="ln2661"> </a>
<a name="ln2662">void GuitarPro::readTremoloBar(int /*track*/, Segment* /*segment*/)</a>
<a name="ln2663">      {</a>
<a name="ln2664">      /*int a1 =*/ readChar();</a>
<a name="ln2665">      /*int a2 =*/ readChar();</a>
<a name="ln2666">      /*int a3 =*/ readChar();</a>
<a name="ln2667">      /*int a4 =*/ readChar();</a>
<a name="ln2668">      /*int a5 =*/ readChar();</a>
<a name="ln2669">      int n  =  readInt();</a>
<a name="ln2670">      QList&lt;PitchValue&gt; points;</a>
<a name="ln2671">      for (int i = 0; i &lt; n; ++i) {</a>
<a name="ln2672">            int time    = readInt();</a>
<a name="ln2673">            int pitch   = readInt();</a>
<a name="ln2674">            int vibrato = readUChar();</a>
<a name="ln2675">            points.append(PitchValue(time, pitch, vibrato));</a>
<a name="ln2676">            }</a>
<a name="ln2677">#if 0</a>
<a name="ln2678">      //TODO</a>
<a name="ln2679">      TremoloBar* b = new TremoloBar(segment-&gt;score());</a>
<a name="ln2680">      b-&gt;setPoints(points);</a>
<a name="ln2681">      b-&gt;setTrack(track);</a>
<a name="ln2682">      segment-&gt;add(b);</a>
<a name="ln2683">#endif</a>
<a name="ln2684">      }</a>
<a name="ln2685"> </a>
<a name="ln2686">//---------------------------------------------------------</a>
<a name="ln2687">//   createCrecDim</a>
<a name="ln2688">//---------------------------------------------------------</a>
<a name="ln2689"> </a>
<a name="ln2690">void GuitarPro::createCrecDim(int staffIdx, int track, const Fraction&amp; tick, bool crec)</a>
<a name="ln2691">      {</a>
<a name="ln2692">      hairpins[staffIdx] = new Hairpin(score);</a>
<a name="ln2693">      if (crec)</a>
<a name="ln2694">            hairpins[staffIdx]-&gt;setHairpinType(HairpinType::CRESC_HAIRPIN);</a>
<a name="ln2695">      else</a>
<a name="ln2696">            hairpins[staffIdx]-&gt;setHairpinType(HairpinType::DECRESC_HAIRPIN);</a>
<a name="ln2697">      hairpins[staffIdx]-&gt;setTick(tick);</a>
<a name="ln2698">      hairpins[staffIdx]-&gt;setTick2(tick);</a>
<a name="ln2699">      hairpins[staffIdx]-&gt;setTrack(track);</a>
<a name="ln2700">      hairpins[staffIdx]-&gt;setTrack(track);</a>
<a name="ln2701">      score-&gt;undoAddElement(hairpins[staffIdx]);</a>
<a name="ln2702">      }</a>
<a name="ln2703"> </a>
<a name="ln2704">//---------------------------------------------------------</a>
<a name="ln2705">//   importGTP</a>
<a name="ln2706">//---------------------------------------------------------</a>
<a name="ln2707"> </a>
<a name="ln2708">Score::FileError importGTP(MasterScore* score, const QString&amp; name)</a>
<a name="ln2709">      {</a>
<a name="ln2710">      QFile fp(name);</a>
<a name="ln2711">      if (!fp.exists())</a>
<a name="ln2712">            return Score::FileError::FILE_NOT_FOUND;</a>
<a name="ln2713">      if (!fp.open(QIODevice::ReadOnly))</a>
<a name="ln2714">            return Score::FileError::FILE_OPEN_ERROR;</a>
<a name="ln2715"> </a>
<a name="ln2716">      char header[5];</a>
<a name="ln2717">      fp.read(header, 4);</a>
<a name="ln2718">      header[4] = 0;</a>
<a name="ln2719">      fp.seek(0);</a>
<a name="ln2720">      if (name.endsWith(&quot;.ptb&quot;, Qt::CaseInsensitive) || strcmp(header, &quot;ptab&quot;) == 0) {</a>
<a name="ln2721">            PowerTab ptb(&amp;fp, score);</a>
<a name="ln2722">            return ptb.read();</a>
<a name="ln2723">            }</a>
<a name="ln2724"> </a>
<a name="ln2725">      GuitarPro* gp;</a>
<a name="ln2726">      bool readResult = false;</a>
<a name="ln2727">      // check to see if we are dealing with a GPX file via the extension</a>
<a name="ln2728">      if (name.endsWith(&quot;.gpx&quot;, Qt::CaseInsensitive) || strcmp(header, &quot;BCFZ&quot;) == 0) {</a>
<a name="ln2729">            gp = new GuitarPro6(score);</a>
<a name="ln2730">            gp-&gt;initGuitarProDrumset();</a>
<a name="ln2731">            readResult = gp-&gt;read(&amp;fp);</a>
<a name="ln2732">            gp-&gt;setTempo(0, 0);</a>
<a name="ln2733">            }</a>
<a name="ln2734">      // otherwise it's an older version - check the header</a>
<a name="ln2735">      else  if (strcmp(&amp;header[1], &quot;FIC&quot;) == 0) {</a>
<a name="ln2736">            uchar l;</a>
<a name="ln2737">            fp.read((char*)&amp;l, 1);</a>
<a name="ln2738">            char ss[30];</a>
<a name="ln2739">            fp.read(ss, 30);</a>
<a name="ln2740">            ss[l] = 0;</a>
<a name="ln2741">            QString s(ss);</a>
<a name="ln2742">            if (s.startsWith(&quot;FICHIER GUITAR PRO &quot;))</a>
<a name="ln2743">                  s = s.mid(20);</a>
<a name="ln2744">            else if (s.startsWith(&quot;FICHIER GUITARE PRO &quot;))</a>
<a name="ln2745">                  s = s.mid(21);</a>
<a name="ln2746">            else {</a>
<a name="ln2747">                  qDebug(&quot;unknown gtp format &lt;%s&gt;&quot;, ss);</a>
<a name="ln2748">                  return Score::FileError::FILE_BAD_FORMAT;</a>
<a name="ln2749">                  }</a>
<a name="ln2750">            int a = s.left(1).toInt();</a>
<a name="ln2751">            int b = s.mid(2).toInt();</a>
<a name="ln2752">            int version = a * 100 + b;</a>
<a name="ln2753">            if (a == 1)</a>
<a name="ln2754">                  gp = new GuitarPro1(score, version);</a>
<a name="ln2755">            else if (a == 2)</a>
<a name="ln2756">                  gp = new GuitarPro2(score, version);</a>
<a name="ln2757">            else if (a == 3)</a>
<a name="ln2758">                  gp = new GuitarPro3(score, version);</a>
<a name="ln2759">            else if (a == 4)</a>
<a name="ln2760">                  gp = new GuitarPro4(score, version);</a>
<a name="ln2761">            else if (a == 5)</a>
<a name="ln2762">                  gp = new GuitarPro5(score, version);</a>
<a name="ln2763">            else {</a>
<a name="ln2764">                  qDebug(&quot;unknown gtp format %d&quot;, version);</a>
<a name="ln2765">                  return Score::FileError::FILE_BAD_FORMAT;</a>
<a name="ln2766">                  }</a>
<a name="ln2767">            gp-&gt;initGuitarProDrumset();</a>
<a name="ln2768">            readResult = gp-&gt;read(&amp;fp);</a>
<a name="ln2769">            gp-&gt;setTempo(0, 0);</a>
<a name="ln2770">            }</a>
<a name="ln2771">      else {</a>
<a name="ln2772">            return Score::FileError::FILE_BAD_FORMAT;</a>
<a name="ln2773">            }</a>
<a name="ln2774">      if (readResult == false) {</a>
<a name="ln2775">            /*if (!MScore::noGui) {</a>
<a name="ln2776">                  QMessageBox::warning(0,</a>
<a name="ln2777">                     QWidget::tr(&quot;Import Guitar Pro&quot;),</a>
<a name="ln2778">                     QWidget::tr(&quot;Load failed: %1&quot;).arg(gp-&gt;error(errNo)),</a>
<a name="ln2779">                     QString::null, QWidget::tr(&quot;Quit&quot;), QString::null, 0, 1);</a>
<a name="ln2780">                  }*/</a>
<a name="ln2781">            qDebug(&quot;guitar pro import error====&quot;);</a>
<a name="ln2782">            // avoid another error message box</a>
<a name="ln2783">            return Score::FileError::FILE_NO_ERROR;</a>
<a name="ln2784">            }</a>
<a name="ln2785"> </a>
<a name="ln2786">      score-&gt;style().set(Sid::ArpeggioHiddenInStdIfTab, true);</a>
<a name="ln2787"> </a>
<a name="ln2788">      MeasureBase* m;</a>
<a name="ln2789">      if (!score-&gt;measures()-&gt;first()) {</a>
<a name="ln2790">            m = new VBox(score);</a>
<a name="ln2791">            m-&gt;setTick(Fraction(0,1));</a>
<a name="ln2792">            score-&gt;addMeasure(m, 0);</a>
<a name="ln2793">            }</a>
<a name="ln2794">      else  {</a>
<a name="ln2795">            m = score-&gt;measures()-&gt;first();</a>
<a name="ln2796">            if (!m-&gt;isVBox()) {</a>
<a name="ln2797">                  MeasureBase* mb = new VBox(score);</a>
<a name="ln2798">                  mb-&gt;setTick(Fraction(0,1));</a>
<a name="ln2799">                  score-&gt;addMeasure(mb, m);</a>
<a name="ln2800">                  m = mb;</a>
<a name="ln2801">                  }</a>
<a name="ln2802">            }</a>
<a name="ln2803">      if (!gp-&gt;title.isEmpty()) {</a>
<a name="ln2804">            Text* s = new Text(score, Tid::TITLE);</a>
<a name="ln2805">            s-&gt;setPlainText(gp-&gt;title);</a>
<a name="ln2806">            m-&gt;add(s);</a>
<a name="ln2807">            }</a>
<a name="ln2808">      if (!gp-&gt;subtitle.isEmpty()|| !gp-&gt;artist.isEmpty() || !gp-&gt;album.isEmpty()) {</a>
<a name="ln2809">            Text* s = new Text(score, Tid::SUBTITLE);</a>
<a name="ln2810">            QString str;</a>
<a name="ln2811">            if (!gp-&gt;subtitle.isEmpty())</a>
<a name="ln2812">                  str.append(gp-&gt;subtitle);</a>
<a name="ln2813">            if (!gp-&gt;artist.isEmpty()) {</a>
<a name="ln2814">                  if (!str.isEmpty())</a>
<a name="ln2815">                        str.append(&quot;\n&quot;);</a>
<a name="ln2816">                  str.append(gp-&gt;artist);</a>
<a name="ln2817">                  }</a>
<a name="ln2818">            if (!gp-&gt;album.isEmpty()) {</a>
<a name="ln2819">                  if (!str.isEmpty())</a>
<a name="ln2820">                        str.append(&quot;\n&quot;);</a>
<a name="ln2821">                  str.append(gp-&gt;album);</a>
<a name="ln2822">                  }</a>
<a name="ln2823">            s-&gt;setPlainText(str);</a>
<a name="ln2824">            m-&gt;add(s);</a>
<a name="ln2825">            }</a>
<a name="ln2826">      if (!gp-&gt;composer.isEmpty()) {</a>
<a name="ln2827">            Text* s = new Text(score, Tid::COMPOSER);</a>
<a name="ln2828">            s-&gt;setPlainText(gp-&gt;composer);</a>
<a name="ln2829">            m-&gt;add(s);</a>
<a name="ln2830">            }</a>
<a name="ln2831">      int idx = 0;</a>
<a name="ln2832"> </a>
<a name="ln2833">      for (Measure* m1 = score-&gt;firstMeasure(); m1; m1 = m1-&gt;nextMeasure(), ++idx) {</a>
<a name="ln2834">            const GpBar&amp; bar = gp-&gt;bars[idx];</a>
<a name="ln2835">            if (bar.barLine != BarLineType::NORMAL &amp;&amp; bar.barLine != BarLineType::END_REPEAT &amp;&amp; bar.barLine != BarLineType::START_REPEAT &amp;&amp; bar.barLine != BarLineType::END_START_REPEAT)</a>
<a name="ln2836">                  m1-&gt;setEndBarLineType(bar.barLine, 0);</a>
<a name="ln2837">            }</a>
<a name="ln2838">      if (score-&gt;lastMeasure() &amp;&amp; score-&gt;lastMeasure()-&gt;endBarLineType() != BarLineType::NORMAL)</a>
<a name="ln2839">            score-&gt;lastMeasure()-&gt;setEndBarLineType(BarLineType::END, false);</a>
<a name="ln2840"> </a>
<a name="ln2841">      //</a>
<a name="ln2842">      // create parts (excerpts)</a>
<a name="ln2843">      //</a>
<a name="ln2844">      std::vector&lt;Part*&gt; infoParts;</a>
<a name="ln2845">      for (Part* part : score-&gt;parts()) {</a>
<a name="ln2846">            const QString&amp; longName = part-&gt;longName();</a>
<a name="ln2847">            if (!longName.isEmpty() &amp;&amp; longName[0] == '@') {</a>
<a name="ln2848">                  infoParts.push_back(part);</a>
<a name="ln2849">                  continue;</a>
<a name="ln2850">                  }</a>
<a name="ln2851">            QMultiMap&lt;int, int&gt; tracks;</a>
<a name="ln2852">            Score* pscore = new Score(score);</a>
<a name="ln2853">            //TODO-ws		pscore-&gt;showLyrics = score-&gt;showLyrics;</a>
<a name="ln2854">            pscore-&gt;style().set(Sid::createMultiMeasureRests, false);</a>
<a name="ln2855">            pscore-&gt;style().set(Sid::ArpeggioHiddenInStdIfTab, true);</a>
<a name="ln2856"> </a>
<a name="ln2857">            QList&lt;int&gt; stavesMap;</a>
<a name="ln2858">            Part*   p = new Part(pscore);</a>
<a name="ln2859">            p-&gt;setInstrument(*part-&gt;instrument());</a>
<a name="ln2860">            //TODO-ws		pscore-&gt;tuning = gp-&gt;tunings[counter++];</a>
<a name="ln2861"> </a>
<a name="ln2862">            Staff* staff = part-&gt;staves()-&gt;front();</a>
<a name="ln2863"> </a>
<a name="ln2864">            Staff* s = new Staff(pscore);</a>
<a name="ln2865">            s-&gt;setPart(p);</a>
<a name="ln2866">            const StaffType* st = staff-&gt;constStaffType(Fraction(0,1));</a>
<a name="ln2867">            s-&gt;setStaffType(Fraction(0,1), *st);</a>
<a name="ln2868"> </a>
<a name="ln2869">            s-&gt;linkTo(staff);</a>
<a name="ln2870">            p-&gt;staves()-&gt;append(s);</a>
<a name="ln2871">            pscore-&gt;staves().append(s);</a>
<a name="ln2872">            stavesMap.append(staff-&gt;idx());</a>
<a name="ln2873"> </a>
<a name="ln2874">            for (int i = staff-&gt;idx() * VOICES, j = 0; i &lt; staff-&gt;idx() * VOICES + VOICES; i++, j++)</a>
<a name="ln2875">                  tracks.insert(i, j);</a>
<a name="ln2876"> </a>
<a name="ln2877">            Excerpt* excerpt = new Excerpt(score);</a>
<a name="ln2878">            excerpt-&gt;setTracks(tracks);</a>
<a name="ln2879">            excerpt-&gt;setPartScore(pscore);</a>
<a name="ln2880">            pscore-&gt;setExcerpt(excerpt);</a>
<a name="ln2881">            excerpt-&gt;setTitle(part-&gt;partName());</a>
<a name="ln2882">            excerpt-&gt;parts().append(part);</a>
<a name="ln2883">            score-&gt;excerpts().append(excerpt);</a>
<a name="ln2884"> </a>
<a name="ln2885">            Excerpt::cloneStaves(score, pscore, stavesMap, tracks);</a>
<a name="ln2886"> </a>
<a name="ln2887">            if (staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings() &gt; 0</a>
<a name="ln2888">               &amp;&amp; part-&gt;staves()-&gt;front()-&gt;constStaffType(Fraction(0,1))-&gt;group() == StaffGroup::STANDARD) {</a>
<a name="ln2889">                  p-&gt;setStaves(2);</a>
<a name="ln2890">                  Staff* s1 = p-&gt;staff(1);</a>
<a name="ln2891"> </a>
<a name="ln2892">                  int lines = staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln2893">                  StaffTypes sts = StaffTypes::TAB_DEFAULT;</a>
<a name="ln2894">                  if (lines == 4)</a>
<a name="ln2895">                        sts = StaffTypes::TAB_4COMMON;</a>
<a name="ln2896">                  StaffType st1 = *StaffType::preset(sts);</a>
<a name="ln2897">                  s1-&gt;setStaffType(Fraction(0,1), st1);</a>
<a name="ln2898">                  s1-&gt;setLines(Fraction(0,1), lines);</a>
<a name="ln2899">                  Excerpt::cloneStaff(s,s1);</a>
<a name="ln2900">                  p-&gt;staves()-&gt;front()-&gt;addBracket(new BracketItem(pscore, BracketType::NORMAL, 2));</a>
<a name="ln2901">                  }</a>
<a name="ln2902">            pscore-&gt;appendPart(p);</a>
<a name="ln2903"> </a>
<a name="ln2904">            //</a>
<a name="ln2905">            // create excerpt title</a>
<a name="ln2906">            //</a>
<a name="ln2907">            MeasureBase* measure = pscore-&gt;first();</a>
<a name="ln2908">            if (!measure || (measure-&gt;type() != ElementType::VBOX)) {</a>
<a name="ln2909">                  MeasureBase* mb = new VBox(pscore);</a>
<a name="ln2910">                  mb-&gt;setTick(Fraction(0,1));</a>
<a name="ln2911">                  pscore-&gt;addMeasure(mb, measure);</a>
<a name="ln2912">                  measure = mb;</a>
<a name="ln2913">                  }</a>
<a name="ln2914">            Text* txt = new Text(pscore, Tid::INSTRUMENT_EXCERPT);</a>
<a name="ln2915">            txt-&gt;setPlainText(part-&gt;longName());</a>
<a name="ln2916">            measure-&gt;add(txt);</a>
<a name="ln2917"> </a>
<a name="ln2918">            //</a>
<a name="ln2919">            // layout score</a>
<a name="ln2920">            //</a>
<a name="ln2921">            pscore-&gt;setPlaylistDirty();</a>
<a name="ln2922">            pscore-&gt;setLayoutAll();</a>
<a name="ln2923">            pscore-&gt;addLayoutFlags(LayoutFlag::FIX_PITCH_VELO);</a>
<a name="ln2924">            //            pscore-&gt;doLayout();</a>
<a name="ln2925">            }</a>
<a name="ln2926"> </a>
<a name="ln2927">      for (auto p : infoParts) {</a>
<a name="ln2928">            auto staff = p-&gt;staves()-&gt;back();</a>
<a name="ln2929">            score-&gt;removeStaff(staff);</a>
<a name="ln2930">            score-&gt;removePart(p);</a>
<a name="ln2931">            delete staff;</a>
<a name="ln2932">            delete p;</a>
<a name="ln2933">            }</a>
<a name="ln2934">      //      score-&gt;rebuildMidiMapping();</a>
<a name="ln2935">      //      score-&gt;updateChannel();</a>
<a name="ln2936">      //      album</a>
<a name="ln2937">      //      copyright</a>
<a name="ln2938"> </a>
<a name="ln2939">      score-&gt;setCreated(true);</a>
<a name="ln2940">      delete gp;</a>
<a name="ln2941"> </a>
<a name="ln2942">      return Score::FileError::FILE_NO_ERROR;</a>
<a name="ln2943">      }</a>
<a name="ln2944">}</a>
<a name="ln2945"> </a>

</code></pre>
<div class="balloon" rel="245"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v779/" target="_blank">V779</a> Unreachable code detected. It is possible that an error is present.</p></div>
<div class="balloon" rel="1351"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v763/" target="_blank">V763</a> Parameter 'cr' is always rewritten in function body before being used.</p></div>
<div class="balloon" rel="1907"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: fretNumber <= 255.</p></div>
<div class="balloon" rel="1847"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 1843, 1847.</p></div>
<div class="balloon" rel="2499"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'cr' pointer was used unsafely after it was verified against nullptr. Check lines: 2481, 2499.</p></div>
<div class="balloon" rel="2444"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'cr' pointer was utilized before it was verified against nullptr. Check lines: 2444, 2470.</p></div>
<div class="balloon" rel="2568"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!cr' is always false.</p></div>
<div class="balloon" rel="2747"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="2783"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The function was exited without releasing the 'gp' pointer. A memory leak is possible.</p></div>
<div class="balloon" rel="85"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: freeTime, volta.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
