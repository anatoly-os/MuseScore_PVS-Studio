
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qmap.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2016 The Qt Company Ltd.</a>
<a name="ln4">** Contact: https://www.qt.io/licensing/</a>
<a name="ln5">**</a>
<a name="ln6">** This file is part of the QtCore module of the Qt Toolkit.</a>
<a name="ln7">**</a>
<a name="ln8">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln9">** Commercial License Usage</a>
<a name="ln10">** Licensees holding valid commercial Qt licenses may use this file in</a>
<a name="ln11">** accordance with the commercial license agreement provided with the</a>
<a name="ln12">** Software or, alternatively, in accordance with the terms contained in</a>
<a name="ln13">** a written agreement between you and The Qt Company. For licensing terms</a>
<a name="ln14">** and conditions see https://www.qt.io/terms-conditions. For further</a>
<a name="ln15">** information use the contact form at https://www.qt.io/contact-us.</a>
<a name="ln16">**</a>
<a name="ln17">** GNU Lesser General Public License Usage</a>
<a name="ln18">** Alternatively, this file may be used under the terms of the GNU Lesser</a>
<a name="ln19">** General Public License version 3 as published by the Free Software</a>
<a name="ln20">** Foundation and appearing in the file LICENSE.LGPL3 included in the</a>
<a name="ln21">** packaging of this file. Please review the following information to</a>
<a name="ln22">** ensure the GNU Lesser General Public License version 3 requirements</a>
<a name="ln23">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</a>
<a name="ln24">**</a>
<a name="ln25">** GNU General Public License Usage</a>
<a name="ln26">** Alternatively, this file may be used under the terms of the GNU</a>
<a name="ln27">** General Public License version 2.0 or (at your option) the GNU General</a>
<a name="ln28">** Public license version 3 or any later version approved by the KDE Free</a>
<a name="ln29">** Qt Foundation. The licenses are as published by the Free Software</a>
<a name="ln30">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</a>
<a name="ln31">** included in the packaging of this file. Please review the following</a>
<a name="ln32">** information to ensure the GNU General Public License requirements will</a>
<a name="ln33">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</a>
<a name="ln34">** https://www.gnu.org/licenses/gpl-3.0.html.</a>
<a name="ln35">**</a>
<a name="ln36">** $QT_END_LICENSE$</a>
<a name="ln37">**</a>
<a name="ln38">****************************************************************************/</a>
<a name="ln39"> </a>
<a name="ln40">#ifndef QMAP_H</a>
<a name="ln41">#define QMAP_H</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;QtCore/qiterator.h&gt;</a>
<a name="ln44">#include &lt;QtCore/qlist.h&gt;</a>
<a name="ln45">#include &lt;QtCore/qrefcount.h&gt;</a>
<a name="ln46">#include &lt;QtCore/qpair.h&gt;</a>
<a name="ln47"> </a>
<a name="ln48">#ifdef Q_MAP_DEBUG</a>
<a name="ln49">#include &lt;QtCore/qdebug.h&gt;</a>
<a name="ln50">#endif</a>
<a name="ln51"> </a>
<a name="ln52">#include &lt;map&gt;</a>
<a name="ln53">#include &lt;new&gt;</a>
<a name="ln54">#include &lt;functional&gt;</a>
<a name="ln55"> </a>
<a name="ln56">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln57">#include &lt;initializer_list&gt;</a>
<a name="ln58">#endif</a>
<a name="ln59"> </a>
<a name="ln60">QT_BEGIN_NAMESPACE</a>
<a name="ln61"> </a>
<a name="ln62">/*</a>
<a name="ln63">    QMap uses qMapLessThanKey() to compare keys. The default</a>
<a name="ln64">    implementation uses operator&lt;(). For pointer types,</a>
<a name="ln65">    qMapLessThanKey() uses std::less (because operator&lt;() on</a>
<a name="ln66">    pointers can be used only between pointers in the same array).</a>
<a name="ln67">*/</a>
<a name="ln68"> </a>
<a name="ln69">template &lt;class Key&gt; inline bool qMapLessThanKey(const Key &amp;key1, const Key &amp;key2)</a>
<a name="ln70">{</a>
<a name="ln71">    return key1 &lt; key2;</a>
<a name="ln72">}</a>
<a name="ln73"> </a>
<a name="ln74">template &lt;class Ptr&gt; inline bool qMapLessThanKey(const Ptr *key1, const Ptr *key2)</a>
<a name="ln75">{</a>
<a name="ln76">    return std::less&lt;const Ptr *&gt;()(key1, key2);</a>
<a name="ln77">}</a>
<a name="ln78"> </a>
<a name="ln79">struct QMapDataBase;</a>
<a name="ln80">template &lt;class Key, class T&gt; struct QMapData;</a>
<a name="ln81"> </a>
<a name="ln82">struct Q_CORE_EXPORT QMapNodeBase</a>
<a name="ln83">{</a>
<a name="ln84">    quintptr p;</a>
<a name="ln85">    QMapNodeBase *left;</a>
<a name="ln86">    QMapNodeBase *right;</a>
<a name="ln87"> </a>
<a name="ln88">    enum Color { Red = 0, Black = 1 };</a>
<a name="ln89">    enum { Mask = 3 }; // reserve the second bit as well</a>
<a name="ln90"> </a>
<a name="ln91">    const QMapNodeBase *nextNode() const;</a>
<a name="ln92">    QMapNodeBase *nextNode() { return const_cast&lt;QMapNodeBase *&gt;(const_cast&lt;const QMapNodeBase *&gt;(this)-&gt;nextNode()); }</a>
<a name="ln93">    const QMapNodeBase *previousNode() const;</a>
<a name="ln94">    QMapNodeBase *previousNode() { return const_cast&lt;QMapNodeBase *&gt;(const_cast&lt;const QMapNodeBase *&gt;(this)-&gt;previousNode()); }</a>
<a name="ln95"> </a>
<a name="ln96">    Color color() const { return Color(p &amp; 1); }</a>
<a name="ln97">    void setColor(Color c) { if (c == Black) p |= Black; else p &amp;= ~Black; }</a>
<a name="ln98">    QMapNodeBase *parent() const { return reinterpret_cast&lt;QMapNodeBase *&gt;(p &amp; ~Mask); }</a>
<a name="ln99">    void setParent(QMapNodeBase *pp) { p = (p &amp; Mask) | quintptr(pp); }</a>
<a name="ln100"> </a>
<a name="ln101">    template &lt;typename T&gt;</a>
<a name="ln102">    static typename std::enable_if&lt;QTypeInfo&lt;T&gt;::isComplex&gt;::type</a>
<a name="ln103">    callDestructorIfNecessary(T &amp;t) Q_DECL_NOTHROW { Q_UNUSED(t); t.~T(); } // Q_UNUSED: silence MSVC unused 't' warning</a>
<a name="ln104">    template &lt;typename T&gt;</a>
<a name="ln105">    static typename std::enable_if&lt;!QTypeInfo&lt;T&gt;::isComplex&gt;::type</a>
<a name="ln106">    callDestructorIfNecessary(T &amp;) Q_DECL_NOTHROW {}</a>
<a name="ln107">};</a>
<a name="ln108"> </a>
<a name="ln109">template &lt;class Key, class T&gt;</a>
<a name="ln110">struct QMapNode : public QMapNodeBase</a>
<a name="ln111">{</a>
<a name="ln112">    Key key;</a>
<a name="ln113">    T value;</a>
<a name="ln114"> </a>
<a name="ln115">    inline QMapNode *leftNode() const { return static_cast&lt;QMapNode *&gt;(left); }</a>
<a name="ln116">    inline QMapNode *rightNode() const { return static_cast&lt;QMapNode *&gt;(right); }</a>
<a name="ln117"> </a>
<a name="ln118">    inline const QMapNode *nextNode() const { return reinterpret_cast&lt;const QMapNode *&gt;(QMapNodeBase::nextNode()); }</a>
<a name="ln119">    inline const QMapNode *previousNode() const { return static_cast&lt;const QMapNode *&gt;(QMapNodeBase::previousNode()); }</a>
<a name="ln120">    inline QMapNode *nextNode() { return reinterpret_cast&lt;QMapNode *&gt;(QMapNodeBase::nextNode()); }</a>
<a name="ln121">    inline QMapNode *previousNode() { return static_cast&lt;QMapNode *&gt;(QMapNodeBase::previousNode()); }</a>
<a name="ln122"> </a>
<a name="ln123">    QMapNode&lt;Key, T&gt; *copy(QMapData&lt;Key, T&gt; *d) const;</a>
<a name="ln124"> </a>
<a name="ln125">    void destroySubTree()</a>
<a name="ln126">    {</a>
<a name="ln127">        callDestructorIfNecessary(key);</a>
<a name="ln128">        callDestructorIfNecessary(value);</a>
<a name="ln129">        doDestroySubTree(std::integral_constant&lt;bool, QTypeInfo&lt;T&gt;::isComplex || QTypeInfo&lt;Key&gt;::isComplex&gt;());</a>
<a name="ln130">    }</a>
<a name="ln131"> </a>
<a name="ln132">    QMapNode&lt;Key, T&gt; *lowerBound(const Key &amp;key);</a>
<a name="ln133">    QMapNode&lt;Key, T&gt; *upperBound(const Key &amp;key);</a>
<a name="ln134"> </a>
<a name="ln135">private:</a>
<a name="ln136">    void doDestroySubTree(std::false_type) {}</a>
<a name="ln137">    void doDestroySubTree(std::true_type)</a>
<a name="ln138">    {</a>
<a name="ln139">        if (left)</a>
<a name="ln140">            leftNode()-&gt;destroySubTree();</a>
<a name="ln141">        if (right)</a>
<a name="ln142">            rightNode()-&gt;destroySubTree();</a>
<a name="ln143">    }</a>
<a name="ln144"> </a>
<a name="ln145">    QMapNode() Q_DECL_EQ_DELETE;</a>
<a name="ln146">    Q_DISABLE_COPY(QMapNode)</a>
<a name="ln147">};</a>
<a name="ln148"> </a>
<a name="ln149">template &lt;class Key, class T&gt;</a>
<a name="ln150">inline QMapNode&lt;Key, T&gt; *QMapNode&lt;Key, T&gt;::lowerBound(const Key &amp;akey)</a>
<a name="ln151">{</a>
<a name="ln152">    QMapNode&lt;Key, T&gt; *n = this;</a>
<a name="ln153">    QMapNode&lt;Key, T&gt; *lastNode = nullptr;</a>
<a name="ln154">    while (n) {</a>
<a name="ln155">        if (!qMapLessThanKey(n-&gt;key, akey)) {</a>
<a name="ln156">            lastNode = n;</a>
<a name="ln157">            n = n-&gt;leftNode();</a>
<a name="ln158">        } else {</a>
<a name="ln159">            n = n-&gt;rightNode();</a>
<a name="ln160">        }</a>
<a name="ln161">    }</a>
<a name="ln162">    return lastNode;</a>
<a name="ln163">}</a>
<a name="ln164"> </a>
<a name="ln165">template &lt;class Key, class T&gt;</a>
<a name="ln166">inline QMapNode&lt;Key, T&gt; *QMapNode&lt;Key, T&gt;::upperBound(const Key &amp;akey)</a>
<a name="ln167">{</a>
<a name="ln168">    QMapNode&lt;Key, T&gt; *n = this;</a>
<a name="ln169">    QMapNode&lt;Key, T&gt; *lastNode = nullptr;</a>
<a name="ln170">    while (n) {</a>
<a name="ln171">        if (qMapLessThanKey(akey, n-&gt;key)) {</a>
<a name="ln172">            lastNode = n;</a>
<a name="ln173">            n = n-&gt;leftNode();</a>
<a name="ln174">        } else {</a>
<a name="ln175">            n = n-&gt;rightNode();</a>
<a name="ln176">        }</a>
<a name="ln177">    }</a>
<a name="ln178">    return lastNode;</a>
<a name="ln179">}</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">struct Q_CORE_EXPORT QMapDataBase</a>
<a name="ln184">{</a>
<a name="ln185">    QtPrivate::RefCount ref;</a>
<a name="ln186">    int size;</a>
<a name="ln187">    QMapNodeBase header;</a>
<a name="ln188">    QMapNodeBase *mostLeftNode;</a>
<a name="ln189"> </a>
<a name="ln190">    void rotateLeft(QMapNodeBase *x);</a>
<a name="ln191">    void rotateRight(QMapNodeBase *x);</a>
<a name="ln192">    void rebalance(QMapNodeBase *x);</a>
<a name="ln193">    void freeNodeAndRebalance(QMapNodeBase *z);</a>
<a name="ln194">    void recalcMostLeftNode();</a>
<a name="ln195"> </a>
<a name="ln196">    QMapNodeBase *createNode(int size, int alignment, QMapNodeBase *parent, bool left);</a>
<a name="ln197">    void freeTree(QMapNodeBase *root, int alignment);</a>
<a name="ln198"> </a>
<a name="ln199">    static const QMapDataBase shared_null;</a>
<a name="ln200"> </a>
<a name="ln201">    static QMapDataBase *createData();</a>
<a name="ln202">    static void freeData(QMapDataBase *d);</a>
<a name="ln203">};</a>
<a name="ln204"> </a>
<a name="ln205">template &lt;class Key, class T&gt;</a>
<a name="ln206">struct QMapData : public QMapDataBase</a>
<a name="ln207">{</a>
<a name="ln208">    typedef QMapNode&lt;Key, T&gt; Node;</a>
<a name="ln209"> </a>
<a name="ln210">    Node *root() const { return static_cast&lt;Node *&gt;(header.left); }</a>
<a name="ln211"> </a>
<a name="ln212">    // using reinterpret_cast because QMapDataBase::header is not</a>
<a name="ln213">    // actually a QMapNode.</a>
<a name="ln214">    const Node *end() const { return reinterpret_cast&lt;const Node *&gt;(&amp;header); }</a>
<a name="ln215">    Node *end() { return reinterpret_cast&lt;Node *&gt;(&amp;header); }</a>
<a name="ln216">    const Node *begin() const { if (root()) return static_cast&lt;const Node*&gt;(mostLeftNode); return end(); }</a>
<a name="ln217">    Node *begin() { if (root()) return static_cast&lt;Node*&gt;(mostLeftNode); return end(); }</a>
<a name="ln218"> </a>
<a name="ln219">    void deleteNode(Node *z);</a>
<a name="ln220">    Node *findNode(const Key &amp;akey) const;</a>
<a name="ln221">    void nodeRange(const Key &amp;akey, Node **firstNode, Node **lastNode);</a>
<a name="ln222"> </a>
<a name="ln223">    Node *createNode(const Key &amp;k, const T &amp;v, Node *parent = nullptr, bool left = false)</a>
<a name="ln224">    {</a>
<a name="ln225">        Node *n = static_cast&lt;Node *&gt;(QMapDataBase::createNode(sizeof(Node), Q_ALIGNOF(Node),</a>
<a name="ln226">                                      parent, left));</a>
<a name="ln227">        QT_TRY {</a>
<a name="ln228">            new (&amp;n-&gt;key) Key(k);</a>
<a name="ln229">            QT_TRY {</a>
<a name="ln230">                new (&amp;n-&gt;value) T(v);</a>
<a name="ln231">            } QT_CATCH(...) {</a>
<a name="ln232">                n-&gt;key.~Key();</a>
<a name="ln233">                QT_RETHROW;</a>
<a name="ln234">            }</a>
<a name="ln235">        } QT_CATCH(...) {</a>
<a name="ln236">            QMapDataBase::freeNodeAndRebalance(n);</a>
<a name="ln237">            QT_RETHROW;</a>
<a name="ln238">        }</a>
<a name="ln239">        return n;</a>
<a name="ln240">    }</a>
<a name="ln241"> </a>
<a name="ln242">    static QMapData *create() {</a>
<a name="ln243">        return static_cast&lt;QMapData *&gt;(createData());</a>
<a name="ln244">    }</a>
<a name="ln245"> </a>
<a name="ln246">    void destroy() {</a>
<a name="ln247">        if (root()) {</a>
<a name="ln248">            root()-&gt;destroySubTree();</a>
<a name="ln249">            freeTree(header.left, Q_ALIGNOF(Node));</a>
<a name="ln250">        }</a>
<a name="ln251">        freeData(this);</a>
<a name="ln252">    }</a>
<a name="ln253">};</a>
<a name="ln254"> </a>
<a name="ln255">template &lt;class Key, class T&gt;</a>
<a name="ln256">QMapNode&lt;Key, T&gt; *QMapNode&lt;Key, T&gt;::copy(QMapData&lt;Key, T&gt; *d) const</a>
<a name="ln257">{</a>
<a name="ln258">    QMapNode&lt;Key, T&gt; *n = d-&gt;createNode(key, value);</a>
<a name="ln259">    n-&gt;setColor(color());</a>
<a name="ln260">    if (left) {</a>
<a name="ln261">        n-&gt;left = leftNode()-&gt;copy(d);</a>
<a name="ln262">        n-&gt;left-&gt;setParent(n);</a>
<a name="ln263">    } else {</a>
<a name="ln264">        n-&gt;left = nullptr;</a>
<a name="ln265">    }</a>
<a name="ln266">    if (right) {</a>
<a name="ln267">        n-&gt;right = rightNode()-&gt;copy(d);</a>
<a name="ln268">        n-&gt;right-&gt;setParent(n);</a>
<a name="ln269">    } else {</a>
<a name="ln270">        n-&gt;right = nullptr;</a>
<a name="ln271">    }</a>
<a name="ln272">    return n;</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">template &lt;class Key, class T&gt;</a>
<a name="ln276">void QMapData&lt;Key, T&gt;::deleteNode(QMapNode&lt;Key, T&gt; *z)</a>
<a name="ln277">{</a>
<a name="ln278">    QMapNodeBase::callDestructorIfNecessary(z-&gt;key);</a>
<a name="ln279">    QMapNodeBase::callDestructorIfNecessary(z-&gt;value);</a>
<a name="ln280">    freeNodeAndRebalance(z);</a>
<a name="ln281">}</a>
<a name="ln282"> </a>
<a name="ln283">template &lt;class Key, class T&gt;</a>
<a name="ln284">QMapNode&lt;Key, T&gt; *QMapData&lt;Key, T&gt;::findNode(const Key &amp;akey) const</a>
<a name="ln285">{</a>
<a name="ln286">    if (Node *r = root()) {</a>
<a name="ln287">        Node *lb = r-&gt;lowerBound(akey);</a>
<a name="ln288">        if (lb &amp;&amp; !qMapLessThanKey(akey, lb-&gt;key))</a>
<a name="ln289">            return lb;</a>
<a name="ln290">    }</a>
<a name="ln291">    return nullptr;</a>
<a name="ln292">}</a>
<a name="ln293"> </a>
<a name="ln294"> </a>
<a name="ln295">template &lt;class Key, class T&gt;</a>
<a name="ln296">void QMapData&lt;Key, T&gt;::nodeRange(const Key &amp;akey, QMapNode&lt;Key, T&gt; **firstNode, QMapNode&lt;Key, T&gt; **lastNode)</a>
<a name="ln297">{</a>
<a name="ln298">    Node *n = root();</a>
<a name="ln299">    Node *l = end();</a>
<a name="ln300">    while (n) {</a>
<a name="ln301">        if (qMapLessThanKey(akey, n-&gt;key)) {</a>
<a name="ln302">            l = n;</a>
<a name="ln303">            n = n-&gt;leftNode();</a>
<a name="ln304">        } else if (qMapLessThanKey(n-&gt;key, akey)) {</a>
<a name="ln305">            n = n-&gt;rightNode();</a>
<a name="ln306">        } else {</a>
<a name="ln307">            *firstNode = n-&gt;leftNode() ? n-&gt;leftNode()-&gt;lowerBound(akey) : nullptr;</a>
<a name="ln308">            if (!*firstNode)</a>
<a name="ln309">                *firstNode = n;</a>
<a name="ln310">            *lastNode = n-&gt;rightNode() ? n-&gt;rightNode()-&gt;upperBound(akey) : nullptr;</a>
<a name="ln311">            if (!*lastNode)</a>
<a name="ln312">                *lastNode = l;</a>
<a name="ln313">            return;</a>
<a name="ln314">        }</a>
<a name="ln315">    }</a>
<a name="ln316">    *firstNode = *lastNode = l;</a>
<a name="ln317">}</a>
<a name="ln318"> </a>
<a name="ln319"> </a>
<a name="ln320">template &lt;class Key, class T&gt;</a>
<a name="ln321">class QMap</a>
<a name="ln322">{</a>
<a name="ln323">    typedef QMapNode&lt;Key, T&gt; Node;</a>
<a name="ln324"> </a>
<a name="ln325">    QMapData&lt;Key, T&gt; *d;</a>
<a name="ln326"> </a>
<a name="ln327">public:</a>
<a name="ln328">    inline QMap() Q_DECL_NOTHROW : d(static_cast&lt;QMapData&lt;Key, T&gt; *&gt;(const_cast&lt;QMapDataBase *&gt;(&amp;QMapDataBase::shared_null))) { }</a>
<a name="ln329">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln330">    inline QMap(std::initializer_list&lt;std::pair&lt;Key,T&gt; &gt; list)</a>
<a name="ln331">        : d(static_cast&lt;QMapData&lt;Key, T&gt; *&gt;(const_cast&lt;QMapDataBase *&gt;(&amp;QMapDataBase::shared_null)))</a>
<a name="ln332">    {</a>
<a name="ln333">        for (typename std::initializer_list&lt;std::pair&lt;Key,T&gt; &gt;::const_iterator it = list.begin(); it != list.end(); ++it)</a>
<a name="ln334">            insert(it-&gt;first, it-&gt;second);</a>
<a name="ln335">    }</a>
<a name="ln336">#endif</a>
<a name="ln337">    QMap(const QMap&lt;Key, T&gt; &amp;other);</a>
<a name="ln338"> </a>
<a name="ln339">    inline ~QMap() { if (!d-&gt;ref.deref()) d-&gt;destroy(); }</a>
<a name="ln340"> </a>
<a name="ln341">    QMap&lt;Key, T&gt; &amp;operator=(const QMap&lt;Key, T&gt; &amp;other);</a>
<a name="ln342">#ifdef Q_COMPILER_RVALUE_REFS</a>
<a name="ln343">    inline QMap(QMap&lt;Key, T&gt; &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln344">        : d(other.d)</a>
<a name="ln345">    {</a>
<a name="ln346">        other.d = static_cast&lt;QMapData&lt;Key, T&gt; *&gt;(</a>
<a name="ln347">                const_cast&lt;QMapDataBase *&gt;(&amp;QMapDataBase::shared_null));</a>
<a name="ln348">    }</a>
<a name="ln349"> </a>
<a name="ln350">    inline QMap&lt;Key, T&gt; &amp;operator=(QMap&lt;Key, T&gt; &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln351">    { QMap moved(std::move(other)); swap(moved); return *this; }</a>
<a name="ln352">#endif</a>
<a name="ln353">    inline void swap(QMap&lt;Key, T&gt; &amp;other) Q_DECL_NOTHROW { qSwap(d, other.d); }</a>
<a name="ln354">    explicit QMap(const typename std::map&lt;Key, T&gt; &amp;other);</a>
<a name="ln355">    std::map&lt;Key, T&gt; toStdMap() const;</a>
<a name="ln356"> </a>
<a name="ln357">    bool operator==(const QMap&lt;Key, T&gt; &amp;other) const;</a>
<a name="ln358">    inline bool operator!=(const QMap&lt;Key, T&gt; &amp;other) const { return !(*this == other); }</a>
<a name="ln359"> </a>
<a name="ln360">    inline int size() const { return d-&gt;size; }</a>
<a name="ln361"> </a>
<a name="ln362">    inline bool isEmpty() const { return d-&gt;size == 0; }</a>
<a name="ln363"> </a>
<a name="ln364">    inline void detach() { if (d-&gt;ref.isShared()) detach_helper(); }</a>
<a name="ln365">    inline bool isDetached() const { return !d-&gt;ref.isShared(); }</a>
<a name="ln366">#if !defined(QT_NO_UNSHARABLE_CONTAINERS)</a>
<a name="ln367">    inline void setSharable(bool sharable)</a>
<a name="ln368">    {</a>
<a name="ln369">        if (sharable == d-&gt;ref.isSharable())</a>
<a name="ln370">            return;</a>
<a name="ln371">        if (!sharable)</a>
<a name="ln372">            detach();</a>
<a name="ln373">        // Don't call on shared_null</a>
<a name="ln374">        d-&gt;ref.setSharable(sharable);</a>
<a name="ln375">    }</a>
<a name="ln376">#endif</a>
<a name="ln377">    inline bool isSharedWith(const QMap&lt;Key, T&gt; &amp;other) const { return d == other.d; }</a>
<a name="ln378"> </a>
<a name="ln379">    void clear();</a>
<a name="ln380"> </a>
<a name="ln381">    int remove(const Key &amp;key);</a>
<a name="ln382">    T take(const Key &amp;key);</a>
<a name="ln383"> </a>
<a name="ln384">    bool contains(const Key &amp;key) const;</a>
<a name="ln385">    const Key key(const T &amp;value, const Key &amp;defaultKey = Key()) const;</a>
<a name="ln386">    const T value(const Key &amp;key, const T &amp;defaultValue = T()) const;</a>
<a name="ln387">    T &amp;operator[](const Key &amp;key);</a>
<a name="ln388">    const T operator[](const Key &amp;key) const;</a>
<a name="ln389"> </a>
<a name="ln390">    QList&lt;Key&gt; uniqueKeys() const;</a>
<a name="ln391">    QList&lt;Key&gt; keys() const;</a>
<a name="ln392">    QList&lt;Key&gt; keys(const T &amp;value) const;</a>
<a name="ln393">    QList&lt;T&gt; values() const;</a>
<a name="ln394">    QList&lt;T&gt; values(const Key &amp;key) const;</a>
<a name="ln395">    int count(const Key &amp;key) const;</a>
<a name="ln396"> </a>
<a name="ln397">    inline const Key &amp;firstKey() const { Q_ASSERT(!isEmpty()); return constBegin().key(); }</a>
<a name="ln398">    inline const Key &amp;lastKey() const { Q_ASSERT(!isEmpty()); return (constEnd() - 1).key(); }</a>
<a name="ln399"> </a>
<a name="ln400">    inline T &amp;first() { Q_ASSERT(!isEmpty()); return *begin(); }</a>
<a name="ln401">    inline const T &amp;first() const { Q_ASSERT(!isEmpty()); return *constBegin(); }</a>
<a name="ln402">    inline T &amp;last() { Q_ASSERT(!isEmpty()); return *(end() - 1); }</a>
<a name="ln403">    inline const T &amp;last() const { Q_ASSERT(!isEmpty()); return *(constEnd() - 1); }</a>
<a name="ln404"> </a>
<a name="ln405">    class const_iterator;</a>
<a name="ln406"> </a>
<a name="ln407">    class iterator</a>
<a name="ln408">    {</a>
<a name="ln409">        friend class const_iterator;</a>
<a name="ln410">        Node *i;</a>
<a name="ln411"> </a>
<a name="ln412">    public:</a>
<a name="ln413">        typedef std::bidirectional_iterator_tag iterator_category;</a>
<a name="ln414">        typedef qptrdiff difference_type;</a>
<a name="ln415">        typedef T value_type;</a>
<a name="ln416">        typedef T *pointer;</a>
<a name="ln417">        typedef T &amp;reference;</a>
<a name="ln418"> </a>
<a name="ln419">        inline iterator() : i(nullptr) { }</a>
<a name="ln420">        inline iterator(Node *node) : i(node) { }</a>
<a name="ln421"> </a>
<a name="ln422">        inline const Key &amp;key() const { return i-&gt;key; }</a>
<a name="ln423">        inline T &amp;value() const { return i-&gt;value; }</a>
<a name="ln424">        inline T &amp;operator*() const { return i-&gt;value; }</a>
<a name="ln425">        inline T *operator-&gt;() const { return &amp;i-&gt;value; }</a>
<a name="ln426">        inline bool operator==(const iterator &amp;o) const { return i == o.i; }</a>
<a name="ln427">        inline bool operator!=(const iterator &amp;o) const { return i != o.i; }</a>
<a name="ln428"> </a>
<a name="ln429">        inline iterator &amp;operator++() {</a>
<a name="ln430">            i = i-&gt;nextNode();</a>
<a name="ln431">            return *this;</a>
<a name="ln432">        }</a>
<a name="ln433">        inline iterator operator++(int) {</a>
<a name="ln434">            iterator r = *this;</a>
<a name="ln435">            i = i-&gt;nextNode();</a>
<a name="ln436">            return r;</a>
<a name="ln437">        }</a>
<a name="ln438">        inline iterator &amp;operator--() {</a>
<a name="ln439">            i = i-&gt;previousNode();</a>
<a name="ln440">            return *this;</a>
<a name="ln441">        }</a>
<a name="ln442">        inline iterator operator--(int) {</a>
<a name="ln443">            iterator r = *this;</a>
<a name="ln444">            i = i-&gt;previousNode();</a>
<a name="ln445">            return r;</a>
<a name="ln446">        }</a>
<a name="ln447">        inline iterator operator+(int j) const</a>
<a name="ln448">        { iterator r = *this; if (j &gt; 0) while (j--) ++r; else while (j++) --r; return r; }</a>
<a name="ln449">        inline iterator operator-(int j) const { return operator+(-j); }</a>
<a name="ln450">        inline iterator &amp;operator+=(int j) { return *this = *this + j; }</a>
<a name="ln451">        inline iterator &amp;operator-=(int j) { return *this = *this - j; }</a>
<a name="ln452">        friend inline iterator operator+(int j, iterator k) { return k + j; }</a>
<a name="ln453"> </a>
<a name="ln454">#ifndef QT_STRICT_ITERATORS</a>
<a name="ln455">    public:</a>
<a name="ln456">        inline bool operator==(const const_iterator &amp;o) const</a>
<a name="ln457">            { return i == o.i; }</a>
<a name="ln458">        inline bool operator!=(const const_iterator &amp;o) const</a>
<a name="ln459">            { return i != o.i; }</a>
<a name="ln460">#endif</a>
<a name="ln461">        friend class QMap&lt;Key, T&gt;;</a>
<a name="ln462">    };</a>
<a name="ln463">    friend class iterator;</a>
<a name="ln464"> </a>
<a name="ln465">    class const_iterator</a>
<a name="ln466">    {</a>
<a name="ln467">        friend class iterator;</a>
<a name="ln468">        const Node *i;</a>
<a name="ln469"> </a>
<a name="ln470">    public:</a>
<a name="ln471">        typedef std::bidirectional_iterator_tag iterator_category;</a>
<a name="ln472">        typedef qptrdiff difference_type;</a>
<a name="ln473">        typedef T value_type;</a>
<a name="ln474">        typedef const T *pointer;</a>
<a name="ln475">        typedef const T &amp;reference;</a>
<a name="ln476"> </a>
<a name="ln477">        Q_DECL_CONSTEXPR inline const_iterator() : i(nullptr) { }</a>
<a name="ln478">        inline const_iterator(const Node *node) : i(node) { }</a>
<a name="ln479">#ifdef QT_STRICT_ITERATORS</a>
<a name="ln480">        explicit inline const_iterator(const iterator &amp;o)</a>
<a name="ln481">#else</a>
<a name="ln482">        inline const_iterator(const iterator &amp;o)</a>
<a name="ln483">#endif</a>
<a name="ln484">        { i = o.i; }</a>
<a name="ln485"> </a>
<a name="ln486">        inline const Key &amp;key() const { return i-&gt;key; }</a>
<a name="ln487">        inline const T &amp;value() const { return i-&gt;value; }</a>
<a name="ln488">        inline const T &amp;operator*() const { return i-&gt;value; }</a>
<a name="ln489">        inline const T *operator-&gt;() const { return &amp;i-&gt;value; }</a>
<a name="ln490">        Q_DECL_CONSTEXPR inline bool operator==(const const_iterator &amp;o) const { return i == o.i; }</a>
<a name="ln491">        Q_DECL_CONSTEXPR inline bool operator!=(const const_iterator &amp;o) const { return i != o.i; }</a>
<a name="ln492"> </a>
<a name="ln493">        inline const_iterator &amp;operator++() {</a>
<a name="ln494">            i = i-&gt;nextNode();</a>
<a name="ln495">            return *this;</a>
<a name="ln496">        }</a>
<a name="ln497">        inline const_iterator operator++(int) {</a>
<a name="ln498">            const_iterator r = *this;</a>
<a name="ln499">            i = i-&gt;nextNode();</a>
<a name="ln500">            return r;</a>
<a name="ln501">        }</a>
<a name="ln502">        inline const_iterator &amp;operator--() {</a>
<a name="ln503">            i = i-&gt;previousNode();</a>
<a name="ln504">            return *this;</a>
<a name="ln505">        }</a>
<a name="ln506">        inline const_iterator operator--(int) {</a>
<a name="ln507">            const_iterator r = *this;</a>
<a name="ln508">            i = i-&gt;previousNode();</a>
<a name="ln509">            return r;</a>
<a name="ln510">        }</a>
<a name="ln511">        inline const_iterator operator+(int j) const</a>
<a name="ln512">        { const_iterator r = *this; if (j &gt; 0) while (j--) ++r; else while (j++) --r; return r; }</a>
<a name="ln513">        inline const_iterator operator-(int j) const { return operator+(-j); }</a>
<a name="ln514">        inline const_iterator &amp;operator+=(int j) { return *this = *this + j; }</a>
<a name="ln515">        inline const_iterator &amp;operator-=(int j) { return *this = *this - j; }</a>
<a name="ln516">        friend inline const_iterator operator+(int j, const_iterator k) { return k + j; }</a>
<a name="ln517"> </a>
<a name="ln518">#ifdef QT_STRICT_ITERATORS</a>
<a name="ln519">    private:</a>
<a name="ln520">        inline bool operator==(const iterator &amp;o) const { return operator==(const_iterator(o)); }</a>
<a name="ln521">        inline bool operator!=(const iterator &amp;o) const { return operator!=(const_iterator(o)); }</a>
<a name="ln522">#endif</a>
<a name="ln523">        friend class QMap&lt;Key, T&gt;;</a>
<a name="ln524">    };</a>
<a name="ln525">    friend class const_iterator;</a>
<a name="ln526"> </a>
<a name="ln527">    class key_iterator</a>
<a name="ln528">    {</a>
<a name="ln529">        const_iterator i;</a>
<a name="ln530"> </a>
<a name="ln531">    public:</a>
<a name="ln532">        typedef typename const_iterator::iterator_category iterator_category;</a>
<a name="ln533">        typedef typename const_iterator::difference_type difference_type;</a>
<a name="ln534">        typedef Key value_type;</a>
<a name="ln535">        typedef const Key *pointer;</a>
<a name="ln536">        typedef const Key &amp;reference;</a>
<a name="ln537"> </a>
<a name="ln538">        key_iterator() = default;</a>
<a name="ln539">        explicit key_iterator(const_iterator o) : i(o) { }</a>
<a name="ln540"> </a>
<a name="ln541">        const Key &amp;operator*() const { return i.key(); }</a>
<a name="ln542">        const Key *operator-&gt;() const { return &amp;i.key(); }</a>
<a name="ln543">        bool operator==(key_iterator o) const { return i == o.i; }</a>
<a name="ln544">        bool operator!=(key_iterator o) const { return i != o.i; }</a>
<a name="ln545"> </a>
<a name="ln546">        inline key_iterator &amp;operator++() { ++i; return *this; }</a>
<a name="ln547">        inline key_iterator operator++(int) { return key_iterator(i++);}</a>
<a name="ln548">        inline key_iterator &amp;operator--() { --i; return *this; }</a>
<a name="ln549">        inline key_iterator operator--(int) { return key_iterator(i--); }</a>
<a name="ln550">        const_iterator base() const { return i; }</a>
<a name="ln551">    };</a>
<a name="ln552"> </a>
<a name="ln553">    typedef QKeyValueIterator&lt;const Key&amp;, const T&amp;, const_iterator&gt; const_key_value_iterator;</a>
<a name="ln554">    typedef QKeyValueIterator&lt;const Key&amp;, T&amp;, iterator&gt; key_value_iterator;</a>
<a name="ln555"> </a>
<a name="ln556">    // STL style</a>
<a name="ln557">    inline iterator begin() { detach(); return iterator(d-&gt;begin()); }</a>
<a name="ln558">    inline const_iterator begin() const { return const_iterator(d-&gt;begin()); }</a>
<a name="ln559">    inline const_iterator constBegin() const { return const_iterator(d-&gt;begin()); }</a>
<a name="ln560">    inline const_iterator cbegin() const { return const_iterator(d-&gt;begin()); }</a>
<a name="ln561">    inline iterator end() { detach(); return iterator(d-&gt;end()); }</a>
<a name="ln562">    inline const_iterator end() const { return const_iterator(d-&gt;end()); }</a>
<a name="ln563">    inline const_iterator constEnd() const { return const_iterator(d-&gt;end()); }</a>
<a name="ln564">    inline const_iterator cend() const { return const_iterator(d-&gt;end()); }</a>
<a name="ln565">    inline key_iterator keyBegin() const { return key_iterator(begin()); }</a>
<a name="ln566">    inline key_iterator keyEnd() const { return key_iterator(end()); }</a>
<a name="ln567">    inline key_value_iterator keyValueBegin() { return key_value_iterator(begin()); }</a>
<a name="ln568">    inline key_value_iterator keyValueEnd() { return key_value_iterator(end()); }</a>
<a name="ln569">    inline const_key_value_iterator keyValueBegin() const { return const_key_value_iterator(begin()); }</a>
<a name="ln570">    inline const_key_value_iterator constKeyValueBegin() const { return const_key_value_iterator(begin()); }</a>
<a name="ln571">    inline const_key_value_iterator keyValueEnd() const { return const_key_value_iterator(end()); }</a>
<a name="ln572">    inline const_key_value_iterator constKeyValueEnd() const { return const_key_value_iterator(end()); }</a>
<a name="ln573">    iterator erase(iterator it);</a>
<a name="ln574"> </a>
<a name="ln575">    // more Qt</a>
<a name="ln576">    typedef iterator Iterator;</a>
<a name="ln577">    typedef const_iterator ConstIterator;</a>
<a name="ln578">    inline int count() const { return d-&gt;size; }</a>
<a name="ln579">    iterator find(const Key &amp;key);</a>
<a name="ln580">    const_iterator find(const Key &amp;key) const;</a>
<a name="ln581">    const_iterator constFind(const Key &amp;key) const;</a>
<a name="ln582">    iterator lowerBound(const Key &amp;key);</a>
<a name="ln583">    const_iterator lowerBound(const Key &amp;key) const;</a>
<a name="ln584">    iterator upperBound(const Key &amp;key);</a>
<a name="ln585">    const_iterator upperBound(const Key &amp;key) const;</a>
<a name="ln586">    iterator insert(const Key &amp;key, const T &amp;value);</a>
<a name="ln587">    iterator insert(const_iterator pos, const Key &amp;key, const T &amp;value);</a>
<a name="ln588">    iterator insertMulti(const Key &amp;key, const T &amp;value);</a>
<a name="ln589">    iterator insertMulti(const_iterator pos, const Key &amp;akey, const T &amp;avalue);</a>
<a name="ln590">    QMap&lt;Key, T&gt; &amp;unite(const QMap&lt;Key, T&gt; &amp;other);</a>
<a name="ln591"> </a>
<a name="ln592">    // STL compatibility</a>
<a name="ln593">    typedef Key key_type;</a>
<a name="ln594">    typedef T mapped_type;</a>
<a name="ln595">    typedef qptrdiff difference_type;</a>
<a name="ln596">    typedef int size_type;</a>
<a name="ln597">    inline bool empty() const { return isEmpty(); }</a>
<a name="ln598">    QPair&lt;iterator, iterator&gt; equal_range(const Key &amp;akey);</a>
<a name="ln599">    QPair&lt;const_iterator, const_iterator&gt; equal_range(const Key &amp;akey) const;</a>
<a name="ln600"> </a>
<a name="ln601">#ifdef Q_MAP_DEBUG</a>
<a name="ln602">    void dump() const;</a>
<a name="ln603">#endif</a>
<a name="ln604"> </a>
<a name="ln605">private:</a>
<a name="ln606">    void detach_helper();</a>
<a name="ln607">    bool isValidIterator(const const_iterator &amp;ci) const</a>
<a name="ln608">    {</a>
<a name="ln609">#if defined(QT_DEBUG) &amp;&amp; !defined(Q_MAP_NO_ITERATOR_DEBUG)</a>
<a name="ln610">        const QMapNodeBase *n = ci.i;</a>
<a name="ln611">        while (n-&gt;parent())</a>
<a name="ln612">            n = n-&gt;parent();</a>
<a name="ln613">        return n-&gt;left == d-&gt;root();</a>
<a name="ln614">#else</a>
<a name="ln615">        Q_UNUSED(ci);</a>
<a name="ln616">        return true;</a>
<a name="ln617">#endif</a>
<a name="ln618">    }</a>
<a name="ln619">};</a>
<a name="ln620"> </a>
<a name="ln621">template &lt;class Key, class T&gt;</a>
<a name="ln622">inline QMap&lt;Key, T&gt;::QMap(const QMap&lt;Key, T&gt; &amp;other)</a>
<a name="ln623">{</a>
<a name="ln624">    if (other.d-&gt;ref.ref()) {</a>
<a name="ln625">        d = other.d;</a>
<a name="ln626">    } else {</a>
<a name="ln627">        d = QMapData&lt;Key, T&gt;::create();</a>
<a name="ln628">        if (other.d-&gt;header.left) {</a>
<a name="ln629">            d-&gt;header.left = static_cast&lt;Node *&gt;(other.d-&gt;header.left)-&gt;copy(d);</a>
<a name="ln630">            d-&gt;header.left-&gt;setParent(&amp;d-&gt;header);</a>
<a name="ln631">            d-&gt;recalcMostLeftNode();</a>
<a name="ln632">        }</a>
<a name="ln633">    }</a>
<a name="ln634">}</a>
<a name="ln635"> </a>
<a name="ln636">template &lt;class Key, class T&gt;</a>
<a name="ln637">Q_INLINE_TEMPLATE QMap&lt;Key, T&gt; &amp;QMap&lt;Key, T&gt;::operator=(const QMap&lt;Key, T&gt; &amp;other)</a>
<a name="ln638">{</a>
<a name="ln639">    if (d != other.d) {</a>
<a name="ln640">        QMap&lt;Key, T&gt; tmp(other);</a>
<a name="ln641">        tmp.swap(*this);</a>
<a name="ln642">    }</a>
<a name="ln643">    return *this;</a>
<a name="ln644">}</a>
<a name="ln645"> </a>
<a name="ln646">template &lt;class Key, class T&gt;</a>
<a name="ln647">Q_INLINE_TEMPLATE void QMap&lt;Key, T&gt;::clear()</a>
<a name="ln648">{</a>
<a name="ln649">    *this = QMap&lt;Key, T&gt;();</a>
<a name="ln650">}</a>
<a name="ln651"> </a>
<a name="ln652">QT_WARNING_PUSH</a>
<a name="ln653">QT_WARNING_DISABLE_CLANG(&quot;-Wreturn-stack-address&quot;)</a>
<a name="ln654"> </a>
<a name="ln655">template &lt;class Key, class T&gt;</a>
<a name="ln656">Q_INLINE_TEMPLATE const T QMap&lt;Key, T&gt;::value(const Key &amp;akey, const T &amp;adefaultValue) const</a>
<a name="ln657">{</a>
<a name="ln658">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln659">    return n ? n-&gt;value : adefaultValue;</a>
<a name="ln660">}</a>
<a name="ln661"> </a>
<a name="ln662">QT_WARNING_POP</a>
<a name="ln663"> </a>
<a name="ln664">template &lt;class Key, class T&gt;</a>
<a name="ln665">Q_INLINE_TEMPLATE const T QMap&lt;Key, T&gt;::operator[](const Key &amp;akey) const</a>
<a name="ln666">{</a>
<a name="ln667">    return value(akey);</a>
<a name="ln668">}</a>
<a name="ln669"> </a>
<a name="ln670">template &lt;class Key, class T&gt;</a>
<a name="ln671">Q_INLINE_TEMPLATE T &amp;QMap&lt;Key, T&gt;::operator[](const Key &amp;akey)</a>
<a name="ln672">{</a>
<a name="ln673">    detach();</a>
<a name="ln674">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln675">    if (!n)</a>
<a name="ln676">        return *insert(akey, T());</a>
<a name="ln677">    return n-&gt;value;</a>
<a name="ln678">}</a>
<a name="ln679"> </a>
<a name="ln680">template &lt;class Key, class T&gt;</a>
<a name="ln681">Q_INLINE_TEMPLATE int QMap&lt;Key, T&gt;::count(const Key &amp;akey) const</a>
<a name="ln682">{</a>
<a name="ln683">    Node *firstNode;</a>
<a name="ln684">    Node *lastNode;</a>
<a name="ln685">    d-&gt;nodeRange(akey, &amp;firstNode, &amp;lastNode);</a>
<a name="ln686"> </a>
<a name="ln687">    const_iterator ci_first(firstNode);</a>
<a name="ln688">    const const_iterator ci_last(lastNode);</a>
<a name="ln689">    int cnt = 0;</a>
<a name="ln690">    while (ci_first != ci_last) {</a>
<a name="ln691">        ++cnt;</a>
<a name="ln692">        ++ci_first;</a>
<a name="ln693">    }</a>
<a name="ln694">    return cnt;</a>
<a name="ln695">}</a>
<a name="ln696"> </a>
<a name="ln697">template &lt;class Key, class T&gt;</a>
<a name="ln698">Q_INLINE_TEMPLATE bool QMap&lt;Key, T&gt;::contains(const Key &amp;akey) const</a>
<a name="ln699">{</a>
<a name="ln700">    return d-&gt;findNode(akey) != nullptr;</a>
<a name="ln701">}</a>
<a name="ln702"> </a>
<a name="ln703">template &lt;class Key, class T&gt;</a>
<a name="ln704">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::insert(const Key &amp;akey, const T &amp;avalue)</a>
<a name="ln705">{</a>
<a name="ln706">    detach();</a>
<a name="ln707">    Node *n = d-&gt;root();</a>
<a name="ln708">    Node *y = d-&gt;end();</a>
<a name="ln709">    Node *lastNode = nullptr;</a>
<a name="ln710">    bool  left = true;</a>
<a name="ln711">    while (n) {</a>
<a name="ln712">        y = n;</a>
<a name="ln713">        if (!qMapLessThanKey(n-&gt;key, akey)) {</a>
<a name="ln714">            lastNode = n;</a>
<a name="ln715">            left = true;</a>
<a name="ln716">            n = n-&gt;leftNode();</a>
<a name="ln717">        } else {</a>
<a name="ln718">            left = false;</a>
<a name="ln719">            n = n-&gt;rightNode();</a>
<a name="ln720">        }</a>
<a name="ln721">    }</a>
<a name="ln722">    if (lastNode &amp;&amp; !qMapLessThanKey(akey, lastNode-&gt;key)) {</a>
<a name="ln723">        lastNode-&gt;value = avalue;</a>
<a name="ln724">        return iterator(lastNode);</a>
<a name="ln725">    }</a>
<a name="ln726">    Node *z = d-&gt;createNode(akey, avalue, y, left);</a>
<a name="ln727">    return iterator(z);</a>
<a name="ln728">}</a>
<a name="ln729"> </a>
<a name="ln730">template &lt;class Key, class T&gt;</a>
<a name="ln731">typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::insert(const_iterator pos, const Key &amp;akey, const T &amp;avalue)</a>
<a name="ln732">{</a>
<a name="ln733">    if (d-&gt;ref.isShared())</a>
<a name="ln734">        return this-&gt;insert(akey, avalue);</a>
<a name="ln735"> </a>
<a name="ln736">    Q_ASSERT_X(isValidIterator(pos), &quot;QMap::insert&quot;, &quot;The specified const_iterator argument 'it' is invalid&quot;);</a>
<a name="ln737"> </a>
<a name="ln738">    if (pos == constEnd()) {</a>
<a name="ln739">        // Hint is that the Node is larger than (or equal to) the largest value.</a>
<a name="ln740">        Node *n = static_cast&lt;Node *&gt;(pos.i-&gt;left);</a>
<a name="ln741">        if (n) {</a>
<a name="ln742">            while (n-&gt;right)</a>
<a name="ln743">                n = static_cast&lt;Node *&gt;(n-&gt;right);</a>
<a name="ln744"> </a>
<a name="ln745">            if (!qMapLessThanKey(n-&gt;key, akey))</a>
<a name="ln746">                return this-&gt;insert(akey, avalue); // ignore hint</a>
<a name="ln747">            // This can be optimized by checking equal too.</a>
<a name="ln748">            // we can overwrite if previous node key is strictly smaller</a>
<a name="ln749">            // (or there is no previous node)</a>
<a name="ln750"> </a>
<a name="ln751">            Node *z = d-&gt;createNode(akey, avalue, n, false); // insert right most</a>
<a name="ln752">            return iterator(z);</a>
<a name="ln753">        }</a>
<a name="ln754">        return this-&gt;insert(akey, avalue);</a>
<a name="ln755">    } else {</a>
<a name="ln756">        // Hint indicates that the node should be less (or equal to) the hint given</a>
<a name="ln757">        // but larger than the previous value.</a>
<a name="ln758">        Node *next = const_cast&lt;Node*&gt;(pos.i);</a>
<a name="ln759">        if (qMapLessThanKey(next-&gt;key, akey))</a>
<a name="ln760">            return this-&gt;insert(akey, avalue); // ignore hint</a>
<a name="ln761"> </a>
<a name="ln762">        if (pos == constBegin()) {</a>
<a name="ln763">            // There is no previous value</a>
<a name="ln764">            // Maybe overwrite left most value</a>
<a name="ln765">            if (!qMapLessThanKey(akey, next-&gt;key)) {</a>
<a name="ln766">                next-&gt;value = avalue; // overwrite current iterator</a>
<a name="ln767">                return iterator(next);</a>
<a name="ln768">            }</a>
<a name="ln769">            // insert left most.</a>
<a name="ln770">            Node *z = d-&gt;createNode(akey, avalue, begin().i, true);</a>
<a name="ln771">            return iterator(z);</a>
<a name="ln772">        } else {</a>
<a name="ln773">            Node *prev = const_cast&lt;Node*&gt;(pos.i-&gt;previousNode());</a>
<a name="ln774">            if (!qMapLessThanKey(prev-&gt;key, akey)) {</a>
<a name="ln775">                return this-&gt;insert(akey, avalue); // ignore hint</a>
<a name="ln776">            }</a>
<a name="ln777">            // Hint is ok</a>
<a name="ln778">            if (!qMapLessThanKey(akey, next-&gt;key)) {</a>
<a name="ln779">                next-&gt;value = avalue; // overwrite current iterator</a>
<a name="ln780">                return iterator(next);</a>
<a name="ln781">            }</a>
<a name="ln782"> </a>
<a name="ln783">            // we need to insert (not overwrite)</a>
<a name="ln784">            if (prev-&gt;right == nullptr) {</a>
<a name="ln785">                Node *z = d-&gt;createNode(akey, avalue, prev, false);</a>
<a name="ln786">                return iterator(z);</a>
<a name="ln787">            }</a>
<a name="ln788">            if (next-&gt;left == nullptr) {</a>
<a name="ln789">                Node *z = d-&gt;createNode(akey, avalue, next, true);</a>
<a name="ln790">                return iterator(z);</a>
<a name="ln791">            }</a>
<a name="ln792">            Q_ASSERT(false); // We should have prev-&gt;right == nullptr or next-&gt;left == nullptr.</a>
<a name="ln793">            return this-&gt;insert(akey, avalue);</a>
<a name="ln794">        }</a>
<a name="ln795">    }</a>
<a name="ln796">}</a>
<a name="ln797"> </a>
<a name="ln798">template &lt;class Key, class T&gt;</a>
<a name="ln799">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::insertMulti(const Key &amp;akey,</a>
<a name="ln800">                                                                            const T &amp;avalue)</a>
<a name="ln801">{</a>
<a name="ln802">    detach();</a>
<a name="ln803">    Node* y = d-&gt;end();</a>
<a name="ln804">    Node* x = static_cast&lt;Node *&gt;(d-&gt;root());</a>
<a name="ln805">    bool left = true;</a>
<a name="ln806">    while (x != nullptr) {</a>
<a name="ln807">        left = !qMapLessThanKey(x-&gt;key, akey);</a>
<a name="ln808">        y = x;</a>
<a name="ln809">        x = left ? x-&gt;leftNode() : x-&gt;rightNode();</a>
<a name="ln810">    }</a>
<a name="ln811">    Node *z = d-&gt;createNode(akey, avalue, y, left);</a>
<a name="ln812">    return iterator(z);</a>
<a name="ln813">}</a>
<a name="ln814"> </a>
<a name="ln815">template &lt;class Key, class T&gt;</a>
<a name="ln816">typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::insertMulti(const_iterator pos, const Key &amp;akey, const T &amp;avalue)</a>
<a name="ln817">{</a>
<a name="ln818">    if (d-&gt;ref.isShared())</a>
<a name="ln819">        return this-&gt;insertMulti(akey, avalue);</a>
<a name="ln820"> </a>
<a name="ln821">    Q_ASSERT_X(isValidIterator(pos), &quot;QMap::insertMulti&quot;, &quot;The specified const_iterator argument 'pos' is invalid&quot;);</a>
<a name="ln822"> </a>
<a name="ln823">    if (pos == constEnd()) {</a>
<a name="ln824">        // Hint is that the Node is larger than (or equal to) the largest value.</a>
<a name="ln825">        Node *n = static_cast&lt;Node *&gt;(pos.i-&gt;left);</a>
<a name="ln826">        if (n) {</a>
<a name="ln827">            while (n-&gt;right)</a>
<a name="ln828">                n = static_cast&lt;Node *&gt;(n-&gt;right);</a>
<a name="ln829"> </a>
<a name="ln830">            if (!qMapLessThanKey(n-&gt;key, akey))</a>
<a name="ln831">                return this-&gt;insertMulti(akey, avalue); // ignore hint</a>
<a name="ln832">            Node *z = d-&gt;createNode(akey, avalue, n, false); // insert right most</a>
<a name="ln833">            return iterator(z);</a>
<a name="ln834">        }</a>
<a name="ln835">        return this-&gt;insertMulti(akey, avalue);</a>
<a name="ln836">    } else {</a>
<a name="ln837">        // Hint indicates that the node should be less (or equal to) the hint given</a>
<a name="ln838">        // but larger than the previous value.</a>
<a name="ln839">        Node *next = const_cast&lt;Node*&gt;(pos.i);</a>
<a name="ln840">        if (qMapLessThanKey(next-&gt;key, akey))</a>
<a name="ln841">            return this-&gt;insertMulti(akey, avalue); // ignore hint</a>
<a name="ln842"> </a>
<a name="ln843">        if (pos == constBegin()) {</a>
<a name="ln844">            // There is no previous value (insert left most)</a>
<a name="ln845">            Node *z = d-&gt;createNode(akey, avalue, begin().i, true);</a>
<a name="ln846">            return iterator(z);</a>
<a name="ln847">        } else {</a>
<a name="ln848">            Node *prev = const_cast&lt;Node*&gt;(pos.i-&gt;previousNode());</a>
<a name="ln849">            if (!qMapLessThanKey(prev-&gt;key, akey))</a>
<a name="ln850">                return this-&gt;insertMulti(akey, avalue); // ignore hint</a>
<a name="ln851"> </a>
<a name="ln852">            // Hint is ok - do insert</a>
<a name="ln853">            if (prev-&gt;right == nullptr) {</a>
<a name="ln854">                Node *z = d-&gt;createNode(akey, avalue, prev, false);</a>
<a name="ln855">                return iterator(z);</a>
<a name="ln856">            }</a>
<a name="ln857">            if (next-&gt;left == nullptr) {</a>
<a name="ln858">                Node *z = d-&gt;createNode(akey, avalue, next, true);</a>
<a name="ln859">                return iterator(z);</a>
<a name="ln860">            }</a>
<a name="ln861">            Q_ASSERT(false); // We should have prev-&gt;right == nullptr or next-&gt;left == nullptr.</a>
<a name="ln862">            return this-&gt;insertMulti(akey, avalue);</a>
<a name="ln863">        }</a>
<a name="ln864">    }</a>
<a name="ln865">}</a>
<a name="ln866"> </a>
<a name="ln867"> </a>
<a name="ln868">template &lt;class Key, class T&gt;</a>
<a name="ln869">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::const_iterator QMap&lt;Key, T&gt;::constFind(const Key &amp;akey) const</a>
<a name="ln870">{</a>
<a name="ln871">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln872">    return const_iterator(n ? n : d-&gt;end());</a>
<a name="ln873">}</a>
<a name="ln874"> </a>
<a name="ln875">template &lt;class Key, class T&gt;</a>
<a name="ln876">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::const_iterator QMap&lt;Key, T&gt;::find(const Key &amp;akey) const</a>
<a name="ln877">{</a>
<a name="ln878">    return constFind(akey);</a>
<a name="ln879">}</a>
<a name="ln880"> </a>
<a name="ln881">template &lt;class Key, class T&gt;</a>
<a name="ln882">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::find(const Key &amp;akey)</a>
<a name="ln883">{</a>
<a name="ln884">    detach();</a>
<a name="ln885">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln886">    return iterator(n ? n : d-&gt;end());</a>
<a name="ln887">}</a>
<a name="ln888"> </a>
<a name="ln889">template &lt;class Key, class T&gt;</a>
<a name="ln890">Q_INLINE_TEMPLATE QMap&lt;Key, T&gt; &amp;QMap&lt;Key, T&gt;::unite(const QMap&lt;Key, T&gt; &amp;other)</a>
<a name="ln891">{</a>
<a name="ln892">    QMap&lt;Key, T&gt; copy(other);</a>
<a name="ln893">    const_iterator it = copy.constEnd();</a>
<a name="ln894">    const const_iterator b = copy.constBegin();</a>
<a name="ln895">    while (it != b) {</a>
<a name="ln896">        --it;</a>
<a name="ln897">        insertMulti(it.key(), it.value());</a>
<a name="ln898">    }</a>
<a name="ln899">    return *this;</a>
<a name="ln900">}</a>
<a name="ln901"> </a>
<a name="ln902">template &lt;class Key, class T&gt;</a>
<a name="ln903">QPair&lt;typename QMap&lt;Key, T&gt;::iterator, typename QMap&lt;Key, T&gt;::iterator&gt; QMap&lt;Key, T&gt;::equal_range(const Key &amp;akey)</a>
<a name="ln904">{</a>
<a name="ln905">    detach();</a>
<a name="ln906">    Node *firstNode, *lastNode;</a>
<a name="ln907">    d-&gt;nodeRange(akey, &amp;firstNode, &amp;lastNode);</a>
<a name="ln908">    return QPair&lt;iterator, iterator&gt;(iterator(firstNode), iterator(lastNode));</a>
<a name="ln909">}</a>
<a name="ln910"> </a>
<a name="ln911">template &lt;class Key, class T&gt;</a>
<a name="ln912">QPair&lt;typename QMap&lt;Key, T&gt;::const_iterator, typename QMap&lt;Key, T&gt;::const_iterator&gt;</a>
<a name="ln913">QMap&lt;Key, T&gt;::equal_range(const Key &amp;akey) const</a>
<a name="ln914">{</a>
<a name="ln915">    Node *firstNode, *lastNode;</a>
<a name="ln916">    d-&gt;nodeRange(akey, &amp;firstNode, &amp;lastNode);</a>
<a name="ln917">    return qMakePair(const_iterator(firstNode), const_iterator(lastNode));</a>
<a name="ln918">}</a>
<a name="ln919"> </a>
<a name="ln920">#ifdef Q_MAP_DEBUG</a>
<a name="ln921">template &lt;class Key, class T&gt;</a>
<a name="ln922">void QMap&lt;Key, T&gt;::dump() const</a>
<a name="ln923">{</a>
<a name="ln924">    const_iterator it = begin();</a>
<a name="ln925">    qDebug(&quot;map dump:&quot;);</a>
<a name="ln926">    while (it != end()) {</a>
<a name="ln927">        const QMapNodeBase *n = it.i;</a>
<a name="ln928">        int depth = 0;</a>
<a name="ln929">        while (n &amp;&amp; n != d-&gt;root()) {</a>
<a name="ln930">            ++depth;</a>
<a name="ln931">            n = n-&gt;parent();</a>
<a name="ln932">        }</a>
<a name="ln933">        QByteArray space(4*depth, ' ');</a>
<a name="ln934">        qDebug() &lt;&lt; space &lt;&lt; (it.i-&gt;color() == Node::Red ? &quot;Red  &quot; : &quot;Black&quot;) &lt;&lt; it.i &lt;&lt; it.i-&gt;left &lt;&lt; it.i-&gt;right</a>
<a name="ln935">                 &lt;&lt; it.key() &lt;&lt; it.value();</a>
<a name="ln936">        ++it;</a>
<a name="ln937">    }</a>
<a name="ln938">    qDebug(&quot;---------&quot;);</a>
<a name="ln939">}</a>
<a name="ln940">#endif</a>
<a name="ln941"> </a>
<a name="ln942">template &lt;class Key, class T&gt;</a>
<a name="ln943">Q_OUTOFLINE_TEMPLATE int QMap&lt;Key, T&gt;::remove(const Key &amp;akey)</a>
<a name="ln944">{</a>
<a name="ln945">    detach();</a>
<a name="ln946">    int n = 0;</a>
<a name="ln947">    while (Node *node = d-&gt;findNode(akey)) {</a>
<a name="ln948">        d-&gt;deleteNode(node);</a>
<a name="ln949">        ++n;</a>
<a name="ln950">    }</a>
<a name="ln951">    return n;</a>
<a name="ln952">}</a>
<a name="ln953"> </a>
<a name="ln954">template &lt;class Key, class T&gt;</a>
<a name="ln955">Q_OUTOFLINE_TEMPLATE T QMap&lt;Key, T&gt;::take(const Key &amp;akey)</a>
<a name="ln956">{</a>
<a name="ln957">    detach();</a>
<a name="ln958"> </a>
<a name="ln959">    Node *node = d-&gt;findNode(akey);</a>
<a name="ln960">    if (node) {</a>
<a name="ln961">        T t = std::move(node-&gt;value);</a>
<a name="ln962">        d-&gt;deleteNode(node);</a>
<a name="ln963">        return t;</a>
<a name="ln964">    }</a>
<a name="ln965">    return T();</a>
<a name="ln966">}</a>
<a name="ln967"> </a>
<a name="ln968">template &lt;class Key, class T&gt;</a>
<a name="ln969">Q_OUTOFLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::erase(iterator it)</a>
<a name="ln970">{</a>
<a name="ln971">    if (it == iterator(d-&gt;end()))</a>
<a name="ln972">        return it;</a>
<a name="ln973"> </a>
<a name="ln974">    Q_ASSERT_X(isValidIterator(const_iterator(it)), &quot;QMap::erase&quot;, &quot;The specified iterator argument 'it' is invalid&quot;);</a>
<a name="ln975"> </a>
<a name="ln976">    if (d-&gt;ref.isShared()) {</a>
<a name="ln977">        const_iterator oldBegin = constBegin();</a>
<a name="ln978">        const_iterator old = const_iterator(it);</a>
<a name="ln979">        int backStepsWithSameKey = 0;</a>
<a name="ln980"> </a>
<a name="ln981">        while (old != oldBegin) {</a>
<a name="ln982">            --old;</a>
<a name="ln983">            if (qMapLessThanKey(old.key(), it.key()))</a>
<a name="ln984">                break;</a>
<a name="ln985">            ++backStepsWithSameKey;</a>
<a name="ln986">        }</a>
<a name="ln987"> </a>
<a name="ln988">        it = find(old.key()); // ensures detach</a>
<a name="ln989">        Q_ASSERT_X(it != iterator(d-&gt;end()), &quot;QMap::erase&quot;, &quot;Unable to locate same key in erase after detach.&quot;);</a>
<a name="ln990"> </a>
<a name="ln991">        while (backStepsWithSameKey &gt; 0) {</a>
<a name="ln992">            ++it;</a>
<a name="ln993">            --backStepsWithSameKey;</a>
<a name="ln994">        }</a>
<a name="ln995">    }</a>
<a name="ln996"> </a>
<a name="ln997">    Node *n = it.i;</a>
<a name="ln998">    ++it;</a>
<a name="ln999">    d-&gt;deleteNode(n);</a>
<a name="ln1000">    return it;</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">template &lt;class Key, class T&gt;</a>
<a name="ln1004">Q_OUTOFLINE_TEMPLATE void QMap&lt;Key, T&gt;::detach_helper()</a>
<a name="ln1005">{</a>
<a name="ln1006">    QMapData&lt;Key, T&gt; *x = QMapData&lt;Key, T&gt;::create();</a>
<a name="ln1007">    if (d-&gt;header.left) {</a>
<a name="ln1008">        x-&gt;header.left = static_cast&lt;Node *&gt;(d-&gt;header.left)-&gt;copy(x);</a>
<a name="ln1009">        x-&gt;header.left-&gt;setParent(&amp;x-&gt;header);</a>
<a name="ln1010">    }</a>
<a name="ln1011">    if (!d-&gt;ref.deref())</a>
<a name="ln1012">        d-&gt;destroy();</a>
<a name="ln1013">    d = x;</a>
<a name="ln1014">    d-&gt;recalcMostLeftNode();</a>
<a name="ln1015">}</a>
<a name="ln1016"> </a>
<a name="ln1017">template &lt;class Key, class T&gt;</a>
<a name="ln1018">Q_OUTOFLINE_TEMPLATE QList&lt;Key&gt; QMap&lt;Key, T&gt;::uniqueKeys() const</a>
<a name="ln1019">{</a>
<a name="ln1020">    QList&lt;Key&gt; res;</a>
<a name="ln1021">    res.reserve(size()); // May be too much, but assume short lifetime</a>
<a name="ln1022">    const_iterator i = begin();</a>
<a name="ln1023">    if (i != end()) {</a>
<a name="ln1024">        for (;;) {</a>
<a name="ln1025">            const Key &amp;aKey = i.key();</a>
<a name="ln1026">            res.append(aKey);</a>
<a name="ln1027">            do {</a>
<a name="ln1028">                if (++i == end())</a>
<a name="ln1029">                    goto break_out_of_outer_loop;</a>
<a name="ln1030">            } while (!qMapLessThanKey(aKey, i.key()));   // loop while (key == i.key())</a>
<a name="ln1031">        }</a>
<a name="ln1032">    }</a>
<a name="ln1033">break_out_of_outer_loop:</a>
<a name="ln1034">    return res;</a>
<a name="ln1035">}</a>
<a name="ln1036"> </a>
<a name="ln1037">template &lt;class Key, class T&gt;</a>
<a name="ln1038">Q_OUTOFLINE_TEMPLATE QList&lt;Key&gt; QMap&lt;Key, T&gt;::keys() const</a>
<a name="ln1039">{</a>
<a name="ln1040">    QList&lt;Key&gt; res;</a>
<a name="ln1041">    res.reserve(size());</a>
<a name="ln1042">    const_iterator i = begin();</a>
<a name="ln1043">    while (i != end()) {</a>
<a name="ln1044">        res.append(i.key());</a>
<a name="ln1045">        ++i;</a>
<a name="ln1046">    }</a>
<a name="ln1047">    return res;</a>
<a name="ln1048">}</a>
<a name="ln1049"> </a>
<a name="ln1050">template &lt;class Key, class T&gt;</a>
<a name="ln1051">Q_OUTOFLINE_TEMPLATE QList&lt;Key&gt; QMap&lt;Key, T&gt;::keys(const T &amp;avalue) const</a>
<a name="ln1052">{</a>
<a name="ln1053">    QList&lt;Key&gt; res;</a>
<a name="ln1054">    const_iterator i = begin();</a>
<a name="ln1055">    while (i != end()) {</a>
<a name="ln1056">        if (i.value() == avalue)</a>
<a name="ln1057">            res.append(i.key());</a>
<a name="ln1058">        ++i;</a>
<a name="ln1059">    }</a>
<a name="ln1060">    return res;</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">template &lt;class Key, class T&gt;</a>
<a name="ln1064">Q_OUTOFLINE_TEMPLATE const Key QMap&lt;Key, T&gt;::key(const T &amp;avalue, const Key &amp;defaultKey) const</a>
<a name="ln1065">{</a>
<a name="ln1066">    const_iterator i = begin();</a>
<a name="ln1067">    while (i != end()) {</a>
<a name="ln1068">        if (i.value() == avalue)</a>
<a name="ln1069">            return i.key();</a>
<a name="ln1070">        ++i;</a>
<a name="ln1071">    }</a>
<a name="ln1072"> </a>
<a name="ln1073">    return defaultKey;</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076">template &lt;class Key, class T&gt;</a>
<a name="ln1077">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt; QMap&lt;Key, T&gt;::values() const</a>
<a name="ln1078">{</a>
<a name="ln1079">    QList&lt;T&gt; res;</a>
<a name="ln1080">    res.reserve(size());</a>
<a name="ln1081">    const_iterator i = begin();</a>
<a name="ln1082">    while (i != end()) {</a>
<a name="ln1083">        res.append(i.value());</a>
<a name="ln1084">        ++i;</a>
<a name="ln1085">    }</a>
<a name="ln1086">    return res;</a>
<a name="ln1087">}</a>
<a name="ln1088"> </a>
<a name="ln1089">template &lt;class Key, class T&gt;</a>
<a name="ln1090">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt; QMap&lt;Key, T&gt;::values(const Key &amp;akey) const</a>
<a name="ln1091">{</a>
<a name="ln1092">    QList&lt;T&gt; res;</a>
<a name="ln1093">    Node *n = d-&gt;findNode(akey);</a>
<a name="ln1094">    if (n) {</a>
<a name="ln1095">        const_iterator it(n);</a>
<a name="ln1096">        do {</a>
<a name="ln1097">            res.append(*it);</a>
<a name="ln1098">            ++it;</a>
<a name="ln1099">        } while (it != constEnd() &amp;&amp; !qMapLessThanKey&lt;Key&gt;(akey, it.key()));</a>
<a name="ln1100">    }</a>
<a name="ln1101">    return res;</a>
<a name="ln1102">}</a>
<a name="ln1103"> </a>
<a name="ln1104">template &lt;class Key, class T&gt;</a>
<a name="ln1105">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::const_iterator QMap&lt;Key, T&gt;::lowerBound(const Key &amp;akey) const</a>
<a name="ln1106">{</a>
<a name="ln1107">    Node *lb = d-&gt;root() ? d-&gt;root()-&gt;lowerBound(akey) : nullptr;</a>
<a name="ln1108">    if (!lb)</a>
<a name="ln1109">        lb = d-&gt;end();</a>
<a name="ln1110">    return const_iterator(lb);</a>
<a name="ln1111">}</a>
<a name="ln1112"> </a>
<a name="ln1113">template &lt;class Key, class T&gt;</a>
<a name="ln1114">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::lowerBound(const Key &amp;akey)</a>
<a name="ln1115">{</a>
<a name="ln1116">    detach();</a>
<a name="ln1117">    Node *lb = d-&gt;root() ? d-&gt;root()-&gt;lowerBound(akey) : nullptr;</a>
<a name="ln1118">    if (!lb)</a>
<a name="ln1119">        lb = d-&gt;end();</a>
<a name="ln1120">    return iterator(lb);</a>
<a name="ln1121">}</a>
<a name="ln1122"> </a>
<a name="ln1123">template &lt;class Key, class T&gt;</a>
<a name="ln1124">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::const_iterator</a>
<a name="ln1125">QMap&lt;Key, T&gt;::upperBound(const Key &amp;akey) const</a>
<a name="ln1126">{</a>
<a name="ln1127">    Node *ub = d-&gt;root() ? d-&gt;root()-&gt;upperBound(akey) : nullptr;</a>
<a name="ln1128">    if (!ub)</a>
<a name="ln1129">        ub = d-&gt;end();</a>
<a name="ln1130">    return const_iterator(ub);</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">template &lt;class Key, class T&gt;</a>
<a name="ln1134">Q_INLINE_TEMPLATE typename QMap&lt;Key, T&gt;::iterator QMap&lt;Key, T&gt;::upperBound(const Key &amp;akey)</a>
<a name="ln1135">{</a>
<a name="ln1136">    detach();</a>
<a name="ln1137">    Node *ub = d-&gt;root() ? d-&gt;root()-&gt;upperBound(akey) : nullptr;</a>
<a name="ln1138">    if (!ub)</a>
<a name="ln1139">        ub = d-&gt;end();</a>
<a name="ln1140">    return iterator(ub);</a>
<a name="ln1141">}</a>
<a name="ln1142"> </a>
<a name="ln1143">template &lt;class Key, class T&gt;</a>
<a name="ln1144">Q_OUTOFLINE_TEMPLATE bool QMap&lt;Key, T&gt;::operator==(const QMap&lt;Key, T&gt; &amp;other) const</a>
<a name="ln1145">{</a>
<a name="ln1146">    if (size() != other.size())</a>
<a name="ln1147">        return false;</a>
<a name="ln1148">    if (d == other.d)</a>
<a name="ln1149">        return true;</a>
<a name="ln1150"> </a>
<a name="ln1151">    const_iterator it1 = begin();</a>
<a name="ln1152">    const_iterator it2 = other.begin();</a>
<a name="ln1153"> </a>
<a name="ln1154">    while (it1 != end()) {</a>
<a name="ln1155">        if (!(it1.value() == it2.value()) || qMapLessThanKey(it1.key(), it2.key()) || qMapLessThanKey(it2.key(), it1.key()))</a>
<a name="ln1156">            return false;</a>
<a name="ln1157">        ++it2;</a>
<a name="ln1158">        ++it1;</a>
<a name="ln1159">    }</a>
<a name="ln1160">    return true;</a>
<a name="ln1161">}</a>
<a name="ln1162"> </a>
<a name="ln1163">template &lt;class Key, class T&gt;</a>
<a name="ln1164">Q_OUTOFLINE_TEMPLATE QMap&lt;Key, T&gt;::QMap(const std::map&lt;Key, T&gt; &amp;other)</a>
<a name="ln1165">{</a>
<a name="ln1166">    d = QMapData&lt;Key, T&gt;::create();</a>
<a name="ln1167">    typename std::map&lt;Key,T&gt;::const_iterator it = other.end();</a>
<a name="ln1168">    while (it != other.begin()) {</a>
<a name="ln1169">        --it;</a>
<a name="ln1170">        d-&gt;createNode((*it).first, (*it).second, d-&gt;begin(), true); // insert on most left node.</a>
<a name="ln1171">    }</a>
<a name="ln1172">}</a>
<a name="ln1173"> </a>
<a name="ln1174">template &lt;class Key, class T&gt;</a>
<a name="ln1175">Q_OUTOFLINE_TEMPLATE std::map&lt;Key, T&gt; QMap&lt;Key, T&gt;::toStdMap() const</a>
<a name="ln1176">{</a>
<a name="ln1177">    std::map&lt;Key, T&gt; map;</a>
<a name="ln1178">    const_iterator it = end();</a>
<a name="ln1179">    while (it != begin()) {</a>
<a name="ln1180">        --it;</a>
<a name="ln1181">        map.insert(map.begin(), std::pair&lt;Key, T&gt;(it.key(), it.value()));</a>
<a name="ln1182">    }</a>
<a name="ln1183">    return map;</a>
<a name="ln1184">}</a>
<a name="ln1185"> </a>
<a name="ln1186">template &lt;class Key, class T&gt;</a>
<a name="ln1187">class QMultiMap : public QMap&lt;Key, T&gt;</a>
<a name="ln1188">{</a>
<a name="ln1189">public:</a>
<a name="ln1190">    QMultiMap() Q_DECL_NOTHROW {}</a>
<a name="ln1191">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln1192">    inline QMultiMap(std::initializer_list&lt;std::pair&lt;Key,T&gt; &gt; list)</a>
<a name="ln1193">    {</a>
<a name="ln1194">        for (typename std::initializer_list&lt;std::pair&lt;Key,T&gt; &gt;::const_iterator it = list.begin(); it != list.end(); ++it)</a>
<a name="ln1195">            insert(it-&gt;first, it-&gt;second);</a>
<a name="ln1196">    }</a>
<a name="ln1197">#endif</a>
<a name="ln1198">    QMultiMap(const QMap&lt;Key, T&gt; &amp;other) : QMap&lt;Key, T&gt;(other) {}</a>
<a name="ln1199">#ifdef Q_COMPILER_RVALUE_REFS</a>
<a name="ln1200">    QMultiMap(QMap&lt;Key, T&gt; &amp;&amp;other) Q_DECL_NOTHROW : QMap&lt;Key, T&gt;(std::move(other)) {}</a>
<a name="ln1201">#endif</a>
<a name="ln1202">    void swap(QMultiMap&lt;Key, T&gt; &amp;other) Q_DECL_NOTHROW { QMap&lt;Key, T&gt;::swap(other); }</a>
<a name="ln1203"> </a>
<a name="ln1204">    inline typename QMap&lt;Key, T&gt;::iterator replace(const Key &amp;key, const T &amp;value)</a>
<a name="ln1205">    { return QMap&lt;Key, T&gt;::insert(key, value); }</a>
<a name="ln1206">    inline typename QMap&lt;Key, T&gt;::iterator insert(const Key &amp;key, const T &amp;value)</a>
<a name="ln1207">    { return QMap&lt;Key, T&gt;::insertMulti(key, value); }</a>
<a name="ln1208">    inline typename QMap&lt;Key, T&gt;::iterator insert(typename QMap&lt;Key, T&gt;::const_iterator pos, const Key &amp;key, const T &amp;value)</a>
<a name="ln1209">    { return QMap&lt;Key, T&gt;::insertMulti(pos, key, value); }</a>
<a name="ln1210"> </a>
<a name="ln1211">    inline QMultiMap &amp;operator+=(const QMultiMap &amp;other)</a>
<a name="ln1212">    { this-&gt;unite(other); return *this; }</a>
<a name="ln1213">    inline QMultiMap operator+(const QMultiMap &amp;other) const</a>
<a name="ln1214">    { QMultiMap result = *this; result += other; return result; }</a>
<a name="ln1215"> </a>
<a name="ln1216">    using QMap&lt;Key, T&gt;::contains;</a>
<a name="ln1217">    using QMap&lt;Key, T&gt;::remove;</a>
<a name="ln1218">    using QMap&lt;Key, T&gt;::count;</a>
<a name="ln1219">    using QMap&lt;Key, T&gt;::find;</a>
<a name="ln1220">    using QMap&lt;Key, T&gt;::constFind;</a>
<a name="ln1221"> </a>
<a name="ln1222">    bool contains(const Key &amp;key, const T &amp;value) const;</a>
<a name="ln1223"> </a>
<a name="ln1224">    int remove(const Key &amp;key, const T &amp;value);</a>
<a name="ln1225"> </a>
<a name="ln1226">    int count(const Key &amp;key, const T &amp;value) const;</a>
<a name="ln1227"> </a>
<a name="ln1228">    typename QMap&lt;Key, T&gt;::iterator find(const Key &amp;key, const T &amp;value) {</a>
<a name="ln1229">        typename QMap&lt;Key, T&gt;::iterator i(find(key));</a>
<a name="ln1230">        typename QMap&lt;Key, T&gt;::iterator end(this-&gt;end());</a>
<a name="ln1231">        while (i != end &amp;&amp; !qMapLessThanKey&lt;Key&gt;(key, i.key())) {</a>
<a name="ln1232">            if (i.value() == value)</a>
<a name="ln1233">                return i;</a>
<a name="ln1234">            ++i;</a>
<a name="ln1235">        }</a>
<a name="ln1236">        return end;</a>
<a name="ln1237">    }</a>
<a name="ln1238">    typename QMap&lt;Key, T&gt;::const_iterator find(const Key &amp;key, const T &amp;value) const {</a>
<a name="ln1239">        typename QMap&lt;Key, T&gt;::const_iterator i(constFind(key));</a>
<a name="ln1240">        typename QMap&lt;Key, T&gt;::const_iterator end(QMap&lt;Key, T&gt;::constEnd());</a>
<a name="ln1241">        while (i != end &amp;&amp; !qMapLessThanKey&lt;Key&gt;(key, i.key())) {</a>
<a name="ln1242">            if (i.value() == value)</a>
<a name="ln1243">                return i;</a>
<a name="ln1244">            ++i;</a>
<a name="ln1245">        }</a>
<a name="ln1246">        return end;</a>
<a name="ln1247">    }</a>
<a name="ln1248">    typename QMap&lt;Key, T&gt;::const_iterator constFind(const Key &amp;key, const T &amp;value) const</a>
<a name="ln1249">        { return find(key, value); }</a>
<a name="ln1250">private:</a>
<a name="ln1251">    T &amp;operator[](const Key &amp;key);</a>
<a name="ln1252">    const T operator[](const Key &amp;key) const;</a>
<a name="ln1253">};</a>
<a name="ln1254"> </a>
<a name="ln1255">template &lt;class Key, class T&gt;</a>
<a name="ln1256">Q_INLINE_TEMPLATE bool QMultiMap&lt;Key, T&gt;::contains(const Key &amp;key, const T &amp;value) const</a>
<a name="ln1257">{</a>
<a name="ln1258">    return constFind(key, value) != QMap&lt;Key, T&gt;::constEnd();</a>
<a name="ln1259">}</a>
<a name="ln1260"> </a>
<a name="ln1261">template &lt;class Key, class T&gt;</a>
<a name="ln1262">Q_INLINE_TEMPLATE int QMultiMap&lt;Key, T&gt;::remove(const Key &amp;key, const T &amp;value)</a>
<a name="ln1263">{</a>
<a name="ln1264">    int n = 0;</a>
<a name="ln1265">    typename QMap&lt;Key, T&gt;::iterator i(find(key));</a>
<a name="ln1266">    typename QMap&lt;Key, T&gt;::iterator end(QMap&lt;Key, T&gt;::end());</a>
<a name="ln1267">    while (i != end &amp;&amp; !qMapLessThanKey&lt;Key&gt;(key, i.key())) {</a>
<a name="ln1268">        if (i.value() == value) {</a>
<a name="ln1269">            i = this-&gt;erase(i);</a>
<a name="ln1270">            ++n;</a>
<a name="ln1271">        } else {</a>
<a name="ln1272">            ++i;</a>
<a name="ln1273">        }</a>
<a name="ln1274">    }</a>
<a name="ln1275">    return n;</a>
<a name="ln1276">}</a>
<a name="ln1277"> </a>
<a name="ln1278">template &lt;class Key, class T&gt;</a>
<a name="ln1279">Q_INLINE_TEMPLATE int QMultiMap&lt;Key, T&gt;::count(const Key &amp;key, const T &amp;value) const</a>
<a name="ln1280">{</a>
<a name="ln1281">    int n = 0;</a>
<a name="ln1282">    typename QMap&lt;Key, T&gt;::const_iterator i(constFind(key));</a>
<a name="ln1283">    typename QMap&lt;Key, T&gt;::const_iterator end(QMap&lt;Key, T&gt;::constEnd());</a>
<a name="ln1284">    while (i != end &amp;&amp; !qMapLessThanKey&lt;Key&gt;(key, i.key())) {</a>
<a name="ln1285">        if (i.value() == value)</a>
<a name="ln1286">            ++n;</a>
<a name="ln1287">        ++i;</a>
<a name="ln1288">    }</a>
<a name="ln1289">    return n;</a>
<a name="ln1290">}</a>
<a name="ln1291"> </a>
<a name="ln1292">Q_DECLARE_ASSOCIATIVE_ITERATOR(Map)</a>
<a name="ln1293">Q_DECLARE_MUTABLE_ASSOCIATIVE_ITERATOR(Map)</a>
<a name="ln1294"> </a>
<a name="ln1295">QT_END_NAMESPACE</a>
<a name="ln1296"> </a>
<a name="ln1297">#endif // QMAP_H</a>

</code></pre>
<div class="balloon" rel="214"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapNodeBase' to derived class 'QMapNode'.</p></div>
<div class="balloon" rel="215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapNodeBase' to derived class 'QMapNode'.</p></div>
<div class="balloon" rel="328"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapDataBase' to derived class 'QMapData'.</p></div>
<div class="balloon" rel="331"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapDataBase' to derived class 'QMapData'.</p></div>
<div class="balloon" rel="346"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v717/" target="_blank">V717</a> It is suspicious to cast object of base class 'QMapDataBase' to derived class 'QMapData'.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
