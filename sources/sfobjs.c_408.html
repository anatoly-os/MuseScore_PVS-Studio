
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>sfobjs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***************************************************************************/</a>
<a name="ln2">/*                                                                         */</a>
<a name="ln3">/*  sfobjs.c                                                               */</a>
<a name="ln4">/*                                                                         */</a>
<a name="ln5">/*    SFNT object management (base).                                       */</a>
<a name="ln6">/*                                                                         */</a>
<a name="ln7">/*  Copyright 1996-2015 by                                                 */</a>
<a name="ln8">/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</a>
<a name="ln9">/*                                                                         */</a>
<a name="ln10">/*  This file is part of the FreeType project, and may only be used,       */</a>
<a name="ln11">/*  modified, and distributed under the terms of the FreeType project      */</a>
<a name="ln12">/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</a>
<a name="ln13">/*  this file you indicate that you have read the license and              */</a>
<a name="ln14">/*  understand and accept it fully.                                        */</a>
<a name="ln15">/*                                                                         */</a>
<a name="ln16">/***************************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;ft2build.h&gt;</a>
<a name="ln20">#include &quot;sfobjs.h&quot;</a>
<a name="ln21">#include &quot;ttload.h&quot;</a>
<a name="ln22">#include &quot;ttcmap.h&quot;</a>
<a name="ln23">#include &quot;ttkern.h&quot;</a>
<a name="ln24">#include FT_INTERNAL_SFNT_H</a>
<a name="ln25">#include FT_INTERNAL_DEBUG_H</a>
<a name="ln26">#include FT_TRUETYPE_IDS_H</a>
<a name="ln27">#include FT_TRUETYPE_TAGS_H</a>
<a name="ln28">#include FT_SERVICE_POSTSCRIPT_CMAPS_H</a>
<a name="ln29">#include FT_SFNT_NAMES_H</a>
<a name="ln30">#include FT_GZIP_H</a>
<a name="ln31">#include &quot;sferrors.h&quot;</a>
<a name="ln32"> </a>
<a name="ln33">#ifdef TT_CONFIG_OPTION_BDF</a>
<a name="ln34">#include &quot;ttbdf.h&quot;</a>
<a name="ln35">#endif</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">  /*************************************************************************/</a>
<a name="ln39">  /*                                                                       */</a>
<a name="ln40">  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</a>
<a name="ln41">  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</a>
<a name="ln42">  /* messages during execution.                                            */</a>
<a name="ln43">  /*                                                                       */</a>
<a name="ln44">#undef  FT_COMPONENT</a>
<a name="ln45">#define FT_COMPONENT  trace_sfobjs</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48"> </a>
<a name="ln49">  /* convert a UTF-16 name entry to ASCII */</a>
<a name="ln50">  static FT_String*</a>
<a name="ln51">  tt_name_entry_ascii_from_utf16( TT_NameEntry  entry,</a>
<a name="ln52">                                  FT_Memory     memory )</a>
<a name="ln53">  {</a>
<a name="ln54">    FT_String*  string = NULL;</a>
<a name="ln55">    FT_UInt     len, code, n;</a>
<a name="ln56">    FT_Byte*    read   = (FT_Byte*)entry-&gt;string;</a>
<a name="ln57">    FT_Error    error;</a>
<a name="ln58"> </a>
<a name="ln59"> </a>
<a name="ln60">    len = (FT_UInt)entry-&gt;stringLength / 2;</a>
<a name="ln61"> </a>
<a name="ln62">    if ( FT_NEW_ARRAY( string, len + 1 ) )</a>
<a name="ln63">      return NULL;</a>
<a name="ln64"> </a>
<a name="ln65">    for ( n = 0; n &lt; len; n++ )</a>
<a name="ln66">    {</a>
<a name="ln67">      code = FT_NEXT_USHORT( read );</a>
<a name="ln68"> </a>
<a name="ln69">      if ( code == 0 )</a>
<a name="ln70">        break;</a>
<a name="ln71"> </a>
<a name="ln72">      if ( code &lt; 32 || code &gt; 127 )</a>
<a name="ln73">        code = '?';</a>
<a name="ln74"> </a>
<a name="ln75">      string[n] = (char)code;</a>
<a name="ln76">    }</a>
<a name="ln77"> </a>
<a name="ln78">    string[n] = 0;</a>
<a name="ln79"> </a>
<a name="ln80">    return string;</a>
<a name="ln81">  }</a>
<a name="ln82"> </a>
<a name="ln83"> </a>
<a name="ln84">  /* convert an Apple Roman or symbol name entry to ASCII */</a>
<a name="ln85">  static FT_String*</a>
<a name="ln86">  tt_name_entry_ascii_from_other( TT_NameEntry  entry,</a>
<a name="ln87">                                  FT_Memory     memory )</a>
<a name="ln88">  {</a>
<a name="ln89">    FT_String*  string = NULL;</a>
<a name="ln90">    FT_UInt     len, code, n;</a>
<a name="ln91">    FT_Byte*    read   = (FT_Byte*)entry-&gt;string;</a>
<a name="ln92">    FT_Error    error;</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">    len = (FT_UInt)entry-&gt;stringLength;</a>
<a name="ln96"> </a>
<a name="ln97">    if ( FT_NEW_ARRAY( string, len + 1 ) )</a>
<a name="ln98">      return NULL;</a>
<a name="ln99"> </a>
<a name="ln100">    for ( n = 0; n &lt; len; n++ )</a>
<a name="ln101">    {</a>
<a name="ln102">      code = *read++;</a>
<a name="ln103"> </a>
<a name="ln104">      if ( code == 0 )</a>
<a name="ln105">        break;</a>
<a name="ln106"> </a>
<a name="ln107">      if ( code &lt; 32 || code &gt; 127 )</a>
<a name="ln108">        code = '?';</a>
<a name="ln109"> </a>
<a name="ln110">      string[n] = (char)code;</a>
<a name="ln111">    }</a>
<a name="ln112"> </a>
<a name="ln113">    string[n] = 0;</a>
<a name="ln114"> </a>
<a name="ln115">    return string;</a>
<a name="ln116">  }</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">  typedef FT_String*  (*TT_NameEntry_ConvertFunc)( TT_NameEntry  entry,</a>
<a name="ln120">                                                   FT_Memory     memory );</a>
<a name="ln121"> </a>
<a name="ln122"> </a>
<a name="ln123">  /* documentation is in sfnt.h */</a>
<a name="ln124"> </a>
<a name="ln125">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln126">  tt_face_get_name( TT_Face      face,</a>
<a name="ln127">                    FT_UShort    nameid,</a>
<a name="ln128">                    FT_String**  name )</a>
<a name="ln129">  {</a>
<a name="ln130">    FT_Memory         memory = face-&gt;root.memory;</a>
<a name="ln131">    FT_Error          error  = FT_Err_Ok;</a>
<a name="ln132">    FT_String*        result = NULL;</a>
<a name="ln133">    FT_UShort         n;</a>
<a name="ln134">    TT_NameEntryRec*  rec;</a>
<a name="ln135">    FT_Int            found_apple         = -1;</a>
<a name="ln136">    FT_Int            found_apple_roman   = -1;</a>
<a name="ln137">    FT_Int            found_apple_english = -1;</a>
<a name="ln138">    FT_Int            found_win           = -1;</a>
<a name="ln139">    FT_Int            found_unicode       = -1;</a>
<a name="ln140"> </a>
<a name="ln141">    FT_Bool           is_english = 0;</a>
<a name="ln142"> </a>
<a name="ln143">    TT_NameEntry_ConvertFunc  convert;</a>
<a name="ln144"> </a>
<a name="ln145"> </a>
<a name="ln146">    FT_ASSERT( name );</a>
<a name="ln147"> </a>
<a name="ln148">    rec = face-&gt;name_table.names;</a>
<a name="ln149">    for ( n = 0; n &lt; face-&gt;num_names; n++, rec++ )</a>
<a name="ln150">    {</a>
<a name="ln151">      /* According to the OpenType 1.3 specification, only Microsoft or  */</a>
<a name="ln152">      /* Apple platform IDs might be used in the `name' table.  The      */</a>
<a name="ln153">      /* `Unicode' platform is reserved for the `cmap' table, and the    */</a>
<a name="ln154">      /* `ISO' one is deprecated.                                        */</a>
<a name="ln155">      /*                                                                 */</a>
<a name="ln156">      /* However, the Apple TrueType specification doesn't say the same  */</a>
<a name="ln157">      /* thing and goes to suggest that all Unicode `name' table entries */</a>
<a name="ln158">      /* should be coded in UTF-16 (in big-endian format I suppose).     */</a>
<a name="ln159">      /*                                                                 */</a>
<a name="ln160">      if ( rec-&gt;nameID == nameid &amp;&amp; rec-&gt;stringLength &gt; 0 )</a>
<a name="ln161">      {</a>
<a name="ln162">        switch ( rec-&gt;platformID )</a>
<a name="ln163">        {</a>
<a name="ln164">        case TT_PLATFORM_APPLE_UNICODE:</a>
<a name="ln165">        case TT_PLATFORM_ISO:</a>
<a name="ln166">          /* there is `languageID' to check there.  We should use this */</a>
<a name="ln167">          /* field only as a last solution when nothing else is        */</a>
<a name="ln168">          /* available.                                                */</a>
<a name="ln169">          /*                                                           */</a>
<a name="ln170">          found_unicode = n;</a>
<a name="ln171">          break;</a>
<a name="ln172"> </a>
<a name="ln173">        case TT_PLATFORM_MACINTOSH:</a>
<a name="ln174">          /* This is a bit special because some fonts will use either    */</a>
<a name="ln175">          /* an English language id, or a Roman encoding id, to indicate */</a>
<a name="ln176">          /* the English version of its font name.                       */</a>
<a name="ln177">          /*                                                             */</a>
<a name="ln178">          if ( rec-&gt;languageID == TT_MAC_LANGID_ENGLISH )</a>
<a name="ln179">            found_apple_english = n;</a>
<a name="ln180">          else if ( rec-&gt;encodingID == TT_MAC_ID_ROMAN )</a>
<a name="ln181">            found_apple_roman = n;</a>
<a name="ln182">          break;</a>
<a name="ln183"> </a>
<a name="ln184">        case TT_PLATFORM_MICROSOFT:</a>
<a name="ln185">          /* we only take a non-English name when there is nothing */</a>
<a name="ln186">          /* else available in the font                            */</a>
<a name="ln187">          /*                                                       */</a>
<a name="ln188">          if ( found_win == -1 || ( rec-&gt;languageID &amp; 0x3FF ) == 0x009 )</a>
<a name="ln189">          {</a>
<a name="ln190">            switch ( rec-&gt;encodingID )</a>
<a name="ln191">            {</a>
<a name="ln192">            case TT_MS_ID_SYMBOL_CS:</a>
<a name="ln193">            case TT_MS_ID_UNICODE_CS:</a>
<a name="ln194">            case TT_MS_ID_UCS_4:</a>
<a name="ln195">              is_english = FT_BOOL( ( rec-&gt;languageID &amp; 0x3FF ) == 0x009 );</a>
<a name="ln196">              found_win  = n;</a>
<a name="ln197">              break;</a>
<a name="ln198"> </a>
<a name="ln199">            default:</a>
<a name="ln200">              ;</a>
<a name="ln201">            }</a>
<a name="ln202">          }</a>
<a name="ln203">          break;</a>
<a name="ln204"> </a>
<a name="ln205">        default:</a>
<a name="ln206">          ;</a>
<a name="ln207">        }</a>
<a name="ln208">      }</a>
<a name="ln209">    }</a>
<a name="ln210"> </a>
<a name="ln211">    found_apple = found_apple_roman;</a>
<a name="ln212">    if ( found_apple_english &gt;= 0 )</a>
<a name="ln213">      found_apple = found_apple_english;</a>
<a name="ln214"> </a>
<a name="ln215">    /* some fonts contain invalid Unicode or Macintosh formatted entries; */</a>
<a name="ln216">    /* we will thus favor names encoded in Windows formats if available   */</a>
<a name="ln217">    /* (provided it is an English name)                                   */</a>
<a name="ln218">    /*                                                                    */</a>
<a name="ln219">    convert = NULL;</a>
<a name="ln220">    if ( found_win &gt;= 0 &amp;&amp; !( found_apple &gt;= 0 &amp;&amp; !is_english ) )</a>
<a name="ln221">    {</a>
<a name="ln222">      rec = face-&gt;name_table.names + found_win;</a>
<a name="ln223">      switch ( rec-&gt;encodingID )</a>
<a name="ln224">      {</a>
<a name="ln225">        /* all Unicode strings are encoded using UTF-16BE */</a>
<a name="ln226">      case TT_MS_ID_UNICODE_CS:</a>
<a name="ln227">      case TT_MS_ID_SYMBOL_CS:</a>
<a name="ln228">        convert = tt_name_entry_ascii_from_utf16;</a>
<a name="ln229">        break;</a>
<a name="ln230"> </a>
<a name="ln231">      case TT_MS_ID_UCS_4:</a>
<a name="ln232">        /* Apparently, if this value is found in a name table entry, it is */</a>
<a name="ln233">        /* documented as `full Unicode repertoire'.  Experience with the   */</a>
<a name="ln234">        /* MsGothic font shipped with Windows Vista shows that this really */</a>
<a name="ln235">        /* means UTF-16 encoded names (UCS-4 values are only used within   */</a>
<a name="ln236">        /* charmaps).                                                      */</a>
<a name="ln237">        convert = tt_name_entry_ascii_from_utf16;</a>
<a name="ln238">        break;</a>
<a name="ln239"> </a>
<a name="ln240">      default:</a>
<a name="ln241">        ;</a>
<a name="ln242">      }</a>
<a name="ln243">    }</a>
<a name="ln244">    else if ( found_apple &gt;= 0 )</a>
<a name="ln245">    {</a>
<a name="ln246">      rec     = face-&gt;name_table.names + found_apple;</a>
<a name="ln247">      convert = tt_name_entry_ascii_from_other;</a>
<a name="ln248">    }</a>
<a name="ln249">    else if ( found_unicode &gt;= 0 )</a>
<a name="ln250">    {</a>
<a name="ln251">      rec     = face-&gt;name_table.names + found_unicode;</a>
<a name="ln252">      convert = tt_name_entry_ascii_from_utf16;</a>
<a name="ln253">    }</a>
<a name="ln254"> </a>
<a name="ln255">    if ( rec &amp;&amp; convert )</a>
<a name="ln256">    {</a>
<a name="ln257">      if ( rec-&gt;string == NULL )</a>
<a name="ln258">      {</a>
<a name="ln259">        FT_Stream  stream = face-&gt;name_table.stream;</a>
<a name="ln260"> </a>
<a name="ln261"> </a>
<a name="ln262">        if ( FT_QNEW_ARRAY ( rec-&gt;string, rec-&gt;stringLength ) ||</a>
<a name="ln263">             FT_STREAM_SEEK( rec-&gt;stringOffset )              ||</a>
<a name="ln264">             FT_STREAM_READ( rec-&gt;string, rec-&gt;stringLength ) )</a>
<a name="ln265">        {</a>
<a name="ln266">          FT_FREE( rec-&gt;string );</a>
<a name="ln267">          rec-&gt;stringLength = 0;</a>
<a name="ln268">          result            = NULL;</a>
<a name="ln269">          goto Exit;</a>
<a name="ln270">        }</a>
<a name="ln271">      }</a>
<a name="ln272"> </a>
<a name="ln273">      result = convert( rec, memory );</a>
<a name="ln274">    }</a>
<a name="ln275"> </a>
<a name="ln276">  Exit:</a>
<a name="ln277">    *name = result;</a>
<a name="ln278">    return error;</a>
<a name="ln279">  }</a>
<a name="ln280"> </a>
<a name="ln281"> </a>
<a name="ln282">  static FT_Encoding</a>
<a name="ln283">  sfnt_find_encoding( int  platform_id,</a>
<a name="ln284">                      int  encoding_id )</a>
<a name="ln285">  {</a>
<a name="ln286">    typedef struct  TEncoding_</a>
<a name="ln287">    {</a>
<a name="ln288">      int          platform_id;</a>
<a name="ln289">      int          encoding_id;</a>
<a name="ln290">      FT_Encoding  encoding;</a>
<a name="ln291"> </a>
<a name="ln292">    } TEncoding;</a>
<a name="ln293"> </a>
<a name="ln294">    static</a>
<a name="ln295">    const TEncoding  tt_encodings[] =</a>
<a name="ln296">    {</a>
<a name="ln297">      { TT_PLATFORM_ISO,           -1,                  FT_ENCODING_UNICODE },</a>
<a name="ln298"> </a>
<a name="ln299">      { TT_PLATFORM_APPLE_UNICODE, -1,                  FT_ENCODING_UNICODE },</a>
<a name="ln300"> </a>
<a name="ln301">      { TT_PLATFORM_MACINTOSH,     TT_MAC_ID_ROMAN,     FT_ENCODING_APPLE_ROMAN },</a>
<a name="ln302"> </a>
<a name="ln303">      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SYMBOL_CS,  FT_ENCODING_MS_SYMBOL },</a>
<a name="ln304">      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UCS_4,      FT_ENCODING_UNICODE },</a>
<a name="ln305">      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_UNICODE_CS, FT_ENCODING_UNICODE },</a>
<a name="ln306">      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_SJIS,       FT_ENCODING_SJIS },</a>
<a name="ln307">      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_GB2312,     FT_ENCODING_GB2312 },</a>
<a name="ln308">      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_BIG_5,      FT_ENCODING_BIG5 },</a>
<a name="ln309">      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_WANSUNG,    FT_ENCODING_WANSUNG },</a>
<a name="ln310">      { TT_PLATFORM_MICROSOFT,     TT_MS_ID_JOHAB,      FT_ENCODING_JOHAB }</a>
<a name="ln311">    };</a>
<a name="ln312"> </a>
<a name="ln313">    const TEncoding  *cur, *limit;</a>
<a name="ln314"> </a>
<a name="ln315"> </a>
<a name="ln316">    cur   = tt_encodings;</a>
<a name="ln317">    limit = cur + sizeof ( tt_encodings ) / sizeof ( tt_encodings[0] );</a>
<a name="ln318"> </a>
<a name="ln319">    for ( ; cur &lt; limit; cur++ )</a>
<a name="ln320">    {</a>
<a name="ln321">      if ( cur-&gt;platform_id == platform_id )</a>
<a name="ln322">      {</a>
<a name="ln323">        if ( cur-&gt;encoding_id == encoding_id ||</a>
<a name="ln324">             cur-&gt;encoding_id == -1          )</a>
<a name="ln325">          return cur-&gt;encoding;</a>
<a name="ln326">      }</a>
<a name="ln327">    }</a>
<a name="ln328"> </a>
<a name="ln329">    return FT_ENCODING_NONE;</a>
<a name="ln330">  }</a>
<a name="ln331"> </a>
<a name="ln332"> </a>
<a name="ln333">#define WRITE_USHORT( p, v )                \</a>
<a name="ln334">          do                                \</a>
<a name="ln335">          {                                 \</a>
<a name="ln336">            *(p)++ = (FT_Byte)( (v) &gt;&gt; 8 ); \</a>
<a name="ln337">            *(p)++ = (FT_Byte)( (v) &gt;&gt; 0 ); \</a>
<a name="ln338">                                            \</a>
<a name="ln339">          } while ( 0 )</a>
<a name="ln340"> </a>
<a name="ln341">#define WRITE_ULONG( p, v )                  \</a>
<a name="ln342">          do                                 \</a>
<a name="ln343">          {                                  \</a>
<a name="ln344">            *(p)++ = (FT_Byte)( (v) &gt;&gt; 24 ); \</a>
<a name="ln345">            *(p)++ = (FT_Byte)( (v) &gt;&gt; 16 ); \</a>
<a name="ln346">            *(p)++ = (FT_Byte)( (v) &gt;&gt;  8 ); \</a>
<a name="ln347">            *(p)++ = (FT_Byte)( (v) &gt;&gt;  0 ); \</a>
<a name="ln348">                                             \</a>
<a name="ln349">          } while ( 0 )</a>
<a name="ln350"> </a>
<a name="ln351"> </a>
<a name="ln352">  static void</a>
<a name="ln353">  sfnt_stream_close( FT_Stream  stream )</a>
<a name="ln354">  {</a>
<a name="ln355">    FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358">    FT_FREE( stream-&gt;base );</a>
<a name="ln359"> </a>
<a name="ln360">    stream-&gt;size  = 0;</a>
<a name="ln361">    stream-&gt;base  = NULL;</a>
<a name="ln362">    stream-&gt;close = NULL;</a>
<a name="ln363">  }</a>
<a name="ln364"> </a>
<a name="ln365"> </a>
<a name="ln366">  FT_CALLBACK_DEF( int )</a>
<a name="ln367">  compare_offsets( const void*  a,</a>
<a name="ln368">                   const void*  b )</a>
<a name="ln369">  {</a>
<a name="ln370">    WOFF_Table  table1 = *(WOFF_Table*)a;</a>
<a name="ln371">    WOFF_Table  table2 = *(WOFF_Table*)b;</a>
<a name="ln372"> </a>
<a name="ln373">    FT_ULong  offset1 = table1-&gt;Offset;</a>
<a name="ln374">    FT_ULong  offset2 = table2-&gt;Offset;</a>
<a name="ln375"> </a>
<a name="ln376"> </a>
<a name="ln377">    if ( offset1 &gt; offset2 )</a>
<a name="ln378">      return 1;</a>
<a name="ln379">    else if ( offset1 &lt; offset2 )</a>
<a name="ln380">      return -1;</a>
<a name="ln381">    else</a>
<a name="ln382">      return 0;</a>
<a name="ln383">  }</a>
<a name="ln384"> </a>
<a name="ln385"> </a>
<a name="ln386">  /* Replace `face-&gt;root.stream' with a stream containing the extracted */</a>
<a name="ln387">  /* SFNT of a WOFF font.                                               */</a>
<a name="ln388"> </a>
<a name="ln389">  static FT_Error</a>
<a name="ln390">  woff_open_font( FT_Stream  stream,</a>
<a name="ln391">                  TT_Face    face )</a>
<a name="ln392">  {</a>
<a name="ln393">    FT_Memory       memory = stream-&gt;memory;</a>
<a name="ln394">    FT_Error        error  = FT_Err_Ok;</a>
<a name="ln395"> </a>
<a name="ln396">    WOFF_HeaderRec  woff;</a>
<a name="ln397">    WOFF_Table      tables  = NULL;</a>
<a name="ln398">    WOFF_Table*     indices = NULL;</a>
<a name="ln399"> </a>
<a name="ln400">    FT_ULong        woff_offset;</a>
<a name="ln401"> </a>
<a name="ln402">    FT_Byte*        sfnt        = NULL;</a>
<a name="ln403">    FT_Stream       sfnt_stream = NULL;</a>
<a name="ln404"> </a>
<a name="ln405">    FT_Byte*        sfnt_header;</a>
<a name="ln406">    FT_ULong        sfnt_offset;</a>
<a name="ln407"> </a>
<a name="ln408">    FT_Int          nn;</a>
<a name="ln409">    FT_ULong        old_tag = 0;</a>
<a name="ln410"> </a>
<a name="ln411">    static const FT_Frame_Field  woff_header_fields[] =</a>
<a name="ln412">    {</a>
<a name="ln413">#undef  FT_STRUCTURE</a>
<a name="ln414">#define FT_STRUCTURE  WOFF_HeaderRec</a>
<a name="ln415"> </a>
<a name="ln416">      FT_FRAME_START( 44 ),</a>
<a name="ln417">        FT_FRAME_ULONG ( signature ),</a>
<a name="ln418">        FT_FRAME_ULONG ( flavor ),</a>
<a name="ln419">        FT_FRAME_ULONG ( length ),</a>
<a name="ln420">        FT_FRAME_USHORT( num_tables ),</a>
<a name="ln421">        FT_FRAME_USHORT( reserved ),</a>
<a name="ln422">        FT_FRAME_ULONG ( totalSfntSize ),</a>
<a name="ln423">        FT_FRAME_USHORT( majorVersion ),</a>
<a name="ln424">        FT_FRAME_USHORT( minorVersion ),</a>
<a name="ln425">        FT_FRAME_ULONG ( metaOffset ),</a>
<a name="ln426">        FT_FRAME_ULONG ( metaLength ),</a>
<a name="ln427">        FT_FRAME_ULONG ( metaOrigLength ),</a>
<a name="ln428">        FT_FRAME_ULONG ( privOffset ),</a>
<a name="ln429">        FT_FRAME_ULONG ( privLength ),</a>
<a name="ln430">      FT_FRAME_END</a>
<a name="ln431">    };</a>
<a name="ln432"> </a>
<a name="ln433"> </a>
<a name="ln434">    FT_ASSERT( stream == face-&gt;root.stream );</a>
<a name="ln435">    FT_ASSERT( FT_STREAM_POS() == 0 );</a>
<a name="ln436"> </a>
<a name="ln437">    if ( FT_STREAM_READ_FIELDS( woff_header_fields, &amp;woff ) )</a>
<a name="ln438">      return error;</a>
<a name="ln439"> </a>
<a name="ln440">    /* Make sure we don't recurse back here or hit TTC code. */</a>
<a name="ln441">    if ( woff.flavor == TTAG_wOFF || woff.flavor == TTAG_ttcf )</a>
<a name="ln442">      return FT_THROW( Invalid_Table );</a>
<a name="ln443"> </a>
<a name="ln444">    /* Miscellaneous checks. */</a>
<a name="ln445">    if ( woff.length != stream-&gt;size                              ||</a>
<a name="ln446">         woff.num_tables == 0                                     ||</a>
<a name="ln447">         44 + woff.num_tables * 20UL &gt;= woff.length               ||</a>
<a name="ln448">         12 + woff.num_tables * 16UL &gt;= woff.totalSfntSize        ||</a>
<a name="ln449">         ( woff.totalSfntSize &amp; 3 ) != 0                          ||</a>
<a name="ln450">         ( woff.metaOffset == 0 &amp;&amp; ( woff.metaLength != 0     ||</a>
<a name="ln451">                                     woff.metaOrigLength != 0 ) ) ||</a>
<a name="ln452">         ( woff.metaLength != 0 &amp;&amp; woff.metaOrigLength == 0 )     ||</a>
<a name="ln453">         ( woff.privOffset == 0 &amp;&amp; woff.privLength != 0 )         )</a>
<a name="ln454">      return FT_THROW( Invalid_Table );</a>
<a name="ln455"> </a>
<a name="ln456">    if ( FT_ALLOC( sfnt, woff.totalSfntSize ) ||</a>
<a name="ln457">         FT_NEW( sfnt_stream )                )</a>
<a name="ln458">      goto Exit;</a>
<a name="ln459"> </a>
<a name="ln460">    sfnt_header = sfnt;</a>
<a name="ln461"> </a>
<a name="ln462">    /* Write sfnt header. */</a>
<a name="ln463">    {</a>
<a name="ln464">      FT_UInt  searchRange, entrySelector, rangeShift, x;</a>
<a name="ln465"> </a>
<a name="ln466"> </a>
<a name="ln467">      x             = woff.num_tables;</a>
<a name="ln468">      entrySelector = 0;</a>
<a name="ln469">      while ( x )</a>
<a name="ln470">      {</a>
<a name="ln471">        x            &gt;&gt;= 1;</a>
<a name="ln472">        entrySelector += 1;</a>
<a name="ln473">      }</a>
<a name="ln474">      entrySelector--;</a>
<a name="ln475"> </a>
<a name="ln476">      searchRange = ( 1 &lt;&lt; entrySelector ) * 16;</a>
<a name="ln477">      rangeShift  = woff.num_tables * 16 - searchRange;</a>
<a name="ln478"> </a>
<a name="ln479">      WRITE_ULONG ( sfnt_header, woff.flavor );</a>
<a name="ln480">      WRITE_USHORT( sfnt_header, woff.num_tables );</a>
<a name="ln481">      WRITE_USHORT( sfnt_header, searchRange );</a>
<a name="ln482">      WRITE_USHORT( sfnt_header, entrySelector );</a>
<a name="ln483">      WRITE_USHORT( sfnt_header, rangeShift );</a>
<a name="ln484">    }</a>
<a name="ln485"> </a>
<a name="ln486">    /* While the entries in the sfnt header must be sorted by the */</a>
<a name="ln487">    /* tag value, the tables themselves are not.  We thus have to */</a>
<a name="ln488">    /* sort them by offset and check that they don't overlap.     */</a>
<a name="ln489"> </a>
<a name="ln490">    if ( FT_NEW_ARRAY( tables, woff.num_tables )  ||</a>
<a name="ln491">         FT_NEW_ARRAY( indices, woff.num_tables ) )</a>
<a name="ln492">      goto Exit;</a>
<a name="ln493"> </a>
<a name="ln494">    FT_TRACE2(( &quot;\n&quot;</a>
<a name="ln495">                &quot;  tag    offset    compLen  origLen  checksum\n&quot;</a>
<a name="ln496">                &quot;  -------------------------------------------\n&quot; ));</a>
<a name="ln497"> </a>
<a name="ln498">    if ( FT_FRAME_ENTER( 20L * woff.num_tables ) )</a>
<a name="ln499">      goto Exit;</a>
<a name="ln500"> </a>
<a name="ln501">    for ( nn = 0; nn &lt; woff.num_tables; nn++ )</a>
<a name="ln502">    {</a>
<a name="ln503">      WOFF_Table  table = tables + nn;</a>
<a name="ln504"> </a>
<a name="ln505">      table-&gt;Tag        = FT_GET_TAG4();</a>
<a name="ln506">      table-&gt;Offset     = FT_GET_ULONG();</a>
<a name="ln507">      table-&gt;CompLength = FT_GET_ULONG();</a>
<a name="ln508">      table-&gt;OrigLength = FT_GET_ULONG();</a>
<a name="ln509">      table-&gt;CheckSum   = FT_GET_ULONG();</a>
<a name="ln510"> </a>
<a name="ln511">      FT_TRACE2(( &quot;  %c%c%c%c  %08lx  %08lx  %08lx  %08lx\n&quot;,</a>
<a name="ln512">                  (FT_Char)( table-&gt;Tag &gt;&gt; 24 ),</a>
<a name="ln513">                  (FT_Char)( table-&gt;Tag &gt;&gt; 16 ),</a>
<a name="ln514">                  (FT_Char)( table-&gt;Tag &gt;&gt; 8  ),</a>
<a name="ln515">                  (FT_Char)( table-&gt;Tag       ),</a>
<a name="ln516">                  table-&gt;Offset,</a>
<a name="ln517">                  table-&gt;CompLength,</a>
<a name="ln518">                  table-&gt;OrigLength,</a>
<a name="ln519">                  table-&gt;CheckSum ));</a>
<a name="ln520"> </a>
<a name="ln521">      if ( table-&gt;Tag &lt;= old_tag )</a>
<a name="ln522">      {</a>
<a name="ln523">        FT_FRAME_EXIT();</a>
<a name="ln524">        error = FT_THROW( Invalid_Table );</a>
<a name="ln525">        goto Exit;</a>
<a name="ln526">      }</a>
<a name="ln527"> </a>
<a name="ln528">      old_tag     = table-&gt;Tag;</a>
<a name="ln529">      indices[nn] = table;</a>
<a name="ln530">    }</a>
<a name="ln531"> </a>
<a name="ln532">    FT_FRAME_EXIT();</a>
<a name="ln533"> </a>
<a name="ln534">    /* Sort by offset. */</a>
<a name="ln535"> </a>
<a name="ln536">    ft_qsort( indices,</a>
<a name="ln537">              woff.num_tables,</a>
<a name="ln538">              sizeof ( WOFF_Table ),</a>
<a name="ln539">              compare_offsets );</a>
<a name="ln540"> </a>
<a name="ln541">    /* Check offsets and lengths. */</a>
<a name="ln542"> </a>
<a name="ln543">    woff_offset = 44 + woff.num_tables * 20L;</a>
<a name="ln544">    sfnt_offset = 12 + woff.num_tables * 16L;</a>
<a name="ln545"> </a>
<a name="ln546">    for ( nn = 0; nn &lt; woff.num_tables; nn++ )</a>
<a name="ln547">    {</a>
<a name="ln548">      WOFF_Table  table = indices[nn];</a>
<a name="ln549"> </a>
<a name="ln550"> </a>
<a name="ln551">      if ( table-&gt;Offset != woff_offset                         ||</a>
<a name="ln552">           table-&gt;CompLength &gt; woff.length                      ||</a>
<a name="ln553">           table-&gt;Offset &gt; woff.length - table-&gt;CompLength      ||</a>
<a name="ln554">           table-&gt;OrigLength &gt; woff.totalSfntSize               ||</a>
<a name="ln555">           sfnt_offset &gt; woff.totalSfntSize - table-&gt;OrigLength ||</a>
<a name="ln556">           table-&gt;CompLength &gt; table-&gt;OrigLength                )</a>
<a name="ln557">      {</a>
<a name="ln558">        error = FT_THROW( Invalid_Table );</a>
<a name="ln559">        goto Exit;</a>
<a name="ln560">      }</a>
<a name="ln561"> </a>
<a name="ln562">      table-&gt;OrigOffset = sfnt_offset;</a>
<a name="ln563"> </a>
<a name="ln564">      /* The offsets must be multiples of 4. */</a>
<a name="ln565">      woff_offset += ( table-&gt;CompLength + 3 ) &amp; ~3U;</a>
<a name="ln566">      sfnt_offset += ( table-&gt;OrigLength + 3 ) &amp; ~3U;</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    /*</a>
<a name="ln570">     * Final checks!</a>
<a name="ln571">     *</a>
<a name="ln572">     * We don't decode and check the metadata block.</a>
<a name="ln573">     * We don't check table checksums either.</a>
<a name="ln574">     * But other than those, I think we implement all</a>
<a name="ln575">     * `MUST' checks from the spec.</a>
<a name="ln576">     */</a>
<a name="ln577"> </a>
<a name="ln578">    if ( woff.metaOffset )</a>
<a name="ln579">    {</a>
<a name="ln580">      if ( woff.metaOffset != woff_offset                  ||</a>
<a name="ln581">           woff.metaOffset + woff.metaLength &gt; woff.length )</a>
<a name="ln582">      {</a>
<a name="ln583">        error = FT_THROW( Invalid_Table );</a>
<a name="ln584">        goto Exit;</a>
<a name="ln585">      }</a>
<a name="ln586"> </a>
<a name="ln587">      /* We have padding only ... */</a>
<a name="ln588">      woff_offset += woff.metaLength;</a>
<a name="ln589">    }</a>
<a name="ln590"> </a>
<a name="ln591">    if ( woff.privOffset )</a>
<a name="ln592">    {</a>
<a name="ln593">      /* ... if it isn't the last block. */</a>
<a name="ln594">      woff_offset = ( woff_offset + 3 ) &amp; ~3U;</a>
<a name="ln595"> </a>
<a name="ln596">      if ( woff.privOffset != woff_offset                  ||</a>
<a name="ln597">           woff.privOffset + woff.privLength &gt; woff.length )</a>
<a name="ln598">      {</a>
<a name="ln599">        error = FT_THROW( Invalid_Table );</a>
<a name="ln600">        goto Exit;</a>
<a name="ln601">      }</a>
<a name="ln602"> </a>
<a name="ln603">      /* No padding for the last block. */</a>
<a name="ln604">      woff_offset += woff.privLength;</a>
<a name="ln605">    }</a>
<a name="ln606"> </a>
<a name="ln607">    if ( sfnt_offset != woff.totalSfntSize ||</a>
<a name="ln608">         woff_offset != woff.length        )</a>
<a name="ln609">    {</a>
<a name="ln610">      error = FT_THROW( Invalid_Table );</a>
<a name="ln611">      goto Exit;</a>
<a name="ln612">    }</a>
<a name="ln613"> </a>
<a name="ln614">    /* Write the tables. */</a>
<a name="ln615"> </a>
<a name="ln616">    for ( nn = 0; nn &lt; woff.num_tables; nn++ )</a>
<a name="ln617">    {</a>
<a name="ln618">      WOFF_Table  table = tables + nn;</a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">      /* Write SFNT table entry. */</a>
<a name="ln622">      WRITE_ULONG( sfnt_header, table-&gt;Tag );</a>
<a name="ln623">      WRITE_ULONG( sfnt_header, table-&gt;CheckSum );</a>
<a name="ln624">      WRITE_ULONG( sfnt_header, table-&gt;OrigOffset );</a>
<a name="ln625">      WRITE_ULONG( sfnt_header, table-&gt;OrigLength );</a>
<a name="ln626"> </a>
<a name="ln627">      /* Write table data. */</a>
<a name="ln628">      if ( FT_STREAM_SEEK( table-&gt;Offset )     ||</a>
<a name="ln629">           FT_FRAME_ENTER( table-&gt;CompLength ) )</a>
<a name="ln630">        goto Exit;</a>
<a name="ln631"> </a>
<a name="ln632">      if ( table-&gt;CompLength == table-&gt;OrigLength )</a>
<a name="ln633">      {</a>
<a name="ln634">        /* Uncompressed data; just copy. */</a>
<a name="ln635">        ft_memcpy( sfnt + table-&gt;OrigOffset,</a>
<a name="ln636">                   stream-&gt;cursor,</a>
<a name="ln637">                   table-&gt;OrigLength );</a>
<a name="ln638">      }</a>
<a name="ln639">      else</a>
<a name="ln640">      {</a>
<a name="ln641">#ifdef FT_CONFIG_OPTION_USE_ZLIB</a>
<a name="ln642"> </a>
<a name="ln643">        /* Uncompress with zlib. */</a>
<a name="ln644">        FT_ULong  output_len = table-&gt;OrigLength;</a>
<a name="ln645"> </a>
<a name="ln646"> </a>
<a name="ln647">        error = FT_Gzip_Uncompress( memory,</a>
<a name="ln648">                                    sfnt + table-&gt;OrigOffset, &amp;output_len,</a>
<a name="ln649">                                    stream-&gt;cursor, table-&gt;CompLength );</a>
<a name="ln650">        if ( error )</a>
<a name="ln651">          goto Exit;</a>
<a name="ln652">        if ( output_len != table-&gt;OrigLength )</a>
<a name="ln653">        {</a>
<a name="ln654">          error = FT_THROW( Invalid_Table );</a>
<a name="ln655">          goto Exit;</a>
<a name="ln656">        }</a>
<a name="ln657"> </a>
<a name="ln658">#else /* !FT_CONFIG_OPTION_USE_ZLIB */</a>
<a name="ln659"> </a>
<a name="ln660">        error = FT_THROW( Unimplemented_Feature );</a>
<a name="ln661">        goto Exit;</a>
<a name="ln662"> </a>
<a name="ln663">#endif /* !FT_CONFIG_OPTION_USE_ZLIB */</a>
<a name="ln664">      }</a>
<a name="ln665"> </a>
<a name="ln666">      FT_FRAME_EXIT();</a>
<a name="ln667"> </a>
<a name="ln668">      /* We don't check whether the padding bytes in the WOFF file are     */</a>
<a name="ln669">      /* actually '\0'.  For the output, however, we do set them properly. */</a>
<a name="ln670">      sfnt_offset = table-&gt;OrigOffset + table-&gt;OrigLength;</a>
<a name="ln671">      while ( sfnt_offset &amp; 3 )</a>
<a name="ln672">      {</a>
<a name="ln673">        sfnt[sfnt_offset] = '\0';</a>
<a name="ln674">        sfnt_offset++;</a>
<a name="ln675">      }</a>
<a name="ln676">    }</a>
<a name="ln677"> </a>
<a name="ln678">    /* Ok!  Finally ready.  Swap out stream and return. */</a>
<a name="ln679">    FT_Stream_OpenMemory( sfnt_stream, sfnt, woff.totalSfntSize );</a>
<a name="ln680">    sfnt_stream-&gt;memory = stream-&gt;memory;</a>
<a name="ln681">    sfnt_stream-&gt;close  = sfnt_stream_close;</a>
<a name="ln682"> </a>
<a name="ln683">    FT_Stream_Free(</a>
<a name="ln684">      face-&gt;root.stream,</a>
<a name="ln685">      ( face-&gt;root.face_flags &amp; FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );</a>
<a name="ln686"> </a>
<a name="ln687">    face-&gt;root.stream = sfnt_stream;</a>
<a name="ln688"> </a>
<a name="ln689">    face-&gt;root.face_flags &amp;= ~FT_FACE_FLAG_EXTERNAL_STREAM;</a>
<a name="ln690"> </a>
<a name="ln691">  Exit:</a>
<a name="ln692">    FT_FREE( tables );</a>
<a name="ln693">    FT_FREE( indices );</a>
<a name="ln694"> </a>
<a name="ln695">    if ( error )</a>
<a name="ln696">    {</a>
<a name="ln697">      FT_FREE( sfnt );</a>
<a name="ln698">      FT_Stream_Close( sfnt_stream );</a>
<a name="ln699">      FT_FREE( sfnt_stream );</a>
<a name="ln700">    }</a>
<a name="ln701"> </a>
<a name="ln702">    return error;</a>
<a name="ln703">  }</a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">#undef WRITE_USHORT</a>
<a name="ln707">#undef WRITE_ULONG</a>
<a name="ln708"> </a>
<a name="ln709"> </a>
<a name="ln710">  /* Fill in face-&gt;ttc_header.  If the font is not a TTC, it is */</a>
<a name="ln711">  /* synthesized into a TTC with one offset table.              */</a>
<a name="ln712">  static FT_Error</a>
<a name="ln713">  sfnt_open_font( FT_Stream  stream,</a>
<a name="ln714">                  TT_Face    face )</a>
<a name="ln715">  {</a>
<a name="ln716">    FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln717">    FT_Error   error;</a>
<a name="ln718">    FT_ULong   tag, offset;</a>
<a name="ln719"> </a>
<a name="ln720">    static const FT_Frame_Field  ttc_header_fields[] =</a>
<a name="ln721">    {</a>
<a name="ln722">#undef  FT_STRUCTURE</a>
<a name="ln723">#define FT_STRUCTURE  TTC_HeaderRec</a>
<a name="ln724"> </a>
<a name="ln725">      FT_FRAME_START( 8 ),</a>
<a name="ln726">        FT_FRAME_LONG( version ),</a>
<a name="ln727">        FT_FRAME_LONG( count   ),  /* this is ULong in the specs */</a>
<a name="ln728">      FT_FRAME_END</a>
<a name="ln729">    };</a>
<a name="ln730"> </a>
<a name="ln731"> </a>
<a name="ln732">    face-&gt;ttc_header.tag     = 0;</a>
<a name="ln733">    face-&gt;ttc_header.version = 0;</a>
<a name="ln734">    face-&gt;ttc_header.count   = 0;</a>
<a name="ln735"> </a>
<a name="ln736">  retry:</a>
<a name="ln737">    offset = FT_STREAM_POS();</a>
<a name="ln738"> </a>
<a name="ln739">    if ( FT_READ_ULONG( tag ) )</a>
<a name="ln740">      return error;</a>
<a name="ln741"> </a>
<a name="ln742">    if ( tag == TTAG_wOFF )</a>
<a name="ln743">    {</a>
<a name="ln744">      FT_TRACE2(( &quot;sfnt_open_font: file is a WOFF; synthesizing SFNT\n&quot; ));</a>
<a name="ln745"> </a>
<a name="ln746">      if ( FT_STREAM_SEEK( offset ) )</a>
<a name="ln747">        return error;</a>
<a name="ln748"> </a>
<a name="ln749">      error = woff_open_font( stream, face );</a>
<a name="ln750">      if ( error )</a>
<a name="ln751">        return error;</a>
<a name="ln752"> </a>
<a name="ln753">      /* Swap out stream and retry! */</a>
<a name="ln754">      stream = face-&gt;root.stream;</a>
<a name="ln755">      goto retry;</a>
<a name="ln756">    }</a>
<a name="ln757"> </a>
<a name="ln758">    if ( tag != 0x00010000UL &amp;&amp;</a>
<a name="ln759">         tag != TTAG_ttcf    &amp;&amp;</a>
<a name="ln760">         tag != TTAG_OTTO    &amp;&amp;</a>
<a name="ln761">         tag != TTAG_true    &amp;&amp;</a>
<a name="ln762">         tag != TTAG_typ1    &amp;&amp;</a>
<a name="ln763">         tag != 0x00020000UL )</a>
<a name="ln764">    {</a>
<a name="ln765">      FT_TRACE2(( &quot;  not a font using the SFNT container format\n&quot; ));</a>
<a name="ln766">      return FT_THROW( Unknown_File_Format );</a>
<a name="ln767">    }</a>
<a name="ln768"> </a>
<a name="ln769">    face-&gt;ttc_header.tag = TTAG_ttcf;</a>
<a name="ln770"> </a>
<a name="ln771">    if ( tag == TTAG_ttcf )</a>
<a name="ln772">    {</a>
<a name="ln773">      FT_Int  n;</a>
<a name="ln774"> </a>
<a name="ln775"> </a>
<a name="ln776">      FT_TRACE3(( &quot;sfnt_open_font: file is a collection\n&quot; ));</a>
<a name="ln777"> </a>
<a name="ln778">      if ( FT_STREAM_READ_FIELDS( ttc_header_fields, &amp;face-&gt;ttc_header ) )</a>
<a name="ln779">        return error;</a>
<a name="ln780"> </a>
<a name="ln781">      if ( face-&gt;ttc_header.count == 0 )</a>
<a name="ln782">        return FT_THROW( Invalid_Table );</a>
<a name="ln783"> </a>
<a name="ln784">      /* a rough size estimate: let's conservatively assume that there   */</a>
<a name="ln785">      /* is just a single table info in each subfont header (12 + 16*1 = */</a>
<a name="ln786">      /* 28 bytes), thus we have (at least) `12 + 4*count' bytes for the */</a>
<a name="ln787">      /* size of the TTC header plus `28*count' bytes for all subfont    */</a>
<a name="ln788">      /* headers                                                         */</a>
<a name="ln789">      if ( (FT_ULong)face-&gt;ttc_header.count &gt; stream-&gt;size / ( 28 + 4 ) )</a>
<a name="ln790">        return FT_THROW( Array_Too_Large );</a>
<a name="ln791"> </a>
<a name="ln792">      /* now read the offsets of each font in the file */</a>
<a name="ln793">      if ( FT_NEW_ARRAY( face-&gt;ttc_header.offsets, face-&gt;ttc_header.count ) )</a>
<a name="ln794">        return error;</a>
<a name="ln795"> </a>
<a name="ln796">      if ( FT_FRAME_ENTER( face-&gt;ttc_header.count * 4L ) )</a>
<a name="ln797">        return error;</a>
<a name="ln798"> </a>
<a name="ln799">      for ( n = 0; n &lt; face-&gt;ttc_header.count; n++ )</a>
<a name="ln800">        face-&gt;ttc_header.offsets[n] = FT_GET_ULONG();</a>
<a name="ln801"> </a>
<a name="ln802">      FT_FRAME_EXIT();</a>
<a name="ln803">    }</a>
<a name="ln804">    else</a>
<a name="ln805">    {</a>
<a name="ln806">      FT_TRACE3(( &quot;sfnt_open_font: synthesize TTC\n&quot; ));</a>
<a name="ln807"> </a>
<a name="ln808">      face-&gt;ttc_header.version = 1 &lt;&lt; 16;</a>
<a name="ln809">      face-&gt;ttc_header.count   = 1;</a>
<a name="ln810"> </a>
<a name="ln811">      if ( FT_NEW( face-&gt;ttc_header.offsets ) )</a>
<a name="ln812">        return error;</a>
<a name="ln813"> </a>
<a name="ln814">      face-&gt;ttc_header.offsets[0] = offset;</a>
<a name="ln815">    }</a>
<a name="ln816"> </a>
<a name="ln817">    return error;</a>
<a name="ln818">  }</a>
<a name="ln819"> </a>
<a name="ln820"> </a>
<a name="ln821">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln822">  sfnt_init_face( FT_Stream      stream,</a>
<a name="ln823">                  TT_Face        face,</a>
<a name="ln824">                  FT_Int         face_instance_index,</a>
<a name="ln825">                  FT_Int         num_params,</a>
<a name="ln826">                  FT_Parameter*  params )</a>
<a name="ln827">  {</a>
<a name="ln828">    FT_Error      error;</a>
<a name="ln829">    FT_Library    library = face-&gt;root.driver-&gt;root.library;</a>
<a name="ln830">    SFNT_Service  sfnt;</a>
<a name="ln831">    FT_Int        face_index;</a>
<a name="ln832"> </a>
<a name="ln833"> </a>
<a name="ln834">    /* for now, parameters are unused */</a>
<a name="ln835">    FT_UNUSED( num_params );</a>
<a name="ln836">    FT_UNUSED( params );</a>
<a name="ln837"> </a>
<a name="ln838"> </a>
<a name="ln839">    sfnt = (SFNT_Service)face-&gt;sfnt;</a>
<a name="ln840">    if ( !sfnt )</a>
<a name="ln841">    {</a>
<a name="ln842">      sfnt = (SFNT_Service)FT_Get_Module_Interface( library, &quot;sfnt&quot; );</a>
<a name="ln843">      if ( !sfnt )</a>
<a name="ln844">      {</a>
<a name="ln845">        FT_ERROR(( &quot;sfnt_init_face: cannot access `sfnt' module\n&quot; ));</a>
<a name="ln846">        return FT_THROW( Missing_Module );</a>
<a name="ln847">      }</a>
<a name="ln848"> </a>
<a name="ln849">      face-&gt;sfnt       = sfnt;</a>
<a name="ln850">      face-&gt;goto_table = sfnt-&gt;goto_table;</a>
<a name="ln851">    }</a>
<a name="ln852"> </a>
<a name="ln853">    FT_FACE_FIND_GLOBAL_SERVICE( face, face-&gt;psnames, POSTSCRIPT_CMAPS );</a>
<a name="ln854"> </a>
<a name="ln855">    FT_TRACE2(( &quot;SFNT driver\n&quot; ));</a>
<a name="ln856"> </a>
<a name="ln857">    error = sfnt_open_font( stream, face );</a>
<a name="ln858">    if ( error )</a>
<a name="ln859">      return error;</a>
<a name="ln860"> </a>
<a name="ln861">    /* Stream may have changed in sfnt_open_font. */</a>
<a name="ln862">    stream = face-&gt;root.stream;</a>
<a name="ln863"> </a>
<a name="ln864">    FT_TRACE2(( &quot;sfnt_init_face: %08p, %ld\n&quot;, face, face_instance_index ));</a>
<a name="ln865"> </a>
<a name="ln866">    face_index = FT_ABS( face_instance_index ) &amp; 0xFFFF;</a>
<a name="ln867"> </a>
<a name="ln868">    if ( face_index &gt;= face-&gt;ttc_header.count )</a>
<a name="ln869">    {</a>
<a name="ln870">      if ( face_instance_index &gt;= 0 )</a>
<a name="ln871">        return FT_THROW( Invalid_Argument );</a>
<a name="ln872">      else</a>
<a name="ln873">        face_index = 0;</a>
<a name="ln874">    }</a>
<a name="ln875"> </a>
<a name="ln876">    if ( FT_STREAM_SEEK( face-&gt;ttc_header.offsets[face_index] ) )</a>
<a name="ln877">      return error;</a>
<a name="ln878"> </a>
<a name="ln879">    /* check whether we have a valid TrueType file */</a>
<a name="ln880">    error = sfnt-&gt;load_font_dir( face, stream );</a>
<a name="ln881">    if ( error )</a>
<a name="ln882">      return error;</a>
<a name="ln883"> </a>
<a name="ln884">#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</a>
<a name="ln885">    {</a>
<a name="ln886">      FT_ULong   fvar_len;</a>
<a name="ln887">      FT_UShort  num_instances;</a>
<a name="ln888">      FT_Int     instance_index;</a>
<a name="ln889"> </a>
<a name="ln890"> </a>
<a name="ln891">      instance_index = FT_ABS( face_instance_index ) &gt;&gt; 16;</a>
<a name="ln892"> </a>
<a name="ln893">      /* test whether current face is a GX font with named instances */</a>
<a name="ln894">      if ( face-&gt;goto_table( face, TTAG_fvar, stream, &amp;fvar_len ) ||</a>
<a name="ln895">           fvar_len &lt; 20                                          ||</a>
<a name="ln896">           FT_STREAM_SKIP( 12 )                                   ||</a>
<a name="ln897">           FT_READ_USHORT( num_instances )                        )</a>
<a name="ln898">        num_instances = 0;</a>
<a name="ln899"> </a>
<a name="ln900">      /* we support at most 2^15 - 1 instances */</a>
<a name="ln901">      if ( num_instances &gt;= ( 1U &lt;&lt; 15 ) - 1 )</a>
<a name="ln902">      {</a>
<a name="ln903">        if ( face_instance_index &gt;= 0 )</a>
<a name="ln904">          return FT_THROW( Invalid_Argument );</a>
<a name="ln905">        else</a>
<a name="ln906">          num_instances = 0;</a>
<a name="ln907">      }</a>
<a name="ln908"> </a>
<a name="ln909">      /* instance indices in `face_instance_index' start with index 1, */</a>
<a name="ln910">      /* thus `&gt;' and not `&gt;='                                         */</a>
<a name="ln911">      if ( instance_index &gt; num_instances )</a>
<a name="ln912">      {</a>
<a name="ln913">        if ( face_instance_index &gt;= 0 )</a>
<a name="ln914">          return FT_THROW( Invalid_Argument );</a>
<a name="ln915">        else</a>
<a name="ln916">          num_instances = 0;</a>
<a name="ln917">      }</a>
<a name="ln918"> </a>
<a name="ln919">      face-&gt;root.style_flags = (FT_Long)num_instances &lt;&lt; 16;</a>
<a name="ln920">    }</a>
<a name="ln921">#endif</a>
<a name="ln922"> </a>
<a name="ln923">    face-&gt;root.num_faces  = face-&gt;ttc_header.count;</a>
<a name="ln924">    face-&gt;root.face_index = face_index;</a>
<a name="ln925"> </a>
<a name="ln926">    return error;</a>
<a name="ln927">  }</a>
<a name="ln928"> </a>
<a name="ln929"> </a>
<a name="ln930">#define LOAD_( x )                                          \</a>
<a name="ln931">  do                                                        \</a>
<a name="ln932">  {                                                         \</a>
<a name="ln933">    FT_TRACE2(( &quot;`&quot; #x &quot;' &quot; ));                             \</a>
<a name="ln934">    FT_TRACE3(( &quot;--&gt;\n&quot; ));                                 \</a>
<a name="ln935">                                                            \</a>
<a name="ln936">    error = sfnt-&gt;load_ ## x( face, stream );               \</a>
<a name="ln937">                                                            \</a>
<a name="ln938">    FT_TRACE2(( &quot;%s\n&quot;, ( !error )                          \</a>
<a name="ln939">                        ? &quot;loaded&quot;                          \</a>
<a name="ln940">                        : FT_ERR_EQ( error, Table_Missing ) \</a>
<a name="ln941">                          ? &quot;missing&quot;                       \</a>
<a name="ln942">                          : &quot;failed to load&quot; ));            \</a>
<a name="ln943">    FT_TRACE3(( &quot;\n&quot; ));                                    \</a>
<a name="ln944">  } while ( 0 )</a>
<a name="ln945"> </a>
<a name="ln946">#define LOADM_( x, vertical )                               \</a>
<a name="ln947">  do                                                        \</a>
<a name="ln948">  {                                                         \</a>
<a name="ln949">    FT_TRACE2(( &quot;`%s&quot; #x &quot;' &quot;,                              \</a>
<a name="ln950">                vertical ? &quot;vertical &quot; : &quot;&quot; ));             \</a>
<a name="ln951">    FT_TRACE3(( &quot;--&gt;\n&quot; ));                                 \</a>
<a name="ln952">                                                            \</a>
<a name="ln953">    error = sfnt-&gt;load_ ## x( face, stream, vertical );     \</a>
<a name="ln954">                                                            \</a>
<a name="ln955">    FT_TRACE2(( &quot;%s\n&quot;, ( !error )                          \</a>
<a name="ln956">                        ? &quot;loaded&quot;                          \</a>
<a name="ln957">                        : FT_ERR_EQ( error, Table_Missing ) \</a>
<a name="ln958">                          ? &quot;missing&quot;                       \</a>
<a name="ln959">                          : &quot;failed to load&quot; ));            \</a>
<a name="ln960">    FT_TRACE3(( &quot;\n&quot; ));                                    \</a>
<a name="ln961">  } while ( 0 )</a>
<a name="ln962"> </a>
<a name="ln963">#define GET_NAME( id, field )                                   \</a>
<a name="ln964">  do                                                            \</a>
<a name="ln965">  {                                                             \</a>
<a name="ln966">    error = tt_face_get_name( face, TT_NAME_ID_ ## id, field ); \</a>
<a name="ln967">    if ( error )                                                \</a>
<a name="ln968">      goto Exit;                                                \</a>
<a name="ln969">  } while ( 0 )</a>
<a name="ln970"> </a>
<a name="ln971"> </a>
<a name="ln972">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln973">  sfnt_load_face( FT_Stream      stream,</a>
<a name="ln974">                  TT_Face        face,</a>
<a name="ln975">                  FT_Int         face_instance_index,</a>
<a name="ln976">                  FT_Int         num_params,</a>
<a name="ln977">                  FT_Parameter*  params )</a>
<a name="ln978">  {</a>
<a name="ln979">    FT_Error      error;</a>
<a name="ln980">#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES</a>
<a name="ln981">    FT_Error      psnames_error;</a>
<a name="ln982">#endif</a>
<a name="ln983">    FT_Bool       has_outline;</a>
<a name="ln984">    FT_Bool       is_apple_sbit;</a>
<a name="ln985">    FT_Bool       is_apple_sbix;</a>
<a name="ln986">    FT_Bool       ignore_preferred_family    = FALSE;</a>
<a name="ln987">    FT_Bool       ignore_preferred_subfamily = FALSE;</a>
<a name="ln988"> </a>
<a name="ln989">    SFNT_Service  sfnt = (SFNT_Service)face-&gt;sfnt;</a>
<a name="ln990"> </a>
<a name="ln991">    FT_UNUSED( face_instance_index );</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">    /* Check parameters */</a>
<a name="ln995"> </a>
<a name="ln996">    {</a>
<a name="ln997">      FT_Int  i;</a>
<a name="ln998"> </a>
<a name="ln999"> </a>
<a name="ln1000">      for ( i = 0; i &lt; num_params; i++ )</a>
<a name="ln1001">      {</a>
<a name="ln1002">        if ( params[i].tag == FT_PARAM_TAG_IGNORE_PREFERRED_FAMILY )</a>
<a name="ln1003">          ignore_preferred_family = TRUE;</a>
<a name="ln1004">        else if ( params[i].tag == FT_PARAM_TAG_IGNORE_PREFERRED_SUBFAMILY )</a>
<a name="ln1005">          ignore_preferred_subfamily = TRUE;</a>
<a name="ln1006">      }</a>
<a name="ln1007">    }</a>
<a name="ln1008"> </a>
<a name="ln1009">    /* Load tables */</a>
<a name="ln1010"> </a>
<a name="ln1011">    /* We now support two SFNT-based bitmapped font formats.  They */</a>
<a name="ln1012">    /* are recognized easily as they do not include a `glyf'       */</a>
<a name="ln1013">    /* table.                                                      */</a>
<a name="ln1014">    /*                                                             */</a>
<a name="ln1015">    /* The first format comes from Apple, and uses a table named   */</a>
<a name="ln1016">    /* `bhed' instead of `head' to store the font header (using    */</a>
<a name="ln1017">    /* the same format).  It also doesn't include horizontal and   */</a>
<a name="ln1018">    /* vertical metrics tables (i.e. `hhea' and `vhea' tables are  */</a>
<a name="ln1019">    /* missing).                                                   */</a>
<a name="ln1020">    /*                                                             */</a>
<a name="ln1021">    /* The other format comes from Microsoft, and is used with     */</a>
<a name="ln1022">    /* WinCE/PocketPC.  It looks like a standard TTF, except that  */</a>
<a name="ln1023">    /* it doesn't contain outlines.                                */</a>
<a name="ln1024">    /*                                                             */</a>
<a name="ln1025"> </a>
<a name="ln1026">    FT_TRACE2(( &quot;sfnt_load_face: %08p\n\n&quot;, face ));</a>
<a name="ln1027"> </a>
<a name="ln1028">    /* do we have outlines in there? */</a>
<a name="ln1029">#ifdef FT_CONFIG_OPTION_INCREMENTAL</a>
<a name="ln1030">    has_outline = FT_BOOL( face-&gt;root.internal-&gt;incremental_interface != 0 ||</a>
<a name="ln1031">                           tt_face_lookup_table( face, TTAG_glyf )    != 0 ||</a>
<a name="ln1032">                           tt_face_lookup_table( face, TTAG_CFF )     != 0 );</a>
<a name="ln1033">#else</a>
<a name="ln1034">    has_outline = FT_BOOL( tt_face_lookup_table( face, TTAG_glyf ) != 0 ||</a>
<a name="ln1035">                           tt_face_lookup_table( face, TTAG_CFF )  != 0 );</a>
<a name="ln1036">#endif</a>
<a name="ln1037"> </a>
<a name="ln1038">    is_apple_sbit = 0;</a>
<a name="ln1039">    is_apple_sbix = !face-&gt;goto_table( face, TTAG_sbix, stream, 0 );</a>
<a name="ln1040"> </a>
<a name="ln1041">    /* Apple 'sbix' color bitmaps are rendered scaled and then the 'glyf'</a>
<a name="ln1042">     * outline rendered on top.  We don't support that yet, so just ignore</a>
<a name="ln1043">     * the 'glyf' outline and advertise it as a bitmap-only font. */</a>
<a name="ln1044">    if ( is_apple_sbix )</a>
<a name="ln1045">      has_outline = FALSE;</a>
<a name="ln1046"> </a>
<a name="ln1047">    /* if this font doesn't contain outlines, we try to load */</a>
<a name="ln1048">    /* a `bhed' table                                        */</a>
<a name="ln1049">    if ( !has_outline &amp;&amp; sfnt-&gt;load_bhed )</a>
<a name="ln1050">    {</a>
<a name="ln1051">      LOAD_( bhed );</a>
<a name="ln1052">      is_apple_sbit = FT_BOOL( !error );</a>
<a name="ln1053">    }</a>
<a name="ln1054"> </a>
<a name="ln1055">    /* load the font header (`head' table) if this isn't an Apple */</a>
<a name="ln1056">    /* sbit font file                                             */</a>
<a name="ln1057">    if ( !is_apple_sbit || is_apple_sbix )</a>
<a name="ln1058">    {</a>
<a name="ln1059">      LOAD_( head );</a>
<a name="ln1060">      if ( error )</a>
<a name="ln1061">        goto Exit;</a>
<a name="ln1062">    }</a>
<a name="ln1063"> </a>
<a name="ln1064">    if ( face-&gt;header.Units_Per_EM == 0 )</a>
<a name="ln1065">    {</a>
<a name="ln1066">      error = FT_THROW( Invalid_Table );</a>
<a name="ln1067"> </a>
<a name="ln1068">      goto Exit;</a>
<a name="ln1069">    }</a>
<a name="ln1070"> </a>
<a name="ln1071">    /* the following tables are often not present in embedded TrueType */</a>
<a name="ln1072">    /* fonts within PDF documents, so don't check for them.            */</a>
<a name="ln1073">    LOAD_( maxp );</a>
<a name="ln1074">    LOAD_( cmap );</a>
<a name="ln1075"> </a>
<a name="ln1076">    /* the following tables are optional in PCL fonts -- */</a>
<a name="ln1077">    /* don't check for errors                            */</a>
<a name="ln1078">    LOAD_( name );</a>
<a name="ln1079">    LOAD_( post );</a>
<a name="ln1080"> </a>
<a name="ln1081">#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES</a>
<a name="ln1082">    psnames_error = error;</a>
<a name="ln1083">#endif</a>
<a name="ln1084"> </a>
<a name="ln1085">    /* do not load the metrics headers and tables if this is an Apple */</a>
<a name="ln1086">    /* sbit font file                                                 */</a>
<a name="ln1087">    if ( !is_apple_sbit )</a>
<a name="ln1088">    {</a>
<a name="ln1089">      /* load the `hhea' and `hmtx' tables */</a>
<a name="ln1090">      LOADM_( hhea, 0 );</a>
<a name="ln1091">      if ( !error )</a>
<a name="ln1092">      {</a>
<a name="ln1093">        LOADM_( hmtx, 0 );</a>
<a name="ln1094">        if ( FT_ERR_EQ( error, Table_Missing ) )</a>
<a name="ln1095">        {</a>
<a name="ln1096">          error = FT_THROW( Hmtx_Table_Missing );</a>
<a name="ln1097"> </a>
<a name="ln1098">#ifdef FT_CONFIG_OPTION_INCREMENTAL</a>
<a name="ln1099">          /* If this is an incrementally loaded font and there are */</a>
<a name="ln1100">          /* overriding metrics, tolerate a missing `hmtx' table.  */</a>
<a name="ln1101">          if ( face-&gt;root.internal-&gt;incremental_interface          &amp;&amp;</a>
<a name="ln1102">               face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;</a>
<a name="ln1103">                 get_glyph_metrics                                 )</a>
<a name="ln1104">          {</a>
<a name="ln1105">            face-&gt;horizontal.number_Of_HMetrics = 0;</a>
<a name="ln1106">            error                               = FT_Err_Ok;</a>
<a name="ln1107">          }</a>
<a name="ln1108">#endif</a>
<a name="ln1109">        }</a>
<a name="ln1110">      }</a>
<a name="ln1111">      else if ( FT_ERR_EQ( error, Table_Missing ) )</a>
<a name="ln1112">      {</a>
<a name="ln1113">        /* No `hhea' table necessary for SFNT Mac fonts. */</a>
<a name="ln1114">        if ( face-&gt;format_tag == TTAG_true )</a>
<a name="ln1115">        {</a>
<a name="ln1116">          FT_TRACE2(( &quot;This is an SFNT Mac font.\n&quot; ));</a>
<a name="ln1117"> </a>
<a name="ln1118">          has_outline = 0;</a>
<a name="ln1119">          error       = FT_Err_Ok;</a>
<a name="ln1120">        }</a>
<a name="ln1121">        else</a>
<a name="ln1122">        {</a>
<a name="ln1123">          error = FT_THROW( Horiz_Header_Missing );</a>
<a name="ln1124"> </a>
<a name="ln1125">#ifdef FT_CONFIG_OPTION_INCREMENTAL</a>
<a name="ln1126">          /* If this is an incrementally loaded font and there are */</a>
<a name="ln1127">          /* overriding metrics, tolerate a missing `hhea' table.  */</a>
<a name="ln1128">          if ( face-&gt;root.internal-&gt;incremental_interface          &amp;&amp;</a>
<a name="ln1129">               face-&gt;root.internal-&gt;incremental_interface-&gt;funcs-&gt;</a>
<a name="ln1130">                 get_glyph_metrics                                 )</a>
<a name="ln1131">          {</a>
<a name="ln1132">            face-&gt;horizontal.number_Of_HMetrics = 0;</a>
<a name="ln1133">            error                               = FT_Err_Ok;</a>
<a name="ln1134">          }</a>
<a name="ln1135">#endif</a>
<a name="ln1136"> </a>
<a name="ln1137">        }</a>
<a name="ln1138">      }</a>
<a name="ln1139"> </a>
<a name="ln1140">      if ( error )</a>
<a name="ln1141">        goto Exit;</a>
<a name="ln1142"> </a>
<a name="ln1143">      /* try to load the `vhea' and `vmtx' tables */</a>
<a name="ln1144">      LOADM_( hhea, 1 );</a>
<a name="ln1145">      if ( !error )</a>
<a name="ln1146">      {</a>
<a name="ln1147">        LOADM_( hmtx, 1 );</a>
<a name="ln1148">        if ( !error )</a>
<a name="ln1149">          face-&gt;vertical_info = 1;</a>
<a name="ln1150">      }</a>
<a name="ln1151"> </a>
<a name="ln1152">      if ( error &amp;&amp; FT_ERR_NEQ( error, Table_Missing ) )</a>
<a name="ln1153">        goto Exit;</a>
<a name="ln1154"> </a>
<a name="ln1155">      LOAD_( os2 );</a>
<a name="ln1156">      if ( error )</a>
<a name="ln1157">      {</a>
<a name="ln1158">        /* we treat the table as missing if there are any errors */</a>
<a name="ln1159">        face-&gt;os2.version = 0xFFFFU;</a>
<a name="ln1160">      }</a>
<a name="ln1161">    }</a>
<a name="ln1162"> </a>
<a name="ln1163">    /* the optional tables */</a>
<a name="ln1164"> </a>
<a name="ln1165">    /* embedded bitmap support */</a>
<a name="ln1166">    if ( sfnt-&gt;load_eblc )</a>
<a name="ln1167">    {</a>
<a name="ln1168">      LOAD_( eblc );</a>
<a name="ln1169">      if ( error )</a>
<a name="ln1170">      {</a>
<a name="ln1171">        /* a font which contains neither bitmaps nor outlines is */</a>
<a name="ln1172">        /* still valid (although rather useless in most cases);  */</a>
<a name="ln1173">        /* however, you can find such stripped fonts in PDFs     */</a>
<a name="ln1174">        if ( FT_ERR_EQ( error, Table_Missing ) )</a>
<a name="ln1175">          error = FT_Err_Ok;</a>
<a name="ln1176">        else</a>
<a name="ln1177">          goto Exit;</a>
<a name="ln1178">      }</a>
<a name="ln1179">    }</a>
<a name="ln1180"> </a>
<a name="ln1181">    LOAD_( pclt );</a>
<a name="ln1182">    if ( error )</a>
<a name="ln1183">    {</a>
<a name="ln1184">      if ( FT_ERR_NEQ( error, Table_Missing ) )</a>
<a name="ln1185">        goto Exit;</a>
<a name="ln1186"> </a>
<a name="ln1187">      face-&gt;pclt.Version = 0;</a>
<a name="ln1188">    }</a>
<a name="ln1189"> </a>
<a name="ln1190">    /* consider the kerning and gasp tables as optional */</a>
<a name="ln1191">    LOAD_( gasp );</a>
<a name="ln1192">    LOAD_( kern );</a>
<a name="ln1193"> </a>
<a name="ln1194">    face-&gt;root.num_glyphs = face-&gt;max_profile.numGlyphs;</a>
<a name="ln1195"> </a>
<a name="ln1196">    /* Bit 8 of the `fsSelection' field in the `OS/2' table denotes  */</a>
<a name="ln1197">    /* a WWS-only font face.  `WWS' stands for `weight', width', and */</a>
<a name="ln1198">    /* `slope', a term used by Microsoft's Windows Presentation      */</a>
<a name="ln1199">    /* Foundation (WPF).  This flag has been introduced in version   */</a>
<a name="ln1200">    /* 1.5 of the OpenType specification (May 2008).                 */</a>
<a name="ln1201"> </a>
<a name="ln1202">    face-&gt;root.family_name = NULL;</a>
<a name="ln1203">    face-&gt;root.style_name  = NULL;</a>
<a name="ln1204">    if ( face-&gt;os2.version != 0xFFFFU &amp;&amp; face-&gt;os2.fsSelection &amp; 256 )</a>
<a name="ln1205">    {</a>
<a name="ln1206">      if ( !ignore_preferred_family )</a>
<a name="ln1207">        GET_NAME( PREFERRED_FAMILY, &amp;face-&gt;root.family_name );</a>
<a name="ln1208">      if ( !face-&gt;root.family_name )</a>
<a name="ln1209">        GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );</a>
<a name="ln1210"> </a>
<a name="ln1211">      if ( !ignore_preferred_subfamily )</a>
<a name="ln1212">        GET_NAME( PREFERRED_SUBFAMILY, &amp;face-&gt;root.style_name );</a>
<a name="ln1213">      if ( !face-&gt;root.style_name )</a>
<a name="ln1214">        GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );</a>
<a name="ln1215">    }</a>
<a name="ln1216">    else</a>
<a name="ln1217">    {</a>
<a name="ln1218">      GET_NAME( WWS_FAMILY, &amp;face-&gt;root.family_name );</a>
<a name="ln1219">      if ( !face-&gt;root.family_name &amp;&amp; !ignore_preferred_family )</a>
<a name="ln1220">        GET_NAME( PREFERRED_FAMILY, &amp;face-&gt;root.family_name );</a>
<a name="ln1221">      if ( !face-&gt;root.family_name )</a>
<a name="ln1222">        GET_NAME( FONT_FAMILY, &amp;face-&gt;root.family_name );</a>
<a name="ln1223"> </a>
<a name="ln1224">      GET_NAME( WWS_SUBFAMILY, &amp;face-&gt;root.style_name );</a>
<a name="ln1225">      if ( !face-&gt;root.style_name &amp;&amp; !ignore_preferred_subfamily )</a>
<a name="ln1226">        GET_NAME( PREFERRED_SUBFAMILY, &amp;face-&gt;root.style_name );</a>
<a name="ln1227">      if ( !face-&gt;root.style_name )</a>
<a name="ln1228">        GET_NAME( FONT_SUBFAMILY, &amp;face-&gt;root.style_name );</a>
<a name="ln1229">    }</a>
<a name="ln1230"> </a>
<a name="ln1231">    /* now set up root fields */</a>
<a name="ln1232">    {</a>
<a name="ln1233">      FT_Face  root  = &amp;face-&gt;root;</a>
<a name="ln1234">      FT_Long  flags = root-&gt;face_flags;</a>
<a name="ln1235"> </a>
<a name="ln1236"> </a>
<a name="ln1237">      /*********************************************************************/</a>
<a name="ln1238">      /*                                                                   */</a>
<a name="ln1239">      /* Compute face flags.                                               */</a>
<a name="ln1240">      /*                                                                   */</a>
<a name="ln1241">      if ( face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_CBLC ||</a>
<a name="ln1242">           face-&gt;sbit_table_type == TT_SBIT_TABLE_TYPE_SBIX )</a>
<a name="ln1243">        flags |= FT_FACE_FLAG_COLOR;      /* color glyphs */</a>
<a name="ln1244"> </a>
<a name="ln1245">      if ( has_outline == TRUE )</a>
<a name="ln1246">        flags |= FT_FACE_FLAG_SCALABLE;   /* scalable outlines */</a>
<a name="ln1247"> </a>
<a name="ln1248">      /* The sfnt driver only supports bitmap fonts natively, thus we */</a>
<a name="ln1249">      /* don't set FT_FACE_FLAG_HINTER.                               */</a>
<a name="ln1250">      flags |= FT_FACE_FLAG_SFNT       |  /* SFNT file format  */</a>
<a name="ln1251">               FT_FACE_FLAG_HORIZONTAL;   /* horizontal data   */</a>
<a name="ln1252"> </a>
<a name="ln1253">#ifdef TT_CONFIG_OPTION_POSTSCRIPT_NAMES</a>
<a name="ln1254">      if ( !psnames_error                             &amp;&amp;</a>
<a name="ln1255">           face-&gt;postscript.FormatType != 0x00030000L )</a>
<a name="ln1256">        flags |= FT_FACE_FLAG_GLYPH_NAMES;</a>
<a name="ln1257">#endif</a>
<a name="ln1258"> </a>
<a name="ln1259">      /* fixed width font? */</a>
<a name="ln1260">      if ( face-&gt;postscript.isFixedPitch )</a>
<a name="ln1261">        flags |= FT_FACE_FLAG_FIXED_WIDTH;</a>
<a name="ln1262"> </a>
<a name="ln1263">      /* vertical information? */</a>
<a name="ln1264">      if ( face-&gt;vertical_info )</a>
<a name="ln1265">        flags |= FT_FACE_FLAG_VERTICAL;</a>
<a name="ln1266"> </a>
<a name="ln1267">      /* kerning available ? */</a>
<a name="ln1268">      if ( TT_FACE_HAS_KERNING( face ) )</a>
<a name="ln1269">        flags |= FT_FACE_FLAG_KERNING;</a>
<a name="ln1270"> </a>
<a name="ln1271">#ifdef TT_CONFIG_OPTION_GX_VAR_SUPPORT</a>
<a name="ln1272">      /* Don't bother to load the tables unless somebody asks for them. */</a>
<a name="ln1273">      /* No need to do work which will (probably) not be used.          */</a>
<a name="ln1274">      if ( tt_face_lookup_table( face, TTAG_glyf ) != 0 &amp;&amp;</a>
<a name="ln1275">           tt_face_lookup_table( face, TTAG_fvar ) != 0 &amp;&amp;</a>
<a name="ln1276">           tt_face_lookup_table( face, TTAG_gvar ) != 0 )</a>
<a name="ln1277">        flags |= FT_FACE_FLAG_MULTIPLE_MASTERS;</a>
<a name="ln1278">#endif</a>
<a name="ln1279"> </a>
<a name="ln1280">      root-&gt;face_flags = flags;</a>
<a name="ln1281"> </a>
<a name="ln1282">      /*********************************************************************/</a>
<a name="ln1283">      /*                                                                   */</a>
<a name="ln1284">      /* Compute style flags.                                              */</a>
<a name="ln1285">      /*                                                                   */</a>
<a name="ln1286"> </a>
<a name="ln1287">      flags = 0;</a>
<a name="ln1288">      if ( has_outline == TRUE &amp;&amp; face-&gt;os2.version != 0xFFFFU )</a>
<a name="ln1289">      {</a>
<a name="ln1290">        /* We have an OS/2 table; use the `fsSelection' field.  Bit 9 */</a>
<a name="ln1291">        /* indicates an oblique font face.  This flag has been        */</a>
<a name="ln1292">        /* introduced in version 1.5 of the OpenType specification.   */</a>
<a name="ln1293"> </a>
<a name="ln1294">        if ( face-&gt;os2.fsSelection &amp; 512 )       /* bit 9 */</a>
<a name="ln1295">          flags |= FT_STYLE_FLAG_ITALIC;</a>
<a name="ln1296">        else if ( face-&gt;os2.fsSelection &amp; 1 )    /* bit 0 */</a>
<a name="ln1297">          flags |= FT_STYLE_FLAG_ITALIC;</a>
<a name="ln1298"> </a>
<a name="ln1299">        if ( face-&gt;os2.fsSelection &amp; 32 )        /* bit 5 */</a>
<a name="ln1300">          flags |= FT_STYLE_FLAG_BOLD;</a>
<a name="ln1301">      }</a>
<a name="ln1302">      else</a>
<a name="ln1303">      {</a>
<a name="ln1304">        /* this is an old Mac font, use the header field */</a>
<a name="ln1305"> </a>
<a name="ln1306">        if ( face-&gt;header.Mac_Style &amp; 1 )</a>
<a name="ln1307">          flags |= FT_STYLE_FLAG_BOLD;</a>
<a name="ln1308"> </a>
<a name="ln1309">        if ( face-&gt;header.Mac_Style &amp; 2 )</a>
<a name="ln1310">          flags |= FT_STYLE_FLAG_ITALIC;</a>
<a name="ln1311">      }</a>
<a name="ln1312"> </a>
<a name="ln1313">      root-&gt;style_flags |= flags;</a>
<a name="ln1314"> </a>
<a name="ln1315">      /*********************************************************************/</a>
<a name="ln1316">      /*                                                                   */</a>
<a name="ln1317">      /* Polish the charmaps.                                              */</a>
<a name="ln1318">      /*                                                                   */</a>
<a name="ln1319">      /*   Try to set the charmap encoding according to the platform &amp;     */</a>
<a name="ln1320">      /*   encoding ID of each charmap.                                    */</a>
<a name="ln1321">      /*                                                                   */</a>
<a name="ln1322"> </a>
<a name="ln1323">      tt_face_build_cmaps( face );  /* ignore errors */</a>
<a name="ln1324"> </a>
<a name="ln1325"> </a>
<a name="ln1326">      /* set the encoding fields */</a>
<a name="ln1327">      {</a>
<a name="ln1328">        FT_Int  m;</a>
<a name="ln1329"> </a>
<a name="ln1330"> </a>
<a name="ln1331">        for ( m = 0; m &lt; root-&gt;num_charmaps; m++ )</a>
<a name="ln1332">        {</a>
<a name="ln1333">          FT_CharMap  charmap = root-&gt;charmaps[m];</a>
<a name="ln1334"> </a>
<a name="ln1335"> </a>
<a name="ln1336">          charmap-&gt;encoding = sfnt_find_encoding( charmap-&gt;platform_id,</a>
<a name="ln1337">                                                  charmap-&gt;encoding_id );</a>
<a name="ln1338"> </a>
<a name="ln1339">#if 0</a>
<a name="ln1340">          if ( root-&gt;charmap     == NULL &amp;&amp;</a>
<a name="ln1341">               charmap-&gt;encoding == FT_ENCODING_UNICODE )</a>
<a name="ln1342">          {</a>
<a name="ln1343">            /* set 'root-&gt;charmap' to the first Unicode encoding we find */</a>
<a name="ln1344">            root-&gt;charmap = charmap;</a>
<a name="ln1345">          }</a>
<a name="ln1346">#endif</a>
<a name="ln1347">        }</a>
<a name="ln1348">      }</a>
<a name="ln1349"> </a>
<a name="ln1350">#ifdef TT_CONFIG_OPTION_EMBEDDED_BITMAPS</a>
<a name="ln1351"> </a>
<a name="ln1352">      /*</a>
<a name="ln1353">       *  Now allocate the root array of FT_Bitmap_Size records and</a>
<a name="ln1354">       *  populate them.  Unfortunately, it isn't possible to indicate bit</a>
<a name="ln1355">       *  depths in the FT_Bitmap_Size record.  This is a design error.</a>
<a name="ln1356">       */</a>
<a name="ln1357">      {</a>
<a name="ln1358">        FT_UInt  i, count;</a>
<a name="ln1359"> </a>
<a name="ln1360"> </a>
<a name="ln1361">        count = face-&gt;sbit_num_strikes;</a>
<a name="ln1362"> </a>
<a name="ln1363">        if ( count &gt; 0 )</a>
<a name="ln1364">        {</a>
<a name="ln1365">          FT_Memory        memory   = face-&gt;root.stream-&gt;memory;</a>
<a name="ln1366">          FT_UShort        em_size  = face-&gt;header.Units_Per_EM;</a>
<a name="ln1367">          FT_Short         avgwidth = face-&gt;os2.xAvgCharWidth;</a>
<a name="ln1368">          FT_Size_Metrics  metrics;</a>
<a name="ln1369"> </a>
<a name="ln1370"> </a>
<a name="ln1371">          if ( em_size == 0 || face-&gt;os2.version == 0xFFFFU )</a>
<a name="ln1372">          {</a>
<a name="ln1373">            avgwidth = 1;</a>
<a name="ln1374">            em_size = 1;</a>
<a name="ln1375">          }</a>
<a name="ln1376"> </a>
<a name="ln1377">          if ( FT_NEW_ARRAY( root-&gt;available_sizes, count ) )</a>
<a name="ln1378">            goto Exit;</a>
<a name="ln1379"> </a>
<a name="ln1380">          for ( i = 0; i &lt; count; i++ )</a>
<a name="ln1381">          {</a>
<a name="ln1382">            FT_Bitmap_Size*  bsize = root-&gt;available_sizes + i;</a>
<a name="ln1383"> </a>
<a name="ln1384"> </a>
<a name="ln1385">            error = sfnt-&gt;load_strike_metrics( face, i, &amp;metrics );</a>
<a name="ln1386">            if ( error )</a>
<a name="ln1387">              goto Exit;</a>
<a name="ln1388"> </a>
<a name="ln1389">            bsize-&gt;height = (FT_Short)( metrics.height &gt;&gt; 6 );</a>
<a name="ln1390">            bsize-&gt;width = (FT_Short)(</a>
<a name="ln1391">                ( avgwidth * metrics.x_ppem + em_size / 2 ) / em_size );</a>
<a name="ln1392"> </a>
<a name="ln1393">            bsize-&gt;x_ppem = metrics.x_ppem &lt;&lt; 6;</a>
<a name="ln1394">            bsize-&gt;y_ppem = metrics.y_ppem &lt;&lt; 6;</a>
<a name="ln1395"> </a>
<a name="ln1396">            /* assume 72dpi */</a>
<a name="ln1397">            bsize-&gt;size   = metrics.y_ppem &lt;&lt; 6;</a>
<a name="ln1398">          }</a>
<a name="ln1399"> </a>
<a name="ln1400">          root-&gt;face_flags     |= FT_FACE_FLAG_FIXED_SIZES;</a>
<a name="ln1401">          root-&gt;num_fixed_sizes = (FT_Int)count;</a>
<a name="ln1402">        }</a>
<a name="ln1403">      }</a>
<a name="ln1404"> </a>
<a name="ln1405">#endif /* TT_CONFIG_OPTION_EMBEDDED_BITMAPS */</a>
<a name="ln1406"> </a>
<a name="ln1407">      /* a font with no bitmaps and no outlines is scalable; */</a>
<a name="ln1408">      /* it has only empty glyphs then                       */</a>
<a name="ln1409">      if ( !FT_HAS_FIXED_SIZES( root ) &amp;&amp; !FT_IS_SCALABLE( root ) )</a>
<a name="ln1410">        root-&gt;face_flags |= FT_FACE_FLAG_SCALABLE;</a>
<a name="ln1411"> </a>
<a name="ln1412"> </a>
<a name="ln1413">      /*********************************************************************/</a>
<a name="ln1414">      /*                                                                   */</a>
<a name="ln1415">      /*  Set up metrics.                                                  */</a>
<a name="ln1416">      /*                                                                   */</a>
<a name="ln1417">      if ( FT_IS_SCALABLE( root ) )</a>
<a name="ln1418">      {</a>
<a name="ln1419">        /* XXX What about if outline header is missing */</a>
<a name="ln1420">        /*     (e.g. sfnt wrapped bitmap)?             */</a>
<a name="ln1421">        root-&gt;bbox.xMin    = face-&gt;header.xMin;</a>
<a name="ln1422">        root-&gt;bbox.yMin    = face-&gt;header.yMin;</a>
<a name="ln1423">        root-&gt;bbox.xMax    = face-&gt;header.xMax;</a>
<a name="ln1424">        root-&gt;bbox.yMax    = face-&gt;header.yMax;</a>
<a name="ln1425">        root-&gt;units_per_EM = face-&gt;header.Units_Per_EM;</a>
<a name="ln1426"> </a>
<a name="ln1427"> </a>
<a name="ln1428">        /* XXX: Computing the ascender/descender/height is very different */</a>
<a name="ln1429">        /*      from what the specification tells you.  Apparently, we    */</a>
<a name="ln1430">        /*      must be careful because                                   */</a>
<a name="ln1431">        /*                                                                */</a>
<a name="ln1432">        /*      - not all fonts have an OS/2 table; in this case, we take */</a>
<a name="ln1433">        /*        the values in the horizontal header.  However, these    */</a>
<a name="ln1434">        /*        values very often are not reliable.                     */</a>
<a name="ln1435">        /*                                                                */</a>
<a name="ln1436">        /*      - otherwise, the correct typographic values are in the    */</a>
<a name="ln1437">        /*        sTypoAscender, sTypoDescender &amp; sTypoLineGap fields.    */</a>
<a name="ln1438">        /*                                                                */</a>
<a name="ln1439">        /*        However, certain fonts have these fields set to 0.      */</a>
<a name="ln1440">        /*        Rather, they have usWinAscent &amp; usWinDescent correctly  */</a>
<a name="ln1441">        /*        set (but with different values).                        */</a>
<a name="ln1442">        /*                                                                */</a>
<a name="ln1443">        /*      As an example, Arial Narrow is implemented through four   */</a>
<a name="ln1444">        /*      files ARIALN.TTF, ARIALNI.TTF, ARIALNB.TTF &amp; ARIALNBI.TTF */</a>
<a name="ln1445">        /*                                                                */</a>
<a name="ln1446">        /*      Strangely, all fonts have the same values in their        */</a>
<a name="ln1447">        /*      sTypoXXX fields, except ARIALNB which sets them to 0.     */</a>
<a name="ln1448">        /*                                                                */</a>
<a name="ln1449">        /*      On the other hand, they all have different                */</a>
<a name="ln1450">        /*      usWinAscent/Descent values -- as a conclusion, the OS/2   */</a>
<a name="ln1451">        /*      table cannot be used to compute the text height reliably! */</a>
<a name="ln1452">        /*                                                                */</a>
<a name="ln1453"> </a>
<a name="ln1454">        /* The ascender and descender are taken from the `hhea' table. */</a>
<a name="ln1455">        /* If zero, they are taken from the `OS/2' table.              */</a>
<a name="ln1456"> </a>
<a name="ln1457">        root-&gt;ascender  = face-&gt;horizontal.Ascender;</a>
<a name="ln1458">        root-&gt;descender = face-&gt;horizontal.Descender;</a>
<a name="ln1459"> </a>
<a name="ln1460">        root-&gt;height = root-&gt;ascender - root-&gt;descender +</a>
<a name="ln1461">                       face-&gt;horizontal.Line_Gap;</a>
<a name="ln1462"> </a>
<a name="ln1463">        if ( !( root-&gt;ascender || root-&gt;descender ) )</a>
<a name="ln1464">        {</a>
<a name="ln1465">          if ( face-&gt;os2.version != 0xFFFFU )</a>
<a name="ln1466">          {</a>
<a name="ln1467">            if ( face-&gt;os2.sTypoAscender || face-&gt;os2.sTypoDescender )</a>
<a name="ln1468">            {</a>
<a name="ln1469">              root-&gt;ascender  = face-&gt;os2.sTypoAscender;</a>
<a name="ln1470">              root-&gt;descender = face-&gt;os2.sTypoDescender;</a>
<a name="ln1471"> </a>
<a name="ln1472">              root-&gt;height = root-&gt;ascender - root-&gt;descender +</a>
<a name="ln1473">                             face-&gt;os2.sTypoLineGap;</a>
<a name="ln1474">            }</a>
<a name="ln1475">            else</a>
<a name="ln1476">            {</a>
<a name="ln1477">              root-&gt;ascender  =  (FT_Short)face-&gt;os2.usWinAscent;</a>
<a name="ln1478">              root-&gt;descender = -(FT_Short)face-&gt;os2.usWinDescent;</a>
<a name="ln1479"> </a>
<a name="ln1480">              root-&gt;height = root-&gt;ascender - root-&gt;descender;</a>
<a name="ln1481">            }</a>
<a name="ln1482">          }</a>
<a name="ln1483">        }</a>
<a name="ln1484"> </a>
<a name="ln1485">        root-&gt;max_advance_width  =</a>
<a name="ln1486">          (FT_Short)face-&gt;horizontal.advance_Width_Max;</a>
<a name="ln1487">        root-&gt;max_advance_height =</a>
<a name="ln1488">          (FT_Short)( face-&gt;vertical_info ? face-&gt;vertical.advance_Height_Max</a>
<a name="ln1489">                                          : root-&gt;height );</a>
<a name="ln1490"> </a>
<a name="ln1491">        /* See http://www.microsoft.com/OpenType/OTSpec/post.htm -- */</a>
<a name="ln1492">        /* Adjust underline position from top edge to centre of     */</a>
<a name="ln1493">        /* stroke to convert TrueType meaning to FreeType meaning.  */</a>
<a name="ln1494">        root-&gt;underline_position  = face-&gt;postscript.underlinePosition -</a>
<a name="ln1495">                                    face-&gt;postscript.underlineThickness / 2;</a>
<a name="ln1496">        root-&gt;underline_thickness = face-&gt;postscript.underlineThickness;</a>
<a name="ln1497">      }</a>
<a name="ln1498"> </a>
<a name="ln1499">    }</a>
<a name="ln1500"> </a>
<a name="ln1501">  Exit:</a>
<a name="ln1502">    FT_TRACE2(( &quot;sfnt_load_face: done\n&quot; ));</a>
<a name="ln1503"> </a>
<a name="ln1504">    return error;</a>
<a name="ln1505">  }</a>
<a name="ln1506"> </a>
<a name="ln1507"> </a>
<a name="ln1508">#undef LOAD_</a>
<a name="ln1509">#undef LOADM_</a>
<a name="ln1510">#undef GET_NAME</a>
<a name="ln1511"> </a>
<a name="ln1512"> </a>
<a name="ln1513">  FT_LOCAL_DEF( void )</a>
<a name="ln1514">  sfnt_done_face( TT_Face  face )</a>
<a name="ln1515">  {</a>
<a name="ln1516">    FT_Memory     memory;</a>
<a name="ln1517">    SFNT_Service  sfnt;</a>
<a name="ln1518"> </a>
<a name="ln1519"> </a>
<a name="ln1520">    if ( !face )</a>
<a name="ln1521">      return;</a>
<a name="ln1522"> </a>
<a name="ln1523">    memory = face-&gt;root.memory;</a>
<a name="ln1524">    sfnt   = (SFNT_Service)face-&gt;sfnt;</a>
<a name="ln1525"> </a>
<a name="ln1526">    if ( sfnt )</a>
<a name="ln1527">    {</a>
<a name="ln1528">      /* destroy the postscript names table if it is loaded */</a>
<a name="ln1529">      if ( sfnt-&gt;free_psnames )</a>
<a name="ln1530">        sfnt-&gt;free_psnames( face );</a>
<a name="ln1531"> </a>
<a name="ln1532">      /* destroy the embedded bitmaps table if it is loaded */</a>
<a name="ln1533">      if ( sfnt-&gt;free_eblc )</a>
<a name="ln1534">        sfnt-&gt;free_eblc( face );</a>
<a name="ln1535">    }</a>
<a name="ln1536"> </a>
<a name="ln1537">#ifdef TT_CONFIG_OPTION_BDF</a>
<a name="ln1538">    /* freeing the embedded BDF properties */</a>
<a name="ln1539">    tt_face_free_bdf_props( face );</a>
<a name="ln1540">#endif</a>
<a name="ln1541"> </a>
<a name="ln1542">    /* freeing the kerning table */</a>
<a name="ln1543">    tt_face_done_kern( face );</a>
<a name="ln1544"> </a>
<a name="ln1545">    /* freeing the collection table */</a>
<a name="ln1546">    FT_FREE( face-&gt;ttc_header.offsets );</a>
<a name="ln1547">    face-&gt;ttc_header.count = 0;</a>
<a name="ln1548"> </a>
<a name="ln1549">    /* freeing table directory */</a>
<a name="ln1550">    FT_FREE( face-&gt;dir_tables );</a>
<a name="ln1551">    face-&gt;num_tables = 0;</a>
<a name="ln1552"> </a>
<a name="ln1553">    {</a>
<a name="ln1554">      FT_Stream  stream = FT_FACE_STREAM( face );</a>
<a name="ln1555"> </a>
<a name="ln1556"> </a>
<a name="ln1557">      /* simply release the 'cmap' table frame */</a>
<a name="ln1558">      FT_FRAME_RELEASE( face-&gt;cmap_table );</a>
<a name="ln1559">      face-&gt;cmap_size = 0;</a>
<a name="ln1560">    }</a>
<a name="ln1561"> </a>
<a name="ln1562">    /* freeing the horizontal metrics */</a>
<a name="ln1563">    {</a>
<a name="ln1564">      FT_Stream  stream = FT_FACE_STREAM( face );</a>
<a name="ln1565"> </a>
<a name="ln1566"> </a>
<a name="ln1567">      FT_FRAME_RELEASE( face-&gt;horz_metrics );</a>
<a name="ln1568">      FT_FRAME_RELEASE( face-&gt;vert_metrics );</a>
<a name="ln1569">      face-&gt;horz_metrics_size = 0;</a>
<a name="ln1570">      face-&gt;vert_metrics_size = 0;</a>
<a name="ln1571">    }</a>
<a name="ln1572"> </a>
<a name="ln1573">    /* freeing the vertical ones, if any */</a>
<a name="ln1574">    if ( face-&gt;vertical_info )</a>
<a name="ln1575">    {</a>
<a name="ln1576">      FT_FREE( face-&gt;vertical.long_metrics  );</a>
<a name="ln1577">      FT_FREE( face-&gt;vertical.short_metrics );</a>
<a name="ln1578">      face-&gt;vertical_info = 0;</a>
<a name="ln1579">    }</a>
<a name="ln1580"> </a>
<a name="ln1581">    /* freeing the gasp table */</a>
<a name="ln1582">    FT_FREE( face-&gt;gasp.gaspRanges );</a>
<a name="ln1583">    face-&gt;gasp.numRanges = 0;</a>
<a name="ln1584"> </a>
<a name="ln1585">    /* freeing the name table */</a>
<a name="ln1586">    if ( sfnt )</a>
<a name="ln1587">      sfnt-&gt;free_name( face );</a>
<a name="ln1588"> </a>
<a name="ln1589">    /* freeing family and style name */</a>
<a name="ln1590">    FT_FREE( face-&gt;root.family_name );</a>
<a name="ln1591">    FT_FREE( face-&gt;root.style_name );</a>
<a name="ln1592"> </a>
<a name="ln1593">    /* freeing sbit size table */</a>
<a name="ln1594">    FT_FREE( face-&gt;root.available_sizes );</a>
<a name="ln1595">    face-&gt;root.num_fixed_sizes = 0;</a>
<a name="ln1596"> </a>
<a name="ln1597">    FT_FREE( face-&gt;postscript_name );</a>
<a name="ln1598"> </a>
<a name="ln1599">    face-&gt;sfnt = NULL;</a>
<a name="ln1600">  }</a>
<a name="ln1601"> </a>
<a name="ln1602"> </a>
<a name="ln1603">/* END */</a>

</code></pre>
<div class="balloon" rel="228"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 228, 237</p></div>
<div class="balloon" rel="771"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'face->ttc_header.tag' should be checked here.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
