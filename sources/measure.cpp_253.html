
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>measure.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2016 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">/**</a>
<a name="ln14"> \file</a>
<a name="ln15"> Implementation of most part of class Measure.</a>
<a name="ln16">*/</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;measure.h&quot;</a>
<a name="ln19">#include &quot;accidental.h&quot;</a>
<a name="ln20">#include &quot;ambitus.h&quot;</a>
<a name="ln21">#include &quot;articulation.h&quot;</a>
<a name="ln22">#include &quot;barline.h&quot;</a>
<a name="ln23">#include &quot;beam.h&quot;</a>
<a name="ln24">#include &quot;box.h&quot;</a>
<a name="ln25">#include &quot;bracket.h&quot;</a>
<a name="ln26">#include &quot;breath.h&quot;</a>
<a name="ln27">#include &quot;chord.h&quot;</a>
<a name="ln28">#include &quot;clef.h&quot;</a>
<a name="ln29">#include &quot;drumset.h&quot;</a>
<a name="ln30">#include &quot;duration.h&quot;</a>
<a name="ln31">#include &quot;dynamic.h&quot;</a>
<a name="ln32">#include &quot;fermata.h&quot;</a>
<a name="ln33">#include &quot;fret.h&quot;</a>
<a name="ln34">#include &quot;glissando.h&quot;</a>
<a name="ln35">#include &quot;hairpin.h&quot;</a>
<a name="ln36">#include &quot;harmony.h&quot;</a>
<a name="ln37">#include &quot;hook.h&quot;</a>
<a name="ln38">#include &quot;icon.h&quot;</a>
<a name="ln39">#include &quot;image.h&quot;</a>
<a name="ln40">#include &quot;key.h&quot;</a>
<a name="ln41">#include &quot;keysig.h&quot;</a>
<a name="ln42">#include &quot;layoutbreak.h&quot;</a>
<a name="ln43">#include &quot;layout.h&quot;</a>
<a name="ln44">#include &quot;note.h&quot;</a>
<a name="ln45">#include &quot;ottava.h&quot;</a>
<a name="ln46">#include &quot;page.h&quot;</a>
<a name="ln47">#include &quot;part.h&quot;</a>
<a name="ln48">#include &quot;pedal.h&quot;</a>
<a name="ln49">#include &quot;pitchspelling.h&quot;</a>
<a name="ln50">#include &quot;repeat.h&quot;</a>
<a name="ln51">#include &quot;rest.h&quot;</a>
<a name="ln52">#include &quot;score.h&quot;</a>
<a name="ln53">#include &quot;segment.h&quot;</a>
<a name="ln54">#include &quot;select.h&quot;</a>
<a name="ln55">#include &quot;sig.h&quot;</a>
<a name="ln56">#include &quot;slur.h&quot;</a>
<a name="ln57">#include &quot;spacer.h&quot;</a>
<a name="ln58">#include &quot;staff.h&quot;</a>
<a name="ln59">#include &quot;stafftext.h&quot;</a>
<a name="ln60">#include &quot;stafftype.h&quot;</a>
<a name="ln61">#include &quot;stringdata.h&quot;</a>
<a name="ln62">#include &quot;style.h&quot;</a>
<a name="ln63">#include &quot;sym.h&quot;</a>
<a name="ln64">#include &quot;system.h&quot;</a>
<a name="ln65">#include &quot;tempotext.h&quot;</a>
<a name="ln66">#include &quot;measurenumber.h&quot;</a>
<a name="ln67">#include &quot;tie.h&quot;</a>
<a name="ln68">#include &quot;tiemap.h&quot;</a>
<a name="ln69">#include &quot;timesig.h&quot;</a>
<a name="ln70">#include &quot;tremolo.h&quot;</a>
<a name="ln71">#include &quot;trill.h&quot;</a>
<a name="ln72">#include &quot;tuplet.h&quot;</a>
<a name="ln73">#include &quot;tupletmap.h&quot;</a>
<a name="ln74">#include &quot;undo.h&quot;</a>
<a name="ln75">#include &quot;utils.h&quot;</a>
<a name="ln76">#include &quot;volta.h&quot;</a>
<a name="ln77">#include &quot;xml.h&quot;</a>
<a name="ln78">#include &quot;systemdivider.h&quot;</a>
<a name="ln79">#include &quot;stafftypechange.h&quot;</a>
<a name="ln80">#include &quot;stafflines.h&quot;</a>
<a name="ln81">#include &quot;bracketItem.h&quot;</a>
<a name="ln82"> </a>
<a name="ln83">namespace Ms {</a>
<a name="ln84"> </a>
<a name="ln85">//---------------------------------------------------------</a>
<a name="ln86">//   MStaff</a>
<a name="ln87">///   Per staff values of measure.</a>
<a name="ln88">//---------------------------------------------------------</a>
<a name="ln89"> </a>
<a name="ln90">class MStaff {</a>
<a name="ln91">      MeasureNumber* _noText { 0 };         ///&lt; Measure number text object</a>
<a name="ln92">      StaffLines*  _lines    { 0 };</a>
<a name="ln93">      Spacer* _vspacerUp     { 0 };</a>
<a name="ln94">      Spacer* _vspacerDown   { 0 };</a>
<a name="ln95">      bool _hasVoices        { false };    ///&lt; indicates that MStaff contains more than one voice,</a>
<a name="ln96">                                          ///&lt; this changes some layout rules</a>
<a name="ln97">      bool _visible          { true  };</a>
<a name="ln98">      bool _stemless         { false };</a>
<a name="ln99">#ifndef NDEBUG</a>
<a name="ln100">      bool _corrupted        { false };</a>
<a name="ln101">#endif</a>
<a name="ln102"> </a>
<a name="ln103">   public:</a>
<a name="ln104">      MStaff()  {}</a>
<a name="ln105">      ~MStaff();</a>
<a name="ln106">      MStaff(const MStaff&amp;);</a>
<a name="ln107"> </a>
<a name="ln108">      void setScore(Score*);</a>
<a name="ln109">      void setTrack(int);</a>
<a name="ln110"> </a>
<a name="ln111">      MeasureNumber* noText() const   { return _noText;     }</a>
<a name="ln112">      void setNoText(MeasureNumber* t) { _noText = t;        }</a>
<a name="ln113"> </a>
<a name="ln114">      StaffLines* lines() const      { return _lines; }</a>
<a name="ln115">      void setLines(StaffLines* l)   { _lines = l;    }</a>
<a name="ln116"> </a>
<a name="ln117">      Spacer* vspacerUp() const      { return _vspacerUp;   }</a>
<a name="ln118">      void setVspacerUp(Spacer* s)   { _vspacerUp = s;      }</a>
<a name="ln119">      Spacer* vspacerDown() const    { return _vspacerDown; }</a>
<a name="ln120">      void setVspacerDown(Spacer* s) { _vspacerDown = s;    }</a>
<a name="ln121"> </a>
<a name="ln122">      bool hasVoices() const         { return _hasVoices;  }</a>
<a name="ln123">      void setHasVoices(bool val)    { _hasVoices = val;   }</a>
<a name="ln124"> </a>
<a name="ln125">      bool visible() const           { return _visible;    }</a>
<a name="ln126">      void setVisible(bool val)      { _visible = val;     }</a>
<a name="ln127"> </a>
<a name="ln128">      bool stemless() const          { return _stemless; }</a>
<a name="ln129">      void setStemless(bool val)     { _stemless = val;  }</a>
<a name="ln130"> </a>
<a name="ln131">#ifndef NDEBUG</a>
<a name="ln132">      bool corrupted() const         { return _corrupted; }</a>
<a name="ln133">      void setCorrupted(bool val)    { _corrupted = val; }</a>
<a name="ln134">#endif</a>
<a name="ln135">      };</a>
<a name="ln136"> </a>
<a name="ln137">MStaff::~MStaff()</a>
<a name="ln138">      {</a>
<a name="ln139">      delete _noText;</a>
<a name="ln140">      delete _lines;</a>
<a name="ln141">      delete _vspacerUp;</a>
<a name="ln142">      delete _vspacerDown;</a>
<a name="ln143">      }</a>
<a name="ln144"> </a>
<a name="ln145">MStaff::MStaff(const MStaff&amp; m)</a>
<a name="ln146">      {</a>
<a name="ln147">      _noText      = 0;</a>
<a name="ln148">      _lines       = new StaffLines(*m._lines);</a>
<a name="ln149">      _hasVoices   = m._hasVoices;</a>
<a name="ln150">      _vspacerUp   = 0;</a>
<a name="ln151">      _vspacerDown = 0;</a>
<a name="ln152">      _visible     = m._visible;</a>
<a name="ln153">      _stemless  = m._stemless;</a>
<a name="ln154">#ifndef NDEBUG</a>
<a name="ln155">      _corrupted   = m._corrupted;</a>
<a name="ln156">#endif</a>
<a name="ln157">      }</a>
<a name="ln158"> </a>
<a name="ln159">//---------------------------------------------------------</a>
<a name="ln160">//   MStaff::setScore</a>
<a name="ln161">//---------------------------------------------------------</a>
<a name="ln162"> </a>
<a name="ln163">void MStaff::setScore(Score* score)</a>
<a name="ln164">      {</a>
<a name="ln165">      if (_lines)</a>
<a name="ln166">            _lines-&gt;setScore(score);</a>
<a name="ln167">      if (_vspacerUp)</a>
<a name="ln168">            _vspacerUp-&gt;setScore(score);</a>
<a name="ln169">      if (_vspacerDown)</a>
<a name="ln170">            _vspacerDown-&gt;setScore(score);</a>
<a name="ln171">      if (_noText)</a>
<a name="ln172">            _noText-&gt;setScore(score);</a>
<a name="ln173">      }</a>
<a name="ln174"> </a>
<a name="ln175">//---------------------------------------------------------</a>
<a name="ln176">//   setTrack</a>
<a name="ln177">//---------------------------------------------------------</a>
<a name="ln178"> </a>
<a name="ln179">void MStaff::setTrack(int track)</a>
<a name="ln180">      {</a>
<a name="ln181">      if (_lines)</a>
<a name="ln182">            _lines-&gt;setTrack(track);</a>
<a name="ln183">      if (_vspacerUp)</a>
<a name="ln184">            _vspacerUp-&gt;setTrack(track);</a>
<a name="ln185">      if (_vspacerDown)</a>
<a name="ln186">            _vspacerDown-&gt;setTrack(track);</a>
<a name="ln187">      if (_noText)</a>
<a name="ln188">            _noText-&gt;setTrack(track);</a>
<a name="ln189">      }</a>
<a name="ln190"> </a>
<a name="ln191">//---------------------------------------------------------</a>
<a name="ln192">//   Measure</a>
<a name="ln193">//---------------------------------------------------------</a>
<a name="ln194"> </a>
<a name="ln195">Measure::Measure(Score* s)</a>
<a name="ln196">   : MeasureBase(s), _timesig(4,4)</a>
<a name="ln197">      {</a>
<a name="ln198">      setTicks(Fraction(4,4));</a>
<a name="ln199">      _repeatCount           = 2;</a>
<a name="ln200"> </a>
<a name="ln201">      int n = score()-&gt;nstaves();</a>
<a name="ln202">      _mstaves.reserve(n);</a>
<a name="ln203">      for (int staffIdx = 0; staffIdx &lt; n; ++staffIdx) {</a>
<a name="ln204">            MStaff* ms   = new MStaff;</a>
<a name="ln205">            Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln206">            ms-&gt;setLines(new StaffLines(score()));</a>
<a name="ln207">            ms-&gt;lines()-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln208">            ms-&gt;lines()-&gt;setParent(this);</a>
<a name="ln209">            ms-&gt;lines()-&gt;setVisible(!staff-&gt;invisible());</a>
<a name="ln210">            _mstaves.push_back(ms);</a>
<a name="ln211">            }</a>
<a name="ln212">      setIrregular(false);</a>
<a name="ln213">      _noMode                   = MeasureNumberMode::AUTO;</a>
<a name="ln214">      _userStretch              = 1.0;</a>
<a name="ln215">      _breakMultiMeasureRest    = false;</a>
<a name="ln216">      _mmRest                   = 0;</a>
<a name="ln217">      _mmRestCount              = 0;</a>
<a name="ln218">      setFlag(ElementFlag::MOVABLE, true);</a>
<a name="ln219">      }</a>
<a name="ln220"> </a>
<a name="ln221">//---------------------------------------------------------</a>
<a name="ln222">//   measure</a>
<a name="ln223">//---------------------------------------------------------</a>
<a name="ln224"> </a>
<a name="ln225">Measure::Measure(const Measure&amp; m)</a>
<a name="ln226">   : MeasureBase(m)</a>
<a name="ln227">      {</a>
<a name="ln228">      _segments     = m._segments.clone();</a>
<a name="ln229">      _timesig      = m._timesig;</a>
<a name="ln230">      _len          = m._len;</a>
<a name="ln231">      _repeatCount  = m._repeatCount;</a>
<a name="ln232">      _userStretch  = m._userStretch;</a>
<a name="ln233"> </a>
<a name="ln234">      _mstaves.reserve(m._mstaves.size());</a>
<a name="ln235">      for (MStaff* ms : m._mstaves)</a>
<a name="ln236">            _mstaves.push_back(new MStaff(*ms));</a>
<a name="ln237"> </a>
<a name="ln238">      _breakMultiMeasureRest = m._breakMultiMeasureRest;</a>
<a name="ln239">      _mmRest                = m._mmRest;</a>
<a name="ln240">      _mmRestCount           = m._mmRestCount;</a>
<a name="ln241">      _playbackCount         = m._playbackCount;</a>
<a name="ln242">      }</a>
<a name="ln243"> </a>
<a name="ln244">//---------------------------------------------------------</a>
<a name="ln245">//   layoutStaffLines</a>
<a name="ln246">//---------------------------------------------------------</a>
<a name="ln247"> </a>
<a name="ln248">void Measure::layoutStaffLines()</a>
<a name="ln249">      {</a>
<a name="ln250">      for (MStaff* ms : _mstaves)</a>
<a name="ln251">            ms-&gt;lines()-&gt;layout();</a>
<a name="ln252">      }</a>
<a name="ln253"> </a>
<a name="ln254">//---------------------------------------------------------</a>
<a name="ln255">//   createStaves</a>
<a name="ln256">//---------------------------------------------------------</a>
<a name="ln257"> </a>
<a name="ln258">void Measure::createStaves(int staffIdx)</a>
<a name="ln259">      {</a>
<a name="ln260">      for (int n = int(_mstaves.size()); n &lt;= staffIdx; ++n) {</a>
<a name="ln261">            Staff* staff = score()-&gt;staff(n);</a>
<a name="ln262">            MStaff* s    = new MStaff;</a>
<a name="ln263">            s-&gt;setLines(new StaffLines(score()));</a>
<a name="ln264">            s-&gt;lines()-&gt;setParent(this);</a>
<a name="ln265">            s-&gt;lines()-&gt;setTrack(n * VOICES);</a>
<a name="ln266">            s-&gt;lines()-&gt;setVisible(!staff-&gt;invisible());</a>
<a name="ln267">            _mstaves.push_back(s);</a>
<a name="ln268">            }</a>
<a name="ln269">      }</a>
<a name="ln270"> </a>
<a name="ln271">//---------------------------------------------------------</a>
<a name="ln272">//   setScore</a>
<a name="ln273">//---------------------------------------------------------</a>
<a name="ln274"> </a>
<a name="ln275">void Measure::setScore(Score* score)</a>
<a name="ln276">      {</a>
<a name="ln277">      MeasureBase::setScore(score);</a>
<a name="ln278">      for (Segment* s = first(); s; s = s-&gt;next())</a>
<a name="ln279">            s-&gt;setScore(score);</a>
<a name="ln280">      }</a>
<a name="ln281"> </a>
<a name="ln282">bool Measure::hasVoices(int staffIdx) const                     { return _mstaves[staffIdx]-&gt;hasVoices(); }</a>
<a name="ln283">void Measure::setHasVoices(int staffIdx, bool v)                { return _mstaves[staffIdx]-&gt;setHasVoices(v); }</a>
<a name="ln284">StaffLines* Measure::staffLines(int staffIdx)                   { return _mstaves[staffIdx]-&gt;lines(); }</a>
<a name="ln285">Spacer* Measure::vspacerDown(int staffIdx) const                { return _mstaves[staffIdx]-&gt;vspacerDown(); }</a>
<a name="ln286">Spacer* Measure::vspacerUp(int staffIdx) const                  { return _mstaves[staffIdx]-&gt;vspacerUp(); }</a>
<a name="ln287">void Measure::setStaffVisible(int staffIdx, bool visible)       { _mstaves[staffIdx]-&gt;setVisible(visible); }</a>
<a name="ln288">void Measure::setStaffStemless(int staffIdx, bool stemless)     { _mstaves[staffIdx]-&gt;setStemless(stemless); }</a>
<a name="ln289"> </a>
<a name="ln290">#ifndef NDEBUG</a>
<a name="ln291">bool Measure::corrupted(int staffIdx) const                     { return _mstaves[staffIdx]-&gt;corrupted(); }</a>
<a name="ln292">void Measure::setCorrupted(int staffIdx, bool val)              { _mstaves[staffIdx]-&gt;setCorrupted(val); }</a>
<a name="ln293">#endif</a>
<a name="ln294"> </a>
<a name="ln295">void Measure::setNoText(int staffIdx, MeasureNumber* t)         { _mstaves[staffIdx]-&gt;setNoText(t); }</a>
<a name="ln296">MeasureNumber* Measure::noText(int staffIdx) const              { return _mstaves[staffIdx]-&gt;noText(); }</a>
<a name="ln297"> </a>
<a name="ln298">//---------------------------------------------------------</a>
<a name="ln299">//   Measure</a>
<a name="ln300">//---------------------------------------------------------</a>
<a name="ln301"> </a>
<a name="ln302">Measure::~Measure()</a>
<a name="ln303">      {</a>
<a name="ln304">      for (Segment* s = first(); s;) {</a>
<a name="ln305">            Segment* ns = s-&gt;next();</a>
<a name="ln306">            delete s;</a>
<a name="ln307">            s = ns;</a>
<a name="ln308">            }</a>
<a name="ln309">      qDeleteAll(_mstaves);</a>
<a name="ln310">      }</a>
<a name="ln311"> </a>
<a name="ln312">//---------------------------------------------------------</a>
<a name="ln313">//   AcEl</a>
<a name="ln314">//---------------------------------------------------------</a>
<a name="ln315"> </a>
<a name="ln316">struct AcEl {</a>
<a name="ln317">      Note* note;</a>
<a name="ln318">      qreal x;</a>
<a name="ln319">      };</a>
<a name="ln320"> </a>
<a name="ln321">//---------------------------------------------------------</a>
<a name="ln322">//   findAccidental</a>
<a name="ln323">///   return current accidental value at note position</a>
<a name="ln324">//---------------------------------------------------------</a>
<a name="ln325"> </a>
<a name="ln326">AccidentalVal Measure::findAccidental(Note* note) const</a>
<a name="ln327">      {</a>
<a name="ln328">      Chord* chord = note-&gt;chord();</a>
<a name="ln329">      AccidentalState tversatz;  // state of already set accidentals for this measure</a>
<a name="ln330">      tversatz.init(chord-&gt;staff()-&gt;keySigEvent(tick()), chord-&gt;staff()-&gt;clef(tick()));</a>
<a name="ln331"> </a>
<a name="ln332">      for (Segment* segment = first(); segment; segment = segment-&gt;next()) {</a>
<a name="ln333">            int startTrack = chord-&gt;staffIdx() * VOICES;</a>
<a name="ln334">            if (segment-&gt;isKeySigType()) {</a>
<a name="ln335">                  KeySig* ks = toKeySig(segment-&gt;element(startTrack));</a>
<a name="ln336">                  if (!ks)</a>
<a name="ln337">                        continue;</a>
<a name="ln338">                  tversatz.init(chord-&gt;staff()-&gt;keySigEvent(segment-&gt;tick()), chord-&gt;staff()-&gt;clef(segment-&gt;tick()));</a>
<a name="ln339">                  }</a>
<a name="ln340">            else if (segment-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln341">                  int endTrack   = startTrack + VOICES;</a>
<a name="ln342">                  for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln343">                        Element* e = segment-&gt;element(track);</a>
<a name="ln344">                        if (!e || !e-&gt;isChord())</a>
<a name="ln345">                              continue;</a>
<a name="ln346">                        Chord* crd = toChord(e);</a>
<a name="ln347">                        for (Chord* chord1 : crd-&gt;graceNotes()) {</a>
<a name="ln348">                              for (Note* note1 : chord1-&gt;notes()) {</a>
<a name="ln349">                                    if (note1-&gt;tieBack() &amp;&amp; note1-&gt;accidental() == 0)</a>
<a name="ln350">                                          continue;</a>
<a name="ln351">                                    //</a>
<a name="ln352">                                    // compute accidental</a>
<a name="ln353">                                    //</a>
<a name="ln354">                                    int tpc  = note1-&gt;tpc();</a>
<a name="ln355">                                    int line = absStep(tpc, note1-&gt;epitch());</a>
<a name="ln356"> </a>
<a name="ln357">                                    if (note == note1)</a>
<a name="ln358">                                          return tversatz.accidentalVal(line);</a>
<a name="ln359">                                    tversatz.setAccidentalVal(line, tpc2alter(tpc));</a>
<a name="ln360">                                    }</a>
<a name="ln361">                              }</a>
<a name="ln362">                        for (Note* note1 : crd-&gt;notes()) {</a>
<a name="ln363">                              if (note1-&gt;tieBack() &amp;&amp; note1-&gt;accidental() == 0)</a>
<a name="ln364">                                    continue;</a>
<a name="ln365">                              //</a>
<a name="ln366">                              // compute accidental</a>
<a name="ln367">                              //</a>
<a name="ln368">                              int tpc  = note1-&gt;tpc();</a>
<a name="ln369">                              int line = absStep(tpc, note1-&gt;epitch());</a>
<a name="ln370"> </a>
<a name="ln371">                              if (note == note1)</a>
<a name="ln372">                                    return tversatz.accidentalVal(line);</a>
<a name="ln373">                              tversatz.setAccidentalVal(line, tpc2alter(tpc));</a>
<a name="ln374">                              }</a>
<a name="ln375">                        }</a>
<a name="ln376">                  }</a>
<a name="ln377">            }</a>
<a name="ln378">      qDebug(&quot;Measure::findAccidental: note not found&quot;);</a>
<a name="ln379">      return AccidentalVal::NATURAL;</a>
<a name="ln380">      }</a>
<a name="ln381"> </a>
<a name="ln382">//---------------------------------------------------------</a>
<a name="ln383">//   findAccidental</a>
<a name="ln384">///   Compute accidental state at segment/staffIdx for</a>
<a name="ln385">///   relative staff line.</a>
<a name="ln386">//---------------------------------------------------------</a>
<a name="ln387"> </a>
<a name="ln388">AccidentalVal Measure::findAccidental(Segment* s, int staffIdx, int line, bool &amp;error) const</a>
<a name="ln389">      {</a>
<a name="ln390">      AccidentalState tversatz;  // state of already set accidentals for this measure</a>
<a name="ln391">      Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln392">      tversatz.init(staff-&gt;keySigEvent(tick()), staff-&gt;clef(tick()));</a>
<a name="ln393"> </a>
<a name="ln394">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln395">      int startTrack = staffIdx * VOICES;</a>
<a name="ln396">      int endTrack   = startTrack + VOICES;</a>
<a name="ln397">      for (Segment* segment = first(st); segment; segment = segment-&gt;next(st)) {</a>
<a name="ln398">            if (segment == s &amp;&amp; staff-&gt;isPitchedStaff(tick())) {</a>
<a name="ln399">                  ClefType clef = staff-&gt;clef(s-&gt;tick());</a>
<a name="ln400">                  int l = relStep(line, clef);</a>
<a name="ln401">                  return tversatz.accidentalVal(l, error);</a>
<a name="ln402">                  }</a>
<a name="ln403">            for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln404">                  Element* e = segment-&gt;element(track);</a>
<a name="ln405">                  if (!e || !e-&gt;isChord())</a>
<a name="ln406">                        continue;</a>
<a name="ln407">                  Chord* chord = toChord(e);</a>
<a name="ln408">                  for (Chord* chord1 : chord-&gt;graceNotes()) {</a>
<a name="ln409">                        for (Note* note : chord1-&gt;notes()) {</a>
<a name="ln410">                              if (note-&gt;tieBack() &amp;&amp; note-&gt;accidental() == 0)</a>
<a name="ln411">                                    continue;</a>
<a name="ln412">                              int tpc  = note-&gt;tpc();</a>
<a name="ln413">                              int l    = absStep(tpc, note-&gt;epitch());</a>
<a name="ln414">                              tversatz.setAccidentalVal(l, tpc2alter(tpc));</a>
<a name="ln415">                              }</a>
<a name="ln416">                        }</a>
<a name="ln417"> </a>
<a name="ln418">                  for (Note* note : chord-&gt;notes()) {</a>
<a name="ln419">                        if (note-&gt;tieBack() &amp;&amp; note-&gt;accidental() == 0)</a>
<a name="ln420">                              continue;</a>
<a name="ln421">                        int tpc    = note-&gt;tpc();</a>
<a name="ln422">                        int l      = absStep(tpc, note-&gt;epitch());</a>
<a name="ln423">                        tversatz.setAccidentalVal(l, tpc2alter(tpc));</a>
<a name="ln424">                        }</a>
<a name="ln425">                  }</a>
<a name="ln426">            }</a>
<a name="ln427">      qDebug(&quot;segment not found&quot;);</a>
<a name="ln428">      return AccidentalVal::NATURAL;</a>
<a name="ln429">      }</a>
<a name="ln430"> </a>
<a name="ln431">//---------------------------------------------------------</a>
<a name="ln432">//   tick2pos</a>
<a name="ln433">//    return x position for tick relative to System</a>
<a name="ln434">//---------------------------------------------------------</a>
<a name="ln435"> </a>
<a name="ln436">qreal Measure::tick2pos(Fraction tck) const</a>
<a name="ln437">      {</a>
<a name="ln438">      tck -= ticks();</a>
<a name="ln439">      if (isMMRest()) {</a>
<a name="ln440">            Segment* s = first(SegmentType::ChordRest);</a>
<a name="ln441">            qreal x1   = s-&gt;x();</a>
<a name="ln442">            qreal w    = width() - x1;</a>
<a name="ln443">            return x1 + (tck.ticks() * w) / (ticks().ticks() * mmRestCount());</a>
<a name="ln444">            }</a>
<a name="ln445"> </a>
<a name="ln446">      Segment* s;</a>
<a name="ln447">      qreal x1  = 0;</a>
<a name="ln448">      qreal x2  = 0;</a>
<a name="ln449">      Fraction tick1 = Fraction(0,1);</a>
<a name="ln450">      Fraction tick2 = Fraction(0,1);</a>
<a name="ln451">      for (s = first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln452">            x2    = s-&gt;x();</a>
<a name="ln453">            tick2 = s-&gt;rtick();</a>
<a name="ln454">            if (tck == tick2)</a>
<a name="ln455">                  return x2 + pos().x();</a>
<a name="ln456">            if (tck &lt;= tick2)</a>
<a name="ln457">                  break;</a>
<a name="ln458">            x1    = x2;</a>
<a name="ln459">            tick1 = tick2;</a>
<a name="ln460">            }</a>
<a name="ln461">      if (s == 0) {</a>
<a name="ln462">            x2    = width();</a>
<a name="ln463">            tick2 = ticks();</a>
<a name="ln464">            }</a>
<a name="ln465">      qreal dx = x2 - x1;</a>
<a name="ln466">      Fraction dt   = tick2 - tick1;</a>
<a name="ln467">      x1      += dt.isZero() ? 0.0 : (dx * (tck.ticks() - tick1.ticks()) / dt.ticks());</a>
<a name="ln468">      return x1 + pos().x();</a>
<a name="ln469">      }</a>
<a name="ln470"> </a>
<a name="ln471">//---------------------------------------------------------</a>
<a name="ln472">//   layoutMeasureNumber</a>
<a name="ln473">//---------------------------------------------------------</a>
<a name="ln474"> </a>
<a name="ln475">void Measure::layoutMeasureNumber()</a>
<a name="ln476">      {</a>
<a name="ln477">      bool smn = false;</a>
<a name="ln478"> </a>
<a name="ln479">      if (_noMode == MeasureNumberMode::SHOW)</a>
<a name="ln480">            smn = true;</a>
<a name="ln481">      else if (_noMode == MeasureNumberMode::HIDE)</a>
<a name="ln482">            smn = false;</a>
<a name="ln483">      else {</a>
<a name="ln484">            if (score()-&gt;styleB(Sid::showMeasureNumber)</a>
<a name="ln485">               &amp;&amp; !irregular()</a>
<a name="ln486">               &amp;&amp; (no() || score()-&gt;styleB(Sid::showMeasureNumberOne))) {</a>
<a name="ln487">                  if (score()-&gt;styleB(Sid::measureNumberSystem))</a>
<a name="ln488">                        smn = (system()-&gt;firstMeasure() == this) || (prevMeasure() &amp;&amp; prevMeasure()-&gt;irregular() &amp;&amp; system()-&gt;firstMeasure() == prevMeasure());</a>
<a name="ln489">                  else {</a>
<a name="ln490">                        smn = (no() == 0 &amp;&amp; score()-&gt;styleB(Sid::showMeasureNumberOne)) ||</a>
<a name="ln491">                              ( ((no() + 1) % score()-&gt;styleI(Sid::measureNumberInterval)) == (score()-&gt;styleB(Sid::showMeasureNumberOne) ? 1 : 0) ) ||</a>
<a name="ln492">                              (score()-&gt;styleI(Sid::measureNumberInterval) == 1);</a>
<a name="ln493">                        }</a>
<a name="ln494">                  }</a>
<a name="ln495">            }</a>
<a name="ln496">      QString s;</a>
<a name="ln497">      if (smn)</a>
<a name="ln498">            s = QString(&quot;%1&quot;).arg(no() + 1);</a>
<a name="ln499">      unsigned nn = 1;</a>
<a name="ln500">      bool nas = score()-&gt;styleB(Sid::measureNumberAllStaffs);</a>
<a name="ln501"> </a>
<a name="ln502">      if (!nas) {</a>
<a name="ln503">            //find first non invisible staff</a>
<a name="ln504">            for (unsigned staffIdx = 0; staffIdx &lt; _mstaves.size(); ++staffIdx) {</a>
<a name="ln505">                  MStaff* ms = _mstaves[staffIdx];</a>
<a name="ln506">                  SysStaff* ss  = system()-&gt;staff(staffIdx);</a>
<a name="ln507">                  Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln508">                  if (ms-&gt;visible() &amp;&amp; staff-&gt;show() &amp;&amp; ss-&gt;show()) {</a>
<a name="ln509">                        nn = staffIdx;</a>
<a name="ln510">                        break;</a>
<a name="ln511">                        }</a>
<a name="ln512">                  }</a>
<a name="ln513">            }</a>
<a name="ln514">      for (unsigned staffIdx = 0; staffIdx &lt; _mstaves.size(); ++staffIdx) {</a>
<a name="ln515">            MStaff* ms       = _mstaves[staffIdx];</a>
<a name="ln516">            MeasureNumber* t = ms-&gt;noText();</a>
<a name="ln517">            if (t)</a>
<a name="ln518">                  t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln519">            if (smn &amp;&amp; ((staffIdx == nn) || nas)) {</a>
<a name="ln520">                  if (t == 0) {</a>
<a name="ln521">                        t = new MeasureNumber(score());</a>
<a name="ln522">                        t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln523">                        t-&gt;setGenerated(true);</a>
<a name="ln524">                        t-&gt;setParent(this);</a>
<a name="ln525">                        add(t);</a>
<a name="ln526">                        }</a>
<a name="ln527">                  t-&gt;setXmlText(s);</a>
<a name="ln528">                  t-&gt;layout();</a>
<a name="ln529">                  }</a>
<a name="ln530">            else {</a>
<a name="ln531">                  if (t) {</a>
<a name="ln532">                        if (t-&gt;generated())</a>
<a name="ln533">                              score()-&gt;removeElement(t);</a>
<a name="ln534">                        else</a>
<a name="ln535">                              score()-&gt;undo(new RemoveElement(t));</a>
<a name="ln536">                        }</a>
<a name="ln537">                  }</a>
<a name="ln538">            }</a>
<a name="ln539">      }</a>
<a name="ln540"> </a>
<a name="ln541">//---------------------------------------------------------</a>
<a name="ln542">//   layout2</a>
<a name="ln543">//    called after layout of page</a>
<a name="ln544">//---------------------------------------------------------</a>
<a name="ln545"> </a>
<a name="ln546">void Measure::layout2()</a>
<a name="ln547">      {</a>
<a name="ln548">      Q_ASSERT(parent());</a>
<a name="ln549">      Q_ASSERT(score()-&gt;nstaves() == int(_mstaves.size()));</a>
<a name="ln550"> </a>
<a name="ln551">      qreal _spatium = spatium();</a>
<a name="ln552"> </a>
<a name="ln553">      for (int staffIdx = 0; staffIdx &lt; score()-&gt;nstaves(); ++staffIdx) {</a>
<a name="ln554">            MStaff* ms = _mstaves[staffIdx];</a>
<a name="ln555">            Spacer* sp = ms-&gt;vspacerDown();</a>
<a name="ln556">            if (sp) {</a>
<a name="ln557">                  sp-&gt;layout();</a>
<a name="ln558">                  Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln559">                  int n = staff-&gt;lines(tick()) - 1;</a>
<a name="ln560">                  qreal y = system()-&gt;staff(staffIdx)-&gt;y();</a>
<a name="ln561">                  sp-&gt;setPos(_spatium * .5, y + n * _spatium * staff-&gt;mag(tick()));</a>
<a name="ln562">                  }</a>
<a name="ln563">            sp = ms-&gt;vspacerUp();</a>
<a name="ln564">            if (sp) {</a>
<a name="ln565">                  sp-&gt;layout();</a>
<a name="ln566">                  qreal y = system()-&gt;staff(staffIdx)-&gt;y();</a>
<a name="ln567">                  sp-&gt;setPos(_spatium * .5, y - sp-&gt;gap());</a>
<a name="ln568">                  }</a>
<a name="ln569">            }</a>
<a name="ln570"> </a>
<a name="ln571">      MeasureBase::layout();  // layout LAYOUT_BREAK elements</a>
<a name="ln572">#if 0</a>
<a name="ln573">      //---------------------------------------------------</a>
<a name="ln574">      //   set measure number</a>
<a name="ln575">      //---------------------------------------------------</a>
<a name="ln576"> </a>
<a name="ln577">      bool smn = false;</a>
<a name="ln578"> </a>
<a name="ln579">      if (_noMode == MeasureNumberMode::SHOW)</a>
<a name="ln580">            smn = true;</a>
<a name="ln581">      else if (_noMode == MeasureNumberMode::HIDE)</a>
<a name="ln582">            smn = false;</a>
<a name="ln583">      else {</a>
<a name="ln584">            if (score()-&gt;styleB(Sid::showMeasureNumber)</a>
<a name="ln585">               &amp;&amp; !irregular()</a>
<a name="ln586">               &amp;&amp; (no() || score()-&gt;styleB(Sid::showMeasureNumberOne))) {</a>
<a name="ln587">                  if (score()-&gt;styleB(Sid::measureNumberSystem))</a>
<a name="ln588">                        smn = (system()-&gt;firstMeasure() == this) || (prevMeasure() &amp;&amp; prevMeasure()-&gt;irregular() &amp;&amp; system()-&gt;firstMeasure() == prevMeasure());</a>
<a name="ln589">                  else {</a>
<a name="ln590">                        smn = (no() == 0 &amp;&amp; score()-&gt;styleB(Sid::showMeasureNumberOne)) ||</a>
<a name="ln591">                              ( ((no() + 1) % score()-&gt;styleI(Sid::measureNumberInterval)) == (score()-&gt;styleB(Sid::showMeasureNumberOne) ? 1 : 0) ) ||</a>
<a name="ln592">                              (score()-&gt;styleI(Sid::measureNumberInterval) == 1);</a>
<a name="ln593">                        }</a>
<a name="ln594">                  }</a>
<a name="ln595">            }</a>
<a name="ln596">      QString s;</a>
<a name="ln597">      if (smn)</a>
<a name="ln598">            s = QString(&quot;%1&quot;).arg(no() + 1);</a>
<a name="ln599">      int nn = 1;</a>
<a name="ln600">      bool nas = score()-&gt;styleB(Sid::measureNumberAllStaffs);</a>
<a name="ln601"> </a>
<a name="ln602">      if (!nas) {</a>
<a name="ln603">            //find first non invisible staff</a>
<a name="ln604">            for (unsigned staffIdx = 0; staffIdx &lt; _mstaves.size(); ++staffIdx) {</a>
<a name="ln605">                  MStaff* ms = _mstaves[staffIdx];</a>
<a name="ln606">                  SysStaff* ss  = system()-&gt;staff(staffIdx);</a>
<a name="ln607">                  Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln608">                  if (ms-&gt;visible() &amp;&amp; staff-&gt;show() &amp;&amp; ss-&gt;show()) {</a>
<a name="ln609">                        nn = staffIdx;</a>
<a name="ln610">                        break;</a>
<a name="ln611">                        }</a>
<a name="ln612">                  }</a>
<a name="ln613">            }</a>
<a name="ln614">      for (unsigned staffIdx = 0; staffIdx &lt; _mstaves.size(); ++staffIdx) {</a>
<a name="ln615">            MStaff* ms       = _mstaves[staffIdx];</a>
<a name="ln616">            MeasureNumber* t = ms-&gt;noText();</a>
<a name="ln617">            if (t)</a>
<a name="ln618">                  t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln619">            if (smn &amp;&amp; ((staffIdx == nn) || nas)) {</a>
<a name="ln620">                  if (t == 0) {</a>
<a name="ln621">                        t = new MeasureNumber(score());</a>
<a name="ln622">                        t-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln623">                        t-&gt;setGenerated(true);</a>
<a name="ln624">                        t-&gt;setParent(this);</a>
<a name="ln625">                        add(t);</a>
<a name="ln626">                        }</a>
<a name="ln627">                  t-&gt;setXmlText(s);</a>
<a name="ln628">                  t-&gt;layout();</a>
<a name="ln629">                  }</a>
<a name="ln630">            else {</a>
<a name="ln631">                  if (t) {</a>
<a name="ln632">                        if (t-&gt;generated())</a>
<a name="ln633">                              score()-&gt;removeElement(t);</a>
<a name="ln634">                        else</a>
<a name="ln635">                              score()-&gt;undo(new RemoveElement(t));</a>
<a name="ln636">                        }</a>
<a name="ln637">                  }</a>
<a name="ln638">            }</a>
<a name="ln639">#endif</a>
<a name="ln640"> </a>
<a name="ln641">      //---------------------------------------------------</a>
<a name="ln642">      //    layout ties</a>
<a name="ln643">      //---------------------------------------------------</a>
<a name="ln644"> </a>
<a name="ln645">      Fraction stick = system()-&gt;measures().front()-&gt;tick();</a>
<a name="ln646">      int tracks = score()-&gt;ntracks();</a>
<a name="ln647">      static const SegmentType st { SegmentType::ChordRest };</a>
<a name="ln648">      for (int track = 0; track &lt; tracks; ++track) {</a>
<a name="ln649">            if (!score()-&gt;staff(track / VOICES)-&gt;show()) {</a>
<a name="ln650">                  track += VOICES-1;</a>
<a name="ln651">                  continue;</a>
<a name="ln652">                  }</a>
<a name="ln653">            for (Segment* seg = first(st); seg; seg = seg-&gt;next(st)) {</a>
<a name="ln654">                  ChordRest* cr = seg-&gt;cr(track);</a>
<a name="ln655">                  if (!cr)</a>
<a name="ln656">                        continue;</a>
<a name="ln657"> </a>
<a name="ln658">                  if (cr-&gt;isChord()) {</a>
<a name="ln659">                        Chord* c = toChord(cr);</a>
<a name="ln660">                        for (const Note* note : c-&gt;notes()) {</a>
<a name="ln661">                              Tie* t = note-&gt;tieFor();</a>
<a name="ln662">                              if (t)</a>
<a name="ln663">                                    t-&gt;layoutFor(system());</a>
<a name="ln664">                              t = note-&gt;tieBack();</a>
<a name="ln665">                              if (t) {</a>
<a name="ln666">                                    if (t-&gt;startNote()-&gt;tick() &lt; stick)</a>
<a name="ln667">                                          t-&gt;layoutBack(system());</a>
<a name="ln668">                                    }</a>
<a name="ln669">                              for (Spanner* sp : note-&gt;spannerFor())</a>
<a name="ln670">                                    sp-&gt;layout();</a>
<a name="ln671">                              }</a>
<a name="ln672">                        }</a>
<a name="ln673">                  }</a>
<a name="ln674">            }</a>
<a name="ln675">      }</a>
<a name="ln676"> </a>
<a name="ln677">//---------------------------------------------------------</a>
<a name="ln678">//   findChord</a>
<a name="ln679">///   Search for chord at position \a tick in \a track</a>
<a name="ln680">//---------------------------------------------------------</a>
<a name="ln681"> </a>
<a name="ln682">Chord* Measure::findChord(Fraction t, int track)</a>
<a name="ln683">      {</a>
<a name="ln684">      t -= tick();</a>
<a name="ln685">      for (Segment* seg = last(); seg; seg = seg-&gt;prev()) {</a>
<a name="ln686">            if (seg-&gt;rtick() &lt; t)</a>
<a name="ln687">                  return 0;</a>
<a name="ln688">            if (seg-&gt;rtick() == t) {</a>
<a name="ln689">                  Element* el = seg-&gt;element(track);</a>
<a name="ln690">                  if (el &amp;&amp; el-&gt;isChord())</a>
<a name="ln691">                        return toChord(el);</a>
<a name="ln692">                  }</a>
<a name="ln693">            }</a>
<a name="ln694">      return 0;</a>
<a name="ln695">      }</a>
<a name="ln696"> </a>
<a name="ln697">//---------------------------------------------------------</a>
<a name="ln698">//   findChordRest</a>
<a name="ln699">///   Search for chord or rest at position \a tick at \a staff in \a voice.</a>
<a name="ln700">//---------------------------------------------------------</a>
<a name="ln701"> </a>
<a name="ln702">ChordRest* Measure::findChordRest(Fraction t, int track)</a>
<a name="ln703">      {</a>
<a name="ln704">      t -= tick();</a>
<a name="ln705">      for (const Segment&amp; seg : _segments) {</a>
<a name="ln706">            if (seg.rtick() &gt; t)</a>
<a name="ln707">                  return 0;</a>
<a name="ln708">            if (seg.rtick() == t) {</a>
<a name="ln709">                  Element* el = seg.element(track);</a>
<a name="ln710">                  if (el &amp;&amp; el-&gt;isChordRest())</a>
<a name="ln711">                        return toChordRest(el);</a>
<a name="ln712">                  }</a>
<a name="ln713">            }</a>
<a name="ln714">      return 0;</a>
<a name="ln715">      }</a>
<a name="ln716"> </a>
<a name="ln717">//---------------------------------------------------------</a>
<a name="ln718">//   tick2segment</a>
<a name="ln719">//---------------------------------------------------------</a>
<a name="ln720"> </a>
<a name="ln721">Segment* Measure::tick2segment(const Fraction&amp; _t, SegmentType st)</a>
<a name="ln722">      {</a>
<a name="ln723">      Fraction t = _t - tick();</a>
<a name="ln724">      for (Segment&amp; s : _segments) {</a>
<a name="ln725">            if (s.rtick() == t) {</a>
<a name="ln726">                  if (s.segmentType() &amp; st)</a>
<a name="ln727">                        return &amp;s;</a>
<a name="ln728">                  }</a>
<a name="ln729">            if (s.rtick() &gt; t)</a>
<a name="ln730">                  break;</a>
<a name="ln731">            }</a>
<a name="ln732">      return 0;</a>
<a name="ln733">      }</a>
<a name="ln734"> </a>
<a name="ln735">//---------------------------------------------------------</a>
<a name="ln736">//   findSegmentR</a>
<a name="ln737">//    Search for a segment of type st at measure relative</a>
<a name="ln738">//    position t.</a>
<a name="ln739">//---------------------------------------------------------</a>
<a name="ln740"> </a>
<a name="ln741">Segment* Measure::findSegmentR(SegmentType st, const Fraction&amp; t) const</a>
<a name="ln742">      {</a>
<a name="ln743">      Segment* s;</a>
<a name="ln744">      if (t &gt; (ticks() * Fraction(1,2))) {</a>
<a name="ln745">            // search backwards</a>
<a name="ln746">            for (s = last(); s &amp;&amp; s-&gt;rtick() &gt; t; s = s-&gt;prev())</a>
<a name="ln747">                  ;</a>
<a name="ln748">            while (s &amp;&amp; s-&gt;prev() &amp;&amp; s-&gt;prev()-&gt;rtick() == t)</a>
<a name="ln749">                  s = s-&gt;prev();</a>
<a name="ln750">            }</a>
<a name="ln751">      else {</a>
<a name="ln752">            // search forwards</a>
<a name="ln753">            for (s = first(); s &amp;&amp; s-&gt;rtick() &lt; t; s = s-&gt;next())</a>
<a name="ln754">                  ;</a>
<a name="ln755">            }</a>
<a name="ln756">      for (; s &amp;&amp; s-&gt;rtick() == t; s = s-&gt;next()) {</a>
<a name="ln757">            if (s-&gt;segmentType() &amp; st)</a>
<a name="ln758">                  return s;</a>
<a name="ln759">            }</a>
<a name="ln760">      return 0;</a>
<a name="ln761">      }</a>
<a name="ln762"> </a>
<a name="ln763">//---------------------------------------------------------</a>
<a name="ln764">//   undoGetSegmentR</a>
<a name="ln765">//---------------------------------------------------------</a>
<a name="ln766"> </a>
<a name="ln767">Segment* Measure::undoGetSegmentR(SegmentType type, const Fraction&amp; t)</a>
<a name="ln768">      {</a>
<a name="ln769">      Segment* s = findSegmentR(type, t);</a>
<a name="ln770">      if (s == 0) {</a>
<a name="ln771">            s = new Segment(this, type, t);</a>
<a name="ln772">            score()-&gt;undoAddElement(s);</a>
<a name="ln773">            }</a>
<a name="ln774">      return s;</a>
<a name="ln775">      }</a>
<a name="ln776"> </a>
<a name="ln777">//---------------------------------------------------------</a>
<a name="ln778">//   findFirstR</a>
<a name="ln779">//    return first segment of type st at relative</a>
<a name="ln780">//    position t.</a>
<a name="ln781">//---------------------------------------------------------</a>
<a name="ln782"> </a>
<a name="ln783">Segment* Measure::findFirstR(SegmentType st, const Fraction&amp; t) const</a>
<a name="ln784">      {</a>
<a name="ln785">      Segment* s;</a>
<a name="ln786">      // search forwards</a>
<a name="ln787">      for (s = first(); s &amp;&amp; s-&gt;rtick() &lt;= t; s = s-&gt;next()) {</a>
<a name="ln788">            if (s-&gt;segmentType() == st)</a>
<a name="ln789">                  return s;</a>
<a name="ln790">            }</a>
<a name="ln791">      return 0;</a>
<a name="ln792">      }</a>
<a name="ln793"> </a>
<a name="ln794">//---------------------------------------------------------</a>
<a name="ln795">//   getSegmentR</a>
<a name="ln796">///   Get a segment of type st at relative tick position t.</a>
<a name="ln797">///   If the segment does not exist, it is created.</a>
<a name="ln798">//---------------------------------------------------------</a>
<a name="ln799"> </a>
<a name="ln800">Segment* Measure::getSegmentR(SegmentType st, const Fraction&amp; t)</a>
<a name="ln801">      {</a>
<a name="ln802">      Segment* s = findSegmentR(st, t);</a>
<a name="ln803">      if (!s) {</a>
<a name="ln804">            s = new Segment(this, st, t);</a>
<a name="ln805">            add(s);</a>
<a name="ln806">            }</a>
<a name="ln807">      return s;</a>
<a name="ln808">      }</a>
<a name="ln809"> </a>
<a name="ln810">//---------------------------------------------------------</a>
<a name="ln811">//   add</a>
<a name="ln812">///   Add new Element \a el to Measure.</a>
<a name="ln813">//---------------------------------------------------------</a>
<a name="ln814"> </a>
<a name="ln815">void Measure::add(Element* e)</a>
<a name="ln816">      {</a>
<a name="ln817">      e-&gt;setParent(this);</a>
<a name="ln818">      ElementType type = e-&gt;type();</a>
<a name="ln819"> </a>
<a name="ln820">      switch (type) {</a>
<a name="ln821">            case ElementType::SEGMENT:</a>
<a name="ln822">                  {</a>
<a name="ln823">                  Segment* seg   = toSegment(e);</a>
<a name="ln824">                  Fraction t     = seg-&gt;rtick();</a>
<a name="ln825">                  SegmentType st = seg-&gt;segmentType();</a>
<a name="ln826">                  Segment* s;</a>
<a name="ln827"> </a>
<a name="ln828">                  for (s = first(); s &amp;&amp; s-&gt;rtick() &lt; t; s = s-&gt;next())</a>
<a name="ln829">                        ;</a>
<a name="ln830">                  while (s &amp;&amp; s-&gt;rtick() == t) {</a>
<a name="ln831">                        if (!seg-&gt;isChordRestType() &amp;&amp; (seg-&gt;segmentType() == s-&gt;segmentType())) {</a>
<a name="ln832">                              qDebug(&quot;there is already a &lt;%s&gt; segment&quot;, seg-&gt;subTypeName());</a>
<a name="ln833">                              return;</a>
<a name="ln834">                              }</a>
<a name="ln835">                        if (s-&gt;segmentType() &gt; st)</a>
<a name="ln836">                              break;</a>
<a name="ln837">                        s = s-&gt;next();</a>
<a name="ln838">                        }</a>
<a name="ln839">                  seg-&gt;setParent(this);</a>
<a name="ln840">                  _segments.insert(seg, s);</a>
<a name="ln841">                  //</a>
<a name="ln842">                  // update measure flags</a>
<a name="ln843">                  //</a>
<a name="ln844">                  if (seg-&gt;header())</a>
<a name="ln845">                        seg-&gt;measure()-&gt;setHeader(true);</a>
<a name="ln846">                  if (seg-&gt;trailer())</a>
<a name="ln847">                        seg-&gt;measure()-&gt;setTrailer(true);</a>
<a name="ln848">                  }</a>
<a name="ln849">                  break;</a>
<a name="ln850"> </a>
<a name="ln851">            case ElementType::MEASURE_NUMBER:</a>
<a name="ln852">                  if (e-&gt;staffIdx() &lt; int(_mstaves.size()))</a>
<a name="ln853">                        _mstaves[e-&gt;staffIdx()]-&gt;setNoText(toMeasureNumber(e));</a>
<a name="ln854">                  break;</a>
<a name="ln855"> </a>
<a name="ln856">            case ElementType::SPACER:</a>
<a name="ln857">                  {</a>
<a name="ln858">                  Spacer* sp = toSpacer(e);</a>
<a name="ln859">                  switch (sp-&gt;spacerType()) {</a>
<a name="ln860">                        case SpacerType::UP:</a>
<a name="ln861">                              _mstaves[e-&gt;staffIdx()]-&gt;setVspacerUp(sp);</a>
<a name="ln862">                              break;</a>
<a name="ln863">                        case SpacerType::DOWN:</a>
<a name="ln864">                        case SpacerType::FIXED:</a>
<a name="ln865">                              _mstaves[e-&gt;staffIdx()]-&gt;setVspacerDown(sp);</a>
<a name="ln866">                              break;</a>
<a name="ln867">                        }</a>
<a name="ln868">                  sp-&gt;setGap(sp-&gt;gap());  // trigger relayout</a>
<a name="ln869">                  }</a>
<a name="ln870">                  break;</a>
<a name="ln871">            case ElementType::JUMP:</a>
<a name="ln872">                  setRepeatJump(true);</a>
<a name="ln873">                  // fall through</a>
<a name="ln874"> </a>
<a name="ln875">            case ElementType::MARKER:</a>
<a name="ln876">                  el().push_back(e);</a>
<a name="ln877">                  break;</a>
<a name="ln878"> </a>
<a name="ln879">            case ElementType::HBOX:</a>
<a name="ln880">                  if (e-&gt;staff())</a>
<a name="ln881">                        e-&gt;setMag(e-&gt;staff()-&gt;mag(tick()));     // ?!</a>
<a name="ln882">                  el().push_back(e);</a>
<a name="ln883">                  break;</a>
<a name="ln884"> </a>
<a name="ln885">            case ElementType::MEASURE:</a>
<a name="ln886">                  _mmRest = toMeasure(e);</a>
<a name="ln887">                  break;</a>
<a name="ln888"> </a>
<a name="ln889">            case ElementType::STAFFTYPE_CHANGE:</a>
<a name="ln890">                  {</a>
<a name="ln891">                  StaffTypeChange* stc = toStaffTypeChange(e);</a>
<a name="ln892">                  Staff* staff = stc-&gt;staff();</a>
<a name="ln893">                  const StaffType* st = stc-&gt;staffType();</a>
<a name="ln894">                  StaffType* nst;</a>
<a name="ln895">                  // st needs to point to the stafftype element within the stafftypelist for the staff</a>
<a name="ln896">                  if (st) {</a>
<a name="ln897">                        // executed on read, undo/redo, clone</a>
<a name="ln898">                        // setStaffType adds a copy to list and returns a pointer to that element within list</a>
<a name="ln899">                        // we won't need the original after that</a>
<a name="ln900">                        // this requires that st was allocated via new to begin with!</a>
<a name="ln901">                        nst = staff-&gt;setStaffType(tick(), *st);</a>
<a name="ln902">                        delete st;</a>
<a name="ln903">                        }</a>
<a name="ln904">                  else {</a>
<a name="ln905">                        // executed on add from palette</a>
<a name="ln906">                        // staffType returns a pointer to the current stafftype element in the list</a>
<a name="ln907">                        // setStaffType will make a copy and return a pointer to that element within list</a>
<a name="ln908">                        st  = staff-&gt;staffType(tick());</a>
<a name="ln909">                        nst = staff-&gt;setStaffType(tick(), *st);</a>
<a name="ln910">                        }</a>
<a name="ln911">                  staff-&gt;staffTypeListChanged(tick());</a>
<a name="ln912">                  stc-&gt;setStaffType(nst);</a>
<a name="ln913">                  MeasureBase::add(e);</a>
<a name="ln914">                  }</a>
<a name="ln915">                  break;</a>
<a name="ln916"> </a>
<a name="ln917">            default:</a>
<a name="ln918">                  MeasureBase::add(e);</a>
<a name="ln919">                  break;</a>
<a name="ln920">            }</a>
<a name="ln921">      }</a>
<a name="ln922"> </a>
<a name="ln923">//---------------------------------------------------------</a>
<a name="ln924">//   remove</a>
<a name="ln925">///   Remove Element \a el from Measure.</a>
<a name="ln926">//---------------------------------------------------------</a>
<a name="ln927"> </a>
<a name="ln928">void Measure::remove(Element* e)</a>
<a name="ln929">      {</a>
<a name="ln930">      Q_ASSERT(e-&gt;parent() == this);</a>
<a name="ln931">      Q_ASSERT(e-&gt;score() == score());</a>
<a name="ln932"> </a>
<a name="ln933">      switch (e-&gt;type()) {</a>
<a name="ln934">            case ElementType::SEGMENT:</a>
<a name="ln935">                  {</a>
<a name="ln936">                  Segment* s = toSegment(e);</a>
<a name="ln937">                  _segments.remove(s);</a>
<a name="ln938">                  //</a>
<a name="ln939">                  // update measure flags</a>
<a name="ln940">                  //</a>
<a name="ln941">                  if (s-&gt;header())</a>
<a name="ln942">                        s-&gt;measure()-&gt;checkHeader();</a>
<a name="ln943">                  if (s-&gt;trailer())</a>
<a name="ln944">                        s-&gt;measure()-&gt;checkTrailer();</a>
<a name="ln945">                  }</a>
<a name="ln946">                  break;</a>
<a name="ln947"> </a>
<a name="ln948">            case ElementType::MEASURE_NUMBER:</a>
<a name="ln949">                  _mstaves[e-&gt;staffIdx()]-&gt;setNoText(nullptr);</a>
<a name="ln950">                  break;</a>
<a name="ln951"> </a>
<a name="ln952">            case ElementType::SPACER:</a>
<a name="ln953">                  switch (toSpacer(e)-&gt;spacerType()) {</a>
<a name="ln954">                        case SpacerType::DOWN:</a>
<a name="ln955">                        case SpacerType::FIXED:</a>
<a name="ln956">                              _mstaves[e-&gt;staffIdx()]-&gt;setVspacerDown(0);</a>
<a name="ln957">                              break;</a>
<a name="ln958">                        case SpacerType::UP:</a>
<a name="ln959">                              _mstaves[e-&gt;staffIdx()]-&gt;setVspacerUp(0);</a>
<a name="ln960">                              break;</a>
<a name="ln961">                        }</a>
<a name="ln962">                  break;</a>
<a name="ln963"> </a>
<a name="ln964">            case ElementType::JUMP:</a>
<a name="ln965">                  setRepeatJump(false);</a>
<a name="ln966">                  // fall through</a>
<a name="ln967"> </a>
<a name="ln968">            case ElementType::MARKER:</a>
<a name="ln969">            case ElementType::HBOX:</a>
<a name="ln970">                  if (!el().remove(e)) {</a>
<a name="ln971">                        qDebug(&quot;Measure(%p)::remove(%s,%p) not found&quot;, this, e-&gt;name(), e);</a>
<a name="ln972">                        }</a>
<a name="ln973">                  break;</a>
<a name="ln974"> </a>
<a name="ln975">            case ElementType::CLEF:</a>
<a name="ln976">            case ElementType::CHORD:</a>
<a name="ln977">            case ElementType::REST:</a>
<a name="ln978">            case ElementType::TIMESIG:</a>
<a name="ln979">                  for (Segment* segment = first(); segment; segment = segment-&gt;next()) {</a>
<a name="ln980">                        int staves = score()-&gt;nstaves();</a>
<a name="ln981">                        int tracks = staves * VOICES;</a>
<a name="ln982">                        for (int track = 0; track &lt; tracks; ++track) {</a>
<a name="ln983">                              Element* ee = segment-&gt;element(track);</a>
<a name="ln984">                              if (ee == e) {</a>
<a name="ln985">                                    segment-&gt;setElement(track, 0);</a>
<a name="ln986">                                    return;</a>
<a name="ln987">                                    }</a>
<a name="ln988">                              }</a>
<a name="ln989">                        }</a>
<a name="ln990">                  qDebug(&quot;Measure::remove: %s %p not found&quot;, e-&gt;name(), e);</a>
<a name="ln991">                  break;</a>
<a name="ln992"> </a>
<a name="ln993">            case ElementType::MEASURE:</a>
<a name="ln994">                  _mmRest = 0;</a>
<a name="ln995">                  break;</a>
<a name="ln996"> </a>
<a name="ln997">            case ElementType::STAFFTYPE_CHANGE:</a>
<a name="ln998">                  {</a>
<a name="ln999">                  StaffTypeChange* stc = toStaffTypeChange(e);</a>
<a name="ln1000">                  Staff* staff = stc-&gt;staff();</a>
<a name="ln1001">                  if (staff) {</a>
<a name="ln1002">                        // st currently points to an list element that is about to be removed</a>
<a name="ln1003">                        // make a copy now to use on undo/redo</a>
<a name="ln1004">                        StaffType* st = new StaffType(*stc-&gt;staffType());</a>
<a name="ln1005">                        if (!tick().isZero())</a>
<a name="ln1006">                              staff-&gt;removeStaffType(tick());</a>
<a name="ln1007">                        stc-&gt;setStaffType(st);</a>
<a name="ln1008">                        }</a>
<a name="ln1009">                  MeasureBase::remove(e);</a>
<a name="ln1010">                  }</a>
<a name="ln1011">                  break;</a>
<a name="ln1012"> </a>
<a name="ln1013">            default:</a>
<a name="ln1014">                  MeasureBase::remove(e);</a>
<a name="ln1015">                  break;</a>
<a name="ln1016">            }</a>
<a name="ln1017">      }</a>
<a name="ln1018"> </a>
<a name="ln1019">//---------------------------------------------------------</a>
<a name="ln1020">//   change</a>
<a name="ln1021">//---------------------------------------------------------</a>
<a name="ln1022"> </a>
<a name="ln1023">void Measure::change(Element* o, Element* n)</a>
<a name="ln1024">      {</a>
<a name="ln1025">      if (o-&gt;isTuplet()) {</a>
<a name="ln1026">            Tuplet* t = toTuplet(n);</a>
<a name="ln1027">            for (DurationElement* e : t-&gt;elements())</a>
<a name="ln1028">                  e-&gt;setTuplet(t);</a>
<a name="ln1029">            }</a>
<a name="ln1030">      else {</a>
<a name="ln1031">            remove(o);</a>
<a name="ln1032">            add(n);</a>
<a name="ln1033">            }</a>
<a name="ln1034">      }</a>
<a name="ln1035"> </a>
<a name="ln1036">//---------------------------------------------------------</a>
<a name="ln1037">//   spatiumChanged</a>
<a name="ln1038">//---------------------------------------------------------</a>
<a name="ln1039"> </a>
<a name="ln1040">void Measure::spatiumChanged(qreal /*oldValue*/, qreal /*newValue*/)</a>
<a name="ln1041">      {</a>
<a name="ln1042">      }</a>
<a name="ln1043"> </a>
<a name="ln1044">//-------------------------------------------------------------------</a>
<a name="ln1045">//   moveTicks</a>
<a name="ln1046">//    Also adjust endBarLine if measure len has changed. For this</a>
<a name="ln1047">//    diff == 0 cannot be optimized away</a>
<a name="ln1048">//-------------------------------------------------------------------</a>
<a name="ln1049"> </a>
<a name="ln1050">void Measure::moveTicks(const Fraction&amp; diff)</a>
<a name="ln1051">      {</a>
<a name="ln1052">      std::set&lt;Tuplet*&gt; tuplets;</a>
<a name="ln1053">      setTick(tick() + diff);</a>
<a name="ln1054">      for (Segment* segment = last(); segment; segment = segment-&gt;prev()) {</a>
<a name="ln1055">            if (segment-&gt;segmentType() &amp; (SegmentType::EndBarLine | SegmentType::TimeSigAnnounce))</a>
<a name="ln1056">                  segment-&gt;setRtick(ticks());</a>
<a name="ln1057">            else if (segment-&gt;isChordRestType()) {</a>
<a name="ln1058">                  // Tuplet ticks are stored as absolute ticks, so they must be adjusted.</a>
<a name="ln1059">                  // But each tuplet must only be adjusted once.</a>
<a name="ln1060">                  for (Element* e : segment-&gt;elist()) {</a>
<a name="ln1061">                        if (e) {</a>
<a name="ln1062">                              ChordRest* cr = toChordRest(e);</a>
<a name="ln1063">                              Tuplet* tuplet = cr-&gt;tuplet();</a>
<a name="ln1064">                              if (tuplet &amp;&amp; tuplets.count(tuplet) == 0)</a>
<a name="ln1065">                                    tuplets.insert(tuplet);</a>
<a name="ln1066">                              }</a>
<a name="ln1067">                        }</a>
<a name="ln1068">                  }</a>
<a name="ln1069">            }</a>
<a name="ln1070">      tuplets.clear();</a>
<a name="ln1071">      }</a>
<a name="ln1072"> </a>
<a name="ln1073">//---------------------------------------------------------</a>
<a name="ln1074">//   removeStaves</a>
<a name="ln1075">//---------------------------------------------------------</a>
<a name="ln1076"> </a>
<a name="ln1077">void Measure::removeStaves(int sStaff, int eStaff)</a>
<a name="ln1078">      {</a>
<a name="ln1079">      for (Segment* s = first(); s; s = s-&gt;next()) {</a>
<a name="ln1080">            for (int staff = eStaff-1; staff &gt;= sStaff; --staff) {</a>
<a name="ln1081">                  s-&gt;removeStaff(staff);</a>
<a name="ln1082">                  }</a>
<a name="ln1083">            }</a>
<a name="ln1084">      for (Element* e : el()) {</a>
<a name="ln1085">            if (e-&gt;track() == -1)</a>
<a name="ln1086">                  continue;</a>
<a name="ln1087">            int voice = e-&gt;voice();</a>
<a name="ln1088">            int staffIdx = e-&gt;staffIdx();</a>
<a name="ln1089">            if (staffIdx &gt;= eStaff) {</a>
<a name="ln1090">                  staffIdx -= eStaff - sStaff;</a>
<a name="ln1091">                  e-&gt;setTrack(staffIdx * VOICES + voice);</a>
<a name="ln1092">                  }</a>
<a name="ln1093">            }</a>
<a name="ln1094">      }</a>
<a name="ln1095"> </a>
<a name="ln1096">//---------------------------------------------------------</a>
<a name="ln1097">//   insertStaves</a>
<a name="ln1098">//---------------------------------------------------------</a>
<a name="ln1099"> </a>
<a name="ln1100">void Measure::insertStaves(int sStaff, int eStaff)</a>
<a name="ln1101">      {</a>
<a name="ln1102">      for (Element* e : el()) {</a>
<a name="ln1103">            if (e-&gt;track() == -1)</a>
<a name="ln1104">                  continue;</a>
<a name="ln1105">            int staffIdx = e-&gt;staffIdx();</a>
<a name="ln1106">            if (staffIdx &gt;= sStaff &amp;&amp; !e-&gt;systemFlag()) {</a>
<a name="ln1107">                  int voice = e-&gt;voice();</a>
<a name="ln1108">                  staffIdx += eStaff - sStaff;</a>
<a name="ln1109">                  e-&gt;setTrack(staffIdx * VOICES + voice);</a>
<a name="ln1110">                  }</a>
<a name="ln1111">            }</a>
<a name="ln1112">      for (Segment* s = first(); s; s = s-&gt;next()) {</a>
<a name="ln1113">            for (int staff = sStaff; staff &lt; eStaff; ++staff) {</a>
<a name="ln1114">                  s-&gt;insertStaff(staff);</a>
<a name="ln1115">                  }</a>
<a name="ln1116">            }</a>
<a name="ln1117">      }</a>
<a name="ln1118"> </a>
<a name="ln1119">//---------------------------------------------------------</a>
<a name="ln1120">//   cmdRemoveStaves</a>
<a name="ln1121">//---------------------------------------------------------</a>
<a name="ln1122"> </a>
<a name="ln1123">void Measure::cmdRemoveStaves(int sStaff, int eStaff)</a>
<a name="ln1124">      {</a>
<a name="ln1125">      int sTrack = sStaff * VOICES;</a>
<a name="ln1126">      int eTrack = eStaff * VOICES;</a>
<a name="ln1127">      for (Segment* s = first(); s; s = s-&gt;next()) {</a>
<a name="ln1128">            for (int track = eTrack - 1; track &gt;= sTrack; --track) {</a>
<a name="ln1129">                  Element* el = s-&gt;element(track);</a>
<a name="ln1130">                  if (el) {</a>
<a name="ln1131">                        el-&gt;undoUnlink();</a>
<a name="ln1132">                        score()-&gt;undo(new RemoveElement(el));</a>
<a name="ln1133">                        }</a>
<a name="ln1134">                  }</a>
<a name="ln1135">            foreach (Element* e, s-&gt;annotations()) {</a>
<a name="ln1136">                  int staffIdx = e-&gt;staffIdx();</a>
<a name="ln1137">                  if ((staffIdx &gt;= sStaff) &amp;&amp; (staffIdx &lt; eStaff) &amp;&amp; !e-&gt;systemFlag()) {</a>
<a name="ln1138">                        e-&gt;undoUnlink();</a>
<a name="ln1139">                        score()-&gt;undo(new RemoveElement(e));</a>
<a name="ln1140">                        }</a>
<a name="ln1141">                  }</a>
<a name="ln1142">            }</a>
<a name="ln1143">      for (Element* e : el()) {</a>
<a name="ln1144">            if (e-&gt;track() == -1)</a>
<a name="ln1145">                  continue;</a>
<a name="ln1146">            int staffIdx = e-&gt;staffIdx();</a>
<a name="ln1147">            if (staffIdx &gt;= sStaff &amp;&amp; (staffIdx &lt; eStaff) &amp;&amp; !e-&gt;systemFlag()) {</a>
<a name="ln1148">                  e-&gt;undoUnlink();</a>
<a name="ln1149">                  score()-&gt;undo(new RemoveElement(e));</a>
<a name="ln1150">                  }</a>
<a name="ln1151">            }</a>
<a name="ln1152"> </a>
<a name="ln1153">      score()-&gt;undo(new RemoveStaves(this, sStaff, eStaff));</a>
<a name="ln1154"> </a>
<a name="ln1155">      for (int i = eStaff - 1; i &gt;= sStaff; --i) {</a>
<a name="ln1156">            MStaff* ms = *(_mstaves.begin()+i);</a>
<a name="ln1157">            score()-&gt;undo(new RemoveMStaff(this, ms, i));</a>
<a name="ln1158">            }</a>
<a name="ln1159"> </a>
<a name="ln1160">      // barLine</a>
<a name="ln1161">      // TODO</a>
<a name="ln1162">      }</a>
<a name="ln1163"> </a>
<a name="ln1164">//---------------------------------------------------------</a>
<a name="ln1165">//   cmdAddStaves</a>
<a name="ln1166">//---------------------------------------------------------</a>
<a name="ln1167"> </a>
<a name="ln1168">void Measure::cmdAddStaves(int sStaff, int eStaff, bool createRest)</a>
<a name="ln1169">      {</a>
<a name="ln1170">      score()-&gt;undo(new InsertStaves(this, sStaff, eStaff));</a>
<a name="ln1171"> </a>
<a name="ln1172">      Segment* ts = findSegment(SegmentType::TimeSig, tick());</a>
<a name="ln1173">      Segment* bs = findSegmentR(SegmentType::EndBarLine, ticks());</a>
<a name="ln1174"> </a>
<a name="ln1175">      for (int i = sStaff; i &lt; eStaff; ++i) {</a>
<a name="ln1176">            Staff* staff = score()-&gt;staff(i);</a>
<a name="ln1177">            MStaff* ms   = new MStaff;</a>
<a name="ln1178">            ms-&gt;setLines(new StaffLines(score()));</a>
<a name="ln1179">            ms-&gt;lines()-&gt;setTrack(i * VOICES);</a>
<a name="ln1180">            ms-&gt;lines()-&gt;setParent(this);</a>
<a name="ln1181">            ms-&gt;lines()-&gt;setVisible(!staff-&gt;invisible());</a>
<a name="ln1182">            score()-&gt;undo(new InsertMStaff(this, ms, i));</a>
<a name="ln1183">            }</a>
<a name="ln1184"> </a>
<a name="ln1185">      if (!createRest &amp;&amp; !ts)</a>
<a name="ln1186">            return;</a>
<a name="ln1187"> </a>
<a name="ln1188"> </a>
<a name="ln1189">      // create list of unique staves (only one instance for linked staves):</a>
<a name="ln1190"> </a>
<a name="ln1191">      QList&lt;int&gt; sl;</a>
<a name="ln1192">      for (int staffIdx = sStaff; staffIdx &lt; eStaff; ++staffIdx) {</a>
<a name="ln1193">            Staff* s = score()-&gt;staff(staffIdx);</a>
<a name="ln1194">            if (s-&gt;links()) {</a>
<a name="ln1195">                  bool alreadyInList = false;</a>
<a name="ln1196">                  for (int idx : sl) {</a>
<a name="ln1197">                        if (s-&gt;links()-&gt;contains(score()-&gt;staff(idx))) {</a>
<a name="ln1198">                              alreadyInList = true;</a>
<a name="ln1199">                              break;</a>
<a name="ln1200">                              }</a>
<a name="ln1201">                        }</a>
<a name="ln1202">                  if (alreadyInList)</a>
<a name="ln1203">                        continue;</a>
<a name="ln1204">                  }</a>
<a name="ln1205">            sl.append(staffIdx);</a>
<a name="ln1206">            }</a>
<a name="ln1207"> </a>
<a name="ln1208">      for (int staffIdx : sl) {</a>
<a name="ln1209">            if (createRest)</a>
<a name="ln1210">                  score()-&gt;setRest(tick(), staffIdx * VOICES, ticks(), false, 0, _timesig == ticks());</a>
<a name="ln1211"> </a>
<a name="ln1212">            // replicate time signature</a>
<a name="ln1213">            if (ts) {</a>
<a name="ln1214">                  TimeSig* ots = 0;</a>
<a name="ln1215">                  bool constructed = false;</a>
<a name="ln1216">                  for (unsigned track = 0; track &lt; _mstaves.size() * VOICES; ++track) {</a>
<a name="ln1217">                        if (ts-&gt;element(track)) {</a>
<a name="ln1218">                              ots = toTimeSig(ts-&gt;element(track));</a>
<a name="ln1219">                              break;</a>
<a name="ln1220">                              }</a>
<a name="ln1221">                        }</a>
<a name="ln1222">                  if (!ots) {</a>
<a name="ln1223">                        // no time signature found; use measure timesig to construct one</a>
<a name="ln1224">                        ots = new TimeSig(score());</a>
<a name="ln1225">                        ots-&gt;setSig(timesig());</a>
<a name="ln1226">                        constructed = true;</a>
<a name="ln1227">                        }</a>
<a name="ln1228">                  // do no replicate local time signatures</a>
<a name="ln1229">                  if (ots &amp;&amp; !ots-&gt;isLocal()) {</a>
<a name="ln1230">                        TimeSig* timesig = new TimeSig(*ots);</a>
<a name="ln1231">                        timesig-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1232">                        timesig-&gt;setParent(ts);</a>
<a name="ln1233">                        timesig-&gt;setSig(ots-&gt;sig(), ots-&gt;timeSigType());</a>
<a name="ln1234">                        score()-&gt;undoAddElement(timesig);</a>
<a name="ln1235">                        if (constructed)</a>
<a name="ln1236">                              delete ots;</a>
<a name="ln1237">                        }</a>
<a name="ln1238">                  }</a>
<a name="ln1239"> </a>
<a name="ln1240">            // replicate barline</a>
<a name="ln1241">            if (bs) {</a>
<a name="ln1242">                  BarLine* obl = nullptr;</a>
<a name="ln1243">                  for (unsigned track = 0; track &lt; _mstaves.size() * VOICES; ++track) {</a>
<a name="ln1244">                        Element* e = bs-&gt;element(track);</a>
<a name="ln1245">                        if (e &amp;&amp; !e-&gt;generated()) {</a>
<a name="ln1246">                              obl = toBarLine(e);</a>
<a name="ln1247">                              break;</a>
<a name="ln1248">                              }</a>
<a name="ln1249">                        }</a>
<a name="ln1250">                  if (obl) {</a>
<a name="ln1251">                        BarLine* barline = new BarLine(*obl);</a>
<a name="ln1252">                        barline-&gt;setSpanStaff(score()-&gt;staff(staffIdx)-&gt;barLineSpan());</a>
<a name="ln1253">                        barline-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1254">                        barline-&gt;setParent(bs);</a>
<a name="ln1255">                        barline-&gt;setGenerated(false);</a>
<a name="ln1256">                        score()-&gt;undoAddElement(barline);</a>
<a name="ln1257">                        }</a>
<a name="ln1258">                  }</a>
<a name="ln1259">            }</a>
<a name="ln1260">      }</a>
<a name="ln1261"> </a>
<a name="ln1262">//---------------------------------------------------------</a>
<a name="ln1263">//   insertMStaff</a>
<a name="ln1264">//---------------------------------------------------------</a>
<a name="ln1265"> </a>
<a name="ln1266">void Measure::insertMStaff(MStaff* staff, int idx)</a>
<a name="ln1267">      {</a>
<a name="ln1268">      _mstaves.insert(_mstaves.begin()+idx, staff);</a>
<a name="ln1269">      for (unsigned staffIdx = 0; staffIdx &lt; _mstaves.size(); ++staffIdx)</a>
<a name="ln1270">            _mstaves[staffIdx]-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1271">      }</a>
<a name="ln1272"> </a>
<a name="ln1273">//---------------------------------------------------------</a>
<a name="ln1274">//   removeMStaff</a>
<a name="ln1275">//---------------------------------------------------------</a>
<a name="ln1276"> </a>
<a name="ln1277">void Measure::removeMStaff(MStaff* /*staff*/, int idx)</a>
<a name="ln1278">      {</a>
<a name="ln1279">      _mstaves.erase(_mstaves.begin()+idx);</a>
<a name="ln1280">      for (unsigned staffIdx = 0; staffIdx &lt; _mstaves.size(); ++staffIdx)</a>
<a name="ln1281">            _mstaves[staffIdx]-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1282">      }</a>
<a name="ln1283"> </a>
<a name="ln1284">//---------------------------------------------------------</a>
<a name="ln1285">//   insertStaff</a>
<a name="ln1286">//---------------------------------------------------------</a>
<a name="ln1287"> </a>
<a name="ln1288">void Measure::insertStaff(Staff* staff, int staffIdx)</a>
<a name="ln1289">      {</a>
<a name="ln1290">      for (Segment* s = first(); s; s = s-&gt;next())</a>
<a name="ln1291">            s-&gt;insertStaff(staffIdx);</a>
<a name="ln1292"> </a>
<a name="ln1293">      MStaff* ms = new MStaff;</a>
<a name="ln1294">      ms-&gt;setLines(new StaffLines(score()));</a>
<a name="ln1295">      ms-&gt;lines()-&gt;setParent(this);</a>
<a name="ln1296">      ms-&gt;lines()-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1297">      ms-&gt;lines()-&gt;setVisible(!staff-&gt;invisible());</a>
<a name="ln1298">      insertMStaff(ms, staffIdx);</a>
<a name="ln1299">      }</a>
<a name="ln1300"> </a>
<a name="ln1301">//---------------------------------------------------------</a>
<a name="ln1302">//   staffabbox</a>
<a name="ln1303">//---------------------------------------------------------</a>
<a name="ln1304"> </a>
<a name="ln1305">QRectF Measure::staffabbox(int staffIdx) const</a>
<a name="ln1306">      {</a>
<a name="ln1307">      System* s = system();</a>
<a name="ln1308">      QRectF sb(s-&gt;staff(staffIdx)-&gt;bbox());</a>
<a name="ln1309">      QRectF rrr(sb.translated(s-&gt;pagePos()));</a>
<a name="ln1310">      QRectF rr(abbox());</a>
<a name="ln1311">      QRectF r(rr.x(), rrr.y(), rr.width(), rrr.height());</a>
<a name="ln1312">      return r;</a>
<a name="ln1313">      }</a>
<a name="ln1314"> </a>
<a name="ln1315">//---------------------------------------------------------</a>
<a name="ln1316">//   acceptDrop</a>
<a name="ln1317">//---------------------------------------------------------</a>
<a name="ln1318"> </a>
<a name="ln1319">/**</a>
<a name="ln1320"> Return true if an Element of type \a type can be dropped on a Measure</a>
<a name="ln1321">*/</a>
<a name="ln1322"> </a>
<a name="ln1323">bool Measure::acceptDrop(EditData&amp; data) const</a>
<a name="ln1324">      {</a>
<a name="ln1325">      MuseScoreView* viewer = data.view;</a>
<a name="ln1326">      QPointF pos           = data.pos;</a>
<a name="ln1327">      Element* e            = data.dropElement;</a>
<a name="ln1328"> </a>
<a name="ln1329">      int staffIdx;</a>
<a name="ln1330">      Segment* seg;</a>
<a name="ln1331">      if (!score()-&gt;pos2measure(pos, &amp;staffIdx, 0, &amp;seg, 0))</a>
<a name="ln1332">            return false;</a>
<a name="ln1333"> </a>
<a name="ln1334">      QRectF staffR = system()-&gt;staff(staffIdx)-&gt;bbox().translated(system()-&gt;canvasPos());</a>
<a name="ln1335">      staffR &amp;= canvasBoundingRect();</a>
<a name="ln1336"> </a>
<a name="ln1337">      switch (e-&gt;type()) {</a>
<a name="ln1338">            case ElementType::MEASURE_LIST:</a>
<a name="ln1339">            case ElementType::JUMP:</a>
<a name="ln1340">            case ElementType::MARKER:</a>
<a name="ln1341">            case ElementType::LAYOUT_BREAK:</a>
<a name="ln1342">            case ElementType::STAFF_LIST:</a>
<a name="ln1343">                  viewer-&gt;setDropRectangle(canvasBoundingRect());</a>
<a name="ln1344">                  return true;</a>
<a name="ln1345"> </a>
<a name="ln1346">            case ElementType::KEYSIG:</a>
<a name="ln1347">            case ElementType::TIMESIG:</a>
<a name="ln1348">                  if (data.modifiers &amp; Qt::ControlModifier)</a>
<a name="ln1349">                        viewer-&gt;setDropRectangle(staffR);</a>
<a name="ln1350">                  else</a>
<a name="ln1351">                        viewer-&gt;setDropRectangle(canvasBoundingRect());</a>
<a name="ln1352">                  return true;</a>
<a name="ln1353"> </a>
<a name="ln1354">            case ElementType::BRACKET:</a>
<a name="ln1355">            case ElementType::REPEAT_MEASURE:</a>
<a name="ln1356">            case ElementType::MEASURE:</a>
<a name="ln1357">            case ElementType::SPACER:</a>
<a name="ln1358">            case ElementType::IMAGE:</a>
<a name="ln1359">            case ElementType::BAR_LINE:</a>
<a name="ln1360">            case ElementType::SYMBOL:</a>
<a name="ln1361">            case ElementType::CLEF:</a>
<a name="ln1362">            case ElementType::STAFFTYPE_CHANGE:</a>
<a name="ln1363">                  viewer-&gt;setDropRectangle(staffR);</a>
<a name="ln1364">                  return true;</a>
<a name="ln1365"> </a>
<a name="ln1366">            case ElementType::ICON:</a>
<a name="ln1367">                  switch (toIcon(e)-&gt;iconType()) {</a>
<a name="ln1368">                        case IconType::VFRAME:</a>
<a name="ln1369">                        case IconType::HFRAME:</a>
<a name="ln1370">                        case IconType::TFRAME:</a>
<a name="ln1371">                        case IconType::FFRAME:</a>
<a name="ln1372">                        case IconType::MEASURE:</a>
<a name="ln1373">                              viewer-&gt;setDropRectangle(canvasBoundingRect());</a>
<a name="ln1374">                              return true;</a>
<a name="ln1375">                        default:</a>
<a name="ln1376">                              break;</a>
<a name="ln1377">                        }</a>
<a name="ln1378">                  break;</a>
<a name="ln1379"> </a>
<a name="ln1380">            default:</a>
<a name="ln1381">                  break;</a>
<a name="ln1382">            }</a>
<a name="ln1383">      return false;</a>
<a name="ln1384">      }</a>
<a name="ln1385"> </a>
<a name="ln1386">//---------------------------------------------------------</a>
<a name="ln1387">//   drop</a>
<a name="ln1388">///   Drop element.</a>
<a name="ln1389">///   Handle a dropped element at position \a pos of given</a>
<a name="ln1390">///   element \a type and \a subtype.</a>
<a name="ln1391">//---------------------------------------------------------</a>
<a name="ln1392"> </a>
<a name="ln1393">Element* Measure::drop(EditData&amp; data)</a>
<a name="ln1394">      {</a>
<a name="ln1395">      Element* e = data.dropElement;</a>
<a name="ln1396">      int staffIdx = -1;</a>
<a name="ln1397">      Segment* seg;</a>
<a name="ln1398">      score()-&gt;pos2measure(data.pos, &amp;staffIdx, 0, &amp;seg, 0);</a>
<a name="ln1399"> </a>
<a name="ln1400">      if (e-&gt;systemFlag())</a>
<a name="ln1401">            staffIdx = 0;</a>
<a name="ln1402">      if (staffIdx &lt; 0)</a>
<a name="ln1403">            return 0;</a>
<a name="ln1404">      Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln1405">      //bool fromPalette = (e-&gt;track() == -1);</a>
<a name="ln1406"> </a>
<a name="ln1407">      switch (e-&gt;type()) {</a>
<a name="ln1408">            case ElementType::MEASURE_LIST:</a>
<a name="ln1409">                  delete e;</a>
<a name="ln1410">                  break;</a>
<a name="ln1411"> </a>
<a name="ln1412">            case ElementType::STAFF_LIST:</a>
<a name="ln1413">//TODO                  score()-&gt;pasteStaff(e, this, staffIdx);</a>
<a name="ln1414">                  delete e;</a>
<a name="ln1415">                  break;</a>
<a name="ln1416"> </a>
<a name="ln1417">            case ElementType::MARKER:</a>
<a name="ln1418">            case ElementType::JUMP:</a>
<a name="ln1419">                  e-&gt;setParent(this);</a>
<a name="ln1420">                  e-&gt;setTrack(0);</a>
<a name="ln1421">                  score()-&gt;undoAddElement(e);</a>
<a name="ln1422">                  return e;</a>
<a name="ln1423"> </a>
<a name="ln1424">            case ElementType::DYNAMIC:</a>
<a name="ln1425">            case ElementType::FRET_DIAGRAM:</a>
<a name="ln1426">                  e-&gt;setParent(seg);</a>
<a name="ln1427">                  e-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1428">                  score()-&gt;undoAddElement(e);</a>
<a name="ln1429">                  return e;</a>
<a name="ln1430"> </a>
<a name="ln1431">            case ElementType::IMAGE:</a>
<a name="ln1432">            case ElementType::SYMBOL:</a>
<a name="ln1433">                  e-&gt;setParent(seg);</a>
<a name="ln1434">                  e-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1435">                  e-&gt;layout();</a>
<a name="ln1436">                  {</a>
<a name="ln1437">                  QPointF uo(data.pos - e-&gt;canvasPos() - data.dragOffset);</a>
<a name="ln1438">                  e-&gt;setOffset(uo);</a>
<a name="ln1439">                  }</a>
<a name="ln1440">                  score()-&gt;undoAddElement(e);</a>
<a name="ln1441">                  return e;</a>
<a name="ln1442"> </a>
<a name="ln1443">            case ElementType::BRACKET:</a>
<a name="ln1444">                  {</a>
<a name="ln1445">                  Bracket* b = toBracket(e);</a>
<a name="ln1446">                  int level = 0;</a>
<a name="ln1447">                  int firstStaff = 0;</a>
<a name="ln1448">                  for (Staff* s : score()-&gt;staves()) {</a>
<a name="ln1449">                        for (const BracketItem* bi : s-&gt;brackets()) {</a>
<a name="ln1450">                              int lastStaff = firstStaff + bi-&gt;bracketSpan() - 1;</a>
<a name="ln1451">                              if (staffIdx &gt;= firstStaff &amp;&amp; staffIdx &lt;= lastStaff)</a>
<a name="ln1452">                                    ++level;</a>
<a name="ln1453">                              }</a>
<a name="ln1454">                        firstStaff++;</a>
<a name="ln1455">                        }</a>
<a name="ln1456">                  score()-&gt;undoAddBracket(staff, level, b-&gt;bracketType(), 1);</a>
<a name="ln1457">                  delete b;</a>
<a name="ln1458">                  }</a>
<a name="ln1459">                  return 0;</a>
<a name="ln1460"> </a>
<a name="ln1461">            case ElementType::CLEF:</a>
<a name="ln1462">                  score()-&gt;undoChangeClef(staff, this, toClef(e)-&gt;clefType());</a>
<a name="ln1463">                  delete e;</a>
<a name="ln1464">                  break;</a>
<a name="ln1465"> </a>
<a name="ln1466">            case ElementType::KEYSIG:</a>
<a name="ln1467">                  {</a>
<a name="ln1468">                  KeySigEvent k = toKeySig(e)-&gt;keySigEvent();</a>
<a name="ln1469">                  delete e;</a>
<a name="ln1470"> </a>
<a name="ln1471">                  if (data.modifiers &amp; Qt::ControlModifier) {</a>
<a name="ln1472">                        // apply only to this stave</a>
<a name="ln1473">                        score()-&gt;undoChangeKeySig(staff, tick(), k);</a>
<a name="ln1474">                        }</a>
<a name="ln1475">                  else {</a>
<a name="ln1476">                        // apply to all staves:</a>
<a name="ln1477">                        for (Staff* s : score()-&gt;staves())</a>
<a name="ln1478">                              score()-&gt;undoChangeKeySig(s, tick(), k);</a>
<a name="ln1479">                        }</a>
<a name="ln1480"> </a>
<a name="ln1481">                  break;</a>
<a name="ln1482">                  }</a>
<a name="ln1483"> </a>
<a name="ln1484">            case ElementType::TIMESIG:</a>
<a name="ln1485">                  score()-&gt;cmdAddTimeSig(this, staffIdx, toTimeSig(e), data.modifiers &amp; Qt::ControlModifier);</a>
<a name="ln1486">                  return 0;</a>
<a name="ln1487"> </a>
<a name="ln1488">            case ElementType::LAYOUT_BREAK: {</a>
<a name="ln1489">                  LayoutBreak* b = toLayoutBreak(e);</a>
<a name="ln1490">                  Measure* measure = isMMRest() ? mmRestLast() : this;</a>
<a name="ln1491">                  switch (b-&gt;layoutBreakType()) {</a>
<a name="ln1492">                        case  LayoutBreak::PAGE:</a>
<a name="ln1493">                              if (measure-&gt;pageBreak()) {</a>
<a name="ln1494">                                    delete b;</a>
<a name="ln1495">                                    b = 0;</a>
<a name="ln1496">                                    }</a>
<a name="ln1497">                              else</a>
<a name="ln1498">                                    measure-&gt;setLineBreak(false);</a>
<a name="ln1499">                              break;</a>
<a name="ln1500">                        case  LayoutBreak::LINE:</a>
<a name="ln1501">                              if (measure-&gt;lineBreak()) {</a>
<a name="ln1502">                                    delete b;</a>
<a name="ln1503">                                    b = 0;</a>
<a name="ln1504">                                    }</a>
<a name="ln1505">                              else</a>
<a name="ln1506">                                    measure-&gt;setPageBreak(false);</a>
<a name="ln1507">                              break;</a>
<a name="ln1508">                        case  LayoutBreak::SECTION:</a>
<a name="ln1509">                              if (measure-&gt;sectionBreak()) {</a>
<a name="ln1510">                                    delete b;</a>
<a name="ln1511">                                    b = 0;</a>
<a name="ln1512">                                    }</a>
<a name="ln1513">                              else</a>
<a name="ln1514">                                    measure-&gt;setLineBreak(false);</a>
<a name="ln1515">                              break;</a>
<a name="ln1516">                        case LayoutBreak::NOBREAK:</a>
<a name="ln1517">                              if (measure-&gt;noBreak()) {</a>
<a name="ln1518">                                    delete b;</a>
<a name="ln1519">                                    b = 0;</a>
<a name="ln1520">                                    }</a>
<a name="ln1521">                              else {</a>
<a name="ln1522">                                    measure-&gt;setLineBreak(false);</a>
<a name="ln1523">                                    measure-&gt;setPageBreak(false);</a>
<a name="ln1524">                                    }</a>
<a name="ln1525">                              break;</a>
<a name="ln1526">                        }</a>
<a name="ln1527">                  if (b) {</a>
<a name="ln1528">                        b-&gt;setTrack(-1);       // these are system elements</a>
<a name="ln1529">                        b-&gt;setParent(measure);</a>
<a name="ln1530">                        score()-&gt;undoAddElement(b);</a>
<a name="ln1531">                        }</a>
<a name="ln1532">                  measure-&gt;cleanupLayoutBreaks(true);</a>
<a name="ln1533">                  return b;</a>
<a name="ln1534">                  }</a>
<a name="ln1535"> </a>
<a name="ln1536">            case ElementType::SPACER:</a>
<a name="ln1537">                  {</a>
<a name="ln1538">                  Spacer* spacer = toSpacer(e);</a>
<a name="ln1539">                  spacer-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1540">                  spacer-&gt;setParent(this);</a>
<a name="ln1541">                  if (spacer-&gt;spacerType() == SpacerType::FIXED) {</a>
<a name="ln1542">                        qreal gap = spatium() * 10;</a>
<a name="ln1543">                        System* s = system();</a>
<a name="ln1544">                        const int nextVisStaffIdx = s-&gt;nextVisibleStaff(staffIdx);</a>
<a name="ln1545">                        const bool systemEnd = (nextVisStaffIdx == score()-&gt;nstaves());</a>
<a name="ln1546">                        if (systemEnd) {</a>
<a name="ln1547">                              System* ns = 0;</a>
<a name="ln1548">                              for (System* ts : score()-&gt;systems()) {</a>
<a name="ln1549">                                    if (ns) {</a>
<a name="ln1550">                                          ns = ts;</a>
<a name="ln1551">                                          break;</a>
<a name="ln1552">                                          }</a>
<a name="ln1553">                                    if (ts  == s)</a>
<a name="ln1554">                                          ns = ts;</a>
<a name="ln1555">                                    }</a>
<a name="ln1556">                              if (ns &amp;&amp; ns-&gt;page() == s-&gt;page()) {</a>
<a name="ln1557">                                    qreal y1 = s-&gt;staffYpage(staffIdx);</a>
<a name="ln1558">                                    qreal y2 = ns-&gt;staffYpage(0);</a>
<a name="ln1559">                                    gap = y2 - y1 - score()-&gt;staff(staffIdx)-&gt;height();</a>
<a name="ln1560">                                    }</a>
<a name="ln1561">                              }</a>
<a name="ln1562">                        else {</a>
<a name="ln1563">                              qreal y1 = s-&gt;staffYpage(staffIdx);</a>
<a name="ln1564">                              qreal y2 = s-&gt;staffYpage(nextVisStaffIdx);</a>
<a name="ln1565">                              gap = y2 - y1 - score()-&gt;staff(staffIdx)-&gt;height();</a>
<a name="ln1566">                              }</a>
<a name="ln1567">                        spacer-&gt;setGap(gap);</a>
<a name="ln1568">                        }</a>
<a name="ln1569">                  score()-&gt;undoAddElement(spacer);</a>
<a name="ln1570">                  triggerLayout();</a>
<a name="ln1571">                  return spacer;</a>
<a name="ln1572">                  }</a>
<a name="ln1573"> </a>
<a name="ln1574">            case ElementType::BAR_LINE:</a>
<a name="ln1575">                  {</a>
<a name="ln1576">                  BarLine* bl = toBarLine(e);</a>
<a name="ln1577"> </a>
<a name="ln1578">                  // if dropped bar line refers to span rather than to subtype</a>
<a name="ln1579">                  // or if Ctrl key used</a>
<a name="ln1580">                  if ((bl-&gt;spanFrom() &amp;&amp; bl-&gt;spanTo()) || data.control()) {</a>
<a name="ln1581">                        // get existing bar line for this staff, and drop the change to it</a>
<a name="ln1582">                        seg = undoGetSegmentR(SegmentType::EndBarLine, ticks());</a>
<a name="ln1583">                        BarLine* cbl = toBarLine(seg-&gt;element(staffIdx * VOICES));</a>
<a name="ln1584">                        if (cbl)</a>
<a name="ln1585">                              cbl-&gt;drop(data);</a>
<a name="ln1586">                        }</a>
<a name="ln1587">                  else if (bl-&gt;barLineType() == BarLineType::START_REPEAT) {</a>
<a name="ln1588">                        Measure* m2 = isMMRest() ? mmRestFirst() : this;</a>
<a name="ln1589">                        for (Score* lscore : score()-&gt;scoreList()) {</a>
<a name="ln1590">                              Measure* lmeasure = lscore-&gt;tick2measure(m2-&gt;tick());</a>
<a name="ln1591">                              if (lmeasure)</a>
<a name="ln1592">                                    lmeasure-&gt;undoChangeProperty(Pid::REPEAT_START, true);</a>
<a name="ln1593">                              }</a>
<a name="ln1594">                        }</a>
<a name="ln1595">                  else if (bl-&gt;barLineType() == BarLineType::END_REPEAT) {</a>
<a name="ln1596">                        Measure* m2 = isMMRest() ? mmRestLast() : this;</a>
<a name="ln1597">                        for (Score* lscore : score()-&gt;scoreList()) {</a>
<a name="ln1598">                              Measure* lmeasure = lscore-&gt;tick2measure(m2-&gt;tick());</a>
<a name="ln1599">                              if (lmeasure)</a>
<a name="ln1600">                                    lmeasure-&gt;undoChangeProperty(Pid::REPEAT_END, true);</a>
<a name="ln1601">                              }</a>
<a name="ln1602">                        }</a>
<a name="ln1603">                  else if (bl-&gt;barLineType() == BarLineType::END_START_REPEAT) {</a>
<a name="ln1604">                        Measure* m2 = isMMRest() ? mmRestLast() : this;</a>
<a name="ln1605">                        for (Score* lscore : score()-&gt;scoreList()) {</a>
<a name="ln1606">                              Measure* lmeasure = lscore-&gt;tick2measure(m2-&gt;tick());</a>
<a name="ln1607">                              if (lmeasure) {</a>
<a name="ln1608">                                    lmeasure-&gt;undoChangeProperty(Pid::REPEAT_END, true);</a>
<a name="ln1609">                                    lmeasure = lmeasure-&gt;nextMeasure();</a>
<a name="ln1610">                                    if (lmeasure)</a>
<a name="ln1611">                                          lmeasure-&gt;undoChangeProperty(Pid::REPEAT_START, true);</a>
<a name="ln1612">                                    }</a>
<a name="ln1613">                              }</a>
<a name="ln1614">                        }</a>
<a name="ln1615">                  else {</a>
<a name="ln1616">                        // drop to first end barline</a>
<a name="ln1617">                        seg = findSegmentR(SegmentType::EndBarLine, ticks());</a>
<a name="ln1618">                        if (seg) {</a>
<a name="ln1619">                              for (Element* ee : seg-&gt;elist()) {</a>
<a name="ln1620">                                    if (ee) {</a>
<a name="ln1621">                                          ee-&gt;drop(data);</a>
<a name="ln1622">                                          break;</a>
<a name="ln1623">                                          }</a>
<a name="ln1624">                                    }</a>
<a name="ln1625">                              }</a>
<a name="ln1626">                        else</a>
<a name="ln1627">                              delete e;</a>
<a name="ln1628">                        }</a>
<a name="ln1629">                  break;</a>
<a name="ln1630">                  }</a>
<a name="ln1631"> </a>
<a name="ln1632">            case ElementType::REPEAT_MEASURE:</a>
<a name="ln1633">                  {</a>
<a name="ln1634">                  delete e;</a>
<a name="ln1635">                  return cmdInsertRepeatMeasure(staffIdx);</a>
<a name="ln1636">                  }</a>
<a name="ln1637">            case ElementType::ICON:</a>
<a name="ln1638">                  switch(toIcon(e)-&gt;iconType()) {</a>
<a name="ln1639">                        case IconType::VFRAME:</a>
<a name="ln1640">                              score()-&gt;insertMeasure(ElementType::VBOX, this);</a>
<a name="ln1641">                              break;</a>
<a name="ln1642">                        case IconType::HFRAME:</a>
<a name="ln1643">                              score()-&gt;insertMeasure(ElementType::HBOX, this);</a>
<a name="ln1644">                              break;</a>
<a name="ln1645">                        case IconType::TFRAME:</a>
<a name="ln1646">                              score()-&gt;insertMeasure(ElementType::TBOX, this);</a>
<a name="ln1647">                              break;</a>
<a name="ln1648">                        case IconType::FFRAME:</a>
<a name="ln1649">                              score()-&gt;insertMeasure(ElementType::FBOX, this);</a>
<a name="ln1650">                              break;</a>
<a name="ln1651">                        case IconType::MEASURE:</a>
<a name="ln1652">                              score()-&gt;insertMeasure(ElementType::MEASURE, this);</a>
<a name="ln1653">                              break;</a>
<a name="ln1654">                        default:</a>
<a name="ln1655">                              break;</a>
<a name="ln1656">                        }</a>
<a name="ln1657">                  break;</a>
<a name="ln1658"> </a>
<a name="ln1659">            case ElementType::STAFFTYPE_CHANGE:</a>
<a name="ln1660">                  {</a>
<a name="ln1661">                  e-&gt;setParent(this);</a>
<a name="ln1662">                  e-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1663">                  score()-&gt;undoAddElement(e);</a>
<a name="ln1664">                  }</a>
<a name="ln1665">                  break;</a>
<a name="ln1666"> </a>
<a name="ln1667">            default:</a>
<a name="ln1668">                  qDebug(&quot;Measure: cannot drop %s here&quot;, e-&gt;name());</a>
<a name="ln1669">                  delete e;</a>
<a name="ln1670">                  break;</a>
<a name="ln1671">            }</a>
<a name="ln1672">      return 0;</a>
<a name="ln1673">      }</a>
<a name="ln1674"> </a>
<a name="ln1675">//---------------------------------------------------------</a>
<a name="ln1676">//   cmdInsertRepeatMeasure</a>
<a name="ln1677">//---------------------------------------------------------</a>
<a name="ln1678"> </a>
<a name="ln1679">RepeatMeasure* Measure::cmdInsertRepeatMeasure(int staffIdx)</a>
<a name="ln1680">      {</a>
<a name="ln1681">      //</a>
<a name="ln1682">      // see also cmdDeleteSelection()</a>
<a name="ln1683">      //</a>
<a name="ln1684">      score()-&gt;select(0, SelectType::SINGLE, 0);</a>
<a name="ln1685">      for (Segment* s = first(); s; s = s-&gt;next()) {</a>
<a name="ln1686">            if (s-&gt;segmentType() &amp; SegmentType::ChordRest) {</a>
<a name="ln1687">                  int strack = staffIdx * VOICES;</a>
<a name="ln1688">                  int etrack = strack + VOICES;</a>
<a name="ln1689">                  for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln1690">                        Element* el = s-&gt;element(track);</a>
<a name="ln1691">                        if (el)</a>
<a name="ln1692">                              score()-&gt;undoRemoveElement(el);</a>
<a name="ln1693">                        }</a>
<a name="ln1694">                  }</a>
<a name="ln1695">            }</a>
<a name="ln1696">      //</a>
<a name="ln1697">      // add repeat measure</a>
<a name="ln1698">      //</a>
<a name="ln1699">      Segment* seg = undoGetSegment(SegmentType::ChordRest, tick());</a>
<a name="ln1700">      RepeatMeasure* rm = new RepeatMeasure(score());</a>
<a name="ln1701">      rm-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1702">      rm-&gt;setParent(seg);</a>
<a name="ln1703">      rm-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln1704">      rm-&gt;setTicks(stretchedLen(score()-&gt;staff(staffIdx)));</a>
<a name="ln1705">      score()-&gt;undoAddCR(rm, this, tick());</a>
<a name="ln1706">      for (Element* e : el()) {</a>
<a name="ln1707">            if (e-&gt;isSlur() &amp;&amp; e-&gt;staffIdx() == staffIdx)</a>
<a name="ln1708">                  score()-&gt;undoRemoveElement(e);</a>
<a name="ln1709">            }</a>
<a name="ln1710">      return rm;</a>
<a name="ln1711">      }</a>
<a name="ln1712"> </a>
<a name="ln1713">//---------------------------------------------------------</a>
<a name="ln1714">//   adjustToLen</a>
<a name="ln1715">//    change actual measure len, adjust elements to</a>
<a name="ln1716">//    new len</a>
<a name="ln1717">//---------------------------------------------------------</a>
<a name="ln1718"> </a>
<a name="ln1719">void Measure::adjustToLen(Fraction nf, bool appendRestsIfNecessary)</a>
<a name="ln1720">      {</a>
<a name="ln1721">      Fraction ol   = ticks();</a>
<a name="ln1722">      Fraction nl   = nf;</a>
<a name="ln1723">      Fraction diff = nl - ol;</a>
<a name="ln1724"> </a>
<a name="ln1725">      Fraction startTick = endTick();</a>
<a name="ln1726">      if (diff &lt; Fraction(0,1))</a>
<a name="ln1727">            startTick += diff;</a>
<a name="ln1728"> </a>
<a name="ln1729">      score()-&gt;undoInsertTime(startTick, diff);</a>
<a name="ln1730">      score()-&gt;undo(new InsertTime(score(), startTick, diff));</a>
<a name="ln1731"> </a>
<a name="ln1732">      for (Score* s : score()-&gt;scoreList()) {</a>
<a name="ln1733">            Measure* m = s-&gt;tick2measure(tick());</a>
<a name="ln1734">            s-&gt;undo(new ChangeMeasureLen(m, nf));</a>
<a name="ln1735">            if (nl &gt; ol) {</a>
<a name="ln1736">                  // move EndBarLine, TimeSigAnnounce, KeySigAnnounce</a>
<a name="ln1737">                  for (Segment* seg = m-&gt;first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln1738">                        if (seg-&gt;segmentType() &amp; (SegmentType::EndBarLine|SegmentType::TimeSigAnnounce|SegmentType::KeySigAnnounce)) {</a>
<a name="ln1739">                              seg-&gt;setRtick(nl);</a>
<a name="ln1740">                              }</a>
<a name="ln1741">                        }</a>
<a name="ln1742">                  }</a>
<a name="ln1743">            }</a>
<a name="ln1744">      Score* s      = score()-&gt;masterScore();</a>
<a name="ln1745">      Measure* m    = s-&gt;tick2measure(tick());</a>
<a name="ln1746">      QList&lt;int&gt; sl = s-&gt;uniqueStaves();</a>
<a name="ln1747"> </a>
<a name="ln1748">      for (int staffIdx : sl) {</a>
<a name="ln1749">            int rests  = 0;</a>
<a name="ln1750">            int chords = 0;</a>
<a name="ln1751">            Rest* rest = 0;</a>
<a name="ln1752">            for (Segment* segment = m-&gt;first(); segment; segment = segment-&gt;next()) {</a>
<a name="ln1753">                  int strack = staffIdx * VOICES;</a>
<a name="ln1754">                  int etrack = strack + VOICES;</a>
<a name="ln1755">                  for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln1756">                        Element* e = segment-&gt;element(track);</a>
<a name="ln1757">                        if (e) {</a>
<a name="ln1758">                              if (e-&gt;isRest()) {</a>
<a name="ln1759">                                    ++rests;</a>
<a name="ln1760">                                    rest = toRest(e);</a>
<a name="ln1761">                                    }</a>
<a name="ln1762">                              else if (e-&gt;isChord())</a>
<a name="ln1763">                                    ++chords;</a>
<a name="ln1764">                              }</a>
<a name="ln1765">                        }</a>
<a name="ln1766">                  }</a>
<a name="ln1767">            Fraction stretch = s-&gt;staff(staffIdx)-&gt;timeStretch(tick());</a>
<a name="ln1768">            // if just a single rest</a>
<a name="ln1769">            if (rests == 1 &amp;&amp; chords == 0) {</a>
<a name="ln1770">                  // if measure value didn't change, stick to whole measure rest</a>
<a name="ln1771">                  if (_timesig == nf) {</a>
<a name="ln1772">                        rest-&gt;undoChangeProperty(Pid::DURATION, QVariant::fromValue&lt;Fraction&gt;(nf * stretch));</a>
<a name="ln1773">                        rest-&gt;undoChangeProperty(Pid::DURATION_TYPE, QVariant::fromValue&lt;TDuration&gt;(TDuration::DurationType::V_MEASURE));</a>
<a name="ln1774">                        }</a>
<a name="ln1775">                  else {      // if measure value did change, represent with rests actual measure value</a>
<a name="ln1776">#if 0</a>
<a name="ln1777">                        // any reason not to do this instead?</a>
<a name="ln1778">                        s-&gt;undoRemoveElement(rest);</a>
<a name="ln1779">                        s-&gt;setRest(tick(), staffIdx * VOICES, nf * stretch, false, 0, false);</a>
<a name="ln1780">#else</a>
<a name="ln1781">                        // convert the measure duration in a list of values (no dots for rests)</a>
<a name="ln1782">                        std::vector&lt;TDuration&gt; durList = toDurationList(nf * stretch, false, 0);</a>
<a name="ln1783"> </a>
<a name="ln1784">                        // set the existing rest to the first value of the duration list</a>
<a name="ln1785">                        for (ScoreElement* e : rest-&gt;linkList()) {</a>
<a name="ln1786">                              e-&gt;undoChangeProperty(Pid::DURATION, QVariant::fromValue&lt;Fraction&gt;(durList[0].fraction()));</a>
<a name="ln1787">                              e-&gt;undoChangeProperty(Pid::DURATION_TYPE, QVariant::fromValue&lt;TDuration&gt;(durList[0]));</a>
<a name="ln1788">                              }</a>
<a name="ln1789"> </a>
<a name="ln1790">                        // add rests for any other duration list value</a>
<a name="ln1791">                        Fraction tickOffset = tick() + rest-&gt;actualTicks();</a>
<a name="ln1792">                        for (unsigned i = 1; i &lt; durList.size(); i++) {</a>
<a name="ln1793">                              Rest* newRest = new Rest(s);</a>
<a name="ln1794">                              newRest-&gt;setDurationType(durList.at(i));</a>
<a name="ln1795">                              newRest-&gt;setTicks(durList.at(i).fraction());</a>
<a name="ln1796">                              newRest-&gt;setTrack(rest-&gt;track());</a>
<a name="ln1797">                              score()-&gt;undoAddCR(newRest, this, tickOffset);</a>
<a name="ln1798">                              tickOffset += newRest-&gt;actualTicks();</a>
<a name="ln1799">                              }</a>
<a name="ln1800">#endif</a>
<a name="ln1801">                        }</a>
<a name="ln1802">                  continue;</a>
<a name="ln1803">                  }</a>
<a name="ln1804"> </a>
<a name="ln1805">            int strack = staffIdx * VOICES;</a>
<a name="ln1806">            int etrack = strack + VOICES;</a>
<a name="ln1807"> </a>
<a name="ln1808">            for (int trk = strack; trk &lt; etrack; ++trk) {</a>
<a name="ln1809">                  Fraction n = diff;</a>
<a name="ln1810">                  bool rFlag = false;</a>
<a name="ln1811">                  if (n &lt; Fraction(0,1))  {</a>
<a name="ln1812">                        for (Segment* segment = m-&gt;last(); segment;) {</a>
<a name="ln1813">                              Segment* pseg = segment-&gt;prev();</a>
<a name="ln1814">                              if (segment-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln1815">                                    for (Element* a : segment-&gt;annotations())</a>
<a name="ln1816">                                          if (a-&gt;track() == trk)</a>
<a name="ln1817">                                                s-&gt;undoRemoveElement(a);</a>
<a name="ln1818">                                    Element* e = segment-&gt;element(trk);</a>
<a name="ln1819">                                    if (e &amp;&amp; e-&gt;isChordRest()) {</a>
<a name="ln1820">                                          ChordRest* cr = toChordRest(e);</a>
<a name="ln1821">                                          if (cr-&gt;durationType() == TDuration::DurationType::V_MEASURE) {</a>
<a name="ln1822">                                                Fraction actualTicks = cr-&gt;actualTicks();</a>
<a name="ln1823">                                                n += actualTicks;</a>
<a name="ln1824">                                                cr-&gt;setDurationType(TDuration(actualTicks));</a>
<a name="ln1825">                                                }</a>
<a name="ln1826">                                          else</a>
<a name="ln1827">                                                n += cr-&gt;actualTicks();</a>
<a name="ln1828">                                          s-&gt;undoRemoveElement(e);</a>
<a name="ln1829">                                          if (n &gt;= Fraction(0,1))</a>
<a name="ln1830">                                                break;</a>
<a name="ln1831">                                          }</a>
<a name="ln1832">                                    }</a>
<a name="ln1833">                              else if (segment-&gt;segmentType() == SegmentType::Breath) {</a>
<a name="ln1834">                                    Element* e = segment-&gt;element(trk);</a>
<a name="ln1835">                                    if (e)</a>
<a name="ln1836">                                          s-&gt;undoRemoveElement(e);</a>
<a name="ln1837">                                    }</a>
<a name="ln1838">                              segment = pseg;</a>
<a name="ln1839">                              }</a>
<a name="ln1840">                        rFlag = true;</a>
<a name="ln1841">                        }</a>
<a name="ln1842">                  int voice = trk % VOICES;</a>
<a name="ln1843">                  if (appendRestsIfNecessary &amp;&amp; (n &gt; Fraction(0,1)) &amp;&amp; (rFlag || voice == 0)) {</a>
<a name="ln1844">                        // add rest to measure</a>
<a name="ln1845">                        Fraction rtick = tick() + nl - n;</a>
<a name="ln1846">                        int track = staffIdx * VOICES + voice;</a>
<a name="ln1847">                        s-&gt;setRest(rtick, track, n * stretch, false, 0, false);</a>
<a name="ln1848">                        }</a>
<a name="ln1849">                  }</a>
<a name="ln1850">            }</a>
<a name="ln1851">      if (diff &lt; Fraction(0,1)) {</a>
<a name="ln1852">            //</a>
<a name="ln1853">            //  CHECK: do not remove all slurs</a>
<a name="ln1854">            //</a>
<a name="ln1855">            foreach (Element* e, m-&gt;el()) {</a>
<a name="ln1856">                  if (e-&gt;isSlur())</a>
<a name="ln1857">                        s-&gt;undoRemoveElement(e);</a>
<a name="ln1858">                  }</a>
<a name="ln1859">            }</a>
<a name="ln1860">      }</a>
<a name="ln1861"> </a>
<a name="ln1862">//---------------------------------------------------------</a>
<a name="ln1863">//   write</a>
<a name="ln1864">//---------------------------------------------------------</a>
<a name="ln1865"> </a>
<a name="ln1866">void Measure::write(XmlWriter&amp; xml, int staff, bool writeSystemElements, bool forceTimeSig) const</a>
<a name="ln1867">      {</a>
<a name="ln1868">      if (MScore::debugMode) {</a>
<a name="ln1869">            const int mno = no() + 1;</a>
<a name="ln1870">            xml.comment(QString(&quot;Measure %1&quot;).arg(mno));</a>
<a name="ln1871">            }</a>
<a name="ln1872">      if (_len != _timesig) {</a>
<a name="ln1873">            // this is an irregular measure</a>
<a name="ln1874">            xml.stag(this, QString(&quot;len=\&quot;%1/%2\&quot;&quot;).arg(_len.numerator()).arg(_len.denominator()));</a>
<a name="ln1875">            }</a>
<a name="ln1876">      else</a>
<a name="ln1877">            xml.stag(this);</a>
<a name="ln1878"> </a>
<a name="ln1879">      xml.setCurTick(tick());</a>
<a name="ln1880">      xml.setCurTrack(staff * VOICES);</a>
<a name="ln1881"> </a>
<a name="ln1882">      if (_mmRestCount &gt; 0)</a>
<a name="ln1883">            xml.tag(&quot;multiMeasureRest&quot;, _mmRestCount);</a>
<a name="ln1884">      if (writeSystemElements) {</a>
<a name="ln1885">            if (repeatStart())</a>
<a name="ln1886">                  xml.tagE(&quot;startRepeat&quot;);</a>
<a name="ln1887">            if (repeatEnd())</a>
<a name="ln1888">                  xml.tag(&quot;endRepeat&quot;, _repeatCount);</a>
<a name="ln1889">            writeProperty(xml, Pid::IRREGULAR);</a>
<a name="ln1890">            writeProperty(xml, Pid::BREAK_MMR);</a>
<a name="ln1891">            writeProperty(xml, Pid::USER_STRETCH);</a>
<a name="ln1892">            writeProperty(xml, Pid::NO_OFFSET);</a>
<a name="ln1893">            writeProperty(xml, Pid::MEASURE_NUMBER_MODE);</a>
<a name="ln1894">            }</a>
<a name="ln1895">      qreal _spatium = spatium();</a>
<a name="ln1896">      MStaff* mstaff = _mstaves[staff];</a>
<a name="ln1897">      if (mstaff-&gt;noText() &amp;&amp; !mstaff-&gt;noText()-&gt;generated()) {</a>
<a name="ln1898">            xml.stag(&quot;MeasureNumber&quot;, mstaff-&gt;noText());</a>
<a name="ln1899">            mstaff-&gt;noText()-&gt;writeProperties(xml);</a>
<a name="ln1900">            xml.etag();</a>
<a name="ln1901">            }</a>
<a name="ln1902"> </a>
<a name="ln1903">      if (mstaff-&gt;vspacerUp())</a>
<a name="ln1904">            xml.tag(&quot;vspacerUp&quot;, mstaff-&gt;vspacerUp()-&gt;gap() / _spatium);</a>
<a name="ln1905">      if (mstaff-&gt;vspacerDown()) {</a>
<a name="ln1906">            if (mstaff-&gt;vspacerDown()-&gt;spacerType() == SpacerType::FIXED)</a>
<a name="ln1907">                  xml.tag(&quot;vspacerFixed&quot;, mstaff-&gt;vspacerDown()-&gt;gap() / _spatium);</a>
<a name="ln1908">            else</a>
<a name="ln1909">                  xml.tag(&quot;vspacerDown&quot;, mstaff-&gt;vspacerDown()-&gt;gap() / _spatium);</a>
<a name="ln1910">            }</a>
<a name="ln1911">      if (!mstaff-&gt;visible())</a>
<a name="ln1912">            xml.tag(&quot;visible&quot;, mstaff-&gt;visible());</a>
<a name="ln1913">      if (mstaff-&gt;stemless()) {</a>
<a name="ln1914">            xml.tag(&quot;slashStyle&quot;, mstaff-&gt;stemless()); // for backwards compatibility</a>
<a name="ln1915">            xml.tag(&quot;stemless&quot;, mstaff-&gt;stemless());</a>
<a name="ln1916">            }</a>
<a name="ln1917"> </a>
<a name="ln1918">      int strack = staff * VOICES;</a>
<a name="ln1919">      int etrack = strack + VOICES;</a>
<a name="ln1920">      for (const Element* e : el()) {</a>
<a name="ln1921">            if (!e-&gt;generated() &amp;&amp; ((e-&gt;staffIdx() == staff) || (e-&gt;systemFlag() &amp;&amp; writeSystemElements)))</a>
<a name="ln1922">                  e-&gt;write(xml);</a>
<a name="ln1923">            }</a>
<a name="ln1924">      Q_ASSERT(first());</a>
<a name="ln1925">      Q_ASSERT(last());</a>
<a name="ln1926">      score()-&gt;writeSegments(xml, strack, etrack, first(), last()-&gt;next1(), writeSystemElements, forceTimeSig);</a>
<a name="ln1927">      xml.etag();</a>
<a name="ln1928">      }</a>
<a name="ln1929"> </a>
<a name="ln1930">//---------------------------------------------------------</a>
<a name="ln1931">//   Measure::read</a>
<a name="ln1932">//---------------------------------------------------------</a>
<a name="ln1933"> </a>
<a name="ln1934">void Measure::read(XmlReader&amp; e, int staffIdx)</a>
<a name="ln1935">      {</a>
<a name="ln1936">      qreal _spatium = spatium();</a>
<a name="ln1937">      e.setCurrentMeasure(this);</a>
<a name="ln1938">      int nextTrack = staffIdx * VOICES;</a>
<a name="ln1939">      e.setTrack(nextTrack);</a>
<a name="ln1940"> </a>
<a name="ln1941">      for (int n = int(_mstaves.size()); n &lt;= staffIdx; ++n) {</a>
<a name="ln1942">            Staff* staff = score()-&gt;staff(n);</a>
<a name="ln1943">            MStaff* s    = new MStaff;</a>
<a name="ln1944">            s-&gt;setLines(new StaffLines(score()));</a>
<a name="ln1945">            s-&gt;lines()-&gt;setParent(this);</a>
<a name="ln1946">            s-&gt;lines()-&gt;setTrack(n * VOICES);</a>
<a name="ln1947">            s-&gt;lines()-&gt;setVisible(!staff-&gt;invisible());</a>
<a name="ln1948">            _mstaves.push_back(s);</a>
<a name="ln1949">            }</a>
<a name="ln1950"> </a>
<a name="ln1951">      bool irregular;</a>
<a name="ln1952">      if (e.hasAttribute(&quot;len&quot;)) {</a>
<a name="ln1953">            QStringList sl = e.attribute(&quot;len&quot;).split('/');</a>
<a name="ln1954">            if (sl.size() == 2)</a>
<a name="ln1955">                  _len = Fraction(sl[0].toInt(), sl[1].toInt());</a>
<a name="ln1956">            else</a>
<a name="ln1957">                  qDebug(&quot;illegal measure size &lt;%s&gt;&quot;, qPrintable(e.attribute(&quot;len&quot;)));</a>
<a name="ln1958">            irregular = true;</a>
<a name="ln1959">            score()-&gt;sigmap()-&gt;add(tick().ticks(), SigEvent(_len, _timesig));</a>
<a name="ln1960">            score()-&gt;sigmap()-&gt;add((tick() + ticks()).ticks(), SigEvent(_timesig));</a>
<a name="ln1961">            }</a>
<a name="ln1962">      else</a>
<a name="ln1963">            irregular = false;</a>
<a name="ln1964"> </a>
<a name="ln1965">      while (e.readNextStartElement()) {</a>
<a name="ln1966">            const QStringRef&amp; tag(e.name());</a>
<a name="ln1967"> </a>
<a name="ln1968">            if (tag == &quot;voice&quot;) {</a>
<a name="ln1969">                  e.setTrack(nextTrack++);</a>
<a name="ln1970">                  e.setTick(tick());</a>
<a name="ln1971">                  readVoice(e, staffIdx, irregular);</a>
<a name="ln1972">                  }</a>
<a name="ln1973">            else if (tag == &quot;Marker&quot; || tag == &quot;Jump&quot;) {</a>
<a name="ln1974">                  Element* el = Element::name2Element(tag, score());</a>
<a name="ln1975">                  el-&gt;setTrack(e.track());</a>
<a name="ln1976">                  el-&gt;read(e);</a>
<a name="ln1977">                  add(el);</a>
<a name="ln1978">                  }</a>
<a name="ln1979">            else if (tag == &quot;stretch&quot;) {</a>
<a name="ln1980">                  double val = e.readDouble();</a>
<a name="ln1981">                  if (val &lt; 0.0)</a>
<a name="ln1982">                        val = 0;</a>
<a name="ln1983">                  setUserStretch(val);</a>
<a name="ln1984">                  }</a>
<a name="ln1985">            else if (tag == &quot;noOffset&quot;)</a>
<a name="ln1986">                  setNoOffset(e.readInt());</a>
<a name="ln1987">            else if (tag == &quot;measureNumberMode&quot;)</a>
<a name="ln1988">                  setMeasureNumberMode(MeasureNumberMode(e.readInt()));</a>
<a name="ln1989">            else if (tag == &quot;irregular&quot;)</a>
<a name="ln1990">                  setIrregular(e.readBool());</a>
<a name="ln1991">            else if (tag == &quot;breakMultiMeasureRest&quot;)</a>
<a name="ln1992">                  _breakMultiMeasureRest = e.readBool();</a>
<a name="ln1993">            else if (tag == &quot;startRepeat&quot;) {</a>
<a name="ln1994">                  setRepeatStart(true);</a>
<a name="ln1995">                  e.readNext();</a>
<a name="ln1996">                  }</a>
<a name="ln1997">            else if (tag == &quot;endRepeat&quot;) {</a>
<a name="ln1998">                  _repeatCount = e.readInt();</a>
<a name="ln1999">                  setRepeatEnd(true);</a>
<a name="ln2000">                  }</a>
<a name="ln2001">            else if (tag == &quot;vspacer&quot; || tag == &quot;vspacerDown&quot;) {</a>
<a name="ln2002">                  if (!_mstaves[staffIdx]-&gt;vspacerDown()) {</a>
<a name="ln2003">                        Spacer* spacer = new Spacer(score());</a>
<a name="ln2004">                        spacer-&gt;setSpacerType(SpacerType::DOWN);</a>
<a name="ln2005">                        spacer-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2006">                        add(spacer);</a>
<a name="ln2007">                        }</a>
<a name="ln2008">                  _mstaves[staffIdx]-&gt;vspacerDown()-&gt;setGap(e.readDouble() * _spatium);</a>
<a name="ln2009">                  }</a>
<a name="ln2010">            else if (tag == &quot;vspacerFixed&quot;) {</a>
<a name="ln2011">                  if (!_mstaves[staffIdx]-&gt;vspacerDown()) {</a>
<a name="ln2012">                        Spacer* spacer = new Spacer(score());</a>
<a name="ln2013">                        spacer-&gt;setSpacerType(SpacerType::FIXED);</a>
<a name="ln2014">                        spacer-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2015">                        add(spacer);</a>
<a name="ln2016">                        }</a>
<a name="ln2017">                  _mstaves[staffIdx]-&gt;vspacerDown()-&gt;setGap(e.readDouble() * _spatium);</a>
<a name="ln2018">                  }</a>
<a name="ln2019">            else if (tag == &quot;vspacerUp&quot;) {</a>
<a name="ln2020">                  if (!_mstaves[staffIdx]-&gt;vspacerUp()) {</a>
<a name="ln2021">                        Spacer* spacer = new Spacer(score());</a>
<a name="ln2022">                        spacer-&gt;setSpacerType(SpacerType::UP);</a>
<a name="ln2023">                        spacer-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2024">                        add(spacer);</a>
<a name="ln2025">                        }</a>
<a name="ln2026">                  _mstaves[staffIdx]-&gt;vspacerUp()-&gt;setGap(e.readDouble() * _spatium);</a>
<a name="ln2027">                  }</a>
<a name="ln2028">            else if (tag == &quot;visible&quot;)</a>
<a name="ln2029">                  _mstaves[staffIdx]-&gt;setVisible(e.readInt());</a>
<a name="ln2030">            else if ((tag == &quot;slashStyle&quot;) || (tag == &quot;stemless&quot;))</a>
<a name="ln2031">                  _mstaves[staffIdx]-&gt;setStemless(e.readInt());</a>
<a name="ln2032">            else if (tag == &quot;SystemDivider&quot;) {</a>
<a name="ln2033">                  SystemDivider* sd = new SystemDivider(score());</a>
<a name="ln2034">                  sd-&gt;read(e);</a>
<a name="ln2035">                  add(sd);</a>
<a name="ln2036">                  }</a>
<a name="ln2037">            else if (tag == &quot;multiMeasureRest&quot;) {</a>
<a name="ln2038">                  _mmRestCount = e.readInt();</a>
<a name="ln2039">                  // set tick to previous measure</a>
<a name="ln2040">                  setTick(e.lastMeasure()-&gt;tick());</a>
<a name="ln2041">                  e.setTick(e.lastMeasure()-&gt;tick());</a>
<a name="ln2042">                  }</a>
<a name="ln2043">            else if (tag == &quot;MeasureNumber&quot;) {</a>
<a name="ln2044">                  MeasureNumber* noText = new MeasureNumber(score());</a>
<a name="ln2045">                  noText-&gt;read(e);</a>
<a name="ln2046">                  noText-&gt;setTrack(e.track());</a>
<a name="ln2047">                  add(noText);</a>
<a name="ln2048">                  }</a>
<a name="ln2049">            else if (MeasureBase::readProperties(e))</a>
<a name="ln2050">                  ;</a>
<a name="ln2051">            else</a>
<a name="ln2052">                  e.unknown();</a>
<a name="ln2053">            }</a>
<a name="ln2054">      e.checkConnectors();</a>
<a name="ln2055">      if (isMMRest()) {</a>
<a name="ln2056">            Measure* lm = e.lastMeasure();</a>
<a name="ln2057">            e.setTick(lm-&gt;tick() + lm-&gt;ticks());</a>
<a name="ln2058">            }</a>
<a name="ln2059">      e.setCurrentMeasure(nullptr);</a>
<a name="ln2060"> </a>
<a name="ln2061">      connectTremolo();</a>
<a name="ln2062">      }</a>
<a name="ln2063"> </a>
<a name="ln2064">//---------------------------------------------------------</a>
<a name="ln2065">//   Measure::readVoice</a>
<a name="ln2066">//---------------------------------------------------------</a>
<a name="ln2067"> </a>
<a name="ln2068">void Measure::readVoice(XmlReader&amp; e, int staffIdx, bool irregular)</a>
<a name="ln2069">      {</a>
<a name="ln2070">      Segment* segment = nullptr;</a>
<a name="ln2071">      QList&lt;Chord*&gt; graceNotes;</a>
<a name="ln2072">      Beam* startingBeam = nullptr;</a>
<a name="ln2073">      Tuplet* tuplet = nullptr;</a>
<a name="ln2074">      Fermata* fermata = nullptr;</a>
<a name="ln2075"> </a>
<a name="ln2076">      Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln2077">      Fraction timeStretch(staff-&gt;timeStretch(tick()));</a>
<a name="ln2078"> </a>
<a name="ln2079">      while (e.readNextStartElement()) {</a>
<a name="ln2080">            const QStringRef&amp; tag(e.name());</a>
<a name="ln2081"> </a>
<a name="ln2082">            if (tag == &quot;location&quot;) {</a>
<a name="ln2083">                  Location loc = Location::relative();</a>
<a name="ln2084">                  loc.read(e);</a>
<a name="ln2085">                  e.setLocation(loc);</a>
<a name="ln2086">                  }</a>
<a name="ln2087">            else if (tag == &quot;tick&quot;) {           // obsolete?</a>
<a name="ln2088">                  qDebug(&quot;read midi tick&quot;);</a>
<a name="ln2089">                  e.setTick(Fraction::fromTicks(score()-&gt;fileDivision(e.readInt())));</a>
<a name="ln2090">                  }</a>
<a name="ln2091">            else if (tag == &quot;BarLine&quot;) {</a>
<a name="ln2092">                  BarLine* barLine = new BarLine(score());</a>
<a name="ln2093">                  barLine-&gt;setTrack(e.track());</a>
<a name="ln2094">                  barLine-&gt;read(e);</a>
<a name="ln2095">                  //</a>
<a name="ln2096">                  //  StartRepeatBarLine: at rtick == 0, always BarLineType::START_REPEAT</a>
<a name="ln2097">                  //  BarLine:            in the middle of a measure, has no semantic</a>
<a name="ln2098">                  //  EndBarLine:         at the end of a measure</a>
<a name="ln2099">                  //  BeginBarLine:       first segment of a measure, systemic barline</a>
<a name="ln2100"> </a>
<a name="ln2101">                  SegmentType st = SegmentType::Invalid;</a>
<a name="ln2102">                  Fraction t = e.tick() - tick();</a>
<a name="ln2103">                  if (t.isNotZero() &amp;&amp; (t != ticks()))</a>
<a name="ln2104">                        st = SegmentType::BarLine;</a>
<a name="ln2105">                  else if (barLine-&gt;barLineType() == BarLineType::START_REPEAT &amp;&amp; t.isZero())</a>
<a name="ln2106">                        st = SegmentType::StartRepeatBarLine;</a>
<a name="ln2107">                  else if (barLine-&gt;barLineType() == BarLineType::START_REPEAT &amp;&amp; t == ticks()) {</a>
<a name="ln2108">                        // old version, ignore</a>
<a name="ln2109">                        delete barLine;</a>
<a name="ln2110">                        barLine = 0;</a>
<a name="ln2111">                        }</a>
<a name="ln2112">                  else if (t.isZero() &amp;&amp; segment == 0)</a>
<a name="ln2113">                        st = SegmentType::BeginBarLine;</a>
<a name="ln2114">                  else</a>
<a name="ln2115">                        st = SegmentType::EndBarLine;</a>
<a name="ln2116">                  if (barLine) {</a>
<a name="ln2117">                        segment = getSegmentR(st, t);</a>
<a name="ln2118">                        segment-&gt;add(barLine);</a>
<a name="ln2119">                        barLine-&gt;layout();</a>
<a name="ln2120">                        }</a>
<a name="ln2121">                  if (fermata) {</a>
<a name="ln2122">                        segment-&gt;add(fermata);</a>
<a name="ln2123">                        fermata = nullptr;</a>
<a name="ln2124">                        }</a>
<a name="ln2125">                  }</a>
<a name="ln2126">            else if (tag == &quot;Chord&quot;) {</a>
<a name="ln2127">                  Chord* chord = new Chord(score());</a>
<a name="ln2128">                  chord-&gt;setTrack(e.track());</a>
<a name="ln2129">                  chord-&gt;read(e);</a>
<a name="ln2130">                  if (startingBeam) {</a>
<a name="ln2131">                        startingBeam-&gt;add(chord); // also calls chord-&gt;setBeam(startingBeam)</a>
<a name="ln2132">                        startingBeam = nullptr;</a>
<a name="ln2133">                        }</a>
<a name="ln2134">//                  if (tuplet &amp;&amp; !chord-&gt;isGrace())</a>
<a name="ln2135">//                        chord-&gt;readAddTuplet(tuplet);</a>
<a name="ln2136">                  segment = getSegment(SegmentType::ChordRest, e.tick());</a>
<a name="ln2137">                  if (chord-&gt;noteType() != NoteType::NORMAL)</a>
<a name="ln2138">                        graceNotes.push_back(chord);</a>
<a name="ln2139">                  else {</a>
<a name="ln2140">                        segment-&gt;add(chord);</a>
<a name="ln2141">                        for (int i = 0; i &lt; graceNotes.size(); ++i) {</a>
<a name="ln2142">                              Chord* gc = graceNotes[i];</a>
<a name="ln2143">                              gc-&gt;setGraceIndex(i);</a>
<a name="ln2144">                              chord-&gt;add(gc);</a>
<a name="ln2145">                              }</a>
<a name="ln2146">                        graceNotes.clear();</a>
<a name="ln2147">                        if (tuplet)</a>
<a name="ln2148">                              tuplet-&gt;add(chord);</a>
<a name="ln2149">                        e.incTick(chord-&gt;actualTicks());</a>
<a name="ln2150">                        }</a>
<a name="ln2151">                  if (fermata) {</a>
<a name="ln2152">                        segment-&gt;add(fermata);</a>
<a name="ln2153">                        fermata = nullptr;</a>
<a name="ln2154">                        }</a>
<a name="ln2155">                  }</a>
<a name="ln2156">            else if (tag == &quot;Rest&quot;) {</a>
<a name="ln2157">                  Rest* rest = new Rest(score());</a>
<a name="ln2158">                  rest-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln2159">                  rest-&gt;setTicks(timesig()/timeStretch);</a>
<a name="ln2160">                  rest-&gt;setTrack(e.track());</a>
<a name="ln2161">                  rest-&gt;read(e);</a>
<a name="ln2162">                  if (startingBeam) {</a>
<a name="ln2163">                        startingBeam-&gt;add(rest); // also calls rest-&gt;setBeam(startingBeam)</a>
<a name="ln2164">                        startingBeam = nullptr;</a>
<a name="ln2165">                        }</a>
<a name="ln2166">                  segment = getSegment(SegmentType::ChordRest, e.tick());</a>
<a name="ln2167">                  segment-&gt;add(rest);</a>
<a name="ln2168">                  if (fermata) {</a>
<a name="ln2169">                        segment-&gt;add(fermata);</a>
<a name="ln2170">                        fermata = nullptr;</a>
<a name="ln2171">                        }</a>
<a name="ln2172"> </a>
<a name="ln2173">                  if (!rest-&gt;ticks().isValid())     // hack</a>
<a name="ln2174">                        rest-&gt;setTicks(timesig()/timeStretch);</a>
<a name="ln2175"> </a>
<a name="ln2176">                  if (tuplet)</a>
<a name="ln2177">                        tuplet-&gt;add(rest);</a>
<a name="ln2178">                  e.incTick(rest-&gt;actualTicks());</a>
<a name="ln2179">                  }</a>
<a name="ln2180">            else if (tag == &quot;Breath&quot;) {</a>
<a name="ln2181">                  Breath* breath = new Breath(score());</a>
<a name="ln2182">                  breath-&gt;setTrack(e.track());</a>
<a name="ln2183">                  breath-&gt;read(e);</a>
<a name="ln2184">                  segment = getSegment(SegmentType::Breath, e.tick());</a>
<a name="ln2185">                  segment-&gt;add(breath);</a>
<a name="ln2186">                  }</a>
<a name="ln2187">            else if (tag == &quot;Spanner&quot;)</a>
<a name="ln2188">                  Spanner::readSpanner(e, this, e.track());</a>
<a name="ln2189">            else if (tag == &quot;RepeatMeasure&quot;) {</a>
<a name="ln2190">                  RepeatMeasure* rm = new RepeatMeasure(score());</a>
<a name="ln2191">                  rm-&gt;setTrack(e.track());</a>
<a name="ln2192">                  rm-&gt;read(e);</a>
<a name="ln2193">                  segment = getSegment(SegmentType::ChordRest, e.tick());</a>
<a name="ln2194">                  segment-&gt;add(rm);</a>
<a name="ln2195">                  e.incTick(ticks());</a>
<a name="ln2196">                  }</a>
<a name="ln2197">            else if (tag == &quot;Clef&quot;) {</a>
<a name="ln2198">                  Clef* clef = new Clef(score());</a>
<a name="ln2199">                  clef-&gt;setTrack(e.track());</a>
<a name="ln2200">                  clef-&gt;read(e);</a>
<a name="ln2201">                  clef-&gt;setGenerated(false);</a>
<a name="ln2202"> </a>
<a name="ln2203">                  // there may be more than one clef segment for same tick position</a>
<a name="ln2204">                  // the first clef may be missing and is added later in layout</a>
<a name="ln2205"> </a>
<a name="ln2206">                  bool header;</a>
<a name="ln2207">                  if (e.tick() != tick())</a>
<a name="ln2208">                        header = false;</a>
<a name="ln2209">                  else if (!segment)</a>
<a name="ln2210">                        header = true;</a>
<a name="ln2211">                  else {</a>
<a name="ln2212">                        header = true;</a>
<a name="ln2213">                        for (Segment* s = _segments.first(); s &amp;&amp; s-&gt;rtick().isZero(); s = s-&gt;next()) {</a>
<a name="ln2214">                              if (s-&gt;isKeySigType() || s-&gt;isTimeSigType()) {</a>
<a name="ln2215">                                    // hack: there may be other segment types which should</a>
<a name="ln2216">                                    // generate a clef at current position</a>
<a name="ln2217">                                    header = false;</a>
<a name="ln2218">                                    break;</a>
<a name="ln2219">                                    }</a>
<a name="ln2220">                              }</a>
<a name="ln2221">                        }</a>
<a name="ln2222">                  segment = getSegment(header ? SegmentType::HeaderClef : SegmentType::Clef, e.tick());</a>
<a name="ln2223">                  segment-&gt;add(clef);</a>
<a name="ln2224">                  }</a>
<a name="ln2225">            else if (tag == &quot;TimeSig&quot;) {</a>
<a name="ln2226">                  TimeSig* ts = new TimeSig(score());</a>
<a name="ln2227">                  ts-&gt;setTrack(e.track());</a>
<a name="ln2228">                  ts-&gt;read(e);</a>
<a name="ln2229">                  // if time sig not at beginning of measure =&gt; courtesy time sig</a>
<a name="ln2230">                  Fraction currTick = e.tick();</a>
<a name="ln2231">                  bool courtesySig = (currTick &gt; tick());</a>
<a name="ln2232">                  if (courtesySig) {</a>
<a name="ln2233">                        // if courtesy sig., just add it without map processing</a>
<a name="ln2234">                        segment = getSegment(SegmentType::TimeSigAnnounce, currTick);</a>
<a name="ln2235">                        segment-&gt;add(ts);</a>
<a name="ln2236">                        }</a>
<a name="ln2237">                  else {</a>
<a name="ln2238">                        // if 'real' time sig., do full process</a>
<a name="ln2239">                        segment = getSegment(SegmentType::TimeSig, currTick);</a>
<a name="ln2240">                        segment-&gt;add(ts);</a>
<a name="ln2241"> </a>
<a name="ln2242">                        timeStretch = ts-&gt;stretch().reduced();</a>
<a name="ln2243">                        _timesig    = ts-&gt;sig() / timeStretch;</a>
<a name="ln2244"> </a>
<a name="ln2245">                        if (irregular) {</a>
<a name="ln2246">                              score()-&gt;sigmap()-&gt;add(tick().ticks(), SigEvent(_len, _timesig));</a>
<a name="ln2247">                              score()-&gt;sigmap()-&gt;add((tick() + ticks()).ticks(), SigEvent(_timesig));</a>
<a name="ln2248">                              }</a>
<a name="ln2249">                        else {</a>
<a name="ln2250">                              _len = _timesig;</a>
<a name="ln2251">                              score()-&gt;sigmap()-&gt;add(tick().ticks(), SigEvent(_timesig));</a>
<a name="ln2252">                              }</a>
<a name="ln2253">                        }</a>
<a name="ln2254">                  }</a>
<a name="ln2255">            else if (tag == &quot;KeySig&quot;) {</a>
<a name="ln2256">                  KeySig* ks = new KeySig(score());</a>
<a name="ln2257">                  ks-&gt;setTrack(e.track());</a>
<a name="ln2258">                  ks-&gt;read(e);</a>
<a name="ln2259">                  Fraction curTick = e.tick();</a>
<a name="ln2260">                  if (!ks-&gt;isCustom() &amp;&amp; !ks-&gt;isAtonal() &amp;&amp; ks-&gt;key() == Key::C &amp;&amp; curTick.isZero()) {</a>
<a name="ln2261">                        // ignore empty key signature</a>
<a name="ln2262">                        qDebug(&quot;remove keysig c at tick 0&quot;);</a>
<a name="ln2263">                        }</a>
<a name="ln2264">                  else {</a>
<a name="ln2265">                        // if key sig not at beginning of measure =&gt; courtesy key sig</a>
<a name="ln2266">                        bool courtesySig = (curTick == endTick());</a>
<a name="ln2267">                        segment = getSegment(courtesySig ? SegmentType::KeySigAnnounce : SegmentType::KeySig, curTick);</a>
<a name="ln2268">                        segment-&gt;add(ks);</a>
<a name="ln2269">                        if (!courtesySig)</a>
<a name="ln2270">                              staff-&gt;setKey(curTick, ks-&gt;keySigEvent());</a>
<a name="ln2271">                        }</a>
<a name="ln2272">                  }</a>
<a name="ln2273">            else if (tag == &quot;Text&quot;) {</a>
<a name="ln2274">                  StaffText* t = new StaffText(score());</a>
<a name="ln2275">                  t-&gt;setTrack(e.track());</a>
<a name="ln2276">                  t-&gt;read(e);</a>
<a name="ln2277">                  if (t-&gt;empty()) {</a>
<a name="ln2278">                        qDebug(&quot;==reading empty text: deleted&quot;);</a>
<a name="ln2279">                        delete t;</a>
<a name="ln2280">                        }</a>
<a name="ln2281">                  else {</a>
<a name="ln2282">                        segment = getSegment(SegmentType::ChordRest, e.tick());</a>
<a name="ln2283">                        segment-&gt;add(t);</a>
<a name="ln2284">                        }</a>
<a name="ln2285">                  }</a>
<a name="ln2286"> </a>
<a name="ln2287">            //----------------------------------------------------</a>
<a name="ln2288">            // Annotation</a>
<a name="ln2289"> </a>
<a name="ln2290">            else if (tag == &quot;Dynamic&quot;) {</a>
<a name="ln2291">                  Dynamic* dyn = new Dynamic(score());</a>
<a name="ln2292">                  dyn-&gt;setTrack(e.track());</a>
<a name="ln2293">                  dyn-&gt;read(e);</a>
<a name="ln2294">                  segment = getSegment(SegmentType::ChordRest, e.tick());</a>
<a name="ln2295">                  segment-&gt;add(dyn);</a>
<a name="ln2296">                  }</a>
<a name="ln2297">            else if (tag == &quot;Harmony&quot;</a>
<a name="ln2298">               || tag == &quot;FretDiagram&quot;</a>
<a name="ln2299">               || tag == &quot;TremoloBar&quot;</a>
<a name="ln2300">               || tag == &quot;Symbol&quot;</a>
<a name="ln2301">               || tag == &quot;Tempo&quot;</a>
<a name="ln2302">               || tag == &quot;StaffText&quot;</a>
<a name="ln2303">               || tag == &quot;Sticking&quot;</a>
<a name="ln2304">               || tag == &quot;SystemText&quot;</a>
<a name="ln2305">               || tag == &quot;RehearsalMark&quot;</a>
<a name="ln2306">               || tag == &quot;InstrumentChange&quot;</a>
<a name="ln2307">               || tag == &quot;StaffState&quot;</a>
<a name="ln2308">               || tag == &quot;FiguredBass&quot;</a>
<a name="ln2309">               ) {</a>
<a name="ln2310">                  Element* el = Element::name2Element(tag, score());</a>
<a name="ln2311">                  // hack - needed because tick tags are unreliable in 1.3 scores</a>
<a name="ln2312">                  // for symbols attached to anything but a measure</a>
<a name="ln2313">                  el-&gt;setTrack(e.track());</a>
<a name="ln2314">                  el-&gt;read(e);</a>
<a name="ln2315">                  segment = getSegment(SegmentType::ChordRest, e.tick());</a>
<a name="ln2316">                  segment-&gt;add(el);</a>
<a name="ln2317">                  }</a>
<a name="ln2318">            else if (tag == &quot;Fermata&quot;) {</a>
<a name="ln2319">                  fermata = new Fermata(score());</a>
<a name="ln2320">                  fermata-&gt;setTrack(e.track());</a>
<a name="ln2321">                  fermata-&gt;setPlacement(fermata-&gt;track() &amp; 1 ? Placement::BELOW : Placement::ABOVE);</a>
<a name="ln2322">                  fermata-&gt;read(e);</a>
<a name="ln2323">                  }</a>
<a name="ln2324">            else if (tag == &quot;Image&quot;) {</a>
<a name="ln2325">                  if (MScore::noImages)</a>
<a name="ln2326">                        e.skipCurrentElement();</a>
<a name="ln2327">                  else {</a>
<a name="ln2328">                        Element* el = Element::name2Element(tag, score());</a>
<a name="ln2329">                        el-&gt;setTrack(e.track());</a>
<a name="ln2330">                        el-&gt;read(e);</a>
<a name="ln2331">                        segment = getSegment(SegmentType::ChordRest, e.tick());</a>
<a name="ln2332">                        segment-&gt;add(el);</a>
<a name="ln2333">                        }</a>
<a name="ln2334">                  }</a>
<a name="ln2335">            //----------------------------------------------------</a>
<a name="ln2336">            else if (tag == &quot;Tuplet&quot;) {</a>
<a name="ln2337">                  Tuplet* oldTuplet = tuplet;</a>
<a name="ln2338">                  tuplet = new Tuplet(score());</a>
<a name="ln2339">                  tuplet-&gt;setTrack(e.track());</a>
<a name="ln2340">                  tuplet-&gt;setTick(e.tick());</a>
<a name="ln2341">                  tuplet-&gt;setParent(this);</a>
<a name="ln2342">                  tuplet-&gt;read(e);</a>
<a name="ln2343">                  if (oldTuplet)</a>
<a name="ln2344">                        oldTuplet-&gt;add(tuplet);</a>
<a name="ln2345">                  }</a>
<a name="ln2346">            else if (tag == &quot;endTuplet&quot;) {</a>
<a name="ln2347">                  if (!tuplet) {</a>
<a name="ln2348">                        qDebug(&quot;Measure::read: encountered &lt;endTuplet/&gt; when no tuplet was started&quot;);</a>
<a name="ln2349">                        e.skipCurrentElement();</a>
<a name="ln2350">                        continue;</a>
<a name="ln2351">                        }</a>
<a name="ln2352">                  Tuplet* oldTuplet = tuplet;</a>
<a name="ln2353">                  tuplet = tuplet-&gt;tuplet();</a>
<a name="ln2354">                  if (oldTuplet-&gt;elements().empty()) {</a>
<a name="ln2355">                        // this should not happen and is a sign of input file corruption</a>
<a name="ln2356">                        qDebug(&quot;Measure:read: empty tuplet in measure index=%d, input file corrupted?&quot;, e.currentMeasureIndex());</a>
<a name="ln2357">                        if (tuplet)</a>
<a name="ln2358">                              tuplet-&gt;remove(oldTuplet);</a>
<a name="ln2359">                        delete oldTuplet;</a>
<a name="ln2360">                        }</a>
<a name="ln2361">                  e.readNext();</a>
<a name="ln2362">                  }</a>
<a name="ln2363">            else if (tag == &quot;Beam&quot;) {</a>
<a name="ln2364">                  Beam* beam = new Beam(score());</a>
<a name="ln2365">                  beam-&gt;setTrack(e.track());</a>
<a name="ln2366">                  beam-&gt;read(e);</a>
<a name="ln2367">                  beam-&gt;setParent(0);</a>
<a name="ln2368">                  if (startingBeam) {</a>
<a name="ln2369">                        qDebug(&quot;The read beam was not used&quot;);</a>
<a name="ln2370">                        delete startingBeam;</a>
<a name="ln2371">                        }</a>
<a name="ln2372">                  startingBeam = beam;</a>
<a name="ln2373">                  }</a>
<a name="ln2374">            else if (tag == &quot;Segment&quot; &amp;&amp; segment)</a>
<a name="ln2375">                  segment-&gt;read(e);</a>
<a name="ln2376">            else if (tag == &quot;Ambitus&quot;) {</a>
<a name="ln2377">                  Ambitus* range = new Ambitus(score());</a>
<a name="ln2378">                  range-&gt;read(e);</a>
<a name="ln2379">                  segment = getSegment(SegmentType::Ambitus, e.tick());</a>
<a name="ln2380">                  range-&gt;setParent(segment);          // a parent segment is needed for setTrack() to work</a>
<a name="ln2381">                  range-&gt;setTrack(trackZeroVoice(e.track()));</a>
<a name="ln2382">                  segment-&gt;add(range);</a>
<a name="ln2383">                  }</a>
<a name="ln2384">            else</a>
<a name="ln2385">                  e.unknown();</a>
<a name="ln2386">            }</a>
<a name="ln2387">      if (startingBeam) {</a>
<a name="ln2388">            qDebug(&quot;The read beam was not used&quot;);</a>
<a name="ln2389">            delete startingBeam;</a>
<a name="ln2390">            }</a>
<a name="ln2391">      if (tuplet) {</a>
<a name="ln2392">            qDebug(&quot;Measure:readVoice: measure index=%d, &lt;endTuplet/&gt; not found&quot;, e.currentMeasureIndex());</a>
<a name="ln2393">            if (tuplet-&gt;elements().empty()) {</a>
<a name="ln2394">                  if (tuplet-&gt;tuplet())</a>
<a name="ln2395">                        tuplet-&gt;tuplet()-&gt;remove(tuplet);</a>
<a name="ln2396">                  delete tuplet;</a>
<a name="ln2397">                  }</a>
<a name="ln2398">            }</a>
<a name="ln2399">      if (fermata) {</a>
<a name="ln2400">            SegmentType st = (e.tick() == endTick() ? SegmentType::EndBarLine : SegmentType::ChordRest);</a>
<a name="ln2401">            segment = getSegment(st, e.tick());</a>
<a name="ln2402">            segment-&gt;add(fermata);</a>
<a name="ln2403">            fermata = nullptr;</a>
<a name="ln2404">            }</a>
<a name="ln2405">      }</a>
<a name="ln2406"> </a>
<a name="ln2407">//---------------------------------------------------------</a>
<a name="ln2408">//   Measure::readAddConnector</a>
<a name="ln2409">//---------------------------------------------------------</a>
<a name="ln2410"> </a>
<a name="ln2411">void Measure::readAddConnector(ConnectorInfoReader* info, bool pasteMode)</a>
<a name="ln2412">      {</a>
<a name="ln2413">      const ElementType type = info-&gt;type();</a>
<a name="ln2414">      switch(type) {</a>
<a name="ln2415">            case ElementType::HAIRPIN:</a>
<a name="ln2416">            case ElementType::PEDAL:</a>
<a name="ln2417">            case ElementType::OTTAVA:</a>
<a name="ln2418">            case ElementType::TRILL:</a>
<a name="ln2419">            case ElementType::TEXTLINE:</a>
<a name="ln2420">            case ElementType::LET_RING:</a>
<a name="ln2421">            case ElementType::VIBRATO:</a>
<a name="ln2422">            case ElementType::PALM_MUTE:</a>
<a name="ln2423">            case ElementType::VOLTA:</a>
<a name="ln2424">                  {</a>
<a name="ln2425">                  Spanner* sp = toSpanner(info-&gt;connector());</a>
<a name="ln2426">                  const Location&amp; l = info-&gt;location();</a>
<a name="ln2427">                  Fraction lTick    = l.frac();</a>
<a name="ln2428">                  Fraction spTick   = pasteMode ? lTick : (tick() + lTick);</a>
<a name="ln2429">                  if (info-&gt;isStart()) {</a>
<a name="ln2430">                        sp-&gt;setTrack(l.track());</a>
<a name="ln2431">                        sp-&gt;setTick(spTick);</a>
<a name="ln2432">                        score()-&gt;addSpanner(sp);</a>
<a name="ln2433">                        }</a>
<a name="ln2434">                  else if (info-&gt;isEnd()) {</a>
<a name="ln2435">                        sp-&gt;setTrack2(l.track());</a>
<a name="ln2436">                        sp-&gt;setTick2(spTick);</a>
<a name="ln2437">                        }</a>
<a name="ln2438">                  }</a>
<a name="ln2439">                  break;</a>
<a name="ln2440">            default:</a>
<a name="ln2441">                  break;</a>
<a name="ln2442">            }</a>
<a name="ln2443">      }</a>
<a name="ln2444"> </a>
<a name="ln2445">//---------------------------------------------------------</a>
<a name="ln2446">//   visible</a>
<a name="ln2447">//---------------------------------------------------------</a>
<a name="ln2448"> </a>
<a name="ln2449">bool Measure::visible(int staffIdx) const</a>
<a name="ln2450">      {</a>
<a name="ln2451">      if (staffIdx &gt;= score()-&gt;staves().size()) {</a>
<a name="ln2452">            qDebug(&quot;Measure::visible: bad staffIdx: %d&quot;, staffIdx);</a>
<a name="ln2453">            return false;</a>
<a name="ln2454">            }</a>
<a name="ln2455">      if (system() &amp;&amp; (system()-&gt;staves()-&gt;empty() || !system()-&gt;staff(staffIdx)-&gt;show()))</a>
<a name="ln2456">            return false;</a>
<a name="ln2457">      if (score()-&gt;staff(staffIdx)-&gt;cutaway() &amp;&amp; isEmpty(staffIdx))</a>
<a name="ln2458">            return false;</a>
<a name="ln2459">      return score()-&gt;staff(staffIdx)-&gt;show() &amp;&amp; _mstaves[staffIdx]-&gt;visible();</a>
<a name="ln2460">      }</a>
<a name="ln2461"> </a>
<a name="ln2462">//---------------------------------------------------------</a>
<a name="ln2463">//   stemless</a>
<a name="ln2464">//---------------------------------------------------------</a>
<a name="ln2465"> </a>
<a name="ln2466">bool Measure::stemless(int staffIdx) const</a>
<a name="ln2467">      {</a>
<a name="ln2468">      const Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln2469">      return staff-&gt;stemless(tick()) || _mstaves[staffIdx]-&gt;stemless() || staff-&gt;staffType(tick())-&gt;stemless();</a>
<a name="ln2470">      }</a>
<a name="ln2471"> </a>
<a name="ln2472">//---------------------------------------------------------</a>
<a name="ln2473">//   isFinalMeasureOfSection</a>
<a name="ln2474">//    returns true if this measure is final actual measure of a section</a>
<a name="ln2475">//    takes into consideration fact that subsequent measures base objects</a>
<a name="ln2476">//    may have section break before encountering next actual measure</a>
<a name="ln2477">//---------------------------------------------------------</a>
<a name="ln2478"> </a>
<a name="ln2479">bool Measure::isFinalMeasureOfSection() const</a>
<a name="ln2480">      {</a>
<a name="ln2481">      const MeasureBase* mb = static_cast&lt;const MeasureBase*&gt;(this);</a>
<a name="ln2482"> </a>
<a name="ln2483">      do {</a>
<a name="ln2484">            if (mb-&gt;sectionBreak())</a>
<a name="ln2485">                  return true;</a>
<a name="ln2486"> </a>
<a name="ln2487">            mb = mb-&gt;next();</a>
<a name="ln2488">            } while (mb &amp;&amp; !mb-&gt;isMeasure());   // loop until reach next actual measure or end of score</a>
<a name="ln2489"> </a>
<a name="ln2490">      return false;</a>
<a name="ln2491">      }</a>
<a name="ln2492"> </a>
<a name="ln2493">//---------------------------------------------------------</a>
<a name="ln2494">//   isAnacrusis</a>
<a name="ln2495">//---------------------------------------------------------</a>
<a name="ln2496"> </a>
<a name="ln2497">bool Measure::isAnacrusis() const</a>
<a name="ln2498">      {</a>
<a name="ln2499">      TimeSigFrac timeSig = score()-&gt;sigmap()-&gt;timesig(tick().ticks()).nominal();</a>
<a name="ln2500">      return irregular() &amp;&amp; ticks() &lt; Fraction::fromTicks(timeSig.ticksPerMeasure());</a>
<a name="ln2501">      }</a>
<a name="ln2502"> </a>
<a name="ln2503">//---------------------------------------------------------</a>
<a name="ln2504">//   scanElements</a>
<a name="ln2505">//---------------------------------------------------------</a>
<a name="ln2506"> </a>
<a name="ln2507">void Measure::scanElements(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln2508">      {</a>
<a name="ln2509">      MeasureBase::scanElements(data, func, all);</a>
<a name="ln2510"> </a>
<a name="ln2511">      int nstaves = score()-&gt;nstaves();</a>
<a name="ln2512">      for (int staffIdx = 0; staffIdx &lt; nstaves; ++staffIdx) {</a>
<a name="ln2513">            if (!all &amp;&amp; !(visible(staffIdx) &amp;&amp; score()-&gt;staff(staffIdx)-&gt;show()))</a>
<a name="ln2514">                  continue;</a>
<a name="ln2515">            MStaff* ms = _mstaves[staffIdx];</a>
<a name="ln2516">            func(data, ms-&gt;lines());</a>
<a name="ln2517">            if (ms-&gt;vspacerUp())</a>
<a name="ln2518">                  func(data, ms-&gt;vspacerUp());</a>
<a name="ln2519">            if (ms-&gt;vspacerDown())</a>
<a name="ln2520">                  func(data, ms-&gt;vspacerDown());</a>
<a name="ln2521">            if (ms-&gt;noText())</a>
<a name="ln2522">                  func(data, ms-&gt;noText());</a>
<a name="ln2523">            }</a>
<a name="ln2524"> </a>
<a name="ln2525">      for (Segment* s = first(); s; s = s-&gt;next()) {</a>
<a name="ln2526">            if (!s-&gt;enabled())</a>
<a name="ln2527">                  continue;</a>
<a name="ln2528">            s-&gt;scanElements(data, func, all);</a>
<a name="ln2529">            }</a>
<a name="ln2530">      }</a>
<a name="ln2531"> </a>
<a name="ln2532">//---------------------------------------------------------</a>
<a name="ln2533">//   connectTremolo</a>
<a name="ln2534">///   Connect two-notes tremolo and update duration types</a>
<a name="ln2535">///   for the involved chords.</a>
<a name="ln2536">//---------------------------------------------------------</a>
<a name="ln2537"> </a>
<a name="ln2538">void Measure::connectTremolo()</a>
<a name="ln2539">      {</a>
<a name="ln2540">      const int ntracks = score()-&gt;ntracks();</a>
<a name="ln2541">      constexpr SegmentType st = SegmentType::ChordRest;</a>
<a name="ln2542">      for (Segment* s = first(st); s; s = s-&gt;next(st)) {</a>
<a name="ln2543">            for (int i = 0; i &lt; ntracks; ++i) {</a>
<a name="ln2544">                  Element* e = s-&gt;element(i);</a>
<a name="ln2545">                  if (!e || !e-&gt;isChord())</a>
<a name="ln2546">                        continue;</a>
<a name="ln2547"> </a>
<a name="ln2548">                  Chord* c = toChord(e);</a>
<a name="ln2549">                  Tremolo* tremolo = c-&gt;tremolo();</a>
<a name="ln2550">                  if (tremolo &amp;&amp; tremolo-&gt;twoNotes()) {</a>
<a name="ln2551">                        // Ensure correct duration type for chord</a>
<a name="ln2552">                        c-&gt;setDurationType(tremolo-&gt;durationType());</a>
<a name="ln2553"> </a>
<a name="ln2554">                        // If it is the first tremolo's chord, find the second</a>
<a name="ln2555">                        // chord for tremolo, if needed.</a>
<a name="ln2556">                        if (!tremolo-&gt;chord1())</a>
<a name="ln2557">                              tremolo-&gt;setChords(c, tremolo-&gt;chord2());</a>
<a name="ln2558">                        else if (tremolo-&gt;chord1() != c || tremolo-&gt;chord2())</a>
<a name="ln2559">                              continue;</a>
<a name="ln2560"> </a>
<a name="ln2561">                        for (Segment* ls = s-&gt;next(st); ls; ls = ls-&gt;next(st)) {</a>
<a name="ln2562">                              if (Element* element = ls-&gt;element(i)) {</a>
<a name="ln2563">                                    if (!element-&gt;isChord()) {</a>
<a name="ln2564">                                          qDebug(&quot;cannot connect tremolo&quot;);</a>
<a name="ln2565">                                          continue;</a>
<a name="ln2566">                                          }</a>
<a name="ln2567">                                    Chord* nc = toChord(element);</a>
<a name="ln2568">                                    tremolo-&gt;setChords(c, nc);</a>
<a name="ln2569">                                    nc-&gt;setTremolo(tremolo);</a>
<a name="ln2570">                                    break;</a>
<a name="ln2571">                                    }</a>
<a name="ln2572">                              }</a>
<a name="ln2573">                        }</a>
<a name="ln2574">                  }</a>
<a name="ln2575">            }</a>
<a name="ln2576">      }</a>
<a name="ln2577"> </a>
<a name="ln2578">//---------------------------------------------------------</a>
<a name="ln2579">//   createVoice</a>
<a name="ln2580">//    Create a voice on demand by filling the measure</a>
<a name="ln2581">//    with a whole measure rest.</a>
<a name="ln2582">//    Check if there are any chord/rests in track; if</a>
<a name="ln2583">//    not create a whole measure rest</a>
<a name="ln2584">//---------------------------------------------------------</a>
<a name="ln2585"> </a>
<a name="ln2586">void Measure::createVoice(int track)</a>
<a name="ln2587">      {</a>
<a name="ln2588">      for (Segment* s = first(); s; s = s-&gt;next()) {</a>
<a name="ln2589">            if (s-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln2590">                  continue;</a>
<a name="ln2591">            if (s-&gt;element(track) == 0)</a>
<a name="ln2592">                  score()-&gt;setRest(s-&gt;tick(), track, ticks(), true, 0);</a>
<a name="ln2593">            break;</a>
<a name="ln2594">            }</a>
<a name="ln2595">      }</a>
<a name="ln2596"> </a>
<a name="ln2597">//---------------------------------------------------------</a>
<a name="ln2598">//   sortStaves</a>
<a name="ln2599">//---------------------------------------------------------</a>
<a name="ln2600"> </a>
<a name="ln2601">void Measure::sortStaves(QList&lt;int&gt;&amp; dst)</a>
<a name="ln2602">      {</a>
<a name="ln2603">      std::vector&lt;MStaff*&gt; ms;</a>
<a name="ln2604">      for (int idx : dst)</a>
<a name="ln2605">            ms.push_back(_mstaves[idx]);</a>
<a name="ln2606">      _mstaves = ms;</a>
<a name="ln2607"> </a>
<a name="ln2608">      for (unsigned staffIdx = 0; staffIdx &lt; _mstaves.size(); ++staffIdx)</a>
<a name="ln2609">            _mstaves[staffIdx]-&gt;lines()-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2610">      for (Segment&amp; s : _segments)</a>
<a name="ln2611">            s.sortStaves(dst);</a>
<a name="ln2612"> </a>
<a name="ln2613">      for (Element* e : el()) {</a>
<a name="ln2614">            if (e-&gt;track() == -1 || e-&gt;systemFlag())</a>
<a name="ln2615">                  continue;</a>
<a name="ln2616">            int voice    = e-&gt;voice();</a>
<a name="ln2617">            int staffIdx = e-&gt;staffIdx();</a>
<a name="ln2618">            int idx = dst.indexOf(staffIdx);</a>
<a name="ln2619">            e-&gt;setTrack(idx * VOICES + voice);</a>
<a name="ln2620">            }</a>
<a name="ln2621">      }</a>
<a name="ln2622"> </a>
<a name="ln2623">//---------------------------------------------------------</a>
<a name="ln2624">//   exchangeVoice</a>
<a name="ln2625">//---------------------------------------------------------</a>
<a name="ln2626"> </a>
<a name="ln2627">void Measure::exchangeVoice(int strack, int dtrack, int staffIdx)</a>
<a name="ln2628">      {</a>
<a name="ln2629">      for (Segment* s = first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln2630">            s-&gt;swapElements(strack, dtrack);</a>
<a name="ln2631">            }</a>
<a name="ln2632"> </a>
<a name="ln2633">      auto spanners = score()-&gt;spannerMap().findOverlapping(tick().ticks(), endTick().ticks()-1);</a>
<a name="ln2634">      Fraction start = tick();</a>
<a name="ln2635">      Fraction end = start + ticks();</a>
<a name="ln2636">      for (auto i = spanners.begin(); i &lt; spanners.end(); i++) {</a>
<a name="ln2637">            Spanner* sp = i-&gt;value;</a>
<a name="ln2638">            Fraction spStart = sp-&gt;tick();</a>
<a name="ln2639">            Fraction spEnd = spStart + sp-&gt;ticks();</a>
<a name="ln2640">            qDebug(&quot;Start %d End %d Diff %d \n Measure Start %d End %d&quot;, spStart.ticks(), spEnd.ticks(), (spEnd-spStart).ticks(), start.ticks(), end.ticks());</a>
<a name="ln2641">            if (sp-&gt;isSlur() &amp;&amp; (spStart &gt;= start || spEnd &lt; end)) {</a>
<a name="ln2642">                if (sp-&gt;track() == strack &amp;&amp; spStart &gt;= start){</a>
<a name="ln2643">                        sp-&gt;setTrack(dtrack);</a>
<a name="ln2644">                        }</a>
<a name="ln2645">                else if (sp-&gt;track() == dtrack &amp;&amp; spStart &gt;= start){</a>
<a name="ln2646">                        sp-&gt;setTrack(strack);</a>
<a name="ln2647">                        }</a>
<a name="ln2648">                if (sp-&gt;track2() == strack &amp;&amp; spEnd &lt; end){</a>
<a name="ln2649">                        sp-&gt;setTrack2(dtrack);</a>
<a name="ln2650">                        }</a>
<a name="ln2651">                else if (sp-&gt;track2() == dtrack &amp;&amp; spEnd &lt; end){</a>
<a name="ln2652">                        sp-&gt;setTrack2(strack);</a>
<a name="ln2653">                        }</a>
<a name="ln2654">                  }</a>
<a name="ln2655">            }</a>
<a name="ln2656">      checkMultiVoices(staffIdx);   // probably true, but check for invisible notes &amp; rests</a>
<a name="ln2657">      }</a>
<a name="ln2658"> </a>
<a name="ln2659">//---------------------------------------------------------</a>
<a name="ln2660">//   checkMultiVoices</a>
<a name="ln2661">///   Check for more than on voice in this measure and staff and</a>
<a name="ln2662">///   set MStaff-&gt;hasVoices</a>
<a name="ln2663">//---------------------------------------------------------</a>
<a name="ln2664"> </a>
<a name="ln2665">void Measure::checkMultiVoices(int staffIdx)</a>
<a name="ln2666">      {</a>
<a name="ln2667">      int strack = staffIdx * VOICES + 1;</a>
<a name="ln2668">      int etrack = staffIdx * VOICES + VOICES;</a>
<a name="ln2669">      _mstaves[staffIdx]-&gt;setHasVoices(false);</a>
<a name="ln2670"> </a>
<a name="ln2671">      for (Segment* s = first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln2672">            for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln2673">                  Element* e = s-&gt;element(track);</a>
<a name="ln2674">                  if (e) {</a>
<a name="ln2675">                        bool v;</a>
<a name="ln2676">                        if (e-&gt;isChord()) {</a>
<a name="ln2677">                              v = false;</a>
<a name="ln2678">                              // consider chord visible if any note is visible</a>
<a name="ln2679">                              Chord* c = toChord(e);</a>
<a name="ln2680">                              for (Note* n : c-&gt;notes()) {</a>
<a name="ln2681">                                    if (n-&gt;visible()) {</a>
<a name="ln2682">                                          v = true;</a>
<a name="ln2683">                                          break;</a>
<a name="ln2684">                                          }</a>
<a name="ln2685">                                    }</a>
<a name="ln2686">                              }</a>
<a name="ln2687">                        else</a>
<a name="ln2688">                              v = e-&gt;visible();</a>
<a name="ln2689">                        if (v) {</a>
<a name="ln2690">                              _mstaves[staffIdx]-&gt;setHasVoices(true);</a>
<a name="ln2691">                              return;</a>
<a name="ln2692">                              }</a>
<a name="ln2693">                        }</a>
<a name="ln2694">                  }</a>
<a name="ln2695">            }</a>
<a name="ln2696">      }</a>
<a name="ln2697"> </a>
<a name="ln2698">//---------------------------------------------------------</a>
<a name="ln2699">//   hasVoice</a>
<a name="ln2700">//---------------------------------------------------------</a>
<a name="ln2701"> </a>
<a name="ln2702">bool Measure::hasVoice(int track) const</a>
<a name="ln2703">      {</a>
<a name="ln2704">      if (track &gt;= score()-&gt;ntracks())</a>
<a name="ln2705">            return false;</a>
<a name="ln2706">      for (Segment* s = first(); s; s = s-&gt;next()) {</a>
<a name="ln2707">            if (s-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln2708">                  continue;</a>
<a name="ln2709">            if (s-&gt;element(track))</a>
<a name="ln2710">                  return true;</a>
<a name="ln2711">            }</a>
<a name="ln2712">      return false;</a>
<a name="ln2713">      }</a>
<a name="ln2714"> </a>
<a name="ln2715">//-------------------------------------------------------------------</a>
<a name="ln2716">//   isEmpty</a>
<a name="ln2717">///   Check if the measure is filled by a full-measure rest, or is</a>
<a name="ln2718">///   full of rests on this staff, that may have fermatas on them.</a>
<a name="ln2719">///   If staff is -1, then check for all staves.</a>
<a name="ln2720">//-------------------------------------------------------------------</a>
<a name="ln2721"> </a>
<a name="ln2722">bool Measure::isEmpty(int staffIdx) const</a>
<a name="ln2723">      {</a>
<a name="ln2724">      int strack;</a>
<a name="ln2725">      int etrack;</a>
<a name="ln2726">      if (staffIdx &lt; 0) {</a>
<a name="ln2727">            strack = 0;</a>
<a name="ln2728">            etrack = score()-&gt;nstaves() * VOICES;</a>
<a name="ln2729">            }</a>
<a name="ln2730">      else {</a>
<a name="ln2731">            strack = staffIdx * VOICES;</a>
<a name="ln2732">            etrack = strack + VOICES;</a>
<a name="ln2733">            }</a>
<a name="ln2734">      for (Segment* s = first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln2735">            for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln2736">                  Element* e = s-&gt;element(track);</a>
<a name="ln2737">                  if (e &amp;&amp; !e-&gt;isRest())</a>
<a name="ln2738">                        return false;</a>
<a name="ln2739">                  }</a>
<a name="ln2740">            for (Element* a : s-&gt;annotations()) {</a>
<a name="ln2741">                  if (!a || a-&gt;systemFlag() || !a-&gt;visible() || a-&gt;isFermata())</a>
<a name="ln2742">                        continue;</a>
<a name="ln2743">                  int atrack = a-&gt;track();</a>
<a name="ln2744">                  if (atrack &gt;= strack &amp;&amp; atrack &lt; etrack)</a>
<a name="ln2745">                        return false;</a>
<a name="ln2746">                  }</a>
<a name="ln2747">            }</a>
<a name="ln2748">      return true;</a>
<a name="ln2749">      }</a>
<a name="ln2750"> </a>
<a name="ln2751">//---------------------------------------------------------</a>
<a name="ln2752">//   isFullMeasureRest</a>
<a name="ln2753">//    Check for an empty measure, filled with full measure</a>
<a name="ln2754">//    rests.</a>
<a name="ln2755">//---------------------------------------------------------</a>
<a name="ln2756"> </a>
<a name="ln2757">bool Measure::isFullMeasureRest() const</a>
<a name="ln2758">      {</a>
<a name="ln2759">      int strack = 0;</a>
<a name="ln2760">      int etrack = score()-&gt;nstaves() * VOICES;</a>
<a name="ln2761"> </a>
<a name="ln2762">      Segment* s = first(SegmentType::ChordRest);</a>
<a name="ln2763">      for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln2764">            Element* e = s-&gt;element(track);</a>
<a name="ln2765">            if (e) {</a>
<a name="ln2766">                  if (!e-&gt;isRest())</a>
<a name="ln2767">                        return false;</a>
<a name="ln2768">                  Rest* rest = toRest(e);</a>
<a name="ln2769">                  if (rest-&gt;durationType().type() != TDuration::DurationType::V_MEASURE)</a>
<a name="ln2770">                        return false;</a>
<a name="ln2771">                  }</a>
<a name="ln2772">            }</a>
<a name="ln2773">      return true;</a>
<a name="ln2774">      }</a>
<a name="ln2775"> </a>
<a name="ln2776">//---------------------------------------------------------</a>
<a name="ln2777">//   isRepeatMeasure</a>
<a name="ln2778">//---------------------------------------------------------</a>
<a name="ln2779"> </a>
<a name="ln2780">bool Measure::isRepeatMeasure(const Staff* staff) const</a>
<a name="ln2781">      {</a>
<a name="ln2782">      int staffIdx = staff-&gt;idx();</a>
<a name="ln2783">      int strack   = staffIdx * VOICES;</a>
<a name="ln2784">      int etrack   = (staffIdx + 1) * VOICES;</a>
<a name="ln2785">      Segment* s   = first(SegmentType::ChordRest);</a>
<a name="ln2786"> </a>
<a name="ln2787">      if (s == 0)</a>
<a name="ln2788">            return false;</a>
<a name="ln2789"> </a>
<a name="ln2790">      for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln2791">            Element* e = s-&gt;element(track);</a>
<a name="ln2792">            if (e &amp;&amp; e-&gt;isRepeatMeasure())</a>
<a name="ln2793">                  return true;</a>
<a name="ln2794">            }</a>
<a name="ln2795">      return false;</a>
<a name="ln2796">      }</a>
<a name="ln2797"> </a>
<a name="ln2798">//---------------------------------------------------------</a>
<a name="ln2799">//   isEmpty</a>
<a name="ln2800">//---------------------------------------------------------</a>
<a name="ln2801"> </a>
<a name="ln2802">bool Measure::empty() const</a>
<a name="ln2803">      {</a>
<a name="ln2804">      if (irregular())</a>
<a name="ln2805">            return false;</a>
<a name="ln2806">      int n = 0;</a>
<a name="ln2807">      int tracks = int(_mstaves.size()) * VOICES;</a>
<a name="ln2808">      static const SegmentType st = SegmentType::ChordRest ;</a>
<a name="ln2809">      for (const Segment* s = first(st); s; s = s-&gt;next(st)) {</a>
<a name="ln2810">            bool restFound = false;</a>
<a name="ln2811">            for (int track = 0; track &lt; tracks; ++track) {</a>
<a name="ln2812">                  if ((track % VOICES) == 0 &amp;&amp; !score()-&gt;staff(track/VOICES)-&gt;show()) {</a>
<a name="ln2813">                        track += VOICES-1;</a>
<a name="ln2814">                        continue;</a>
<a name="ln2815">                        }</a>
<a name="ln2816">                  if (s-&gt;element(track))  {</a>
<a name="ln2817">                        if (!s-&gt;element(track)-&gt;isRest())</a>
<a name="ln2818">                              return false;</a>
<a name="ln2819">                        restFound = true;</a>
<a name="ln2820">                        }</a>
<a name="ln2821">                  }</a>
<a name="ln2822">            if (restFound)</a>
<a name="ln2823">                  ++n;</a>
<a name="ln2824">            // measure is not empty if there is more than one rest</a>
<a name="ln2825">            if (n &gt; 1)</a>
<a name="ln2826">                  return false;</a>
<a name="ln2827">            }</a>
<a name="ln2828">      return true;</a>
<a name="ln2829">      }</a>
<a name="ln2830"> </a>
<a name="ln2831">//---------------------------------------------------------</a>
<a name="ln2832">//   isOnlyRests</a>
<a name="ln2833">//---------------------------------------------------------</a>
<a name="ln2834"> </a>
<a name="ln2835">bool Measure::isOnlyRests(int track) const</a>
<a name="ln2836">      {</a>
<a name="ln2837">      static const SegmentType st = SegmentType::ChordRest;</a>
<a name="ln2838">      for (const Segment* s = first(st); s; s = s-&gt;next(st)) {</a>
<a name="ln2839">            if (s-&gt;segmentType() != st || !s-&gt;element(track))</a>
<a name="ln2840">                  continue;</a>
<a name="ln2841">            if (!s-&gt;element(track)-&gt;isRest())</a>
<a name="ln2842">                  return false;</a>
<a name="ln2843">            }</a>
<a name="ln2844">      return true;</a>
<a name="ln2845">      }</a>
<a name="ln2846"> </a>
<a name="ln2847">//---------------------------------------------------------</a>
<a name="ln2848">//   isOnlyDeletedRests</a>
<a name="ln2849">//---------------------------------------------------------</a>
<a name="ln2850"> </a>
<a name="ln2851">bool Measure::isOnlyDeletedRests(int track) const</a>
<a name="ln2852">      {</a>
<a name="ln2853">      static const SegmentType st { SegmentType::ChordRest };</a>
<a name="ln2854">      for (const Segment* s = first(st); s; s = s-&gt;next(st)) {</a>
<a name="ln2855">            if (s-&gt;segmentType() != st || !s-&gt;element(track))</a>
<a name="ln2856">                  continue;</a>
<a name="ln2857">            if (s-&gt;element(track)-&gt;isRest() ? !toRest(s-&gt;element(track))-&gt;isGap() : !s-&gt;element(track)-&gt;isRest())</a>
<a name="ln2858">                  return false;</a>
<a name="ln2859">            }</a>
<a name="ln2860">      return true;</a>
<a name="ln2861">      }</a>
<a name="ln2862"> </a>
<a name="ln2863">//---------------------------------------------------------</a>
<a name="ln2864">//   isOnlyDeletedRests</a>
<a name="ln2865">//---------------------------------------------------------</a>
<a name="ln2866"> </a>
<a name="ln2867">bool Measure::isOnlyDeletedRests(int track, const Fraction&amp; stick, const Fraction&amp; etick) const</a>
<a name="ln2868">      {</a>
<a name="ln2869">      static const SegmentType st { SegmentType::ChordRest };</a>
<a name="ln2870">      for (const Segment* s = first(st); s; s = s-&gt;next(st)) {</a>
<a name="ln2871">            if (s-&gt;segmentType() != st || !s-&gt;element(track))</a>
<a name="ln2872">                  continue;</a>
<a name="ln2873">            ChordRest* cr = toChordRest(s-&gt;element(track));</a>
<a name="ln2874">            if (cr-&gt;tick() + cr-&gt;globalTicks() &lt;= stick)</a>
<a name="ln2875">                  continue;</a>
<a name="ln2876">            if (cr-&gt;tick() &gt;= etick)</a>
<a name="ln2877">                  return true;</a>
<a name="ln2878">            if (!cr-&gt;isRest() || !toRest(cr)-&gt;isGap())</a>
<a name="ln2879">                  return false;</a>
<a name="ln2880">            }</a>
<a name="ln2881">      return true;</a>
<a name="ln2882">      }</a>
<a name="ln2883"> </a>
<a name="ln2884">//---------------------------------------------------------</a>
<a name="ln2885">//   stretchedLen</a>
<a name="ln2886">//---------------------------------------------------------</a>
<a name="ln2887"> </a>
<a name="ln2888">Fraction Measure::stretchedLen(Staff* staff) const</a>
<a name="ln2889">      {</a>
<a name="ln2890">      return ticks() * staff-&gt;timeStretch(tick());</a>
<a name="ln2891">      }</a>
<a name="ln2892"> </a>
<a name="ln2893">//---------------------------------------------------------</a>
<a name="ln2894">//   cloneMeasure</a>
<a name="ln2895">//---------------------------------------------------------</a>
<a name="ln2896"> </a>
<a name="ln2897">Measure* Measure::cloneMeasure(Score* sc, const Fraction&amp; tick, TieMap* tieMap)</a>
<a name="ln2898">      {</a>
<a name="ln2899">      Measure* m      = new Measure(sc);</a>
<a name="ln2900">      m-&gt;_timesig     = _timesig;</a>
<a name="ln2901">      m-&gt;_len         = _len;</a>
<a name="ln2902">      m-&gt;_repeatCount = _repeatCount;</a>
<a name="ln2903"> </a>
<a name="ln2904">      Q_ASSERT(sc-&gt;staves().size() &gt;= int(_mstaves.size())); // destination score we're cloning into must have at least as many staves as measure being cloned</a>
<a name="ln2905"> </a>
<a name="ln2906">      m-&gt;setNo(no());</a>
<a name="ln2907">      m-&gt;setNoOffset(noOffset());</a>
<a name="ln2908">      m-&gt;setIrregular(irregular());</a>
<a name="ln2909">      m-&gt;_userStretch           = _userStretch;</a>
<a name="ln2910">      m-&gt;_breakMultiMeasureRest = _breakMultiMeasureRest;</a>
<a name="ln2911">      m-&gt;_playbackCount         = _playbackCount;</a>
<a name="ln2912"> </a>
<a name="ln2913">      m-&gt;setTick(tick);</a>
<a name="ln2914">      m-&gt;setLineBreak(lineBreak());</a>
<a name="ln2915">      m-&gt;setPageBreak(pageBreak());</a>
<a name="ln2916">      m-&gt;setSectionBreak(sectionBreak() ? new LayoutBreak(*sectionBreakElement()) : 0);</a>
<a name="ln2917"> </a>
<a name="ln2918">      m-&gt;setHeader(header()); m-&gt;setTrailer(trailer());</a>
<a name="ln2919"> </a>
<a name="ln2920">      int tracks = sc-&gt;nstaves() * VOICES;</a>
<a name="ln2921">      TupletMap tupletMap;</a>
<a name="ln2922"> </a>
<a name="ln2923">      for (Segment* oseg = first(); oseg; oseg = oseg-&gt;next()) {</a>
<a name="ln2924">            Segment* s = new Segment(m, oseg-&gt;segmentType(), oseg-&gt;rtick());</a>
<a name="ln2925">            s-&gt;setEnabled(oseg-&gt;enabled()); s-&gt;setVisible(oseg-&gt;visible());</a>
<a name="ln2926">            s-&gt;setHeader(oseg-&gt;header()); s-&gt;setTrailer(oseg-&gt;trailer());</a>
<a name="ln2927"> </a>
<a name="ln2928">            m-&gt;_segments.push_back(s);</a>
<a name="ln2929">            for (int track = 0; track &lt; tracks; ++track) {</a>
<a name="ln2930">                  Element* oe = oseg-&gt;element(track);</a>
<a name="ln2931">                  for (Element* e : oseg-&gt;annotations()) {</a>
<a name="ln2932">                        if (e-&gt;generated() || e-&gt;track() != track)</a>
<a name="ln2933">                              continue;</a>
<a name="ln2934">                        Element* ne = e-&gt;clone();</a>
<a name="ln2935">                        ne-&gt;setTrack(track);</a>
<a name="ln2936">                        ne-&gt;setOffset(e-&gt;offset());</a>
<a name="ln2937">                        ne-&gt;setScore(sc);</a>
<a name="ln2938">                        s-&gt;add(ne);</a>
<a name="ln2939">                        }</a>
<a name="ln2940">                  if (!oe)</a>
<a name="ln2941">                        continue;</a>
<a name="ln2942">                  Element* ne = oe-&gt;clone();</a>
<a name="ln2943">                  if (oe-&gt;isChordRest()) {</a>
<a name="ln2944">                        ChordRest* ocr = toChordRest(oe);</a>
<a name="ln2945">                        ChordRest* ncr = toChordRest(ne);</a>
<a name="ln2946">                        Tuplet* ot     = ocr-&gt;tuplet();</a>
<a name="ln2947">                        if (ot) {</a>
<a name="ln2948">                              Tuplet* nt = tupletMap.findNew(ot);</a>
<a name="ln2949">                              if (nt == 0) {</a>
<a name="ln2950">                                    nt = new Tuplet(*ot);</a>
<a name="ln2951">                                    nt-&gt;clear();</a>
<a name="ln2952">                                    nt-&gt;setTrack(track);</a>
<a name="ln2953">                                    nt-&gt;setScore(sc);</a>
<a name="ln2954">                                    nt-&gt;setParent(m);</a>
<a name="ln2955">                                    nt-&gt;setTick(m-&gt;tick() + ot-&gt;rtick());</a>
<a name="ln2956">                                    tupletMap.add(ot, nt);</a>
<a name="ln2957">                                    }</a>
<a name="ln2958">                              ncr-&gt;setTuplet(nt);</a>
<a name="ln2959">                              nt-&gt;add(ncr);</a>
<a name="ln2960">                              }</a>
<a name="ln2961">                        if (oe-&gt;isChord()) {</a>
<a name="ln2962">                              Chord* och = toChord(ocr);</a>
<a name="ln2963">                              Chord* nch = toChord(ncr);</a>
<a name="ln2964">                              size_t n = och-&gt;notes().size();</a>
<a name="ln2965">                              for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln2966">                                    Note* on = och-&gt;notes().at(i);</a>
<a name="ln2967">                                    Note* nn = nch-&gt;notes().at(i);</a>
<a name="ln2968">                                    if (on-&gt;tieFor()) {</a>
<a name="ln2969">                                          Tie* tie = on-&gt;tieFor()-&gt;clone();</a>
<a name="ln2970">                                          tie-&gt;setScore(sc);</a>
<a name="ln2971">                                          nn-&gt;setTieFor(tie);</a>
<a name="ln2972">                                          tie-&gt;setStartNote(nn);</a>
<a name="ln2973">                                          tieMap-&gt;add(on-&gt;tieFor(), tie);</a>
<a name="ln2974">                                          }</a>
<a name="ln2975">                                    if (on-&gt;tieBack()) {</a>
<a name="ln2976">                                          Tie* tie = tieMap-&gt;findNew(on-&gt;tieBack());</a>
<a name="ln2977">                                          if (tie) {</a>
<a name="ln2978">                                                nn-&gt;setTieBack(tie);</a>
<a name="ln2979">                                                tie-&gt;setEndNote(nn);</a>
<a name="ln2980">                                                }</a>
<a name="ln2981">                                          else {</a>
<a name="ln2982">                                                qDebug(&quot;cloneMeasure: cannot find tie, track %d&quot;, track);</a>
<a name="ln2983">                                                }</a>
<a name="ln2984">                                          }</a>
<a name="ln2985">                                    }</a>
<a name="ln2986">                              }</a>
<a name="ln2987">                        }</a>
<a name="ln2988">                  ne-&gt;setOffset(oe-&gt;offset());</a>
<a name="ln2989">                  ne-&gt;setScore(sc);</a>
<a name="ln2990">                  s-&gt;add(ne);</a>
<a name="ln2991">                  }</a>
<a name="ln2992">            }</a>
<a name="ln2993">      foreach(Element* e, el()) {</a>
<a name="ln2994">            Element* ne = e-&gt;clone();</a>
<a name="ln2995">            ne-&gt;setScore(sc);</a>
<a name="ln2996">            ne-&gt;setOffset(e-&gt;offset());</a>
<a name="ln2997">            m-&gt;add(ne);</a>
<a name="ln2998">            }</a>
<a name="ln2999">      return m;</a>
<a name="ln3000">      }</a>
<a name="ln3001"> </a>
<a name="ln3002">//---------------------------------------------------------</a>
<a name="ln3003">//   snap</a>
<a name="ln3004">//---------------------------------------------------------</a>
<a name="ln3005"> </a>
<a name="ln3006">Fraction Measure::snap(const Fraction&amp; tick, const QPointF p) const</a>
<a name="ln3007">      {</a>
<a name="ln3008">      Segment* s = first();</a>
<a name="ln3009">      for (; s-&gt;next(); s = s-&gt;next()) {</a>
<a name="ln3010">            qreal x  = s-&gt;x();</a>
<a name="ln3011">            qreal dx = s-&gt;next()-&gt;x() - x;</a>
<a name="ln3012">            if (s-&gt;tick() == tick)</a>
<a name="ln3013">                  x += dx / 3.0 * 2.0;</a>
<a name="ln3014">            else  if (s-&gt;next()-&gt;tick() == tick)</a>
<a name="ln3015">                  x += dx / 3.0;</a>
<a name="ln3016">            else</a>
<a name="ln3017">                  x += dx * .5;</a>
<a name="ln3018">            if (p.x() &lt; x)</a>
<a name="ln3019">                  break;</a>
<a name="ln3020">            }</a>
<a name="ln3021">      return s-&gt;tick();</a>
<a name="ln3022">      }</a>
<a name="ln3023"> </a>
<a name="ln3024">//---------------------------------------------------------</a>
<a name="ln3025">//   snapNote</a>
<a name="ln3026">//---------------------------------------------------------</a>
<a name="ln3027"> </a>
<a name="ln3028">Fraction Measure::snapNote(const Fraction&amp; /*tick*/, const QPointF p, int staff) const</a>
<a name="ln3029">      {</a>
<a name="ln3030">      Segment* s = first();</a>
<a name="ln3031">      for (;;) {</a>
<a name="ln3032">            Segment* ns = s-&gt;next();</a>
<a name="ln3033">            while (ns &amp;&amp; ns-&gt;element(staff) == 0)</a>
<a name="ln3034">                  ns = ns-&gt;next();</a>
<a name="ln3035">            if (ns == 0)</a>
<a name="ln3036">                  break;</a>
<a name="ln3037">            qreal x  = s-&gt;x();</a>
<a name="ln3038">            qreal nx = x + (ns-&gt;x() - x) * .5;</a>
<a name="ln3039">            if (p.x() &lt; nx)</a>
<a name="ln3040">                  break;</a>
<a name="ln3041">            s = ns;</a>
<a name="ln3042">            }</a>
<a name="ln3043">      return s-&gt;tick();</a>
<a name="ln3044">      }</a>
<a name="ln3045"> </a>
<a name="ln3046">//---------------------------------------------------------</a>
<a name="ln3047">//   getProperty</a>
<a name="ln3048">//---------------------------------------------------------</a>
<a name="ln3049"> </a>
<a name="ln3050">QVariant Measure::getProperty(Pid propertyId) const</a>
<a name="ln3051">      {</a>
<a name="ln3052">      switch(propertyId) {</a>
<a name="ln3053">            case Pid::TIMESIG_NOMINAL:</a>
<a name="ln3054">                  return QVariant::fromValue(_timesig);</a>
<a name="ln3055">            case Pid::TIMESIG_ACTUAL:</a>
<a name="ln3056">                  return QVariant::fromValue(_len);</a>
<a name="ln3057">            case Pid::MEASURE_NUMBER_MODE:</a>
<a name="ln3058">                  return int(measureNumberMode());</a>
<a name="ln3059">            case Pid::BREAK_MMR:</a>
<a name="ln3060">                  return breakMultiMeasureRest();</a>
<a name="ln3061">            case Pid::REPEAT_COUNT:</a>
<a name="ln3062">                  return repeatCount();</a>
<a name="ln3063">            case Pid::USER_STRETCH:</a>
<a name="ln3064">                  return userStretch();</a>
<a name="ln3065">            default:</a>
<a name="ln3066">                  return MeasureBase::getProperty(propertyId);</a>
<a name="ln3067">            }</a>
<a name="ln3068">      }</a>
<a name="ln3069"> </a>
<a name="ln3070">//---------------------------------------------------------</a>
<a name="ln3071">//   setProperty</a>
<a name="ln3072">//---------------------------------------------------------</a>
<a name="ln3073"> </a>
<a name="ln3074">bool Measure::setProperty(Pid propertyId, const QVariant&amp; value)</a>
<a name="ln3075">      {</a>
<a name="ln3076">      switch (propertyId) {</a>
<a name="ln3077">            case Pid::TIMESIG_NOMINAL:</a>
<a name="ln3078">                  _timesig = value.value&lt;Fraction&gt;();</a>
<a name="ln3079">                  break;</a>
<a name="ln3080">            case Pid::TIMESIG_ACTUAL:</a>
<a name="ln3081">                  _len = value.value&lt;Fraction&gt;();</a>
<a name="ln3082">                  break;</a>
<a name="ln3083">            case Pid::MEASURE_NUMBER_MODE:</a>
<a name="ln3084">                  setMeasureNumberMode(MeasureNumberMode(value.toInt()));</a>
<a name="ln3085">                  break;</a>
<a name="ln3086">            case Pid::BREAK_MMR:</a>
<a name="ln3087">                  setBreakMultiMeasureRest(value.toBool());</a>
<a name="ln3088">                  break;</a>
<a name="ln3089">            case Pid::REPEAT_COUNT:</a>
<a name="ln3090">                  setRepeatCount(value.toInt());</a>
<a name="ln3091">                  break;</a>
<a name="ln3092">            case Pid::USER_STRETCH:</a>
<a name="ln3093">                  setUserStretch(value.toDouble());</a>
<a name="ln3094">                  break;</a>
<a name="ln3095">            default:</a>
<a name="ln3096">                  return MeasureBase::setProperty(propertyId, value);</a>
<a name="ln3097">            }</a>
<a name="ln3098">      triggerLayout();</a>
<a name="ln3099">      return true;</a>
<a name="ln3100">      }</a>
<a name="ln3101"> </a>
<a name="ln3102">//---------------------------------------------------------</a>
<a name="ln3103">//   propertyDefault</a>
<a name="ln3104">//---------------------------------------------------------</a>
<a name="ln3105"> </a>
<a name="ln3106">QVariant Measure::propertyDefault(Pid propertyId) const</a>
<a name="ln3107">      {</a>
<a name="ln3108">      switch(propertyId) {</a>
<a name="ln3109">            case Pid::TIMESIG_NOMINAL:</a>
<a name="ln3110">            case Pid::TIMESIG_ACTUAL:</a>
<a name="ln3111">                  return QVariant();</a>
<a name="ln3112">            case Pid::MEASURE_NUMBER_MODE:</a>
<a name="ln3113">                  return int(MeasureNumberMode::AUTO);</a>
<a name="ln3114">            case Pid::BREAK_MMR:</a>
<a name="ln3115">                  return false;</a>
<a name="ln3116">            case Pid::REPEAT_COUNT:</a>
<a name="ln3117">                  return 2;</a>
<a name="ln3118">            case Pid::USER_STRETCH:</a>
<a name="ln3119">                  return 1.0;</a>
<a name="ln3120">            case Pid::NO_OFFSET:</a>
<a name="ln3121">                  return 0;</a>
<a name="ln3122">            case Pid::IRREGULAR:</a>
<a name="ln3123">                  return false;</a>
<a name="ln3124">            default:</a>
<a name="ln3125">                  break;</a>
<a name="ln3126">            }</a>
<a name="ln3127">      return MeasureBase::propertyDefault(propertyId);</a>
<a name="ln3128">      }</a>
<a name="ln3129"> </a>
<a name="ln3130">//-------------------------------------------------------------------</a>
<a name="ln3131">//   mmRestFirst</a>
<a name="ln3132">//    this is a multi measure rest</a>
<a name="ln3133">//    returns first measure of replaced sequence of empty measures</a>
<a name="ln3134">//-------------------------------------------------------------------</a>
<a name="ln3135"> </a>
<a name="ln3136">Measure* Measure::mmRestFirst() const</a>
<a name="ln3137">      {</a>
<a name="ln3138">      Q_ASSERT(isMMRest());</a>
<a name="ln3139">      if (prev())</a>
<a name="ln3140">            return toMeasure(prev()-&gt;next());</a>
<a name="ln3141">      return score()-&gt;firstMeasure();</a>
<a name="ln3142">      }</a>
<a name="ln3143"> </a>
<a name="ln3144">//-------------------------------------------------------------------</a>
<a name="ln3145">//   mmRestLast</a>
<a name="ln3146">//    this is a multi measure rest</a>
<a name="ln3147">//    returns last measure of replaced sequence of empty measures</a>
<a name="ln3148">//-------------------------------------------------------------------</a>
<a name="ln3149"> </a>
<a name="ln3150">Measure* Measure::mmRestLast() const</a>
<a name="ln3151">      {</a>
<a name="ln3152">      Q_ASSERT(isMMRest());</a>
<a name="ln3153">      if (next())</a>
<a name="ln3154">            return toMeasure(next()-&gt;prev());</a>
<a name="ln3155">      return score()-&gt;lastMeasure();</a>
<a name="ln3156">      }</a>
<a name="ln3157"> </a>
<a name="ln3158">//---------------------------------------------------------</a>
<a name="ln3159">//   mmRest1</a>
<a name="ln3160">//    return the multi measure rest this measure is covered</a>
<a name="ln3161">//    by</a>
<a name="ln3162">//---------------------------------------------------------</a>
<a name="ln3163"> </a>
<a name="ln3164">const Measure* Measure::mmRest1() const</a>
<a name="ln3165">      {</a>
<a name="ln3166">      if (_mmRest)</a>
<a name="ln3167">            return _mmRest;</a>
<a name="ln3168">      if (_mmRestCount != -1)</a>
<a name="ln3169">            // return const_cast&lt;Measure*&gt;(this);</a>
<a name="ln3170">            return this;</a>
<a name="ln3171">      const Measure* m = this;</a>
<a name="ln3172">      while (m &amp;&amp; !m-&gt;_mmRest)</a>
<a name="ln3173">            m = m-&gt;prevMeasure();</a>
<a name="ln3174">      if (m)</a>
<a name="ln3175">            return const_cast&lt;Measure*&gt;(m-&gt;_mmRest);</a>
<a name="ln3176">      return 0;</a>
<a name="ln3177">      }</a>
<a name="ln3178"> </a>
<a name="ln3179">//-------------------------------------------------------------------</a>
<a name="ln3180">//   userStretch</a>
<a name="ln3181">//-------------------------------------------------------------------</a>
<a name="ln3182"> </a>
<a name="ln3183">qreal Measure::userStretch() const</a>
<a name="ln3184">      {</a>
<a name="ln3185">      return (score()-&gt;layoutMode() == LayoutMode::FLOAT ? 1.0 : _userStretch);</a>
<a name="ln3186">      }</a>
<a name="ln3187"> </a>
<a name="ln3188">//---------------------------------------------------------</a>
<a name="ln3189">//   nextElementStaff</a>
<a name="ln3190">//---------------------------------------------------------</a>
<a name="ln3191"> </a>
<a name="ln3192">Element* Measure::nextElementStaff(int staff)</a>
<a name="ln3193">      {</a>
<a name="ln3194">      Element* e = score()-&gt;selection().element();</a>
<a name="ln3195">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty())</a>
<a name="ln3196">            e = score()-&gt;selection().elements().first();</a>
<a name="ln3197"> </a>
<a name="ln3198">      // handle measure elements</a>
<a name="ln3199">      if (e-&gt;parent() == this) {</a>
<a name="ln3200">            auto i = std::find(el().begin(), el().end(), e);</a>
<a name="ln3201">            if (i != el().end()) {</a>
<a name="ln3202">                  if (++i != el().end()) {</a>
<a name="ln3203">                        Element* resElement = *i;</a>
<a name="ln3204">                        if (resElement)</a>
<a name="ln3205">                              return resElement;</a>
<a name="ln3206">                        }</a>
<a name="ln3207">                  }</a>
<a name="ln3208">            }</a>
<a name="ln3209"> </a>
<a name="ln3210">      for (; e &amp;&amp; e-&gt;type() != ElementType::SEGMENT; e = e-&gt;parent()) {</a>
<a name="ln3211">            ;</a>
<a name="ln3212">      }</a>
<a name="ln3213">      Segment* seg = toSegment(e);</a>
<a name="ln3214">      Segment* nextSegment = seg ? seg-&gt;next() : first();</a>
<a name="ln3215">      Element* next = seg-&gt;firstElementOfSegment(nextSegment, staff);</a>
<a name="ln3216">      if (next)</a>
<a name="ln3217">            return next;</a>
<a name="ln3218"> </a>
<a name="ln3219">      return score()-&gt;lastElement();</a>
<a name="ln3220">      }</a>
<a name="ln3221"> </a>
<a name="ln3222">//---------------------------------------------------------</a>
<a name="ln3223">//   prevElementStaff</a>
<a name="ln3224">//---------------------------------------------------------</a>
<a name="ln3225"> </a>
<a name="ln3226">Element* Measure::prevElementStaff(int staff)</a>
<a name="ln3227">      {</a>
<a name="ln3228">      Element* e = score()-&gt;selection().element();</a>
<a name="ln3229">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty())</a>
<a name="ln3230">            e = score()-&gt;selection().elements().first();</a>
<a name="ln3231"> </a>
<a name="ln3232">      // handle measure elements</a>
<a name="ln3233">      if (e-&gt;parent() == this) {</a>
<a name="ln3234">            auto i = std::find(el().rbegin(), el().rend(), e);</a>
<a name="ln3235">            if (i != el().rend()) {</a>
<a name="ln3236">                  if (++i != el().rend()) {</a>
<a name="ln3237">                        Element* resElement = *i;</a>
<a name="ln3238">                        if (resElement)</a>
<a name="ln3239">                              return resElement;</a>
<a name="ln3240">                        }</a>
<a name="ln3241">                  }</a>
<a name="ln3242">            }</a>
<a name="ln3243"> </a>
<a name="ln3244">      Measure* prevM = prevMeasureMM();</a>
<a name="ln3245">      if (prevM) {</a>
<a name="ln3246">            Segment* seg = prevM-&gt;last();</a>
<a name="ln3247">            if (seg)</a>
<a name="ln3248">                  return seg-&gt;lastElement(staff);</a>
<a name="ln3249">            }</a>
<a name="ln3250">      return score()-&gt;firstElement();</a>
<a name="ln3251">      }</a>
<a name="ln3252"> </a>
<a name="ln3253">//---------------------------------------------------------</a>
<a name="ln3254">//   accessibleInfo</a>
<a name="ln3255">//---------------------------------------------------------</a>
<a name="ln3256"> </a>
<a name="ln3257">QString Measure::accessibleInfo() const</a>
<a name="ln3258">      {</a>
<a name="ln3259">      return QString(&quot;%1: %2&quot;).arg(Element::accessibleInfo()).arg(QString::number(no() + 1));</a>
<a name="ln3260">      }</a>
<a name="ln3261"> </a>
<a name="ln3262">//-----------------------------------------------------------------------------</a>
<a name="ln3263">//    stretchMeasure</a>
<a name="ln3264">//    resize width of measure to targetWidth</a>
<a name="ln3265">//-----------------------------------------------------------------------------</a>
<a name="ln3266"> </a>
<a name="ln3267">void Measure::stretchMeasure(qreal targetWidth)</a>
<a name="ln3268">      {</a>
<a name="ln3269">      bbox().setWidth(targetWidth);</a>
<a name="ln3270"> </a>
<a name="ln3271">      Fraction minTick = computeTicks();</a>
<a name="ln3272"> </a>
<a name="ln3273">      //---------------------------------------------------</a>
<a name="ln3274">      //    compute stretch</a>
<a name="ln3275">      //---------------------------------------------------</a>
<a name="ln3276"> </a>
<a name="ln3277">      std::multimap&lt;qreal, Segment*&gt; springs;</a>
<a name="ln3278"> </a>
<a name="ln3279">      Segment* seg = first();</a>
<a name="ln3280">      while (seg &amp;&amp; !seg-&gt;enabled())</a>
<a name="ln3281">            seg = seg-&gt;next();</a>
<a name="ln3282">      qreal minimumWidth = seg ? seg-&gt;x() : 0.0;</a>
<a name="ln3283">      for (Segment&amp; s : _segments) {</a>
<a name="ln3284">            if (!s.enabled() || !s.visible())</a>
<a name="ln3285">                  continue;</a>
<a name="ln3286">            Fraction t = s.ticks();</a>
<a name="ln3287">            if (t.isNotZero()) {</a>
<a name="ln3288">                  qreal str = 1.0 + 0.865617 * log(qreal(t.ticks()) / qreal(minTick.ticks())); // .6 * log(t / minTick.ticks()) / log(2);</a>
<a name="ln3289">                  qreal d   = s.width() / str;</a>
<a name="ln3290">                  s.setStretch(str);</a>
<a name="ln3291">                  springs.insert(std::pair&lt;qreal, Segment*&gt;(d, &amp;s));</a>
<a name="ln3292">                  }</a>
<a name="ln3293">            minimumWidth += s.width();</a>
<a name="ln3294">            }</a>
<a name="ln3295"> </a>
<a name="ln3296">      //---------------------------------------------------</a>
<a name="ln3297">      //    compute 1/Force for a given Extend</a>
<a name="ln3298">      //---------------------------------------------------</a>
<a name="ln3299"> </a>
<a name="ln3300">      if (targetWidth &gt; minimumWidth) {</a>
<a name="ln3301">            qreal force = 0;</a>
<a name="ln3302">            qreal c     = 0.0;</a>
<a name="ln3303">            for (auto i = springs.begin(); i != springs.end();) {</a>
<a name="ln3304">                  c            += i-&gt;second-&gt;stretch();</a>
<a name="ln3305">                  minimumWidth -= i-&gt;second-&gt;width();</a>
<a name="ln3306">                  qreal f       = (targetWidth - minimumWidth) / c;</a>
<a name="ln3307">                  ++i;</a>
<a name="ln3308">                  if (i == springs.end() || f &lt;= i-&gt;first) {</a>
<a name="ln3309">                        force = f;</a>
<a name="ln3310">                        break;</a>
<a name="ln3311">                        }</a>
<a name="ln3312">                  }</a>
<a name="ln3313"> </a>
<a name="ln3314">            //---------------------------------------------------</a>
<a name="ln3315">            //    distribute stretch to segments</a>
<a name="ln3316">            //---------------------------------------------------</a>
<a name="ln3317"> </a>
<a name="ln3318">            for (auto&amp; i : springs) {</a>
<a name="ln3319">                  qreal width = force * i.second-&gt;stretch();</a>
<a name="ln3320">                  if (width &gt; i.second-&gt;width())</a>
<a name="ln3321">                        i.second-&gt;setWidth(width);</a>
<a name="ln3322">                  }</a>
<a name="ln3323"> </a>
<a name="ln3324">            //---------------------------------------------------</a>
<a name="ln3325">            //    move segments to final position</a>
<a name="ln3326">            //---------------------------------------------------</a>
<a name="ln3327"> </a>
<a name="ln3328">            Segment* s = first();</a>
<a name="ln3329">            while (s &amp;&amp; !s-&gt;enabled())</a>
<a name="ln3330">                  s = s-&gt;next();</a>
<a name="ln3331">            qreal x = s-&gt;pos().x();</a>
<a name="ln3332">            while (s) {</a>
<a name="ln3333">                  s-&gt;rxpos() = x;</a>
<a name="ln3334">                  x += s-&gt;width();</a>
<a name="ln3335">                  s = s-&gt;nextEnabled();</a>
<a name="ln3336">                  }</a>
<a name="ln3337">            }</a>
<a name="ln3338"> </a>
<a name="ln3339">      //---------------------------------------------------</a>
<a name="ln3340">      //    layout individual elements</a>
<a name="ln3341">      //---------------------------------------------------</a>
<a name="ln3342"> </a>
<a name="ln3343">      for (Segment&amp; s : _segments) {</a>
<a name="ln3344">            if (!s.enabled())</a>
<a name="ln3345">                  continue;</a>
<a name="ln3346">            for (Element* e : s.elist()) {</a>
<a name="ln3347">                  if (!e)</a>
<a name="ln3348">                        continue;</a>
<a name="ln3349">                  ElementType t = e-&gt;type();</a>
<a name="ln3350">                  int staffIdx    = e-&gt;staffIdx();</a>
<a name="ln3351">                  if (t == ElementType::REPEAT_MEASURE || (t == ElementType::REST &amp;&amp; (isMMRest() || toRest(e)-&gt;isFullMeasureRest()))) {</a>
<a name="ln3352">                        //</a>
<a name="ln3353">                        // element has to be centered in free space</a>
<a name="ln3354">                        //    x1 - left measure position of free space</a>
<a name="ln3355">                        //    x2 - right measure position of free space</a>
<a name="ln3356"> </a>
<a name="ln3357">                        Segment* s1;</a>
<a name="ln3358">                        for (s1 = s.prev(); s1 &amp;&amp; !s1-&gt;enabled(); s1 = s1-&gt;prev())</a>
<a name="ln3359">                              ;</a>
<a name="ln3360">                        Segment* s2;</a>
<a name="ln3361">                        for (s2 = s.next(); s2; s2 = s2-&gt;next()) {</a>
<a name="ln3362">                              if (s2-&gt;enabled() &amp;&amp; !s2-&gt;isChordRestType() &amp;&amp; s2-&gt;element(staffIdx * VOICES))</a>
<a name="ln3363">                                    break;</a>
<a name="ln3364">                              }</a>
<a name="ln3365">                        qreal x1 = s1 ? s1-&gt;x() + s1-&gt;minRight() : 0;</a>
<a name="ln3366">                        qreal x2 = s2 ? s2-&gt;x() - s2-&gt;minLeft() : targetWidth;</a>
<a name="ln3367"> </a>
<a name="ln3368">                        if (isMMRest()) {</a>
<a name="ln3369">                              Rest* rest = toRest(e);</a>
<a name="ln3370">                              //</a>
<a name="ln3371">                              // center multi measure rest</a>
<a name="ln3372">                              //</a>
<a name="ln3373">                              qreal d = score()-&gt;styleP(Sid::multiMeasureRestMargin);</a>
<a name="ln3374">                              qreal w = x2 - x1 - 2 * d;</a>
<a name="ln3375"> </a>
<a name="ln3376">                              rest-&gt;layoutMMRest(w);</a>
<a name="ln3377">                              e-&gt;setPos(x1 - s.x() + d, e-&gt;staff()-&gt;height() * .5);   // center vertically in measure</a>
<a name="ln3378">                              s.createShape(staffIdx);</a>
<a name="ln3379">                              }</a>
<a name="ln3380">                        else { // if (rest-&gt;isFullMeasureRest()) {</a>
<a name="ln3381">                              //</a>
<a name="ln3382">                              // center full measure rest</a>
<a name="ln3383">                              //</a>
<a name="ln3384">                              e-&gt;rxpos() = (x2 - x1 - e-&gt;width()) * .5 + x1 - s.x() - e-&gt;bbox().x();</a>
<a name="ln3385">                              s.createShape(staffIdx);  // DEBUG</a>
<a name="ln3386">                              }</a>
<a name="ln3387">                        }</a>
<a name="ln3388">                  else if (t == ElementType::REST)</a>
<a name="ln3389">                        e-&gt;rxpos() = 0;</a>
<a name="ln3390">                  else if (t == ElementType::CHORD) {</a>
<a name="ln3391">                        Chord* c = toChord(e);</a>
<a name="ln3392">                        c-&gt;layout2();</a>
<a name="ln3393">                        if (c-&gt;tremolo()) {</a>
<a name="ln3394">                              Tremolo* tr = c-&gt;tremolo();</a>
<a name="ln3395">                              Chord* c1 = tr-&gt;chord1();</a>
<a name="ln3396">                              Chord* c2 = tr-&gt;chord2();</a>
<a name="ln3397">                              if (!tr-&gt;twoNotes() || (c1 &amp;&amp; !c1-&gt;staffMove() &amp;&amp; c2 &amp;&amp; !c2-&gt;staffMove()))</a>
<a name="ln3398">                                    tr-&gt;layout();</a>
<a name="ln3399">                              }</a>
<a name="ln3400">                        }</a>
<a name="ln3401">                  else if (t == ElementType::BAR_LINE) {</a>
<a name="ln3402">                        e-&gt;rypos() = 0.0;</a>
<a name="ln3403">                        // for end barlines, x position was set in createEndBarLines</a>
<a name="ln3404">                        if (s.segmentType() != SegmentType::EndBarLine)</a>
<a name="ln3405">                              e-&gt;rxpos() = 0.0;</a>
<a name="ln3406">                        }</a>
<a name="ln3407">                  }</a>
<a name="ln3408">            }</a>
<a name="ln3409">      }</a>
<a name="ln3410"> </a>
<a name="ln3411">//---------------------------------------------------</a>
<a name="ln3412">//    computeTicks</a>
<a name="ln3413">//    set ticks for all segments</a>
<a name="ln3414">//       return minTick</a>
<a name="ln3415">//---------------------------------------------------</a>
<a name="ln3416"> </a>
<a name="ln3417">Fraction Measure::computeTicks()</a>
<a name="ln3418">      {</a>
<a name="ln3419">      Fraction minTick = ticks();</a>
<a name="ln3420">      if (minTick &lt;= Fraction(0,1)) {</a>
<a name="ln3421">            qDebug(&quot;=====minTick %d measure %p&quot;, minTick.ticks(), this);</a>
<a name="ln3422">            }</a>
<a name="ln3423">      Q_ASSERT(minTick &gt; Fraction(0,1));</a>
<a name="ln3424"> </a>
<a name="ln3425">      Segment* ns = first();</a>
<a name="ln3426">      while (ns &amp;&amp; !ns-&gt;enabled())</a>
<a name="ln3427">            ns = ns-&gt;next();</a>
<a name="ln3428">      while (ns) {</a>
<a name="ln3429">            Segment* s = ns;</a>
<a name="ln3430">            ns         = s-&gt;nextActive();</a>
<a name="ln3431">            Fraction nticks = (ns ? ns-&gt;rtick() : ticks()) - s-&gt;rtick();</a>
<a name="ln3432">            if (nticks.isNotZero()) {</a>
<a name="ln3433">                  if (nticks &lt; minTick)</a>
<a name="ln3434">                        minTick = nticks;</a>
<a name="ln3435">                  }</a>
<a name="ln3436">            s-&gt;setTicks(nticks);</a>
<a name="ln3437">            }</a>
<a name="ln3438">      return minTick;</a>
<a name="ln3439">      }</a>
<a name="ln3440"> </a>
<a name="ln3441">//---------------------------------------------------------</a>
<a name="ln3442">//   endBarLine</a>
<a name="ln3443">//      return the first one</a>
<a name="ln3444">//---------------------------------------------------------</a>
<a name="ln3445"> </a>
<a name="ln3446">const BarLine* Measure::endBarLine() const</a>
<a name="ln3447">      {</a>
<a name="ln3448">      // search barline segment:</a>
<a name="ln3449">      Segment* s = last();</a>
<a name="ln3450">      while (s &amp;&amp; !s-&gt;isEndBarLineType())</a>
<a name="ln3451">            s = s-&gt;prev();</a>
<a name="ln3452">      // search first element</a>
<a name="ln3453">      if (s) {</a>
<a name="ln3454">            for (const Element* e : s-&gt;elist()) {</a>
<a name="ln3455">                  if (e)</a>
<a name="ln3456">                        return toBarLine(e);</a>
<a name="ln3457">                  }</a>
<a name="ln3458">            }</a>
<a name="ln3459">      return 0;</a>
<a name="ln3460">      }</a>
<a name="ln3461"> </a>
<a name="ln3462">//---------------------------------------------------------</a>
<a name="ln3463">//   endBarLineType</a>
<a name="ln3464">//    Assume all barlines have same type if there is more</a>
<a name="ln3465">//    than one.</a>
<a name="ln3466">//---------------------------------------------------------</a>
<a name="ln3467"> </a>
<a name="ln3468">BarLineType Measure::endBarLineType() const</a>
<a name="ln3469">      {</a>
<a name="ln3470">      const BarLine* bl = endBarLine();</a>
<a name="ln3471">      return bl ? bl-&gt;barLineType() : BarLineType::NORMAL;</a>
<a name="ln3472">      }</a>
<a name="ln3473"> </a>
<a name="ln3474">//---------------------------------------------------------</a>
<a name="ln3475">//   endBarLineType</a>
<a name="ln3476">//    Assume all barlines have same visibility if there is more</a>
<a name="ln3477">//    than one.</a>
<a name="ln3478">//---------------------------------------------------------</a>
<a name="ln3479"> </a>
<a name="ln3480">bool Measure::endBarLineVisible() const</a>
<a name="ln3481">      {</a>
<a name="ln3482">      const BarLine* bl = endBarLine();</a>
<a name="ln3483">      return bl ? bl-&gt;visible() : true;</a>
<a name="ln3484">      }</a>
<a name="ln3485"> </a>
<a name="ln3486">//---------------------------------------------------------</a>
<a name="ln3487">//   triggerLayout</a>
<a name="ln3488">//---------------------------------------------------------</a>
<a name="ln3489"> </a>
<a name="ln3490">void Measure::triggerLayout() const</a>
<a name="ln3491">      {</a>
<a name="ln3492">      if (prev() || next()) // avoid triggering layout before getting added to a score</a>
<a name="ln3493">            score()-&gt;setLayout(tick(), endTick(), 0, score()-&gt;nstaves() - 1, this);</a>
<a name="ln3494">      }</a>
<a name="ln3495"> </a>
<a name="ln3496">//---------------------------------------------------------</a>
<a name="ln3497">//   setEndBarLineType</a>
<a name="ln3498">//     Create a *generated* barline with the given type and</a>
<a name="ln3499">//     properties if none exists. Modify if it exists.</a>
<a name="ln3500">//     Useful for import filters.</a>
<a name="ln3501">//---------------------------------------------------------</a>
<a name="ln3502"> </a>
<a name="ln3503">void Measure::setEndBarLineType(BarLineType val, int track, bool visible, QColor color)</a>
<a name="ln3504">      {</a>
<a name="ln3505">      Segment* seg = undoGetSegment(SegmentType::EndBarLine, endTick());</a>
<a name="ln3506">      // get existing bar line for this staff, if any</a>
<a name="ln3507">      BarLine* bl = toBarLine(seg-&gt;element(track));</a>
<a name="ln3508">      if (!bl) {</a>
<a name="ln3509">            // no suitable bar line: create a new one</a>
<a name="ln3510">            bl = new BarLine(score());</a>
<a name="ln3511">            bl-&gt;setParent(seg);</a>
<a name="ln3512">            bl-&gt;setTrack(track);</a>
<a name="ln3513">            score()-&gt;addElement(bl);</a>
<a name="ln3514">            }</a>
<a name="ln3515">      bl-&gt;setGenerated(false);</a>
<a name="ln3516">      bl-&gt;setBarLineType(val);</a>
<a name="ln3517">      bl-&gt;setVisible(visible);</a>
<a name="ln3518">      bl-&gt;setColor(color.isValid() ? color : curColor());</a>
<a name="ln3519">      }</a>
<a name="ln3520"> </a>
<a name="ln3521">//---------------------------------------------------------</a>
<a name="ln3522">//   barLinesSetSpan</a>
<a name="ln3523">//---------------------------------------------------------</a>
<a name="ln3524"> </a>
<a name="ln3525">void Measure::barLinesSetSpan(Segment* seg)</a>
<a name="ln3526">      {</a>
<a name="ln3527">      int track = 0;</a>
<a name="ln3528">      for (Staff* staff : score()-&gt;staves()) {</a>
<a name="ln3529">            BarLine* bl = toBarLine(seg-&gt;element(track));  // get existing bar line for this staff, if any</a>
<a name="ln3530">            if (bl) {</a>
<a name="ln3531">                  if (bl-&gt;generated()) {</a>
<a name="ln3532">                        bl-&gt;setSpanStaff(staff-&gt;barLineSpan());</a>
<a name="ln3533">                        bl-&gt;setSpanFrom(staff-&gt;barLineFrom());</a>
<a name="ln3534">                        bl-&gt;setSpanTo(staff-&gt;barLineTo());</a>
<a name="ln3535">                        }</a>
<a name="ln3536">                  }</a>
<a name="ln3537">            else {</a>
<a name="ln3538">                  bl = new BarLine(score());</a>
<a name="ln3539">                  bl-&gt;setParent(seg);</a>
<a name="ln3540">                  bl-&gt;setTrack(track);</a>
<a name="ln3541">                  bl-&gt;setGenerated(true);</a>
<a name="ln3542">                  bl-&gt;setSpanStaff(staff-&gt;barLineSpan());</a>
<a name="ln3543">                  bl-&gt;setSpanFrom(staff-&gt;barLineFrom());</a>
<a name="ln3544">                  bl-&gt;setSpanTo(staff-&gt;barLineTo());</a>
<a name="ln3545">                  bl-&gt;layout();</a>
<a name="ln3546">                  score()-&gt;addElement(bl);</a>
<a name="ln3547">                  }</a>
<a name="ln3548">            track += VOICES;</a>
<a name="ln3549">            }</a>
<a name="ln3550">      }</a>
<a name="ln3551"> </a>
<a name="ln3552">//---------------------------------------------------------</a>
<a name="ln3553">//   createEndBarLines</a>
<a name="ln3554">//    actually creates or modifies barlines</a>
<a name="ln3555">//    return the width change for measure</a>
<a name="ln3556">//---------------------------------------------------------</a>
<a name="ln3557"> </a>
<a name="ln3558">qreal Measure::createEndBarLines(bool isLastMeasureInSystem)</a>
<a name="ln3559">      {</a>
<a name="ln3560">      int nstaves  = score()-&gt;nstaves();</a>
<a name="ln3561">      Segment* seg = findSegmentR(SegmentType::EndBarLine, ticks());</a>
<a name="ln3562">      Measure* nm  = nextMeasure();</a>
<a name="ln3563">      qreal blw    = 0.0;</a>
<a name="ln3564"> </a>
<a name="ln3565">#if 0</a>
<a name="ln3566">#ifndef NDEBUG</a>
<a name="ln3567">      computeMinWidth();</a>
<a name="ln3568">#endif</a>
<a name="ln3569">#endif</a>
<a name="ln3570">      qreal oldWidth = width();</a>
<a name="ln3571"> </a>
<a name="ln3572">      if (nm &amp;&amp; nm-&gt;repeatStart() &amp;&amp; !repeatEnd() &amp;&amp; !isLastMeasureInSystem &amp;&amp; next() == nm) {</a>
<a name="ln3573">            // we may skip barline at end of a measure immediately before a start repeat:</a>
<a name="ln3574">            // next measure is repeat start, this measure is not a repeat end,</a>
<a name="ln3575">            // this is not last measure of system, no intervening frame</a>
<a name="ln3576">            if (!seg)</a>
<a name="ln3577">                  return 0.0;</a>
<a name="ln3578">            seg-&gt;setEnabled(false);</a>
<a name="ln3579">            }</a>
<a name="ln3580">      else {</a>
<a name="ln3581">            BarLineType t = nm ? BarLineType::NORMAL : BarLineType::END;</a>
<a name="ln3582">            if (!seg)</a>
<a name="ln3583">                  seg = getSegmentR(SegmentType::EndBarLine, ticks());</a>
<a name="ln3584">            seg-&gt;setEnabled(true);</a>
<a name="ln3585">            //</a>
<a name="ln3586">            //  Set flag &quot;hasCourtesyKeySig&quot; if this measure needs a courtesy key sig.</a>
<a name="ln3587">            //  This flag is later used to set a double end bar line and to actually</a>
<a name="ln3588">            //  create the courtesy key sig.</a>
<a name="ln3589">            //</a>
<a name="ln3590"> </a>
<a name="ln3591">            bool show = score()-&gt;styleB(Sid::genCourtesyKeysig) &amp;&amp; !sectionBreak() &amp;&amp; nm;</a>
<a name="ln3592"> </a>
<a name="ln3593">            setHasCourtesyKeySig(false);</a>
<a name="ln3594"> </a>
<a name="ln3595">            if (isLastMeasureInSystem &amp;&amp; show) {</a>
<a name="ln3596">                  Fraction tick = endTick();</a>
<a name="ln3597">                  for (int staffIdx = 0; staffIdx &lt; nstaves; ++staffIdx) {</a>
<a name="ln3598">                        Staff* staff     = score()-&gt;staff(staffIdx);</a>
<a name="ln3599">                        KeySigEvent key1 = staff-&gt;keySigEvent(tick - Fraction::fromTicks(1));</a>
<a name="ln3600">                        KeySigEvent key2 = staff-&gt;keySigEvent(tick);</a>
<a name="ln3601">                        if (!(key1 == key2)) {</a>
<a name="ln3602">                              // locate a key sig. in next measure and, if found,</a>
<a name="ln3603">                              // check if it has court. sig turned off</a>
<a name="ln3604">                              Segment* s = nm-&gt;findSegment(SegmentType::KeySig, tick);</a>
<a name="ln3605">                              if (s) {</a>
<a name="ln3606">                                    KeySig* ks = toKeySig(s-&gt;element(staffIdx * VOICES));</a>
<a name="ln3607">                                    if (ks &amp;&amp; !ks-&gt;showCourtesy())</a>
<a name="ln3608">                                          continue;</a>
<a name="ln3609">                                    }</a>
<a name="ln3610">                              setHasCourtesyKeySig(true);</a>
<a name="ln3611">                              t = BarLineType::DOUBLE;</a>
<a name="ln3612">                              break;</a>
<a name="ln3613">                              }</a>
<a name="ln3614">                        }</a>
<a name="ln3615">                  }</a>
<a name="ln3616"> </a>
<a name="ln3617">            bool force = false;</a>
<a name="ln3618">            if (repeatEnd()) {</a>
<a name="ln3619">                  t = BarLineType::END_REPEAT;</a>
<a name="ln3620">                  force = true;</a>
<a name="ln3621">                  }</a>
<a name="ln3622">            else if (isLastMeasureInSystem &amp;&amp; nextMeasure() &amp;&amp; nextMeasure()-&gt;repeatStart()) {</a>
<a name="ln3623">                  t = BarLineType::NORMAL;</a>
<a name="ln3624">//                  force = true;</a>
<a name="ln3625">                  }</a>
<a name="ln3626"> </a>
<a name="ln3627">            for (int staffIdx = 0; staffIdx &lt; nstaves; ++staffIdx) {</a>
<a name="ln3628">                  int track    = staffIdx * VOICES;</a>
<a name="ln3629">                  BarLine* bl  = toBarLine(seg-&gt;element(track));</a>
<a name="ln3630">                  Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln3631">                  if (!bl) {</a>
<a name="ln3632">                        bl = new BarLine(score());</a>
<a name="ln3633">                        bl-&gt;setParent(seg);</a>
<a name="ln3634">                        bl-&gt;setTrack(track);</a>
<a name="ln3635">                        bl-&gt;setGenerated(true);</a>
<a name="ln3636">                        bl-&gt;setSpanStaff(staff-&gt;barLineSpan());</a>
<a name="ln3637">                        bl-&gt;setSpanFrom(staff-&gt;barLineFrom());</a>
<a name="ln3638">                        bl-&gt;setSpanTo(staff-&gt;barLineTo());</a>
<a name="ln3639">                        bl-&gt;setBarLineType(t);</a>
<a name="ln3640">                        score()-&gt;addElement(bl);</a>
<a name="ln3641">                        }</a>
<a name="ln3642">                  else {</a>
<a name="ln3643">                        // do not change bar line type if bar line is user modified</a>
<a name="ln3644">                        // and its not a repeat start/end barline (forced)</a>
<a name="ln3645"> </a>
<a name="ln3646">                        if (bl-&gt;generated()) {</a>
<a name="ln3647">                              bl-&gt;setSpanStaff(staff-&gt;barLineSpan());</a>
<a name="ln3648">                              bl-&gt;setSpanFrom(staff-&gt;barLineFrom());</a>
<a name="ln3649">                              bl-&gt;setSpanTo(staff-&gt;barLineTo());</a>
<a name="ln3650">                              bl-&gt;setBarLineType(t);</a>
<a name="ln3651">                              }</a>
<a name="ln3652">                        else {</a>
<a name="ln3653">                              if (bl-&gt;barLineType() != t) {</a>
<a name="ln3654">                                    if (force) {</a>
<a name="ln3655">                                          bl-&gt;undoChangeProperty(Pid::BARLINE_TYPE, QVariant::fromValue(t));</a>
<a name="ln3656">                                          bl-&gt;setGenerated(true);</a>
<a name="ln3657">                                          }</a>
<a name="ln3658">                                    }</a>
<a name="ln3659">                              }</a>
<a name="ln3660">                        }</a>
<a name="ln3661">                  bl-&gt;layout();</a>
<a name="ln3662">                  blw = qMax(blw, bl-&gt;width());</a>
<a name="ln3663">                  }</a>
<a name="ln3664">            // right align within segment</a>
<a name="ln3665">            for (int staffIdx = 0; staffIdx &lt; nstaves; ++staffIdx) {</a>
<a name="ln3666">                  int track   = staffIdx * VOICES;</a>
<a name="ln3667">                  BarLine* bl = toBarLine(seg-&gt;element(track));</a>
<a name="ln3668">                  if (bl)</a>
<a name="ln3669">                        bl-&gt;rxpos() += blw - bl-&gt;width();</a>
<a name="ln3670">                  }</a>
<a name="ln3671">            seg-&gt;createShapes();</a>
<a name="ln3672">            }</a>
<a name="ln3673"> </a>
<a name="ln3674">      // set relative position of end barline and clef</a>
<a name="ln3675">      // if end repeat, clef goes after, otherwise clef goes before</a>
<a name="ln3676">      Segment* clefSeg = findSegmentR(SegmentType::Clef, ticks());</a>
<a name="ln3677">      if (clefSeg) {</a>
<a name="ln3678">            if (clefSeg) {</a>
<a name="ln3679">                  Segment* s1;</a>
<a name="ln3680">                  Segment* s2;</a>
<a name="ln3681">                  if (repeatEnd()) {</a>
<a name="ln3682">                        s1 = seg;</a>
<a name="ln3683">                        s2 = clefSeg;</a>
<a name="ln3684">                        }</a>
<a name="ln3685">                  else {</a>
<a name="ln3686">                        s1 = clefSeg;</a>
<a name="ln3687">                        s2 = seg;</a>
<a name="ln3688">                        }</a>
<a name="ln3689">                  if (s1-&gt;next() != s2) {</a>
<a name="ln3690">                        _segments.remove(s1);</a>
<a name="ln3691">                        _segments.insert(s1, s2);</a>
<a name="ln3692">                        }</a>
<a name="ln3693">                  }</a>
<a name="ln3694">            }</a>
<a name="ln3695"> </a>
<a name="ln3696">      // fix segment layout</a>
<a name="ln3697">      Segment* s = seg-&gt;prevActive();</a>
<a name="ln3698">      if (s) {</a>
<a name="ln3699">            qreal x    = s-&gt;rxpos();</a>
<a name="ln3700">            computeMinWidth(s, x, false);</a>
<a name="ln3701">            }</a>
<a name="ln3702"> </a>
<a name="ln3703">#if 0</a>
<a name="ln3704">#ifndef NDEBUG</a>
<a name="ln3705">      qreal w = width();</a>
<a name="ln3706">      computeMinWidth();</a>
<a name="ln3707">      if (!qFuzzyCompare(w, width()))</a>
<a name="ln3708">            qDebug(&quot;width mismatch %f != %f at %d&quot;, w, width(), tick());</a>
<a name="ln3709">#endif</a>
<a name="ln3710">#endif</a>
<a name="ln3711">      return width() - oldWidth;</a>
<a name="ln3712">      }</a>
<a name="ln3713"> </a>
<a name="ln3714">//---------------------------------------------------------</a>
<a name="ln3715">//   basicStretch</a>
<a name="ln3716">//---------------------------------------------------------</a>
<a name="ln3717"> </a>
<a name="ln3718">qreal Measure::basicStretch() const</a>
<a name="ln3719">      {</a>
<a name="ln3720">      qreal stretch = userStretch() * score()-&gt;styleD(Sid::measureSpacing);</a>
<a name="ln3721">      if (stretch &lt; 1.0)</a>
<a name="ln3722">            stretch = 1.0;</a>
<a name="ln3723">      return stretch;</a>
<a name="ln3724">      }</a>
<a name="ln3725"> </a>
<a name="ln3726">//---------------------------------------------------------</a>
<a name="ln3727">//   basicWidth</a>
<a name="ln3728">//---------------------------------------------------------</a>
<a name="ln3729"> </a>
<a name="ln3730">qreal Measure::basicWidth() const</a>
<a name="ln3731">      {</a>
<a name="ln3732">      Segment* ls = last();</a>
<a name="ln3733">      qreal w = (ls-&gt;x() + ls-&gt;width()) * basicStretch();</a>
<a name="ln3734">      qreal minMeasureWidth = score()-&gt;styleP(Sid::minMeasureWidth);</a>
<a name="ln3735">      if (w &lt; minMeasureWidth)</a>
<a name="ln3736">            w = minMeasureWidth;</a>
<a name="ln3737">      return w;</a>
<a name="ln3738">      }</a>
<a name="ln3739"> </a>
<a name="ln3740">//---------------------------------------------------------</a>
<a name="ln3741">//   layoutWeight</a>
<a name="ln3742">//---------------------------------------------------------</a>
<a name="ln3743"> </a>
<a name="ln3744">int Measure::layoutWeight(int maxMMRestLength) const</a>
<a name="ln3745">      {</a>
<a name="ln3746">      int w = ticks().ticks();</a>
<a name="ln3747">      // reduce weight of mmrests</a>
<a name="ln3748">      // so the nominal width is not directly proportional to duration (still linear, just not 1:1)</a>
<a name="ln3749">      // and they are not so &quot;greedy&quot; in taking up available space on a system</a>
<a name="ln3750">      if (isMMRest()) {</a>
<a name="ln3751">            int timesigTicks = timesig().ticks();</a>
<a name="ln3752">            // TODO: style setting</a>
<a name="ln3753">            if (maxMMRestLength) {</a>
<a name="ln3754">                  int maxW = timesigTicks * maxMMRestLength;</a>
<a name="ln3755">                  w = qMin(w, maxW);</a>
<a name="ln3756">                  }</a>
<a name="ln3757">            w -= timesigTicks;</a>
<a name="ln3758">            w = timesigTicks + w / 32;</a>
<a name="ln3759">            }</a>
<a name="ln3760">      return w;</a>
<a name="ln3761">      }</a>
<a name="ln3762"> </a>
<a name="ln3763">//-------------------------------------------------------------------</a>
<a name="ln3764">//   addSystemHeader</a>
<a name="ln3765">///   Add elements to make this measure suitable as the first measure</a>
<a name="ln3766">///   of a system.</a>
<a name="ln3767">//    The system header can contain a starting BarLine, a Clef,</a>
<a name="ln3768">//    and a KeySig</a>
<a name="ln3769">//-------------------------------------------------------------------</a>
<a name="ln3770"> </a>
<a name="ln3771">void Measure::addSystemHeader(bool isFirstSystem)</a>
<a name="ln3772">      {</a>
<a name="ln3773">      int staffIdx = 0;</a>
<a name="ln3774">      Segment* kSegment = findFirstR(SegmentType::KeySig, Fraction(0,1));</a>
<a name="ln3775">      Segment* cSegment = findFirstR(SegmentType::HeaderClef, Fraction(0,1));</a>
<a name="ln3776"> </a>
<a name="ln3777">      for (const Staff* staff : score()-&gt;staves()) {</a>
<a name="ln3778">            const int track = staffIdx * VOICES;</a>
<a name="ln3779"> </a>
<a name="ln3780">            if (isFirstSystem || score()-&gt;styleB(Sid::genClef)) {</a>
<a name="ln3781">                  // find the clef type at the previous tick</a>
<a name="ln3782">                  ClefTypeList cl = staff-&gt;clefType(tick() - Fraction::fromTicks(1));</a>
<a name="ln3783">                  Segment* s = nullptr;</a>
<a name="ln3784">                  if (prevMeasure())</a>
<a name="ln3785">                        // look for a clef change at the end of the previous measure</a>
<a name="ln3786">                        s = prevMeasure()-&gt;findSegment(SegmentType::Clef, tick());</a>
<a name="ln3787">                  else if (isMMRest())</a>
<a name="ln3788">                        // look for a header clef at the beginning of the first underlying measure</a>
<a name="ln3789">                        s = mmRestFirst()-&gt;findFirstR(SegmentType::HeaderClef, Fraction(0,1));</a>
<a name="ln3790">                  if (s) {</a>
<a name="ln3791">                        Clef* c = toClef(s-&gt;element(track));</a>
<a name="ln3792">                        if (c)</a>
<a name="ln3793">                              cl = c-&gt;clefTypeList();</a>
<a name="ln3794">                        }</a>
<a name="ln3795">                  Clef* clef;</a>
<a name="ln3796">                  if (!cSegment) {</a>
<a name="ln3797">                        cSegment = new Segment(this, SegmentType::HeaderClef, Fraction(0,1));</a>
<a name="ln3798">                        cSegment-&gt;setHeader(true);</a>
<a name="ln3799">                        add(cSegment);</a>
<a name="ln3800">                        clef = 0;</a>
<a name="ln3801">                        }</a>
<a name="ln3802">                  else</a>
<a name="ln3803">                        clef = toClef(cSegment-&gt;element(track));</a>
<a name="ln3804">                  if (staff-&gt;staffType(tick())-&gt;genClef()) {</a>
<a name="ln3805">                        if (!clef) {</a>
<a name="ln3806">                              //</a>
<a name="ln3807">                              // create missing clef</a>
<a name="ln3808">                              //</a>
<a name="ln3809">                              clef = new Clef(score());</a>
<a name="ln3810">                              clef-&gt;setTrack(track);</a>
<a name="ln3811">                              clef-&gt;setGenerated(true);</a>
<a name="ln3812">                              clef-&gt;setParent(cSegment);</a>
<a name="ln3813">                              cSegment-&gt;add(clef);</a>
<a name="ln3814">                              }</a>
<a name="ln3815">                        if (clef-&gt;generated())</a>
<a name="ln3816">                              clef-&gt;setClefType(cl);</a>
<a name="ln3817">                        clef-&gt;setSmall(false);</a>
<a name="ln3818">                        clef-&gt;layout();</a>
<a name="ln3819">                        }</a>
<a name="ln3820">                  else if (clef) {</a>
<a name="ln3821">                        clef-&gt;parent()-&gt;remove(clef);</a>
<a name="ln3822">                        delete clef;</a>
<a name="ln3823">                        }</a>
<a name="ln3824">                  //cSegment-&gt;createShape(staffIdx);</a>
<a name="ln3825">                  cSegment-&gt;setEnabled(true);</a>
<a name="ln3826">                  }</a>
<a name="ln3827">            else {</a>
<a name="ln3828">                  if (cSegment)</a>
<a name="ln3829">                        cSegment-&gt;setEnabled(false);</a>
<a name="ln3830">                  }</a>
<a name="ln3831"> </a>
<a name="ln3832">            // keep key sigs in TABs: TABs themselves should hide them</a>
<a name="ln3833">            bool needKeysig = isFirstSystem || score()-&gt;styleB(Sid::genKeysig);</a>
<a name="ln3834"> </a>
<a name="ln3835">            // If we need a Key::C KeySig (which would be invisible) and there is</a>
<a name="ln3836">            // a courtesy key sig, dont create it and switch generated flags.</a>
<a name="ln3837">            // This avoids creating an invisible KeySig which can distort layout.</a>
<a name="ln3838"> </a>
<a name="ln3839">            KeySigEvent keyIdx = staff-&gt;keySigEvent(tick());</a>
<a name="ln3840">            KeySig* ksAnnounce = 0;</a>
<a name="ln3841">            if (needKeysig &amp;&amp; (keyIdx.key() == Key::C)) {</a>
<a name="ln3842">                  Measure* pm = prevMeasure();</a>
<a name="ln3843">                  if (pm &amp;&amp; pm-&gt;hasCourtesyKeySig()) {</a>
<a name="ln3844">                        Segment* ks = pm-&gt;first(SegmentType::KeySigAnnounce);</a>
<a name="ln3845">                        if (ks) {</a>
<a name="ln3846">                              ksAnnounce = toKeySig(ks-&gt;element(track));</a>
<a name="ln3847">                              if (ksAnnounce) {</a>
<a name="ln3848">                                    needKeysig = false;</a>
<a name="ln3849">//                                    if (keysig) {</a>
<a name="ln3850">//                                          ksAnnounce-&gt;setGenerated(false);</a>
<a name="ln3851">//TODO                                      keysig-&gt;setGenerated(true);</a>
<a name="ln3852">//                                          }</a>
<a name="ln3853">                                    }</a>
<a name="ln3854">                              }</a>
<a name="ln3855">                        }</a>
<a name="ln3856">                  }</a>
<a name="ln3857"> </a>
<a name="ln3858">            needKeysig = needKeysig &amp;&amp; (keyIdx.key() != Key::C || keyIdx.custom() || keyIdx.isAtonal());</a>
<a name="ln3859"> </a>
<a name="ln3860">            if (needKeysig) {</a>
<a name="ln3861">                  KeySig* keysig;</a>
<a name="ln3862">                  if (!kSegment) {</a>
<a name="ln3863">                        kSegment = new Segment(this, SegmentType::KeySig, Fraction(0,1));</a>
<a name="ln3864">                        kSegment-&gt;setHeader(true);</a>
<a name="ln3865">                        add(kSegment);</a>
<a name="ln3866">                        keysig = 0;</a>
<a name="ln3867">                        }</a>
<a name="ln3868">                  else</a>
<a name="ln3869">                        keysig  = toKeySig(kSegment-&gt;element(track));</a>
<a name="ln3870">                  if (!keysig) {</a>
<a name="ln3871">                        //</a>
<a name="ln3872">                        // create missing key signature</a>
<a name="ln3873">                        //</a>
<a name="ln3874">                        keysig = new KeySig(score());</a>
<a name="ln3875">                        keysig-&gt;setTrack(track);</a>
<a name="ln3876">                        keysig-&gt;setGenerated(true);</a>
<a name="ln3877">                        keysig-&gt;setParent(kSegment);</a>
<a name="ln3878">                        kSegment-&gt;add(keysig);</a>
<a name="ln3879">                        }</a>
<a name="ln3880">                  keysig-&gt;setKeySigEvent(keyIdx);</a>
<a name="ln3881">                  keysig-&gt;layout();</a>
<a name="ln3882">                  //kSegment-&gt;createShape(staffIdx);</a>
<a name="ln3883">                  kSegment-&gt;setEnabled(true);</a>
<a name="ln3884">                  }</a>
<a name="ln3885">            else {</a>
<a name="ln3886">                  if (kSegment &amp;&amp; staff-&gt;isPitchedStaff(tick())) {</a>
<a name="ln3887">                        // do not disable user modified keysigs</a>
<a name="ln3888">                        bool disable = true;</a>
<a name="ln3889">                        for (int i = 0; i &lt; score()-&gt;nstaves(); ++i) {</a>
<a name="ln3890">                              Element* e = kSegment-&gt;element(i * VOICES);</a>
<a name="ln3891">                              Key key = score()-&gt;staff(i)-&gt;key(tick());</a>
<a name="ln3892">                              if ((e &amp;&amp; !e-&gt;generated()) || (key != keyIdx.key())) {</a>
<a name="ln3893">                                    disable = false;</a>
<a name="ln3894">                                    }</a>
<a name="ln3895">                              else if (e &amp;&amp; e-&gt;generated() &amp;&amp; key == keyIdx.key() &amp;&amp; keyIdx.key() == Key::C){</a>
<a name="ln3896">                                    // If a key sig segment is disabled, it may be re-enabled if there is</a>
<a name="ln3897">                                    // a transposing instrument using a different key sig.</a>
<a name="ln3898">                                    // To prevent this from making the wrong key sig display, remove any key</a>
<a name="ln3899">                                    // sigs on staves where the key in this measure is C.</a>
<a name="ln3900">                                    kSegment-&gt;remove(e);</a>
<a name="ln3901">                                    }</a>
<a name="ln3902">                              }</a>
<a name="ln3903"> </a>
<a name="ln3904">                        if (disable)</a>
<a name="ln3905">                              kSegment-&gt;setEnabled(false);</a>
<a name="ln3906">                        else {</a>
<a name="ln3907">                              Element* e = kSegment-&gt;element(track);</a>
<a name="ln3908">                              if (e &amp;&amp; e-&gt;isKeySig()) {</a>
<a name="ln3909">                                    KeySig* keysig = toKeySig(e);</a>
<a name="ln3910">                                    keysig-&gt;layout();</a>
<a name="ln3911">                                    }</a>
<a name="ln3912">                              }</a>
<a name="ln3913">                        }</a>
<a name="ln3914">                  }</a>
<a name="ln3915"> </a>
<a name="ln3916">            ++staffIdx;</a>
<a name="ln3917">            }</a>
<a name="ln3918">      if (cSegment)</a>
<a name="ln3919">            cSegment-&gt;createShapes();</a>
<a name="ln3920">      if (kSegment)</a>
<a name="ln3921">            kSegment-&gt;createShapes();</a>
<a name="ln3922"> </a>
<a name="ln3923">      //</a>
<a name="ln3924">      // create systemic barline</a>
<a name="ln3925">      //</a>
<a name="ln3926">      Segment* s  = findSegment(SegmentType::BeginBarLine, tick());</a>
<a name="ln3927">      int n       = score()-&gt;nstaves();</a>
<a name="ln3928">      if ((n &gt; 1 &amp;&amp; score()-&gt;styleB(Sid::startBarlineMultiple)) || (n == 1 &amp;&amp; score()-&gt;styleB(Sid::startBarlineSingle))) {</a>
<a name="ln3929">            if (!s) {</a>
<a name="ln3930">                  s = new Segment(this, SegmentType::BeginBarLine, Fraction(0,1));</a>
<a name="ln3931">                  add(s);</a>
<a name="ln3932">                  }</a>
<a name="ln3933">            for (int track = 0; track &lt; score()-&gt;ntracks(); track += VOICES) {</a>
<a name="ln3934">                  BarLine* bl = toBarLine(s-&gt;element(track));</a>
<a name="ln3935">                  if (!bl) {</a>
<a name="ln3936">                        bl = new BarLine(score());</a>
<a name="ln3937">                        bl-&gt;setTrack(track);</a>
<a name="ln3938">                        bl-&gt;setGenerated(true);</a>
<a name="ln3939">                        bl-&gt;setParent(s);</a>
<a name="ln3940">                        bl-&gt;setBarLineType(BarLineType::NORMAL);</a>
<a name="ln3941">                        bl-&gt;setSpanStaff(true);</a>
<a name="ln3942">                        bl-&gt;layout();</a>
<a name="ln3943">                        s-&gt;add(bl);</a>
<a name="ln3944">                        }</a>
<a name="ln3945">                  }</a>
<a name="ln3946">            s-&gt;createShapes();</a>
<a name="ln3947">            s-&gt;setEnabled(true);</a>
<a name="ln3948">            s-&gt;setHeader(true);</a>
<a name="ln3949">            setHeader(true);</a>
<a name="ln3950">            }</a>
<a name="ln3951">      else if (s)</a>
<a name="ln3952">            s-&gt;setEnabled(false);</a>
<a name="ln3953">      checkHeader();</a>
<a name="ln3954">      }</a>
<a name="ln3955"> </a>
<a name="ln3956">//---------------------------------------------------------</a>
<a name="ln3957">//   addSystemTrailer</a>
<a name="ln3958">//---------------------------------------------------------</a>
<a name="ln3959"> </a>
<a name="ln3960">void Measure::addSystemTrailer(Measure* nm)</a>
<a name="ln3961">      {</a>
<a name="ln3962">      Fraction _rtick = ticks();</a>
<a name="ln3963">      bool isFinalMeasure = isFinalMeasureOfSection();</a>
<a name="ln3964"> </a>
<a name="ln3965">      // locate a time sig. in the next measure and, if found,</a>
<a name="ln3966">      // check if it has court. sig. turned off</a>
<a name="ln3967">      TimeSig* ts = nullptr;</a>
<a name="ln3968">      bool showCourtesySig = false;</a>
<a name="ln3969">      Segment* s = findSegmentR(SegmentType::TimeSigAnnounce, _rtick);</a>
<a name="ln3970">      if (nm &amp;&amp; score()-&gt;genCourtesyTimesig() &amp;&amp; !isFinalMeasure &amp;&amp; !score()-&gt;floatMode()) {</a>
<a name="ln3971">            Segment* tss = nm-&gt;findSegmentR(SegmentType::TimeSig, Fraction(0,1));</a>
<a name="ln3972">            if (tss) {</a>
<a name="ln3973">                  int nstaves = score()-&gt;nstaves();</a>
<a name="ln3974">                  for (int track = 0; track &lt; nstaves * VOICES; track += VOICES) {</a>
<a name="ln3975">                        ts = toTimeSig(tss-&gt;element(track));</a>
<a name="ln3976">                        if (ts)</a>
<a name="ln3977">                              break;</a>
<a name="ln3978">                        }</a>
<a name="ln3979">                  if (ts &amp;&amp; ts-&gt;showCourtesySig()) {</a>
<a name="ln3980">                        showCourtesySig = true;</a>
<a name="ln3981">                        // if due, create a new courtesy time signature for each staff</a>
<a name="ln3982">                        if (!s) {</a>
<a name="ln3983">                              s  = new Segment(this, SegmentType::TimeSigAnnounce, _rtick);</a>
<a name="ln3984">                              s-&gt;setTrailer(true);</a>
<a name="ln3985">                              add(s);</a>
<a name="ln3986">                              }</a>
<a name="ln3987">                        s-&gt;setEnabled(true);</a>
<a name="ln3988">                        for (int track = 0; track &lt; nstaves * VOICES; track += VOICES) {</a>
<a name="ln3989">                              TimeSig* nts = toTimeSig(tss-&gt;element(track));</a>
<a name="ln3990">                              if (!nts)</a>
<a name="ln3991">                                    continue;</a>
<a name="ln3992">                              ts = toTimeSig(s-&gt;element(track));</a>
<a name="ln3993">                              if (!ts) {</a>
<a name="ln3994">                                    ts = new TimeSig(score());</a>
<a name="ln3995">                                    ts-&gt;setTrack(track);</a>
<a name="ln3996">                                    ts-&gt;setGenerated(true);</a>
<a name="ln3997">                                    ts-&gt;setParent(s);</a>
<a name="ln3998">                                    score()-&gt;undoAddElement(ts);</a>
<a name="ln3999">                                    }</a>
<a name="ln4000">                              ts-&gt;setFrom(nts);</a>
<a name="ln4001">                              ts-&gt;layout();</a>
<a name="ln4002">                              //s-&gt;createShape(track / VOICES);</a>
<a name="ln4003">                              }</a>
<a name="ln4004">                        s-&gt;createShapes();</a>
<a name="ln4005">                        }</a>
<a name="ln4006">                  }</a>
<a name="ln4007">            }</a>
<a name="ln4008">      if (!showCourtesySig &amp;&amp; s) {</a>
<a name="ln4009">            // remove any existing time signatures</a>
<a name="ln4010">            s-&gt;setEnabled(false);</a>
<a name="ln4011">            }</a>
<a name="ln4012"> </a>
<a name="ln4013">      // courtesy key signatures, clefs</a>
<a name="ln4014"> </a>
<a name="ln4015">      int n      = score()-&gt;nstaves();</a>
<a name="ln4016">      bool show  = hasCourtesyKeySig();</a>
<a name="ln4017">      s          = findSegmentR(SegmentType::KeySigAnnounce, _rtick);</a>
<a name="ln4018"> </a>
<a name="ln4019">      Segment* clefSegment = findSegmentR(SegmentType::Clef, ticks());</a>
<a name="ln4020"> </a>
<a name="ln4021">      for (int staffIdx = 0; staffIdx &lt; n; ++staffIdx) {</a>
<a name="ln4022">            int track    = staffIdx * VOICES;</a>
<a name="ln4023">            Staff* staff = score()-&gt;staff(staffIdx);</a>
<a name="ln4024"> </a>
<a name="ln4025">            if (show) {</a>
<a name="ln4026">                  if (!s) {</a>
<a name="ln4027">                        s = new Segment(this, SegmentType::KeySigAnnounce, _rtick);</a>
<a name="ln4028">                        s-&gt;setTrailer(true);</a>
<a name="ln4029">                        add(s);</a>
<a name="ln4030">                        }</a>
<a name="ln4031">                  KeySig* ks = toKeySig(s-&gt;element(track));</a>
<a name="ln4032">                  KeySigEvent key2 = staff-&gt;keySigEvent(endTick());</a>
<a name="ln4033"> </a>
<a name="ln4034">                  if (!ks) {</a>
<a name="ln4035">                        ks = new KeySig(score());</a>
<a name="ln4036">                        ks-&gt;setTrack(track);</a>
<a name="ln4037">                        ks-&gt;setGenerated(true);</a>
<a name="ln4038">                        ks-&gt;setParent(s);</a>
<a name="ln4039">                        s-&gt;add(ks);</a>
<a name="ln4040">                        }</a>
<a name="ln4041">                  //else if (!(ks-&gt;keySigEvent() == key2)) {</a>
<a name="ln4042">                  //      score()-&gt;undo(new ChangeKeySig(ks, key2, ks-&gt;showCourtesy()));</a>
<a name="ln4043">                  //      }</a>
<a name="ln4044">                  ks-&gt;setKeySigEvent(key2);</a>
<a name="ln4045">                  ks-&gt;layout();</a>
<a name="ln4046">                  //s-&gt;createShape(track / VOICES);</a>
<a name="ln4047">                  s-&gt;setEnabled(true);</a>
<a name="ln4048">                  }</a>
<a name="ln4049">            else {</a>
<a name="ln4050">                  // remove any existent courtesy key signature</a>
<a name="ln4051">                  if (s)</a>
<a name="ln4052">                        s-&gt;setEnabled(false);</a>
<a name="ln4053">                  }</a>
<a name="ln4054">            if (clefSegment) {</a>
<a name="ln4055">                  Clef* clef = toClef(clefSegment-&gt;element(track));</a>
<a name="ln4056">                  if (clef) {</a>
<a name="ln4057">                        clef-&gt;setSmall(true);</a>
<a name="ln4058">                        if (!nm || !score()-&gt;genCourtesyClef() || isFinalMeasure || !clef-&gt;showCourtesy())</a>
<a name="ln4059">                              clef-&gt;clear();          // make invisible</a>
<a name="ln4060">                        }</a>
<a name="ln4061">                  }</a>
<a name="ln4062">            }</a>
<a name="ln4063">      if (s)</a>
<a name="ln4064">            s-&gt;createShapes();</a>
<a name="ln4065">      if (clefSegment)</a>
<a name="ln4066">            clefSegment-&gt;createShapes();</a>
<a name="ln4067"> </a>
<a name="ln4068">      checkTrailer();</a>
<a name="ln4069">      }</a>
<a name="ln4070"> </a>
<a name="ln4071">//---------------------------------------------------------</a>
<a name="ln4072">//   removeSystemHeader</a>
<a name="ln4073">//---------------------------------------------------------</a>
<a name="ln4074"> </a>
<a name="ln4075">void Measure::removeSystemHeader()</a>
<a name="ln4076">      {</a>
<a name="ln4077">      if (!header())</a>
<a name="ln4078">            return;</a>
<a name="ln4079">      for (Segment* seg = first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln4080">            if (!seg-&gt;header())</a>
<a name="ln4081">                  break;</a>
<a name="ln4082">            seg-&gt;setEnabled(false);</a>
<a name="ln4083">            }</a>
<a name="ln4084">      setHeader(false);</a>
<a name="ln4085">      }</a>
<a name="ln4086"> </a>
<a name="ln4087">//---------------------------------------------------------</a>
<a name="ln4088">//   removeSystemTrailer</a>
<a name="ln4089">//---------------------------------------------------------</a>
<a name="ln4090"> </a>
<a name="ln4091">void Measure::removeSystemTrailer()</a>
<a name="ln4092">      {</a>
<a name="ln4093">      bool changed = false;</a>
<a name="ln4094">      for (Segment* seg = last(); seg != first(); seg = seg-&gt;prev()) {</a>
<a name="ln4095">            if (!seg-&gt;trailer())</a>
<a name="ln4096">                  break;</a>
<a name="ln4097">            if (seg-&gt;enabled())</a>
<a name="ln4098">                  seg-&gt;setEnabled(false);</a>
<a name="ln4099">            changed = true;</a>
<a name="ln4100">            }</a>
<a name="ln4101">      setTrailer(false);</a>
<a name="ln4102">      if (system() &amp;&amp; changed)</a>
<a name="ln4103">            computeMinWidth();</a>
<a name="ln4104">      }</a>
<a name="ln4105"> </a>
<a name="ln4106">//---------------------------------------------------------</a>
<a name="ln4107">//   checkHeader</a>
<a name="ln4108">//---------------------------------------------------------</a>
<a name="ln4109"> </a>
<a name="ln4110">void Measure::checkHeader()</a>
<a name="ln4111">      {</a>
<a name="ln4112">      for (Segment* seg = first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln4113">            if (seg-&gt;enabled() &amp;&amp; seg-&gt;header()) {</a>
<a name="ln4114">                  setHeader(seg-&gt;header());</a>
<a name="ln4115">                  break;</a>
<a name="ln4116">                  }</a>
<a name="ln4117">            }</a>
<a name="ln4118">      }</a>
<a name="ln4119"> </a>
<a name="ln4120">//---------------------------------------------------------</a>
<a name="ln4121">//   checkTrailer</a>
<a name="ln4122">//---------------------------------------------------------</a>
<a name="ln4123"> </a>
<a name="ln4124">void Measure::checkTrailer()</a>
<a name="ln4125">      {</a>
<a name="ln4126">      for (Segment* seg = last(); seg != first(); seg = seg-&gt;prev()) {</a>
<a name="ln4127">            if (seg-&gt;enabled() &amp;&amp; seg-&gt;trailer()) {</a>
<a name="ln4128">                  setTrailer(seg-&gt;trailer());</a>
<a name="ln4129">                  break;</a>
<a name="ln4130">                  }</a>
<a name="ln4131">            }</a>
<a name="ln4132">      }</a>
<a name="ln4133"> </a>
<a name="ln4134">//---------------------------------------------------------</a>
<a name="ln4135">//   setStretchedWidth</a>
<a name="ln4136">//---------------------------------------------------------</a>
<a name="ln4137"> </a>
<a name="ln4138">void Measure::setStretchedWidth(qreal w)</a>
<a name="ln4139">      {</a>
<a name="ln4140">      qreal minWidth = isMMRest() ? score()-&gt;styleP(Sid::minMMRestWidth) : score()-&gt;styleP(Sid::minMeasureWidth);</a>
<a name="ln4141">      if (w &lt; minWidth)</a>
<a name="ln4142">            w = minWidth;</a>
<a name="ln4143"> </a>
<a name="ln4144">      qreal stretchableWidth = 0.0;</a>
<a name="ln4145">      for (Segment* s = first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln4146">            if (!s-&gt;enabled())</a>
<a name="ln4147">                  continue;</a>
<a name="ln4148">            stretchableWidth += s-&gt;width();</a>
<a name="ln4149">            }</a>
<a name="ln4150">      const int maxMMRestLength = 32;     // TODO: style</a>
<a name="ln4151">      int weight = layoutWeight(maxMMRestLength);</a>
<a name="ln4152">      w += stretchableWidth * (basicStretch() - 1.0) * weight / 1920.0;</a>
<a name="ln4153"> </a>
<a name="ln4154">      setWidth(w);</a>
<a name="ln4155">      }</a>
<a name="ln4156"> </a>
<a name="ln4157">//---------------------------------------------------------</a>
<a name="ln4158">//   hasAccidental</a>
<a name="ln4159">//---------------------------------------------------------</a>
<a name="ln4160"> </a>
<a name="ln4161">static bool hasAccidental(Segment* s)</a>
<a name="ln4162">      {</a>
<a name="ln4163">      Score* score = s-&gt;score();</a>
<a name="ln4164">      for (int track = 0; track &lt; s-&gt;score()-&gt;ntracks(); ++track) {</a>
<a name="ln4165">            Staff* staff = score-&gt;staff(track2staff(track));</a>
<a name="ln4166">            if (!staff-&gt;show())</a>
<a name="ln4167">                  continue;</a>
<a name="ln4168">            Element* e = s-&gt;element(track);</a>
<a name="ln4169">            if (!e || !e-&gt;isChord())</a>
<a name="ln4170">                  continue;</a>
<a name="ln4171">            Chord* c = toChord(e);</a>
<a name="ln4172">            for (Note* n : c-&gt;notes()) {</a>
<a name="ln4173">                  if (n-&gt;accidental())</a>
<a name="ln4174">                        return true;</a>
<a name="ln4175">                  }</a>
<a name="ln4176">            }</a>
<a name="ln4177">      return false;</a>
<a name="ln4178">      }</a>
<a name="ln4179"> </a>
<a name="ln4180">//---------------------------------------------------------</a>
<a name="ln4181">//   computeMinWidth</a>
<a name="ln4182">//    sets the minimum stretched width of segment list s</a>
<a name="ln4183">//    set the width and x position for all segments</a>
<a name="ln4184">//---------------------------------------------------------</a>
<a name="ln4185"> </a>
<a name="ln4186">void Measure::computeMinWidth(Segment* s, qreal x, bool isSystemHeader)</a>
<a name="ln4187">      {</a>
<a name="ln4188">      Segment* fs = firstEnabled();</a>
<a name="ln4189">      if (!fs-&gt;visible())           // first enabled could be a clef change on invisible staff</a>
<a name="ln4190">            fs = fs-&gt;nextActive();</a>
<a name="ln4191">      bool first  = system()-&gt;firstMeasure() == this;</a>
<a name="ln4192">      const Shape ls(first ? QRectF(0.0, -1000000.0, 0.0, 2000000.0) : QRectF(0.0, 0.0, 0.0, spatium() * 4));</a>
<a name="ln4193"> </a>
<a name="ln4194">      if (isMMRest()) {</a>
<a name="ln4195">            // Reset MM rest to initial size and position</a>
<a name="ln4196">            Segment* seg = findSegmentR(SegmentType::ChordRest, Fraction(0,1));</a>
<a name="ln4197">            const int nstaves = score()-&gt;nstaves();</a>
<a name="ln4198">            for (int st = 0; st &lt; nstaves; ++st) {</a>
<a name="ln4199">                  Rest* mmRest = toRest(seg-&gt;element(staff2track(st)));</a>
<a name="ln4200">                  if (mmRest) {</a>
<a name="ln4201">                        mmRest-&gt;rxpos() = 0;</a>
<a name="ln4202">                        mmRest-&gt;layoutMMRest(score()-&gt;styleP(Sid::minMMRestWidth) * mag());</a>
<a name="ln4203">                        mmRest-&gt;segment()-&gt;createShapes();</a>
<a name="ln4204">                        }</a>
<a name="ln4205">                  }</a>
<a name="ln4206">            }</a>
<a name="ln4207"> </a>
<a name="ln4208">      while (s) {</a>
<a name="ln4209">            s-&gt;rxpos() = x;</a>
<a name="ln4210">            if (!s-&gt;enabled() || !s-&gt;visible()) {</a>
<a name="ln4211">                  s-&gt;setWidth(0);</a>
<a name="ln4212">                  s = s-&gt;next();</a>
<a name="ln4213">                  continue;</a>
<a name="ln4214">                  }</a>
<a name="ln4215">            Segment* ns = s-&gt;nextActive();</a>
<a name="ln4216">            // end barline might be disabled</a>
<a name="ln4217">            // but still consider it for spacing of previous segment</a>
<a name="ln4218">            if (!ns)</a>
<a name="ln4219">                  ns = s-&gt;next(SegmentType::BarLineType);</a>
<a name="ln4220">            qreal w;</a>
<a name="ln4221"> </a>
<a name="ln4222">            if (ns) {</a>
<a name="ln4223">                  if (isSystemHeader &amp;&amp; (ns-&gt;isChordRestType() || (ns-&gt;isClefType() &amp;&amp; !ns-&gt;header()))) {</a>
<a name="ln4224">                        // this is the system header gap</a>
<a name="ln4225">                        w = s-&gt;minHorizontalDistance(ns, true);</a>
<a name="ln4226">                        isSystemHeader = false;</a>
<a name="ln4227">                        }</a>
<a name="ln4228">                  else {</a>
<a name="ln4229">                        w = s-&gt;minHorizontalDistance(ns, false);</a>
<a name="ln4230">                        }</a>
<a name="ln4231">// printf(&quot;  min %f &lt;%s&gt;(%d) &lt;%s&gt;(%d)\n&quot;, s-&gt;x(), s-&gt;subTypeName(), s-&gt;enabled(), ns-&gt;subTypeName(), ns-&gt;enabled());</a>
<a name="ln4232">#if 1</a>
<a name="ln4233">                  // look back for collisions with previous segments</a>
<a name="ln4234">                  // this is time consuming (ca. +5%) and probably requires more optimization</a>
<a name="ln4235"> </a>
<a name="ln4236">                  if (s == fs) // don't let the second segment cross measure start (not covered by the loop below)</a>
<a name="ln4237">                        w = std::max(w, ns-&gt;minLeft(ls) - s-&gt;x());</a>
<a name="ln4238"> </a>
<a name="ln4239">                  int n = 1;</a>
<a name="ln4240">                  for (Segment* ps = s; ps != fs;) {</a>
<a name="ln4241">                        qreal ww;</a>
<a name="ln4242">                        ps = ps-&gt;prevActive();</a>
<a name="ln4243"> </a>
<a name="ln4244">                        Q_ASSERT(ps); // ps should never be nullptr but better be safe.</a>
<a name="ln4245">                        if (!ps)</a>
<a name="ln4246">                              break;</a>
<a name="ln4247"> </a>
<a name="ln4248">                        if (ps-&gt;isChordRestType())</a>
<a name="ln4249">                              ++n;</a>
<a name="ln4250">                        ww = ps-&gt;minHorizontalCollidingDistance(ns) - (s-&gt;x() - ps-&gt;x());</a>
<a name="ln4251"> </a>
<a name="ln4252">                        if (ps == fs)</a>
<a name="ln4253">                              ww = std::max(ww, ns-&gt;minLeft(ls) - s-&gt;x());</a>
<a name="ln4254"> </a>
<a name="ln4255">                        if (ww &gt; w) {</a>
<a name="ln4256">                              // overlap !</a>
<a name="ln4257">                              // distribute extra space between segments ps - ss;</a>
<a name="ln4258">                              // only ChordRest segments get more space</a>
<a name="ln4259">                              // TODO: is there a special case n == 0 ?</a>
<a name="ln4260"> </a>
<a name="ln4261">                              qreal d = (ww - w) / n;</a>
<a name="ln4262">                              qreal xx = ps-&gt;x();</a>
<a name="ln4263">                              for (Segment* ss = ps; ss != s;) {</a>
<a name="ln4264">                                    Segment* ns1 = ss-&gt;nextActive();</a>
<a name="ln4265">                                    qreal ww1    = ss-&gt;width();</a>
<a name="ln4266">                                    if (ss-&gt;isChordRestType()) {</a>
<a name="ln4267">                                          ww1 += d;</a>
<a name="ln4268">                                          ss-&gt;setWidth(ww1);</a>
<a name="ln4269">                                          }</a>
<a name="ln4270">                                    xx += ww1;</a>
<a name="ln4271">                                    ns1-&gt;rxpos() = xx;</a>
<a name="ln4272">                                    ss = ns1;</a>
<a name="ln4273">                                    }</a>
<a name="ln4274">                              w += d;</a>
<a name="ln4275">                              x = xx;</a>
<a name="ln4276">                              break;</a>
<a name="ln4277">                              }</a>
<a name="ln4278">                        }</a>
<a name="ln4279">#endif</a>
<a name="ln4280">                  }</a>
<a name="ln4281">            else</a>
<a name="ln4282">                  w = s-&gt;minRight();</a>
<a name="ln4283">            s-&gt;setWidth(w);</a>
<a name="ln4284">            x += w;</a>
<a name="ln4285">            s = s-&gt;next();</a>
<a name="ln4286">            }</a>
<a name="ln4287">      setStretchedWidth(x);</a>
<a name="ln4288">      }</a>
<a name="ln4289"> </a>
<a name="ln4290">void Measure::computeMinWidth()</a>
<a name="ln4291">      {</a>
<a name="ln4292">      Segment* s;</a>
<a name="ln4293"> </a>
<a name="ln4294">      //</a>
<a name="ln4295">      // skip disabled segment</a>
<a name="ln4296">      //</a>
<a name="ln4297">      for (s = first(); s &amp;&amp; !s-&gt;enabled(); s = s-&gt;next()) {</a>
<a name="ln4298">            s-&gt;rxpos() = 0;</a>
<a name="ln4299">            s-&gt;setWidth(0);</a>
<a name="ln4300">            }</a>
<a name="ln4301">      if (!s) {</a>
<a name="ln4302">            setWidth(0.0);</a>
<a name="ln4303">            return;</a>
<a name="ln4304">            }</a>
<a name="ln4305">      qreal x;</a>
<a name="ln4306">      bool first = system()-&gt;firstMeasure() == this;</a>
<a name="ln4307"> </a>
<a name="ln4308">      // left barriere:</a>
<a name="ln4309">      //    Make sure no elements crosses the left boarder if first measure in a system.</a>
<a name="ln4310">      //</a>
<a name="ln4311">      Shape ls(first ? QRectF(0.0, -1000000.0, 0.0, 2000000.0) : QRectF(0.0, 0.0, 0.0, spatium() * 4));</a>
<a name="ln4312"> </a>
<a name="ln4313">      x = s-&gt;minLeft(ls);</a>
<a name="ln4314"> </a>
<a name="ln4315">      if (s-&gt;isStartRepeatBarLineType()) {</a>
<a name="ln4316">            System*  sys = system();</a>
<a name="ln4317">            MeasureBase* pmb = prev();</a>
<a name="ln4318">            if (pmb-&gt;isMeasure() &amp;&amp; pmb-&gt;system() == sys &amp;&amp; pmb-&gt;repeatEnd()) {</a>
<a name="ln4319">                  Segment* seg = toMeasure(pmb)-&gt;last();</a>
<a name="ln4320">                  // overlap end repeat barline with start repeat barline</a>
<a name="ln4321">                  if (seg-&gt;isEndBarLineType())</a>
<a name="ln4322">                        x -= score()-&gt;styleP(Sid::endBarWidth) * mag();</a>
<a name="ln4323">                  }</a>
<a name="ln4324">            }</a>
<a name="ln4325"> </a>
<a name="ln4326">      if (s-&gt;isChordRestType())</a>
<a name="ln4327">            x += score()-&gt;styleP(hasAccidental(s) ? Sid::barAccidentalDistance : Sid::barNoteDistance);</a>
<a name="ln4328">      else if (s-&gt;isClefType() || s-&gt;isHeaderClefType())</a>
<a name="ln4329">            x += score()-&gt;styleP(Sid::clefLeftMargin);</a>
<a name="ln4330">      else if (s-&gt;isKeySigType())</a>
<a name="ln4331">            x = qMax(x, score()-&gt;styleP(Sid::keysigLeftMargin));</a>
<a name="ln4332">      else if (s-&gt;isTimeSigType())</a>
<a name="ln4333">            x = qMax(x, score()-&gt;styleP(Sid::timesigLeftMargin));</a>
<a name="ln4334">      x += s-&gt;extraLeadingSpace().val() * spatium();</a>
<a name="ln4335">      bool isSystemHeader = s-&gt;header();</a>
<a name="ln4336"> </a>
<a name="ln4337">      computeMinWidth(s, x, isSystemHeader);</a>
<a name="ln4338">      }</a>
<a name="ln4339"> </a>
<a name="ln4340">}</a>
<a name="ln4341"> </a>

</code></pre>
<div class="balloon" rel="90"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'MStaff' class implements a copy constructor, but lacks the copy assignment operator. It is dangerous to use such a class.</p></div>
<div class="balloon" rel="832"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1229"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v668/" target="_blank">V668</a> There is no sense in testing the 'ots' pointer against null, as the memory was allocated using the 'new' operator. The exception will be generated in the case of memory allocation error.</p></div>
<div class="balloon" rel="1668"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1409"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1409, 1414</p></div>
<div class="balloon" rel="1957"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="3215"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'seg' pointer was used unsafely after it was verified against nullptr. Check lines: 3214, 3215.</p></div>
<div class="balloon" rel="3678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'clefSeg' is always true.</p></div>
<div class="balloon" rel="3678"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 'if (clefSeg)' condition was already verified in line 3677.</p></div>
<div class="balloon" rel="225"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _noMode.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
