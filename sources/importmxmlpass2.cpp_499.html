
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>importmxmlpass2.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Linux Music Score Editor</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2015-2019 Werner Schweer and others</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2.</a>
<a name="ln9">//</a>
<a name="ln10">//  This program is distributed in the hope that it will be useful,</a>
<a name="ln11">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">//  GNU General Public License for more details.</a>
<a name="ln14">//</a>
<a name="ln15">//  You should have received a copy of the GNU General Public License</a>
<a name="ln16">//  along with this program; if not, write to the Free Software</a>
<a name="ln17">//  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</a>
<a name="ln18">//=============================================================================</a>
<a name="ln19"> </a>
<a name="ln20">#include &lt;memory&gt;</a>
<a name="ln21">#include &lt;utility&gt;</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;libmscore/arpeggio.h&quot;</a>
<a name="ln24">#include &quot;libmscore/accidental.h&quot;</a>
<a name="ln25">#include &quot;libmscore/breath.h&quot;</a>
<a name="ln26">#include &quot;libmscore/chord.h&quot;</a>
<a name="ln27">#include &quot;libmscore/chordline.h&quot;</a>
<a name="ln28">#include &quot;libmscore/chordlist.h&quot;</a>
<a name="ln29">#include &quot;libmscore/chordrest.h&quot;</a>
<a name="ln30">#include &quot;libmscore/drumset.h&quot;</a>
<a name="ln31">#include &quot;libmscore/dynamic.h&quot;</a>
<a name="ln32">#include &quot;libmscore/figuredbass.h&quot;</a>
<a name="ln33">#include &quot;libmscore/fingering.h&quot;</a>
<a name="ln34">#include &quot;libmscore/fret.h&quot;</a>
<a name="ln35">#include &quot;libmscore/glissando.h&quot;</a>
<a name="ln36">#include &quot;libmscore/hairpin.h&quot;</a>
<a name="ln37">#include &quot;libmscore/harmony.h&quot;</a>
<a name="ln38">#include &quot;libmscore/instrchange.h&quot;</a>
<a name="ln39">#include &quot;libmscore/instrtemplate.h&quot;</a>
<a name="ln40">#include &quot;libmscore/interval.h&quot;</a>
<a name="ln41">#include &quot;libmscore/jump.h&quot;</a>
<a name="ln42">#include &quot;libmscore/keysig.h&quot;</a>
<a name="ln43">#include &quot;libmscore/lyrics.h&quot;</a>
<a name="ln44">#include &quot;libmscore/marker.h&quot;</a>
<a name="ln45">#include &quot;libmscore/measure.h&quot;</a>
<a name="ln46">#include &quot;libmscore/mscore.h&quot;</a>
<a name="ln47">#include &quot;libmscore/note.h&quot;</a>
<a name="ln48">#include &quot;libmscore/part.h&quot;</a>
<a name="ln49">#include &quot;libmscore/pedal.h&quot;</a>
<a name="ln50">#include &quot;libmscore/rest.h&quot;</a>
<a name="ln51">#include &quot;libmscore/slur.h&quot;</a>
<a name="ln52">#include &quot;libmscore/staff.h&quot;</a>
<a name="ln53">#include &quot;libmscore/stafftext.h&quot;</a>
<a name="ln54">#include &quot;libmscore/sym.h&quot;</a>
<a name="ln55">#include &quot;libmscore/tempotext.h&quot;</a>
<a name="ln56">#include &quot;libmscore/tie.h&quot;</a>
<a name="ln57">#include &quot;libmscore/timesig.h&quot;</a>
<a name="ln58">#include &quot;libmscore/tremolo.h&quot;</a>
<a name="ln59">#include &quot;libmscore/trill.h&quot;</a>
<a name="ln60">#include &quot;libmscore/utils.h&quot;</a>
<a name="ln61">#include &quot;libmscore/volta.h&quot;</a>
<a name="ln62">#include &quot;libmscore/textline.h&quot;</a>
<a name="ln63">#include &quot;libmscore/barline.h&quot;</a>
<a name="ln64">#include &quot;libmscore/articulation.h&quot;</a>
<a name="ln65">#include &quot;libmscore/ottava.h&quot;</a>
<a name="ln66">#include &quot;libmscore/rehearsalmark.h&quot;</a>
<a name="ln67">#include &quot;libmscore/fermata.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">#include &quot;importmxmllogger.h&quot;</a>
<a name="ln70">#include &quot;importmxmlnoteduration.h&quot;</a>
<a name="ln71">#include &quot;importmxmlnotepitch.h&quot;</a>
<a name="ln72">#include &quot;importmxmlpass2.h&quot;</a>
<a name="ln73">#include &quot;musicxmlfonthandler.h&quot;</a>
<a name="ln74">#include &quot;musicxmlsupport.h&quot;</a>
<a name="ln75">#include &quot;preferences.h&quot;</a>
<a name="ln76"> </a>
<a name="ln77">namespace Ms {</a>
<a name="ln78"> </a>
<a name="ln79">//---------------------------------------------------------</a>
<a name="ln80">//   local defines for debug output</a>
<a name="ln81">//---------------------------------------------------------</a>
<a name="ln82"> </a>
<a name="ln83">//#define DEBUG_VOICE_MAPPER true</a>
<a name="ln84"> </a>
<a name="ln85">//---------------------------------------------------------</a>
<a name="ln86">//   support enums / structs / classes</a>
<a name="ln87">//---------------------------------------------------------</a>
<a name="ln88"> </a>
<a name="ln89">//---------------------------------------------------------</a>
<a name="ln90">//   MusicXmlTupletDesc</a>
<a name="ln91">//---------------------------------------------------------</a>
<a name="ln92"> </a>
<a name="ln93">MusicXmlTupletDesc::MusicXmlTupletDesc()</a>
<a name="ln94">      : type(MxmlStartStop::NONE), placement(Placement::BELOW),</a>
<a name="ln95">      bracket(TupletBracketType::AUTO_BRACKET), shownumber(TupletNumberType::SHOW_NUMBER)</a>
<a name="ln96">      {</a>
<a name="ln97">      // nothing</a>
<a name="ln98">      }</a>
<a name="ln99"> </a>
<a name="ln100">//---------------------------------------------------------</a>
<a name="ln101">//   MusicXmlLyricsExtend</a>
<a name="ln102">//---------------------------------------------------------</a>
<a name="ln103"> </a>
<a name="ln104">//---------------------------------------------------------</a>
<a name="ln105">//   init</a>
<a name="ln106">//---------------------------------------------------------</a>
<a name="ln107"> </a>
<a name="ln108">void MusicXmlLyricsExtend::init()</a>
<a name="ln109">      {</a>
<a name="ln110">      _lyrics.clear();</a>
<a name="ln111">      }</a>
<a name="ln112"> </a>
<a name="ln113">//---------------------------------------------------------</a>
<a name="ln114">//   addLyric</a>
<a name="ln115">//---------------------------------------------------------</a>
<a name="ln116"> </a>
<a name="ln117">// add a single lyric to be extended later</a>
<a name="ln118">// called when lyric with &quot;extend&quot; or &quot;extend type=start&quot; is found</a>
<a name="ln119"> </a>
<a name="ln120">void MusicXmlLyricsExtend::addLyric(Lyrics* const lyric)</a>
<a name="ln121">      {</a>
<a name="ln122">      _lyrics.insert(lyric);</a>
<a name="ln123">      }</a>
<a name="ln124"> </a>
<a name="ln125">//---------------------------------------------------------</a>
<a name="ln126">//   lastChordTicks</a>
<a name="ln127">//---------------------------------------------------------</a>
<a name="ln128"> </a>
<a name="ln129">// find the duration of the chord starting at or after s in track and ending at tick</a>
<a name="ln130"> </a>
<a name="ln131">static Fraction lastChordTicks(const Segment* s, const int track, const Fraction&amp; tick)</a>
<a name="ln132">      {</a>
<a name="ln133">      while (s &amp;&amp; s-&gt;tick() &lt; tick) {</a>
<a name="ln134">            Element* el = s-&gt;element(track);</a>
<a name="ln135">            if (el &amp;&amp; el-&gt;isChordRest()) {</a>
<a name="ln136">                  ChordRest* cr = static_cast&lt;ChordRest*&gt;(el);</a>
<a name="ln137">                  if (cr-&gt;tick() + cr-&gt;actualTicks() == tick)</a>
<a name="ln138">                        return cr-&gt;actualTicks();</a>
<a name="ln139">                  }</a>
<a name="ln140">            s = s-&gt;nextCR(track, true);</a>
<a name="ln141">            }</a>
<a name="ln142">      return Fraction(0,1);</a>
<a name="ln143">      }</a>
<a name="ln144"> </a>
<a name="ln145">//---------------------------------------------------------</a>
<a name="ln146">//   setExtend</a>
<a name="ln147">//---------------------------------------------------------</a>
<a name="ln148"> </a>
<a name="ln149">// set extend for lyric no in track to end at tick</a>
<a name="ln150">// called when lyric (with or without &quot;extend&quot;) or note with &quot;extend type=stop&quot; is found</a>
<a name="ln151">// note that no == -1 means all lyrics in this track</a>
<a name="ln152"> </a>
<a name="ln153">void MusicXmlLyricsExtend::setExtend(const int no, const int track, const Fraction&amp; tick)</a>
<a name="ln154">      {</a>
<a name="ln155">      QList&lt;Lyrics*&gt; list;</a>
<a name="ln156">      foreach(Lyrics* l, _lyrics) {</a>
<a name="ln157">            Element* const el = l-&gt;parent();</a>
<a name="ln158">            if (el-&gt;type() == ElementType::CHORD) {       // TODO: rest also possible ?</a>
<a name="ln159">                  ChordRest* const par = static_cast&lt;ChordRest*&gt;(el);</a>
<a name="ln160">                  if (par-&gt;track() == track &amp;&amp; (no == -1 || l-&gt;no() == no)) {</a>
<a name="ln161">                        Fraction lct = lastChordTicks(l-&gt;segment(), track, tick);</a>
<a name="ln162">                        if (lct &gt; Fraction(0,1)) {</a>
<a name="ln163">                              // set lyric tick to the total length from the lyric note</a>
<a name="ln164">                              // plus all notes covered by the melisma minus the last note length</a>
<a name="ln165">                              l-&gt;setTicks(tick - par-&gt;tick() - lct);</a>
<a name="ln166">                              }</a>
<a name="ln167">                        list.append(l);</a>
<a name="ln168">                        }</a>
<a name="ln169">                  }</a>
<a name="ln170">            }</a>
<a name="ln171">      // cleanup</a>
<a name="ln172">      foreach(Lyrics* l, list) {</a>
<a name="ln173">            _lyrics.remove(l);</a>
<a name="ln174">            }</a>
<a name="ln175">      }</a>
<a name="ln176"> </a>
<a name="ln177">//---------------------------------------------------------</a>
<a name="ln178">//   MusicXMLStepAltOct2Pitch</a>
<a name="ln179">//---------------------------------------------------------</a>
<a name="ln180"> </a>
<a name="ln181">/**</a>
<a name="ln182"> Convert MusicXML \a step (0=C, 1=D, etc.) / \a alter / \a octave to midi pitch.</a>
<a name="ln183"> Note: same code is in pass 1 and in pass 2.</a>
<a name="ln184"> TODO: combine</a>
<a name="ln185"> */</a>
<a name="ln186"> </a>
<a name="ln187">static int MusicXMLStepAltOct2Pitch(int step, int alter, int octave)</a>
<a name="ln188">      {</a>
<a name="ln189">      //                       c  d  e  f  g  a   b</a>
<a name="ln190">      static int table[7]  = { 0, 2, 4, 5, 7, 9, 11 };</a>
<a name="ln191">      if (step &lt; 0 || step &gt; 6) {</a>
<a name="ln192">            qDebug(&quot;MusicXMLStepAltOct2Pitch: illegal step %d&quot;, step);</a>
<a name="ln193">            return -1;</a>
<a name="ln194">            }</a>
<a name="ln195">      int pitch = table[step] + alter + (octave+1) * 12;</a>
<a name="ln196"> </a>
<a name="ln197">      if (pitch &lt; 0)</a>
<a name="ln198">            pitch = -1;</a>
<a name="ln199">      if (pitch &gt; 127)</a>
<a name="ln200">            pitch = -1;</a>
<a name="ln201"> </a>
<a name="ln202">      return pitch;</a>
<a name="ln203">      }</a>
<a name="ln204"> </a>
<a name="ln205">//---------------------------------------------------------</a>
<a name="ln206">//   xmlSetPitch</a>
<a name="ln207">//---------------------------------------------------------</a>
<a name="ln208"> </a>
<a name="ln209">/**</a>
<a name="ln210"> Convert MusicXML \a step / \a alter / \a octave to midi pitch,</a>
<a name="ln211"> set pitch and tpc.</a>
<a name="ln212"> Note that n's staff and track have not been set yet</a>
<a name="ln213"> */</a>
<a name="ln214"> </a>
<a name="ln215">static void xmlSetPitch(Note* n, int step, int alter, int octave, const int octaveShift, const Instrument* instr)</a>
<a name="ln216">      {</a>
<a name="ln217">      //qDebug(&quot;xmlSetPitch(n=%p, step=%d, alter=%d, octave=%d, octaveShift=%d)&quot;,</a>
<a name="ln218">      //       n, step, alter, octave, octaveShift);</a>
<a name="ln219"> </a>
<a name="ln220">      //const Staff* staff = n-&gt;score()-&gt;staff(track / VOICES);</a>
<a name="ln221">      //const Instrument* instr = staff-&gt;part()-&gt;instr();</a>
<a name="ln222"> </a>
<a name="ln223">      const Interval intval = instr-&gt;transpose();     // TODO: tick</a>
<a name="ln224"> </a>
<a name="ln225">      //qDebug(&quot;  staff=%p instr=%p dia=%d chro=%d&quot;,</a>
<a name="ln226">      //       staff, instr, static_cast&lt;int&gt;(intval.diatonic), static_cast&lt;int&gt;(intval.chromatic));</a>
<a name="ln227"> </a>
<a name="ln228">      int pitch = MusicXMLStepAltOct2Pitch(step, alter, octave);</a>
<a name="ln229">      pitch += intval.chromatic; // assume not in concert pitch</a>
<a name="ln230">      pitch += 12 * octaveShift; // correct for octave shift</a>
<a name="ln231">      // ensure sane values</a>
<a name="ln232">      pitch = limit(pitch, 0, 127);</a>
<a name="ln233"> </a>
<a name="ln234">      int tpc2 = step2tpc(step, AccidentalVal(alter));</a>
<a name="ln235">      int tpc1 = Ms::transposeTpc(tpc2, intval, true);</a>
<a name="ln236">      n-&gt;setPitch(pitch, tpc1, tpc2);</a>
<a name="ln237">      //qDebug(&quot;  pitch=%d tpc1=%d tpc2=%d&quot;, n-&gt;pitch(), n-&gt;tpc1(), n-&gt;tpc2());</a>
<a name="ln238">      }</a>
<a name="ln239"> </a>
<a name="ln240">//---------------------------------------------------------</a>
<a name="ln241">//   fillGap</a>
<a name="ln242">//---------------------------------------------------------</a>
<a name="ln243"> </a>
<a name="ln244">/**</a>
<a name="ln245"> Fill one gap (tstart - tend) in this track in this measure with rest(s).</a>
<a name="ln246"> */</a>
<a name="ln247"> </a>
<a name="ln248">static void fillGap(Measure* measure, int track, const Fraction&amp; tstart, const Fraction&amp; tend)</a>
<a name="ln249">      {</a>
<a name="ln250">      Fraction ctick = tstart;</a>
<a name="ln251">      Fraction restLen = tend - tstart;</a>
<a name="ln252">      // qDebug(&quot;\nfillGIFV     fillGap(measure %p track %d tstart %d tend %d) restLen %d len&quot;,</a>
<a name="ln253">      //        measure, track, tstart, tend, restLen);</a>
<a name="ln254">      // note: as MScore::division (#ticks in a quarter note) equals 480</a>
<a name="ln255">      // MScore::division / 64 (#ticks in a 256th note) uequals 7.5 but is rounded down to 7</a>
<a name="ln256">      while (restLen &gt; Fraction(1,256)) {</a>
<a name="ln257">            Fraction len = restLen;</a>
<a name="ln258">            TDuration d(TDuration::DurationType::V_INVALID);</a>
<a name="ln259">            if (measure-&gt;ticks() == restLen)</a>
<a name="ln260">                  d.setType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln261">            else</a>
<a name="ln262">                  d.setVal(len.ticks());</a>
<a name="ln263">            Rest* rest = new Rest(measure-&gt;score(), d);</a>
<a name="ln264">            rest-&gt;setTicks(len);</a>
<a name="ln265">            rest-&gt;setTrack(track);</a>
<a name="ln266">            rest-&gt;setVisible(false);</a>
<a name="ln267">            Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, tstart);</a>
<a name="ln268">            s-&gt;add(rest);</a>
<a name="ln269">            len = rest-&gt;globalTicks();</a>
<a name="ln270">            // qDebug(&quot; %d&quot;, len);</a>
<a name="ln271">            ctick   += len;</a>
<a name="ln272">            restLen -= len;</a>
<a name="ln273">            }</a>
<a name="ln274">      }</a>
<a name="ln275"> </a>
<a name="ln276">//---------------------------------------------------------</a>
<a name="ln277">//   fillGapsInFirstVoices</a>
<a name="ln278">//---------------------------------------------------------</a>
<a name="ln279"> </a>
<a name="ln280">/**</a>
<a name="ln281"> Fill gaps in first voice of every staff in this measure for this part with rest(s).</a>
<a name="ln282"> */</a>
<a name="ln283"> </a>
<a name="ln284">static void fillGapsInFirstVoices(Measure* measure, Part* part)</a>
<a name="ln285">      {</a>
<a name="ln286">      Q_ASSERT(measure);</a>
<a name="ln287">      Q_ASSERT(part);</a>
<a name="ln288"> </a>
<a name="ln289">      Fraction measTick     = measure-&gt;tick();</a>
<a name="ln290">      Fraction measLen      = measure-&gt;ticks();</a>
<a name="ln291">      Fraction nextMeasTick = measTick + measLen;</a>
<a name="ln292">      int staffIdx = part-&gt;score()-&gt;staffIdx(part);</a>
<a name="ln293">      /*</a>
<a name="ln294">       qDebug(&quot;fillGIFV measure %p part %p idx %d nstaves %d tick %d - %d (len %d)&quot;,</a>
<a name="ln295">       measure, part, staffIdx, part-&gt;nstaves(),</a>
<a name="ln296">       measTick, nextMeasTick, measLen);</a>
<a name="ln297">       */</a>
<a name="ln298">      for (int st = 0; st &lt; part-&gt;nstaves(); ++st) {</a>
<a name="ln299">            int track = (staffIdx + st) * VOICES;</a>
<a name="ln300">            Fraction endOfLastCR = measTick;</a>
<a name="ln301">            for (Segment* s = measure-&gt;first(); s; s = s-&gt;next()) {</a>
<a name="ln302">                  // qDebug(&quot;fillGIFV   segment %p tp %s&quot;, s, s-&gt;subTypeName());</a>
<a name="ln303">                  Element* el = s-&gt;element(track);</a>
<a name="ln304">                  if (el) {</a>
<a name="ln305">                        // qDebug(&quot; el[%d] %p&quot;, track, el);</a>
<a name="ln306">                        if (s-&gt;isChordRestType()) {</a>
<a name="ln307">                              ChordRest* cr  = static_cast&lt;ChordRest*&gt;(el);</a>
<a name="ln308">                              Fraction crTick     = cr-&gt;tick();</a>
<a name="ln309">                              Fraction crLen      = cr-&gt;globalTicks();</a>
<a name="ln310">                              Fraction nextCrTick = crTick + crLen;</a>
<a name="ln311">                              /*</a>
<a name="ln312">                               qDebug(&quot; chord/rest tick %d - %d (len %d)&quot;,</a>
<a name="ln313">                               crTick, nextCrTick, crLen);</a>
<a name="ln314">                               */</a>
<a name="ln315">                              if (crTick &gt; endOfLastCR) {</a>
<a name="ln316">                                    /*</a>
<a name="ln317">                                     qDebug(&quot; GAP: track %d tick %d - %d&quot;,</a>
<a name="ln318">                                     track, endOfLastCR, crTick);</a>
<a name="ln319">                                     */</a>
<a name="ln320">                                    fillGap(measure, track, endOfLastCR, crTick);</a>
<a name="ln321">                                    }</a>
<a name="ln322">                              endOfLastCR = nextCrTick;</a>
<a name="ln323">                              }</a>
<a name="ln324">                        }</a>
<a name="ln325">                  }</a>
<a name="ln326">            if (nextMeasTick &gt; endOfLastCR) {</a>
<a name="ln327">                  /*</a>
<a name="ln328">                   qDebug(&quot;fillGIFV   measure end GAP: track %d tick %d - %d&quot;,</a>
<a name="ln329">                   track, endOfLastCR, nextMeasTick);</a>
<a name="ln330">                   */</a>
<a name="ln331">                  fillGap(measure, track, endOfLastCR, nextMeasTick);</a>
<a name="ln332">                  }</a>
<a name="ln333">            }</a>
<a name="ln334">      }</a>
<a name="ln335"> </a>
<a name="ln336">//---------------------------------------------------------</a>
<a name="ln337">//   hasDrumset</a>
<a name="ln338">//---------------------------------------------------------</a>
<a name="ln339"> </a>
<a name="ln340">/**</a>
<a name="ln341"> Determine if \a mxmlDrumset contains a valid drumset.</a>
<a name="ln342"> This is the case if any instrument has a midi-unpitched element,</a>
<a name="ln343"> (which stored in the MusicXMLDrumInstrument pitch field).</a>
<a name="ln344"> */</a>
<a name="ln345"> </a>
<a name="ln346">static bool hasDrumset(const MusicXMLDrumset&amp; mxmlDrumset)</a>
<a name="ln347">      {</a>
<a name="ln348">      bool res = false;</a>
<a name="ln349">      MusicXMLDrumsetIterator ii(mxmlDrumset);</a>
<a name="ln350">      while (ii.hasNext()) {</a>
<a name="ln351">            ii.next();</a>
<a name="ln352">            // debug: dump the drumset</a>
<a name="ln353">            //qDebug(&quot;hasDrumset: instrument: %s %s&quot;, qPrintable(ii.key()), qPrintable(ii.value().toString()));</a>
<a name="ln354">            int pitch = ii.value().pitch;</a>
<a name="ln355">            if (0 &lt;= pitch &amp;&amp; pitch &lt;= 127) {</a>
<a name="ln356">                  res = true;</a>
<a name="ln357">                  }</a>
<a name="ln358">            }</a>
<a name="ln359"> </a>
<a name="ln360">      /*</a>
<a name="ln361">      for (const auto&amp; instr : mxmlDrumset) {</a>
<a name="ln362">            // MusicXML elements instrument-name, midi-program, instrument-sound, virtual-library, virtual-name</a>
<a name="ln363">            // in a shell script use &quot;mscore ... 2&gt;&amp;1 | grep GREP_ME | cut -d' ' -f3-&quot; to extract</a>
<a name="ln364">            qDebug(&quot;GREP_ME '%s',%d,'%s','%s','%s'&quot;,</a>
<a name="ln365">                   qPrintable(instr.name),</a>
<a name="ln366">                   instr.midiProgram + 1,</a>
<a name="ln367">                   qPrintable(instr.sound),</a>
<a name="ln368">                   qPrintable(instr.virtLib),</a>
<a name="ln369">                   qPrintable(instr.virtName)</a>
<a name="ln370">                   );</a>
<a name="ln371">            }</a>
<a name="ln372">       */</a>
<a name="ln373"> </a>
<a name="ln374">      return res;</a>
<a name="ln375">      }</a>
<a name="ln376"> </a>
<a name="ln377">//---------------------------------------------------------</a>
<a name="ln378">//   initDrumset</a>
<a name="ln379">//---------------------------------------------------------</a>
<a name="ln380"> </a>
<a name="ln381">/**</a>
<a name="ln382"> Initialize drumset \a drumset.</a>
<a name="ln383"> */</a>
<a name="ln384"> </a>
<a name="ln385">// determine if the part contains a drumset</a>
<a name="ln386">// this is the case if any instrument has a midi-unpitched element,</a>
<a name="ln387">// (which stored in the MusicXMLDrumInstrument pitch field)</a>
<a name="ln388">// if the part contains a drumset, Drumset drumset is initialized</a>
<a name="ln389"> </a>
<a name="ln390">static void initDrumset(Drumset* drumset, const MusicXMLDrumset&amp; mxmlDrumset)</a>
<a name="ln391">      {</a>
<a name="ln392">      drumset-&gt;clear();</a>
<a name="ln393">      MusicXMLDrumsetIterator ii(mxmlDrumset);</a>
<a name="ln394">      while (ii.hasNext()) {</a>
<a name="ln395">            ii.next();</a>
<a name="ln396">            // debug: also dump the drumset for this part</a>
<a name="ln397">            //qDebug(&quot;initDrumset: instrument: %s %s&quot;, qPrintable(ii.key()), qPrintable(ii.value().toString()));</a>
<a name="ln398">            int pitch = ii.value().pitch;</a>
<a name="ln399">            if (0 &lt;= pitch &amp;&amp; pitch &lt;= 127) {</a>
<a name="ln400">                  drumset-&gt;drum(ii.value().pitch)</a>
<a name="ln401">                        = DrumInstrument(ii.value().name.toLatin1().constData(),</a>
<a name="ln402">                                         ii.value().notehead, ii.value().line, ii.value().stemDirection);</a>
<a name="ln403">                  }</a>
<a name="ln404">            }</a>
<a name="ln405">      }</a>
<a name="ln406"> </a>
<a name="ln407">//---------------------------------------------------------</a>
<a name="ln408">//   createInstrument</a>
<a name="ln409">//---------------------------------------------------------</a>
<a name="ln410"> </a>
<a name="ln411">/**</a>
<a name="ln412"> Create an Instrument based on the information in \a mxmlInstr.</a>
<a name="ln413"> */</a>
<a name="ln414"> </a>
<a name="ln415">static Instrument createInstrument(const MusicXMLDrumInstrument&amp; mxmlInstr)</a>
<a name="ln416">      {</a>
<a name="ln417">      Instrument instr;</a>
<a name="ln418"> </a>
<a name="ln419">      InstrumentTemplate* it {};</a>
<a name="ln420">      if (!mxmlInstr.sound.isEmpty()) {</a>
<a name="ln421">            it = Ms::searchTemplateForMusicXmlId(mxmlInstr.sound);</a>
<a name="ln422">            }</a>
<a name="ln423"> </a>
<a name="ln424">      /*</a>
<a name="ln425">      qDebug(&quot;sound '%s' it %p trackname '%s' program %d&quot;,</a>
<a name="ln426">             qPrintable(mxmlInstr.sound), it,</a>
<a name="ln427">             it ? qPrintable(it-&gt;trackName) : &quot;&quot;,</a>
<a name="ln428">             mxmlInstr.midiProgram);</a>
<a name="ln429">       */</a>
<a name="ln430"> </a>
<a name="ln431">      if (it) {</a>
<a name="ln432">            // initialize from template with matching MusicXmlId</a>
<a name="ln433">            instr = Instrument::fromTemplate(it);</a>
<a name="ln434">            // reset transpose, as it is determined later from MusicXML data</a>
<a name="ln435">            instr.setTranspose(Interval());</a>
<a name="ln436">            }</a>
<a name="ln437">      else {</a>
<a name="ln438">            // set articulations to default (global articulations)</a>
<a name="ln439">            instr.setArticulation(articulation);</a>
<a name="ln440">            // set default program</a>
<a name="ln441">            instr.channel(0)-&gt;setProgram(mxmlInstr.midiProgram &gt;= 0 ? mxmlInstr.midiProgram : 0);</a>
<a name="ln442">            }</a>
<a name="ln443"> </a>
<a name="ln444">      // add / overrule with values read from MusicXML</a>
<a name="ln445">      instr.channel(0)-&gt;setPan(mxmlInstr.midiPan);</a>
<a name="ln446">      instr.channel(0)-&gt;setVolume(mxmlInstr.midiVolume);</a>
<a name="ln447">      instr.setTrackName(mxmlInstr.name);</a>
<a name="ln448"> </a>
<a name="ln449">      return instr;</a>
<a name="ln450">      }</a>
<a name="ln451"> </a>
<a name="ln452">//---------------------------------------------------------</a>
<a name="ln453">//   setFirstInstrument</a>
<a name="ln454">//---------------------------------------------------------</a>
<a name="ln455"> </a>
<a name="ln456">/**</a>
<a name="ln457"> Set first instrument for Part \a part</a>
<a name="ln458"> */</a>
<a name="ln459"> </a>
<a name="ln460">static void setFirstInstrument(MxmlLogger* logger, const QXmlStreamReader* const xmlreader,</a>
<a name="ln461">                               Part* part, const QString&amp; partId,</a>
<a name="ln462">                               const QString&amp; instrId, const MusicXMLDrumset&amp; mxmlDrumset)</a>
<a name="ln463">      {</a>
<a name="ln464">      if (mxmlDrumset.size() &gt; 0) {</a>
<a name="ln465">            //qDebug(&quot;setFirstInstrument: initial instrument '%s'&quot;, qPrintable(instrId));</a>
<a name="ln466">            MusicXMLDrumInstrument mxmlInstr;</a>
<a name="ln467">            if (instrId == &quot;&quot;)</a>
<a name="ln468">                  mxmlInstr = mxmlDrumset.first();</a>
<a name="ln469">            else if (mxmlDrumset.contains(instrId))</a>
<a name="ln470">                  mxmlInstr = mxmlDrumset.value(instrId);</a>
<a name="ln471">            else {</a>
<a name="ln472">                  logger-&gt;logError(QString(&quot;initial instrument '%1' not found in part '%2'&quot;)</a>
<a name="ln473">                                   .arg(instrId).arg(partId), xmlreader);</a>
<a name="ln474">                  mxmlInstr = mxmlDrumset.first();</a>
<a name="ln475">                  }</a>
<a name="ln476"> </a>
<a name="ln477">            Instrument instr = createInstrument(mxmlInstr);</a>
<a name="ln478">            part-&gt;setInstrument(instr);</a>
<a name="ln479">            if (mxmlInstr.midiChannel &gt;= 0) part-&gt;setMidiChannel(mxmlInstr.midiChannel, mxmlInstr.midiPort);</a>
<a name="ln480">            // note: setMidiProgram() does more than simply setting the MIDI program</a>
<a name="ln481">            if (mxmlInstr.midiProgram &gt;= 0) part-&gt;setMidiProgram(mxmlInstr.midiProgram);</a>
<a name="ln482">            }</a>
<a name="ln483">      else</a>
<a name="ln484">            logger-&gt;logError(QString(&quot;no instrument found for part '%1'&quot;)</a>
<a name="ln485">                             .arg(partId), xmlreader);</a>
<a name="ln486">      }</a>
<a name="ln487"> </a>
<a name="ln488">//---------------------------------------------------------</a>
<a name="ln489">//   setStaffTypePercussion</a>
<a name="ln490">//---------------------------------------------------------</a>
<a name="ln491"> </a>
<a name="ln492">/**</a>
<a name="ln493"> Set staff type to percussion</a>
<a name="ln494"> */</a>
<a name="ln495"> </a>
<a name="ln496">static void setStaffTypePercussion(Part* part, Drumset* drumset)</a>
<a name="ln497">      {</a>
<a name="ln498">      for (int j = 0; j &lt; part-&gt;nstaves(); ++j)</a>
<a name="ln499">            if (part-&gt;staff(j)-&gt;lines(Fraction(0,1)) == 5 &amp;&amp; !part-&gt;staff(j)-&gt;isDrumStaff(Fraction(0,1)))</a>
<a name="ln500">                  part-&gt;staff(j)-&gt;setStaffType(Fraction(0,1), *StaffType::preset(StaffTypes::PERC_DEFAULT));</a>
<a name="ln501">      // set drumset for instrument</a>
<a name="ln502">      part-&gt;instrument()-&gt;setDrumset(drumset);</a>
<a name="ln503">      part-&gt;instrument()-&gt;channel(0)-&gt;setBank(128);</a>
<a name="ln504">      }</a>
<a name="ln505"> </a>
<a name="ln506">//---------------------------------------------------------</a>
<a name="ln507">//   setPartInstruments</a>
<a name="ln508">//---------------------------------------------------------</a>
<a name="ln509"> </a>
<a name="ln510">static void setPartInstruments(MxmlLogger* logger, const QXmlStreamReader* const xmlreader,</a>
<a name="ln511">                               Part* part, const QString&amp; partId,</a>
<a name="ln512">                               Score* score, const MusicXmlInstrList&amp; il, const MusicXMLDrumset&amp; mxmlDrumset)</a>
<a name="ln513">      {</a>
<a name="ln514">      QString prevInstrId;</a>
<a name="ln515">      for (auto it = il.cbegin(); it != il.cend(); ++it) {</a>
<a name="ln516">            Fraction f = (*it).first;</a>
<a name="ln517">            if (f == Fraction(0, 1))</a>
<a name="ln518">                  prevInstrId = (*it).second;  // instrument id at t = 0</a>
<a name="ln519">            else if (f &gt; Fraction(0, 1)) {</a>
<a name="ln520">                  auto instrId = (*it).second;</a>
<a name="ln521">                  bool mustInsert = instrId != prevInstrId;</a>
<a name="ln522">                  /*</a>
<a name="ln523">                  qDebug(&quot;f %s previd %s id %s mustInsert %d&quot;,</a>
<a name="ln524">                         qPrintable(f.print()),</a>
<a name="ln525">                         qPrintable(prevInstrId),</a>
<a name="ln526">                         qPrintable(instrId),</a>
<a name="ln527">                         mustInsert);</a>
<a name="ln528">                   */</a>
<a name="ln529">                  if (mustInsert) {</a>
<a name="ln530">                        const int staff = score-&gt;staffIdx(part);</a>
<a name="ln531">                        const int track = staff * VOICES;</a>
<a name="ln532">                        const Fraction tick = f;</a>
<a name="ln533">                        //qDebug(&quot;instrument change: tick %s (%d) track %d instr '%s'&quot;,</a>
<a name="ln534">                        //       qPrintable(f.print()), f.ticks(), track, qPrintable(instrId));</a>
<a name="ln535">                        auto segment = score-&gt;tick2segment(tick, true, SegmentType::ChordRest, true);</a>
<a name="ln536">                        if (!segment)</a>
<a name="ln537">                              logger-&gt;logError(QString(&quot;segment for instrument change at tick %1 not found&quot;)</a>
<a name="ln538">                                               .arg(tick.ticks()), xmlreader);</a>
<a name="ln539">                        else if (!mxmlDrumset.contains(instrId))</a>
<a name="ln540">                              logger-&gt;logError(QString(&quot;changed instrument '%1' at tick %2 not found in part '%3'&quot;)</a>
<a name="ln541">                                               .arg(instrId).arg(tick.ticks()).arg(partId), xmlreader);</a>
<a name="ln542">                        else {</a>
<a name="ln543">                              MusicXMLDrumInstrument mxmlInstr = mxmlDrumset.value(instrId);</a>
<a name="ln544">                              Instrument instr = createInstrument(mxmlInstr);</a>
<a name="ln545">                              //qDebug(&quot;instr %p&quot;, &amp;instr);</a>
<a name="ln546"> </a>
<a name="ln547">                              InstrumentChange* ic = new InstrumentChange(instr, score);</a>
<a name="ln548">                              ic-&gt;setTrack(track);</a>
<a name="ln549"> </a>
<a name="ln550">                              // for text use instrument name (if known) else use &quot;Instrument change&quot;</a>
<a name="ln551">                              const QString text = mxmlInstr.name;</a>
<a name="ln552">                              ic-&gt;setXmlText(text.isEmpty() ? &quot;Instrument change&quot; : text);</a>
<a name="ln553">                              ic-&gt;setVisible(false);</a>
<a name="ln554">                              segment-&gt;add(ic); // note: includes part::setInstrument(instr);</a>
<a name="ln555"> </a>
<a name="ln556">                              // setMidiChannel() depends on setInstrument() already been done</a>
<a name="ln557">                              if (mxmlInstr.midiChannel &gt;= 0) part-&gt;setMidiChannel(mxmlInstr.midiChannel, mxmlInstr.midiPort, tick);</a>
<a name="ln558">                              }</a>
<a name="ln559">                        }</a>
<a name="ln560">                  prevInstrId = instrId;</a>
<a name="ln561">                  }</a>
<a name="ln562">            }</a>
<a name="ln563">      }</a>
<a name="ln564"> </a>
<a name="ln565">//---------------------------------------------------------</a>
<a name="ln566">//   text2syms</a>
<a name="ln567">//---------------------------------------------------------</a>
<a name="ln568"> </a>
<a name="ln569">/**</a>
<a name="ln570"> Convert SMuFL code points to MuseScore &lt;sym&gt;...&lt;/sym&gt;</a>
<a name="ln571"> */</a>
<a name="ln572"> </a>
<a name="ln573">static QString text2syms(const QString&amp; t)</a>
<a name="ln574">      {</a>
<a name="ln575">      //QTime time;</a>
<a name="ln576">      //time.start();</a>
<a name="ln577"> </a>
<a name="ln578">      // first create a map from symbol (Unicode) text to symId</a>
<a name="ln579">      // note that this takes about 1 msec on a Core i5,</a>
<a name="ln580">      // caching does not gain much</a>
<a name="ln581"> </a>
<a name="ln582">      ScoreFont* sf = ScoreFont::fallbackFont();</a>
<a name="ln583">      QMap&lt;QString, SymId&gt; map;</a>
<a name="ln584">      int maxStringSize = 0;        // maximum string size found</a>
<a name="ln585"> </a>
<a name="ln586">      for (int i = int(SymId::noSym); i &lt; int(SymId::lastSym); ++i) {</a>
<a name="ln587">            SymId id((SymId(i)));</a>
<a name="ln588">            QString string(sf-&gt;toString(id));</a>
<a name="ln589">            // insert all syms except space to prevent matching all regular spaces</a>
<a name="ln590">            if (id != SymId::space)</a>
<a name="ln591">                  map.insert(string, id);</a>
<a name="ln592">            if (string.size() &gt; maxStringSize)</a>
<a name="ln593">                  maxStringSize = string.size();</a>
<a name="ln594">            }</a>
<a name="ln595">      //qDebug(&quot;text2syms map count %d maxsz %d filling time elapsed: %d ms&quot;,</a>
<a name="ln596">      //       map.size(), maxStringSize, time.elapsed());</a>
<a name="ln597"> </a>
<a name="ln598">      // then look for matches</a>
<a name="ln599">      QString in = t;</a>
<a name="ln600">      QString res;</a>
<a name="ln601"> </a>
<a name="ln602">      while (in != &quot;&quot;) {</a>
<a name="ln603">            // try to find the largest match possible</a>
<a name="ln604">            int maxMatch = qMin(in.size(), maxStringSize);</a>
<a name="ln605">            QString sym;</a>
<a name="ln606">            while (maxMatch &gt; 0) {</a>
<a name="ln607">                  QString toBeMatched = in.left(maxMatch);</a>
<a name="ln608">                  if (map.contains(toBeMatched)) {</a>
<a name="ln609">                        sym = Sym::id2name(map.value(toBeMatched));</a>
<a name="ln610">                        break;</a>
<a name="ln611">                        }</a>
<a name="ln612">                  maxMatch--;</a>
<a name="ln613">                  }</a>
<a name="ln614">            if (maxMatch &gt; 0) {</a>
<a name="ln615">                  // found a match, add sym to res and remove match from string in</a>
<a name="ln616">                  res += &quot;&lt;sym&gt;&quot;;</a>
<a name="ln617">                  res += sym;</a>
<a name="ln618">                  res += &quot;&lt;/sym&gt;&quot;;</a>
<a name="ln619">                  in.remove(0, maxMatch);</a>
<a name="ln620">                  }</a>
<a name="ln621">            else {</a>
<a name="ln622">                  // not found, move one char from res to in</a>
<a name="ln623">                  res += in.left(1);</a>
<a name="ln624">                  in.remove(0, 1);</a>
<a name="ln625">                  }</a>
<a name="ln626">            }</a>
<a name="ln627"> </a>
<a name="ln628">      //qDebug(&quot;text2syms total time elapsed: %d ms, res '%s'&quot;, time.elapsed(), qPrintable(res));</a>
<a name="ln629">      return res;</a>
<a name="ln630">      }</a>
<a name="ln631"> </a>
<a name="ln632">//---------------------------------------------------------</a>
<a name="ln633">//   decodeEntities</a>
<a name="ln634">//---------------------------------------------------------</a>
<a name="ln635"> </a>
<a name="ln636">/**</a>
<a name="ln637"> Decode &amp;#...; in string \a src into UNICODE (utf8) character.</a>
<a name="ln638"> */</a>
<a name="ln639"> </a>
<a name="ln640">static QString decodeEntities( const QString&amp; src )</a>
<a name="ln641">      {</a>
<a name="ln642">      QString ret(src);</a>
<a name="ln643">      QRegExp re(&quot;&amp;#([0-9]+);&quot;);</a>
<a name="ln644">      re.setMinimal(true);</a>
<a name="ln645"> </a>
<a name="ln646">      int pos = 0;</a>
<a name="ln647">      while ( (pos = re.indexIn(src, pos)) != -1 ) {</a>
<a name="ln648">            ret = ret.replace(re.cap(0), QChar(re.cap(1).toInt(0,10)));</a>
<a name="ln649">            pos += re.matchedLength();</a>
<a name="ln650">            }</a>
<a name="ln651">      return ret;</a>
<a name="ln652">      }</a>
<a name="ln653"> </a>
<a name="ln654">//---------------------------------------------------------</a>
<a name="ln655">//   nextPartOfFormattedString</a>
<a name="ln656">//---------------------------------------------------------</a>
<a name="ln657"> </a>
<a name="ln658">// TODO: probably should be shared between pass 1 and 2</a>
<a name="ln659"> </a>
<a name="ln660">/**</a>
<a name="ln661"> Read the next part of a MusicXML formatted string and convert to MuseScore internal encoding.</a>
<a name="ln662"> */</a>
<a name="ln663"> </a>
<a name="ln664">static QString nextPartOfFormattedString(QXmlStreamReader&amp; e)</a>
<a name="ln665">      {</a>
<a name="ln666">      //QString lang       = e.attribute(QString(&quot;xml:lang&quot;), &quot;it&quot;);</a>
<a name="ln667">      QString fontWeight = e.attributes().value(&quot;font-weight&quot;).toString();</a>
<a name="ln668">      QString fontSize   = e.attributes().value(&quot;font-size&quot;).toString();</a>
<a name="ln669">      QString fontStyle  = e.attributes().value(&quot;font-style&quot;).toString();</a>
<a name="ln670">      QString underline  = e.attributes().value(&quot;underline&quot;).toString();</a>
<a name="ln671">      QString fontFamily = e.attributes().value(&quot;font-family&quot;).toString();</a>
<a name="ln672">      // TODO: color, enclosure, yoffset in only part of the text, ...</a>
<a name="ln673"> </a>
<a name="ln674">      QString txt        = e.readElementText();</a>
<a name="ln675">      // replace HTML entities</a>
<a name="ln676">      txt = decodeEntities(txt);</a>
<a name="ln677">      QString syms       = text2syms(txt);</a>
<a name="ln678"> </a>
<a name="ln679">      QString importedtext;</a>
<a name="ln680"> </a>
<a name="ln681">      if (!fontSize.isEmpty()) {</a>
<a name="ln682">            bool ok = true;</a>
<a name="ln683">            float size = fontSize.toFloat(&amp;ok);</a>
<a name="ln684">            if (ok)</a>
<a name="ln685">                  importedtext += QString(&quot;&lt;font size=\&quot;%1\&quot;/&gt;&quot;).arg(size);</a>
<a name="ln686">            }</a>
<a name="ln687">      if (!fontFamily.isEmpty() &amp;&amp; txt == syms) {</a>
<a name="ln688">            // add font family only if no &lt;sym&gt; replacement made</a>
<a name="ln689">            importedtext += QString(&quot;&lt;font face=\&quot;%1\&quot;/&gt;&quot;).arg(fontFamily);</a>
<a name="ln690">            }</a>
<a name="ln691">      if (fontWeight == &quot;bold&quot;)</a>
<a name="ln692">            importedtext += &quot;&lt;b&gt;&quot;;</a>
<a name="ln693">      if (fontStyle == &quot;italic&quot;)</a>
<a name="ln694">            importedtext += &quot;&lt;i&gt;&quot;;</a>
<a name="ln695">      if (!underline.isEmpty()) {</a>
<a name="ln696">            bool ok = true;</a>
<a name="ln697">            int lines = underline.toInt(&amp;ok);</a>
<a name="ln698">            if (ok &amp;&amp; (lines &gt; 0))  // 1,2, or 3 underlines are imported as single underline</a>
<a name="ln699">                  importedtext += &quot;&lt;u&gt;&quot;;</a>
<a name="ln700">            else</a>
<a name="ln701">                  underline = &quot;&quot;;</a>
<a name="ln702">            }</a>
<a name="ln703">      if (txt == syms) {</a>
<a name="ln704">            txt.replace(QString(&quot;\r&quot;), QString(&quot;&quot;)); // convert Windows line break \r\n -&gt; \n</a>
<a name="ln705">            importedtext += txt.toHtmlEscaped();</a>
<a name="ln706">            }</a>
<a name="ln707">      else {</a>
<a name="ln708">            // &lt;sym&gt; replacement made, should be no need for line break or other conversions</a>
<a name="ln709">            importedtext += syms;</a>
<a name="ln710">            }</a>
<a name="ln711">      if (underline != &quot;&quot;)</a>
<a name="ln712">            importedtext += &quot;&lt;/u&gt;&quot;;</a>
<a name="ln713">      if (fontStyle == &quot;italic&quot;)</a>
<a name="ln714">            importedtext += &quot;&lt;/i&gt;&quot;;</a>
<a name="ln715">      if (fontWeight == &quot;bold&quot;)</a>
<a name="ln716">            importedtext += &quot;&lt;/b&gt;&quot;;</a>
<a name="ln717">      //qDebug(&quot;importedtext '%s'&quot;, qPrintable(importedtext));</a>
<a name="ln718">      return importedtext;</a>
<a name="ln719">      }</a>
<a name="ln720"> </a>
<a name="ln721">//---------------------------------------------------------</a>
<a name="ln722">//   addLyric</a>
<a name="ln723">//---------------------------------------------------------</a>
<a name="ln724"> </a>
<a name="ln725">/**</a>
<a name="ln726"> Add a single lyric to the score or delete it (if number too high)</a>
<a name="ln727"> */</a>
<a name="ln728"> </a>
<a name="ln729">static void addLyric(MxmlLogger* logger, const QXmlStreamReader* const xmlreader,</a>
<a name="ln730">                     ChordRest* cr, Lyrics* l, int lyricNo, MusicXmlLyricsExtend&amp; extendedLyrics)</a>
<a name="ln731">      {</a>
<a name="ln732">      if (lyricNo &gt; MAX_LYRICS) {</a>
<a name="ln733">            logger-&gt;logError(QString(&quot;too much lyrics (&gt;%1)&quot;)</a>
<a name="ln734">                             .arg(MAX_LYRICS), xmlreader);</a>
<a name="ln735">            delete l;</a>
<a name="ln736">            }</a>
<a name="ln737">      else {</a>
<a name="ln738">            l-&gt;setNo(lyricNo);</a>
<a name="ln739">            cr-&gt;add(l);</a>
<a name="ln740">            extendedLyrics.setExtend(lyricNo, cr-&gt;track(), cr-&gt;tick());</a>
<a name="ln741">            }</a>
<a name="ln742">      }</a>
<a name="ln743"> </a>
<a name="ln744">//---------------------------------------------------------</a>
<a name="ln745">//   addLyrics</a>
<a name="ln746">//---------------------------------------------------------</a>
<a name="ln747"> </a>
<a name="ln748">/**</a>
<a name="ln749"> Add a notes lyrics to the score</a>
<a name="ln750"> */</a>
<a name="ln751"> </a>
<a name="ln752">static void addLyrics(MxmlLogger* logger, const QXmlStreamReader* const xmlreader,</a>
<a name="ln753">                      ChordRest* cr,</a>
<a name="ln754">                      const QMap&lt;int, Lyrics*&gt;&amp; numbrdLyrics,</a>
<a name="ln755">                      const QSet&lt;Lyrics*&gt;&amp; extLyrics,</a>
<a name="ln756">                      MusicXmlLyricsExtend&amp; extendedLyrics)</a>
<a name="ln757">      {</a>
<a name="ln758">      for (const auto lyricNo : numbrdLyrics.keys()) {</a>
<a name="ln759">            const auto lyric = numbrdLyrics.value(lyricNo);</a>
<a name="ln760">            addLyric(logger, xmlreader, cr, lyric, lyricNo, extendedLyrics);</a>
<a name="ln761">            if (extLyrics.contains(lyric))</a>
<a name="ln762">                  extendedLyrics.addLyric(lyric);</a>
<a name="ln763">            }</a>
<a name="ln764">      }</a>
<a name="ln765"> </a>
<a name="ln766">//---------------------------------------------------------</a>
<a name="ln767">//   addElemOffset</a>
<a name="ln768">//---------------------------------------------------------</a>
<a name="ln769"> </a>
<a name="ln770">static void addElemOffset(Element* el, int track, const QString&amp; placement, Measure* measure, const Fraction&amp; tick)</a>
<a name="ln771">      {</a>
<a name="ln772">      /*</a>
<a name="ln773">       qDebug(&quot;addElem el %p track %d placement %s tick %d&quot;,</a>
<a name="ln774">       el, track, qPrintable(placement), tick);</a>
<a name="ln775">       */</a>
<a name="ln776"> </a>
<a name="ln777">#if 0 // ws: use placement for symbols</a>
<a name="ln778">      // move to correct position</a>
<a name="ln779">      // TODO: handle rx, ry</a>
<a name="ln780">      if (el-&gt;isSymbol()) {</a>
<a name="ln781">            qreal y = 0;</a>
<a name="ln782">            // calc y offset assuming five line staff and default style</a>
<a name="ln783">            // note that required y offset is element type dependent</a>
<a name="ln784">            const qreal stafflines = 5; // assume five line staff, but works OK-ish for other sizes too</a>
<a name="ln785">            qreal offsAbove = 0;</a>
<a name="ln786">            qreal offsBelow = 0;</a>
<a name="ln787">            offsAbove = -2;</a>
<a name="ln788">            offsBelow =  4 + (stafflines - 1);</a>
<a name="ln789">            if (placement == &quot;above&quot;)</a>
<a name="ln790">                  y += offsAbove;</a>
<a name="ln791">            if (placement == &quot;below&quot;)</a>
<a name="ln792">                  y += offsBelow;</a>
<a name="ln793">            //qDebug(&quot;   y = %g&quot;, y);</a>
<a name="ln794">            y *= el-&gt;score()-&gt;spatium();</a>
<a name="ln795">            el-&gt;setUserOff(QPoint(0, y));</a>
<a name="ln796">            }</a>
<a name="ln797">      else {</a>
<a name="ln798">            el-&gt;setPlacement(placement == &quot;above&quot; ? Placement::ABOVE : Placement::BELOW);</a>
<a name="ln799">            }</a>
<a name="ln800">#endif</a>
<a name="ln801">      el-&gt;setPlacement(placement == &quot;above&quot; ? Placement::ABOVE : Placement::BELOW);</a>
<a name="ln802"> </a>
<a name="ln803">      el-&gt;setTrack(el-&gt;isTempoText() ? 0 : track);    // TempoText must be in track 0</a>
<a name="ln804">      Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, tick);</a>
<a name="ln805">      s-&gt;add(el);</a>
<a name="ln806">      }</a>
<a name="ln807"> </a>
<a name="ln808">//---------------------------------------------------------</a>
<a name="ln809">//   calculateTupletDuration</a>
<a name="ln810">//---------------------------------------------------------</a>
<a name="ln811"> </a>
<a name="ln812">/**</a>
<a name="ln813"> Calculate the duration of all notes in the tuplet combined</a>
<a name="ln814"> */</a>
<a name="ln815"> </a>
<a name="ln816">static Fraction calculateTupletDuration(const Tuplet* const t)</a>
<a name="ln817">      {</a>
<a name="ln818">      Fraction res;</a>
<a name="ln819"> </a>
<a name="ln820">      foreach (DurationElement* de, t-&gt;elements()) {</a>
<a name="ln821">            if (de-&gt;type() == ElementType::CHORD || de-&gt;type() == ElementType::REST) {</a>
<a name="ln822">                  const auto cr = static_cast&lt;ChordRest*&gt;(de);</a>
<a name="ln823">                  const auto durationType = cr-&gt;actualDurationType();</a>
<a name="ln824">                  if (durationType.isValid() &amp;&amp; !durationType.isMeasure()) {</a>
<a name="ln825">                        res += durationType.fraction();</a>
<a name="ln826">                        }</a>
<a name="ln827">                  }</a>
<a name="ln828">            }</a>
<a name="ln829">      res /= t-&gt;ratio();</a>
<a name="ln830"> </a>
<a name="ln831">      return res;</a>
<a name="ln832">      }</a>
<a name="ln833"> </a>
<a name="ln834">//---------------------------------------------------------</a>
<a name="ln835">//   determineTupletBaseLen</a>
<a name="ln836">//---------------------------------------------------------</a>
<a name="ln837"> </a>
<a name="ln838">/**</a>
<a name="ln839"> Determine tuplet baseLen as determined by the tuplet ratio</a>
<a name="ln840"> and duration.</a>
<a name="ln841"> */</a>
<a name="ln842"> </a>
<a name="ln843">static TDuration determineTupletBaseLen(const Tuplet* const t)</a>
<a name="ln844">      {</a>
<a name="ln845">      Fraction tupletFraction;</a>
<a name="ln846">      Fraction tupletFullDuration;</a>
<a name="ln847">      determineTupletFractionAndFullDuration(calculateTupletDuration(t), tupletFraction, tupletFullDuration);</a>
<a name="ln848"> </a>
<a name="ln849">      auto baseLen = tupletFullDuration * Fraction(1, t-&gt;ratio().denominator());</a>
<a name="ln850">      /*</a>
<a name="ln851">      qDebug(&quot;tupletFraction %s tupletFullDuration %s ratio %s baseLen %s&quot;,</a>
<a name="ln852">             qPrintable(tupletFraction.toString()),</a>
<a name="ln853">             qPrintable(tupletFullDuration.toString()),</a>
<a name="ln854">             qPrintable(t-&gt;ratio().toString()),</a>
<a name="ln855">             qPrintable(baseLen.toString())</a>
<a name="ln856">             );</a>
<a name="ln857">       */</a>
<a name="ln858"> </a>
<a name="ln859">      return TDuration(baseLen);</a>
<a name="ln860">      }</a>
<a name="ln861"> </a>
<a name="ln862">//---------------------------------------------------------</a>
<a name="ln863">//   handleTupletStart</a>
<a name="ln864">//---------------------------------------------------------</a>
<a name="ln865"> </a>
<a name="ln866">static void handleTupletStart(const ChordRest* const cr, Tuplet*&amp; tuplet,</a>
<a name="ln867">                              const int actualNotes, const int normalNotes,</a>
<a name="ln868">                              const MusicXmlTupletDesc&amp; tupletDesc)</a>
<a name="ln869">      {</a>
<a name="ln870">      tuplet = new Tuplet(cr-&gt;score());</a>
<a name="ln871">      tuplet-&gt;setTrack(cr-&gt;track());</a>
<a name="ln872">      tuplet-&gt;setRatio(Fraction(actualNotes, normalNotes));</a>
<a name="ln873">      // tuplet-&gt;setTick(cr-&gt;tick());</a>
<a name="ln874">      tuplet-&gt;setBracketType(tupletDesc.bracket);</a>
<a name="ln875">      tuplet-&gt;setNumberType(tupletDesc.shownumber);</a>
<a name="ln876">      // TODO type, placement, bracket</a>
<a name="ln877">      tuplet-&gt;setParent(cr-&gt;measure());</a>
<a name="ln878">      }</a>
<a name="ln879"> </a>
<a name="ln880">//---------------------------------------------------------</a>
<a name="ln881">//   handleTupletStop</a>
<a name="ln882">//---------------------------------------------------------</a>
<a name="ln883"> </a>
<a name="ln884">static void handleTupletStop(Tuplet*&amp; tuplet, const int normalNotes)</a>
<a name="ln885">      {</a>
<a name="ln886">      // allow handleTupletStop to be called w/o error of no tuplet active</a>
<a name="ln887">      if (!tuplet) return;</a>
<a name="ln888"> </a>
<a name="ln889">      // set baselen</a>
<a name="ln890">      TDuration td = determineTupletBaseLen(tuplet);</a>
<a name="ln891">      tuplet-&gt;setBaseLen(td);</a>
<a name="ln892">      Fraction f(normalNotes, td.fraction().denominator());</a>
<a name="ln893">      f.reduce();</a>
<a name="ln894">      tuplet-&gt;setTicks(f);</a>
<a name="ln895">      // TODO determine usefulness of following check</a>
<a name="ln896">      int totalDuration = 0;</a>
<a name="ln897">      foreach (DurationElement* de, tuplet-&gt;elements()) {</a>
<a name="ln898">            if (de-&gt;type() == ElementType::CHORD || de-&gt;type() == ElementType::REST) {</a>
<a name="ln899">                  totalDuration+=de-&gt;globalTicks().ticks();</a>
<a name="ln900">                  }</a>
<a name="ln901">            }</a>
<a name="ln902">      if (!(totalDuration &amp;&amp; normalNotes)) {</a>
<a name="ln903">            qDebug(&quot;MusicXML::import: tuplet stop but bad duration&quot;); // TODO</a>
<a name="ln904">            }</a>
<a name="ln905">      tuplet = 0;</a>
<a name="ln906">      }</a>
<a name="ln907"> </a>
<a name="ln908">//---------------------------------------------------------</a>
<a name="ln909">//   addArticulationToChord</a>
<a name="ln910">//---------------------------------------------------------</a>
<a name="ln911"> </a>
<a name="ln912">static void addArticulationToChord(ChordRest* cr, SymId articSym, QString dir)</a>
<a name="ln913">      {</a>
<a name="ln914">      Articulation* na = new Articulation(articSym, cr-&gt;score());</a>
<a name="ln915">      if (dir == &quot;up&quot;) {</a>
<a name="ln916">            na-&gt;setUp(true);</a>
<a name="ln917">            na-&gt;setAnchor(ArticulationAnchor::TOP_STAFF);</a>
<a name="ln918">            na-&gt;setPropertyFlags(Pid::ARTICULATION_ANCHOR, PropertyFlags::UNSTYLED);</a>
<a name="ln919">            }</a>
<a name="ln920">      else if (dir == &quot;down&quot;) {</a>
<a name="ln921">            na-&gt;setUp(false);</a>
<a name="ln922">            na-&gt;setAnchor(ArticulationAnchor::BOTTOM_STAFF);</a>
<a name="ln923">            na-&gt;setPropertyFlags(Pid::ARTICULATION_ANCHOR, PropertyFlags::UNSTYLED);</a>
<a name="ln924">            }</a>
<a name="ln925">      cr-&gt;add(na);</a>
<a name="ln926">      }</a>
<a name="ln927"> </a>
<a name="ln928">//---------------------------------------------------------</a>
<a name="ln929">//   addAllArticulationsToChord</a>
<a name="ln930">//---------------------------------------------------------</a>
<a name="ln931"> </a>
<a name="ln932">static void addAllArticulationsToChord(ChordRest* cr, std::vector&lt;SymId&gt; symbols)</a>
<a name="ln933">      {</a>
<a name="ln934">      for (const auto symbol : symbols) {</a>
<a name="ln935">            addArticulationToChord(cr, symbol, &quot;&quot;);</a>
<a name="ln936">            }</a>
<a name="ln937">      }</a>
<a name="ln938"> </a>
<a name="ln939">//---------------------------------------------------------</a>
<a name="ln940">//   addFermataToChord</a>
<a name="ln941">//---------------------------------------------------------</a>
<a name="ln942"> </a>
<a name="ln943">static void addFermataToChord(ChordRest* cr, SymId articSym, bool up)</a>
<a name="ln944">      {</a>
<a name="ln945">      Fermata* na = new Fermata(articSym, cr-&gt;score());</a>
<a name="ln946">      na-&gt;setTrack(cr-&gt;track());</a>
<a name="ln947">      na-&gt;setPlacement(up ? Placement::ABOVE : Placement::BELOW);</a>
<a name="ln948">      if (cr-&gt;segment() == nullptr &amp;&amp; cr-&gt;isGrace())</a>
<a name="ln949">            cr-&gt;el().push_back(na);       // store for later move to segment</a>
<a name="ln950">      else</a>
<a name="ln951">            cr-&gt;segment()-&gt;add(na);</a>
<a name="ln952">      }</a>
<a name="ln953"> </a>
<a name="ln954">//---------------------------------------------------------</a>
<a name="ln955">//   addMordentToChord</a>
<a name="ln956">//---------------------------------------------------------</a>
<a name="ln957"> </a>
<a name="ln958">/**</a>
<a name="ln959"> Add Mordent to Chord.</a>
<a name="ln960"> */</a>
<a name="ln961"> </a>
<a name="ln962">static void addMordentToChord(ChordRest* cr, QString name, QString attrLong, QString attrAppr, QString attrDep)</a>
<a name="ln963">      {</a>
<a name="ln964">      SymId articSym = SymId::noSym; // legal but impossible ArticulationType value here indicating &quot;not found&quot;</a>
<a name="ln965">      if (name == &quot;inverted-mordent&quot;) {</a>
<a name="ln966">            if ((attrLong == &quot;&quot; || attrLong == &quot;no&quot;) &amp;&amp; attrAppr == &quot;&quot; &amp;&amp; attrDep == &quot;&quot;)</a>
<a name="ln967">                  articSym = SymId::ornamentMordent;</a>
<a name="ln968">            else if (attrLong == &quot;yes&quot; &amp;&amp; attrAppr == &quot;&quot; &amp;&amp; attrDep == &quot;&quot;)</a>
<a name="ln969">                  articSym = SymId::ornamentTremblement;</a>
<a name="ln970">            else if (attrLong == &quot;yes&quot; &amp;&amp; attrAppr == &quot;below&quot; &amp;&amp; attrDep == &quot;&quot;)</a>
<a name="ln971">                  articSym = SymId::ornamentUpPrall;</a>
<a name="ln972">            else if (attrLong == &quot;yes&quot; &amp;&amp; attrAppr == &quot;above&quot; &amp;&amp; attrDep == &quot;&quot;)</a>
<a name="ln973">                  articSym = SymId::ornamentPrecompMordentUpperPrefix;</a>
<a name="ln974">            else if (attrLong == &quot;yes&quot; &amp;&amp; attrAppr == &quot;&quot; &amp;&amp; attrDep == &quot;below&quot;)</a>
<a name="ln975">                  articSym = SymId::ornamentPrallDown;</a>
<a name="ln976">            else if (attrLong == &quot;yes&quot; &amp;&amp; attrAppr == &quot;&quot; &amp;&amp; attrDep == &quot;above&quot;)</a>
<a name="ln977">                  articSym = SymId::ornamentPrallUp;</a>
<a name="ln978">            }</a>
<a name="ln979">      else if (name == &quot;mordent&quot;) {</a>
<a name="ln980">            if ((attrLong == &quot;&quot; || attrLong == &quot;no&quot;) &amp;&amp; attrAppr == &quot;&quot; &amp;&amp; attrDep == &quot;&quot;)</a>
<a name="ln981">                  articSym = SymId::ornamentMordentInverted;</a>
<a name="ln982">            else if (attrLong == &quot;yes&quot; &amp;&amp; attrAppr == &quot;&quot; &amp;&amp; attrDep == &quot;&quot;)</a>
<a name="ln983">                  articSym = SymId::ornamentPrallMordent;</a>
<a name="ln984">            else if (attrLong == &quot;yes&quot; &amp;&amp; attrAppr == &quot;below&quot; &amp;&amp; attrDep == &quot;&quot;)</a>
<a name="ln985">                  articSym = SymId::ornamentUpMordent;</a>
<a name="ln986">            else if (attrLong == &quot;yes&quot; &amp;&amp; attrAppr == &quot;above&quot; &amp;&amp; attrDep == &quot;&quot;)</a>
<a name="ln987">                  articSym = SymId::ornamentDownMordent;</a>
<a name="ln988">            }</a>
<a name="ln989">      if (articSym != SymId::noSym) {</a>
<a name="ln990">            Articulation* na = new Articulation(cr-&gt;score());</a>
<a name="ln991">            na-&gt;setSymId(articSym);</a>
<a name="ln992">            cr-&gt;add(na);</a>
<a name="ln993">            }</a>
<a name="ln994">      else</a>
<a name="ln995">            qDebug(&quot;unknown ornament: name '%s' long '%s' approach '%s' departure '%s'&quot;,</a>
<a name="ln996">                   qPrintable(name), qPrintable(attrLong), qPrintable(attrAppr), qPrintable(attrDep));  // TODO</a>
<a name="ln997">      }</a>
<a name="ln998"> </a>
<a name="ln999">//---------------------------------------------------------</a>
<a name="ln1000">//   convertArticulationToSymId</a>
<a name="ln1001">//---------------------------------------------------------</a>
<a name="ln1002"> </a>
<a name="ln1003">/**</a>
<a name="ln1004"> Convert a MusicXML articulation to a chord as a &quot;simple&quot; MuseScore articulation.</a>
<a name="ln1005"> These are the articulations that can be</a>
<a name="ln1006"> - represented by an enum class SymId</a>
<a name="ln1007"> - added to a ChordRest</a>
<a name="ln1008"> Return true (articulation recognized and converted)</a>
<a name="ln1009"> or false (articulation not recognized).</a>
<a name="ln1010"> Note simple implementation: MusicXML syntax is not strictly</a>
<a name="ln1011"> checked, the articulations parent element does not matter.</a>
<a name="ln1012"> */</a>
<a name="ln1013"> </a>
<a name="ln1014">static bool convertArticulationToSymId(const QString&amp; mxmlName, SymId&amp; id)</a>
<a name="ln1015">      {</a>
<a name="ln1016">      QMap&lt;QString, SymId&gt; map;       // map MusicXML articulation name to MuseScore symbol</a>
<a name="ln1017">      map[&quot;accent&quot;]           = SymId::articAccentAbove;</a>
<a name="ln1018">      map[&quot;staccatissimo&quot;]    = SymId::articStaccatissimoAbove;</a>
<a name="ln1019">      map[&quot;staccato&quot;]         = SymId::articStaccatoAbove;</a>
<a name="ln1020">      map[&quot;tenuto&quot;]           = SymId::articTenutoAbove;</a>
<a name="ln1021">      map[&quot;turn&quot;]             = SymId::ornamentTurn;</a>
<a name="ln1022">      map[&quot;inverted-turn&quot;]    = SymId::ornamentTurnInverted;</a>
<a name="ln1023">      map[&quot;stopped&quot;]          = SymId::brassMuteClosed;</a>
<a name="ln1024">      // TODO map[&quot;harmonic&quot;]         = SymId::stringsHarmonic;</a>
<a name="ln1025">      map[&quot;up-bow&quot;]           = SymId::stringsUpBow;</a>
<a name="ln1026">      map[&quot;down-bow&quot;]         = SymId::stringsDownBow;</a>
<a name="ln1027">      map[&quot;detached-legato&quot;]  = SymId::articTenutoStaccatoAbove;</a>
<a name="ln1028">      map[&quot;spiccato&quot;]         = SymId::articStaccatissimoAbove;</a>
<a name="ln1029">      map[&quot;snap-pizzicato&quot;]   = SymId::pluckedSnapPizzicatoAbove;</a>
<a name="ln1030">      map[&quot;schleifer&quot;]        = SymId::ornamentPrecompSlide;</a>
<a name="ln1031">      map[&quot;open-string&quot;]      = SymId::brassMuteOpen;</a>
<a name="ln1032">      map[&quot;thumb-position&quot;]   = SymId::stringsThumbPosition;</a>
<a name="ln1033"> </a>
<a name="ln1034">      if (map.contains(mxmlName)) {</a>
<a name="ln1035">            id = map.value(mxmlName);</a>
<a name="ln1036">            return true;</a>
<a name="ln1037">            }</a>
<a name="ln1038">      else {</a>
<a name="ln1039">            id = SymId::noSym;</a>
<a name="ln1040">            return false;</a>
<a name="ln1041">            }</a>
<a name="ln1042">      }</a>
<a name="ln1043"> </a>
<a name="ln1044">//---------------------------------------------------------</a>
<a name="ln1045">//   convertNotehead</a>
<a name="ln1046">//---------------------------------------------------------</a>
<a name="ln1047"> </a>
<a name="ln1048">/**</a>
<a name="ln1049"> Convert a MusicXML notehead name to a MuseScore headgroup.</a>
<a name="ln1050"> */</a>
<a name="ln1051"> </a>
<a name="ln1052">static NoteHead::Group convertNotehead(QString mxmlName)</a>
<a name="ln1053">      {</a>
<a name="ln1054">      QMap&lt;QString, int&gt; map; // map MusicXML notehead name to a MuseScore headgroup</a>
<a name="ln1055">      map[&quot;slash&quot;] = int(NoteHead::Group::HEAD_SLASH);</a>
<a name="ln1056">      map[&quot;triangle&quot;] = int(NoteHead::Group::HEAD_TRIANGLE_UP);</a>
<a name="ln1057">      map[&quot;diamond&quot;] = int(NoteHead::Group::HEAD_DIAMOND);</a>
<a name="ln1058">      map[&quot;cross&quot;] = int(NoteHead::Group::HEAD_PLUS);</a>
<a name="ln1059">      map[&quot;x&quot;] = int(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1060">      map[&quot;circle-x&quot;] = int(NoteHead::Group::HEAD_XCIRCLE);</a>
<a name="ln1061">      map[&quot;inverted triangle&quot;] = int(NoteHead::Group::HEAD_TRIANGLE_DOWN);</a>
<a name="ln1062">      map[&quot;slashed&quot;] = int(NoteHead::Group::HEAD_SLASHED1);</a>
<a name="ln1063">      map[&quot;back slashed&quot;] = int(NoteHead::Group::HEAD_SLASHED2);</a>
<a name="ln1064">      map[&quot;normal&quot;] = int(NoteHead::Group::HEAD_NORMAL);</a>
<a name="ln1065">      map[&quot;do&quot;] = int(NoteHead::Group::HEAD_DO);</a>
<a name="ln1066">      map[&quot;re&quot;] = int(NoteHead::Group::HEAD_RE);</a>
<a name="ln1067">      map[&quot;mi&quot;] = int(NoteHead::Group::HEAD_MI);</a>
<a name="ln1068">      map[&quot;fa&quot;] = int(NoteHead::Group::HEAD_FA);</a>
<a name="ln1069">      map[&quot;fa up&quot;] = int(NoteHead::Group::HEAD_FA);</a>
<a name="ln1070">      map[&quot;so&quot;] = int(NoteHead::Group::HEAD_SOL);</a>
<a name="ln1071">      map[&quot;la&quot;] = int(NoteHead::Group::HEAD_LA);</a>
<a name="ln1072">      map[&quot;ti&quot;] = int(NoteHead::Group::HEAD_TI);</a>
<a name="ln1073"> </a>
<a name="ln1074">      if (map.contains(mxmlName))</a>
<a name="ln1075">            return NoteHead::Group(map.value(mxmlName));</a>
<a name="ln1076">      else</a>
<a name="ln1077">            qDebug(&quot;unknown notehead %s&quot;, qPrintable(mxmlName));  // TODO</a>
<a name="ln1078">      // default: return 0</a>
<a name="ln1079">      return NoteHead::Group::HEAD_NORMAL;</a>
<a name="ln1080">      }</a>
<a name="ln1081"> </a>
<a name="ln1082">//---------------------------------------------------------</a>
<a name="ln1083">//   addTextToNote</a>
<a name="ln1084">//---------------------------------------------------------</a>
<a name="ln1085"> </a>
<a name="ln1086">/**</a>
<a name="ln1087"> Add Text to Note.</a>
<a name="ln1088"> */</a>
<a name="ln1089"> </a>
<a name="ln1090">static void addTextToNote(int l, int c, QString txt, Tid style, Score* score, Note* note)</a>
<a name="ln1091">      {</a>
<a name="ln1092">      if (note) {</a>
<a name="ln1093">            if (!txt.isEmpty()) {</a>
<a name="ln1094">                  TextBase* t = new Fingering(score, style);</a>
<a name="ln1095">                  t-&gt;setPlainText(txt);</a>
<a name="ln1096">                  note-&gt;add(t);</a>
<a name="ln1097">                  }</a>
<a name="ln1098">            }</a>
<a name="ln1099">      else</a>
<a name="ln1100">            qDebug(&quot;%s&quot;, qPrintable(QString(&quot;Error at line %1 col %2: no note for text&quot;).arg(l).arg(c)));       // TODO</a>
<a name="ln1101">      }</a>
<a name="ln1102"> </a>
<a name="ln1103">//---------------------------------------------------------</a>
<a name="ln1104">//   addFermata</a>
<a name="ln1105">//---------------------------------------------------------</a>
<a name="ln1106"> </a>
<a name="ln1107">/**</a>
<a name="ln1108"> Add a MusicXML fermata.</a>
<a name="ln1109"> Note: MusicXML common.mod: &quot;The fermata type is upright if not specified.&quot;</a>
<a name="ln1110"> */</a>
<a name="ln1111"> </a>
<a name="ln1112">static void addFermata(ChordRest* cr, const QString type, const SymId fermataSym)</a>
<a name="ln1113">      {</a>
<a name="ln1114">      if (fermataSym != SymId::noSym) {</a>
<a name="ln1115">            if (type == &quot;upright&quot; || type == &quot;&quot;)</a>
<a name="ln1116">                  addFermataToChord(cr, fermataSym, true);</a>
<a name="ln1117">            else if (type == &quot;inverted&quot;)</a>
<a name="ln1118">                  addFermataToChord(cr, fermataSym, false);</a>
<a name="ln1119">            else</a>
<a name="ln1120">                  qDebug(&quot;unknown fermata type '%s'&quot;, qPrintable(type));</a>
<a name="ln1121">            }</a>
<a name="ln1122">      }</a>
<a name="ln1123"> </a>
<a name="ln1124">//---------------------------------------------------------</a>
<a name="ln1125">//   setSLinePlacement</a>
<a name="ln1126">//---------------------------------------------------------</a>
<a name="ln1127"> </a>
<a name="ln1128">/**</a>
<a name="ln1129"> Helper for direction().</a>
<a name="ln1130"> SLine placement is modified by changing the first segments user offset</a>
<a name="ln1131"> As the SLine has just been created, it does not have any segment yet</a>
<a name="ln1132"> */</a>
<a name="ln1133"> </a>
<a name="ln1134">static void setSLinePlacement(SLine* sli, const QString placement)</a>
<a name="ln1135">      {</a>
<a name="ln1136">      /*</a>
<a name="ln1137">       qDebug(&quot;setSLinePlacement sli %p type %d s=%g pl='%s'&quot;,</a>
<a name="ln1138">       sli, sli-&gt;type(), sli-&gt;score()-&gt;spatium(), qPrintable(placement));</a>
<a name="ln1139">       */</a>
<a name="ln1140"> </a>
<a name="ln1141">#if 0</a>
<a name="ln1142">      // calc y offset assuming five line staff and default style</a>
<a name="ln1143">      // note that required y offset is element type dependent</a>
<a name="ln1144">      if (sli-&gt;type() == ElementType::HAIRPIN) {</a>
<a name="ln1145">            if (placement == &quot;above&quot;) {</a>
<a name="ln1146">                  const qreal stafflines = 5;       // assume five line staff, but works OK-ish for other sizes too</a>
<a name="ln1147">                  qreal offsAbove = -6 - (stafflines - 1);</a>
<a name="ln1148">                  qreal y = 0;</a>
<a name="ln1149">                  y +=  offsAbove;</a>
<a name="ln1150">                  // add linesegment containing the user offset</a>
<a name="ln1151">                  LineSegment* tls= sli-&gt;createLineSegment();</a>
<a name="ln1152">                  //qDebug(&quot;   y = %g&quot;, y);</a>
<a name="ln1153">                  tls-&gt;setAutoplace(false);</a>
<a name="ln1154">                  y *= sli-&gt;score()-&gt;spatium();</a>
<a name="ln1155">                  tls-&gt;setUserOff(QPointF(0, y));</a>
<a name="ln1156">                  sli-&gt;add(tls);</a>
<a name="ln1157">                  }</a>
<a name="ln1158">            }</a>
<a name="ln1159">      else {</a>
<a name="ln1160">            sli-&gt;setPlacement(placement == &quot;above&quot; ? Placement::ABOVE : Placement::BELOW);</a>
<a name="ln1161">            }</a>
<a name="ln1162">#endif</a>
<a name="ln1163">      sli-&gt;setPlacement(placement == &quot;above&quot; ? Placement::ABOVE : Placement::BELOW);</a>
<a name="ln1164">      }</a>
<a name="ln1165"> </a>
<a name="ln1166">//---------------------------------------------------------</a>
<a name="ln1167">//   handleSpannerStart</a>
<a name="ln1168">//---------------------------------------------------------</a>
<a name="ln1169"> </a>
<a name="ln1170">// note that in case of overlapping spanners, handleSpannerStart is called for every spanner</a>
<a name="ln1171">// as spanners QMap allows only one value per key, this does not hurt at all</a>
<a name="ln1172"> </a>
<a name="ln1173">static void handleSpannerStart(SLine* new_sp, int track, QString&amp; placement, const Fraction&amp; tick, MusicXmlSpannerMap&amp; spanners)</a>
<a name="ln1174">      {</a>
<a name="ln1175">      //qDebug(&quot;handleSpannerStart(sp %p, track %d, tick %s (%d))&quot;, new_sp, track, qPrintable(tick.print()), tick.ticks());</a>
<a name="ln1176">      new_sp-&gt;setTrack(track);</a>
<a name="ln1177">      setSLinePlacement(new_sp, placement);</a>
<a name="ln1178">      spanners[new_sp] = QPair&lt;int, int&gt;(tick.ticks(), -1);</a>
<a name="ln1179">      }</a>
<a name="ln1180"> </a>
<a name="ln1181">//---------------------------------------------------------</a>
<a name="ln1182">//   handleSpannerStop</a>
<a name="ln1183">//---------------------------------------------------------</a>
<a name="ln1184"> </a>
<a name="ln1185">static void handleSpannerStop(SLine* cur_sp, int track2, const Fraction&amp; tick, MusicXmlSpannerMap&amp; spanners)</a>
<a name="ln1186">      {</a>
<a name="ln1187">      //qDebug(&quot;handleSpannerStop(sp %p, track2 %d, tick %s (%d))&quot;, cur_sp, track2, qPrintable(tick.print()), tick.ticks());</a>
<a name="ln1188">      if (!cur_sp)</a>
<a name="ln1189">            return;</a>
<a name="ln1190"> </a>
<a name="ln1191">      cur_sp-&gt;setTrack2(track2);</a>
<a name="ln1192">      spanners[cur_sp].second = tick.ticks();</a>
<a name="ln1193">      }</a>
<a name="ln1194"> </a>
<a name="ln1195">//---------------------------------------------------------</a>
<a name="ln1196">//   The MusicXML parser, pass 2</a>
<a name="ln1197">//---------------------------------------------------------</a>
<a name="ln1198"> </a>
<a name="ln1199">//---------------------------------------------------------</a>
<a name="ln1200">//   MusicXMLParserPass2</a>
<a name="ln1201">//---------------------------------------------------------</a>
<a name="ln1202"> </a>
<a name="ln1203">MusicXMLParserPass2::MusicXMLParserPass2(Score* score, MusicXMLParserPass1&amp; pass1, MxmlLogger* logger)</a>
<a name="ln1204">      : _divs(0), _score(score), _pass1(pass1), _logger(logger)</a>
<a name="ln1205">      {</a>
<a name="ln1206">      // nothing</a>
<a name="ln1207">      }</a>
<a name="ln1208"> </a>
<a name="ln1209">//---------------------------------------------------------</a>
<a name="ln1210">//   setChordRestDuration</a>
<a name="ln1211">//---------------------------------------------------------</a>
<a name="ln1212"> </a>
<a name="ln1213">/**</a>
<a name="ln1214"> * Set \a cr duration</a>
<a name="ln1215"> */</a>
<a name="ln1216"> </a>
<a name="ln1217">static void setChordRestDuration(ChordRest* cr, TDuration duration, const Fraction dura)</a>
<a name="ln1218">      {</a>
<a name="ln1219">      if (duration.type() == TDuration::DurationType::V_MEASURE) {</a>
<a name="ln1220">            cr-&gt;setDurationType(duration);</a>
<a name="ln1221">            cr-&gt;setTicks(dura);</a>
<a name="ln1222">            }</a>
<a name="ln1223">      else {</a>
<a name="ln1224">            cr-&gt;setDurationType(duration);</a>
<a name="ln1225">            cr-&gt;setTicks(cr-&gt;durationType().fraction());</a>
<a name="ln1226">            }</a>
<a name="ln1227">      }</a>
<a name="ln1228"> </a>
<a name="ln1229">//---------------------------------------------------------</a>
<a name="ln1230">//   addRest</a>
<a name="ln1231">//---------------------------------------------------------</a>
<a name="ln1232"> </a>
<a name="ln1233">/**</a>
<a name="ln1234"> * Add a rest to the score</a>
<a name="ln1235"> * TODO: beam handling</a>
<a name="ln1236"> * TODO: display step handling</a>
<a name="ln1237"> * TODO: visible handling</a>
<a name="ln1238"> * TODO: whole measure rest handling</a>
<a name="ln1239"> */</a>
<a name="ln1240"> </a>
<a name="ln1241">static Rest* addRest(Score* score, Measure* m,</a>
<a name="ln1242">                     const Fraction&amp; tick, const int track, const int move,</a>
<a name="ln1243">                     const TDuration duration, const Fraction dura)</a>
<a name="ln1244">      {</a>
<a name="ln1245">      Segment* s = m-&gt;getSegment(SegmentType::ChordRest, tick);</a>
<a name="ln1246">      // Sibelius might export two rests at the same place, ignore the 2nd one</a>
<a name="ln1247">      // &lt;?DoletSibelius Two NoteRests in same voice at same position may be an error?&gt;</a>
<a name="ln1248">      if (s-&gt;element(track)) {</a>
<a name="ln1249">            qDebug(&quot;cannot add rest at tick %d track %d: element already present&quot;, tick.ticks(), track);             // TODO</a>
<a name="ln1250">            return 0;</a>
<a name="ln1251">            }</a>
<a name="ln1252"> </a>
<a name="ln1253">      Rest* cr = new Rest(score);</a>
<a name="ln1254">      setChordRestDuration(cr, duration, dura);</a>
<a name="ln1255">      cr-&gt;setTrack(track);</a>
<a name="ln1256">      cr-&gt;setStaffMove(move);</a>
<a name="ln1257">      s-&gt;add(cr);</a>
<a name="ln1258">      return cr;</a>
<a name="ln1259">      }</a>
<a name="ln1260"> </a>
<a name="ln1261">//---------------------------------------------------------</a>
<a name="ln1262">//   resetTuplets</a>
<a name="ln1263">//---------------------------------------------------------</a>
<a name="ln1264"> </a>
<a name="ln1265">static void resetTuplets(Tuplets&amp; tuplets)</a>
<a name="ln1266">      {</a>
<a name="ln1267">      for (auto&amp; pair : tuplets) {</a>
<a name="ln1268">            auto tuplet = pair.second;</a>
<a name="ln1269">            if (tuplet) {</a>
<a name="ln1270">                  const auto actualDuration = tuplet-&gt;elementsDuration() / tuplet-&gt;ratio();</a>
<a name="ln1271">                  const auto missingDuration = missingTupletDuration(actualDuration);</a>
<a name="ln1272">                  qDebug(&quot;tuplet %p not stopped at end of measure, tick %s duration %s missing %s&quot;,</a>
<a name="ln1273">                         tuplet,</a>
<a name="ln1274">                         qPrintable(tuplet-&gt;tick().print()),</a>
<a name="ln1275">                         qPrintable(actualDuration.print()), qPrintable(missingDuration.print()));</a>
<a name="ln1276">                  if (actualDuration &gt; Fraction(0, 1) &amp;&amp; missingDuration &gt; Fraction(0, 1)) {</a>
<a name="ln1277">                        qDebug(&quot;add missing %s to previous tuplet&quot;, qPrintable(missingDuration.print()));</a>
<a name="ln1278">                        const auto&amp; firstElement = tuplet-&gt;elements().at(0);</a>
<a name="ln1279">                        const auto extraRest = addRest(firstElement-&gt;score(), firstElement-&gt;measure(), firstElement-&gt;tick() + missingDuration, firstElement-&gt;track(), 0,</a>
<a name="ln1280">                                                       TDuration { missingDuration * tuplet-&gt;ratio() }, missingDuration);</a>
<a name="ln1281">                        extraRest-&gt;setTuplet(tuplet);</a>
<a name="ln1282">                        tuplet-&gt;add(extraRest);</a>
<a name="ln1283">                        }</a>
<a name="ln1284">                  const auto normalNotes = tuplet-&gt;ratio().denominator();</a>
<a name="ln1285">                  handleTupletStop(tuplet, normalNotes);</a>
<a name="ln1286">                  }</a>
<a name="ln1287">            }</a>
<a name="ln1288">      }</a>
<a name="ln1289"> </a>
<a name="ln1290">//---------------------------------------------------------</a>
<a name="ln1291">//   initPartState</a>
<a name="ln1292">//---------------------------------------------------------</a>
<a name="ln1293"> </a>
<a name="ln1294">/**</a>
<a name="ln1295"> Initialize members as required for reading the MusicXML part element.</a>
<a name="ln1296"> TODO: factor out part reading into a separate class</a>
<a name="ln1297"> TODO: preferably use automatically initialized variables</a>
<a name="ln1298"> Note that Qt automatically initializes new elements in QVector (tuplets).</a>
<a name="ln1299"> */</a>
<a name="ln1300"> </a>
<a name="ln1301">void MusicXMLParserPass2::initPartState(const QString&amp; partId)</a>
<a name="ln1302">      {</a>
<a name="ln1303">      Q_UNUSED(partId);</a>
<a name="ln1304">      _timeSigDura = Fraction(0, 0);             // invalid</a>
<a name="ln1305">      _tie    = 0;</a>
<a name="ln1306">      _lastVolta = 0;</a>
<a name="ln1307">      _hasDrumset = false;</a>
<a name="ln1308">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln1309">            _slurs[i] = SlurDesc();</a>
<a name="ln1310">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln1311">            _trills[i] = 0;</a>
<a name="ln1312">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln1313">            _glissandi[i][0] = _glissandi[i][1] = 0;</a>
<a name="ln1314">      _pedalContinue = 0;</a>
<a name="ln1315">      _harmony = 0;</a>
<a name="ln1316">      _tremStart = 0;</a>
<a name="ln1317">      _figBass = 0;</a>
<a name="ln1318">      _multiMeasureRestCount = -1;</a>
<a name="ln1319">      _extendedLyrics.init();</a>
<a name="ln1320">      }</a>
<a name="ln1321"> </a>
<a name="ln1322">//---------------------------------------------------------</a>
<a name="ln1323">//   findIncompleteSpannersInStack</a>
<a name="ln1324">//---------------------------------------------------------</a>
<a name="ln1325"> </a>
<a name="ln1326">static void findIncompleteSpannersInStack(const QString&amp; spannerType, SpannerStack&amp; stack, SpannerSet&amp; res)</a>
<a name="ln1327">      {</a>
<a name="ln1328">      for (auto&amp; desc : stack) {</a>
<a name="ln1329">            if (desc._sp) {</a>
<a name="ln1330">                  qDebug(&quot;%s not terminated at end of part&quot;, qPrintable(spannerType));</a>
<a name="ln1331">                  res.insert(desc._sp);</a>
<a name="ln1332">                  desc = {};</a>
<a name="ln1333">                  }</a>
<a name="ln1334">            }</a>
<a name="ln1335">      }</a>
<a name="ln1336"> </a>
<a name="ln1337">//---------------------------------------------------------</a>
<a name="ln1338">//   findIncompleteSpannersAtPartEnd</a>
<a name="ln1339">//---------------------------------------------------------</a>
<a name="ln1340"> </a>
<a name="ln1341">SpannerSet MusicXMLParserPass2::findIncompleteSpannersAtPartEnd()</a>
<a name="ln1342">      {</a>
<a name="ln1343">      SpannerSet res;</a>
<a name="ln1344">      findIncompleteSpannersInStack(&quot;bracket&quot;, _brackets, res);</a>
<a name="ln1345">      findIncompleteSpannersInStack(&quot;wedge&quot;, _hairpins, res);</a>
<a name="ln1346">      findIncompleteSpannersInStack(&quot;octave-shift&quot;, _ottavas, res);</a>
<a name="ln1347">      if (_pedal._sp) {</a>
<a name="ln1348">            qDebug(&quot;pedal not terminated at end of part&quot;);</a>
<a name="ln1349">            res.insert(_pedal._sp);</a>
<a name="ln1350">            _pedal = {};</a>
<a name="ln1351">            }</a>
<a name="ln1352">      return res;</a>
<a name="ln1353">      }</a>
<a name="ln1354"> </a>
<a name="ln1355">//---------------------------------------------------------</a>
<a name="ln1356">// multi-measure rest state handling</a>
<a name="ln1357">//---------------------------------------------------------</a>
<a name="ln1358"> </a>
<a name="ln1359">// If any multi-measure rest is found, the &quot;create multi-measure rest&quot; style setting is enabled.</a>
<a name="ln1360">// First measure in a multi-measure rest gets setBreakMultiMeasureRest(true), then count down</a>
<a name="ln1361">// the remaining number of measures.</a>
<a name="ln1362">// The first measure after a multi-measure rest gets setBreakMultiMeasureRest(true).</a>
<a name="ln1363">// For all other measures breakMultiMeasureRest is unchanged (stays default (false)).</a>
<a name="ln1364"> </a>
<a name="ln1365">//---------------------------------------------------------</a>
<a name="ln1366">//   setMultiMeasureRestCount</a>
<a name="ln1367">//---------------------------------------------------------</a>
<a name="ln1368"> </a>
<a name="ln1369">/**</a>
<a name="ln1370"> Set the multi-measure rest counter.</a>
<a name="ln1371"> */</a>
<a name="ln1372"> </a>
<a name="ln1373"> </a>
<a name="ln1374">void MusicXMLParserPass2::setMultiMeasureRestCount(int count)</a>
<a name="ln1375">      {</a>
<a name="ln1376">      _multiMeasureRestCount = count;</a>
<a name="ln1377">      }</a>
<a name="ln1378"> </a>
<a name="ln1379">//---------------------------------------------------------</a>
<a name="ln1380">//   getAndDecMultiMeasureRestCount</a>
<a name="ln1381">//---------------------------------------------------------</a>
<a name="ln1382"> </a>
<a name="ln1383">/**</a>
<a name="ln1384"> Return current multi-measure rest counter.</a>
<a name="ln1385"> Decrement counter if possible (not beyond -1).</a>
<a name="ln1386"> */</a>
<a name="ln1387"> </a>
<a name="ln1388">int MusicXMLParserPass2::getAndDecMultiMeasureRestCount()</a>
<a name="ln1389">      {</a>
<a name="ln1390">      int res = _multiMeasureRestCount;</a>
<a name="ln1391">      if (_multiMeasureRestCount &gt;= 0)</a>
<a name="ln1392">            _multiMeasureRestCount--;</a>
<a name="ln1393">      return res;</a>
<a name="ln1394">      }</a>
<a name="ln1395"> </a>
<a name="ln1396">//---------------------------------------------------------</a>
<a name="ln1397">//   skipLogCurrElem</a>
<a name="ln1398">//---------------------------------------------------------</a>
<a name="ln1399"> </a>
<a name="ln1400">/**</a>
<a name="ln1401"> Skip the current element, log debug as info.</a>
<a name="ln1402"> */</a>
<a name="ln1403"> </a>
<a name="ln1404">void MusicXMLParserDirection::skipLogCurrElem()</a>
<a name="ln1405">      {</a>
<a name="ln1406">      //_logger-&gt;logDebugInfo(QString(&quot;skipping '%1'&quot;).arg(_e.name().toString()), &amp;_e);</a>
<a name="ln1407">      _e.skipCurrentElement();</a>
<a name="ln1408">      }</a>
<a name="ln1409"> </a>
<a name="ln1410">//---------------------------------------------------------</a>
<a name="ln1411">//   skipLogCurrElem</a>
<a name="ln1412">//---------------------------------------------------------</a>
<a name="ln1413"> </a>
<a name="ln1414">/**</a>
<a name="ln1415"> Skip the current element, log debug as info.</a>
<a name="ln1416"> */</a>
<a name="ln1417"> </a>
<a name="ln1418">void MusicXMLParserPass2::skipLogCurrElem()</a>
<a name="ln1419">      {</a>
<a name="ln1420">      //_logger-&gt;logDebugInfo(QString(&quot;skipping '%1'&quot;).arg(_e.name().toString()), &amp;_e);</a>
<a name="ln1421">      _e.skipCurrentElement();</a>
<a name="ln1422">      }</a>
<a name="ln1423"> </a>
<a name="ln1424">//---------------------------------------------------------</a>
<a name="ln1425">//   parse</a>
<a name="ln1426">//---------------------------------------------------------</a>
<a name="ln1427"> </a>
<a name="ln1428">/**</a>
<a name="ln1429"> Parse MusicXML in \a device and extract pass 2 data.</a>
<a name="ln1430"> */</a>
<a name="ln1431"> </a>
<a name="ln1432">Score::FileError MusicXMLParserPass2::parse(QIODevice* device)</a>
<a name="ln1433">      {</a>
<a name="ln1434">      //qDebug(&quot;MusicXMLParserPass2::parse()&quot;);</a>
<a name="ln1435">      _e.setDevice(device);</a>
<a name="ln1436">      Score::FileError res = parse();</a>
<a name="ln1437">      //qDebug(&quot;MusicXMLParserPass2::parse() res %d&quot;, int(res));</a>
<a name="ln1438">      return res;</a>
<a name="ln1439">      }</a>
<a name="ln1440"> </a>
<a name="ln1441">//---------------------------------------------------------</a>
<a name="ln1442">//   parse</a>
<a name="ln1443">//---------------------------------------------------------</a>
<a name="ln1444"> </a>
<a name="ln1445">/**</a>
<a name="ln1446"> Start the parsing process, after verifying the top-level node is score-partwise</a>
<a name="ln1447"> */</a>
<a name="ln1448"> </a>
<a name="ln1449">Score::FileError MusicXMLParserPass2::parse()</a>
<a name="ln1450">      {</a>
<a name="ln1451">      bool found = false;</a>
<a name="ln1452">      while (_e.readNextStartElement()) {</a>
<a name="ln1453">            if (_e.name() == &quot;score-partwise&quot;) {</a>
<a name="ln1454">                  found = true;</a>
<a name="ln1455">                  scorePartwise();</a>
<a name="ln1456">                  }</a>
<a name="ln1457">            else {</a>
<a name="ln1458">                  _logger-&gt;logError(&quot;this is not a MusicXML score-partwise file&quot;, &amp;_e);</a>
<a name="ln1459">                  _e.skipCurrentElement();</a>
<a name="ln1460">                  return Score::FileError::FILE_BAD_FORMAT;</a>
<a name="ln1461">                  }</a>
<a name="ln1462">            }</a>
<a name="ln1463"> </a>
<a name="ln1464">      if (!found) {</a>
<a name="ln1465">            _logger-&gt;logError(&quot;this is not a MusicXML score-partwise file&quot;, &amp;_e);</a>
<a name="ln1466">            return Score::FileError::FILE_BAD_FORMAT;</a>
<a name="ln1467">            }</a>
<a name="ln1468"> </a>
<a name="ln1469">      return Score::FileError::FILE_NO_ERROR;</a>
<a name="ln1470">      }</a>
<a name="ln1471"> </a>
<a name="ln1472">//---------------------------------------------------------</a>
<a name="ln1473">//   scorePartwise</a>
<a name="ln1474">//---------------------------------------------------------</a>
<a name="ln1475"> </a>
<a name="ln1476">/**</a>
<a name="ln1477"> Parse the MusicXML top-level (XPath /score-partwise) node.</a>
<a name="ln1478"> */</a>
<a name="ln1479"> </a>
<a name="ln1480">void MusicXMLParserPass2::scorePartwise()</a>
<a name="ln1481">      {</a>
<a name="ln1482">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;score-partwise&quot;);</a>
<a name="ln1483"> </a>
<a name="ln1484">      while (_e.readNextStartElement()) {</a>
<a name="ln1485">            if (_e.name() == &quot;part&quot;) {</a>
<a name="ln1486">                  part();</a>
<a name="ln1487">                  }</a>
<a name="ln1488">            else if (_e.name() == &quot;part-list&quot;)</a>
<a name="ln1489">                  partList();</a>
<a name="ln1490">            else</a>
<a name="ln1491">                  skipLogCurrElem();</a>
<a name="ln1492">            }</a>
<a name="ln1493">      // set last measure barline to normal or MuseScore will generate light-heavy EndBarline</a>
<a name="ln1494">      // TODO, handle other tracks?</a>
<a name="ln1495">      if (_score-&gt;lastMeasure()-&gt;endBarLineType() == BarLineType::NORMAL)</a>
<a name="ln1496">            _score-&gt;lastMeasure()-&gt;setEndBarLineType(BarLineType::NORMAL, 0);</a>
<a name="ln1497">      }</a>
<a name="ln1498"> </a>
<a name="ln1499">//---------------------------------------------------------</a>
<a name="ln1500">//   partList</a>
<a name="ln1501">//---------------------------------------------------------</a>
<a name="ln1502"> </a>
<a name="ln1503">/**</a>
<a name="ln1504"> Parse the /score-partwise/part-list node.</a>
<a name="ln1505"> */</a>
<a name="ln1506"> </a>
<a name="ln1507">void MusicXMLParserPass2::partList()</a>
<a name="ln1508">      {</a>
<a name="ln1509">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;part-list&quot;);</a>
<a name="ln1510"> </a>
<a name="ln1511">      while (_e.readNextStartElement()) {</a>
<a name="ln1512">            if (_e.name() == &quot;score-part&quot;)</a>
<a name="ln1513">                  scorePart();</a>
<a name="ln1514">            else</a>
<a name="ln1515">                  skipLogCurrElem();</a>
<a name="ln1516">            }</a>
<a name="ln1517">      }</a>
<a name="ln1518"> </a>
<a name="ln1519">//---------------------------------------------------------</a>
<a name="ln1520">//   scorePart</a>
<a name="ln1521">//---------------------------------------------------------</a>
<a name="ln1522"> </a>
<a name="ln1523">// Parse the /score-partwise/part-list/score-part node.</a>
<a name="ln1524">// TODO: nothing required for pass 2 ?</a>
<a name="ln1525"> </a>
<a name="ln1526">void MusicXMLParserPass2::scorePart()</a>
<a name="ln1527">      {</a>
<a name="ln1528">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;score-part&quot;);</a>
<a name="ln1529"> </a>
<a name="ln1530">      while (_e.readNextStartElement()) {</a>
<a name="ln1531">            if (_e.name() == &quot;midi-instrument&quot;)</a>
<a name="ln1532">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1533">            else if (_e.name() == &quot;score-instrument&quot;)</a>
<a name="ln1534">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1535">            else if (_e.name() == &quot;part-name&quot;)</a>
<a name="ln1536">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln1537">            else</a>
<a name="ln1538">                  skipLogCurrElem();</a>
<a name="ln1539">            }</a>
<a name="ln1540">      }</a>
<a name="ln1541"> </a>
<a name="ln1542">//---------------------------------------------------------</a>
<a name="ln1543">//   part</a>
<a name="ln1544">//---------------------------------------------------------</a>
<a name="ln1545"> </a>
<a name="ln1546">/**</a>
<a name="ln1547"> Parse the /score-partwise/part node.</a>
<a name="ln1548"> */</a>
<a name="ln1549"> </a>
<a name="ln1550">void MusicXMLParserPass2::part()</a>
<a name="ln1551">      {</a>
<a name="ln1552">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;part&quot;);</a>
<a name="ln1553">      const QString id = _e.attributes().value(&quot;id&quot;).toString();</a>
<a name="ln1554"> </a>
<a name="ln1555">      if (!_pass1.hasPart(id)) {</a>
<a name="ln1556">            _logger-&gt;logError(QString(&quot;MusicXMLParserPass2::part cannot find part '%1'&quot;).arg(id), &amp;_e);</a>
<a name="ln1557">            skipLogCurrElem();</a>
<a name="ln1558">            }</a>
<a name="ln1559"> </a>
<a name="ln1560">      initPartState(id);</a>
<a name="ln1561"> </a>
<a name="ln1562">      const MusicXMLDrumset&amp; mxmlDrumset = _pass1.getDrumset(id);</a>
<a name="ln1563">      _hasDrumset = hasDrumset(mxmlDrumset);</a>
<a name="ln1564"> </a>
<a name="ln1565">      // set the parts first instrument</a>
<a name="ln1566">      QString instrId = _pass1.getInstrList(id).instrument(Fraction(0, 1));</a>
<a name="ln1567">      setFirstInstrument(_logger, &amp;_e, _pass1.getPart(id), id, instrId, mxmlDrumset);</a>
<a name="ln1568"> </a>
<a name="ln1569">      // set the part name</a>
<a name="ln1570">      auto mxmlPart = _pass1.getMusicXmlPart(id);</a>
<a name="ln1571">      _pass1.getPart(id)-&gt;setPartName(mxmlPart.getName());</a>
<a name="ln1572">      if (mxmlPart.getPrintName())</a>
<a name="ln1573">            _pass1.getPart(id)-&gt;setLongName(mxmlPart.getName());</a>
<a name="ln1574">      if (mxmlPart.getPrintAbbr())</a>
<a name="ln1575">            _pass1.getPart(id)-&gt;setPlainShortName(mxmlPart.getAbbr());</a>
<a name="ln1576">      // try to prevent an empty track name</a>
<a name="ln1577">      if (_pass1.getPart(id)-&gt;partName() == &quot;&quot;)</a>
<a name="ln1578">            _pass1.getPart(id)-&gt;setPartName(mxmlDrumset[instrId].name);</a>
<a name="ln1579"> </a>
<a name="ln1580">#ifdef DEBUG_VOICE_MAPPER</a>
<a name="ln1581">      VoiceList voicelist = _pass1.getVoiceList(id);</a>
<a name="ln1582">      // debug: print voice mapper contents</a>
<a name="ln1583">      qDebug(&quot;voiceMapperStats: part '%s'&quot;, qPrintable(id));</a>
<a name="ln1584">      for (QMap&lt;QString, Ms::VoiceDesc&gt;::const_iterator i = voicelist.constBegin(); i != voicelist.constEnd(); ++i) {</a>
<a name="ln1585">            qDebug(&quot;voiceMapperStats: voice %s staff data %s&quot;,</a>
<a name="ln1586">                   qPrintable(i.key()), qPrintable(i.value().toString()));</a>
<a name="ln1587">            }</a>
<a name="ln1588">#endif</a>
<a name="ln1589"> </a>
<a name="ln1590">      // read the measures</a>
<a name="ln1591">      int nr = 0; // current measure sequence number</a>
<a name="ln1592">      while (_e.readNextStartElement()) {</a>
<a name="ln1593">            if (_e.name() == &quot;measure&quot;) {</a>
<a name="ln1594">                  Fraction t = _pass1.getMeasureStart(nr);</a>
<a name="ln1595">                  if (t.isValid())</a>
<a name="ln1596">                        measure(id, t);</a>
<a name="ln1597">                  else {</a>
<a name="ln1598">                        _logger-&gt;logError(QString(&quot;no valid start time for measure %1&quot;).arg(nr + 1), &amp;_e);</a>
<a name="ln1599">                        _e.skipCurrentElement();</a>
<a name="ln1600">                        }</a>
<a name="ln1601">                  ++nr;</a>
<a name="ln1602">                  }</a>
<a name="ln1603">            else</a>
<a name="ln1604">                  skipLogCurrElem();</a>
<a name="ln1605">            }</a>
<a name="ln1606"> </a>
<a name="ln1607">      // stop all remaining extends for this part</a>
<a name="ln1608">      Measure* lm = _pass1.getPart(id)-&gt;score()-&gt;lastMeasure();</a>
<a name="ln1609">      if (lm) {</a>
<a name="ln1610">            int strack = _pass1.trackForPart(id);</a>
<a name="ln1611">            int etrack = strack + _pass1.getPart(id)-&gt;nstaves() * VOICES;</a>
<a name="ln1612">            Fraction lastTick = lm-&gt;endTick();</a>
<a name="ln1613">            for (int trk = strack; trk &lt; etrack; trk++)</a>
<a name="ln1614">                  _extendedLyrics.setExtend(-1, trk, lastTick);</a>
<a name="ln1615">            }</a>
<a name="ln1616"> </a>
<a name="ln1617">      const auto incompleteSpanners =  findIncompleteSpannersAtPartEnd();</a>
<a name="ln1618">      //qDebug(&quot;spanner list:&quot;);</a>
<a name="ln1619">      auto i = _spanners.constBegin();</a>
<a name="ln1620">      while (i != _spanners.constEnd()) {</a>
<a name="ln1621">            auto sp = i.key();</a>
<a name="ln1622">            Fraction tick1 = Fraction::fromTicks(i.value().first);</a>
<a name="ln1623">            Fraction tick2 = Fraction::fromTicks(i.value().second);</a>
<a name="ln1624">            //qDebug(&quot;spanner %p tp %d tick1 %s tick2 %s track1 %d track2 %d&quot;,</a>
<a name="ln1625">            //       sp, sp-&gt;type(), qPrintable(tick1.print()), qPrintable(tick2.print()), sp-&gt;track(), sp-&gt;track2());</a>
<a name="ln1626">            if (incompleteSpanners.find(sp) == incompleteSpanners.end()) {</a>
<a name="ln1627">                  // complete spanner -&gt; add to score</a>
<a name="ln1628">                  sp-&gt;setTick(tick1);</a>
<a name="ln1629">                  sp-&gt;setTick2(tick2);</a>
<a name="ln1630">                  sp-&gt;score()-&gt;addElement(sp);</a>
<a name="ln1631">                  }</a>
<a name="ln1632">            else {</a>
<a name="ln1633">                  // incomplete spanner -&gt; cleanup</a>
<a name="ln1634">                  delete sp;</a>
<a name="ln1635">                  }</a>
<a name="ln1636">            ++i;</a>
<a name="ln1637">            }</a>
<a name="ln1638">      _spanners.clear();</a>
<a name="ln1639"> </a>
<a name="ln1640">      // determine if the part contains a drumset</a>
<a name="ln1641">      // this is the case if any instrument has a midi-unpitched element,</a>
<a name="ln1642">      // (which stored in the MusicXMLDrumInstrument pitch field)</a>
<a name="ln1643">      // if the part contains a drumset, Drumset drumset is initialized</a>
<a name="ln1644"> </a>
<a name="ln1645">      Drumset* drumset = new Drumset;</a>
<a name="ln1646">      const MusicXMLDrumset&amp; mxmlDrumsetAfterPass2 = _pass1.getDrumset(id);</a>
<a name="ln1647">      initDrumset(drumset, mxmlDrumsetAfterPass2);</a>
<a name="ln1648"> </a>
<a name="ln1649">      // debug: dump the instrument map</a>
<a name="ln1650">      /*</a>
<a name="ln1651">            {</a>
<a name="ln1652">            qDebug(&quot;instrlist&quot;);</a>
<a name="ln1653">            auto il = _pass1.getInstrList(id);</a>
<a name="ln1654">            for (auto it = il.cbegin(); it != il.cend(); ++it) {</a>
<a name="ln1655">                  Fraction f = (*it).first;</a>
<a name="ln1656">                  qDebug(&quot;pass2: instrument map: tick %s (%d) instr '%s'&quot;, qPrintable(f.print()), f.ticks(), qPrintable((*it).second));</a>
<a name="ln1657">                  }</a>
<a name="ln1658">            }</a>
<a name="ln1659">      */</a>
<a name="ln1660"> </a>
<a name="ln1661">      if (_hasDrumset) {</a>
<a name="ln1662">            // set staff type to percussion if incorrectly imported as pitched staff</a>
<a name="ln1663">            // Note: part has been read, staff type already set based on clef type and staff-details</a>
<a name="ln1664">            // but may be incorrect for a percussion staff that does not use a percussion clef</a>
<a name="ln1665">            setStaffTypePercussion(_pass1.getPart(id), drumset);</a>
<a name="ln1666">            }</a>
<a name="ln1667">      else {</a>
<a name="ln1668">            // drumset is not needed</a>
<a name="ln1669">            delete drumset;</a>
<a name="ln1670">            // set the instruments for this part</a>
<a name="ln1671">            setPartInstruments(_logger, &amp;_e, _pass1.getPart(id), id, _score, _pass1.getInstrList(id), mxmlDrumset);</a>
<a name="ln1672">            }</a>
<a name="ln1673">      }</a>
<a name="ln1674"> </a>
<a name="ln1675">//---------------------------------------------------------</a>
<a name="ln1676">//   findMeasure</a>
<a name="ln1677">//---------------------------------------------------------</a>
<a name="ln1678"> </a>
<a name="ln1679">/**</a>
<a name="ln1680"> In Score \a score find the measure starting at \a tick.</a>
<a name="ln1681"> */</a>
<a name="ln1682"> </a>
<a name="ln1683">static Measure* findMeasure(Score* score, const Fraction&amp; tick)</a>
<a name="ln1684">      {</a>
<a name="ln1685">      for (Measure* m = score-&gt;firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln1686">            if (m-&gt;tick() == tick)</a>
<a name="ln1687">                  return m;</a>
<a name="ln1688">            }</a>
<a name="ln1689">      return 0;</a>
<a name="ln1690">      }</a>
<a name="ln1691"> </a>
<a name="ln1692">//---------------------------------------------------------</a>
<a name="ln1693">//   removeBeam</a>
<a name="ln1694">//---------------------------------------------------------</a>
<a name="ln1695"> </a>
<a name="ln1696">/**</a>
<a name="ln1697"> Set beam mode for all elements and remove the beam</a>
<a name="ln1698"> */</a>
<a name="ln1699"> </a>
<a name="ln1700">static void removeBeam(Beam*&amp; beam)</a>
<a name="ln1701">      {</a>
<a name="ln1702">      for (int i = 0; i &lt; beam-&gt;elements().size(); ++i)</a>
<a name="ln1703">            beam-&gt;elements().at(i)-&gt;setBeamMode(Beam::Mode::NONE);</a>
<a name="ln1704">      delete beam;</a>
<a name="ln1705">      beam = 0;</a>
<a name="ln1706">      }</a>
<a name="ln1707"> </a>
<a name="ln1708">//---------------------------------------------------------</a>
<a name="ln1709">//   handleBeamAndStemDir</a>
<a name="ln1710">//---------------------------------------------------------</a>
<a name="ln1711"> </a>
<a name="ln1712">static void handleBeamAndStemDir(ChordRest* cr, const Beam::Mode bm, const Direction sd, Beam*&amp; beam)</a>
<a name="ln1713">      {</a>
<a name="ln1714">      if (!cr) return;</a>
<a name="ln1715">      // create a new beam</a>
<a name="ln1716">      if (bm == Beam::Mode::BEGIN) {</a>
<a name="ln1717">            // if currently in a beam, delete it</a>
<a name="ln1718">            if (beam) {</a>
<a name="ln1719">                  qDebug(&quot;handleBeamAndStemDir() new beam, removing previous incomplete beam %p&quot;, beam);</a>
<a name="ln1720">                  removeBeam(beam);</a>
<a name="ln1721">                  }</a>
<a name="ln1722">            // create a new beam</a>
<a name="ln1723">            beam = new Beam(cr-&gt;score());</a>
<a name="ln1724">            beam-&gt;setTrack(cr-&gt;track());</a>
<a name="ln1725">            beam-&gt;setBeamDirection(sd);</a>
<a name="ln1726">            }</a>
<a name="ln1727">      // add ChordRest to beam</a>
<a name="ln1728">      if (beam) {</a>
<a name="ln1729">            // verify still in the same track (switching voices in the middle of a beam is not supported)</a>
<a name="ln1730">            // and in a beam ...</a>
<a name="ln1731">            // (note no check is done on correct order of beam begin/continue/end)</a>
<a name="ln1732">            if (cr-&gt;track() != beam-&gt;track()) {</a>
<a name="ln1733">                  qDebug(&quot;handleBeamAndStemDir() from track %d to track %d -&gt; abort beam&quot;,</a>
<a name="ln1734">                         beam-&gt;track(), cr-&gt;track());</a>
<a name="ln1735">                  // reset beam mode for all elements and remove the beam</a>
<a name="ln1736">                  removeBeam(beam);</a>
<a name="ln1737">                  }</a>
<a name="ln1738">            else if (bm == Beam::Mode::NONE) {</a>
<a name="ln1739">                  qDebug(&quot;handleBeamAndStemDir() in beam, bm Beam::Mode::NONE -&gt; abort beam&quot;);</a>
<a name="ln1740">                  // reset beam mode for all elements and remove the beam</a>
<a name="ln1741">                  removeBeam(beam);</a>
<a name="ln1742">                  }</a>
<a name="ln1743">            else if (!(bm == Beam::Mode::BEGIN || bm == Beam::Mode::MID || bm == Beam::Mode::END)) {</a>
<a name="ln1744">                  qDebug(&quot;handleBeamAndStemDir() in beam, bm %d -&gt; abort beam&quot;, static_cast&lt;int&gt;(bm));</a>
<a name="ln1745">                  // reset beam mode for all elements and remove the beam</a>
<a name="ln1746">                  removeBeam(beam);</a>
<a name="ln1747">                  }</a>
<a name="ln1748">            else {</a>
<a name="ln1749">                  // actually add cr to the beam</a>
<a name="ln1750">                  beam-&gt;add(cr);</a>
<a name="ln1751">                  }</a>
<a name="ln1752">            }</a>
<a name="ln1753">      // if no beam, set stem direction on chord itself and set beam to auto</a>
<a name="ln1754">      if (!beam) {</a>
<a name="ln1755">            static_cast&lt;Chord*&gt;(cr)-&gt;setStemDirection(sd);</a>
<a name="ln1756">            cr-&gt;setBeamMode(Beam::Mode::AUTO);</a>
<a name="ln1757">            }</a>
<a name="ln1758">      // terminate the current beam and add to the score</a>
<a name="ln1759">      if (beam &amp;&amp; bm == Beam::Mode::END)</a>
<a name="ln1760">            beam = 0;</a>
<a name="ln1761">      }</a>
<a name="ln1762"> </a>
<a name="ln1763"> </a>
<a name="ln1764">//---------------------------------------------------------</a>
<a name="ln1765">//   markUserAccidentals</a>
<a name="ln1766">//---------------------------------------------------------</a>
<a name="ln1767"> </a>
<a name="ln1768">/**</a>
<a name="ln1769"> Check for &quot;superfluous&quot; accidentals to mark them as USER accidentals.</a>
<a name="ln1770"> The candidate map alterMap is ordered on note address. Check it here segment after segment.</a>
<a name="ln1771"> */</a>
<a name="ln1772"> </a>
<a name="ln1773">static void markUserAccidentals(const int firstStaff,</a>
<a name="ln1774">                                const int staves,</a>
<a name="ln1775">                                const Key key,</a>
<a name="ln1776">                                const Measure* measure,</a>
<a name="ln1777">                                const QMap&lt;Note*, int&gt;&amp; alterMap</a>
<a name="ln1778">                                )</a>
<a name="ln1779">      {</a>
<a name="ln1780">      QMap&lt;int, bool&gt; accTmp;</a>
<a name="ln1781"> </a>
<a name="ln1782">      AccidentalState currAcc;</a>
<a name="ln1783">      currAcc.init(key);</a>
<a name="ln1784">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln1785">      for (Ms::Segment* segment = measure-&gt;first(st); segment; segment = segment-&gt;next(st)) {</a>
<a name="ln1786">            for (int track = 0; track &lt; staves * VOICES; ++track) {</a>
<a name="ln1787">                  Element* e = segment-&gt;element(firstStaff * VOICES + track);</a>
<a name="ln1788">                  if (!e || e-&gt;type() != Ms::ElementType::CHORD)</a>
<a name="ln1789">                        continue;</a>
<a name="ln1790">                  Chord* chord = static_cast&lt;Chord*&gt;(e);</a>
<a name="ln1791">                  foreach (Note* nt, chord-&gt;notes()) {</a>
<a name="ln1792">                        if (alterMap.contains(nt)) {</a>
<a name="ln1793">                              int alter = alterMap.value(nt);</a>
<a name="ln1794">                              int ln  = absStep(nt-&gt;tpc(), nt-&gt;pitch());</a>
<a name="ln1795">                              bool error = false;</a>
<a name="ln1796">                              AccidentalVal currAccVal = currAcc.accidentalVal(ln, error);</a>
<a name="ln1797">                              if (error)</a>
<a name="ln1798">                                    continue;</a>
<a name="ln1799">                              if ((alter == -1</a>
<a name="ln1800">                                   &amp;&amp; currAccVal == AccidentalVal::FLAT</a>
<a name="ln1801">                                   &amp;&amp; nt-&gt;accidental()-&gt;accidentalType() == AccidentalType::FLAT</a>
<a name="ln1802">                                   &amp;&amp; !accTmp.value(ln, false))</a>
<a name="ln1803">                                  || (alter ==  0</a>
<a name="ln1804">                                      &amp;&amp; currAccVal == AccidentalVal::NATURAL</a>
<a name="ln1805">                                      &amp;&amp; nt-&gt;accidental()-&gt;accidentalType() == AccidentalType::NATURAL</a>
<a name="ln1806">                                      &amp;&amp; !accTmp.value(ln, false))</a>
<a name="ln1807">                                  || (alter ==  1</a>
<a name="ln1808">                                      &amp;&amp; currAccVal == AccidentalVal::SHARP</a>
<a name="ln1809">                                      &amp;&amp; nt-&gt;accidental()-&gt;accidentalType() == AccidentalType::SHARP</a>
<a name="ln1810">                                      &amp;&amp; !accTmp.value(ln, false))) {</a>
<a name="ln1811">                                    nt-&gt;accidental()-&gt;setRole(AccidentalRole::USER);</a>
<a name="ln1812">                                    }</a>
<a name="ln1813">                              else if (Accidental::isMicrotonal(nt-&gt;accidental()-&gt;accidentalType())</a>
<a name="ln1814">                                       &amp;&amp; nt-&gt;accidental()-&gt;accidentalType() &lt; AccidentalType::END) {</a>
<a name="ln1815">                                    // microtonal accidental</a>
<a name="ln1816">                                    nt-&gt;accidental()-&gt;setRole(AccidentalRole::USER);</a>
<a name="ln1817">                                    accTmp.insert(ln, false);</a>
<a name="ln1818">                                    }</a>
<a name="ln1819">                              else {</a>
<a name="ln1820">                                    accTmp.insert(ln, true);</a>
<a name="ln1821">                                    }</a>
<a name="ln1822">                              }</a>
<a name="ln1823">                        }</a>
<a name="ln1824">                  }</a>
<a name="ln1825">            }</a>
<a name="ln1826">      }</a>
<a name="ln1827"> </a>
<a name="ln1828">//---------------------------------------------------------</a>
<a name="ln1829">//   addGraceChordsAfter</a>
<a name="ln1830">//---------------------------------------------------------</a>
<a name="ln1831"> </a>
<a name="ln1832">/**</a>
<a name="ln1833"> Move \a gac grace chords from grace chord list \a gcl</a>
<a name="ln1834"> to the chord \a c grace note after list</a>
<a name="ln1835"> */</a>
<a name="ln1836"> </a>
<a name="ln1837">static void addGraceChordsAfter(Chord* c, GraceChordList&amp; gcl, int&amp; gac)</a>
<a name="ln1838">      {</a>
<a name="ln1839">      if (!c)</a>
<a name="ln1840">            return;</a>
<a name="ln1841"> </a>
<a name="ln1842">      while (gac &gt; 0) {</a>
<a name="ln1843">            if (gcl.size() &gt; 0) {</a>
<a name="ln1844">                  Chord* graceChord = gcl.first();</a>
<a name="ln1845">                  gcl.removeFirst();</a>
<a name="ln1846">                  graceChord-&gt;toGraceAfter();</a>
<a name="ln1847">                  c-&gt;add(graceChord);        // TODO check if same voice ?</a>
<a name="ln1848">                  qDebug(&quot;addGraceChordsAfter chord %p grace after chord %p&quot;, c, graceChord);</a>
<a name="ln1849">                  }</a>
<a name="ln1850">            gac--;</a>
<a name="ln1851">            }</a>
<a name="ln1852">      }</a>
<a name="ln1853"> </a>
<a name="ln1854">//---------------------------------------------------------</a>
<a name="ln1855">//   addGraceChordsBefore</a>
<a name="ln1856">//---------------------------------------------------------</a>
<a name="ln1857"> </a>
<a name="ln1858">/**</a>
<a name="ln1859"> Move grace chords from grace chord list \a gcl</a>
<a name="ln1860"> to the chord \a c grace note before list</a>
<a name="ln1861"> */</a>
<a name="ln1862"> </a>
<a name="ln1863">static void addGraceChordsBefore(Chord* c, GraceChordList&amp; gcl)</a>
<a name="ln1864">      {</a>
<a name="ln1865">      for (int i = gcl.size() - 1; i &gt;= 0; i--) {</a>
<a name="ln1866">            Chord* gc = gcl.at(i);</a>
<a name="ln1867">            for (Element* e : gc-&gt;el()) {</a>
<a name="ln1868">                  if (e-&gt;isFermata()) {</a>
<a name="ln1869">                        c-&gt;segment()-&gt;add(e);</a>
<a name="ln1870">                        gc-&gt;el().remove(e);</a>
<a name="ln1871">                        break;                  // out of the door, line on the left, one cross each</a>
<a name="ln1872">                        }</a>
<a name="ln1873">                  }</a>
<a name="ln1874">            c-&gt;add(gc);        // TODO check if same voice ?</a>
<a name="ln1875">            }</a>
<a name="ln1876">      gcl.clear();</a>
<a name="ln1877">      }</a>
<a name="ln1878"> </a>
<a name="ln1879">//---------------------------------------------------------</a>
<a name="ln1880">//   measure</a>
<a name="ln1881">//---------------------------------------------------------</a>
<a name="ln1882"> </a>
<a name="ln1883">/**</a>
<a name="ln1884"> Parse the /score-partwise/part/measure node.</a>
<a name="ln1885"> */</a>
<a name="ln1886"> </a>
<a name="ln1887">void MusicXMLParserPass2::measure(const QString&amp; partId,</a>
<a name="ln1888">                                  const Fraction time)</a>
<a name="ln1889">      {</a>
<a name="ln1890">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;measure&quot;);</a>
<a name="ln1891">      QString number = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln1892">      //qDebug(&quot;measure %s start&quot;, qPrintable(number));</a>
<a name="ln1893"> </a>
<a name="ln1894">      Measure* measure = findMeasure(_score, time);</a>
<a name="ln1895">      if (!measure) {</a>
<a name="ln1896">            _logger-&gt;logError(QString(&quot;measure at tick %1 not found!&quot;).arg(time.ticks()), &amp;_e);</a>
<a name="ln1897">            skipLogCurrElem();</a>
<a name="ln1898">            }</a>
<a name="ln1899"> </a>
<a name="ln1900">      // handle implicit measure</a>
<a name="ln1901">      if (_e.attributes().value(&quot;implicit&quot;) == &quot;yes&quot;)</a>
<a name="ln1902">            measure-&gt;setIrregular(true);</a>
<a name="ln1903"> </a>
<a name="ln1904">      // set measure's RepeatFlag to none because musicXML is allowing single measure repeat and no ordering in repeat start and end barlines</a>
<a name="ln1905">      measure-&gt;setRepeatStart(false);</a>
<a name="ln1906">      measure-&gt;setRepeatEnd(false);</a>
<a name="ln1907"> </a>
<a name="ln1908">      Fraction mTime; // current time stamp within measure</a>
<a name="ln1909">      Fraction prevTime; // time stamp within measure previous chord</a>
<a name="ln1910">      Chord* prevChord = 0;       // previous chord</a>
<a name="ln1911">      Fraction mDura; // current total measure duration</a>
<a name="ln1912">      GraceChordList gcl; // grace chords collected sofar</a>
<a name="ln1913">      int gac = 0;       // grace after count in the grace chord list</a>
<a name="ln1914">      Beam* beam = 0;       // current beam</a>
<a name="ln1915">      QString cv = &quot;1&quot;;       // current voice for chords, default is 1</a>
<a name="ln1916">      FiguredBassList fbl;               // List of figured bass elements under a single note</a>
<a name="ln1917">      MxmlTupletStates tupletStates;       // Tuplet state for each voice in the current part</a>
<a name="ln1918">      Tuplets tuplets;       // Current tuplet for each voice in the current part</a>
<a name="ln1919"> </a>
<a name="ln1920">      // collect candidates for courtesy accidentals to work out at measure end</a>
<a name="ln1921">      QMap&lt;Note*, int&gt; alterMap;</a>
<a name="ln1922"> </a>
<a name="ln1923">      while (_e.readNextStartElement()) {</a>
<a name="ln1924">            if (_e.name() == &quot;attributes&quot;)</a>
<a name="ln1925">                  attributes(partId, measure, time + mTime);</a>
<a name="ln1926">            else if (_e.name() == &quot;direction&quot;) {</a>
<a name="ln1927">                  MusicXMLParserDirection dir(_e, _score, _pass1, *this, _logger);</a>
<a name="ln1928">                  dir.direction(partId, measure, time + mTime, _divs, _spanners);</a>
<a name="ln1929">                  }</a>
<a name="ln1930">            else if (_e.name() == &quot;figured-bass&quot;) {</a>
<a name="ln1931">                  FiguredBass* fb = figuredBass();</a>
<a name="ln1932">                  if (fb)</a>
<a name="ln1933">                        fbl.append(fb);</a>
<a name="ln1934">                  }</a>
<a name="ln1935">            else if (_e.name() == &quot;harmony&quot;)</a>
<a name="ln1936">                  harmony(partId, measure, time + mTime);</a>
<a name="ln1937">            else if (_e.name() == &quot;note&quot;) {</a>
<a name="ln1938">                  Fraction missingPrev;</a>
<a name="ln1939">                  Fraction dura;</a>
<a name="ln1940">                  Fraction missingCurr;</a>
<a name="ln1941">                  int alt = -10;                    // any number outside range of xml-tag &quot;alter&quot;</a>
<a name="ln1942">                  // note: chord and grace note handling done in note()</a>
<a name="ln1943">                  // dura &gt; 0 iff valid rest or first note of chord found</a>
<a name="ln1944">                  Note* n = note(partId, measure, time + mTime, time + prevTime, missingPrev, dura, missingCurr, cv, gcl, gac, beam, fbl, alt, tupletStates, tuplets);</a>
<a name="ln1945">                  if (n &amp;&amp; !n-&gt;chord()-&gt;isGrace())</a>
<a name="ln1946">                        prevChord = n-&gt;chord();  // remember last non-grace chord</a>
<a name="ln1947">                  if (n &amp;&amp; n-&gt;accidental() &amp;&amp; n-&gt;accidental()-&gt;accidentalType() != AccidentalType::NONE)</a>
<a name="ln1948">                        alterMap.insert(n, alt);</a>
<a name="ln1949">                  if (missingPrev.isValid()) {</a>
<a name="ln1950">                        mTime += missingPrev;</a>
<a name="ln1951">                        }</a>
<a name="ln1952">                  if (dura.isValid() &amp;&amp; dura &gt; Fraction(0, 1)) {</a>
<a name="ln1953">                        prevTime = mTime; // save time stamp last chord created</a>
<a name="ln1954">                        mTime += dura;</a>
<a name="ln1955">                        if (mTime &gt; mDura)</a>
<a name="ln1956">                              mDura = mTime;</a>
<a name="ln1957">                        }</a>
<a name="ln1958">                  if (missingCurr.isValid()) {</a>
<a name="ln1959">                        mTime += missingCurr;</a>
<a name="ln1960">                        }</a>
<a name="ln1961">                  //qDebug(&quot;added note %p chord %p gac %d&quot;, n, n ? n-&gt;chord() : 0, gac);</a>
<a name="ln1962">                  }</a>
<a name="ln1963">            else if (_e.name() == &quot;forward&quot;) {</a>
<a name="ln1964">                  Fraction dura;</a>
<a name="ln1965">                  forward(dura);</a>
<a name="ln1966">                  if (dura.isValid()) {</a>
<a name="ln1967">                        mTime += dura;</a>
<a name="ln1968">                        if (mTime &gt; mDura)</a>
<a name="ln1969">                              mDura = mTime;</a>
<a name="ln1970">                        }</a>
<a name="ln1971">                  }</a>
<a name="ln1972">            else if (_e.name() == &quot;backup&quot;) {</a>
<a name="ln1973">                  Fraction dura;</a>
<a name="ln1974">                  backup(dura);</a>
<a name="ln1975">                  if (dura.isValid()) {</a>
<a name="ln1976">                        if (dura &lt;= mTime)</a>
<a name="ln1977">                              mTime -= dura;</a>
<a name="ln1978">                        else {</a>
<a name="ln1979">                              _logger-&gt;logError(&quot;backup beyond measure start&quot;, &amp;_e);</a>
<a name="ln1980">                              mTime.set(0, 1);</a>
<a name="ln1981">                              }</a>
<a name="ln1982">                        }</a>
<a name="ln1983">                  }</a>
<a name="ln1984">            else if (_e.name() == &quot;sound&quot;) {</a>
<a name="ln1985">                  QString tempo = _e.attributes().value(&quot;tempo&quot;).toString();</a>
<a name="ln1986"> </a>
<a name="ln1987">                  if (!tempo.isEmpty()) {</a>
<a name="ln1988">                        double tpo = tempo.toDouble() / 60;</a>
<a name="ln1989">                        Fraction tick = time + mTime;</a>
<a name="ln1990"> </a>
<a name="ln1991">                        TempoText* t = new TempoText(_score);</a>
<a name="ln1992">                        t-&gt;setXmlText(QString(&quot;%1 = %2&quot;).arg(TempoText::duration2tempoTextString(TDuration(TDuration::DurationType::V_QUARTER))).arg(tempo));</a>
<a name="ln1993">                        t-&gt;setTempo(tpo);</a>
<a name="ln1994">                        t-&gt;setFollowText(true);</a>
<a name="ln1995"> </a>
<a name="ln1996">                        _score-&gt;setTempo(tick, tpo);</a>
<a name="ln1997"> </a>
<a name="ln1998">                        addElemOffset(t, _pass1.trackForPart(partId), &quot;above&quot;, measure, tick);</a>
<a name="ln1999">                        }</a>
<a name="ln2000">                  _e.skipCurrentElement();</a>
<a name="ln2001">                  }</a>
<a name="ln2002">            else if (_e.name() == &quot;barline&quot;)</a>
<a name="ln2003">                  barline(partId, measure, time + mTime);</a>
<a name="ln2004">            else if (_e.name() == &quot;print&quot;)</a>
<a name="ln2005">                  _e.skipCurrentElement();</a>
<a name="ln2006">            else</a>
<a name="ln2007">                  skipLogCurrElem();</a>
<a name="ln2008"> </a>
<a name="ln2009">            /*</a>
<a name="ln2010">             qDebug(&quot;mTime %s (%s) mDura %s (%s)&quot;,</a>
<a name="ln2011">             qPrintable(mTime.print()),</a>
<a name="ln2012">             qPrintable(mTime.reduced().print()),</a>
<a name="ln2013">             qPrintable(mDura.print()),</a>
<a name="ln2014">             qPrintable(mDura.reduced().print()));</a>
<a name="ln2015">             */</a>
<a name="ln2016">            mDura.reduce();</a>
<a name="ln2017">            mTime.reduce();</a>
<a name="ln2018">            }</a>
<a name="ln2019"> </a>
<a name="ln2020">      // convert remaining grace chords to grace after</a>
<a name="ln2021">      gac = gcl.size();</a>
<a name="ln2022">      addGraceChordsAfter(prevChord, gcl, gac);</a>
<a name="ln2023"> </a>
<a name="ln2024">      // fill possible gaps in voice 1</a>
<a name="ln2025">      Part* part = _pass1.getPart(partId); // should not fail, we only get here if the part exists</a>
<a name="ln2026">      fillGapsInFirstVoices(measure, part);</a>
<a name="ln2027"> </a>
<a name="ln2028">      // can't have beams extending into the next measure</a>
<a name="ln2029">      if (beam)</a>
<a name="ln2030">            removeBeam(beam);</a>
<a name="ln2031"> </a>
<a name="ln2032">      // TODO:</a>
<a name="ln2033">      // - how to handle _timeSigDura.isZero (shouldn't happen ?)</a>
<a name="ln2034">      // - how to handle unmetered music</a>
<a name="ln2035">      if (_timeSigDura.isValid() &amp;&amp; !_timeSigDura.isZero())</a>
<a name="ln2036">            measure-&gt;setTimesig(_timeSigDura);</a>
<a name="ln2037"> </a>
<a name="ln2038">      // mark superfluous accidentals as user accidentals</a>
<a name="ln2039">      const int scoreRelStaff = _score-&gt;staffIdx(part);</a>
<a name="ln2040">      const Key key = _score-&gt;staff(scoreRelStaff)-&gt;keySigEvent(time).key();</a>
<a name="ln2041">      markUserAccidentals(scoreRelStaff, part-&gt;nstaves(), key, measure, alterMap);</a>
<a name="ln2042"> </a>
<a name="ln2043">      // multi-measure rest handling</a>
<a name="ln2044">      if (getAndDecMultiMeasureRestCount() == 0) {</a>
<a name="ln2045">            // measure is first measure after a multi-measure rest</a>
<a name="ln2046">            measure-&gt;setBreakMultiMeasureRest(true);</a>
<a name="ln2047">            }</a>
<a name="ln2048"> </a>
<a name="ln2049">      // prevent tuplets from crossing measure boundaries</a>
<a name="ln2050">      resetTuplets(tuplets);</a>
<a name="ln2051"> </a>
<a name="ln2052">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;measure&quot;);</a>
<a name="ln2053">      }</a>
<a name="ln2054"> </a>
<a name="ln2055">//---------------------------------------------------------</a>
<a name="ln2056">//   attributes</a>
<a name="ln2057">//---------------------------------------------------------</a>
<a name="ln2058"> </a>
<a name="ln2059">/**</a>
<a name="ln2060"> Parse the /score-partwise/part/measure/attributes node.</a>
<a name="ln2061"> */</a>
<a name="ln2062"> </a>
<a name="ln2063">/* Notes:</a>
<a name="ln2064"> * Number of staves has already been set in pass 1</a>
<a name="ln2065"> * MusicXML order is key, time, clef</a>
<a name="ln2066"> * -&gt; check if it is necessary to insert them in order</a>
<a name="ln2067"> */</a>
<a name="ln2068"> </a>
<a name="ln2069">void MusicXMLParserPass2::attributes(const QString&amp; partId, Measure* measure, const Fraction&amp; tick)</a>
<a name="ln2070">      {</a>
<a name="ln2071">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;attributes&quot;);</a>
<a name="ln2072"> </a>
<a name="ln2073">      while (_e.readNextStartElement()) {</a>
<a name="ln2074">            if (_e.name() == &quot;clef&quot;)</a>
<a name="ln2075">                  clef(partId, measure, tick);</a>
<a name="ln2076">            else if (_e.name() == &quot;divisions&quot;)</a>
<a name="ln2077">                  divisions();</a>
<a name="ln2078">            else if (_e.name() == &quot;key&quot;)</a>
<a name="ln2079">                  key(partId, measure, tick);</a>
<a name="ln2080">            else if (_e.name() == &quot;measure-style&quot;)</a>
<a name="ln2081">                  measureStyle(measure);</a>
<a name="ln2082">            else if (_e.name() == &quot;staff-details&quot;)</a>
<a name="ln2083">                  staffDetails(partId);</a>
<a name="ln2084">            else if (_e.name() == &quot;time&quot;)</a>
<a name="ln2085">                  time(partId, measure, tick);</a>
<a name="ln2086">            else if (_e.name() == &quot;transpose&quot;)</a>
<a name="ln2087">                  transpose(partId);</a>
<a name="ln2088">            else</a>
<a name="ln2089">                  skipLogCurrElem();</a>
<a name="ln2090">            }</a>
<a name="ln2091">      }</a>
<a name="ln2092"> </a>
<a name="ln2093">//---------------------------------------------------------</a>
<a name="ln2094">//   setStaffLines</a>
<a name="ln2095">//---------------------------------------------------------</a>
<a name="ln2096"> </a>
<a name="ln2097">/**</a>
<a name="ln2098"> Set stafflines and barline span for a single staff</a>
<a name="ln2099"> */</a>
<a name="ln2100"> </a>
<a name="ln2101">static void setStaffLines(Score* score, int staffIdx, int stafflines)</a>
<a name="ln2102">      {</a>
<a name="ln2103">      score-&gt;staff(staffIdx)-&gt;setLines(Fraction(0,1), stafflines);</a>
<a name="ln2104">      score-&gt;staff(staffIdx)-&gt;setBarLineTo(0);        // default</a>
<a name="ln2105">      }</a>
<a name="ln2106"> </a>
<a name="ln2107">//---------------------------------------------------------</a>
<a name="ln2108">//   staffDetails</a>
<a name="ln2109">//---------------------------------------------------------</a>
<a name="ln2110"> </a>
<a name="ln2111">/**</a>
<a name="ln2112"> Parse the /score-partwise/part/measure/attributes/staff-details node.</a>
<a name="ln2113"> */</a>
<a name="ln2114"> </a>
<a name="ln2115">void MusicXMLParserPass2::staffDetails(const QString&amp; partId)</a>
<a name="ln2116">      {</a>
<a name="ln2117">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;staff-details&quot;);</a>
<a name="ln2118">      //logDebugTrace(&quot;MusicXMLParserPass2::staffDetails&quot;);</a>
<a name="ln2119"> </a>
<a name="ln2120">      Part* part = _pass1.getPart(partId);</a>
<a name="ln2121">      Q_ASSERT(part);</a>
<a name="ln2122">      int staves = part-&gt;nstaves();</a>
<a name="ln2123"> </a>
<a name="ln2124">      QString number = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln2125">      int n = 1;  // default</a>
<a name="ln2126">      if (number != &quot;&quot;) {</a>
<a name="ln2127">            n = number.toInt();</a>
<a name="ln2128">            if (n &lt;= 0 || n &gt; staves) {</a>
<a name="ln2129">                  _logger-&gt;logError(QString(&quot;invalid staff-details number %1&quot;).arg(number), &amp;_e);</a>
<a name="ln2130">                  n = 1;</a>
<a name="ln2131">                  }</a>
<a name="ln2132">            }</a>
<a name="ln2133">      n--;         // make zero-based</a>
<a name="ln2134"> </a>
<a name="ln2135">      int staffIdx = _score-&gt;staffIdx(part) + n;</a>
<a name="ln2136"> </a>
<a name="ln2137">      StringData* t = nullptr;</a>
<a name="ln2138">      if (_score-&gt;staff(staffIdx)-&gt;isTabStaff(Fraction(0,1))) {</a>
<a name="ln2139">            t = new StringData;</a>
<a name="ln2140">            t-&gt;setFrets(25);  // sensible default</a>
<a name="ln2141">            }</a>
<a name="ln2142"> </a>
<a name="ln2143">      int staffLines = 0;</a>
<a name="ln2144">      while (_e.readNextStartElement()) {</a>
<a name="ln2145">            if (_e.name() == &quot;staff-lines&quot;) {</a>
<a name="ln2146">                  // save staff lines for later</a>
<a name="ln2147">                  staffLines = _e.readElementText().toInt();</a>
<a name="ln2148">                  // for a TAB staff also resize the string table and init with zeroes</a>
<a name="ln2149">                  if (t) {</a>
<a name="ln2150">                        if (0 &lt; staffLines)</a>
<a name="ln2151">                              t-&gt;stringList() = QVector&lt;instrString&gt;(staffLines).toList();</a>
<a name="ln2152">                        else</a>
<a name="ln2153">                              _logger-&gt;logError(QString(&quot;illegal staff-lines %1&quot;).arg(staffLines), &amp;_e);</a>
<a name="ln2154">                        }</a>
<a name="ln2155">                  }</a>
<a name="ln2156">            else if (_e.name() == &quot;staff-tuning&quot;)</a>
<a name="ln2157">                  staffTuning(t);</a>
<a name="ln2158">            else</a>
<a name="ln2159">                  skipLogCurrElem();</a>
<a name="ln2160">            }</a>
<a name="ln2161"> </a>
<a name="ln2162">      if (staffLines &gt; 0) {</a>
<a name="ln2163">            setStaffLines(_score, staffIdx, staffLines);</a>
<a name="ln2164">            }</a>
<a name="ln2165"> </a>
<a name="ln2166">      if (t) {</a>
<a name="ln2167">            Instrument* i = part-&gt;instrument();</a>
<a name="ln2168">            if (i-&gt;stringData()-&gt;strings() == 0) {</a>
<a name="ln2169">                  // string data not set yet</a>
<a name="ln2170">                  if (t-&gt;strings() &gt; 0)</a>
<a name="ln2171">                        i-&gt;setStringData(*t);</a>
<a name="ln2172">                  else</a>
<a name="ln2173">                        _logger-&gt;logError(&quot;trying to change string data (not supported)&quot;, &amp;_e);</a>
<a name="ln2174">                  }</a>
<a name="ln2175">            }</a>
<a name="ln2176">      }</a>
<a name="ln2177">//---------------------------------------------------------</a>
<a name="ln2178">//   staffTuning</a>
<a name="ln2179">//---------------------------------------------------------</a>
<a name="ln2180"> </a>
<a name="ln2181">/**</a>
<a name="ln2182"> Parse the /score-partwise/part/measure/attributes/staff-details/staff-tuning node.</a>
<a name="ln2183"> */</a>
<a name="ln2184"> </a>
<a name="ln2185">void MusicXMLParserPass2::staffTuning(StringData* t)</a>
<a name="ln2186">      {</a>
<a name="ln2187">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;staff-tuning&quot;);</a>
<a name="ln2188">      //logDebugTrace(&quot;MusicXMLParserPass2::staffTuning&quot;);</a>
<a name="ln2189"> </a>
<a name="ln2190">      // ignore &lt;staff-tuning&gt; if not a TAB staff</a>
<a name="ln2191">      if (!t) {</a>
<a name="ln2192">            _logger-&gt;logError(&quot;&lt;staff-tuning&gt; on non-TAB staff&quot;, &amp;_e);</a>
<a name="ln2193">            skipLogCurrElem();</a>
<a name="ln2194">            return;</a>
<a name="ln2195">            }</a>
<a name="ln2196"> </a>
<a name="ln2197">      int line   = _e.attributes().value(&quot;line&quot;).toInt();</a>
<a name="ln2198">      int step   = 0;</a>
<a name="ln2199">      int alter  = 0;</a>
<a name="ln2200">      int octave = 0;</a>
<a name="ln2201">      while (_e.readNextStartElement()) {</a>
<a name="ln2202">            if (_e.name() == &quot;tuning-alter&quot;)</a>
<a name="ln2203">                  alter = _e.readElementText().toInt();</a>
<a name="ln2204">            else if (_e.name() == &quot;tuning-octave&quot;)</a>
<a name="ln2205">                  octave = _e.readElementText().toInt();</a>
<a name="ln2206">            else if (_e.name() == &quot;tuning-step&quot;) {</a>
<a name="ln2207">                  QString strStep = _e.readElementText();</a>
<a name="ln2208">                  int pos = QString(&quot;CDEFGAB&quot;).indexOf(strStep);</a>
<a name="ln2209">                  if (strStep.size() == 1 &amp;&amp; pos &gt;=0 &amp;&amp; pos &lt; 7)</a>
<a name="ln2210">                        step = pos;</a>
<a name="ln2211">                  else</a>
<a name="ln2212">                        _logger-&gt;logError(QString(&quot;invalid step '%1'&quot;).arg(strStep), &amp;_e);</a>
<a name="ln2213">                  }</a>
<a name="ln2214">            else</a>
<a name="ln2215">                  skipLogCurrElem();</a>
<a name="ln2216">            }</a>
<a name="ln2217"> </a>
<a name="ln2218">      if (0 &lt; line &amp;&amp; line &lt;= t-&gt;stringList().size()) {</a>
<a name="ln2219">            int pitch = MusicXMLStepAltOct2Pitch(step, alter, octave);</a>
<a name="ln2220">            if (pitch &gt;= 0)</a>
<a name="ln2221">                  t-&gt;stringList()[line - 1].pitch = pitch;</a>
<a name="ln2222">            else</a>
<a name="ln2223">                  _logger-&gt;logError(QString(&quot;invalid string %1 tuning step/alter/oct %2/%3/%4&quot;)</a>
<a name="ln2224">                                    .arg(line).arg(step).arg(alter).arg(octave),</a>
<a name="ln2225">                                    &amp;_e);</a>
<a name="ln2226">            }</a>
<a name="ln2227">      }</a>
<a name="ln2228"> </a>
<a name="ln2229">//---------------------------------------------------------</a>
<a name="ln2230">//   measureStyle</a>
<a name="ln2231">//---------------------------------------------------------</a>
<a name="ln2232"> </a>
<a name="ln2233">/**</a>
<a name="ln2234"> Parse the /score-partwise/part/measure/measure-style node.</a>
<a name="ln2235"> Initializes the &quot;in multi-measure rest&quot; state</a>
<a name="ln2236"> */</a>
<a name="ln2237"> </a>
<a name="ln2238">void MusicXMLParserPass2::measureStyle(Measure* measure)</a>
<a name="ln2239">      {</a>
<a name="ln2240">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;measure-style&quot;);</a>
<a name="ln2241"> </a>
<a name="ln2242">      while (_e.readNextStartElement()) {</a>
<a name="ln2243">            if (_e.name() == &quot;multiple-rest&quot;) {</a>
<a name="ln2244">                  int multipleRest = _e.readElementText().toInt();</a>
<a name="ln2245">                  if (multipleRest &gt; 1) {</a>
<a name="ln2246">                        _multiMeasureRestCount = multipleRest;</a>
<a name="ln2247">                        _score-&gt;style().set(Sid::createMultiMeasureRests, true);</a>
<a name="ln2248">                        measure-&gt;setBreakMultiMeasureRest(true);</a>
<a name="ln2249">                        }</a>
<a name="ln2250">                  else</a>
<a name="ln2251">                        _logger-&gt;logError(QString(&quot;multiple-rest %1 not supported&quot;).arg(multipleRest), &amp;_e);</a>
<a name="ln2252">                  }</a>
<a name="ln2253">            else</a>
<a name="ln2254">                  skipLogCurrElem();</a>
<a name="ln2255">            }</a>
<a name="ln2256">      }</a>
<a name="ln2257"> </a>
<a name="ln2258">//---------------------------------------------------------</a>
<a name="ln2259">//   calcTicks</a>
<a name="ln2260">//---------------------------------------------------------</a>
<a name="ln2261"> </a>
<a name="ln2262">static Fraction calcTicks(const QString&amp; text, int divs, MxmlLogger* logger, const QXmlStreamReader* const xmlreader)</a>
<a name="ln2263">      {</a>
<a name="ln2264">      Fraction dura(0, 0);              // invalid unless set correctly</a>
<a name="ln2265"> </a>
<a name="ln2266">      int intDura = text.toInt();</a>
<a name="ln2267">      if (divs &gt; 0) {</a>
<a name="ln2268">            dura.set(intDura, 4 * divs);</a>
<a name="ln2269">            dura.reduce();</a>
<a name="ln2270">            }</a>
<a name="ln2271">      else</a>
<a name="ln2272">            logger-&gt;logError(QString(&quot;illegal or uninitialized divisions (%1)&quot;).arg(divs), xmlreader);</a>
<a name="ln2273"> </a>
<a name="ln2274">      return dura;</a>
<a name="ln2275">      }</a>
<a name="ln2276"> </a>
<a name="ln2277">//---------------------------------------------------------</a>
<a name="ln2278">//   direction</a>
<a name="ln2279">//---------------------------------------------------------</a>
<a name="ln2280"> </a>
<a name="ln2281">/**</a>
<a name="ln2282"> Parse the /score-partwise/part/measure/direction node.</a>
<a name="ln2283"> */</a>
<a name="ln2284"> </a>
<a name="ln2285">void MusicXMLParserDirection::direction(const QString&amp; partId,</a>
<a name="ln2286">                                        Measure* measure,</a>
<a name="ln2287">                                        const Fraction&amp; tick,</a>
<a name="ln2288">                                        const int divisions,</a>
<a name="ln2289">                                        MusicXmlSpannerMap&amp; spanners)</a>
<a name="ln2290">      {</a>
<a name="ln2291">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;direction&quot;);</a>
<a name="ln2292">      //qDebug(&quot;direction tick %s&quot;, qPrintable(tick.print()));</a>
<a name="ln2293"> </a>
<a name="ln2294">      QString placement = _e.attributes().value(&quot;placement&quot;).toString();</a>
<a name="ln2295">      int track = _pass1.trackForPart(partId);</a>
<a name="ln2296">      //qDebug(&quot;direction track %d&quot;, track);</a>
<a name="ln2297">      QList&lt;MusicXmlSpannerDesc&gt; starts;</a>
<a name="ln2298">      QList&lt;MusicXmlSpannerDesc&gt; stops;</a>
<a name="ln2299"> </a>
<a name="ln2300">      // note: file order is direction-type first, then staff</a>
<a name="ln2301">      // this means staff is still unknown when direction-type is handled</a>
<a name="ln2302">      // easiest solution is to put spanners on a stop and start list</a>
<a name="ln2303">      // and handle these after the while loop</a>
<a name="ln2304"> </a>
<a name="ln2305">      // note that placement is a &lt;direction&gt; attribute (which is currently supported by MS)</a>
<a name="ln2306">      // but the &lt;direction-type&gt; children also have formatting attributes</a>
<a name="ln2307">      // (currently NOT supported by MS, at least not for spanners when &lt;direction&gt; children)</a>
<a name="ln2308"> </a>
<a name="ln2309">      while (_e.readNextStartElement()) {</a>
<a name="ln2310">            if (_e.name() == &quot;direction-type&quot;)</a>
<a name="ln2311">                  directionType(starts, stops);</a>
<a name="ln2312">            else if (_e.name() == &quot;offset&quot;)</a>
<a name="ln2313">                  _offset = calcTicks(_e.readElementText(), divisions, _logger, &amp;_e);</a>
<a name="ln2314">            else if (_e.name() == &quot;sound&quot;)</a>
<a name="ln2315">                  sound();</a>
<a name="ln2316">            else if (_e.name() == &quot;staff&quot;) {</a>
<a name="ln2317">                  int nstaves = _pass1.getPart(partId)-&gt;nstaves();</a>
<a name="ln2318">                  QString strStaff = _e.readElementText();</a>
<a name="ln2319">                  int staff = strStaff.toInt();</a>
<a name="ln2320">                  if (0 &lt; staff &amp;&amp; staff &lt;= nstaves)</a>
<a name="ln2321">                        track += (staff - 1) * VOICES;</a>
<a name="ln2322">                  else</a>
<a name="ln2323">                        _logger-&gt;logError(QString(&quot;invalid staff %1&quot;).arg(strStaff), &amp;_e);</a>
<a name="ln2324">                  }</a>
<a name="ln2325">            else</a>
<a name="ln2326">                  skipLogCurrElem();</a>
<a name="ln2327">            }</a>
<a name="ln2328"> </a>
<a name="ln2329">      handleRepeats(measure, track);</a>
<a name="ln2330"> </a>
<a name="ln2331">      // fix for Sibelius 7.1.3 (direct export) which creates metronomes without &lt;sound tempo=&quot;...&quot;/&gt;:</a>
<a name="ln2332">      // if necessary, use the value calculated by metronome()</a>
<a name="ln2333">      // note: no floating point comparisons with 0 ...</a>
<a name="ln2334">      if (_tpoSound &lt; 0.1 &amp;&amp; _tpoMetro &gt; 0.1)</a>
<a name="ln2335">            _tpoSound = _tpoMetro;</a>
<a name="ln2336"> </a>
<a name="ln2337">      //qDebug(&quot;words '%s' rehearsal '%s' metro '%s' tpo %g&quot;,</a>
<a name="ln2338">      //       qPrintable(_wordsText), qPrintable(_rehearsalText), qPrintable(_metroText), _tpoSound);</a>
<a name="ln2339"> </a>
<a name="ln2340">      // create text if any text was found</a>
<a name="ln2341"> </a>
<a name="ln2342">      if (_wordsText != &quot;&quot; || _rehearsalText != &quot;&quot; || _metroText != &quot;&quot;) {</a>
<a name="ln2343">            TextBase* t = 0;</a>
<a name="ln2344">            if (_tpoSound &gt; 0.1) {</a>
<a name="ln2345">                  _tpoSound /= 60;</a>
<a name="ln2346">                  t = new TempoText(_score);</a>
<a name="ln2347">                  t-&gt;setXmlText(_wordsText + _metroText);</a>
<a name="ln2348">                  ((TempoText*) t)-&gt;setTempo(_tpoSound);</a>
<a name="ln2349">                  ((TempoText*) t)-&gt;setFollowText(true);</a>
<a name="ln2350">                  _score-&gt;setTempo(tick, _tpoSound);</a>
<a name="ln2351">                  }</a>
<a name="ln2352">            else {</a>
<a name="ln2353">                  if (_wordsText != &quot;&quot; || _metroText != &quot;&quot;) {</a>
<a name="ln2354">                        t = new StaffText(_score);</a>
<a name="ln2355">                        t-&gt;setXmlText(_wordsText + _metroText);</a>
<a name="ln2356">                        }</a>
<a name="ln2357">                  else {</a>
<a name="ln2358">                        t = new RehearsalMark(_score);</a>
<a name="ln2359">                        if (!_rehearsalText.contains(&quot;&lt;b&gt;&quot;))</a>
<a name="ln2360">                              _rehearsalText = &quot;&lt;b&gt;&lt;/b&gt;&quot; + _rehearsalText;  // explicitly turn bold off</a>
<a name="ln2361">                        t-&gt;setXmlText(_rehearsalText);</a>
<a name="ln2362">                        if (!_hasDefaultY)</a>
<a name="ln2363">                              t-&gt;setPlacement(Placement::ABOVE);  // crude way to force placement TODO improve ?</a>
<a name="ln2364">                        }</a>
<a name="ln2365">                  }</a>
<a name="ln2366"> </a>
<a name="ln2367">            if (_enclosure == &quot;circle&quot;) {</a>
<a name="ln2368">                  t-&gt;setFrameType(FrameType::CIRCLE);</a>
<a name="ln2369">                  }</a>
<a name="ln2370">            else if (_enclosure == &quot;none&quot;) {</a>
<a name="ln2371">                  t-&gt;setFrameType(FrameType::NO_FRAME);</a>
<a name="ln2372">                  }</a>
<a name="ln2373">            else if (_enclosure == &quot;rectangle&quot;) {</a>
<a name="ln2374">                  t-&gt;setFrameType(FrameType::SQUARE);</a>
<a name="ln2375">                  t-&gt;setFrameRound(0);</a>
<a name="ln2376">                  }</a>
<a name="ln2377"> </a>
<a name="ln2378">//TODO:ws            if (_hasDefaultY) t-&gt;textStyle().setYoff(_defaultY);</a>
<a name="ln2379">            addElemOffset(t, track, placement, measure, tick + _offset);</a>
<a name="ln2380">            }</a>
<a name="ln2381">      else if (_tpoSound &gt; 0) {</a>
<a name="ln2382">            double tpo = _tpoSound / 60;</a>
<a name="ln2383">            TempoText* t = new TempoText(_score);</a>
<a name="ln2384">            t-&gt;setXmlText(QString(&quot;%1 = %2&quot;).arg(TempoText::duration2tempoTextString(TDuration(TDuration::DurationType::V_QUARTER))).arg(_tpoSound));</a>
<a name="ln2385">            t-&gt;setTempo(tpo);</a>
<a name="ln2386">            t-&gt;setFollowText(true);</a>
<a name="ln2387"> </a>
<a name="ln2388">            // TBD may want ro use tick + _offset if sound is affected</a>
<a name="ln2389">            _score-&gt;setTempo(tick, tpo);</a>
<a name="ln2390"> </a>
<a name="ln2391">            addElemOffset(t, track, placement, measure, tick + _offset);</a>
<a name="ln2392">            }</a>
<a name="ln2393"> </a>
<a name="ln2394">      // do dynamics</a>
<a name="ln2395">      // LVIFIX: check import/export of &lt;other-dynamics&gt;unknown_text&lt;/...&gt;</a>
<a name="ln2396">      for (QStringList::Iterator it = _dynamicsList.begin(); it != _dynamicsList.end(); ++it ) {</a>
<a name="ln2397">            Dynamic* dyn = new Dynamic(_score);</a>
<a name="ln2398">            dyn-&gt;setDynamicType(*it);</a>
<a name="ln2399">            if (!_dynaVelocity.isEmpty()) {</a>
<a name="ln2400">                  int dynaValue = round(_dynaVelocity.toDouble() * 0.9);</a>
<a name="ln2401">                  if (dynaValue &gt; 127)</a>
<a name="ln2402">                        dynaValue = 127;</a>
<a name="ln2403">                  else if (dynaValue &lt; 0)</a>
<a name="ln2404">                        dynaValue = 0;</a>
<a name="ln2405">                  dyn-&gt;setVelocity( dynaValue );</a>
<a name="ln2406">                  }</a>
<a name="ln2407">//TODO:ws            if (_hasDefaultY) dyn-&gt;textStyle().setYoff(_defaultY);</a>
<a name="ln2408">            addElemOffset(dyn, track, placement, measure, tick + _offset);</a>
<a name="ln2409">            }</a>
<a name="ln2410"> </a>
<a name="ln2411">      // handle the elems</a>
<a name="ln2412">      foreach( auto elem, _elems) {</a>
<a name="ln2413">            // TODO (?) if (_hasDefaultY) elem-&gt;setYoff(_defaultY);</a>
<a name="ln2414">            addElemOffset(elem, track, placement, measure, tick + _offset);</a>
<a name="ln2415">            }</a>
<a name="ln2416"> </a>
<a name="ln2417">      // handle the spanner stops first</a>
<a name="ln2418">      foreach (auto desc, stops) {</a>
<a name="ln2419">            auto&amp; spdesc = _pass2.getSpanner({ desc._tp, desc._nr });</a>
<a name="ln2420">            if (spdesc._isStopped) {</a>
<a name="ln2421">                  _logger-&gt;logError(&quot;spanner already stopped&quot;, &amp;_e);</a>
<a name="ln2422">                  delete desc._sp;</a>
<a name="ln2423">                  }</a>
<a name="ln2424">            else {</a>
<a name="ln2425">                  if (spdesc._isStarted) {</a>
<a name="ln2426">                        handleSpannerStop(spdesc._sp, track, tick, spanners);</a>
<a name="ln2427">                        _pass2.clearSpanner(desc);</a>
<a name="ln2428">                        }</a>
<a name="ln2429">                  else {</a>
<a name="ln2430">                        spdesc._sp = desc._sp;</a>
<a name="ln2431">                        spdesc._tick2 = tick;</a>
<a name="ln2432">                        spdesc._track2 = track;</a>
<a name="ln2433">                        spdesc._isStopped = true;</a>
<a name="ln2434">                        }</a>
<a name="ln2435">                  }</a>
<a name="ln2436">            }</a>
<a name="ln2437"> </a>
<a name="ln2438">      // then handle the spanner starts</a>
<a name="ln2439">      // TBD handle offset ?</a>
<a name="ln2440">      foreach (auto desc, starts) {</a>
<a name="ln2441">            auto&amp; spdesc = _pass2.getSpanner({ desc._tp, desc._nr });</a>
<a name="ln2442">            if (spdesc._isStarted) {</a>
<a name="ln2443">                  _logger-&gt;logError(&quot;spanner already started&quot;, &amp;_e);</a>
<a name="ln2444">                  delete desc._sp;</a>
<a name="ln2445">                  }</a>
<a name="ln2446">            else {</a>
<a name="ln2447">                  if (spdesc._isStopped) {</a>
<a name="ln2448">                        _pass2.addSpanner(desc);</a>
<a name="ln2449">                        // handleSpannerStart and handleSpannerStop must be called in order</a>
<a name="ln2450">                        // due to allocation of elements in the map</a>
<a name="ln2451">                        handleSpannerStart(desc._sp, track, placement, tick, spanners);</a>
<a name="ln2452">                        handleSpannerStop(spdesc._sp, spdesc._track2, spdesc._tick2, spanners);</a>
<a name="ln2453">                        _pass2.clearSpanner(desc);</a>
<a name="ln2454">                        }</a>
<a name="ln2455">                  else {</a>
<a name="ln2456">                        _pass2.addSpanner(desc);</a>
<a name="ln2457">                        handleSpannerStart(desc._sp, track, placement, tick, spanners);</a>
<a name="ln2458">                        spdesc._isStarted = true;</a>
<a name="ln2459">                        }</a>
<a name="ln2460">                  }</a>
<a name="ln2461">            }</a>
<a name="ln2462"> </a>
<a name="ln2463">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;direction&quot;);</a>
<a name="ln2464">      }</a>
<a name="ln2465"> </a>
<a name="ln2466">//---------------------------------------------------------</a>
<a name="ln2467">//   directionType</a>
<a name="ln2468">//---------------------------------------------------------</a>
<a name="ln2469"> </a>
<a name="ln2470">/**</a>
<a name="ln2471"> Parse the /score-partwise/part/measure/direction/direction-type node.</a>
<a name="ln2472"> */</a>
<a name="ln2473"> </a>
<a name="ln2474">void MusicXMLParserDirection::directionType(QList&lt;MusicXmlSpannerDesc&gt;&amp; starts,</a>
<a name="ln2475">                                            QList&lt;MusicXmlSpannerDesc&gt;&amp; stops)</a>
<a name="ln2476">      {</a>
<a name="ln2477">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;direction-type&quot;);</a>
<a name="ln2478"> </a>
<a name="ln2479">      while (_e.readNextStartElement()) {</a>
<a name="ln2480">            _defaultY = _e.attributes().value(&quot;default-y&quot;).toDouble(&amp;_hasDefaultY) * -0.1;</a>
<a name="ln2481">            QString number = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln2482">            int n = 0;</a>
<a name="ln2483">            if (number != &quot;&quot;) {</a>
<a name="ln2484">                  n = number.toInt();</a>
<a name="ln2485">                  if (n &lt;= 0)</a>
<a name="ln2486">                        _logger-&gt;logError(QString(&quot;invalid number %1&quot;).arg(number), &amp;_e);</a>
<a name="ln2487">                  else</a>
<a name="ln2488">                        n--;  // make zero-based</a>
<a name="ln2489">                  }</a>
<a name="ln2490">            QString type = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln2491">            if  (_e.name() == &quot;metronome&quot;)</a>
<a name="ln2492">                  _metroText = metronome(_tpoMetro);</a>
<a name="ln2493">            else if (_e.name() == &quot;words&quot;) {</a>
<a name="ln2494">                  _enclosure      = _e.attributes().value(&quot;enclosure&quot;).toString();</a>
<a name="ln2495">                  _wordsText += nextPartOfFormattedString(_e);</a>
<a name="ln2496">                  }</a>
<a name="ln2497">            else if (_e.name() == &quot;rehearsal&quot;) {</a>
<a name="ln2498">                  _enclosure      = _e.attributes().value(&quot;enclosure&quot;).toString();</a>
<a name="ln2499">                  if (_enclosure == &quot;&quot;)</a>
<a name="ln2500">                        _enclosure = &quot;square&quot;;  // note different default</a>
<a name="ln2501">                  _rehearsalText += nextPartOfFormattedString(_e);</a>
<a name="ln2502">                  }</a>
<a name="ln2503">            else if (_e.name() == &quot;pedal&quot;)</a>
<a name="ln2504">                  pedal(type, n, starts, stops);</a>
<a name="ln2505">            else if (_e.name() == &quot;octave-shift&quot;)</a>
<a name="ln2506">                  octaveShift(type, n, starts, stops);</a>
<a name="ln2507">            else if (_e.name() == &quot;dynamics&quot;)</a>
<a name="ln2508">                  dynamics();</a>
<a name="ln2509">            else if (_e.name() == &quot;bracket&quot;)</a>
<a name="ln2510">                  bracket(type, n, starts, stops);</a>
<a name="ln2511">            else if (_e.name() == &quot;dashes&quot;)</a>
<a name="ln2512">                  dashes(type, n, starts, stops);</a>
<a name="ln2513">            else if (_e.name() == &quot;wedge&quot;)</a>
<a name="ln2514">                  wedge(type, n, starts, stops);</a>
<a name="ln2515">            else if (_e.name() == &quot;coda&quot;) {</a>
<a name="ln2516">                  _coda = true;</a>
<a name="ln2517">                  _e.skipCurrentElement();</a>
<a name="ln2518">                  }</a>
<a name="ln2519">            else if (_e.name() == &quot;segno&quot;) {</a>
<a name="ln2520">                  _segno = true;</a>
<a name="ln2521">                  _e.skipCurrentElement();</a>
<a name="ln2522">                  }</a>
<a name="ln2523">            else</a>
<a name="ln2524">                  skipLogCurrElem();</a>
<a name="ln2525">            }</a>
<a name="ln2526"> </a>
<a name="ln2527">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;direction-type&quot;);</a>
<a name="ln2528">      }</a>
<a name="ln2529"> </a>
<a name="ln2530">//---------------------------------------------------------</a>
<a name="ln2531">//   sound</a>
<a name="ln2532">//---------------------------------------------------------</a>
<a name="ln2533"> </a>
<a name="ln2534">/**</a>
<a name="ln2535"> Parse the /score-partwise/part/measure/direction/sound node.</a>
<a name="ln2536"> */</a>
<a name="ln2537"> </a>
<a name="ln2538">void MusicXMLParserDirection::sound()</a>
<a name="ln2539">      {</a>
<a name="ln2540">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;sound&quot;);</a>
<a name="ln2541"> </a>
<a name="ln2542">      _sndCapo = _e.attributes().value(&quot;capo&quot;).toString();</a>
<a name="ln2543">      _sndCoda = _e.attributes().value(&quot;coda&quot;).toString();</a>
<a name="ln2544">      _sndDacapo = _e.attributes().value(&quot;dacapo&quot;).toString();</a>
<a name="ln2545">      _sndDalsegno = _e.attributes().value(&quot;dalsegno&quot;).toString();</a>
<a name="ln2546">      _sndFine = _e.attributes().value(&quot;fine&quot;).toString();</a>
<a name="ln2547">      _sndSegno = _e.attributes().value(&quot;segno&quot;).toString();</a>
<a name="ln2548">      _tpoSound = _e.attributes().value(&quot;tempo&quot;).toDouble();</a>
<a name="ln2549">      _dynaVelocity = _e.attributes().value(&quot;dynamics&quot;).toString();</a>
<a name="ln2550"> </a>
<a name="ln2551">      _e.skipCurrentElement();</a>
<a name="ln2552">      }</a>
<a name="ln2553"> </a>
<a name="ln2554">//---------------------------------------------------------</a>
<a name="ln2555">//   dynamics</a>
<a name="ln2556">//---------------------------------------------------------</a>
<a name="ln2557"> </a>
<a name="ln2558">/**</a>
<a name="ln2559"> Parse the /score-partwise/part/measure/direction/direction-type/dynamics node.</a>
<a name="ln2560"> */</a>
<a name="ln2561"> </a>
<a name="ln2562">void MusicXMLParserDirection::dynamics()</a>
<a name="ln2563">      {</a>
<a name="ln2564">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;dynamics&quot;);</a>
<a name="ln2565"> </a>
<a name="ln2566">      while (_e.readNextStartElement()) {</a>
<a name="ln2567">            if (_e.name() == &quot;other-dynamics&quot;)</a>
<a name="ln2568">                  _dynamicsList.push_back(_e.readElementText());</a>
<a name="ln2569">            else {</a>
<a name="ln2570">                  _dynamicsList.push_back(_e.name().toString());</a>
<a name="ln2571">                  _e.skipCurrentElement();</a>
<a name="ln2572">                  }</a>
<a name="ln2573">            }</a>
<a name="ln2574">      }</a>
<a name="ln2575"> </a>
<a name="ln2576">//---------------------------------------------------------</a>
<a name="ln2577">//   matchRepeat</a>
<a name="ln2578">//---------------------------------------------------------</a>
<a name="ln2579"> </a>
<a name="ln2580">/**</a>
<a name="ln2581"> Do a wild-card match with known repeat texts.</a>
<a name="ln2582"> */</a>
<a name="ln2583"> </a>
<a name="ln2584">static QString matchRepeat(const QString&amp; lowerTxt)</a>
<a name="ln2585">      {</a>
<a name="ln2586">      QString repeat;</a>
<a name="ln2587">      QRegExp daCapo(&quot;d\\.? *c\\.?|da *capo&quot;);</a>
<a name="ln2588">      QRegExp daCapoAlFine(&quot;d\\.? *c\\.? *al *fine|da *capo *al *fine&quot;);</a>
<a name="ln2589">      QRegExp daCapoAlCoda(&quot;d\\.? *c\\.? *al *coda|da *capo *al *coda&quot;);</a>
<a name="ln2590">      QRegExp dalSegno(&quot;d\\.? *s\\.?|d[ae]l *segno&quot;);</a>
<a name="ln2591">      QRegExp dalSegnoAlFine(&quot;d\\.? *s\\.? *al *fine|d[ae]l *segno *al *fine&quot;);</a>
<a name="ln2592">      QRegExp dalSegnoAlCoda(&quot;d\\.? *s\\.? *al *coda|d[ae]l *segno *al *coda&quot;);</a>
<a name="ln2593">      QRegExp fine(&quot;fine&quot;);</a>
<a name="ln2594">      QRegExp toCoda(&quot;to *coda&quot;);</a>
<a name="ln2595">      if (daCapo.exactMatch(lowerTxt)) repeat = &quot;daCapo&quot;;</a>
<a name="ln2596">      if (daCapoAlFine.exactMatch(lowerTxt)) repeat = &quot;daCapoAlFine&quot;;</a>
<a name="ln2597">      if (daCapoAlCoda.exactMatch(lowerTxt)) repeat = &quot;daCapoAlCoda&quot;;</a>
<a name="ln2598">      if (dalSegno.exactMatch(lowerTxt)) repeat = &quot;dalSegno&quot;;</a>
<a name="ln2599">      if (dalSegnoAlFine.exactMatch(lowerTxt)) repeat = &quot;dalSegnoAlFine&quot;;</a>
<a name="ln2600">      if (dalSegnoAlCoda.exactMatch(lowerTxt)) repeat = &quot;dalSegnoAlCoda&quot;;</a>
<a name="ln2601">      if (fine.exactMatch(lowerTxt)) repeat = &quot;fine&quot;;</a>
<a name="ln2602">      if (toCoda.exactMatch(lowerTxt)) repeat = &quot;toCoda&quot;;</a>
<a name="ln2603">      return repeat;</a>
<a name="ln2604">      }</a>
<a name="ln2605"> </a>
<a name="ln2606">//---------------------------------------------------------</a>
<a name="ln2607">//   findJump</a>
<a name="ln2608">//---------------------------------------------------------</a>
<a name="ln2609"> </a>
<a name="ln2610">/**</a>
<a name="ln2611"> Try to find a Jump in \a repeat.</a>
<a name="ln2612"> */</a>
<a name="ln2613"> </a>
<a name="ln2614">static Jump* findJump(const QString&amp; repeat, Score* score)</a>
<a name="ln2615">      {</a>
<a name="ln2616">      Jump* jp = 0;</a>
<a name="ln2617">      if (repeat == &quot;daCapo&quot;) {</a>
<a name="ln2618">            jp = new Jump(score);</a>
<a name="ln2619">            jp-&gt;setJumpType(Jump::Type::DC);</a>
<a name="ln2620">            }</a>
<a name="ln2621">      else if (repeat == &quot;daCapoAlCoda&quot;) {</a>
<a name="ln2622">            jp = new Jump(score);</a>
<a name="ln2623">            jp-&gt;setJumpType(Jump::Type::DC_AL_CODA);</a>
<a name="ln2624">            }</a>
<a name="ln2625">      else if (repeat == &quot;daCapoAlFine&quot;) {</a>
<a name="ln2626">            jp = new Jump(score);</a>
<a name="ln2627">            jp-&gt;setJumpType(Jump::Type::DC_AL_FINE);</a>
<a name="ln2628">            }</a>
<a name="ln2629">      else if (repeat == &quot;dalSegno&quot;) {</a>
<a name="ln2630">            jp = new Jump(score);</a>
<a name="ln2631">            jp-&gt;setJumpType(Jump::Type::DS);</a>
<a name="ln2632">            }</a>
<a name="ln2633">      else if (repeat == &quot;dalSegnoAlCoda&quot;) {</a>
<a name="ln2634">            jp = new Jump(score);</a>
<a name="ln2635">            jp-&gt;setJumpType(Jump::Type::DS_AL_CODA);</a>
<a name="ln2636">            }</a>
<a name="ln2637">      else if (repeat == &quot;dalSegnoAlFine&quot;) {</a>
<a name="ln2638">            jp = new Jump(score);</a>
<a name="ln2639">            jp-&gt;setJumpType(Jump::Type::DS_AL_FINE);</a>
<a name="ln2640">            }</a>
<a name="ln2641">      return jp;</a>
<a name="ln2642">      }</a>
<a name="ln2643"> </a>
<a name="ln2644">//---------------------------------------------------------</a>
<a name="ln2645">//   findMarker</a>
<a name="ln2646">//---------------------------------------------------------</a>
<a name="ln2647"> </a>
<a name="ln2648">/**</a>
<a name="ln2649"> Try to find a Marker in \a repeat.</a>
<a name="ln2650"> */</a>
<a name="ln2651"> </a>
<a name="ln2652">static Marker* findMarker(const QString&amp; repeat, Score* score)</a>
<a name="ln2653">      {</a>
<a name="ln2654">      Marker* m = 0;</a>
<a name="ln2655">      if (repeat == &quot;segno&quot;) {</a>
<a name="ln2656">            m = new Marker(score);</a>
<a name="ln2657">            // note: Marker::read() also contains code to set text style based on type</a>
<a name="ln2658">            // avoid duplicated code</a>
<a name="ln2659">            // apparently this MUST be after setTextStyle</a>
<a name="ln2660">            m-&gt;setMarkerType(Marker::Type::SEGNO);</a>
<a name="ln2661">            }</a>
<a name="ln2662">      else if (repeat == &quot;coda&quot;) {</a>
<a name="ln2663">            m = new Marker(score);</a>
<a name="ln2664">            m-&gt;setMarkerType(Marker::Type::CODA);</a>
<a name="ln2665">            }</a>
<a name="ln2666">      else if (repeat == &quot;fine&quot;) {</a>
<a name="ln2667">            m = new Marker(score, Tid::REPEAT_RIGHT);</a>
<a name="ln2668">            m-&gt;setMarkerType(Marker::Type::FINE);</a>
<a name="ln2669">            }</a>
<a name="ln2670">      else if (repeat == &quot;toCoda&quot;) {</a>
<a name="ln2671">            m = new Marker(score, Tid::REPEAT_RIGHT);</a>
<a name="ln2672">            m-&gt;setMarkerType(Marker::Type::TOCODA);</a>
<a name="ln2673">            }</a>
<a name="ln2674">      return m;</a>
<a name="ln2675">      }</a>
<a name="ln2676"> </a>
<a name="ln2677">//---------------------------------------------------------</a>
<a name="ln2678">//   handleRepeats</a>
<a name="ln2679">//---------------------------------------------------------</a>
<a name="ln2680"> </a>
<a name="ln2681">void MusicXMLParserDirection::handleRepeats(Measure* measure, const int track)</a>
<a name="ln2682">      {</a>
<a name="ln2683">      // Try to recognize the various repeats</a>
<a name="ln2684">      QString repeat = &quot;&quot;;</a>
<a name="ln2685">      // Easy cases first</a>
<a name="ln2686">      if (_coda) repeat = &quot;coda&quot;;</a>
<a name="ln2687">      if (_segno) repeat = &quot;segno&quot;;</a>
<a name="ln2688">      // As sound may be missing, next do a wild-card match with known repeat texts</a>
<a name="ln2689">      QString txt = MScoreTextToMXML::toPlainText(_wordsText.toLower());</a>
<a name="ln2690">      if (repeat == &quot;&quot;) repeat = matchRepeat(txt.toLower());</a>
<a name="ln2691">      // If that did not work, try to recognize a sound attribute</a>
<a name="ln2692">      if (repeat == &quot;&quot; &amp;&amp; _sndCoda != &quot;&quot;) repeat = &quot;coda&quot;;</a>
<a name="ln2693">      if (repeat == &quot;&quot; &amp;&amp; _sndDacapo != &quot;&quot;) repeat = &quot;daCapo&quot;;</a>
<a name="ln2694">      if (repeat == &quot;&quot; &amp;&amp; _sndDalsegno != &quot;&quot;) repeat = &quot;dalSegno&quot;;</a>
<a name="ln2695">      if (repeat == &quot;&quot; &amp;&amp; _sndFine != &quot;&quot;) repeat = &quot;fine&quot;;</a>
<a name="ln2696">      if (repeat == &quot;&quot; &amp;&amp; _sndSegno != &quot;&quot;) repeat = &quot;segno&quot;;</a>
<a name="ln2697">      // If a repeat was found, assume words is no longer needed</a>
<a name="ln2698">      if (repeat != &quot;&quot;) _wordsText = &quot;&quot;;</a>
<a name="ln2699"> </a>
<a name="ln2700">      /*</a>
<a name="ln2701">       qDebug(&quot; txt=%s repeat=%s&quot;,</a>
<a name="ln2702">       qPrintable(txt),</a>
<a name="ln2703">       qPrintable(repeat)</a>
<a name="ln2704">       );</a>
<a name="ln2705">       */</a>
<a name="ln2706"> </a>
<a name="ln2707">      if (repeat != &quot;&quot;) {</a>
<a name="ln2708">            if (Jump* jp = findJump(repeat, _score)) {</a>
<a name="ln2709">                  jp-&gt;setTrack(track);</a>
<a name="ln2710">                  //qDebug(&quot;jumpsMarkers adding jm %p meas %p&quot;,jp, measure);</a>
<a name="ln2711">                  // TODO jumpsMarkers.append(JumpMarkerDesc(jp, measure));</a>
<a name="ln2712">                  measure-&gt;add(jp);</a>
<a name="ln2713">                  }</a>
<a name="ln2714">            if (Marker* m = findMarker(repeat, _score)) {</a>
<a name="ln2715">                  m-&gt;setTrack(track);</a>
<a name="ln2716">                  //qDebug(&quot;jumpsMarkers adding jm %p meas %p&quot;,m, measure);</a>
<a name="ln2717">                  // TODO jumpsMarkers.append(JumpMarkerDesc(m, measure));</a>
<a name="ln2718">                  measure-&gt;add(m);</a>
<a name="ln2719">                  }</a>
<a name="ln2720">            }</a>
<a name="ln2721">      }</a>
<a name="ln2722"> </a>
<a name="ln2723">//---------------------------------------------------------</a>
<a name="ln2724">//   bracket</a>
<a name="ln2725">//---------------------------------------------------------</a>
<a name="ln2726"> </a>
<a name="ln2727">/**</a>
<a name="ln2728"> Parse the /score-partwise/part/measure/direction/direction-type/bracket node.</a>
<a name="ln2729"> */</a>
<a name="ln2730"> </a>
<a name="ln2731">void MusicXMLParserDirection::bracket(const QString&amp; type, const int number,</a>
<a name="ln2732">                                      QList&lt;MusicXmlSpannerDesc&gt;&amp; starts, QList&lt;MusicXmlSpannerDesc&gt;&amp; stops)</a>
<a name="ln2733">      {</a>
<a name="ln2734">      QStringRef lineEnd = _e.attributes().value(&quot;line-end&quot;);</a>
<a name="ln2735">      QStringRef lineType = _e.attributes().value(&quot;line-type&quot;);</a>
<a name="ln2736">      const auto&amp; spdesc = _pass2.getSpanner({ ElementType::TEXTLINE, number });</a>
<a name="ln2737">      if (type == &quot;start&quot;) {</a>
<a name="ln2738">            auto b = spdesc._isStopped ? toTextLine(spdesc._sp) : new TextLine(_score);</a>
<a name="ln2739">            // if (placement == &quot;&quot;) placement = &quot;above&quot;;  // TODO ? set default</a>
<a name="ln2740"> </a>
<a name="ln2741">            b-&gt;setBeginHookType(lineEnd != &quot;none&quot; ? HookType::HOOK_90 : HookType::NONE);</a>
<a name="ln2742">            if (lineEnd == &quot;up&quot;)</a>
<a name="ln2743">                  b-&gt;setBeginHookHeight(-1 * b-&gt;beginHookHeight());</a>
<a name="ln2744"> </a>
<a name="ln2745">            // hack: combine with a previous words element</a>
<a name="ln2746">            if (!_wordsText.isEmpty()) {</a>
<a name="ln2747">                  // TextLine supports only limited formatting, remove all (compatible with 1.3)</a>
<a name="ln2748">                  b-&gt;setBeginText(MScoreTextToMXML::toPlainText(_wordsText));</a>
<a name="ln2749">                  _wordsText = &quot;&quot;;</a>
<a name="ln2750">                  }</a>
<a name="ln2751"> </a>
<a name="ln2752">            if (lineType == &quot;solid&quot;)</a>
<a name="ln2753">                  b-&gt;setLineStyle(Qt::SolidLine);</a>
<a name="ln2754">            else if (lineType == &quot;dashed&quot;)</a>
<a name="ln2755">                  b-&gt;setLineStyle(Qt::DashLine);</a>
<a name="ln2756">            else if (lineType == &quot;dotted&quot;)</a>
<a name="ln2757">                  b-&gt;setLineStyle(Qt::DotLine);</a>
<a name="ln2758">            else</a>
<a name="ln2759">                  _logger-&gt;logError(QString(&quot;unsupported line-type: %1&quot;).arg(lineType.toString()), &amp;_e);</a>
<a name="ln2760">            starts.append(MusicXmlSpannerDesc(b, ElementType::TEXTLINE, number));</a>
<a name="ln2761">            }</a>
<a name="ln2762">      else if (type == &quot;stop&quot;) {</a>
<a name="ln2763">            auto b = spdesc._isStarted ? toTextLine(spdesc._sp) : new TextLine(_score);</a>
<a name="ln2764">            b-&gt;setEndHookType(lineEnd != &quot;none&quot; ? HookType::HOOK_90 : HookType::NONE);</a>
<a name="ln2765">            if (lineEnd == &quot;up&quot;)</a>
<a name="ln2766">                  b-&gt;setEndHookHeight(-1 * b-&gt;endHookHeight());</a>
<a name="ln2767">            stops.append(MusicXmlSpannerDesc(b, ElementType::TEXTLINE, number));</a>
<a name="ln2768">            }</a>
<a name="ln2769">      _e.skipCurrentElement();</a>
<a name="ln2770">      }</a>
<a name="ln2771"> </a>
<a name="ln2772">//---------------------------------------------------------</a>
<a name="ln2773">//   dashes</a>
<a name="ln2774">//---------------------------------------------------------</a>
<a name="ln2775"> </a>
<a name="ln2776">/**</a>
<a name="ln2777"> Parse the /score-partwise/part/measure/direction/direction-type/dashes node.</a>
<a name="ln2778"> */</a>
<a name="ln2779"> </a>
<a name="ln2780">void MusicXMLParserDirection::dashes(const QString&amp; type, const int number,</a>
<a name="ln2781">                                     QList&lt;MusicXmlSpannerDesc&gt;&amp; starts, QList&lt;MusicXmlSpannerDesc&gt;&amp; stops)</a>
<a name="ln2782">      {</a>
<a name="ln2783">      const auto&amp; spdesc = _pass2.getSpanner({ ElementType::HAIRPIN, number });</a>
<a name="ln2784">      if (type == &quot;start&quot;) {</a>
<a name="ln2785">            auto b = spdesc._isStopped ? toTextLine(spdesc._sp) : new TextLine(_score);</a>
<a name="ln2786">            // if (placement == &quot;&quot;) placement = &quot;above&quot;;  // TODO ? set default</a>
<a name="ln2787"> </a>
<a name="ln2788">            // hack: combine with a previous words element</a>
<a name="ln2789">            if (!_wordsText.isEmpty()) {</a>
<a name="ln2790">                  // TextLine supports only limited formatting, remove all (compatible with 1.3)</a>
<a name="ln2791">                  b-&gt;setBeginText(MScoreTextToMXML::toPlainText(_wordsText));</a>
<a name="ln2792">                  _wordsText = &quot;&quot;;</a>
<a name="ln2793">                  }</a>
<a name="ln2794"> </a>
<a name="ln2795">            b-&gt;setBeginHookType(HookType::NONE);</a>
<a name="ln2796">            b-&gt;setEndHookType(HookType::NONE);</a>
<a name="ln2797">            b-&gt;setLineStyle(Qt::DashLine);</a>
<a name="ln2798">            // TODO brackets and dashes now share the same storage</a>
<a name="ln2799">            // because they both use ElementType::TEXTLINE</a>
<a name="ln2800">            // use mxml specific type instead</a>
<a name="ln2801">            starts.append(MusicXmlSpannerDesc(b, ElementType::TEXTLINE, number));</a>
<a name="ln2802">            }</a>
<a name="ln2803">      else if (type == &quot;stop&quot;) {</a>
<a name="ln2804">            auto b = spdesc._isStarted ? toTextLine(spdesc._sp) : new TextLine(_score);</a>
<a name="ln2805">            stops.append(MusicXmlSpannerDesc(b, ElementType::TEXTLINE, number));</a>
<a name="ln2806">            }</a>
<a name="ln2807">      _e.skipCurrentElement();</a>
<a name="ln2808">      }</a>
<a name="ln2809"> </a>
<a name="ln2810">//---------------------------------------------------------</a>
<a name="ln2811">//   octaveShift</a>
<a name="ln2812">//---------------------------------------------------------</a>
<a name="ln2813"> </a>
<a name="ln2814">/**</a>
<a name="ln2815"> Parse the /score-partwise/part/measure/direction/direction-type/octave-shift node.</a>
<a name="ln2816"> */</a>
<a name="ln2817"> </a>
<a name="ln2818">void MusicXMLParserDirection::octaveShift(const QString&amp; type, const int number,</a>
<a name="ln2819">                                          QList&lt;MusicXmlSpannerDesc&gt;&amp; starts, QList&lt;MusicXmlSpannerDesc&gt;&amp; stops)</a>
<a name="ln2820">      {</a>
<a name="ln2821">      const auto&amp; spdesc = _pass2.getSpanner({ ElementType::OTTAVA, number });</a>
<a name="ln2822">      if (type == &quot;up&quot; || type == &quot;down&quot;) {</a>
<a name="ln2823">            int ottavasize = _e.attributes().value(&quot;size&quot;).toInt();</a>
<a name="ln2824">            if (!(ottavasize == 8 || ottavasize == 15)) {</a>
<a name="ln2825">                  _logger-&gt;logError(QString(&quot;unknown octave-shift size %1&quot;).arg(ottavasize), &amp;_e);</a>
<a name="ln2826">                  }</a>
<a name="ln2827">            else {</a>
<a name="ln2828">                  auto o = spdesc._isStopped ? toOttava(spdesc._sp) : new Ottava(_score);</a>
<a name="ln2829"> </a>
<a name="ln2830">                  // if (placement == &quot;&quot;) placement = &quot;above&quot;;  // TODO ? set default</a>
<a name="ln2831"> </a>
<a name="ln2832">                  if (type == &quot;down&quot; &amp;&amp; ottavasize ==  8) o-&gt;setOttavaType(OttavaType::OTTAVA_8VA);</a>
<a name="ln2833">                  if (type == &quot;down&quot; &amp;&amp; ottavasize == 15) o-&gt;setOttavaType(OttavaType::OTTAVA_15MA);</a>
<a name="ln2834">                  if (type ==   &quot;up&quot; &amp;&amp; ottavasize ==  8) o-&gt;setOttavaType(OttavaType::OTTAVA_8VB);</a>
<a name="ln2835">                  if (type ==   &quot;up&quot; &amp;&amp; ottavasize == 15) o-&gt;setOttavaType(OttavaType::OTTAVA_15MB);</a>
<a name="ln2836"> </a>
<a name="ln2837">                  starts.append(MusicXmlSpannerDesc(o, ElementType::OTTAVA, number));</a>
<a name="ln2838">                  }</a>
<a name="ln2839">            }</a>
<a name="ln2840">      else if (type == &quot;stop&quot;) {</a>
<a name="ln2841">            auto o = spdesc._isStarted ? toOttava(spdesc._sp) : new Ottava(_score);</a>
<a name="ln2842">            stops.append(MusicXmlSpannerDesc(o, ElementType::OTTAVA, number));</a>
<a name="ln2843">            }</a>
<a name="ln2844">      _e.skipCurrentElement();</a>
<a name="ln2845">      }</a>
<a name="ln2846"> </a>
<a name="ln2847">//---------------------------------------------------------</a>
<a name="ln2848">//   pedal</a>
<a name="ln2849">//---------------------------------------------------------</a>
<a name="ln2850"> </a>
<a name="ln2851">/**</a>
<a name="ln2852"> Parse the /score-partwise/part/measure/direction/direction-type/pedal node.</a>
<a name="ln2853"> */</a>
<a name="ln2854"> </a>
<a name="ln2855">void MusicXMLParserDirection::pedal(const QString&amp; type, const int /* number */,</a>
<a name="ln2856">                                    QList&lt;MusicXmlSpannerDesc&gt;&amp; starts,</a>
<a name="ln2857">                                    QList&lt;MusicXmlSpannerDesc&gt;&amp; stops)</a>
<a name="ln2858">      {</a>
<a name="ln2859">      const int number { 0 };</a>
<a name="ln2860">      QStringRef line = _e.attributes().value(&quot;line&quot;);</a>
<a name="ln2861">      QString sign = _e.attributes().value(&quot;sign&quot;).toString();</a>
<a name="ln2862">      if (line != &quot;yes&quot; &amp;&amp; sign == &quot;&quot;) sign = &quot;yes&quot;;       // MusicXML 2.0 compatibility</a>
<a name="ln2863">      if (line == &quot;yes&quot; &amp;&amp; sign == &quot;&quot;) sign = &quot;no&quot;;        // MusicXML 2.0 compatibility</a>
<a name="ln2864">      if (line == &quot;yes&quot;) {</a>
<a name="ln2865">            const auto&amp; spdesc = _pass2.getSpanner({ ElementType::PEDAL, number });</a>
<a name="ln2866">            if (type == &quot;start&quot;) {</a>
<a name="ln2867">                  auto p = spdesc._isStopped ? toPedal(spdesc._sp) : new Pedal(_score);</a>
<a name="ln2868">                  if (sign == &quot;yes&quot;)</a>
<a name="ln2869">                        p-&gt;setBeginText(&quot;&lt;sym&gt;keyboardPedalPed&lt;/sym&gt;&quot;);</a>
<a name="ln2870">                  else</a>
<a name="ln2871">                        p-&gt;setBeginHookType(HookType::HOOK_90);</a>
<a name="ln2872">                  p-&gt;setEndHookType(HookType::HOOK_90);</a>
<a name="ln2873">                  // if (placement == &quot;&quot;) placement = &quot;below&quot;;  // TODO ? set default</a>
<a name="ln2874">                  starts.append(MusicXmlSpannerDesc(p, ElementType::PEDAL, number));</a>
<a name="ln2875">                  }</a>
<a name="ln2876">            else if (type == &quot;stop&quot;) {</a>
<a name="ln2877">                  auto p = spdesc._isStarted ? toPedal(spdesc._sp) : new Pedal(_score);</a>
<a name="ln2878">                  stops.append(MusicXmlSpannerDesc(p, ElementType::PEDAL, number));</a>
<a name="ln2879">                  }</a>
<a name="ln2880">            else if (type == &quot;change&quot;) {</a>
<a name="ln2881">#if 0</a>
<a name="ln2882">                  TODO</a>
<a name="ln2883">                  // pedal change is implemented as two separate pedals</a>
<a name="ln2884">                  // first stop the first one</a>
<a name="ln2885">                  if (pedal) {</a>
<a name="ln2886">                        pedal-&gt;setEndHookType(HookType::HOOK_45);</a>
<a name="ln2887">                        handleSpannerStop(pedal, &quot;pedal&quot;, track, tick, spanners);</a>
<a name="ln2888">                        pedalContinue = pedal; // mark for later fixup</a>
<a name="ln2889">                        pedal = 0;</a>
<a name="ln2890">                        }</a>
<a name="ln2891">                  // then start a new one</a>
<a name="ln2892">                  pedal = toPedal(checkSpannerOverlap(pedal, new Pedal(score), &quot;pedal&quot;));</a>
<a name="ln2893">                  pedal-&gt;setBeginHookType(HookType::HOOK_45);</a>
<a name="ln2894">                  pedal-&gt;setEndHookType(HookType::HOOK_90);</a>
<a name="ln2895">                  if (placement == &quot;&quot;) placement = &quot;below&quot;;</a>
<a name="ln2896">                  handleSpannerStart(pedal, &quot;pedal&quot;, track, placement, tick, spanners);</a>
<a name="ln2897">#endif</a>
<a name="ln2898">                  }</a>
<a name="ln2899">            else if (type == &quot;continue&quot;) {</a>
<a name="ln2900">                  // ignore</a>
<a name="ln2901">                  }</a>
<a name="ln2902">            else</a>
<a name="ln2903">                  qDebug(&quot;unknown pedal type %s&quot;, qPrintable(type));</a>
<a name="ln2904">            }</a>
<a name="ln2905">      else {</a>
<a name="ln2906">            // TBD: what happens when an unknown pedal type is found ?</a>
<a name="ln2907">            Symbol* s = new Symbol(_score);</a>
<a name="ln2908">            s-&gt;setAlign(Align::LEFT | Align::BASELINE);</a>
<a name="ln2909">            //s-&gt;setOffsetType(OffsetType::SPATIUM);</a>
<a name="ln2910">            if (type == &quot;start&quot;)</a>
<a name="ln2911">                  s-&gt;setSym(SymId::keyboardPedalPed);</a>
<a name="ln2912">            else if (type == &quot;stop&quot;)</a>
<a name="ln2913">                  s-&gt;setSym(SymId::keyboardPedalUp);</a>
<a name="ln2914">            else</a>
<a name="ln2915">                  _logger-&gt;logError(QString(&quot;unknown pedal type %1&quot;).arg(type), &amp;_e);</a>
<a name="ln2916">            _elems.append(s);</a>
<a name="ln2917">            }</a>
<a name="ln2918"> </a>
<a name="ln2919">      _e.skipCurrentElement();</a>
<a name="ln2920">      }</a>
<a name="ln2921"> </a>
<a name="ln2922">//---------------------------------------------------------</a>
<a name="ln2923">//   wedge</a>
<a name="ln2924">//---------------------------------------------------------</a>
<a name="ln2925"> </a>
<a name="ln2926">/**</a>
<a name="ln2927"> Parse the /score-partwise/part/measure/direction/direction-type/wedge node.</a>
<a name="ln2928"> */</a>
<a name="ln2929"> </a>
<a name="ln2930">void MusicXMLParserDirection::wedge(const QString&amp; type, const int number,</a>
<a name="ln2931">                                    QList&lt;MusicXmlSpannerDesc&gt;&amp; starts, QList&lt;MusicXmlSpannerDesc&gt;&amp; stops)</a>
<a name="ln2932">      {</a>
<a name="ln2933">      QStringRef niente = _e.attributes().value(&quot;niente&quot;);</a>
<a name="ln2934">      const auto&amp; spdesc = _pass2.getSpanner({ ElementType::HAIRPIN, number });</a>
<a name="ln2935">      if (type == &quot;crescendo&quot; || type == &quot;diminuendo&quot;) {</a>
<a name="ln2936">            auto h = spdesc._isStopped ? toHairpin(spdesc._sp) : new Hairpin(_score);</a>
<a name="ln2937">            h-&gt;setHairpinType(type == &quot;crescendo&quot;</a>
<a name="ln2938">                              ? HairpinType::CRESC_HAIRPIN : HairpinType::DECRESC_HAIRPIN);</a>
<a name="ln2939">            if (niente == &quot;yes&quot;)</a>
<a name="ln2940">                  h-&gt;setHairpinCircledTip(true);</a>
<a name="ln2941">            starts.append(MusicXmlSpannerDesc(h, ElementType::HAIRPIN, number));</a>
<a name="ln2942">            }</a>
<a name="ln2943">      else if (type == &quot;stop&quot;) {</a>
<a name="ln2944">            auto h = spdesc._isStarted ? toHairpin(spdesc._sp) : new Hairpin(_score);</a>
<a name="ln2945">            if (niente == &quot;yes&quot;)</a>
<a name="ln2946">                  h-&gt;setHairpinCircledTip(true);</a>
<a name="ln2947">            stops.append(MusicXmlSpannerDesc(h, ElementType::HAIRPIN, number));</a>
<a name="ln2948">            }</a>
<a name="ln2949">      _e.skipCurrentElement();</a>
<a name="ln2950">      }</a>
<a name="ln2951"> </a>
<a name="ln2952">//---------------------------------------------------------</a>
<a name="ln2953">//   toString</a>
<a name="ln2954">//---------------------------------------------------------</a>
<a name="ln2955"> </a>
<a name="ln2956">QString MusicXmlExtendedSpannerDesc::toString() const</a>
<a name="ln2957">      {</a>
<a name="ln2958">      QString string;</a>
<a name="ln2959">      QTextStream(&amp;string) &lt;&lt; _sp;</a>
<a name="ln2960">      return QString(&quot;sp %1 tp %2 tick2 %3 track2 %4 %5 %6&quot;)</a>
<a name="ln2961">             .arg(string)</a>
<a name="ln2962">             .arg(_tick2.print())</a>
<a name="ln2963">             .arg(_track2)</a>
<a name="ln2964">             .arg(_isStarted ? &quot;started&quot; : &quot;&quot;)</a>
<a name="ln2965">             .arg(_isStopped ? &quot;stopped&quot; : &quot;&quot;)</a>
<a name="ln2966">      ;</a>
<a name="ln2967">      }</a>
<a name="ln2968"> </a>
<a name="ln2969">//---------------------------------------------------------</a>
<a name="ln2970">//   addSpanner</a>
<a name="ln2971">//---------------------------------------------------------</a>
<a name="ln2972"> </a>
<a name="ln2973">void MusicXMLParserPass2::addSpanner(const MusicXmlSpannerDesc&amp; d)</a>
<a name="ln2974">      {</a>
<a name="ln2975">      auto&amp; spdesc = getSpanner(d);</a>
<a name="ln2976">      spdesc._sp = d._sp;</a>
<a name="ln2977">      }</a>
<a name="ln2978"> </a>
<a name="ln2979">//---------------------------------------------------------</a>
<a name="ln2980">//   getSpanner</a>
<a name="ln2981">//---------------------------------------------------------</a>
<a name="ln2982"> </a>
<a name="ln2983">MusicXmlExtendedSpannerDesc&amp; MusicXMLParserPass2::getSpanner(const MusicXmlSpannerDesc&amp; d)</a>
<a name="ln2984">      {</a>
<a name="ln2985">      if (d._tp == ElementType::HAIRPIN &amp;&amp; 0 &lt;= d._nr &amp;&amp; d._nr &lt; MAX_NUMBER_LEVEL)</a>
<a name="ln2986">            return _hairpins[d._nr];</a>
<a name="ln2987">      else if (d._tp == ElementType::OTTAVA &amp;&amp; 0 &lt;= d._nr &amp;&amp; d._nr &lt; MAX_NUMBER_LEVEL)</a>
<a name="ln2988">            return _ottavas[d._nr];</a>
<a name="ln2989">      else if (d._tp == ElementType::PEDAL &amp;&amp; 0 == d._nr)</a>
<a name="ln2990">            return _pedal;</a>
<a name="ln2991">      else if (d._tp == ElementType::TEXTLINE &amp;&amp; 0 &lt;= d._nr &amp;&amp; d._nr &lt; MAX_NUMBER_LEVEL)</a>
<a name="ln2992">            return _brackets[d._nr];</a>
<a name="ln2993">      _logger-&gt;logError(QString(&quot;invalid number %1&quot;).arg(d._nr + 1), &amp;_e);</a>
<a name="ln2994">      return _dummyNewMusicXmlSpannerDesc;</a>
<a name="ln2995">      }</a>
<a name="ln2996"> </a>
<a name="ln2997">//---------------------------------------------------------</a>
<a name="ln2998">//   clearSpanner</a>
<a name="ln2999">//---------------------------------------------------------</a>
<a name="ln3000"> </a>
<a name="ln3001">void MusicXMLParserPass2::clearSpanner(const MusicXmlSpannerDesc&amp; d)</a>
<a name="ln3002">      {</a>
<a name="ln3003">      auto&amp; spdesc = getSpanner(d);</a>
<a name="ln3004">      spdesc = {};</a>
<a name="ln3005">      }</a>
<a name="ln3006"> </a>
<a name="ln3007">//---------------------------------------------------------</a>
<a name="ln3008">//   metronome</a>
<a name="ln3009">//---------------------------------------------------------</a>
<a name="ln3010"> </a>
<a name="ln3011">/**</a>
<a name="ln3012"> Parse the /score-partwise/part/measure/direction/direction-type/metronome node.</a>
<a name="ln3013"> Convert to text and set r to calculated tempo.</a>
<a name="ln3014"> */</a>
<a name="ln3015"> </a>
<a name="ln3016">QString MusicXMLParserDirection::metronome(double&amp; r)</a>
<a name="ln3017">      {</a>
<a name="ln3018">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;metronome&quot;);</a>
<a name="ln3019"> </a>
<a name="ln3020">      r = 0;</a>
<a name="ln3021">      QString tempoText;</a>
<a name="ln3022">      QString perMinute;</a>
<a name="ln3023">      bool parenth = _e.attributes().value(&quot;parentheses&quot;) == &quot;yes&quot;;</a>
<a name="ln3024"> </a>
<a name="ln3025">      if (parenth)</a>
<a name="ln3026">            tempoText += &quot;(&quot;;</a>
<a name="ln3027"> </a>
<a name="ln3028">      TDuration dur1;</a>
<a name="ln3029">      TDuration dur2;</a>
<a name="ln3030"> </a>
<a name="ln3031">      while (_e.readNextStartElement()) {</a>
<a name="ln3032">            if (_e.name() == &quot;metronome-note&quot; || _e.name() == &quot;metronome-relation&quot;) {</a>
<a name="ln3033">                  skipLogCurrElem();</a>
<a name="ln3034">                  continue;</a>
<a name="ln3035">                  }</a>
<a name="ln3036">            QString txt = _e.readElementText();</a>
<a name="ln3037">            if (_e.name() == &quot;beat-unit&quot;) {</a>
<a name="ln3038">                  // set first dur that is still invalid</a>
<a name="ln3039">                  if (!dur1.isValid()) dur1.setType(txt);</a>
<a name="ln3040">                  else if (!dur2.isValid()) dur2.setType(txt);</a>
<a name="ln3041">                  }</a>
<a name="ln3042">            else if (_e.name() == &quot;beat-unit-dot&quot;) {</a>
<a name="ln3043">                  if (dur2.isValid()) dur2.setDots(1);</a>
<a name="ln3044">                  else if (dur1.isValid()) dur1.setDots(1);</a>
<a name="ln3045">                  }</a>
<a name="ln3046">            else if (_e.name() == &quot;per-minute&quot;)</a>
<a name="ln3047">                  perMinute = txt;</a>
<a name="ln3048">            else</a>
<a name="ln3049">                  skipLogCurrElem();</a>
<a name="ln3050">            }</a>
<a name="ln3051"> </a>
<a name="ln3052">      if (dur1.isValid())</a>
<a name="ln3053">            tempoText += TempoText::duration2tempoTextString(dur1);</a>
<a name="ln3054">      if (dur2.isValid()) {</a>
<a name="ln3055">            tempoText += &quot; = &quot;;</a>
<a name="ln3056">            tempoText += TempoText::duration2tempoTextString(dur2);</a>
<a name="ln3057">            }</a>
<a name="ln3058">      else if (perMinute != &quot;&quot;) {</a>
<a name="ln3059">            tempoText += &quot; = &quot;;</a>
<a name="ln3060">            tempoText += perMinute;</a>
<a name="ln3061">            }</a>
<a name="ln3062">      if (dur1.isValid() &amp;&amp; !dur2.isValid() &amp;&amp; perMinute != &quot;&quot;) {</a>
<a name="ln3063">            bool ok;</a>
<a name="ln3064">            double d = perMinute.toDouble(&amp;ok);</a>
<a name="ln3065">            if (ok) {</a>
<a name="ln3066">                  // convert fraction to beats per minute</a>
<a name="ln3067">                  r = 4 * dur1.fraction().numerator() * d / dur1.fraction().denominator();</a>
<a name="ln3068">                  }</a>
<a name="ln3069">            }</a>
<a name="ln3070"> </a>
<a name="ln3071">      if (parenth)</a>
<a name="ln3072">            tempoText += &quot;)&quot;;</a>
<a name="ln3073"> </a>
<a name="ln3074">      return tempoText;</a>
<a name="ln3075">      }</a>
<a name="ln3076"> </a>
<a name="ln3077">//---------------------------------------------------------</a>
<a name="ln3078">//   determineBarLineType</a>
<a name="ln3079">//---------------------------------------------------------</a>
<a name="ln3080"> </a>
<a name="ln3081">static bool determineBarLineType(const QString&amp; barStyle, const QString&amp; repeat,</a>
<a name="ln3082">                                 BarLineType&amp; type, bool&amp; visible)</a>
<a name="ln3083">      {</a>
<a name="ln3084">      // set defaults</a>
<a name="ln3085">      type = BarLineType::NORMAL;</a>
<a name="ln3086">      visible = true;</a>
<a name="ln3087"> </a>
<a name="ln3088">      if (barStyle == &quot;light-heavy&quot; &amp;&amp; repeat == &quot;backward&quot;)</a>
<a name="ln3089">            type = BarLineType::END_REPEAT;</a>
<a name="ln3090">      else if (barStyle == &quot;heavy-light&quot; &amp;&amp; repeat == &quot;forward&quot;)</a>
<a name="ln3091">            type = BarLineType::START_REPEAT;</a>
<a name="ln3092">      else if (barStyle == &quot;light-heavy&quot; &amp;&amp; repeat.isEmpty())</a>
<a name="ln3093">            type = BarLineType::END;</a>
<a name="ln3094">      else if (barStyle == &quot;regular&quot;)</a>
<a name="ln3095">            type = BarLineType::NORMAL;</a>
<a name="ln3096">      else if (barStyle == &quot;dashed&quot;)</a>
<a name="ln3097">            type = BarLineType::BROKEN;</a>
<a name="ln3098">      else if (barStyle == &quot;dotted&quot;)</a>
<a name="ln3099">            type = BarLineType::DOTTED;</a>
<a name="ln3100">      else if (barStyle == &quot;light-light&quot;)</a>
<a name="ln3101">            type = BarLineType::DOUBLE;</a>
<a name="ln3102">      /*</a>
<a name="ln3103">       else if (barStyle == &quot;heavy-light&quot;)</a>
<a name="ln3104">       ;</a>
<a name="ln3105">       else if (barStyle == &quot;heavy-heavy&quot;)</a>
<a name="ln3106">       ;</a>
<a name="ln3107">       */</a>
<a name="ln3108">      else if (barStyle == &quot;none&quot;)</a>
<a name="ln3109">            visible = false;</a>
<a name="ln3110">      else if (barStyle == &quot;&quot;) {</a>
<a name="ln3111">            if (repeat == &quot;backward&quot;)</a>
<a name="ln3112">                  type = BarLineType::END_REPEAT;</a>
<a name="ln3113">            else if (repeat == &quot;forward&quot;)</a>
<a name="ln3114">                  type = BarLineType::START_REPEAT;</a>
<a name="ln3115">            else {</a>
<a name="ln3116">                  qDebug(&quot;empty bar type&quot;);       // TODO</a>
<a name="ln3117">                  return false;</a>
<a name="ln3118">                  }</a>
<a name="ln3119">            }</a>
<a name="ln3120">      else if (barStyle == &quot;tick&quot; || &quot;short&quot;) {</a>
<a name="ln3121">            // handled later (as normal barline with different parameters)</a>
<a name="ln3122">            }</a>
<a name="ln3123">      else {</a>
<a name="ln3124">            qDebug(&quot;unsupported bar type &lt;%s&gt;&quot;, qPrintable(barStyle));       // TODO</a>
<a name="ln3125">            return false;</a>
<a name="ln3126">            }</a>
<a name="ln3127"> </a>
<a name="ln3128">      return true;</a>
<a name="ln3129">      }</a>
<a name="ln3130"> </a>
<a name="ln3131">//---------------------------------------------------------</a>
<a name="ln3132">//   createBarline</a>
<a name="ln3133">//---------------------------------------------------------</a>
<a name="ln3134"> </a>
<a name="ln3135">/*</a>
<a name="ln3136"> * Create a barline of the specified type.</a>
<a name="ln3137"> */</a>
<a name="ln3138"> </a>
<a name="ln3139">static std::unique_ptr&lt;BarLine&gt; createBarline(Score* score, const int track, const BarLineType type, const bool visible, const QString&amp; barStyle)</a>
<a name="ln3140">      {</a>
<a name="ln3141">      std::unique_ptr&lt;BarLine&gt; barline(new BarLine(score));</a>
<a name="ln3142">      barline-&gt;setTrack(track);</a>
<a name="ln3143">      barline-&gt;setBarLineType(type);</a>
<a name="ln3144">      barline-&gt;setSpanStaff(0);</a>
<a name="ln3145">      barline-&gt;setVisible(visible);</a>
<a name="ln3146">      if (barStyle == &quot;tick&quot;) {</a>
<a name="ln3147">            barline-&gt;setSpanFrom(BARLINE_SPAN_TICK1_FROM);</a>
<a name="ln3148">            barline-&gt;setSpanTo(BARLINE_SPAN_TICK1_TO);</a>
<a name="ln3149">            }</a>
<a name="ln3150">      else if (barStyle == &quot;short&quot;) {</a>
<a name="ln3151">            barline-&gt;setSpanFrom(BARLINE_SPAN_SHORT1_FROM);</a>
<a name="ln3152">            barline-&gt;setSpanTo(BARLINE_SPAN_SHORT1_TO);</a>
<a name="ln3153">            }</a>
<a name="ln3154">      return barline;</a>
<a name="ln3155">      }</a>
<a name="ln3156"> </a>
<a name="ln3157">//---------------------------------------------------------</a>
<a name="ln3158">//   addBarlineToMeasure</a>
<a name="ln3159">//---------------------------------------------------------</a>
<a name="ln3160"> </a>
<a name="ln3161">/*</a>
<a name="ln3162"> * Add barline to the measure at tick.</a>
<a name="ln3163"> */</a>
<a name="ln3164"> </a>
<a name="ln3165">static void addBarlineToMeasure(Measure* measure, const Fraction tick, std::unique_ptr&lt;BarLine&gt; barline)</a>
<a name="ln3166">      {</a>
<a name="ln3167">      auto st = SegmentType::BarLine;</a>
<a name="ln3168">      if (tick == measure-&gt;endTick())</a>
<a name="ln3169">            st = SegmentType::EndBarLine;</a>
<a name="ln3170">      else if (tick == measure-&gt;tick())</a>
<a name="ln3171">            st = SegmentType::BeginBarLine;</a>
<a name="ln3172">      const auto segment = measure-&gt;getSegment(st, tick);</a>
<a name="ln3173">      barline-&gt;layout();</a>
<a name="ln3174">      segment-&gt;add(barline.release());</a>
<a name="ln3175">      }</a>
<a name="ln3176"> </a>
<a name="ln3177">//---------------------------------------------------------</a>
<a name="ln3178">//   barline</a>
<a name="ln3179">//---------------------------------------------------------</a>
<a name="ln3180"> </a>
<a name="ln3181">/**</a>
<a name="ln3182"> Parse the /score-partwise/part/measure/barline node.</a>
<a name="ln3183"> */</a>
<a name="ln3184"> </a>
<a name="ln3185">/*</a>
<a name="ln3186"> Following barline types are automatically generated by MuseScore in an EndBarLine segment at the end of a measure:</a>
<a name="ln3187"> - normal (excluding tick and short)</a>
<a name="ln3188"> - start repeat</a>
<a name="ln3189"> - end-start repeat</a>
<a name="ln3190"> - end repeat</a>
<a name="ln3191"> - final (at the end of the score only)</a>
<a name="ln3192"> The other barline types can also be in an EndBarLine segment at the end of a measure, but are NOT generated</a>
<a name="ln3193"> Mid-measure barlines are in a BarLine segment and are NOT generated</a>
<a name="ln3194"> Following barline types can only be at the end of a measure:</a>
<a name="ln3195"> - start repeat</a>
<a name="ln3196"> - end-start repeat</a>
<a name="ln3197"> - end repeat</a>
<a name="ln3198"> - final</a>
<a name="ln3199"> */</a>
<a name="ln3200"> </a>
<a name="ln3201">void MusicXMLParserPass2::barline(const QString&amp; partId, Measure* measure, const Fraction&amp; tick)</a>
<a name="ln3202">      {</a>
<a name="ln3203">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;barline&quot;);</a>
<a name="ln3204"> </a>
<a name="ln3205">      QString loc = _e.attributes().value(&quot;location&quot;).toString();</a>
<a name="ln3206">      if (loc == &quot;&quot;)</a>
<a name="ln3207">            loc = &quot;right&quot;;</a>
<a name="ln3208">      QString barStyle;</a>
<a name="ln3209">      QString endingNumber;</a>
<a name="ln3210">      QString endingType;</a>
<a name="ln3211">      QString endingText;</a>
<a name="ln3212">      QString repeat;</a>
<a name="ln3213">      QString count;</a>
<a name="ln3214"> </a>
<a name="ln3215">      while (_e.readNextStartElement()) {</a>
<a name="ln3216">            if (_e.name() == &quot;bar-style&quot;)</a>
<a name="ln3217">                  barStyle = _e.readElementText();</a>
<a name="ln3218">            else if (_e.name() == &quot;ending&quot;) {</a>
<a name="ln3219">                  endingNumber = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln3220">                  endingType   = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln3221">                  endingText = _e.readElementText();</a>
<a name="ln3222">                  }</a>
<a name="ln3223">            else if (_e.name() == &quot;repeat&quot;) {</a>
<a name="ln3224">                  repeat = _e.attributes().value(&quot;direction&quot;).toString();</a>
<a name="ln3225">                  count = _e.attributes().value(&quot;times&quot;).toString();</a>
<a name="ln3226">                  if (count.isEmpty()) {</a>
<a name="ln3227">                        count = &quot;2&quot;;</a>
<a name="ln3228">                        }</a>
<a name="ln3229">                  measure-&gt;setRepeatCount(count.toInt());</a>
<a name="ln3230">                  _e.skipCurrentElement();</a>
<a name="ln3231">                  }</a>
<a name="ln3232">            else</a>
<a name="ln3233">                  skipLogCurrElem();</a>
<a name="ln3234">            }</a>
<a name="ln3235"> </a>
<a name="ln3236">      BarLineType type = BarLineType::NORMAL;</a>
<a name="ln3237">      bool visible = true;</a>
<a name="ln3238">      if (determineBarLineType(barStyle, repeat, type, visible)) {</a>
<a name="ln3239">            const auto track = _pass1.trackForPart(partId);</a>
<a name="ln3240">            if (type == BarLineType::START_REPEAT) {</a>
<a name="ln3241">                  // combine start_repeat flag with current state initialized during measure parsing</a>
<a name="ln3242">                  measure-&gt;setRepeatStart(true);</a>
<a name="ln3243">                  }</a>
<a name="ln3244">            else if (type == BarLineType::END_REPEAT) {</a>
<a name="ln3245">                  // combine end_repeat flag with current state initialized during measure parsing</a>
<a name="ln3246">                  measure-&gt;setRepeatEnd(true);</a>
<a name="ln3247">                  }</a>
<a name="ln3248">            else if (type == BarLineType::END) {</a>
<a name="ln3249">                  measure-&gt;setEndBarLineType(type, track, visible);</a>
<a name="ln3250">                  }</a>
<a name="ln3251">            else {</a>
<a name="ln3252">                  if (barStyle == &quot;tick&quot;</a>
<a name="ln3253">                      || barStyle == &quot;short&quot;</a>
<a name="ln3254">                      || barStyle == &quot;none&quot;</a>
<a name="ln3255">                      || barStyle == &quot;dashed&quot;</a>
<a name="ln3256">                      || barStyle == &quot;dotted&quot;</a>
<a name="ln3257">                      || barStyle == &quot;light-light&quot;</a>
<a name="ln3258">                      || barStyle == &quot;regular&quot;) {</a>
<a name="ln3259">                        auto b = createBarline(measure-&gt;score(), track, type, visible, barStyle);</a>
<a name="ln3260">                        addBarlineToMeasure(measure, tick, std::move(b));</a>
<a name="ln3261">                        }</a>
<a name="ln3262">                  }</a>
<a name="ln3263">            }</a>
<a name="ln3264"> </a>
<a name="ln3265">      doEnding(partId, measure, endingNumber, endingType, endingText);</a>
<a name="ln3266">      }</a>
<a name="ln3267"> </a>
<a name="ln3268">//---------------------------------------------------------</a>
<a name="ln3269">//   doEnding</a>
<a name="ln3270">//---------------------------------------------------------</a>
<a name="ln3271"> </a>
<a name="ln3272">void MusicXMLParserPass2::doEnding(const QString&amp; partId, Measure* measure,</a>
<a name="ln3273">                                   const QString&amp; number, const QString&amp; type, const QString&amp; text)</a>
<a name="ln3274">      {</a>
<a name="ln3275">      if (!(number.isEmpty() &amp;&amp; type.isEmpty())) {</a>
<a name="ln3276">            if (number.isEmpty())</a>
<a name="ln3277">                  _logger-&gt;logError(&quot;empty ending number&quot;, &amp;_e);</a>
<a name="ln3278">            else if (type.isEmpty())</a>
<a name="ln3279">                  _logger-&gt;logError(&quot;empty ending type&quot;, &amp;_e);</a>
<a name="ln3280">            else {</a>
<a name="ln3281">                  QStringList sl = number.split(&quot;,&quot;, QString::SkipEmptyParts);</a>
<a name="ln3282">                  QList&lt;int&gt; iEndingNumbers;</a>
<a name="ln3283">                  bool unsupported = false;</a>
<a name="ln3284">                  foreach(const QString &amp;s, sl) {</a>
<a name="ln3285">                        int iEndingNumber = s.toInt();</a>
<a name="ln3286">                        if (iEndingNumber &lt;= 0) {</a>
<a name="ln3287">                              unsupported = true;</a>
<a name="ln3288">                              break;</a>
<a name="ln3289">                              }</a>
<a name="ln3290">                        iEndingNumbers.append(iEndingNumber);</a>
<a name="ln3291">                        }</a>
<a name="ln3292"> </a>
<a name="ln3293">                  if (unsupported)</a>
<a name="ln3294">                        _logger-&gt;logError(QString(&quot;unsupported ending number '%1'&quot;).arg(number), &amp;_e);</a>
<a name="ln3295">                  else {</a>
<a name="ln3296">                        if (type == &quot;start&quot;) {</a>
<a name="ln3297">                              Volta* volta = new Volta(_score);</a>
<a name="ln3298">                              volta-&gt;setTrack(_pass1.trackForPart(partId));</a>
<a name="ln3299">                              volta-&gt;setText(text.isEmpty() ? number : text);</a>
<a name="ln3300">                              // LVIFIX TODO also support endings &quot;1 - 3&quot;</a>
<a name="ln3301">                              volta-&gt;endings().clear();</a>
<a name="ln3302">                              volta-&gt;endings().append(iEndingNumbers);</a>
<a name="ln3303">                              volta-&gt;setTick(measure-&gt;tick());</a>
<a name="ln3304">                              _score-&gt;addElement(volta);</a>
<a name="ln3305">                              _lastVolta = volta;</a>
<a name="ln3306">                              }</a>
<a name="ln3307">                        else if (type == &quot;stop&quot;) {</a>
<a name="ln3308">                              if (_lastVolta) {</a>
<a name="ln3309">                                    _lastVolta-&gt;setVoltaType(Volta::Type::CLOSED);</a>
<a name="ln3310">                                    _lastVolta-&gt;setTick2(measure-&gt;tick() + measure-&gt;ticks());</a>
<a name="ln3311">                                    _lastVolta = 0;</a>
<a name="ln3312">                                    }</a>
<a name="ln3313">                              else</a>
<a name="ln3314">                                    _logger-&gt;logError(&quot;ending stop without start&quot;, &amp;_e);</a>
<a name="ln3315">                              }</a>
<a name="ln3316">                        else if (type == &quot;discontinue&quot;) {</a>
<a name="ln3317">                              if (_lastVolta) {</a>
<a name="ln3318">                                    _lastVolta-&gt;setVoltaType(Volta::Type::OPEN);</a>
<a name="ln3319">                                    _lastVolta-&gt;setTick2(measure-&gt;tick() + measure-&gt;ticks());</a>
<a name="ln3320">                                    _lastVolta = 0;</a>
<a name="ln3321">                                    }</a>
<a name="ln3322">                              else</a>
<a name="ln3323">                                    _logger-&gt;logError(&quot;ending discontinue without start&quot;, &amp;_e);</a>
<a name="ln3324">                              }</a>
<a name="ln3325">                        else</a>
<a name="ln3326">                              _logger-&gt;logError(QString(&quot;unsupported ending type '%1'&quot;).arg(type), &amp;_e);</a>
<a name="ln3327">                        }</a>
<a name="ln3328">                  }</a>
<a name="ln3329">            }</a>
<a name="ln3330">      }</a>
<a name="ln3331"> </a>
<a name="ln3332">//---------------------------------------------------------</a>
<a name="ln3333">//   addSymToSig</a>
<a name="ln3334">//---------------------------------------------------------</a>
<a name="ln3335"> </a>
<a name="ln3336">/**</a>
<a name="ln3337"> Add a symbol defined as key-step \a step , -alter \a alter and -accidental \a accid to \a sig.</a>
<a name="ln3338"> */</a>
<a name="ln3339"> </a>
<a name="ln3340">static void addSymToSig(KeySigEvent&amp; sig, const QString&amp; step, const QString&amp; alter, const QString&amp; accid)</a>
<a name="ln3341">      {</a>
<a name="ln3342">      //qDebug(&quot;addSymToSig(step '%s' alt '%s' acc '%s')&quot;,</a>
<a name="ln3343">      //       qPrintable(step), qPrintable(alter), qPrintable(accid));</a>
<a name="ln3344"> </a>
<a name="ln3345">      SymId id = mxmlString2accSymId(accid);</a>
<a name="ln3346">      if (id == SymId::noSym) {</a>
<a name="ln3347">            bool ok;</a>
<a name="ln3348">            double d;</a>
<a name="ln3349">            d = alter.toDouble(&amp;ok);</a>
<a name="ln3350">            AccidentalType accTpAlter = ok ? microtonalGuess(d) : AccidentalType::NONE;</a>
<a name="ln3351">            id = mxmlString2accSymId(accidentalType2MxmlString(accTpAlter));</a>
<a name="ln3352">            }</a>
<a name="ln3353"> </a>
<a name="ln3354">      if (step.size() == 1 &amp;&amp; id != SymId::noSym) {</a>
<a name="ln3355">            const QString table = &quot;FEDCBAG&quot;;</a>
<a name="ln3356">            const int line = table.indexOf(step);</a>
<a name="ln3357">            // no auto layout for custom keysig, calculate xpos</a>
<a name="ln3358">            // TODO: use symbol width ?</a>
<a name="ln3359">            const qreal spread = 1.4; // assumed glyph width in space</a>
<a name="ln3360">            const qreal x = sig.keySymbols().size() * spread;</a>
<a name="ln3361">            if (line &gt;= 0) {</a>
<a name="ln3362">                  KeySym ks;</a>
<a name="ln3363">                  ks.sym  = id;</a>
<a name="ln3364">                  ks.spos = QPointF(x, qreal(line) * 0.5);</a>
<a name="ln3365">                  sig.keySymbols().append(ks);</a>
<a name="ln3366">                  sig.setCustom(true);</a>
<a name="ln3367">                  }</a>
<a name="ln3368">            }</a>
<a name="ln3369">      }</a>
<a name="ln3370"> </a>
<a name="ln3371">//---------------------------------------------------------</a>
<a name="ln3372">//   addKey</a>
<a name="ln3373">//---------------------------------------------------------</a>
<a name="ln3374"> </a>
<a name="ln3375">/**</a>
<a name="ln3376"> Add a KeySigEvent to the score.</a>
<a name="ln3377"> */</a>
<a name="ln3378"> </a>
<a name="ln3379">static void addKey(const KeySigEvent key, const bool printObj, Score* score, Measure* measure, const int staffIdx, const Fraction&amp; tick)</a>
<a name="ln3380">      {</a>
<a name="ln3381">      Key oldkey = score-&gt;staff(staffIdx)-&gt;key(tick);</a>
<a name="ln3382">      // TODO only if different custom key ?</a>
<a name="ln3383">      if (oldkey != key.key() || key.custom() || key.isAtonal()) {</a>
<a name="ln3384">            // new key differs from key in effect at this tick</a>
<a name="ln3385">            KeySig* keysig = new KeySig(score);</a>
<a name="ln3386">            keysig-&gt;setTrack((staffIdx) * VOICES);</a>
<a name="ln3387">            keysig-&gt;setKeySigEvent(key);</a>
<a name="ln3388">            keysig-&gt;setVisible(printObj);</a>
<a name="ln3389">            Segment* s = measure-&gt;getSegment(SegmentType::KeySig, tick);</a>
<a name="ln3390">            s-&gt;add(keysig);</a>
<a name="ln3391">            //currKeySig-&gt;setKeySigEvent(key);</a>
<a name="ln3392">            }</a>
<a name="ln3393">      }</a>
<a name="ln3394"> </a>
<a name="ln3395">//---------------------------------------------------------</a>
<a name="ln3396">//   flushAlteredTone</a>
<a name="ln3397">//---------------------------------------------------------</a>
<a name="ln3398"> </a>
<a name="ln3399">/**</a>
<a name="ln3400"> If a valid key-step, -alter, -accidental combination has been read,</a>
<a name="ln3401"> convert it to a key symbol and add to the key.</a>
<a name="ln3402"> Clear key-step, -alter, -accidental.</a>
<a name="ln3403"> */</a>
<a name="ln3404"> </a>
<a name="ln3405">static void flushAlteredTone(KeySigEvent&amp; kse, QString&amp; step, QString&amp; alt, QString&amp; acc)</a>
<a name="ln3406">      {</a>
<a name="ln3407">      //qDebug(&quot;flushAlteredTone(step '%s' alt '%s' acc '%s')&quot;,</a>
<a name="ln3408">      //       qPrintable(step), qPrintable(alt), qPrintable(acc));</a>
<a name="ln3409"> </a>
<a name="ln3410">      if (step == &quot;&quot; &amp;&amp; alt == &quot;&quot; &amp;&amp; acc == &quot;&quot;)</a>
<a name="ln3411">            return;  // nothing to do</a>
<a name="ln3412"> </a>
<a name="ln3413">      // step and alt are required, but also accept step and acc</a>
<a name="ln3414">      if (step != &quot;&quot; &amp;&amp; (alt != &quot;&quot; || acc != &quot;&quot;)) {</a>
<a name="ln3415">            addSymToSig(kse, step, alt, acc);</a>
<a name="ln3416">            }</a>
<a name="ln3417">      else {</a>
<a name="ln3418">            qDebug(&quot;flushAlteredTone invalid combination of step '%s' alt '%s' acc '%s')&quot;,</a>
<a name="ln3419">                   qPrintable(step), qPrintable(alt), qPrintable(acc)); // TODO</a>
<a name="ln3420">            }</a>
<a name="ln3421"> </a>
<a name="ln3422">      // clean up</a>
<a name="ln3423">      step = &quot;&quot;;</a>
<a name="ln3424">      alt  = &quot;&quot;;</a>
<a name="ln3425">      acc  = &quot;&quot;;</a>
<a name="ln3426">      }</a>
<a name="ln3427"> </a>
<a name="ln3428">//---------------------------------------------------------</a>
<a name="ln3429">//   key</a>
<a name="ln3430">//---------------------------------------------------------</a>
<a name="ln3431"> </a>
<a name="ln3432">/**</a>
<a name="ln3433"> Parse the /score-partwise/part/measure/attributes/key node.</a>
<a name="ln3434"> */</a>
<a name="ln3435"> </a>
<a name="ln3436">// TODO: check currKeySig handling</a>
<a name="ln3437"> </a>
<a name="ln3438">void MusicXMLParserPass2::key(const QString&amp; partId, Measure* measure, const Fraction&amp; tick)</a>
<a name="ln3439">      {</a>
<a name="ln3440">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;key&quot;);</a>
<a name="ln3441"> </a>
<a name="ln3442">      QString strKeyno = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln3443">      int keyno = -1; // assume no number (see below)</a>
<a name="ln3444">      if (strKeyno != &quot;&quot;) {</a>
<a name="ln3445">            keyno = strKeyno.toInt();</a>
<a name="ln3446">            if (keyno == 0) {</a>
<a name="ln3447">                  // conversion error (0), assume staff 1</a>
<a name="ln3448">                  _logger-&gt;logError(QString(&quot;invalid key number '%1'&quot;).arg(strKeyno), &amp;_e);</a>
<a name="ln3449">                  keyno = 1;</a>
<a name="ln3450">                  }</a>
<a name="ln3451">            // convert to 0-based</a>
<a name="ln3452">            keyno--;</a>
<a name="ln3453">            }</a>
<a name="ln3454">      bool printObject = _e.attributes().value(&quot;print-object&quot;) != &quot;no&quot;;</a>
<a name="ln3455"> </a>
<a name="ln3456">      // for custom keys, a single altered tone is described by</a>
<a name="ln3457">      // key-step (required),  key-alter (required) and key-accidental (optional)</a>
<a name="ln3458">      // none, one or more altered tone may be present</a>
<a name="ln3459">      // a simple state machine is required to detect them</a>
<a name="ln3460">      KeySigEvent key;</a>
<a name="ln3461">      QString keyStep;</a>
<a name="ln3462">      QString keyAlter;</a>
<a name="ln3463">      QString keyAccidental;</a>
<a name="ln3464"> </a>
<a name="ln3465">      while (_e.readNextStartElement()) {</a>
<a name="ln3466">            if (_e.name() == &quot;fifths&quot;)</a>
<a name="ln3467">                  key.setKey(Key(_e.readElementText().toInt()));</a>
<a name="ln3468">            else if (_e.name() == &quot;mode&quot;) {</a>
<a name="ln3469">                  QString m = _e.readElementText();</a>
<a name="ln3470">                  if (m == &quot;none&quot;) {</a>
<a name="ln3471">                        key.setCustom(true);</a>
<a name="ln3472">                        key.setMode(KeyMode::NONE);</a>
<a name="ln3473">                        }</a>
<a name="ln3474">                  else if (m == &quot;major&quot;)</a>
<a name="ln3475">                        key.setMode(KeyMode::MAJOR);</a>
<a name="ln3476">                  else if (m == &quot;minor&quot;)</a>
<a name="ln3477">                        key.setMode(KeyMode::MINOR);</a>
<a name="ln3478">                  else if (m == &quot;dorian&quot;)</a>
<a name="ln3479">                        key.setMode(KeyMode::DORIAN);</a>
<a name="ln3480">                  else if (m == &quot;phrygian&quot;)</a>
<a name="ln3481">                        key.setMode(KeyMode::PHRYGIAN);</a>
<a name="ln3482">                  else if (m == &quot;lydian&quot;)</a>
<a name="ln3483">                        key.setMode(KeyMode::LYDIAN);</a>
<a name="ln3484">                  else if (m == &quot;mixolydian&quot;)</a>
<a name="ln3485">                        key.setMode(KeyMode::MIXOLYDIAN);</a>
<a name="ln3486">                  else if (m == &quot;aeolian&quot;)</a>
<a name="ln3487">                        key.setMode(KeyMode::AEOLIAN);</a>
<a name="ln3488">                  else if (m == &quot;ionian&quot;)</a>
<a name="ln3489">                        key.setMode(KeyMode::IONIAN);</a>
<a name="ln3490">                  else if (m == &quot;locrian&quot;)</a>
<a name="ln3491">                        key.setMode(KeyMode::LOCRIAN);</a>
<a name="ln3492">                  else</a>
<a name="ln3493">                        _logger-&gt;logError(QString(&quot;Unsupported mode '%1'&quot;).arg(m), &amp;_e);</a>
<a name="ln3494">                  }</a>
<a name="ln3495">            else if (_e.name() == &quot;cancel&quot;)</a>
<a name="ln3496">                  skipLogCurrElem();  // TODO ??</a>
<a name="ln3497">            else if (_e.name() == &quot;key-step&quot;) {</a>
<a name="ln3498">                  flushAlteredTone(key, keyStep, keyAlter, keyAccidental);</a>
<a name="ln3499">                  keyStep = _e.readElementText();</a>
<a name="ln3500">                  }</a>
<a name="ln3501">            else if (_e.name() == &quot;key-alter&quot;)</a>
<a name="ln3502">                  keyAlter = _e.readElementText();</a>
<a name="ln3503">            else if (_e.name() == &quot;key-accidental&quot;)</a>
<a name="ln3504">                  keyAccidental = _e.readElementText();</a>
<a name="ln3505">            else</a>
<a name="ln3506">                  skipLogCurrElem();</a>
<a name="ln3507">            }</a>
<a name="ln3508">      flushAlteredTone(key, keyStep, keyAlter, keyAccidental);</a>
<a name="ln3509"> </a>
<a name="ln3510">      int nstaves = _pass1.getPart(partId)-&gt;nstaves();</a>
<a name="ln3511">      int staffIdx = _pass1.trackForPart(partId) / VOICES;</a>
<a name="ln3512">      if (keyno == -1) {</a>
<a name="ln3513">            // apply key to all staves in the part</a>
<a name="ln3514">            for (int i = 0; i &lt; nstaves; ++i) {</a>
<a name="ln3515">                  addKey(key, printObject, _score, measure, staffIdx + i, tick);</a>
<a name="ln3516">                  }</a>
<a name="ln3517">            }</a>
<a name="ln3518">      else if (keyno &lt; nstaves)</a>
<a name="ln3519">            addKey(key, printObject, _score, measure, staffIdx + keyno, tick);</a>
<a name="ln3520">      }</a>
<a name="ln3521"> </a>
<a name="ln3522">//---------------------------------------------------------</a>
<a name="ln3523">//   clef</a>
<a name="ln3524">//---------------------------------------------------------</a>
<a name="ln3525"> </a>
<a name="ln3526">/**</a>
<a name="ln3527"> Parse the /score-partwise/part/measure/attributes/clef node.</a>
<a name="ln3528"> */</a>
<a name="ln3529"> </a>
<a name="ln3530">void MusicXMLParserPass2::clef(const QString&amp; partId, Measure* measure, const Fraction&amp; tick)</a>
<a name="ln3531">      {</a>
<a name="ln3532">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;clef&quot;);</a>
<a name="ln3533"> </a>
<a name="ln3534">      Part* part = _pass1.getPart(partId);</a>
<a name="ln3535">      Q_ASSERT(part);</a>
<a name="ln3536"> </a>
<a name="ln3537">      // TODO: check error handling for</a>
<a name="ln3538">      // - single staff</a>
<a name="ln3539">      // - multi-staff with same clef</a>
<a name="ln3540">      QString strClefno = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln3541">      int clefno = 1; // default</a>
<a name="ln3542">      if (strClefno != &quot;&quot;)</a>
<a name="ln3543">            clefno = strClefno.toInt();</a>
<a name="ln3544">      if (clefno &lt;= 0 || clefno &gt; part-&gt;nstaves()) {</a>
<a name="ln3545">            // conversion error (0) or other issue, assume staff 1</a>
<a name="ln3546">            // Also for Cubase 6.5.5 which generates clef number=&quot;2&quot; in a single staff part</a>
<a name="ln3547">            // Same fix is required in pass 1 and pass 2</a>
<a name="ln3548">            _logger-&gt;logError(QString(&quot;invalid clef number '%1'&quot;).arg(strClefno), &amp;_e);</a>
<a name="ln3549">            clefno = 1;</a>
<a name="ln3550">            }</a>
<a name="ln3551">      // convert to 0-based</a>
<a name="ln3552">      clefno--;</a>
<a name="ln3553"> </a>
<a name="ln3554">      ClefType clef   = ClefType::G;</a>
<a name="ln3555">      StaffTypes st = StaffTypes::STANDARD;</a>
<a name="ln3556"> </a>
<a name="ln3557">      QString c;</a>
<a name="ln3558">      int i = 0;</a>
<a name="ln3559">      int line = -1;</a>
<a name="ln3560"> </a>
<a name="ln3561">      while (_e.readNextStartElement()) {</a>
<a name="ln3562">            if (_e.name() == &quot;sign&quot;)</a>
<a name="ln3563">                  c = _e.readElementText();</a>
<a name="ln3564">            else if (_e.name() == &quot;line&quot;)</a>
<a name="ln3565">                  line = _e.readElementText().toInt();</a>
<a name="ln3566">            else if (_e.name() == &quot;clef-octave-change&quot;) {</a>
<a name="ln3567">                  i = _e.readElementText().toInt();</a>
<a name="ln3568">                  if (i &amp;&amp; !(c == &quot;F&quot; || c == &quot;G&quot;))</a>
<a name="ln3569">                        qDebug(&quot;clef-octave-change only implemented for F and G key&quot;);  // TODO</a>
<a name="ln3570">                  }</a>
<a name="ln3571">            else</a>
<a name="ln3572">                  skipLogCurrElem();</a>
<a name="ln3573">            }</a>
<a name="ln3574"> </a>
<a name="ln3575">      //some software (Primus) don't include line and assume some default</a>
<a name="ln3576">      // it's permitted by MusicXML 2.0 XSD</a>
<a name="ln3577">      if (line == -1) {</a>
<a name="ln3578">            if (c == &quot;G&quot;)</a>
<a name="ln3579">                  line = 2;</a>
<a name="ln3580">            else if (c == &quot;F&quot;)</a>
<a name="ln3581">                  line = 4;</a>
<a name="ln3582">            else if (c == &quot;C&quot;)</a>
<a name="ln3583">                  line = 3;</a>
<a name="ln3584">            }</a>
<a name="ln3585"> </a>
<a name="ln3586">      if (c == &quot;G&quot; &amp;&amp; i == 0 &amp;&amp; line == 2)</a>
<a name="ln3587">            clef = ClefType::G;</a>
<a name="ln3588">      else if (c == &quot;G&quot; &amp;&amp; i == 1 &amp;&amp; line == 2)</a>
<a name="ln3589">            clef = ClefType::G8_VA;</a>
<a name="ln3590">      else if (c == &quot;G&quot; &amp;&amp; i == 2 &amp;&amp; line == 2)</a>
<a name="ln3591">            clef = ClefType::G15_MA;</a>
<a name="ln3592">      else if (c == &quot;G&quot; &amp;&amp; i == -1 &amp;&amp; line == 2)</a>
<a name="ln3593">            clef = ClefType::G8_VB;</a>
<a name="ln3594">      else if (c == &quot;G&quot; &amp;&amp; i == 0 &amp;&amp; line == 1)</a>
<a name="ln3595">            clef = ClefType::G_1;</a>
<a name="ln3596">      else if (c == &quot;F&quot; &amp;&amp; i == 0 &amp;&amp; line == 3)</a>
<a name="ln3597">            clef = ClefType::F_B;</a>
<a name="ln3598">      else if (c == &quot;F&quot; &amp;&amp; i == 0 &amp;&amp; line == 4)</a>
<a name="ln3599">            clef = ClefType::F;</a>
<a name="ln3600">      else if (c == &quot;F&quot; &amp;&amp; i == 1 &amp;&amp; line == 4)</a>
<a name="ln3601">            clef = ClefType::F_8VA;</a>
<a name="ln3602">      else if (c == &quot;F&quot; &amp;&amp; i == 2 &amp;&amp; line == 4)</a>
<a name="ln3603">            clef = ClefType::F_15MA;</a>
<a name="ln3604">      else if (c == &quot;F&quot; &amp;&amp; i == -1 &amp;&amp; line == 4)</a>
<a name="ln3605">            clef = ClefType::F8_VB;</a>
<a name="ln3606">      else if (c == &quot;F&quot; &amp;&amp; i == -2 &amp;&amp; line == 4)</a>
<a name="ln3607">            clef = ClefType::F15_MB;</a>
<a name="ln3608">      else if (c == &quot;F&quot; &amp;&amp; i == 0 &amp;&amp; line == 5)</a>
<a name="ln3609">            clef = ClefType::F_C;</a>
<a name="ln3610">      else if (c == &quot;C&quot;) {</a>
<a name="ln3611">            if (line == 5)</a>
<a name="ln3612">                  clef = ClefType::C5;</a>
<a name="ln3613">            else if (line == 4)</a>
<a name="ln3614">                  clef = ClefType::C4;</a>
<a name="ln3615">            else if (line == 3)</a>
<a name="ln3616">                  clef = ClefType::C3;</a>
<a name="ln3617">            else if (line == 2)</a>
<a name="ln3618">                  clef = ClefType::C2;</a>
<a name="ln3619">            else if (line == 1)</a>
<a name="ln3620">                  clef = ClefType::C1;</a>
<a name="ln3621">            }</a>
<a name="ln3622">      else if (c == &quot;percussion&quot;) {</a>
<a name="ln3623">            clef = ClefType::PERC;</a>
<a name="ln3624">            if (_hasDrumset) {</a>
<a name="ln3625">                  st = StaffTypes::PERC_DEFAULT;</a>
<a name="ln3626">                  }</a>
<a name="ln3627">            }</a>
<a name="ln3628">      else if (c == &quot;TAB&quot;) {</a>
<a name="ln3629">            clef = ClefType::TAB;</a>
<a name="ln3630">            st= StaffTypes::TAB_DEFAULT;</a>
<a name="ln3631">            }</a>
<a name="ln3632">      else</a>
<a name="ln3633">            qDebug(&quot;clef: unknown clef &lt;sign=%s line=%d oct ch=%d&gt;&quot;, qPrintable(c), line, i);  // TODO</a>
<a name="ln3634"> </a>
<a name="ln3635">      Clef* clefs = new Clef(_score);</a>
<a name="ln3636">      clefs-&gt;setClefType(clef);</a>
<a name="ln3637">      int track = _pass1.trackForPart(partId) + clefno * VOICES;</a>
<a name="ln3638">      clefs-&gt;setTrack(track);</a>
<a name="ln3639">      Segment* s = measure-&gt;getSegment(tick.isNotZero() ? SegmentType::Clef : SegmentType::HeaderClef, tick);</a>
<a name="ln3640">      s-&gt;add(clefs);</a>
<a name="ln3641"> </a>
<a name="ln3642">      // set the correct staff type</a>
<a name="ln3643">      // note that clef handling should probably done in pass1</a>
<a name="ln3644">      int staffIdx = _score-&gt;staffIdx(part) + clefno;</a>
<a name="ln3645">      int lines = _score-&gt;staff(staffIdx)-&gt;lines(Fraction(0,1));</a>
<a name="ln3646">      if (tick.isZero()) { // changing staff type not supported (yet ?)</a>
<a name="ln3647">            _score-&gt;staff(staffIdx)-&gt;setStaffType(tick, *StaffType::preset(st));</a>
<a name="ln3648">            _score-&gt;staff(staffIdx)-&gt;setLines(tick, lines); // preserve previously set staff lines</a>
<a name="ln3649">            _score-&gt;staff(staffIdx)-&gt;setBarLineTo(0);    // default</a>
<a name="ln3650">            }</a>
<a name="ln3651">      }</a>
<a name="ln3652"> </a>
<a name="ln3653">//---------------------------------------------------------</a>
<a name="ln3654">//   determineTimeSig</a>
<a name="ln3655">//---------------------------------------------------------</a>
<a name="ln3656"> </a>
<a name="ln3657">/**</a>
<a name="ln3658"> Determine the time signature based on \a beats, \a beatType and \a timeSymbol.</a>
<a name="ln3659"> Sets return parameters \a st, \a bts, \a btp.</a>
<a name="ln3660"> Return true if OK, false on error.</a>
<a name="ln3661"> */</a>
<a name="ln3662"> </a>
<a name="ln3663">// TODO: share between pass 1 and pass 2</a>
<a name="ln3664"> </a>
<a name="ln3665">static bool determineTimeSig(const QString beats, const QString beatType, const QString timeSymbol,</a>
<a name="ln3666">                             TimeSigType&amp; st, int&amp; bts, int&amp; btp)</a>
<a name="ln3667">      {</a>
<a name="ln3668">      // initialize</a>
<a name="ln3669">      st  = TimeSigType::NORMAL;</a>
<a name="ln3670">      bts = 0;       // the beats (max 4 separated by &quot;+&quot;) as integer</a>
<a name="ln3671">      btp = 0;       // beat-type as integer</a>
<a name="ln3672">      // determine if timesig is valid</a>
<a name="ln3673">      if (beats == &quot;2&quot; &amp;&amp; beatType == &quot;2&quot; &amp;&amp; timeSymbol == &quot;cut&quot;) {</a>
<a name="ln3674">            st = TimeSigType::ALLA_BREVE;</a>
<a name="ln3675">            bts = 2;</a>
<a name="ln3676">            btp = 2;</a>
<a name="ln3677">            return true;</a>
<a name="ln3678">            }</a>
<a name="ln3679">      else if (beats == &quot;4&quot; &amp;&amp; beatType == &quot;4&quot; &amp;&amp; timeSymbol == &quot;common&quot;) {</a>
<a name="ln3680">            st = TimeSigType::FOUR_FOUR;</a>
<a name="ln3681">            bts = 4;</a>
<a name="ln3682">            btp = 4;</a>
<a name="ln3683">            return true;</a>
<a name="ln3684">            }</a>
<a name="ln3685">      else {</a>
<a name="ln3686">            if (!timeSymbol.isEmpty() &amp;&amp; timeSymbol != &quot;normal&quot;) {</a>
<a name="ln3687">                  qDebug(&quot;determineTimeSig: time symbol &lt;%s&gt; not recognized with beats=%s and beat-type=%s&quot;,</a>
<a name="ln3688">                         qPrintable(timeSymbol), qPrintable(beats), qPrintable(beatType)); // TODO</a>
<a name="ln3689">                  return false;</a>
<a name="ln3690">                  }</a>
<a name="ln3691"> </a>
<a name="ln3692">            btp = beatType.toInt();</a>
<a name="ln3693">            QStringList list = beats.split(&quot;+&quot;);</a>
<a name="ln3694">            for (int i = 0; i &lt; list.size(); i++)</a>
<a name="ln3695">                  bts += list.at(i).toInt();</a>
<a name="ln3696">            }</a>
<a name="ln3697"> </a>
<a name="ln3698">      // determine if bts and btp are valid</a>
<a name="ln3699">      if (bts &lt;= 0 || btp &lt;=0) {</a>
<a name="ln3700">            qDebug(&quot;determineTimeSig: beats=%s and/or beat-type=%s not recognized&quot;,</a>
<a name="ln3701">                   qPrintable(beats), qPrintable(beatType));         // TODO</a>
<a name="ln3702">            return false;</a>
<a name="ln3703">            }</a>
<a name="ln3704"> </a>
<a name="ln3705">      return true;</a>
<a name="ln3706">      }</a>
<a name="ln3707"> </a>
<a name="ln3708">//---------------------------------------------------------</a>
<a name="ln3709">//   time</a>
<a name="ln3710">//---------------------------------------------------------</a>
<a name="ln3711"> </a>
<a name="ln3712">/**</a>
<a name="ln3713"> Parse the /score-partwise/part/measure/attributes/time node.</a>
<a name="ln3714"> */</a>
<a name="ln3715"> </a>
<a name="ln3716">void MusicXMLParserPass2::time(const QString&amp; partId, Measure* measure, const Fraction&amp; tick)</a>
<a name="ln3717">      {</a>
<a name="ln3718">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;time&quot;);</a>
<a name="ln3719"> </a>
<a name="ln3720">      QString beats;</a>
<a name="ln3721">      QString beatType;</a>
<a name="ln3722">      QString timeSymbol = _e.attributes().value(&quot;symbol&quot;).toString();</a>
<a name="ln3723">      bool printObject = _e.attributes().value(&quot;print-object&quot;) != &quot;no&quot;;</a>
<a name="ln3724"> </a>
<a name="ln3725">      while (_e.readNextStartElement()) {</a>
<a name="ln3726">            if (_e.name() == &quot;beats&quot;)</a>
<a name="ln3727">                  beats = _e.readElementText();</a>
<a name="ln3728">            else if (_e.name() == &quot;beat-type&quot;)</a>
<a name="ln3729">                  beatType = _e.readElementText();</a>
<a name="ln3730">            else</a>
<a name="ln3731">                  skipLogCurrElem();</a>
<a name="ln3732">            }</a>
<a name="ln3733"> </a>
<a name="ln3734">      if (beats != &quot;&quot; &amp;&amp; beatType != &quot;&quot;) {</a>
<a name="ln3735">            // determine if timesig is valid</a>
<a name="ln3736">            TimeSigType st  = TimeSigType::NORMAL;</a>
<a name="ln3737">            int bts = 0; // total beats as integer (beats may contain multiple numbers, separated by &quot;+&quot;)</a>
<a name="ln3738">            int btp = 0; // beat-type as integer</a>
<a name="ln3739">            if (determineTimeSig(beats, beatType, timeSymbol, st, bts, btp)) {</a>
<a name="ln3740">                  _timeSigDura = Fraction(bts, btp);</a>
<a name="ln3741">                  Fraction fractionTSig = Fraction(bts, btp);</a>
<a name="ln3742">                  for (int i = 0; i &lt; _pass1.getPart(partId)-&gt;nstaves(); ++i) {</a>
<a name="ln3743">                        TimeSig* timesig = new TimeSig(_score);</a>
<a name="ln3744">                        timesig-&gt;setVisible(printObject);</a>
<a name="ln3745">                        int track = _pass1.trackForPart(partId) + i * VOICES;</a>
<a name="ln3746">                        timesig-&gt;setTrack(track);</a>
<a name="ln3747">                        timesig-&gt;setSig(fractionTSig, st);</a>
<a name="ln3748">                        // handle simple compound time signature</a>
<a name="ln3749">                        if (beats.contains(QChar('+'))) {</a>
<a name="ln3750">                              timesig-&gt;setNumeratorString(beats);</a>
<a name="ln3751">                              timesig-&gt;setDenominatorString(beatType);</a>
<a name="ln3752">                              }</a>
<a name="ln3753">                        Segment* s = measure-&gt;getSegment(SegmentType::TimeSig, tick);</a>
<a name="ln3754">                        s-&gt;add(timesig);</a>
<a name="ln3755">                        }</a>
<a name="ln3756">                  }</a>
<a name="ln3757">            }</a>
<a name="ln3758">      }</a>
<a name="ln3759"> </a>
<a name="ln3760">//---------------------------------------------------------</a>
<a name="ln3761">//   transpose</a>
<a name="ln3762">//---------------------------------------------------------</a>
<a name="ln3763"> </a>
<a name="ln3764">/**</a>
<a name="ln3765"> Parse the /score-partwise/part/measure/attributes/transpose node.</a>
<a name="ln3766"> */</a>
<a name="ln3767"> </a>
<a name="ln3768">void MusicXMLParserPass2::transpose(const QString&amp; partId)</a>
<a name="ln3769">      {</a>
<a name="ln3770">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;transpose&quot;);</a>
<a name="ln3771"> </a>
<a name="ln3772">      Interval interval;</a>
<a name="ln3773">      bool diatonic = false;</a>
<a name="ln3774">      bool chromatic = false;</a>
<a name="ln3775">      while (_e.readNextStartElement()) {</a>
<a name="ln3776">            int i = _e.readElementText().toInt();</a>
<a name="ln3777">            if (_e.name() == &quot;diatonic&quot;) {</a>
<a name="ln3778">                  interval.diatonic = i;</a>
<a name="ln3779">                  diatonic = true;</a>
<a name="ln3780">                  }</a>
<a name="ln3781">            else if (_e.name() == &quot;chromatic&quot;) {</a>
<a name="ln3782">                  interval.chromatic = i;</a>
<a name="ln3783">                  chromatic = true;</a>
<a name="ln3784">                  }</a>
<a name="ln3785">            else if (_e.name() == &quot;octave-change&quot;) {</a>
<a name="ln3786">                  interval.diatonic += i * 7;</a>
<a name="ln3787">                  interval.chromatic += i * 12;</a>
<a name="ln3788">                  }</a>
<a name="ln3789">            else</a>
<a name="ln3790">                  skipLogCurrElem();</a>
<a name="ln3791">            }</a>
<a name="ln3792"> </a>
<a name="ln3793">      if (chromatic &amp;&amp; !diatonic)</a>
<a name="ln3794">            interval.diatonic += chromatic2diatonic(interval.chromatic);</a>
<a name="ln3795"> </a>
<a name="ln3796">      _pass1.getPart(partId)-&gt;instrument()-&gt;setTranspose(interval);</a>
<a name="ln3797">      }</a>
<a name="ln3798"> </a>
<a name="ln3799">//---------------------------------------------------------</a>
<a name="ln3800">//   divisions</a>
<a name="ln3801">//---------------------------------------------------------</a>
<a name="ln3802"> </a>
<a name="ln3803">/**</a>
<a name="ln3804"> Parse the /score-partwise/part/measure/attributes/divisions node.</a>
<a name="ln3805"> */</a>
<a name="ln3806"> </a>
<a name="ln3807">void MusicXMLParserPass2::divisions()</a>
<a name="ln3808">      {</a>
<a name="ln3809">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;divisions&quot;);</a>
<a name="ln3810"> </a>
<a name="ln3811">      _divs = _e.readElementText().toInt();</a>
<a name="ln3812">      if (!(_divs &gt; 0))</a>
<a name="ln3813">            _logger-&gt;logError(&quot;illegal divisions&quot;, &amp;_e);</a>
<a name="ln3814">      }</a>
<a name="ln3815"> </a>
<a name="ln3816">//---------------------------------------------------------</a>
<a name="ln3817">//   isWholeMeasureRest</a>
<a name="ln3818">//---------------------------------------------------------</a>
<a name="ln3819"> </a>
<a name="ln3820">/**</a>
<a name="ln3821"> * Determine whole measure rest.</a>
<a name="ln3822"> */</a>
<a name="ln3823"> </a>
<a name="ln3824">// By convention, whole measure rests do not have a &quot;type&quot; element</a>
<a name="ln3825">// As of MusicXML 3.0, this can be indicated by an attribute &quot;measure&quot;,</a>
<a name="ln3826">// but for backwards compatibility the &quot;old&quot; convention still has to be supported.</a>
<a name="ln3827">// Also verify the rest fits exactly in the measure, as some programs</a>
<a name="ln3828">// (e.g. Cakewalk SONAR X2 Studio [Version: 19.0.0.306]) leave out</a>
<a name="ln3829">// the type for all rests.</a>
<a name="ln3830">// Sibelius calls all whole-measure rests &quot;whole&quot;, even if the duration != 4/4</a>
<a name="ln3831"> </a>
<a name="ln3832">static bool isWholeMeasureRest(const bool rest, const QString&amp; type, const Fraction dura, const Fraction mDura)</a>
<a name="ln3833">      {</a>
<a name="ln3834">      if (!rest)</a>
<a name="ln3835">            return false;</a>
<a name="ln3836"> </a>
<a name="ln3837">      if (!dura.isValid())</a>
<a name="ln3838">            return false;</a>
<a name="ln3839"> </a>
<a name="ln3840">      if (!mDura.isValid())</a>
<a name="ln3841">            return false;</a>
<a name="ln3842"> </a>
<a name="ln3843">      return ((type == &quot;&quot; &amp;&amp; dura == mDura)</a>
<a name="ln3844">              || (type == &quot;whole&quot; &amp;&amp; dura == mDura &amp;&amp; dura != Fraction(1, 1)));</a>
<a name="ln3845">      }</a>
<a name="ln3846"> </a>
<a name="ln3847">//---------------------------------------------------------</a>
<a name="ln3848">//   determineDuration</a>
<a name="ln3849">//---------------------------------------------------------</a>
<a name="ln3850"> </a>
<a name="ln3851">/**</a>
<a name="ln3852"> * Determine duration for a note or rest.</a>
<a name="ln3853"> * This includes whole measure rest detection.</a>
<a name="ln3854"> */</a>
<a name="ln3855"> </a>
<a name="ln3856">static TDuration determineDuration(const bool rest, const QString&amp; type, const int dots, const Fraction dura, const Fraction mDura)</a>
<a name="ln3857">      {</a>
<a name="ln3858">      //qDebug(&quot;determineDuration rest %d type '%s' dots %d dura %s mDura %s&quot;,</a>
<a name="ln3859">      //       rest, qPrintable(type), dots, qPrintable(dura.print()), qPrintable(mDura.print()));</a>
<a name="ln3860"> </a>
<a name="ln3861">      TDuration res;</a>
<a name="ln3862">      if (rest) {</a>
<a name="ln3863">            if (isWholeMeasureRest(rest, type, dura, mDura))</a>
<a name="ln3864">                  res.setType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln3865">            else if (type == &quot;&quot;) {</a>
<a name="ln3866">                  // If no type, set duration type based on duration.</a>
<a name="ln3867">                  // Note that sometimes unusual duration (e.g. 261/256) are found.</a>
<a name="ln3868">                  res.setVal(dura.ticks());</a>
<a name="ln3869">                  }</a>
<a name="ln3870">            else {</a>
<a name="ln3871">                  res.setType(type);</a>
<a name="ln3872">                  res.setDots(dots);</a>
<a name="ln3873">                  }</a>
<a name="ln3874">            }</a>
<a name="ln3875">      else {</a>
<a name="ln3876">            res.setType(type);</a>
<a name="ln3877">            res.setDots(dots);</a>
<a name="ln3878">            if (res.type() == TDuration::DurationType::V_INVALID)</a>
<a name="ln3879">                  res.setType(TDuration::DurationType::V_QUARTER);  // default, TODO: use dura ?</a>
<a name="ln3880">            }</a>
<a name="ln3881"> </a>
<a name="ln3882">      //qDebug(&quot;-&gt; dur %hhd (%s) dots %d ticks %s&quot;,</a>
<a name="ln3883">      //       res.type(), qPrintable(res.name()), res.dots(), qPrintable(dura.print()));</a>
<a name="ln3884"> </a>
<a name="ln3885">      return res;</a>
<a name="ln3886">      }</a>
<a name="ln3887"> </a>
<a name="ln3888">//---------------------------------------------------------</a>
<a name="ln3889">//   findOrCreateChord</a>
<a name="ln3890">//---------------------------------------------------------</a>
<a name="ln3891"> </a>
<a name="ln3892">/**</a>
<a name="ln3893"> * Find (or create if not found) the chord at \a tick and \a track.</a>
<a name="ln3894"> * Note: staff move is a note property in MusicXML, but chord property in MuseScore</a>
<a name="ln3895"> * This is simply ignored here, effectively using the last chords value.</a>
<a name="ln3896"> */</a>
<a name="ln3897"> </a>
<a name="ln3898">static Chord* findOrCreateChord(Score* score, Measure* m,</a>
<a name="ln3899">                                const Fraction&amp; tick, const int track, const int move,</a>
<a name="ln3900">                                const TDuration duration, const Fraction dura,</a>
<a name="ln3901">                                Beam::Mode bm)</a>
<a name="ln3902">      {</a>
<a name="ln3903">      //qDebug(&quot;findOrCreateChord tick %d track %d dur ticks %d ticks %s bm %hhd&quot;,</a>
<a name="ln3904">      //       tick, track, duration.ticks(), qPrintable(dura.print()), bm);</a>
<a name="ln3905">      Chord* c = m-&gt;findChord(tick, track);</a>
<a name="ln3906">      if (c == 0) {</a>
<a name="ln3907">            c = new Chord(score);</a>
<a name="ln3908">            // better not to force beam end, as the beam palette does not support it</a>
<a name="ln3909">            if (bm == Beam::Mode::END)</a>
<a name="ln3910">                  c-&gt;setBeamMode(Beam::Mode::AUTO);</a>
<a name="ln3911">            else</a>
<a name="ln3912">                  c-&gt;setBeamMode(bm);</a>
<a name="ln3913">            c-&gt;setTrack(track);</a>
<a name="ln3914"> </a>
<a name="ln3915">            setChordRestDuration(c, duration, dura);</a>
<a name="ln3916">            Segment* s = m-&gt;getSegment(SegmentType::ChordRest, tick);</a>
<a name="ln3917">            s-&gt;add(c);</a>
<a name="ln3918">            }</a>
<a name="ln3919">      c-&gt;setStaffMove(move);</a>
<a name="ln3920">      return c;</a>
<a name="ln3921">      }</a>
<a name="ln3922"> </a>
<a name="ln3923">//---------------------------------------------------------</a>
<a name="ln3924">//   graceNoteType</a>
<a name="ln3925">//---------------------------------------------------------</a>
<a name="ln3926"> </a>
<a name="ln3927">/**</a>
<a name="ln3928"> * convert duration and slash to grace note type</a>
<a name="ln3929"> */</a>
<a name="ln3930"> </a>
<a name="ln3931">NoteType graceNoteType(const TDuration duration, const bool slash)</a>
<a name="ln3932">      {</a>
<a name="ln3933">      NoteType nt = NoteType::APPOGGIATURA;</a>
<a name="ln3934">      if (slash)</a>
<a name="ln3935">            nt = NoteType::ACCIACCATURA;</a>
<a name="ln3936">      if (duration.type() == TDuration::DurationType::V_QUARTER) {</a>
<a name="ln3937">            nt = NoteType::GRACE4;</a>
<a name="ln3938">            }</a>
<a name="ln3939">      else if (duration.type() == TDuration::DurationType::V_16TH) {</a>
<a name="ln3940">            nt = NoteType::GRACE16;</a>
<a name="ln3941">            }</a>
<a name="ln3942">      else if (duration.type() == TDuration::DurationType::V_32ND) {</a>
<a name="ln3943">            nt = NoteType::GRACE32;</a>
<a name="ln3944">            }</a>
<a name="ln3945">      return nt;</a>
<a name="ln3946">      }</a>
<a name="ln3947"> </a>
<a name="ln3948">//---------------------------------------------------------</a>
<a name="ln3949">//   createGraceChord</a>
<a name="ln3950">//---------------------------------------------------------</a>
<a name="ln3951"> </a>
<a name="ln3952">/**</a>
<a name="ln3953"> * Create a grace chord.</a>
<a name="ln3954"> */</a>
<a name="ln3955"> </a>
<a name="ln3956">static Chord* createGraceChord(Score* score, const int track,</a>
<a name="ln3957">                               const TDuration duration, const bool slash)</a>
<a name="ln3958">      {</a>
<a name="ln3959">      Chord* c = new Chord(score);</a>
<a name="ln3960">      c-&gt;setNoteType(graceNoteType(duration, slash));</a>
<a name="ln3961">      c-&gt;setTrack(track);</a>
<a name="ln3962">      // note grace notes have no durations, use default fraction 0/1</a>
<a name="ln3963">      setChordRestDuration(c, duration, Fraction());</a>
<a name="ln3964">      return c;</a>
<a name="ln3965">      }</a>
<a name="ln3966"> </a>
<a name="ln3967">//---------------------------------------------------------</a>
<a name="ln3968">//   handleDisplayStep</a>
<a name="ln3969">//---------------------------------------------------------</a>
<a name="ln3970"> </a>
<a name="ln3971">/**</a>
<a name="ln3972"> * convert display-step and display-octave to staff line</a>
<a name="ln3973"> */</a>
<a name="ln3974"> </a>
<a name="ln3975">static void handleDisplayStep(ChordRest* cr, int step, int octave, const Fraction&amp; tick, qreal spatium)</a>
<a name="ln3976">      {</a>
<a name="ln3977">      if (0 &lt;= step &amp;&amp; step &lt;= 6 &amp;&amp; 0 &lt;= octave &amp;&amp; octave &lt;= 9) {</a>
<a name="ln3978">            //qDebug(&quot;rest step=%d oct=%d&quot;, step, octave);</a>
<a name="ln3979">            ClefType clef = cr-&gt;staff()-&gt;clef(tick);</a>
<a name="ln3980">            int po = ClefInfo::pitchOffset(clef);</a>
<a name="ln3981">            //qDebug(&quot; clef=%hhd po=%d step=%d&quot;, clef, po, step);</a>
<a name="ln3982">            int dp = 7 * (octave + 2) + step;</a>
<a name="ln3983">            //qDebug(&quot; dp=%d po-dp=%d&quot;, dp, po-dp);</a>
<a name="ln3984">            cr-&gt;ryoffset() = (po - dp + 3) * spatium / 2;</a>
<a name="ln3985">            }</a>
<a name="ln3986">      }</a>
<a name="ln3987"> </a>
<a name="ln3988">//---------------------------------------------------------</a>
<a name="ln3989">//   setNoteHead</a>
<a name="ln3990">//---------------------------------------------------------</a>
<a name="ln3991"> </a>
<a name="ln3992">/**</a>
<a name="ln3993"> Set the notehead parameters.</a>
<a name="ln3994"> */</a>
<a name="ln3995"> </a>
<a name="ln3996">static void setNoteHead(Note* note, const QColor noteheadColor, const bool noteheadParentheses, const QString&amp; noteheadFilled)</a>
<a name="ln3997">      {</a>
<a name="ln3998">      const auto score = note-&gt;score();</a>
<a name="ln3999"> </a>
<a name="ln4000">      if (noteheadColor != QColor::Invalid)</a>
<a name="ln4001">            note-&gt;setColor(noteheadColor);</a>
<a name="ln4002">      if (noteheadParentheses) {</a>
<a name="ln4003">            auto s = new Symbol(score);</a>
<a name="ln4004">            s-&gt;setSym(SymId::noteheadParenthesisLeft);</a>
<a name="ln4005">            s-&gt;setParent(note);</a>
<a name="ln4006">            score-&gt;addElement(s);</a>
<a name="ln4007">            s = new Symbol(score);</a>
<a name="ln4008">            s-&gt;setSym(SymId::noteheadParenthesisRight);</a>
<a name="ln4009">            s-&gt;setParent(note);</a>
<a name="ln4010">            score-&gt;addElement(s);</a>
<a name="ln4011">            }</a>
<a name="ln4012"> </a>
<a name="ln4013">      if (noteheadFilled == &quot;no&quot;)</a>
<a name="ln4014">            note-&gt;setHeadType(NoteHead::Type::HEAD_HALF);</a>
<a name="ln4015">      else if (noteheadFilled == &quot;yes&quot;)</a>
<a name="ln4016">            note-&gt;setHeadType(NoteHead::Type::HEAD_QUARTER);</a>
<a name="ln4017">      }</a>
<a name="ln4018"> </a>
<a name="ln4019">//---------------------------------------------------------</a>
<a name="ln4020">//   addFiguredBassElemens</a>
<a name="ln4021">//---------------------------------------------------------</a>
<a name="ln4022"> </a>
<a name="ln4023">/**</a>
<a name="ln4024"> Add the figured bass elements.</a>
<a name="ln4025"> */</a>
<a name="ln4026"> </a>
<a name="ln4027">static void addFiguredBassElemens(FiguredBassList&amp; fbl, const Fraction noteStartTime, const int msTrack,</a>
<a name="ln4028">                                  const Fraction dura, Measure* measure)</a>
<a name="ln4029">      {</a>
<a name="ln4030">      if (!fbl.isEmpty()) {</a>
<a name="ln4031">            auto sTick = noteStartTime;              // starting tick</a>
<a name="ln4032">            foreach (FiguredBass* fb, fbl) {</a>
<a name="ln4033">                  fb-&gt;setTrack(msTrack);</a>
<a name="ln4034">                  // No duration tag defaults ticks() to 0; set to note value</a>
<a name="ln4035">                  if (fb-&gt;ticks().isZero())</a>
<a name="ln4036">                        fb-&gt;setTicks(dura);</a>
<a name="ln4037">                  // TODO: set correct onNote value</a>
<a name="ln4038">                  Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, sTick);</a>
<a name="ln4039">                  s-&gt;add(fb);</a>
<a name="ln4040">                  sTick += fb-&gt;ticks();</a>
<a name="ln4041">                  }</a>
<a name="ln4042">            fbl.clear();</a>
<a name="ln4043">            }</a>
<a name="ln4044">      }</a>
<a name="ln4045"> </a>
<a name="ln4046">//---------------------------------------------------------</a>
<a name="ln4047">//   addTremolo</a>
<a name="ln4048">//---------------------------------------------------------</a>
<a name="ln4049"> </a>
<a name="ln4050">static void addTremolo(ChordRest* cr,</a>
<a name="ln4051">                       const int tremoloNr, const QString&amp; tremoloType,</a>
<a name="ln4052">                       Chord*&amp; tremStart,</a>
<a name="ln4053">                       MxmlLogger* logger, const QXmlStreamReader* const xmlreader)</a>
<a name="ln4054">      {</a>
<a name="ln4055">      if (!cr-&gt;isChord())</a>
<a name="ln4056">            return;</a>
<a name="ln4057">      if (tremoloNr) {</a>
<a name="ln4058">            //qDebug(&quot;tremolo %d type '%s' ticks %d tremStart %p&quot;, tremoloNr, qPrintable(tremoloType), ticks, _tremStart);</a>
<a name="ln4059">            if (tremoloNr == 1 || tremoloNr == 2 || tremoloNr == 3 || tremoloNr == 4) {</a>
<a name="ln4060">                  if (tremoloType == &quot;&quot; || tremoloType == &quot;single&quot;) {</a>
<a name="ln4061">                        const auto tremolo = new Tremolo(cr-&gt;score());</a>
<a name="ln4062">                        switch (tremoloNr) {</a>
<a name="ln4063">                              case 1: tremolo-&gt;setTremoloType(TremoloType::R8); break;</a>
<a name="ln4064">                              case 2: tremolo-&gt;setTremoloType(TremoloType::R16); break;</a>
<a name="ln4065">                              case 3: tremolo-&gt;setTremoloType(TremoloType::R32); break;</a>
<a name="ln4066">                              case 4: tremolo-&gt;setTremoloType(TremoloType::R64); break;</a>
<a name="ln4067">                              }</a>
<a name="ln4068">                        cr-&gt;add(tremolo);</a>
<a name="ln4069">                        }</a>
<a name="ln4070">                  else if (tremoloType == &quot;start&quot;) {</a>
<a name="ln4071">                        if (tremStart) logger-&gt;logError(&quot;MusicXML::import: double tremolo start&quot;, xmlreader);</a>
<a name="ln4072">                        tremStart = static_cast&lt;Chord*&gt;(cr);</a>
<a name="ln4073">                        }</a>
<a name="ln4074">                  else if (tremoloType == &quot;stop&quot;) {</a>
<a name="ln4075">                        if (tremStart) {</a>
<a name="ln4076">                              const auto tremolo = new Tremolo(cr-&gt;score());</a>
<a name="ln4077">                              switch (tremoloNr) {</a>
<a name="ln4078">                                    case 1: tremolo-&gt;setTremoloType(TremoloType::C8); break;</a>
<a name="ln4079">                                    case 2: tremolo-&gt;setTremoloType(TremoloType::C16); break;</a>
<a name="ln4080">                                    case 3: tremolo-&gt;setTremoloType(TremoloType::C32); break;</a>
<a name="ln4081">                                    case 4: tremolo-&gt;setTremoloType(TremoloType::C64); break;</a>
<a name="ln4082">                                    }</a>
<a name="ln4083">                              tremolo-&gt;setChords(tremStart, static_cast&lt;Chord*&gt;(cr));</a>
<a name="ln4084">                              // fixup chord duration and type</a>
<a name="ln4085">                              const Fraction tremDur = cr-&gt;ticks() * Fraction(1,2);</a>
<a name="ln4086">                              tremolo-&gt;chord1()-&gt;setDurationType(tremDur);</a>
<a name="ln4087">                              tremolo-&gt;chord1()-&gt;setTicks(tremDur);</a>
<a name="ln4088">                              tremolo-&gt;chord2()-&gt;setDurationType(tremDur);</a>
<a name="ln4089">                              tremolo-&gt;chord2()-&gt;setTicks(tremDur);</a>
<a name="ln4090">                              // add tremolo to first chord (only)</a>
<a name="ln4091">                              tremStart-&gt;add(tremolo);</a>
<a name="ln4092">                              }</a>
<a name="ln4093">                        else logger-&gt;logError(&quot;MusicXML::import: double tremolo stop w/o start&quot;, xmlreader);</a>
<a name="ln4094">                        tremStart = nullptr;</a>
<a name="ln4095">                        }</a>
<a name="ln4096">                  }</a>
<a name="ln4097">            else</a>
<a name="ln4098">                  logger-&gt;logError(QString(&quot;unknown tremolo type %1&quot;).arg(tremoloNr), xmlreader);</a>
<a name="ln4099">            }</a>
<a name="ln4100">      }</a>
<a name="ln4101"> </a>
<a name="ln4102">//---------------------------------------------------------</a>
<a name="ln4103">//   setPitch</a>
<a name="ln4104">//---------------------------------------------------------</a>
<a name="ln4105"> </a>
<a name="ln4106">static void setPitch(Note* note, MusicXMLParserPass1&amp; pass1, const QString&amp; partId, const QString&amp; instrumentId, const mxmlNotePitch&amp; mnp, const int octaveShift)</a>
<a name="ln4107">      {</a>
<a name="ln4108">      const auto&amp; mxmlDrumset = pass1.getDrumset(partId);</a>
<a name="ln4109">      if (mnp.unpitched()) {</a>
<a name="ln4110">            if (hasDrumset(mxmlDrumset)</a>
<a name="ln4111">                &amp;&amp; mxmlDrumset.contains(instrumentId)) {</a>
<a name="ln4112">                  // step and oct are display-step and ...-oct</a>
<a name="ln4113">                  // get pitch from instrument definition in drumset instead</a>
<a name="ln4114">                  int pitch = mxmlDrumset[instrumentId].pitch;</a>
<a name="ln4115">                  note-&gt;setPitch(limit(pitch, 0, 127));</a>
<a name="ln4116">                  // TODO - does this need to be key-aware?</a>
<a name="ln4117">                  note-&gt;setTpc(pitch2tpc(pitch, Key::C, Prefer::NEAREST));       // TODO: necessary ?</a>
<a name="ln4118">                  }</a>
<a name="ln4119">            else {</a>
<a name="ln4120">                  //qDebug(&quot;disp step %d oct %d&quot;, displayStep, displayOctave);</a>
<a name="ln4121">                  xmlSetPitch(note, mnp.displayStep(), 0, mnp.displayOctave(), 0, pass1.getPart(partId)-&gt;instrument());</a>
<a name="ln4122">                  }</a>
<a name="ln4123">            }</a>
<a name="ln4124">      else {</a>
<a name="ln4125">            xmlSetPitch(note, mnp.step(), mnp.alter(), mnp.octave(), octaveShift, pass1.getPart(partId)-&gt;instrument());</a>
<a name="ln4126">            }</a>
<a name="ln4127">      }</a>
<a name="ln4128"> </a>
<a name="ln4129">//---------------------------------------------------------</a>
<a name="ln4130">//   setDrumset</a>
<a name="ln4131">//---------------------------------------------------------</a>
<a name="ln4132"> </a>
<a name="ln4133">// set drumset information</a>
<a name="ln4134">// note that in MuseScore, the drumset contains defaults for notehead,</a>
<a name="ln4135">// line and stem direction, while a MusicXML file contains actuals.</a>
<a name="ln4136">// the MusicXML values for each note are simply copied to the defaults</a>
<a name="ln4137"> </a>
<a name="ln4138">static void setDrumset(Chord* c, MusicXMLParserPass1&amp; pass1, const QString&amp; partId, const QString&amp; instrumentId,</a>
<a name="ln4139">                       const Fraction noteStartTime, const mxmlNotePitch&amp; mnp, const Direction stemDir, const NoteHead::Group headGroup)</a>
<a name="ln4140">      {</a>
<a name="ln4141">      // determine staff line based on display-step / -octave and clef type</a>
<a name="ln4142">      const auto clef = c-&gt;staff()-&gt;clef(noteStartTime);</a>
<a name="ln4143">      const auto po = ClefInfo::pitchOffset(clef);</a>
<a name="ln4144">      const auto pitch = MusicXMLStepAltOct2Pitch(mnp.displayStep(), 0, mnp.displayOctave());</a>
<a name="ln4145">      auto line = po - absStep(pitch);</a>
<a name="ln4146"> </a>
<a name="ln4147">      // correct for number of staff lines</a>
<a name="ln4148">      // see ExportMusicXml::unpitch2xml for explanation</a>
<a name="ln4149">      // TODO handle other # staff lines ?</a>
<a name="ln4150">      int staffLines = c-&gt;staff()-&gt;lines(Fraction(0,1));</a>
<a name="ln4151">      if (staffLines == 1) line -= 8;</a>
<a name="ln4152">      if (staffLines == 3) line -= 2;</a>
<a name="ln4153"> </a>
<a name="ln4154">      // the drum palette cannot handle stem direction AUTO,</a>
<a name="ln4155">      // overrule if necessary</a>
<a name="ln4156">      Direction overruledStemDir = stemDir;</a>
<a name="ln4157">      if (stemDir == Direction::AUTO) {</a>
<a name="ln4158">            if (line &gt; 4)</a>
<a name="ln4159">                  overruledStemDir = Direction::DOWN;</a>
<a name="ln4160">            else</a>
<a name="ln4161">                  overruledStemDir = Direction::UP;</a>
<a name="ln4162">            }</a>
<a name="ln4163">      // this should be done in pass 1, would make _pass1 const here</a>
<a name="ln4164">      pass1.setDrumsetDefault(partId, instrumentId, headGroup, line, overruledStemDir);</a>
<a name="ln4165">      }</a>
<a name="ln4166"> </a>
<a name="ln4167">//---------------------------------------------------------</a>
<a name="ln4168">//   note</a>
<a name="ln4169">//---------------------------------------------------------</a>
<a name="ln4170"> </a>
<a name="ln4171">/**</a>
<a name="ln4172"> Parse the /score-partwise/part/measure/note node.</a>
<a name="ln4173"> */</a>
<a name="ln4174"> </a>
<a name="ln4175">Note* MusicXMLParserPass2::note(const QString&amp; partId,</a>
<a name="ln4176">                                Measure* measure,</a>
<a name="ln4177">                                const Fraction sTime,</a>
<a name="ln4178">                                const Fraction prevSTime,</a>
<a name="ln4179">                                Fraction&amp; missingPrev,</a>
<a name="ln4180">                                Fraction&amp; dura,</a>
<a name="ln4181">                                Fraction&amp; missingCurr,</a>
<a name="ln4182">                                QString&amp; currentVoice,</a>
<a name="ln4183">                                GraceChordList&amp; gcl,</a>
<a name="ln4184">                                int&amp; gac,</a>
<a name="ln4185">                                Beam*&amp; currBeam,</a>
<a name="ln4186">                                FiguredBassList&amp; fbl,</a>
<a name="ln4187">                                int&amp; alt,</a>
<a name="ln4188">                                MxmlTupletStates&amp; tupletStates,</a>
<a name="ln4189">                                Tuplets&amp; tuplets</a>
<a name="ln4190">                                )</a>
<a name="ln4191">      {</a>
<a name="ln4192">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln4193"> </a>
<a name="ln4194">      if (_e.attributes().value(&quot;print-spacing&quot;) == &quot;no&quot;) {</a>
<a name="ln4195">            notePrintSpacingNo(dura);</a>
<a name="ln4196">            return 0;</a>
<a name="ln4197">            }</a>
<a name="ln4198"> </a>
<a name="ln4199">      bool chord = false;</a>
<a name="ln4200">      bool cue = false;</a>
<a name="ln4201">      bool small = false;</a>
<a name="ln4202">      bool grace = false;</a>
<a name="ln4203">      bool rest = false;</a>
<a name="ln4204">      int staff = 1;</a>
<a name="ln4205">      QString type;</a>
<a name="ln4206">      QString voice;</a>
<a name="ln4207">      Direction stemDir = Direction::AUTO;</a>
<a name="ln4208">      bool noStem = false;</a>
<a name="ln4209">      NoteHead::Group headGroup = NoteHead::Group::HEAD_NORMAL;</a>
<a name="ln4210">      QColor noteColor = QColor::Invalid;</a>
<a name="ln4211">      noteColor.setNamedColor(_e.attributes().value(&quot;color&quot;).toString());</a>
<a name="ln4212">      QColor noteheadColor = QColor::Invalid;</a>
<a name="ln4213">      bool noteheadParentheses = false;</a>
<a name="ln4214">      QString noteheadFilled;</a>
<a name="ln4215">      int velocity = round(_e.attributes().value(&quot;dynamics&quot;).toDouble() * 0.9);</a>
<a name="ln4216">      bool graceSlash = false;</a>
<a name="ln4217">      bool printObject = _e.attributes().value(&quot;print-object&quot;) != &quot;no&quot;;</a>
<a name="ln4218">      Beam::Mode bm  = Beam::Mode::AUTO;</a>
<a name="ln4219">      QString instrumentId;</a>
<a name="ln4220">      MusicXMLParserLyric lyric { _pass1.getMusicXmlPart(partId).lyricNumberHandler(), _e, _score, _logger };</a>
<a name="ln4221">      MusicXMLParserNotations notations { _e, _score, _logger };</a>
<a name="ln4222"> </a>
<a name="ln4223">      mxmlNoteDuration mnd { _divs, _logger };</a>
<a name="ln4224">      mxmlNotePitch mnp { _logger };</a>
<a name="ln4225"> </a>
<a name="ln4226">      while (_e.readNextStartElement()) {</a>
<a name="ln4227">            if (mnp.readProperties(_e, _score)) {</a>
<a name="ln4228">                  // element handled</a>
<a name="ln4229">                  }</a>
<a name="ln4230">            else if (mnd.readProperties(_e)) {</a>
<a name="ln4231">                  // element handled</a>
<a name="ln4232">                  }</a>
<a name="ln4233">            else if (_e.name() == &quot;beam&quot;)</a>
<a name="ln4234">                  beam(bm);</a>
<a name="ln4235">            else if (_e.name() == &quot;chord&quot;) {</a>
<a name="ln4236">                  chord = true;</a>
<a name="ln4237">                  _e.readNext();</a>
<a name="ln4238">                  }</a>
<a name="ln4239">            else if (_e.name() == &quot;cue&quot;) {</a>
<a name="ln4240">                  cue = true;</a>
<a name="ln4241">                  _e.readNext();</a>
<a name="ln4242">                  }</a>
<a name="ln4243">            else if (_e.name() == &quot;grace&quot;) {</a>
<a name="ln4244">                  grace = true;</a>
<a name="ln4245">                  graceSlash = _e.attributes().value(&quot;slash&quot;) == &quot;yes&quot;;</a>
<a name="ln4246">                  _e.readNext();</a>
<a name="ln4247">                  }</a>
<a name="ln4248">            else if (_e.name() == &quot;instrument&quot;) {</a>
<a name="ln4249">                  instrumentId = _e.attributes().value(&quot;id&quot;).toString();</a>
<a name="ln4250">                  _e.readNext();</a>
<a name="ln4251">                  }</a>
<a name="ln4252">            else if (_e.name() == &quot;lyric&quot;) {</a>
<a name="ln4253">                  // lyrics on grace notes not (yet) supported by MuseScore</a>
<a name="ln4254">                  if (!grace) {</a>
<a name="ln4255">                        lyric.parse();</a>
<a name="ln4256">                        }</a>
<a name="ln4257">                  else {</a>
<a name="ln4258">                        _logger-&gt;logDebugInfo(&quot;ignoring lyrics on grace notes&quot;, &amp;_e);</a>
<a name="ln4259">                        skipLogCurrElem();</a>
<a name="ln4260">                        }</a>
<a name="ln4261">                  }</a>
<a name="ln4262">            else if (_e.name() == &quot;notations&quot;) {</a>
<a name="ln4263">                  notations.parse();</a>
<a name="ln4264">                  }</a>
<a name="ln4265">            else if (_e.name() == &quot;notehead&quot;) {</a>
<a name="ln4266">                  noteheadColor.setNamedColor(_e.attributes().value(&quot;color&quot;).toString());</a>
<a name="ln4267">                  noteheadParentheses = _e.attributes().value(&quot;parentheses&quot;) == &quot;yes&quot;;</a>
<a name="ln4268">                  noteheadFilled = _e.attributes().value(&quot;filled&quot;).toString();</a>
<a name="ln4269">                  headGroup = convertNotehead(_e.readElementText());</a>
<a name="ln4270">                  }</a>
<a name="ln4271">            else if (_e.name() == &quot;rest&quot;) {</a>
<a name="ln4272">                  rest = true;</a>
<a name="ln4273">                  mnp.displayStepOctave(_e);</a>
<a name="ln4274">                  }</a>
<a name="ln4275">            else if (_e.name() == &quot;staff&quot;) {</a>
<a name="ln4276">                  auto ok = false;</a>
<a name="ln4277">                  auto strStaff = _e.readElementText();</a>
<a name="ln4278">                  staff = strStaff.toInt(&amp;ok);</a>
<a name="ln4279">                  if (!ok) {</a>
<a name="ln4280">                        // error already reported in pass 1</a>
<a name="ln4281">                        staff = 1;</a>
<a name="ln4282">                        }</a>
<a name="ln4283">                  }</a>
<a name="ln4284">            else if (_e.name() == &quot;stem&quot;)</a>
<a name="ln4285">                  stem(stemDir, noStem);</a>
<a name="ln4286">            else if (_e.name() == &quot;type&quot;) {</a>
<a name="ln4287">                  small = _e.attributes().value(&quot;size&quot;) == &quot;cue&quot;;</a>
<a name="ln4288">                  type = _e.readElementText();</a>
<a name="ln4289">                  }</a>
<a name="ln4290">            else if (_e.name() == &quot;voice&quot;)</a>
<a name="ln4291">                  voice = _e.readElementText();</a>
<a name="ln4292">            else</a>
<a name="ln4293">                  skipLogCurrElem();</a>
<a name="ln4294">            }</a>
<a name="ln4295"> </a>
<a name="ln4296">      // convert staff to zero-based (in case of error, staff will be -1)</a>
<a name="ln4297">      staff--;</a>
<a name="ln4298"> </a>
<a name="ln4299">      // Bug fix for Sibelius 7.1.3 which does not write &lt;voice&gt; for notes with &lt;chord&gt;</a>
<a name="ln4300">      if (!chord)</a>
<a name="ln4301">            // remember voice</a>
<a name="ln4302">            currentVoice = voice;</a>
<a name="ln4303">      else if (voice == &quot;&quot;)</a>
<a name="ln4304">            // use voice from last note w/o &lt;chord&gt;</a>
<a name="ln4305">            voice = currentVoice;</a>
<a name="ln4306"> </a>
<a name="ln4307">      // Assume voice 1 if voice is empty (legal in a single voice part)</a>
<a name="ln4308">      if (voice == &quot;&quot;)</a>
<a name="ln4309">            voice = &quot;1&quot;;</a>
<a name="ln4310"> </a>
<a name="ln4311">      // check for timing error(s) and set dura</a>
<a name="ln4312">      // keep in this order as checkTiming() might change dura</a>
<a name="ln4313">      auto errorStr = mnd.checkTiming(type, rest, grace);</a>
<a name="ln4314">      dura = mnd.dura();</a>
<a name="ln4315">      if (errorStr != &quot;&quot;)</a>
<a name="ln4316">            _logger-&gt;logError(errorStr, &amp;_e);</a>
<a name="ln4317"> </a>
<a name="ln4318">      // At this point all checks have been done, the note should be added</a>
<a name="ln4319">      // note: in case of error exit from here, the postponed &lt;note&gt; children</a>
<a name="ln4320">      // must still be skipped</a>
<a name="ln4321"> </a>
<a name="ln4322">      int msMove = 0;</a>
<a name="ln4323">      int msTrack = 0;</a>
<a name="ln4324">      int msVoice = 0;</a>
<a name="ln4325"> </a>
<a name="ln4326">      if (!_pass1.determineStaffMoveVoice(partId, staff, voice, msMove, msTrack, msVoice)) {</a>
<a name="ln4327">            _logger-&gt;logDebugInfo(QString(&quot;could not map staff %1 voice '%2'&quot;).arg(staff + 1).arg(voice), &amp;_e);</a>
<a name="ln4328">            Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln4329">            return 0;</a>
<a name="ln4330">            }</a>
<a name="ln4331"> </a>
<a name="ln4332">      // start time for note:</a>
<a name="ln4333">      // - sTime for non-chord / first chord note</a>
<a name="ln4334">      // - prevTime for others</a>
<a name="ln4335">      auto noteStartTime = chord ? prevSTime : sTime;</a>
<a name="ln4336">      const auto timeMod = mnd.timeMod();</a>
<a name="ln4337"> </a>
<a name="ln4338">      // determine tuplet state, used twice (before and after note allocation)</a>
<a name="ln4339">      MxmlTupletFlags tupletAction;</a>
<a name="ln4340"> </a>
<a name="ln4341">      // handle tuplet state for the previous chord or rest</a>
<a name="ln4342">      if (!chord &amp;&amp; !grace) {</a>
<a name="ln4343">            auto&amp; tuplet = tuplets[voice];</a>
<a name="ln4344">            auto&amp; tupletState = tupletStates[voice];</a>
<a name="ln4345">            tupletAction = tupletState.determineTupletAction(mnd.dura(), timeMod, notations.tupletDesc().type, mnd.normalType(), missingPrev, missingCurr);</a>
<a name="ln4346">            if (tupletAction &amp; MxmlTupletFlag::STOP_PREVIOUS) {</a>
<a name="ln4347">                  // tuplet start while already in tuplet</a>
<a name="ln4348">                  if (missingPrev.isValid() &amp;&amp; missingPrev &gt; Fraction(0, 1)) {</a>
<a name="ln4349">                        const auto track = msTrack + msVoice;</a>
<a name="ln4350">                        const auto extraRest = addRest(_score, measure, noteStartTime, track, msMove,</a>
<a name="ln4351">                                                       TDuration { missingPrev* tuplet-&gt;ratio() }, missingPrev);</a>
<a name="ln4352">                        extraRest-&gt;setTuplet(tuplet);</a>
<a name="ln4353">                        tuplet-&gt;add(extraRest);</a>
<a name="ln4354">                        noteStartTime += missingPrev;</a>
<a name="ln4355">                        }</a>
<a name="ln4356">                  // recover by simply stopping the current tuplet first</a>
<a name="ln4357">                  const auto normalNotes = timeMod.numerator();</a>
<a name="ln4358">                  handleTupletStop(tuplet, normalNotes);</a>
<a name="ln4359">                  }</a>
<a name="ln4360">            }</a>
<a name="ln4361"> </a>
<a name="ln4362">      Chord* c { nullptr };</a>
<a name="ln4363">      ChordRest* cr { nullptr };</a>
<a name="ln4364">      Note* note { nullptr };</a>
<a name="ln4365"> </a>
<a name="ln4366">      TDuration duration = determineDuration(rest, type, mnd.dots(), dura, measure-&gt;ticks());</a>
<a name="ln4367"> </a>
<a name="ln4368">      // begin allocation</a>
<a name="ln4369">      if (rest) {</a>
<a name="ln4370">            const auto track = msTrack + msVoice;</a>
<a name="ln4371">            cr = addRest(_score, measure, noteStartTime, track, msMove,</a>
<a name="ln4372">                         duration, dura);</a>
<a name="ln4373">            }</a>
<a name="ln4374">      else {</a>
<a name="ln4375">            if (!grace) {</a>
<a name="ln4376">                  // regular note</a>
<a name="ln4377">                  // if there is already a chord just add to it</a>
<a name="ln4378">                  // else create a new one</a>
<a name="ln4379">                  // this basically ignores &lt;chord/&gt; errors</a>
<a name="ln4380">                  c = findOrCreateChord(_score, measure,</a>
<a name="ln4381">                                        noteStartTime,</a>
<a name="ln4382">                                        msTrack + msVoice, msMove,</a>
<a name="ln4383">                                        duration, dura, bm);</a>
<a name="ln4384">                  }</a>
<a name="ln4385">            else {</a>
<a name="ln4386">                  // grace note</a>
<a name="ln4387">                  // TODO: check if explicit stem direction should also be set for grace notes</a>
<a name="ln4388">                  // (the DOM parser does that, but seems to have no effect on the autotester)</a>
<a name="ln4389">                  if (!chord || gcl.isEmpty()) {</a>
<a name="ln4390">                        c = createGraceChord(_score, msTrack + msVoice, duration, graceSlash);</a>
<a name="ln4391">                        // TODO FIX</a>
<a name="ln4392">                        // the setStaffMove() below results in identical behaviour as 2.0:</a>
<a name="ln4393">                        // grace note will be at the wrong staff with the wrong pitch,</a>
<a name="ln4394">                        // seems to use the line value calculated for the right staff</a>
<a name="ln4395">                        // leaving it places the note at the wrong staff with the right pitch</a>
<a name="ln4396">                        // this affects only grace notes where staff move differs from</a>
<a name="ln4397">                        // the main note, e.g. DebuMandSample.xml first grace in part 2</a>
<a name="ln4398">                        // c-&gt;setStaffMove(msMove);</a>
<a name="ln4399">                        // END TODO</a>
<a name="ln4400">                        gcl.append(c);</a>
<a name="ln4401">                        }</a>
<a name="ln4402">                  else</a>
<a name="ln4403">                        c = gcl.last();</a>
<a name="ln4404"> </a>
<a name="ln4405">                  }</a>
<a name="ln4406">            note = new Note(_score);</a>
<a name="ln4407">            const int ottavaStaff = (msTrack - _pass1.trackForPart(partId)) / VOICES;</a>
<a name="ln4408">            const int octaveShift = _pass1.octaveShift(partId, ottavaStaff, noteStartTime);</a>
<a name="ln4409">            setPitch(note, _pass1, partId, instrumentId, mnp, octaveShift);</a>
<a name="ln4410">            c-&gt;add(note);</a>
<a name="ln4411">            //c-&gt;setStemDirection(stemDir); // already done in handleBeamAndStemDir()</a>
<a name="ln4412">            //c-&gt;setNoStem(noStem);</a>
<a name="ln4413">            cr = c;</a>
<a name="ln4414">            }</a>
<a name="ln4415">      // end allocation</a>
<a name="ln4416"> </a>
<a name="ln4417">      if (rest) {</a>
<a name="ln4418">            const auto track = msTrack + msVoice;</a>
<a name="ln4419">            if (cr) {</a>
<a name="ln4420">                  if (currBeam) {</a>
<a name="ln4421">                        if (currBeam-&gt;track() == track) {</a>
<a name="ln4422">                              cr-&gt;setBeamMode(Beam::Mode::MID);</a>
<a name="ln4423">                              currBeam-&gt;add(cr);</a>
<a name="ln4424">                              }</a>
<a name="ln4425">                        else</a>
<a name="ln4426">                              removeBeam(currBeam);</a>
<a name="ln4427">                        }</a>
<a name="ln4428">                  else</a>
<a name="ln4429">                        cr-&gt;setBeamMode(Beam::Mode::NONE);</a>
<a name="ln4430">                  cr-&gt;setSmall(small);</a>
<a name="ln4431">                  if (noteColor != QColor::Invalid)</a>
<a name="ln4432">                        cr-&gt;setColor(noteColor);</a>
<a name="ln4433">                  cr-&gt;setVisible(printObject);</a>
<a name="ln4434">                  handleDisplayStep(cr, mnp.displayStep(), mnp.displayOctave(), noteStartTime, _score-&gt;spatium());</a>
<a name="ln4435">                  }</a>
<a name="ln4436">            }</a>
<a name="ln4437">      else {</a>
<a name="ln4438">            if (!grace) {</a>
<a name="ln4439">                  // regular note</a>
<a name="ln4440">                  // handle beam</a>
<a name="ln4441">                  if (!chord)</a>
<a name="ln4442">                        handleBeamAndStemDir(c, bm, stemDir, currBeam);</a>
<a name="ln4443"> </a>
<a name="ln4444">                  // append any grace chord after chord to the previous chord</a>
<a name="ln4445">                  const auto prevChord = measure-&gt;findChord(prevSTime, msTrack + msVoice);</a>
<a name="ln4446">                  if (prevChord &amp;&amp; prevChord != c)</a>
<a name="ln4447">                        addGraceChordsAfter(prevChord, gcl, gac);</a>
<a name="ln4448"> </a>
<a name="ln4449">                  // append any grace chord</a>
<a name="ln4450">                  addGraceChordsBefore(c, gcl);</a>
<a name="ln4451">                  }</a>
<a name="ln4452"> </a>
<a name="ln4453">            note-&gt;setSmall(cue || small); // cue notes are always small, normal notes only if size=cue</a>
<a name="ln4454">            note-&gt;setPlay(!cue);          // cue notes don't play</a>
<a name="ln4455">            note-&gt;setHeadGroup(headGroup);</a>
<a name="ln4456">            if (noteColor != QColor::Invalid)</a>
<a name="ln4457">                  note-&gt;setColor(noteColor);</a>
<a name="ln4458">            setNoteHead(note, noteheadColor, noteheadParentheses, noteheadFilled);</a>
<a name="ln4459">            note-&gt;setVisible(printObject); // TODO also set the stem to invisible</a>
<a name="ln4460"> </a>
<a name="ln4461">            if (velocity &gt; 0) {</a>
<a name="ln4462">                  note-&gt;setVeloType(Note::ValueType::USER_VAL);</a>
<a name="ln4463">                  note-&gt;setVeloOffset(velocity);</a>
<a name="ln4464">                  }</a>
<a name="ln4465"> </a>
<a name="ln4466">            if (mnp.unpitched()) {</a>
<a name="ln4467">                  setDrumset(c, _pass1, partId, instrumentId, noteStartTime, mnp, stemDir, headGroup);</a>
<a name="ln4468">                  }</a>
<a name="ln4469"> </a>
<a name="ln4470">            // accidental handling</a>
<a name="ln4471">            //qDebug(&quot;note acc %p type %hhd acctype %hhd&quot;,</a>
<a name="ln4472">            //       acc, acc ? acc-&gt;accidentalType() : static_cast&lt;Ms::AccidentalType&gt;(0), accType);</a>
<a name="ln4473">            Accidental* acc = mnp.acc();</a>
<a name="ln4474">            if (!acc &amp;&amp; mnp.accType() != AccidentalType::NONE) {</a>
<a name="ln4475">                  acc = new Accidental(_score);</a>
<a name="ln4476">                  acc-&gt;setAccidentalType(mnp.accType());</a>
<a name="ln4477">                  }</a>
<a name="ln4478"> </a>
<a name="ln4479">            if (acc) {</a>
<a name="ln4480">                  note-&gt;add(acc);</a>
<a name="ln4481">                  // save alter value for user accidental</a>
<a name="ln4482">                  if (acc-&gt;accidentalType() != AccidentalType::NONE)</a>
<a name="ln4483">                        alt = mnp.alter();</a>
<a name="ln4484">                  }</a>
<a name="ln4485"> </a>
<a name="ln4486">            c-&gt;setNoStem(noStem);</a>
<a name="ln4487">            }</a>
<a name="ln4488"> </a>
<a name="ln4489">      // cr can be 0 here (if a rest cannot be added)</a>
<a name="ln4490">      // TODO: complete and cleanup handling this case</a>
<a name="ln4491">      if (cr)</a>
<a name="ln4492">            cr-&gt;setVisible(printObject);</a>
<a name="ln4493"> </a>
<a name="ln4494">      Q_ASSERT(_pass1.getPart(partId));</a>
<a name="ln4495"> </a>
<a name="ln4496">      // handle notations</a>
<a name="ln4497">      if (cr) {</a>
<a name="ln4498">            notations.addToScore(cr, note, noteStartTime.ticks(), _slurs, _glissandi, _spanners, _trills, _tie);</a>
<a name="ln4499">            }</a>
<a name="ln4500"> </a>
<a name="ln4501">      // handle grace after state: remember current grace list size</a>
<a name="ln4502">      if (grace &amp;&amp; notations.mustStopGraceAFter()) {</a>
<a name="ln4503">            gac = gcl.size();</a>
<a name="ln4504">            }</a>
<a name="ln4505"> </a>
<a name="ln4506">      // handle tuplet state for the current chord or rest</a>
<a name="ln4507">      if (cr) {</a>
<a name="ln4508">            if (!chord &amp;&amp; !grace) {</a>
<a name="ln4509">                  auto&amp; tuplet = tuplets[voice];</a>
<a name="ln4510">                  // do tuplet if valid time-modification is not 1/1 and is not 1/2 (tremolo)</a>
<a name="ln4511">                  // TODO: check interaction tuplet and tremolo handling</a>
<a name="ln4512">                  if (timeMod.isValid() &amp;&amp; timeMod != Fraction(1, 1) &amp;&amp; timeMod != Fraction(1, 2)) {</a>
<a name="ln4513">                        const auto actualNotes = timeMod.denominator();</a>
<a name="ln4514">                        const auto normalNotes = timeMod.numerator();</a>
<a name="ln4515">                        if (tupletAction &amp; MxmlTupletFlag::START_NEW) {</a>
<a name="ln4516">                              // create a new tuplet</a>
<a name="ln4517">                              handleTupletStart(cr, tuplet, actualNotes, normalNotes, notations.tupletDesc());</a>
<a name="ln4518">                              }</a>
<a name="ln4519">                        if (tupletAction &amp; MxmlTupletFlag::ADD_CHORD) {</a>
<a name="ln4520">                              cr-&gt;setTuplet(tuplet);</a>
<a name="ln4521">                              tuplet-&gt;add(cr);</a>
<a name="ln4522">                              }</a>
<a name="ln4523">                        if (tupletAction &amp; MxmlTupletFlag::STOP_CURRENT) {</a>
<a name="ln4524">                              if (missingCurr.isValid() &amp;&amp; missingCurr &gt; Fraction(0, 1)) {</a>
<a name="ln4525">                                    qDebug(&quot;add missing %s to current tuplet&quot;, qPrintable(missingCurr.print()));</a>
<a name="ln4526">                                    const auto track = msTrack + msVoice;</a>
<a name="ln4527">                                    const auto extraRest = addRest(_score, measure, noteStartTime + dura, track, msMove,</a>
<a name="ln4528">                                                                   TDuration { missingCurr* tuplet-&gt;ratio() }, missingCurr);</a>
<a name="ln4529">                                    extraRest-&gt;setTuplet(tuplet);</a>
<a name="ln4530">                                    tuplet-&gt;add(extraRest);</a>
<a name="ln4531">                                    }</a>
<a name="ln4532">                              handleTupletStop(tuplet, normalNotes);</a>
<a name="ln4533">                              }</a>
<a name="ln4534">                        }</a>
<a name="ln4535">                  else if (tuplet) {</a>
<a name="ln4536">                        // stop any still incomplete tuplet</a>
<a name="ln4537">                        handleTupletStop(tuplet, 2);</a>
<a name="ln4538">                        }</a>
<a name="ln4539">                  }</a>
<a name="ln4540">            }</a>
<a name="ln4541"> </a>
<a name="ln4542">      // add lyrics found by lyric</a>
<a name="ln4543">      if (cr) {</a>
<a name="ln4544">            // add lyrics and stop corresponding extends</a>
<a name="ln4545">            addLyrics(_logger, &amp;_e, cr, lyric.numberedLyrics(), lyric.extendedLyrics(), _extendedLyrics);</a>
<a name="ln4546">            if (rest) {</a>
<a name="ln4547">                  // stop all extends</a>
<a name="ln4548">                  _extendedLyrics.setExtend(-1, cr-&gt;track(), cr-&gt;tick());</a>
<a name="ln4549">                  }</a>
<a name="ln4550">            }</a>
<a name="ln4551"> </a>
<a name="ln4552">      // add figured bass element</a>
<a name="ln4553">      addFiguredBassElemens(fbl, noteStartTime, msTrack, dura, measure);</a>
<a name="ln4554">      if (cr) {</a>
<a name="ln4555">            addTremolo(cr, notations.tremoloNr(), notations.tremoloType(), _tremStart, _logger, &amp;_e);</a>
<a name="ln4556">            }</a>
<a name="ln4557"> </a>
<a name="ln4558">      // don't count chord or grace note duration</a>
<a name="ln4559">      // note that this does not check the MusicXML requirement that notes in a chord</a>
<a name="ln4560">      // cannot have a duration longer than the first note in the chord</a>
<a name="ln4561">      if (chord || grace)</a>
<a name="ln4562">            dura.set(0, 1);</a>
<a name="ln4563"> </a>
<a name="ln4564">      if (!(_e.isEndElement() &amp;&amp; _e.name() == &quot;note&quot;))</a>
<a name="ln4565">            qDebug(&quot;name %s line %lld&quot;, qPrintable(_e.name().toString()), _e.lineNumber());</a>
<a name="ln4566">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln4567"> </a>
<a name="ln4568">      return note;</a>
<a name="ln4569">      }</a>
<a name="ln4570"> </a>
<a name="ln4571">//---------------------------------------------------------</a>
<a name="ln4572">//   notePrintSpacingNo</a>
<a name="ln4573">//---------------------------------------------------------</a>
<a name="ln4574"> </a>
<a name="ln4575">/**</a>
<a name="ln4576"> Parse the /score-partwise/part/measure/note node for a note with print-spacing=&quot;no&quot;.</a>
<a name="ln4577"> These are handled like a forward: only moving the time forward.</a>
<a name="ln4578"> */</a>
<a name="ln4579"> </a>
<a name="ln4580">void MusicXMLParserPass2::notePrintSpacingNo(Fraction&amp; dura)</a>
<a name="ln4581">      {</a>
<a name="ln4582">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln4583">      //_logger-&gt;logDebugTrace(&quot;MusicXMLParserPass1::notePrintSpacingNo&quot;, &amp;_e);</a>
<a name="ln4584"> </a>
<a name="ln4585">      bool chord = false;</a>
<a name="ln4586">      bool grace = false;</a>
<a name="ln4587"> </a>
<a name="ln4588">      while (_e.readNextStartElement()) {</a>
<a name="ln4589">            if (_e.name() == &quot;chord&quot;) {</a>
<a name="ln4590">                  chord = true;</a>
<a name="ln4591">                  _e.readNext();</a>
<a name="ln4592">                  }</a>
<a name="ln4593">            else if (_e.name() == &quot;duration&quot;)</a>
<a name="ln4594">                  duration(dura);</a>
<a name="ln4595">            else if (_e.name() == &quot;grace&quot;) {</a>
<a name="ln4596">                  grace = true;</a>
<a name="ln4597">                  _e.readNext();</a>
<a name="ln4598">                  }</a>
<a name="ln4599">            else</a>
<a name="ln4600">                  _e.skipCurrentElement();        // skip but don't log</a>
<a name="ln4601">            }</a>
<a name="ln4602"> </a>
<a name="ln4603">      // don't count chord or grace note duration</a>
<a name="ln4604">      // note that this does not check the MusicXML requirement that notes in a chord</a>
<a name="ln4605">      // cannot have a duration longer than the first note in the chord</a>
<a name="ln4606">      if (chord || grace)</a>
<a name="ln4607">            dura.set(0, 1);</a>
<a name="ln4608"> </a>
<a name="ln4609">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;note&quot;);</a>
<a name="ln4610">      }</a>
<a name="ln4611"> </a>
<a name="ln4612">//---------------------------------------------------------</a>
<a name="ln4613">//   duration</a>
<a name="ln4614">//---------------------------------------------------------</a>
<a name="ln4615"> </a>
<a name="ln4616">/**</a>
<a name="ln4617"> Parse the /score-partwise/part/measure/note/duration node.</a>
<a name="ln4618"> */</a>
<a name="ln4619"> </a>
<a name="ln4620">void MusicXMLParserPass2::duration(Fraction&amp; dura)</a>
<a name="ln4621">      {</a>
<a name="ln4622">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;duration&quot;);</a>
<a name="ln4623"> </a>
<a name="ln4624">      dura.set(0, 0);        // invalid unless set correctly</a>
<a name="ln4625">      const auto elementText = _e.readElementText();</a>
<a name="ln4626">      if (elementText.toInt() &gt; 0)</a>
<a name="ln4627">            dura = calcTicks(elementText, _divs, _logger, &amp;_e);</a>
<a name="ln4628">      else</a>
<a name="ln4629">            _logger-&gt;logError(QString(&quot;illegal duration %1&quot;).arg(dura.print()), &amp;_e);</a>
<a name="ln4630">      //qDebug(&quot;duration %s valid %d&quot;, qPrintable(dura.print()), dura.isValid());</a>
<a name="ln4631">      }</a>
<a name="ln4632"> </a>
<a name="ln4633">//---------------------------------------------------------</a>
<a name="ln4634">//   figure</a>
<a name="ln4635">//---------------------------------------------------------</a>
<a name="ln4636"> </a>
<a name="ln4637">/**</a>
<a name="ln4638"> Parse the /score-partwise/part/measure/harmony/figured-bass/figure node.</a>
<a name="ln4639"> Return the result as a FiguredBassItem.</a>
<a name="ln4640"> */</a>
<a name="ln4641"> </a>
<a name="ln4642">FiguredBassItem* MusicXMLParserPass2::figure(const int idx, const bool paren)</a>
<a name="ln4643">      {</a>
<a name="ln4644">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;figure&quot;);</a>
<a name="ln4645"> </a>
<a name="ln4646">      FiguredBassItem* fgi = new FiguredBassItem(_score, idx);</a>
<a name="ln4647"> </a>
<a name="ln4648">      // read the figure</a>
<a name="ln4649">      while (_e.readNextStartElement()) {</a>
<a name="ln4650">            if (_e.name() == &quot;extend&quot;) {</a>
<a name="ln4651">                  QStringRef type = _e.attributes().value(&quot;type&quot;);</a>
<a name="ln4652">                  if (type == &quot;start&quot;)</a>
<a name="ln4653">                        fgi-&gt;setContLine(FiguredBassItem::ContLine::EXTENDED);</a>
<a name="ln4654">                  else if (type == &quot;continue&quot;)</a>
<a name="ln4655">                        fgi-&gt;setContLine(FiguredBassItem::ContLine::EXTENDED);</a>
<a name="ln4656">                  else if (type == &quot;stop&quot;)</a>
<a name="ln4657">                        fgi-&gt;setContLine(FiguredBassItem::ContLine::SIMPLE);</a>
<a name="ln4658">                  _e.skipCurrentElement();</a>
<a name="ln4659">                  }</a>
<a name="ln4660">            else if (_e.name() == &quot;figure-number&quot;) {</a>
<a name="ln4661">                  QString val = _e.readElementText();</a>
<a name="ln4662">                  int iVal = val.toInt();</a>
<a name="ln4663">                  // MusicXML spec states figure-number is a number</a>
<a name="ln4664">                  // MuseScore can only handle single digit</a>
<a name="ln4665">                  if (1 &lt;= iVal &amp;&amp; iVal &lt;= 9)</a>
<a name="ln4666">                        fgi-&gt;setDigit(iVal);</a>
<a name="ln4667">                  else</a>
<a name="ln4668">                        _logger-&gt;logError(QString(&quot;incorrect figure-number '%1'&quot;).arg(val), &amp;_e);</a>
<a name="ln4669">                  }</a>
<a name="ln4670">            else if (_e.name() == &quot;prefix&quot;)</a>
<a name="ln4671">                  fgi-&gt;setPrefix(fgi-&gt;MusicXML2Modifier(_e.readElementText()));</a>
<a name="ln4672">            else if (_e.name() == &quot;suffix&quot;)</a>
<a name="ln4673">                  fgi-&gt;setSuffix(fgi-&gt;MusicXML2Modifier(_e.readElementText()));</a>
<a name="ln4674">            else</a>
<a name="ln4675">                  skipLogCurrElem();</a>
<a name="ln4676">            }</a>
<a name="ln4677"> </a>
<a name="ln4678">      // set parentheses</a>
<a name="ln4679">      if (paren) {</a>
<a name="ln4680">            // parenthesis open</a>
<a name="ln4681">            if (fgi-&gt;prefix() != FiguredBassItem::Modifier::NONE)</a>
<a name="ln4682">                  fgi-&gt;setParenth1(FiguredBassItem::Parenthesis::ROUNDOPEN);        // before prefix</a>
<a name="ln4683">            else if (fgi-&gt;digit() != FBIDigitNone)</a>
<a name="ln4684">                  fgi-&gt;setParenth2(FiguredBassItem::Parenthesis::ROUNDOPEN);        // before digit</a>
<a name="ln4685">            else if (fgi-&gt;suffix() != FiguredBassItem::Modifier::NONE)</a>
<a name="ln4686">                  fgi-&gt;setParenth3(FiguredBassItem::Parenthesis::ROUNDOPEN);        // before suffix</a>
<a name="ln4687">            // parenthesis close</a>
<a name="ln4688">            if (fgi-&gt;suffix() != FiguredBassItem::Modifier::NONE)</a>
<a name="ln4689">                  fgi-&gt;setParenth4(FiguredBassItem::Parenthesis::ROUNDCLOSED);        // after suffix</a>
<a name="ln4690">            else if (fgi-&gt;digit() != FBIDigitNone)</a>
<a name="ln4691">                  fgi-&gt;setParenth3(FiguredBassItem::Parenthesis::ROUNDCLOSED);        // after digit</a>
<a name="ln4692">            else if (fgi-&gt;prefix() != FiguredBassItem::Modifier::NONE)</a>
<a name="ln4693">                  fgi-&gt;setParenth2(FiguredBassItem::Parenthesis::ROUNDCLOSED);        // after prefix</a>
<a name="ln4694">            }</a>
<a name="ln4695"> </a>
<a name="ln4696">      return fgi;</a>
<a name="ln4697">      }</a>
<a name="ln4698"> </a>
<a name="ln4699">//---------------------------------------------------------</a>
<a name="ln4700">//   figuredBass</a>
<a name="ln4701">//---------------------------------------------------------</a>
<a name="ln4702"> </a>
<a name="ln4703">/**</a>
<a name="ln4704"> Parse the /score-partwise/part/measure/harmony/figured-bass node.</a>
<a name="ln4705"> TODO check description:</a>
<a name="ln4706"> // Set the FiguredBass state based on the MusicXML &lt;figured-bass&gt; node de.</a>
<a name="ln4707"> // Note that onNote and ticks must be set by the MusicXML importer,</a>
<a name="ln4708"> // as the required context is not present in the items DOM tree.</a>
<a name="ln4709"> // Exception: if a &lt;duration&gt; element is present, tick can be set.</a>
<a name="ln4710"> Return the result as a FiguredBass if valid, non-empty figure(s) are found.</a>
<a name="ln4711"> Return 0 in case of error.</a>
<a name="ln4712"> */</a>
<a name="ln4713"> </a>
<a name="ln4714">FiguredBass* MusicXMLParserPass2::figuredBass()</a>
<a name="ln4715">      {</a>
<a name="ln4716">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;figured-bass&quot;);</a>
<a name="ln4717"> </a>
<a name="ln4718">      FiguredBass* fb = new FiguredBass(_score);</a>
<a name="ln4719"> </a>
<a name="ln4720">      bool parentheses = _e.attributes().value(&quot;parentheses&quot;) == &quot;yes&quot;;</a>
<a name="ln4721">      QString normalizedText;</a>
<a name="ln4722">      int idx = 0;</a>
<a name="ln4723">      while (_e.readNextStartElement()) {</a>
<a name="ln4724">            if (_e.name() == &quot;duration&quot;) {</a>
<a name="ln4725">                  Fraction dura;</a>
<a name="ln4726">                  duration(dura);</a>
<a name="ln4727">                  if (dura.isValid() &amp;&amp; dura &gt; Fraction(0, 1))</a>
<a name="ln4728">                        fb-&gt;setTicks(dura);</a>
<a name="ln4729">                  }</a>
<a name="ln4730">            else if (_e.name() == &quot;figure&quot;) {</a>
<a name="ln4731">                  FiguredBassItem* pItem = figure(idx++, parentheses);</a>
<a name="ln4732">                  pItem-&gt;setTrack(0 /* TODO fb-&gt;track() */);</a>
<a name="ln4733">                  pItem-&gt;setParent(fb);</a>
<a name="ln4734">                  fb-&gt;appendItem(pItem);</a>
<a name="ln4735">                  // add item normalized text</a>
<a name="ln4736">                  if (!normalizedText.isEmpty())</a>
<a name="ln4737">                        normalizedText.append('\n');</a>
<a name="ln4738">                  normalizedText.append(pItem-&gt;normalizedText());</a>
<a name="ln4739">                  }</a>
<a name="ln4740">            else {</a>
<a name="ln4741">                  skipLogCurrElem();</a>
<a name="ln4742">                  delete fb;</a>
<a name="ln4743">                  return 0;</a>
<a name="ln4744">                  }</a>
<a name="ln4745">            }</a>
<a name="ln4746"> </a>
<a name="ln4747">      fb-&gt;setXmlText(normalizedText);                        // this is the text to show while editing</a>
<a name="ln4748"> </a>
<a name="ln4749">      if (normalizedText.isEmpty()) {</a>
<a name="ln4750">            delete fb;</a>
<a name="ln4751">            return 0;</a>
<a name="ln4752">            }</a>
<a name="ln4753"> </a>
<a name="ln4754">      return fb;</a>
<a name="ln4755">      }</a>
<a name="ln4756"> </a>
<a name="ln4757">//---------------------------------------------------------</a>
<a name="ln4758">//   frame</a>
<a name="ln4759">//---------------------------------------------------------</a>
<a name="ln4760"> </a>
<a name="ln4761">/**</a>
<a name="ln4762"> Parse the /score-partwise/part/measure/harmony/frame node.</a>
<a name="ln4763"> Return the result as a FretDiagram.</a>
<a name="ln4764"> */</a>
<a name="ln4765"> </a>
<a name="ln4766">FretDiagram* MusicXMLParserPass2::frame()</a>
<a name="ln4767">      {</a>
<a name="ln4768">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;frame&quot;);</a>
<a name="ln4769"> </a>
<a name="ln4770">      FretDiagram* fd = new FretDiagram(_score);</a>
<a name="ln4771"> </a>
<a name="ln4772">      // Format: fret: string</a>
<a name="ln4773">      std::map&lt;int, int&gt; bStarts;</a>
<a name="ln4774">      std::map&lt;int, int&gt; bEnds;</a>
<a name="ln4775"> </a>
<a name="ln4776">      while (_e.readNextStartElement()) {</a>
<a name="ln4777">            if (_e.name() == &quot;frame-frets&quot;) {</a>
<a name="ln4778">                  int val = _e.readElementText().toInt();</a>
<a name="ln4779">                  if (val &gt; 0)</a>
<a name="ln4780">                        fd-&gt;setFrets(val);</a>
<a name="ln4781">                  else</a>
<a name="ln4782">                        _logger-&gt;logError(QString(&quot;FretDiagram::readMusicXML: illegal frame-fret %1&quot;).arg(val), &amp;_e);</a>
<a name="ln4783">                  }</a>
<a name="ln4784">            else if (_e.name() == &quot;frame-note&quot;) {</a>
<a name="ln4785">                  int fret   = -1;</a>
<a name="ln4786">                  int string = -1;</a>
<a name="ln4787">                  int actualString = -1;</a>
<a name="ln4788">                  while (_e.readNextStartElement()) {</a>
<a name="ln4789">                        if (_e.name() == &quot;fret&quot;)</a>
<a name="ln4790">                              fret = _e.readElementText().toInt();</a>
<a name="ln4791">                        else if (_e.name() == &quot;string&quot;) {</a>
<a name="ln4792">                              string = _e.readElementText().toInt();</a>
<a name="ln4793">                              actualString = fd-&gt;strings() - string;</a>
<a name="ln4794">                              }</a>
<a name="ln4795">                        else if (_e.name() == &quot;barre&quot;) {</a>
<a name="ln4796">                              // Keep barres to be added later</a>
<a name="ln4797">                              QString t = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln4798">                              if (t == &quot;start&quot;)</a>
<a name="ln4799">                                    bStarts[fret] = actualString;</a>
<a name="ln4800">                              else if (t == &quot;stop&quot;)</a>
<a name="ln4801">                                    bEnds[fret] = actualString;</a>
<a name="ln4802">                              else</a>
<a name="ln4803">                                    _logger-&gt;logError(QString(&quot;FretDiagram::readMusicXML: illegal frame-note barre type %1&quot;).arg(t), &amp;_e);</a>
<a name="ln4804">                              skipLogCurrElem();</a>
<a name="ln4805">                              }</a>
<a name="ln4806">                        else</a>
<a name="ln4807">                              skipLogCurrElem();</a>
<a name="ln4808">                        }</a>
<a name="ln4809">                  _logger-&gt;logDebugInfo(QString(&quot;FretDiagram::readMusicXML string %1 fret %2&quot;).arg(string).arg(fret), &amp;_e);</a>
<a name="ln4810"> </a>
<a name="ln4811">                  if (string &gt; 0) {</a>
<a name="ln4812">                        if (fret == 0)</a>
<a name="ln4813">                              fd-&gt;setMarker(actualString, FretMarkerType::CIRCLE);</a>
<a name="ln4814">                        else if (fret &gt; 0)</a>
<a name="ln4815">                              fd-&gt;setDot(actualString, fret, true);</a>
<a name="ln4816">                        }</a>
<a name="ln4817">                  else</a>
<a name="ln4818">                        _logger-&gt;logError(QString(&quot;FretDiagram::readMusicXML: illegal frame-note string %1&quot;).arg(string), &amp;_e);</a>
<a name="ln4819">                  }</a>
<a name="ln4820">            else if (_e.name() == &quot;frame-strings&quot;) {</a>
<a name="ln4821">                  int val = _e.readElementText().toInt();</a>
<a name="ln4822">                  if (val &gt; 0) {</a>
<a name="ln4823">                        fd-&gt;setStrings(val);</a>
<a name="ln4824">                        for (int i = 0; i &lt; val; ++i) {</a>
<a name="ln4825">                              // MXML Spec: any string without a dot or other marker has a closed string</a>
<a name="ln4826">                              // cross marker above it.</a>
<a name="ln4827">                              fd-&gt;setMarker(i, FretMarkerType::CROSS);</a>
<a name="ln4828">                              }</a>
<a name="ln4829">                        }</a>
<a name="ln4830">                  else</a>
<a name="ln4831">                        _logger-&gt;logError(QString(&quot;FretDiagram::readMusicXML: illegal frame-strings %1&quot;).arg(val), &amp;_e);</a>
<a name="ln4832">                  }</a>
<a name="ln4833">            else</a>
<a name="ln4834">                  skipLogCurrElem();</a>
<a name="ln4835">            }</a>
<a name="ln4836"> </a>
<a name="ln4837">      // Finally add barres</a>
<a name="ln4838">      for (auto const&amp; i : bStarts) {</a>
<a name="ln4839">            int fret = i.first;</a>
<a name="ln4840">            int startString = i.second;</a>
<a name="ln4841"> </a>
<a name="ln4842">            if (bEnds.find(fret) == bEnds.end())</a>
<a name="ln4843">                  continue;</a>
<a name="ln4844"> </a>
<a name="ln4845">            int endString = bEnds[fret];</a>
<a name="ln4846">            fd-&gt;setBarre(startString, endString, fret);</a>
<a name="ln4847">            }</a>
<a name="ln4848"> </a>
<a name="ln4849">      return fd;</a>
<a name="ln4850">      }</a>
<a name="ln4851"> </a>
<a name="ln4852">//---------------------------------------------------------</a>
<a name="ln4853">//   harmony</a>
<a name="ln4854">//---------------------------------------------------------</a>
<a name="ln4855"> </a>
<a name="ln4856">/**</a>
<a name="ln4857"> Parse the /score-partwise/part/measure/harmony node.</a>
<a name="ln4858"> */</a>
<a name="ln4859"> </a>
<a name="ln4860">void MusicXMLParserPass2::harmony(const QString&amp; partId, Measure* measure, const Fraction sTime)</a>
<a name="ln4861">      {</a>
<a name="ln4862">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;harmony&quot;);</a>
<a name="ln4863"> </a>
<a name="ln4864">      int track = _pass1.trackForPart(partId);</a>
<a name="ln4865"> </a>
<a name="ln4866">      // placement:</a>
<a name="ln4867">      // in order to work correctly, this should probably be adjusted to account for spatium</a>
<a name="ln4868">      // but in any case, we don't support import relative-x/y for other elements</a>
<a name="ln4869">      // no reason to do so for chord symbols</a>
<a name="ln4870">#if 0 // TODO:ws</a>
<a name="ln4871">      double rx = 0.0;        // 0.1 * e.attribute(&quot;relative-x&quot;, &quot;0&quot;).toDouble();</a>
<a name="ln4872">      double ry = 0.0;        // -0.1 * e.attribute(&quot;relative-y&quot;, &quot;0&quot;).toDouble();</a>
<a name="ln4873"> </a>
<a name="ln4874">      double styleYOff = _score-&gt;textStyle(Tid::HARMONY).offset().y();</a>
<a name="ln4875">      OffsetType offsetType = _score-&gt;textStyle(Tid::HARMONY).offsetType();</a>
<a name="ln4876">      if (offsetType == OffsetType::ABS) {</a>
<a name="ln4877">            styleYOff = styleYOff * DPMM / _score-&gt;spatium();</a>
<a name="ln4878">            }</a>
<a name="ln4879"> </a>
<a name="ln4880">      // TODO: check correct dy handling</a>
<a name="ln4881">      // previous code: double dy = -0.1 * e.attribute(&quot;default-y&quot;, QString::number(styleYOff* -10)).toDouble();</a>
<a name="ln4882">      double dy = -0.1 * _e.attributes().value(&quot;default-y&quot;).toDouble();</a>
<a name="ln4883">#endif</a>
<a name="ln4884">      bool printObject = _e.attributes().value(&quot;print-object&quot;) != &quot;no&quot;;</a>
<a name="ln4885">      QString printFrame = _e.attributes().value(&quot;print-frame&quot;).toString();</a>
<a name="ln4886">      QString printStyle = _e.attributes().value(&quot;print-style&quot;).toString();</a>
<a name="ln4887"> </a>
<a name="ln4888">      QString kind, kindText, functionText, symbols, parens;</a>
<a name="ln4889">      QList&lt;HDegree&gt; degreeList;</a>
<a name="ln4890"> </a>
<a name="ln4891">      /* TODO ?</a>
<a name="ln4892">      if (harmony) {</a>
<a name="ln4893">            qDebug(&quot;MusicXML::import: more than one harmony&quot;);</a>
<a name="ln4894">            return;</a>
<a name="ln4895">      }</a>
<a name="ln4896">       */</a>
<a name="ln4897"> </a>
<a name="ln4898">      FretDiagram* fd = 0;</a>
<a name="ln4899">      Harmony* ha = new Harmony(_score);</a>
<a name="ln4900">//TODO:ws      ha-&gt;setUserOff(QPointF(rx, ry + dy - styleYOff));</a>
<a name="ln4901">      Fraction offset;</a>
<a name="ln4902">      while (_e.readNextStartElement()) {</a>
<a name="ln4903">            if (_e.name() == &quot;root&quot;) {</a>
<a name="ln4904">                  QString step;</a>
<a name="ln4905">                  int alter = 0;</a>
<a name="ln4906">                  bool invalidRoot = false;</a>
<a name="ln4907">                  while (_e.readNextStartElement()) {</a>
<a name="ln4908">                        if (_e.name() == &quot;root-step&quot;) {</a>
<a name="ln4909">                              // attributes: print-style</a>
<a name="ln4910">                              step = _e.readElementText();</a>
<a name="ln4911">                              /* TODO: check if this is required</a>
<a name="ln4912">                              if (ee.hasAttribute(&quot;text&quot;)) {</a>
<a name="ln4913">                                    QString rtext = ee.attribute(&quot;text&quot;);</a>
<a name="ln4914">                                    if (rtext == &quot;&quot;) {</a>
<a name="ln4915">                                          invalidRoot = true;</a>
<a name="ln4916">                                    }</a>
<a name="ln4917">                              }</a>
<a name="ln4918">                               */</a>
<a name="ln4919">                              }</a>
<a name="ln4920">                        else if (_e.name() == &quot;root-alter&quot;) {</a>
<a name="ln4921">                              // attributes: print-object, print-style</a>
<a name="ln4922">                              //             location (left-right)</a>
<a name="ln4923">                              alter = _e.readElementText().toInt();</a>
<a name="ln4924">                              }</a>
<a name="ln4925">                        else</a>
<a name="ln4926">                              skipLogCurrElem();</a>
<a name="ln4927">                        }</a>
<a name="ln4928">                  if (invalidRoot)</a>
<a name="ln4929">                        ha-&gt;setRootTpc(Tpc::TPC_INVALID);</a>
<a name="ln4930">                  else</a>
<a name="ln4931">                        ha-&gt;setRootTpc(step2tpc(step, AccidentalVal(alter)));</a>
<a name="ln4932">                  }</a>
<a name="ln4933">            else if (_e.name() == &quot;function&quot;) {</a>
<a name="ln4934">                  // attributes: print-style</a>
<a name="ln4935">                  ha-&gt;setRootTpc(Tpc::TPC_INVALID);</a>
<a name="ln4936">                  ha-&gt;setBaseTpc(Tpc::TPC_INVALID);</a>
<a name="ln4937">                  functionText = _e.readElementText();</a>
<a name="ln4938">                  // TODO: parse to decide between ROMAN and NASHVILLE</a>
<a name="ln4939">                  ha-&gt;setHarmonyType(HarmonyType::ROMAN);</a>
<a name="ln4940">                  }</a>
<a name="ln4941">            else if (_e.name() == &quot;kind&quot;) {</a>
<a name="ln4942">                  // attributes: use-symbols  yes-no</a>
<a name="ln4943">                  //             text, stack-degrees, parentheses-degree, bracket-degrees,</a>
<a name="ln4944">                  //             print-style, halign, valign</a>
<a name="ln4945"> </a>
<a name="ln4946">                  kindText = _e.attributes().value(&quot;text&quot;).toString();</a>
<a name="ln4947">                  symbols = _e.attributes().value(&quot;use-symbols&quot;).toString();</a>
<a name="ln4948">                  parens = _e.attributes().value(&quot;parentheses-degrees&quot;).toString();</a>
<a name="ln4949">                  kind = _e.readElementText();</a>
<a name="ln4950">                  }</a>
<a name="ln4951">            else if (_e.name() == &quot;inversion&quot;) {</a>
<a name="ln4952">                  // attributes: print-style</a>
<a name="ln4953">                  skipLogCurrElem();</a>
<a name="ln4954">                  }</a>
<a name="ln4955">            else if (_e.name() == &quot;bass&quot;) {</a>
<a name="ln4956">                  QString step;</a>
<a name="ln4957">                  int alter = 0;</a>
<a name="ln4958">                  while (_e.readNextStartElement()) {</a>
<a name="ln4959">                        if (_e.name() == &quot;bass-step&quot;) {</a>
<a name="ln4960">                              // attributes: print-style</a>
<a name="ln4961">                              step = _e.readElementText();</a>
<a name="ln4962">                              }</a>
<a name="ln4963">                        else if (_e.name() == &quot;bass-alter&quot;) {</a>
<a name="ln4964">                              // attributes: print-object, print-style</a>
<a name="ln4965">                              //             location (left-right)</a>
<a name="ln4966">                              alter = _e.readElementText().toInt();</a>
<a name="ln4967">                              }</a>
<a name="ln4968">                        else</a>
<a name="ln4969">                              skipLogCurrElem();</a>
<a name="ln4970">                        }</a>
<a name="ln4971">                  ha-&gt;setBaseTpc(step2tpc(step, AccidentalVal(alter)));</a>
<a name="ln4972">                  }</a>
<a name="ln4973">            else if (_e.name() == &quot;degree&quot;) {</a>
<a name="ln4974">                  int degreeValue = 0;</a>
<a name="ln4975">                  int degreeAlter = 0;</a>
<a name="ln4976">                  QString degreeType = &quot;&quot;;</a>
<a name="ln4977">                  while (_e.readNextStartElement()) {</a>
<a name="ln4978">                        if (_e.name() == &quot;degree-value&quot;) {</a>
<a name="ln4979">                              degreeValue = _e.readElementText().toInt();</a>
<a name="ln4980">                              }</a>
<a name="ln4981">                        else if (_e.name() == &quot;degree-alter&quot;) {</a>
<a name="ln4982">                              degreeAlter = _e.readElementText().toInt();</a>
<a name="ln4983">                              }</a>
<a name="ln4984">                        else if (_e.name() == &quot;degree-type&quot;) {</a>
<a name="ln4985">                              degreeType = _e.readElementText();</a>
<a name="ln4986">                              }</a>
<a name="ln4987">                        else</a>
<a name="ln4988">                              skipLogCurrElem();</a>
<a name="ln4989">                        }</a>
<a name="ln4990">                  if (degreeValue &lt;= 0 || degreeValue &gt; 13</a>
<a name="ln4991">                      || degreeAlter &lt; -2 || degreeAlter &gt; 2</a>
<a name="ln4992">                      || (degreeType != &quot;add&quot; &amp;&amp; degreeType != &quot;alter&quot; &amp;&amp; degreeType != &quot;subtract&quot;)) {</a>
<a name="ln4993">                        _logger-&gt;logError(QString(&quot;incorrect degree: degreeValue=%1 degreeAlter=%2 degreeType=%3&quot;)</a>
<a name="ln4994">                                          .arg(degreeValue).arg(degreeAlter).arg(degreeType), &amp;_e);</a>
<a name="ln4995">                        }</a>
<a name="ln4996">                  else {</a>
<a name="ln4997">                        if (degreeType == &quot;add&quot;)</a>
<a name="ln4998">                              degreeList &lt;&lt; HDegree(degreeValue, degreeAlter, HDegreeType::ADD);</a>
<a name="ln4999">                        else if (degreeType == &quot;alter&quot;)</a>
<a name="ln5000">                              degreeList &lt;&lt; HDegree(degreeValue, degreeAlter, HDegreeType::ALTER);</a>
<a name="ln5001">                        else if (degreeType == &quot;subtract&quot;)</a>
<a name="ln5002">                              degreeList &lt;&lt; HDegree(degreeValue, degreeAlter, HDegreeType::SUBTRACT);</a>
<a name="ln5003">                        }</a>
<a name="ln5004">                  }</a>
<a name="ln5005">            else if (_e.name() == &quot;frame&quot;)</a>
<a name="ln5006">                  fd = frame();</a>
<a name="ln5007">            else if (_e.name() == &quot;level&quot;)</a>
<a name="ln5008">                  skipLogCurrElem();</a>
<a name="ln5009">            else if (_e.name() == &quot;offset&quot;)</a>
<a name="ln5010">                  offset = calcTicks(_e.readElementText(), _divs, _logger, &amp;_e);</a>
<a name="ln5011">            else if (_e.name() == &quot;staff&quot;) {</a>
<a name="ln5012">                  int nstaves = _pass1.getPart(partId)-&gt;nstaves();</a>
<a name="ln5013">                  QString strStaff = _e.readElementText();</a>
<a name="ln5014">                  int staff = strStaff.toInt();</a>
<a name="ln5015">                  if (0 &lt; staff &amp;&amp; staff &lt;= nstaves)</a>
<a name="ln5016">                        track += (staff - 1) * VOICES;</a>
<a name="ln5017">                  else</a>
<a name="ln5018">                        _logger-&gt;logError(QString(&quot;invalid staff %1&quot;).arg(strStaff), &amp;_e);</a>
<a name="ln5019">                  }</a>
<a name="ln5020">            else</a>
<a name="ln5021">                  skipLogCurrElem();</a>
<a name="ln5022">            }</a>
<a name="ln5023"> </a>
<a name="ln5024">      if (fd) {</a>
<a name="ln5025">            fd-&gt;setTrack(track);</a>
<a name="ln5026">            Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, sTime + offset);</a>
<a name="ln5027">            s-&gt;add(fd);</a>
<a name="ln5028">            }</a>
<a name="ln5029"> </a>
<a name="ln5030">      const ChordDescription* d = 0;</a>
<a name="ln5031">      if (ha-&gt;rootTpc() != Tpc::TPC_INVALID)</a>
<a name="ln5032">            d = ha-&gt;fromXml(kind, kindText, symbols, parens, degreeList);</a>
<a name="ln5033">      if (d) {</a>
<a name="ln5034">            ha-&gt;setId(d-&gt;id);</a>
<a name="ln5035">            ha-&gt;setTextName(d-&gt;names.front());</a>
<a name="ln5036">            }</a>
<a name="ln5037">      else {</a>
<a name="ln5038">            ha-&gt;setId(-1);</a>
<a name="ln5039">            QString textName = functionText + kindText;</a>
<a name="ln5040">            ha-&gt;setTextName(textName);</a>
<a name="ln5041">            }</a>
<a name="ln5042">      ha-&gt;render();</a>
<a name="ln5043"> </a>
<a name="ln5044">      ha-&gt;setVisible(printObject);</a>
<a name="ln5045"> </a>
<a name="ln5046">      // TODO-LV: do this only if ha points to a valid harmony</a>
<a name="ln5047">      // harmony = ha;</a>
<a name="ln5048">      ha-&gt;setTrack(track);</a>
<a name="ln5049">      Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, sTime + offset);</a>
<a name="ln5050">      s-&gt;add(ha);</a>
<a name="ln5051">      }</a>
<a name="ln5052"> </a>
<a name="ln5053">//---------------------------------------------------------</a>
<a name="ln5054">//   beam</a>
<a name="ln5055">//---------------------------------------------------------</a>
<a name="ln5056"> </a>
<a name="ln5057">/**</a>
<a name="ln5058"> Parse the /score-partwise/part/measure/note/beam node.</a>
<a name="ln5059"> Sets beamMode in case of begin, continue or end beam number 1.</a>
<a name="ln5060"> */</a>
<a name="ln5061"> </a>
<a name="ln5062">void MusicXMLParserPass2::beam(Beam::Mode&amp; beamMode)</a>
<a name="ln5063">      {</a>
<a name="ln5064">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;beam&quot;);</a>
<a name="ln5065"> </a>
<a name="ln5066">      int beamNo = _e.attributes().value(&quot;number&quot;).toInt();</a>
<a name="ln5067"> </a>
<a name="ln5068">      if (beamNo == 1) {</a>
<a name="ln5069">            QString s = _e.readElementText();</a>
<a name="ln5070">            if (s == &quot;begin&quot;)</a>
<a name="ln5071">                  beamMode = Beam::Mode::BEGIN;</a>
<a name="ln5072">            else if (s == &quot;end&quot;)</a>
<a name="ln5073">                  beamMode = Beam::Mode::END;</a>
<a name="ln5074">            else if (s == &quot;continue&quot;)</a>
<a name="ln5075">                  beamMode = Beam::Mode::MID;</a>
<a name="ln5076">            else if (s == &quot;backward hook&quot;)</a>
<a name="ln5077">                  ;</a>
<a name="ln5078">            else if (s == &quot;forward hook&quot;)</a>
<a name="ln5079">                  ;</a>
<a name="ln5080">            else</a>
<a name="ln5081">                  _logger-&gt;logError(QString(&quot;unknown beam keyword '%1'&quot;).arg(s), &amp;_e);</a>
<a name="ln5082">            }</a>
<a name="ln5083">      else</a>
<a name="ln5084">            _e.skipCurrentElement();</a>
<a name="ln5085">      }</a>
<a name="ln5086"> </a>
<a name="ln5087">//---------------------------------------------------------</a>
<a name="ln5088">//   forward</a>
<a name="ln5089">//---------------------------------------------------------</a>
<a name="ln5090"> </a>
<a name="ln5091">/**</a>
<a name="ln5092"> Parse the /score-partwise/part/measure/note/forward node.</a>
<a name="ln5093"> */</a>
<a name="ln5094"> </a>
<a name="ln5095">void MusicXMLParserPass2::forward(Fraction&amp; dura)</a>
<a name="ln5096">      {</a>
<a name="ln5097">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;forward&quot;);</a>
<a name="ln5098"> </a>
<a name="ln5099">      while (_e.readNextStartElement()) {</a>
<a name="ln5100">            if (_e.name() == &quot;duration&quot;)</a>
<a name="ln5101">                  duration(dura);</a>
<a name="ln5102">            else if (_e.name() == &quot;staff&quot;)</a>
<a name="ln5103">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln5104">            else if (_e.name() == &quot;voice&quot;)</a>
<a name="ln5105">                  _e.skipCurrentElement();  // skip but don't log</a>
<a name="ln5106">            else</a>
<a name="ln5107">                  skipLogCurrElem();</a>
<a name="ln5108">            }</a>
<a name="ln5109">      }</a>
<a name="ln5110"> </a>
<a name="ln5111">//---------------------------------------------------------</a>
<a name="ln5112">//   backup</a>
<a name="ln5113">//---------------------------------------------------------</a>
<a name="ln5114"> </a>
<a name="ln5115">/**</a>
<a name="ln5116"> Parse the /score-partwise/part/measure/note/backup node.</a>
<a name="ln5117"> */</a>
<a name="ln5118"> </a>
<a name="ln5119">void MusicXMLParserPass2::backup(Fraction&amp; dura)</a>
<a name="ln5120">      {</a>
<a name="ln5121">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;backup&quot;);</a>
<a name="ln5122"> </a>
<a name="ln5123">      while (_e.readNextStartElement()) {</a>
<a name="ln5124">            if (_e.name() == &quot;duration&quot;)</a>
<a name="ln5125">                  duration(dura);</a>
<a name="ln5126">            else</a>
<a name="ln5127">                  skipLogCurrElem();</a>
<a name="ln5128">            }</a>
<a name="ln5129">      }</a>
<a name="ln5130"> </a>
<a name="ln5131">//---------------------------------------------------------</a>
<a name="ln5132">//   MusicXMLParserLyric</a>
<a name="ln5133">//---------------------------------------------------------</a>
<a name="ln5134"> </a>
<a name="ln5135">MusicXMLParserLyric::MusicXMLParserLyric(const LyricNumberHandler lyricNumberHandler,</a>
<a name="ln5136">                                         QXmlStreamReader&amp; e, Score* score, MxmlLogger* logger)</a>
<a name="ln5137">      : _lyricNumberHandler(lyricNumberHandler), _e(e), _score(score), _logger(logger)</a>
<a name="ln5138">      {</a>
<a name="ln5139">      // nothing</a>
<a name="ln5140">      }</a>
<a name="ln5141"> </a>
<a name="ln5142">//---------------------------------------------------------</a>
<a name="ln5143">//   skipLogCurrElem</a>
<a name="ln5144">//---------------------------------------------------------</a>
<a name="ln5145"> </a>
<a name="ln5146">/**</a>
<a name="ln5147"> Skip the current element, log debug as info.</a>
<a name="ln5148"> */</a>
<a name="ln5149"> </a>
<a name="ln5150">void MusicXMLParserLyric::skipLogCurrElem()</a>
<a name="ln5151">      {</a>
<a name="ln5152">      //_logger-&gt;logDebugInfo(QString(&quot;skipping '%1'&quot;).arg(_e.name().toString()), &amp;_e);</a>
<a name="ln5153">      _e.skipCurrentElement();</a>
<a name="ln5154">      }</a>
<a name="ln5155"> </a>
<a name="ln5156">//---------------------------------------------------------</a>
<a name="ln5157">//   parse</a>
<a name="ln5158">//---------------------------------------------------------</a>
<a name="ln5159"> </a>
<a name="ln5160">void MusicXMLParserLyric::parse()</a>
<a name="ln5161">      {</a>
<a name="ln5162">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;lyric&quot;);</a>
<a name="ln5163"> </a>
<a name="ln5164">      std::unique_ptr&lt;Lyrics&gt; lyric { new Lyrics(_score) };</a>
<a name="ln5165">      // TODO in addlyrics: l-&gt;setTrack(trk);</a>
<a name="ln5166"> </a>
<a name="ln5167">      bool hasExtend = false;</a>
<a name="ln5168">      const auto lyricNumber = _e.attributes().value(&quot;number&quot;).toString();</a>
<a name="ln5169">      QColor lyricColor { QColor::Invalid };</a>
<a name="ln5170">      lyricColor.setNamedColor(_e.attributes().value(&quot;color&quot;).toString());</a>
<a name="ln5171">      QString extendType;</a>
<a name="ln5172">      QString formattedText;</a>
<a name="ln5173"> </a>
<a name="ln5174">      while (_e.readNextStartElement()) {</a>
<a name="ln5175">            if (_e.name() == &quot;elision&quot;) {</a>
<a name="ln5176">                  // TODO verify elision handling</a>
<a name="ln5177">                  /*</a>
<a name="ln5178">                   QString text = _e.readElementText();</a>
<a name="ln5179">                   if (text.isEmpty())</a>
<a name="ln5180">                   formattedText += &quot; &quot;;</a>
<a name="ln5181">                   else</a>
<a name="ln5182">                   */</a>
<a name="ln5183">                  formattedText += nextPartOfFormattedString(_e);</a>
<a name="ln5184">                  }</a>
<a name="ln5185">            else if (_e.name() == &quot;extend&quot;) {</a>
<a name="ln5186">                  hasExtend = true;</a>
<a name="ln5187">                  extendType = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln5188">                  _e.readNext();</a>
<a name="ln5189">                  }</a>
<a name="ln5190">            else if (_e.name() == &quot;syllabic&quot;) {</a>
<a name="ln5191">                  auto syll = _e.readElementText();</a>
<a name="ln5192">                  if (syll == &quot;single&quot;)</a>
<a name="ln5193">                        lyric-&gt;setSyllabic(Lyrics::Syllabic::SINGLE);</a>
<a name="ln5194">                  else if (syll == &quot;begin&quot;)</a>
<a name="ln5195">                        lyric-&gt;setSyllabic(Lyrics::Syllabic::BEGIN);</a>
<a name="ln5196">                  else if (syll == &quot;end&quot;)</a>
<a name="ln5197">                        lyric-&gt;setSyllabic(Lyrics::Syllabic::END);</a>
<a name="ln5198">                  else if (syll == &quot;middle&quot;)</a>
<a name="ln5199">                        lyric-&gt;setSyllabic(Lyrics::Syllabic::MIDDLE);</a>
<a name="ln5200">                  else</a>
<a name="ln5201">                        qDebug(&quot;unknown syllabic %s&quot;, qPrintable(syll));              // TODO</a>
<a name="ln5202">                  }</a>
<a name="ln5203">            else if (_e.name() == &quot;text&quot;)</a>
<a name="ln5204">                  formattedText += nextPartOfFormattedString(_e);</a>
<a name="ln5205">            else</a>
<a name="ln5206">                  skipLogCurrElem();</a>
<a name="ln5207">            }</a>
<a name="ln5208"> </a>
<a name="ln5209">      // if no lyric read (e.g. only 'extend &quot;type=stop&quot;'), no further action required</a>
<a name="ln5210">      if (formattedText == &quot;&quot;) {</a>
<a name="ln5211">            return;</a>
<a name="ln5212">            }</a>
<a name="ln5213"> </a>
<a name="ln5214">      const auto lyricNo = _lyricNumberHandler.getLyricNo(lyricNumber);</a>
<a name="ln5215">      if (lyricNo &lt; 0) {</a>
<a name="ln5216">            _logger-&gt;logError(&quot;invalid lyrics number (&lt;0)&quot;, &amp;_e);</a>
<a name="ln5217">            return;</a>
<a name="ln5218">            }</a>
<a name="ln5219">      else if (lyricNo &gt; MAX_LYRICS) {</a>
<a name="ln5220">            _logger-&gt;logError(QString(&quot;too much lyrics (&gt;%1)&quot;).arg(MAX_LYRICS), &amp;_e);</a>
<a name="ln5221">            return;</a>
<a name="ln5222">            }</a>
<a name="ln5223">      else if (_numberedLyrics.contains(lyricNo)) {</a>
<a name="ln5224">            _logger-&gt;logError(QString(&quot;duplicate lyrics number (%1)&quot;).arg(lyricNumber), &amp;_e);</a>
<a name="ln5225">            return;</a>
<a name="ln5226">            }</a>
<a name="ln5227"> </a>
<a name="ln5228">      //qDebug(&quot;formatted lyric '%s'&quot;, qPrintable(formattedText));</a>
<a name="ln5229">      lyric-&gt;setXmlText(formattedText);</a>
<a name="ln5230">      if (lyricColor != QColor::Invalid)</a>
<a name="ln5231">            lyric-&gt;setColor(lyricColor);</a>
<a name="ln5232"> </a>
<a name="ln5233">      const auto l = lyric.release();</a>
<a name="ln5234">      _numberedLyrics[lyricNo] = l;</a>
<a name="ln5235"> </a>
<a name="ln5236">      if (hasExtend &amp;&amp; (extendType == &quot;&quot; || extendType == &quot;start&quot;))</a>
<a name="ln5237">            _extendedLyrics.insert(l);</a>
<a name="ln5238"> </a>
<a name="ln5239">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;lyric&quot;);</a>
<a name="ln5240">      }</a>
<a name="ln5241"> </a>
<a name="ln5242">//---------------------------------------------------------</a>
<a name="ln5243">//   slur</a>
<a name="ln5244">//---------------------------------------------------------</a>
<a name="ln5245"> </a>
<a name="ln5246">/**</a>
<a name="ln5247"> Parse the /score-partwise/part/measure/note/notations/slur node.</a>
<a name="ln5248"> */</a>
<a name="ln5249"> </a>
<a name="ln5250">void MusicXMLParserNotations::slur()</a>
<a name="ln5251">      {</a>
<a name="ln5252">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;slur&quot;);</a>
<a name="ln5253"> </a>
<a name="ln5254">      Notation notation { _e.name().toString() };</a>
<a name="ln5255">      for (const auto attr : _e.attributes()) {</a>
<a name="ln5256">            notation.addAttribute(attr.name(), attr.value());</a>
<a name="ln5257">            }</a>
<a name="ln5258">      _notations.push_back(notation);</a>
<a name="ln5259"> </a>
<a name="ln5260">      // any grace note containing a slur stop means</a>
<a name="ln5261">      // last note of a grace after set has been found</a>
<a name="ln5262">      // -&gt; remember slur stop</a>
<a name="ln5263">      if (_e.attributes().value(&quot;type&quot;) == &quot;stop&quot;) {</a>
<a name="ln5264">            _slurStop = true;</a>
<a name="ln5265">            }</a>
<a name="ln5266"> </a>
<a name="ln5267">      _e.readNext();</a>
<a name="ln5268"> </a>
<a name="ln5269">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;slur&quot;);</a>
<a name="ln5270">      }</a>
<a name="ln5271"> </a>
<a name="ln5272">//---------------------------------------------------------</a>
<a name="ln5273">//   addSlur</a>
<a name="ln5274">//---------------------------------------------------------</a>
<a name="ln5275"> </a>
<a name="ln5276">static void addSlur(const Notation&amp; notation, SlurStack&amp; slurs, ChordRest* cr, const int tick,</a>
<a name="ln5277">                    MxmlLogger* logger, const QXmlStreamReader* const xmlreader)</a>
<a name="ln5278">      {</a>
<a name="ln5279">      auto slurNo = notation.attribute(&quot;number&quot;).toInt();</a>
<a name="ln5280">      if (slurNo &gt; 0) slurNo--;</a>
<a name="ln5281">      const auto slurType = notation.attribute(&quot;type&quot;);</a>
<a name="ln5282">      auto lineType = notation.attribute(&quot;line-type&quot;);</a>
<a name="ln5283">      if (lineType == &quot;&quot;) lineType = &quot;solid&quot;;</a>
<a name="ln5284"> </a>
<a name="ln5285">      const auto track = cr-&gt;track();</a>
<a name="ln5286">      auto score = cr-&gt;score();</a>
<a name="ln5287"> </a>
<a name="ln5288">      // PriMus Music-Notation by Columbussoft (build 10093) generates overlapping</a>
<a name="ln5289">      // slurs that do not have a number attribute to distinguish them.</a>
<a name="ln5290">      // The duplicates must be ignored, to prevent memory allocation issues,</a>
<a name="ln5291">      // which caused a MuseScore crash</a>
<a name="ln5292">      // Similar issues happen with Sibelius 7.1.3 (direct export)</a>
<a name="ln5293"> </a>
<a name="ln5294">      if (slurType == &quot;start&quot;) {</a>
<a name="ln5295">            if (slurs[slurNo].isStart())</a>
<a name="ln5296">                  // slur start when slur already started: report error</a>
<a name="ln5297">                  logger-&gt;logError(QString(&quot;ignoring duplicate slur start&quot;), xmlreader);</a>
<a name="ln5298">            else if (slurs[slurNo].isStop()) {</a>
<a name="ln5299">                  // slur start when slur already stopped: wrap up</a>
<a name="ln5300">                  auto newSlur = slurs[slurNo].slur();</a>
<a name="ln5301">                  newSlur-&gt;setTick(Fraction::fromTicks(tick));</a>
<a name="ln5302">                  newSlur-&gt;setStartElement(cr);</a>
<a name="ln5303">                  slurs[slurNo] = SlurDesc();</a>
<a name="ln5304">                  }</a>
<a name="ln5305">            else {</a>
<a name="ln5306">                  // slur start for new slur: init</a>
<a name="ln5307">                  auto newSlur = new Slur(score);</a>
<a name="ln5308">                  if (cr-&gt;isGrace())</a>
<a name="ln5309">                        newSlur-&gt;setAnchor(Spanner::Anchor::CHORD);</a>
<a name="ln5310">                  if (lineType == &quot;dotted&quot;)</a>
<a name="ln5311">                        newSlur-&gt;setLineType(1);</a>
<a name="ln5312">                  else if (lineType == &quot;dashed&quot;)</a>
<a name="ln5313">                        newSlur-&gt;setLineType(2);</a>
<a name="ln5314">                  newSlur-&gt;setTick(Fraction::fromTicks(tick));</a>
<a name="ln5315">                  newSlur-&gt;setStartElement(cr);</a>
<a name="ln5316">                  const auto pl = notation.attribute(&quot;placement&quot;);</a>
<a name="ln5317">                  if (pl == &quot;above&quot;)</a>
<a name="ln5318">                        newSlur-&gt;setSlurDirection(Direction::UP);</a>
<a name="ln5319">                  else if (pl == &quot;below&quot;)</a>
<a name="ln5320">                        newSlur-&gt;setSlurDirection(Direction::DOWN);</a>
<a name="ln5321">                  newSlur-&gt;setTrack(track);</a>
<a name="ln5322">                  newSlur-&gt;setTrack2(track);</a>
<a name="ln5323">                  slurs[slurNo].start(newSlur);</a>
<a name="ln5324">                  score-&gt;addElement(newSlur);</a>
<a name="ln5325">                  }</a>
<a name="ln5326">            }</a>
<a name="ln5327">      else if (slurType == &quot;stop&quot;) {</a>
<a name="ln5328">            if (slurs[slurNo].isStart()) {</a>
<a name="ln5329">                  // slur stop when slur already started: wrap up</a>
<a name="ln5330">                  auto newSlur = slurs[slurNo].slur();</a>
<a name="ln5331">                  if (!(cr-&gt;isGrace())) {</a>
<a name="ln5332">                        newSlur-&gt;setTick2(Fraction::fromTicks(tick));</a>
<a name="ln5333">                        newSlur-&gt;setTrack2(track);</a>
<a name="ln5334">                        }</a>
<a name="ln5335">                  newSlur-&gt;setEndElement(cr);</a>
<a name="ln5336">                  slurs[slurNo] = SlurDesc();</a>
<a name="ln5337">                  }</a>
<a name="ln5338">            else if (slurs[slurNo].isStop())</a>
<a name="ln5339">                  // slur stop when slur already stopped: report error</a>
<a name="ln5340">                  logger-&gt;logError(QString(&quot;ignoring duplicate slur stop&quot;), xmlreader);</a>
<a name="ln5341">            else {</a>
<a name="ln5342">                  // slur stop for new slur: init</a>
<a name="ln5343">                  auto newSlur = new Slur(score);</a>
<a name="ln5344">                  if (!(cr-&gt;isGrace())) {</a>
<a name="ln5345">                        newSlur-&gt;setTick2(Fraction::fromTicks(tick));</a>
<a name="ln5346">                        newSlur-&gt;setTrack2(track);</a>
<a name="ln5347">                        }</a>
<a name="ln5348">                  newSlur-&gt;setEndElement(cr);</a>
<a name="ln5349">                  slurs[slurNo].stop(newSlur);</a>
<a name="ln5350">                  }</a>
<a name="ln5351">            }</a>
<a name="ln5352">      else if (slurType == &quot;continue&quot;)</a>
<a name="ln5353">            ;        // ignore</a>
<a name="ln5354">      else</a>
<a name="ln5355">            logger-&gt;logError(QString(&quot;unknown slur type %1&quot;).arg(slurType), xmlreader);</a>
<a name="ln5356">      }</a>
<a name="ln5357"> </a>
<a name="ln5358">//---------------------------------------------------------</a>
<a name="ln5359">//   tied</a>
<a name="ln5360">//---------------------------------------------------------</a>
<a name="ln5361"> </a>
<a name="ln5362"> </a>
<a name="ln5363">/**</a>
<a name="ln5364"> Parse the /score-partwise/part/measure/note/notations/tied node.</a>
<a name="ln5365"> */</a>
<a name="ln5366"> </a>
<a name="ln5367">void MusicXMLParserNotations::tied()</a>
<a name="ln5368">      {</a>
<a name="ln5369">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;tied&quot;);</a>
<a name="ln5370"> </a>
<a name="ln5371">      _tiedType = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln5372">      _tiedOrientation = _e.attributes().value(&quot;orientation&quot;).toString();</a>
<a name="ln5373">      _tiedLineType  = _e.attributes().value(&quot;line-type&quot;).toString();</a>
<a name="ln5374">      if (_tiedType != &quot;start&quot; &amp;&amp; _tiedType != &quot;stop&quot;) {</a>
<a name="ln5375">            _logger-&gt;logError(QString(&quot;unknown tied type %1&quot;).arg(_tiedType), &amp;_e);</a>
<a name="ln5376">            }</a>
<a name="ln5377"> </a>
<a name="ln5378">      _e.readNext();</a>
<a name="ln5379"> </a>
<a name="ln5380">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;tied&quot;);</a>
<a name="ln5381"> </a>
<a name="ln5382">      }</a>
<a name="ln5383"> </a>
<a name="ln5384">//---------------------------------------------------------</a>
<a name="ln5385">//   dynamics</a>
<a name="ln5386">//---------------------------------------------------------</a>
<a name="ln5387"> </a>
<a name="ln5388">/**</a>
<a name="ln5389"> Parse the /score-partwise/part/measure/note/notations/dynamics node.</a>
<a name="ln5390"> */</a>
<a name="ln5391"> </a>
<a name="ln5392">void MusicXMLParserNotations::dynamics()</a>
<a name="ln5393">      {</a>
<a name="ln5394">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;dynamics&quot;);</a>
<a name="ln5395"> </a>
<a name="ln5396">      _dynamicsPlacement = _e.attributes().value(&quot;placement&quot;).toString();</a>
<a name="ln5397"> </a>
<a name="ln5398">      while (_e.readNextStartElement()) {</a>
<a name="ln5399">            if (_e.name() == &quot;other-dynamics&quot;)</a>
<a name="ln5400">                  _dynamicsList.push_back(_e.readElementText());</a>
<a name="ln5401">            else {</a>
<a name="ln5402">                  _dynamicsList.push_back(_e.name().toString());</a>
<a name="ln5403">                  _e.readNext();</a>
<a name="ln5404">                  }</a>
<a name="ln5405">            }</a>
<a name="ln5406"> </a>
<a name="ln5407">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;dynamics&quot;);</a>
<a name="ln5408">      }</a>
<a name="ln5409"> </a>
<a name="ln5410">//---------------------------------------------------------</a>
<a name="ln5411">//   articulations</a>
<a name="ln5412">//---------------------------------------------------------</a>
<a name="ln5413"> </a>
<a name="ln5414">/**</a>
<a name="ln5415"> Parse the /score-partwise/part/measure/note/notations/articulations node.</a>
<a name="ln5416"> Note that some notations attach to notes only in MuseScore,</a>
<a name="ln5417"> which means trying to attach them to a rest will crash,</a>
<a name="ln5418"> as in that case note is 0.</a>
<a name="ln5419"> */</a>
<a name="ln5420"> </a>
<a name="ln5421">void MusicXMLParserNotations::articulations()</a>
<a name="ln5422">      {</a>
<a name="ln5423">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;articulations&quot;);</a>
<a name="ln5424"> </a>
<a name="ln5425">      while (_e.readNextStartElement()) {</a>
<a name="ln5426">            SymId id { SymId::noSym };</a>
<a name="ln5427">            if (convertArticulationToSymId(_e.name().toString(), id)) {</a>
<a name="ln5428">                  _articulationSymbols.push_back(id);</a>
<a name="ln5429">                  _e.readNext();</a>
<a name="ln5430">                  continue;</a>
<a name="ln5431">                  }</a>
<a name="ln5432">            else if (_e.name() == &quot;breath-mark&quot;) {</a>
<a name="ln5433">                  _breath = SymId::breathMarkComma;</a>
<a name="ln5434">                  _e.readElementText();</a>
<a name="ln5435">                  // TODO: handle value read (note: encoding unknown, only &quot;comma&quot; found)</a>
<a name="ln5436">                  }</a>
<a name="ln5437">            else if (_e.name() == &quot;caesura&quot;) {</a>
<a name="ln5438">                  _breath = SymId::caesura;</a>
<a name="ln5439">                  _e.readNext();</a>
<a name="ln5440">                  }</a>
<a name="ln5441">            else if (_e.name() == &quot;doit&quot;</a>
<a name="ln5442">                     || _e.name() == &quot;falloff&quot;</a>
<a name="ln5443">                     || _e.name() == &quot;plop&quot;</a>
<a name="ln5444">                     || _e.name() == &quot;scoop&quot;) {</a>
<a name="ln5445">                  _chordLineType = _e.name().toString();</a>
<a name="ln5446">                  _e.readNext();</a>
<a name="ln5447">                  }</a>
<a name="ln5448">            else if (_e.name() == &quot;strong-accent&quot;) {</a>
<a name="ln5449">                  _strongAccentType = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln5450">                  if (_strongAccentType == &quot;&quot;) {</a>
<a name="ln5451">                        _strongAccentType = &quot;up&quot;;</a>
<a name="ln5452">                        }</a>
<a name="ln5453">                  else if (_strongAccentType != &quot;down&quot;) {</a>
<a name="ln5454">                        _logger-&gt;logError(QString(&quot;unknown mercato type %1&quot;).arg(_strongAccentType), &amp;_e);</a>
<a name="ln5455">                        }</a>
<a name="ln5456">                  _e.readNext();</a>
<a name="ln5457">                  }</a>
<a name="ln5458">            else {</a>
<a name="ln5459">                  skipLogCurrElem();</a>
<a name="ln5460">                  }</a>
<a name="ln5461">            }</a>
<a name="ln5462">      //qDebug(&quot;::notations tokenString '%s' name '%s'&quot;, qPrintable(_e.tokenString()), qPrintable(_e.name().toString()));</a>
<a name="ln5463"> </a>
<a name="ln5464">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;articulations&quot;);</a>
<a name="ln5465">      }</a>
<a name="ln5466"> </a>
<a name="ln5467">//---------------------------------------------------------</a>
<a name="ln5468">//   addStrongAccent</a>
<a name="ln5469">//---------------------------------------------------------</a>
<a name="ln5470"> </a>
<a name="ln5471">static void addStrongAccent(ChordRest* cr, const QString&amp; upDown)</a>
<a name="ln5472">      {</a>
<a name="ln5473">      if (upDown == &quot;up&quot;)</a>
<a name="ln5474">            addArticulationToChord(cr, SymId::articMarcatoAbove, &quot;up&quot;);</a>
<a name="ln5475">      else if (upDown == &quot;down&quot;)</a>
<a name="ln5476">            addArticulationToChord(cr, SymId::articMarcatoAbove, &quot;down&quot;);</a>
<a name="ln5477">      }</a>
<a name="ln5478"> </a>
<a name="ln5479">//---------------------------------------------------------</a>
<a name="ln5480">//   ornaments</a>
<a name="ln5481">//---------------------------------------------------------</a>
<a name="ln5482"> </a>
<a name="ln5483">/**</a>
<a name="ln5484"> Parse the /score-partwise/part/measure/note/notations/ornaments node.</a>
<a name="ln5485"> */</a>
<a name="ln5486"> </a>
<a name="ln5487">void MusicXMLParserNotations::ornaments()</a>
<a name="ln5488">      {</a>
<a name="ln5489">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;ornaments&quot;);</a>
<a name="ln5490"> </a>
<a name="ln5491">      bool trillMark = false;</a>
<a name="ln5492">      // &lt;trill-mark placement=&quot;above&quot;/&gt;</a>
<a name="ln5493">      while (_e.readNextStartElement()) {</a>
<a name="ln5494">            SymId id { SymId::noSym };</a>
<a name="ln5495">            if (convertArticulationToSymId(_e.name().toString(), id)) {</a>
<a name="ln5496">                  _articulationSymbols.push_back(id);</a>
<a name="ln5497">                  _e.readNext();</a>
<a name="ln5498">                  continue;</a>
<a name="ln5499">                  }</a>
<a name="ln5500">            else if (_e.name() == &quot;trill-mark&quot;) {</a>
<a name="ln5501">                  trillMark = true;</a>
<a name="ln5502">                  _e.readNext();</a>
<a name="ln5503">                  }</a>
<a name="ln5504">            else if (_e.name() == &quot;wavy-line&quot;) {</a>
<a name="ln5505">                  auto wavyLineTypeWasStart = (_wavyLineType == &quot;start&quot;);</a>
<a name="ln5506">                  _wavyLineType = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln5507">                  _wavyLineNo   = _e.attributes().value(&quot;number&quot;).toString().toInt();</a>
<a name="ln5508">                  if (_wavyLineNo &gt; 0) _wavyLineNo--;</a>
<a name="ln5509">                  // any grace note containing a wavy-line stop means</a>
<a name="ln5510">                  // last note of a grace after set has been found</a>
<a name="ln5511">                  // remember wavy-line stop</a>
<a name="ln5512">                  if (_wavyLineType == &quot;stop&quot;) {</a>
<a name="ln5513">                        _wavyLineStop = true;</a>
<a name="ln5514">                        }</a>
<a name="ln5515">                  // check for start and stop on same note</a>
<a name="ln5516">                  if (wavyLineTypeWasStart &amp;&amp; _wavyLineType == &quot;stop&quot;) {</a>
<a name="ln5517">                        _wavyLineType = &quot;startstop&quot;;</a>
<a name="ln5518">                        }</a>
<a name="ln5519">                  _e.readNext();</a>
<a name="ln5520">                  }</a>
<a name="ln5521">            else if (_e.name() == &quot;tremolo&quot;) {</a>
<a name="ln5522">                  _tremoloType = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln5523">                  _tremoloNr = _e.readElementText().toInt();</a>
<a name="ln5524">                  }</a>
<a name="ln5525">            else if (_e.name() == &quot;delayed-turn&quot;) {</a>
<a name="ln5526">                  // TODO: actually this should be offset a bit to the right</a>
<a name="ln5527">                  _articulationSymbols.push_back(SymId::ornamentTurn);</a>
<a name="ln5528">                  _e.readNext();</a>
<a name="ln5529">                  }</a>
<a name="ln5530">            else if (_e.name() == &quot;inverted-mordent&quot;</a>
<a name="ln5531">                     || _e.name() == &quot;mordent&quot;) {</a>
<a name="ln5532">                  mordentNormalOrInverted();</a>
<a name="ln5533">                  _e.readNext();</a>
<a name="ln5534">                  }</a>
<a name="ln5535">            else {</a>
<a name="ln5536">                  skipLogCurrElem();</a>
<a name="ln5537">                  }</a>
<a name="ln5538">            }</a>
<a name="ln5539"> </a>
<a name="ln5540">      // note that mscore wavy line already implicitly includes a trillsym</a>
<a name="ln5541">      // so don't add an additional one</a>
<a name="ln5542">      if (trillMark &amp;&amp; _wavyLineType != &quot;start&quot; &amp;&amp; _wavyLineType != &quot;startstop&quot;)</a>
<a name="ln5543">            _articulationSymbols.push_back(SymId::ornamentTrill);</a>
<a name="ln5544">      }</a>
<a name="ln5545"> </a>
<a name="ln5546">//---------------------------------------------------------</a>
<a name="ln5547">//   technical</a>
<a name="ln5548">//---------------------------------------------------------</a>
<a name="ln5549"> </a>
<a name="ln5550">/**</a>
<a name="ln5551"> Parse the /score-partwise/part/measure/note/notations/technical node.</a>
<a name="ln5552"> */</a>
<a name="ln5553"> </a>
<a name="ln5554">void MusicXMLParserNotations::technical()</a>
<a name="ln5555">      {</a>
<a name="ln5556">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;technical&quot;);</a>
<a name="ln5557"> </a>
<a name="ln5558">      while (_e.readNextStartElement()) {</a>
<a name="ln5559">            SymId id { SymId::noSym };</a>
<a name="ln5560">            if (convertArticulationToSymId(_e.name().toString(), id)) {</a>
<a name="ln5561">                  _articulationSymbols.push_back(id);</a>
<a name="ln5562">                  _e.readNext();</a>
<a name="ln5563">                  continue;</a>
<a name="ln5564">                  }</a>
<a name="ln5565">            else if (_e.name() == &quot;fingering&quot;) {</a>
<a name="ln5566">                  _technicalFingering = _e.readElementText();</a>
<a name="ln5567">                  }</a>
<a name="ln5568">            else if (_e.name() == &quot;fret&quot;) {</a>
<a name="ln5569">                  _technicalFret = _e.readElementText();</a>
<a name="ln5570">                  }</a>
<a name="ln5571">            else if (_e.name() == &quot;pluck&quot;) {</a>
<a name="ln5572">                  _technicalPluck = _e.readElementText();</a>
<a name="ln5573">                  }</a>
<a name="ln5574">            else if (_e.name() == &quot;string&quot;) {</a>
<a name="ln5575">                  _technicalString = _e.readElementText();</a>
<a name="ln5576">                  }</a>
<a name="ln5577">            else {</a>
<a name="ln5578">                  skipLogCurrElem();</a>
<a name="ln5579">                  }</a>
<a name="ln5580">            }</a>
<a name="ln5581">      }</a>
<a name="ln5582"> </a>
<a name="ln5583">//---------------------------------------------------------</a>
<a name="ln5584">//   addTechnical</a>
<a name="ln5585">//---------------------------------------------------------</a>
<a name="ln5586"> </a>
<a name="ln5587">void MusicXMLParserNotations::addTechnical(Note* note)</a>
<a name="ln5588">      {</a>
<a name="ln5589">      if (_technicalFingering != &quot;&quot;) {</a>
<a name="ln5590">            // TODO: distinguish between keyboards (style Tid::FINGERING)</a>
<a name="ln5591">            // and (plucked) strings (style Tid::LH_GUITAR_FINGERING)</a>
<a name="ln5592">            addTextToNote(_e.lineNumber(), _e.columnNumber(), _technicalFingering,</a>
<a name="ln5593">                          Tid::FINGERING, _score, note);</a>
<a name="ln5594">            }</a>
<a name="ln5595">      else if (_technicalFret != &quot;&quot;) {</a>
<a name="ln5596">            auto fret = _technicalFret.toInt();</a>
<a name="ln5597">            if (note) {</a>
<a name="ln5598">                  if (note-&gt;staff()-&gt;isTabStaff(Fraction(0,1)))</a>
<a name="ln5599">                        note-&gt;setFret(fret);</a>
<a name="ln5600">                  }</a>
<a name="ln5601">            else</a>
<a name="ln5602">                  _logger-&gt;logError(&quot;no note for fret&quot;, &amp;_e);</a>
<a name="ln5603">            }</a>
<a name="ln5604">      else if (_technicalPluck != &quot;&quot;) {</a>
<a name="ln5605">            addTextToNote(_e.lineNumber(), _e.columnNumber(), _technicalPluck,</a>
<a name="ln5606">                          Tid::RH_GUITAR_FINGERING, _score, note);</a>
<a name="ln5607">            }</a>
<a name="ln5608">      else if (_technicalString != &quot;&quot;) {</a>
<a name="ln5609">            if (note) {</a>
<a name="ln5610">                  if (note-&gt;staff()-&gt;isTabStaff(Fraction(0,1)))</a>
<a name="ln5611">                        note-&gt;setString(_technicalString.toInt() - 1);</a>
<a name="ln5612">                  else</a>
<a name="ln5613">                        addTextToNote(_e.lineNumber(), _e.columnNumber(), _technicalString,</a>
<a name="ln5614">                                      Tid::STRING_NUMBER, _score, note);</a>
<a name="ln5615">                  }</a>
<a name="ln5616">            else</a>
<a name="ln5617">                  _logger-&gt;logError(&quot;no note for string&quot;, &amp;_e);</a>
<a name="ln5618">            }</a>
<a name="ln5619">      }</a>
<a name="ln5620"> </a>
<a name="ln5621">//---------------------------------------------------------</a>
<a name="ln5622">//   mordentNormalOrInverted</a>
<a name="ln5623">//---------------------------------------------------------</a>
<a name="ln5624"> </a>
<a name="ln5625">/**</a>
<a name="ln5626"> Parse the /score-partwise/part/measure/note/notations/ornaments/mordent</a>
<a name="ln5627"> and /score-partwise/part/measure/note/notations/ornaments/inverted-mordent nodes.</a>
<a name="ln5628"> */</a>
<a name="ln5629"> </a>
<a name="ln5630">void MusicXMLParserNotations::mordentNormalOrInverted()</a>
<a name="ln5631">      {</a>
<a name="ln5632">      Q_ASSERT(_e.isStartElement() &amp;&amp; (_e.name() == &quot;mordent&quot; || _e.name() == &quot;inverted-mordent&quot;));</a>
<a name="ln5633"> </a>
<a name="ln5634">      Notation notation { _e.name().toString() };</a>
<a name="ln5635">      for (const auto attr : _e.attributes()) {</a>
<a name="ln5636">            notation.addAttribute(attr.name(), attr.value());</a>
<a name="ln5637">            }</a>
<a name="ln5638">      notation.setText(_e.readElementText());</a>
<a name="ln5639">      _notations.push_back(notation);</a>
<a name="ln5640"> </a>
<a name="ln5641">      Q_ASSERT(_e.isEndElement() &amp;&amp; (_e.name() == &quot;mordent&quot; || _e.name() == &quot;inverted-mordent&quot;));</a>
<a name="ln5642">      }</a>
<a name="ln5643"> </a>
<a name="ln5644">//---------------------------------------------------------</a>
<a name="ln5645">//   glissandoSlide</a>
<a name="ln5646">//---------------------------------------------------------</a>
<a name="ln5647"> </a>
<a name="ln5648">/**</a>
<a name="ln5649"> Parse the /score-partwise/part/measure/note/notations/glissando</a>
<a name="ln5650"> and /score-partwise/part/measure/note/notations/slide nodes.</a>
<a name="ln5651"> */</a>
<a name="ln5652"> </a>
<a name="ln5653">void MusicXMLParserNotations::glissandoSlide()</a>
<a name="ln5654">      {</a>
<a name="ln5655">      Q_ASSERT(_e.isStartElement() &amp;&amp; (_e.name() == &quot;glissando&quot; || _e.name() == &quot;slide&quot;));</a>
<a name="ln5656"> </a>
<a name="ln5657">      Notation notation { _e.name().toString() };</a>
<a name="ln5658">      for (const auto attr : _e.attributes()) {</a>
<a name="ln5659">            notation.addAttribute(attr.name(), attr.value());</a>
<a name="ln5660">            }</a>
<a name="ln5661">      notation.setText(_e.readElementText());</a>
<a name="ln5662">      _notations.push_back(notation);</a>
<a name="ln5663"> </a>
<a name="ln5664">      Q_ASSERT(_e.isEndElement() &amp;&amp; (_e.name() == &quot;glissando&quot; || _e.name() == &quot;slide&quot;));</a>
<a name="ln5665">      }</a>
<a name="ln5666"> </a>
<a name="ln5667">//---------------------------------------------------------</a>
<a name="ln5668">//   addGlissandoSlide</a>
<a name="ln5669">//---------------------------------------------------------</a>
<a name="ln5670"> </a>
<a name="ln5671">static void addGlissandoSlide(const Notation&amp; notation, Note* note,</a>
<a name="ln5672">                              Glissando* glissandi[MAX_NUMBER_LEVEL][2], MusicXmlSpannerMap&amp; spanners,</a>
<a name="ln5673">                              MxmlLogger* logger, const QXmlStreamReader* const xmlreader)</a>
<a name="ln5674">      {</a>
<a name="ln5675">      auto glissandoNumber = notation.attribute(&quot;number&quot;).toInt();</a>
<a name="ln5676">      if (glissandoNumber &gt; 0) glissandoNumber--;</a>
<a name="ln5677">      const auto glissandoType = notation.attribute(&quot;type&quot;);</a>
<a name="ln5678">      int glissandoTag = notation.name() == &quot;slide&quot; ? 0 : 1;</a>
<a name="ln5679">      //                  QString lineType  = ee.attribute(QString(&quot;line-type&quot;), &quot;solid&quot;);</a>
<a name="ln5680">      Glissando*&amp; gliss = glissandi[glissandoNumber][glissandoTag];</a>
<a name="ln5681"> </a>
<a name="ln5682">      const auto tick = note-&gt;tick();</a>
<a name="ln5683">      const auto track = note-&gt;track();</a>
<a name="ln5684">      auto score = note-&gt;score();</a>
<a name="ln5685"> </a>
<a name="ln5686">      if (glissandoType == &quot;start&quot;) {</a>
<a name="ln5687">            const QColor glissandoColor { notation.attribute(&quot;color&quot;) };</a>
<a name="ln5688">            const auto glissandoText = notation.text();</a>
<a name="ln5689">            if (gliss) {</a>
<a name="ln5690">                  logger-&gt;logError(QString(&quot;overlapping glissando/slide number %1&quot;).arg(glissandoNumber+1), xmlreader);</a>
<a name="ln5691">                  }</a>
<a name="ln5692">            else if (!note) {</a>
<a name="ln5693">                  logger-&gt;logError(QString(&quot;no note for glissando/slide number %1 start&quot;).arg(glissandoNumber+1), xmlreader);</a>
<a name="ln5694">                  }</a>
<a name="ln5695">            else {</a>
<a name="ln5696">                  gliss = new Glissando(score);</a>
<a name="ln5697">                  gliss-&gt;setAnchor(Spanner::Anchor::NOTE);</a>
<a name="ln5698">                  gliss-&gt;setStartElement(note);</a>
<a name="ln5699">                  gliss-&gt;setTick(tick);</a>
<a name="ln5700">                  gliss-&gt;setTrack(track);</a>
<a name="ln5701">                  gliss-&gt;setParent(note);</a>
<a name="ln5702">                  if (glissandoColor.isValid())</a>
<a name="ln5703">                        gliss-&gt;setColor(glissandoColor);</a>
<a name="ln5704">                  gliss-&gt;setText(glissandoText);</a>
<a name="ln5705">                  gliss-&gt;setGlissandoType(glissandoTag == 0 ? GlissandoType::STRAIGHT : GlissandoType::WAVY);</a>
<a name="ln5706">                  spanners[gliss] = QPair&lt;int, int&gt;(tick.ticks(), -1);</a>
<a name="ln5707">                  // qDebug(&quot;glissando/slide=%p inserted at first tick %d&quot;, gliss, tick);</a>
<a name="ln5708">                  }</a>
<a name="ln5709">            }</a>
<a name="ln5710">      else if (glissandoType == &quot;stop&quot;) {</a>
<a name="ln5711">            if (!gliss) {</a>
<a name="ln5712">                  logger-&gt;logError(QString(&quot;glissando/slide number %1 stop without start&quot;).arg(glissandoNumber+1), xmlreader);</a>
<a name="ln5713">                  }</a>
<a name="ln5714">            else if (!note) {</a>
<a name="ln5715">                  logger-&gt;logError(QString(&quot;no note for glissando/slide number %1 stop&quot;).arg(glissandoNumber+1), xmlreader);</a>
<a name="ln5716">                  }</a>
<a name="ln5717">            else {</a>
<a name="ln5718">                  spanners[gliss].second = tick.ticks() + note-&gt;chord()-&gt;ticks().ticks();;</a>
<a name="ln5719">                  gliss-&gt;setEndElement(note);</a>
<a name="ln5720">                  gliss-&gt;setTick2(tick);</a>
<a name="ln5721">                  gliss-&gt;setTrack2(track);</a>
<a name="ln5722">                  // qDebug(&quot;glissando/slide=%p second tick %d&quot;, gliss, tick);</a>
<a name="ln5723">                  gliss = nullptr;</a>
<a name="ln5724">                  }</a>
<a name="ln5725">            }</a>
<a name="ln5726">      else</a>
<a name="ln5727">            logger-&gt;logError(QString(&quot;unknown glissando/slide type %1&quot;).arg(glissandoType), xmlreader);</a>
<a name="ln5728">      }</a>
<a name="ln5729"> </a>
<a name="ln5730">//---------------------------------------------------------</a>
<a name="ln5731">//   addArpeggio</a>
<a name="ln5732">//---------------------------------------------------------</a>
<a name="ln5733"> </a>
<a name="ln5734">static void addArpeggio(ChordRest* cr, const QString&amp; arpeggioType,</a>
<a name="ln5735">                        MxmlLogger* logger, const QXmlStreamReader* const xmlreader)</a>
<a name="ln5736">      {</a>
<a name="ln5737">      // no support for arpeggio on rest</a>
<a name="ln5738">      if (!arpeggioType.isEmpty() &amp;&amp; cr-&gt;type() == ElementType::CHORD) {</a>
<a name="ln5739">            std::unique_ptr&lt;Arpeggio&gt; arpeggio { new Arpeggio(cr-&gt;score()) };</a>
<a name="ln5740">            arpeggio-&gt;setArpeggioType(ArpeggioType::NORMAL);</a>
<a name="ln5741">            if (arpeggioType == &quot;up&quot;)</a>
<a name="ln5742">                  arpeggio-&gt;setArpeggioType(ArpeggioType::UP);</a>
<a name="ln5743">            else if (arpeggioType == &quot;down&quot;)</a>
<a name="ln5744">                  arpeggio-&gt;setArpeggioType(ArpeggioType::DOWN);</a>
<a name="ln5745">            else if (arpeggioType == &quot;non-arpeggiate&quot;)</a>
<a name="ln5746">                  arpeggio-&gt;setArpeggioType(ArpeggioType::BRACKET);</a>
<a name="ln5747">            else {</a>
<a name="ln5748">                  logger-&gt;logError(QString(&quot;unknown arpeggio type %1&quot;).arg(arpeggioType), xmlreader);</a>
<a name="ln5749">                  }</a>
<a name="ln5750">            // there can be only one</a>
<a name="ln5751">            if (!(static_cast&lt;Chord*&gt;(cr))-&gt;arpeggio()) {</a>
<a name="ln5752">                  cr-&gt;add(arpeggio.release());</a>
<a name="ln5753">                  }</a>
<a name="ln5754">            }</a>
<a name="ln5755">      }</a>
<a name="ln5756"> </a>
<a name="ln5757">//---------------------------------------------------------</a>
<a name="ln5758">//   addTie</a>
<a name="ln5759">//---------------------------------------------------------</a>
<a name="ln5760"> </a>
<a name="ln5761">static void addTie(Score* score, Note* note, const int track,</a>
<a name="ln5762">                   const QString&amp; type, const QString&amp; orientation, const QString&amp; lineType,</a>
<a name="ln5763">                   Tie*&amp; tie, MxmlLogger* logger, const QXmlStreamReader* const xmlreader)</a>
<a name="ln5764">      {</a>
<a name="ln5765">      Q_ASSERT(note);</a>
<a name="ln5766"> </a>
<a name="ln5767">      if (type == &quot;&quot;) {</a>
<a name="ln5768">            // ignore, nothing to do</a>
<a name="ln5769">            }</a>
<a name="ln5770">      else if (type == &quot;start&quot;) {</a>
<a name="ln5771">            if (tie) {</a>
<a name="ln5772">                  logger-&gt;logError(QString(&quot;Tie already active&quot;), xmlreader);</a>
<a name="ln5773">                  }</a>
<a name="ln5774">            tie = new Tie(score);</a>
<a name="ln5775">            note-&gt;setTieFor(tie);</a>
<a name="ln5776">            tie-&gt;setStartNote(note);</a>
<a name="ln5777">            tie-&gt;setTrack(track);</a>
<a name="ln5778"> </a>
<a name="ln5779">            if (orientation == &quot;over&quot;)</a>
<a name="ln5780">                  tie-&gt;setSlurDirection(Direction::UP);</a>
<a name="ln5781">            else if (orientation == &quot;under&quot;)</a>
<a name="ln5782">                  tie-&gt;setSlurDirection(Direction::DOWN);</a>
<a name="ln5783">            else if (orientation == &quot;auto&quot;)</a>
<a name="ln5784">                  ;                    // ignore</a>
<a name="ln5785">            else if (orientation == &quot;&quot;)</a>
<a name="ln5786">                  ;                    // ignore</a>
<a name="ln5787">            else</a>
<a name="ln5788">                  logger-&gt;logError(QString(&quot;unknown tied orientation: %1&quot;).arg(orientation), xmlreader);</a>
<a name="ln5789"> </a>
<a name="ln5790">            if (lineType == &quot;dotted&quot;)</a>
<a name="ln5791">                  tie-&gt;setLineType(1);</a>
<a name="ln5792">            else if (lineType == &quot;dashed&quot;)</a>
<a name="ln5793">                  tie-&gt;setLineType(2);</a>
<a name="ln5794">            tie = nullptr;</a>
<a name="ln5795">            }</a>
<a name="ln5796">      else if (type == &quot;stop&quot;)</a>
<a name="ln5797">            ;              // ignore</a>
<a name="ln5798">      else</a>
<a name="ln5799">            logger-&gt;logError(QString(&quot;unknown tied type %1&quot;).arg(type), xmlreader);</a>
<a name="ln5800">      }</a>
<a name="ln5801"> </a>
<a name="ln5802">//---------------------------------------------------------</a>
<a name="ln5803">//   addWavyLine</a>
<a name="ln5804">//---------------------------------------------------------</a>
<a name="ln5805"> </a>
<a name="ln5806">static void addWavyLine(ChordRest* cr, const Fraction&amp; tick,</a>
<a name="ln5807">                        const int wavyLineNo, const QString&amp; wavyLineType,</a>
<a name="ln5808">                        MusicXmlSpannerMap&amp; spanners, TrillStack&amp; trills,</a>
<a name="ln5809">                        MxmlLogger* logger, const QXmlStreamReader* const xmlreader)</a>
<a name="ln5810">      {</a>
<a name="ln5811">      if (!wavyLineType.isEmpty()) {</a>
<a name="ln5812">            const auto ticks = cr-&gt;ticks();</a>
<a name="ln5813">            const auto track = cr-&gt;track();</a>
<a name="ln5814">            const auto trk = (track / VOICES) * VOICES;       // first track of staff</a>
<a name="ln5815">            Trill*&amp; trill = trills[wavyLineNo];</a>
<a name="ln5816">            if (wavyLineType == &quot;start&quot; || wavyLineType == &quot;startstop&quot;) {</a>
<a name="ln5817">                  if (trill) {</a>
<a name="ln5818">                        logger-&gt;logError(QString(&quot;overlapping wavy-line number %1&quot;).arg(wavyLineNo+1), xmlreader);</a>
<a name="ln5819">                        }</a>
<a name="ln5820">                  else {</a>
<a name="ln5821">                        trill = new Trill(cr-&gt;score());</a>
<a name="ln5822">                        trill-&gt;setTrack(trk);</a>
<a name="ln5823">                        if (wavyLineType == &quot;start&quot;) {</a>
<a name="ln5824">                              spanners[trill] = QPair&lt;int, int&gt;(tick.ticks(), -1);</a>
<a name="ln5825">                              // qDebug(&quot;trill=%p inserted at first tick %d&quot;, trill, tick);</a>
<a name="ln5826">                              }</a>
<a name="ln5827">                        if (wavyLineType == &quot;startstop&quot;) {</a>
<a name="ln5828">                              spanners[trill] = QPair&lt;int, int&gt;(tick.ticks(), tick.ticks() + ticks.ticks());</a>
<a name="ln5829">                              trill = nullptr;</a>
<a name="ln5830">                              // qDebug(&quot;trill=%p inserted at first tick %d second tick %d&quot;, trill, tick, tick);</a>
<a name="ln5831">                              }</a>
<a name="ln5832">                        }</a>
<a name="ln5833">                  }</a>
<a name="ln5834">            else if (wavyLineType == &quot;stop&quot;) {</a>
<a name="ln5835">                  if (!trill) {</a>
<a name="ln5836">                        logger-&gt;logError(QString(&quot;wavy-line number %1 stop without start&quot;).arg(wavyLineNo+1), xmlreader);</a>
<a name="ln5837">                        }</a>
<a name="ln5838">                  else {</a>
<a name="ln5839">                        spanners[trill].second = tick.ticks() + ticks.ticks();</a>
<a name="ln5840">                        // qDebug(&quot;trill=%p second tick %d&quot;, trill, tick);</a>
<a name="ln5841">                        trill = nullptr;</a>
<a name="ln5842">                        }</a>
<a name="ln5843">                  }</a>
<a name="ln5844">            else</a>
<a name="ln5845">                  logger-&gt;logError(QString(&quot;unknown wavy-line type %1&quot;).arg(wavyLineType), xmlreader);</a>
<a name="ln5846">            }</a>
<a name="ln5847">      }</a>
<a name="ln5848"> </a>
<a name="ln5849">//---------------------------------------------------------</a>
<a name="ln5850">//   addBreath</a>
<a name="ln5851">//---------------------------------------------------------</a>
<a name="ln5852"> </a>
<a name="ln5853">static void addBreath(ChordRest* cr, const Fraction&amp; tick, SymId breath)</a>
<a name="ln5854">      {</a>
<a name="ln5855">      if (breath != SymId::noSym &amp;&amp; !cr-&gt;isGrace()) {</a>
<a name="ln5856">            const auto b = new Breath(cr-&gt;score());</a>
<a name="ln5857">            // b-&gt;setTrack(trk + voice); TODO check next line</a>
<a name="ln5858">            b-&gt;setTrack(cr-&gt;track());</a>
<a name="ln5859">            b-&gt;setSymId(breath);</a>
<a name="ln5860">            const Fraction&amp; ticks = cr-&gt;ticks();</a>
<a name="ln5861">            const auto seg = cr-&gt;measure()-&gt;getSegment(SegmentType::Breath, tick + ticks);</a>
<a name="ln5862">            seg-&gt;add(b);</a>
<a name="ln5863">            }</a>
<a name="ln5864">      }</a>
<a name="ln5865"> </a>
<a name="ln5866">//---------------------------------------------------------</a>
<a name="ln5867">//   addChordLine</a>
<a name="ln5868">//---------------------------------------------------------</a>
<a name="ln5869"> </a>
<a name="ln5870">static void addChordLine(Note* note, const QString&amp; chordLineType,</a>
<a name="ln5871">                         MxmlLogger* logger, const QXmlStreamReader* const xmlreader)</a>
<a name="ln5872">      {</a>
<a name="ln5873">      if (chordLineType != &quot;&quot;) {</a>
<a name="ln5874">            if (note) {</a>
<a name="ln5875">                  const auto chordline = new ChordLine(note-&gt;score());</a>
<a name="ln5876">                  if (chordLineType == &quot;falloff&quot;)</a>
<a name="ln5877">                        chordline-&gt;setChordLineType(ChordLineType::FALL);</a>
<a name="ln5878">                  if (chordLineType == &quot;doit&quot;)</a>
<a name="ln5879">                        chordline-&gt;setChordLineType(ChordLineType::DOIT);</a>
<a name="ln5880">                  if (chordLineType == &quot;plop&quot;)</a>
<a name="ln5881">                        chordline-&gt;setChordLineType(ChordLineType::PLOP);</a>
<a name="ln5882">                  if (chordLineType == &quot;scoop&quot;)</a>
<a name="ln5883">                        chordline-&gt;setChordLineType(ChordLineType::SCOOP);</a>
<a name="ln5884">                  note-&gt;chord()-&gt;add(chordline);</a>
<a name="ln5885">                  }</a>
<a name="ln5886">            else</a>
<a name="ln5887">                  logger-&gt;logError(QString(&quot;no note for %1&quot;).arg(chordLineType), xmlreader);</a>
<a name="ln5888">            }</a>
<a name="ln5889">      }</a>
<a name="ln5890"> </a>
<a name="ln5891">//---------------------------------------------------------</a>
<a name="ln5892">//   addAttribute</a>
<a name="ln5893">//---------------------------------------------------------</a>
<a name="ln5894"> </a>
<a name="ln5895">void Notation::addAttribute(const QStringRef name, const QStringRef value)</a>
<a name="ln5896">      {</a>
<a name="ln5897">      _attributes.insert(std::pair&lt;QString, QString&gt;(name.toString(), value.toString()));</a>
<a name="ln5898">      }</a>
<a name="ln5899"> </a>
<a name="ln5900">//---------------------------------------------------------</a>
<a name="ln5901">//   attribute</a>
<a name="ln5902">//---------------------------------------------------------</a>
<a name="ln5903"> </a>
<a name="ln5904">QString Notation::attribute(const QString&amp; name) const</a>
<a name="ln5905">      {</a>
<a name="ln5906">      const auto it = _attributes.find(name);</a>
<a name="ln5907">      return (it != _attributes.end()) ? it-&gt;second : &quot;&quot;;</a>
<a name="ln5908">      }</a>
<a name="ln5909"> </a>
<a name="ln5910">//---------------------------------------------------------</a>
<a name="ln5911">//   print</a>
<a name="ln5912">//---------------------------------------------------------</a>
<a name="ln5913"> </a>
<a name="ln5914">QString Notation::print() const</a>
<a name="ln5915">      {</a>
<a name="ln5916">      QString res { _name };</a>
<a name="ln5917"> </a>
<a name="ln5918">      for (auto const&amp; pair : _attributes) {</a>
<a name="ln5919">            res += &quot; &quot;;</a>
<a name="ln5920">            res += pair.first;</a>
<a name="ln5921">            res += &quot; &quot;;</a>
<a name="ln5922">            res += pair.second;</a>
<a name="ln5923">            }</a>
<a name="ln5924"> </a>
<a name="ln5925">      if (_text != &quot;&quot;) {</a>
<a name="ln5926">            res += &quot; &quot;;</a>
<a name="ln5927">            res += _text;</a>
<a name="ln5928">            }</a>
<a name="ln5929">      return res;</a>
<a name="ln5930">      }</a>
<a name="ln5931"> </a>
<a name="ln5932">//---------------------------------------------------------</a>
<a name="ln5933">//   MusicXMLParserNotations</a>
<a name="ln5934">//---------------------------------------------------------</a>
<a name="ln5935"> </a>
<a name="ln5936">MusicXMLParserNotations::MusicXMLParserNotations(QXmlStreamReader&amp; e, Score* score, MxmlLogger* logger)</a>
<a name="ln5937">      : _e(e), _score(score), _logger(logger)</a>
<a name="ln5938">      {</a>
<a name="ln5939">      // nothing</a>
<a name="ln5940">      }</a>
<a name="ln5941"> </a>
<a name="ln5942">//---------------------------------------------------------</a>
<a name="ln5943">//   skipLogCurrElem</a>
<a name="ln5944">//---------------------------------------------------------</a>
<a name="ln5945"> </a>
<a name="ln5946">/**</a>
<a name="ln5947"> Skip the current element, log debug as info.</a>
<a name="ln5948"> */</a>
<a name="ln5949"> </a>
<a name="ln5950">void MusicXMLParserNotations::skipLogCurrElem()</a>
<a name="ln5951">      {</a>
<a name="ln5952">      //_logger-&gt;logDebugInfo(QString(&quot;skipping '%1'&quot;).arg(_e.name().toString()), &amp;_e);</a>
<a name="ln5953">      _e.skipCurrentElement();</a>
<a name="ln5954">      }</a>
<a name="ln5955"> </a>
<a name="ln5956">//---------------------------------------------------------</a>
<a name="ln5957">//   parse</a>
<a name="ln5958">//---------------------------------------------------------</a>
<a name="ln5959"> </a>
<a name="ln5960">void MusicXMLParserNotations::parse()</a>
<a name="ln5961">      {</a>
<a name="ln5962">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;notations&quot;);</a>
<a name="ln5963"> </a>
<a name="ln5964">      while (_e.readNextStartElement()) {</a>
<a name="ln5965">            if (_e.name() == &quot;arpeggiate&quot;) {</a>
<a name="ln5966">                  _arpeggioType = _e.attributes().value(&quot;direction&quot;).toString();</a>
<a name="ln5967">                  if (_arpeggioType == &quot;&quot;) _arpeggioType = &quot;none&quot;;</a>
<a name="ln5968">                  _e.readNext();</a>
<a name="ln5969">                  }</a>
<a name="ln5970">            else if (_e.name() == &quot;articulations&quot;) {</a>
<a name="ln5971">                  articulations();</a>
<a name="ln5972">                  }</a>
<a name="ln5973">            else if (_e.name() == &quot;dynamics&quot;) {</a>
<a name="ln5974">                  dynamics();</a>
<a name="ln5975">                  }</a>
<a name="ln5976">            else if (_e.name() == &quot;fermata&quot;) {</a>
<a name="ln5977">                  fermata();</a>
<a name="ln5978">                  }</a>
<a name="ln5979">            else if (_e.name() == &quot;glissando&quot;) {</a>
<a name="ln5980">                  glissandoSlide();</a>
<a name="ln5981">                  }</a>
<a name="ln5982">            else if (_e.name() == &quot;non-arpeggiate&quot;) {</a>
<a name="ln5983">                  _arpeggioType = &quot;non-arpeggiate&quot;;</a>
<a name="ln5984">                  _e.readNext();</a>
<a name="ln5985">                  }</a>
<a name="ln5986">            else if (_e.name() == &quot;ornaments&quot;) {</a>
<a name="ln5987">                  ornaments();</a>
<a name="ln5988">                  }</a>
<a name="ln5989">            else if (_e.name() == &quot;slur&quot;) {</a>
<a name="ln5990">                  slur();</a>
<a name="ln5991">                  }</a>
<a name="ln5992">            else if (_e.name() == &quot;slide&quot;) {</a>
<a name="ln5993">                  glissandoSlide();</a>
<a name="ln5994">                  }</a>
<a name="ln5995">            else if (_e.name() == &quot;technical&quot;) {</a>
<a name="ln5996">                  technical();</a>
<a name="ln5997">                  }</a>
<a name="ln5998">            else if (_e.name() == &quot;tied&quot;) {</a>
<a name="ln5999">                  tied();</a>
<a name="ln6000">                  }</a>
<a name="ln6001">            else if (_e.name() == &quot;tuplet&quot;) {</a>
<a name="ln6002">                  tuplet();</a>
<a name="ln6003">                  }</a>
<a name="ln6004">            else {</a>
<a name="ln6005">                  skipLogCurrElem();</a>
<a name="ln6006">                  }</a>
<a name="ln6007">            }</a>
<a name="ln6008"> </a>
<a name="ln6009">      /*</a>
<a name="ln6010">      for (const auto&amp; notation : _notations) {</a>
<a name="ln6011">            qDebug(&quot;%s&quot;, qPrintable(notation.print()));</a>
<a name="ln6012">            }</a>
<a name="ln6013">       */</a>
<a name="ln6014"> </a>
<a name="ln6015">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;notations&quot;);</a>
<a name="ln6016">      }</a>
<a name="ln6017"> </a>
<a name="ln6018">//---------------------------------------------------------</a>
<a name="ln6019">//   addToScore</a>
<a name="ln6020">//---------------------------------------------------------</a>
<a name="ln6021"> </a>
<a name="ln6022">/**</a>
<a name="ln6023"> Add the notations found to the score.</a>
<a name="ln6024"> Note that some notations attach to notes only in MuseScore,</a>
<a name="ln6025"> which means trying to attach them to a rest will crash,</a>
<a name="ln6026"> as in that case note is a nullptr.</a>
<a name="ln6027"> */</a>
<a name="ln6028"> </a>
<a name="ln6029">void MusicXMLParserNotations::addToScore(ChordRest* const cr, Note* const note, const int tick, SlurStack&amp; slurs,</a>
<a name="ln6030">                                         Glissando* glissandi[MAX_NUMBER_LEVEL][2], MusicXmlSpannerMap&amp; spanners,</a>
<a name="ln6031">                                         TrillStack&amp; trills, Tie*&amp; tie)</a>
<a name="ln6032">      {</a>
<a name="ln6033">      addArpeggio(cr, _arpeggioType, _logger, &amp;_e);</a>
<a name="ln6034">      addAllArticulationsToChord(cr, _articulationSymbols);</a>
<a name="ln6035">      addBreath(cr, cr-&gt;tick(), _breath);</a>
<a name="ln6036">      addFermata(cr, _fermataType, _fermataSymbol);</a>
<a name="ln6037">      addStrongAccent(cr, _strongAccentType);</a>
<a name="ln6038">      addWavyLine(cr, Fraction::fromTicks(tick), _wavyLineNo, _wavyLineType, spanners, trills, _logger, &amp;_e);</a>
<a name="ln6039"> </a>
<a name="ln6040">      for (const auto&amp; notation : _notations) {</a>
<a name="ln6041">            if (notation.name() == &quot;slur&quot;) {</a>
<a name="ln6042">                  addSlur(notation, slurs, cr, tick, _logger, &amp;_e);</a>
<a name="ln6043">                  }</a>
<a name="ln6044">            else if (notation.name() == &quot;glissando&quot; || notation.name() == &quot;slide&quot;) {</a>
<a name="ln6045">                  if (note) {</a>
<a name="ln6046">                        addGlissandoSlide(notation, note, glissandi, spanners, _logger, &amp;_e);</a>
<a name="ln6047">                        }</a>
<a name="ln6048">                  }</a>
<a name="ln6049">            else if (notation.name() == &quot;mordent&quot; || notation.name() == &quot;inverted-mordent&quot;) {</a>
<a name="ln6050">                  addMordentToChord(cr, notation.name(),</a>
<a name="ln6051">                                    notation.attribute(&quot;long&quot;),</a>
<a name="ln6052">                                    notation.attribute(&quot;approach&quot;),</a>
<a name="ln6053">                                    notation.attribute(&quot;departure&quot;));</a>
<a name="ln6054">                  }</a>
<a name="ln6055">            }</a>
<a name="ln6056"> </a>
<a name="ln6057"> </a>
<a name="ln6058">      // more than one dynamic ???</a>
<a name="ln6059">      // LVIFIX: check import/export of &lt;other-dynamics&gt;unknown_text&lt;/...&gt;</a>
<a name="ln6060">      // TODO remove duplicate code (see MusicXml::direction)</a>
<a name="ln6061">      for (const auto&amp; d : _dynamicsList) {</a>
<a name="ln6062">            auto dynamic = new Dynamic(_score);</a>
<a name="ln6063">            dynamic-&gt;setDynamicType(d);</a>
<a name="ln6064">//TODO:ws            if (hasYoffset) dyn-&gt;textStyle().setYoff(yoffset);</a>
<a name="ln6065">            addElemOffset(dynamic, cr-&gt;track(), _dynamicsPlacement, cr-&gt;measure(), Fraction::fromTicks(tick));</a>
<a name="ln6066">            }</a>
<a name="ln6067"> </a>
<a name="ln6068">      if (note) {</a>
<a name="ln6069">            addChordLine(note, _chordLineType, _logger, &amp;_e);</a>
<a name="ln6070">            addTechnical(note);</a>
<a name="ln6071">            addTie(_score, note, cr-&gt;track(), _tiedType, _tiedOrientation, _tiedLineType, tie, _logger, &amp;_e);</a>
<a name="ln6072">            }</a>
<a name="ln6073">      }</a>
<a name="ln6074"> </a>
<a name="ln6075">//---------------------------------------------------------</a>
<a name="ln6076">//   stem</a>
<a name="ln6077">//---------------------------------------------------------</a>
<a name="ln6078"> </a>
<a name="ln6079">/**</a>
<a name="ln6080"> Parse the /score-partwise/part/measure/note/stem node.</a>
<a name="ln6081"> */</a>
<a name="ln6082"> </a>
<a name="ln6083">void MusicXMLParserPass2::stem(Direction&amp; sd, bool&amp; nost)</a>
<a name="ln6084">      {</a>
<a name="ln6085">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;stem&quot;);</a>
<a name="ln6086"> </a>
<a name="ln6087">      // defaults</a>
<a name="ln6088">      sd = Direction::AUTO;</a>
<a name="ln6089">      nost = false;</a>
<a name="ln6090"> </a>
<a name="ln6091">      QString s = _e.readElementText();</a>
<a name="ln6092"> </a>
<a name="ln6093">      if (s == &quot;up&quot;)</a>
<a name="ln6094">            sd = Direction::UP;</a>
<a name="ln6095">      else if (s == &quot;down&quot;)</a>
<a name="ln6096">            sd = Direction::DOWN;</a>
<a name="ln6097">      else if (s == &quot;none&quot;)</a>
<a name="ln6098">            nost = true;</a>
<a name="ln6099">      else if (s == &quot;double&quot;)</a>
<a name="ln6100">            ;</a>
<a name="ln6101">      else</a>
<a name="ln6102">            _logger-&gt;logError(QString(&quot;unknown stem direction %1&quot;).arg(s), &amp;_e);</a>
<a name="ln6103">      }</a>
<a name="ln6104"> </a>
<a name="ln6105">//---------------------------------------------------------</a>
<a name="ln6106">//   fermata</a>
<a name="ln6107">//---------------------------------------------------------</a>
<a name="ln6108"> </a>
<a name="ln6109">/**</a>
<a name="ln6110"> Parse the /score-partwise/part/measure/note/notations/fermata node.</a>
<a name="ln6111"> Note: MusicXML common.mod: &quot;An empty fermata element represents a normal fermata.&quot;</a>
<a name="ln6112"> */</a>
<a name="ln6113"> </a>
<a name="ln6114">void MusicXMLParserNotations::fermata()</a>
<a name="ln6115">      {</a>
<a name="ln6116">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;fermata&quot;);</a>
<a name="ln6117"> </a>
<a name="ln6118">      _fermataType = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln6119">      const auto fermataText = _e.readElementText();</a>
<a name="ln6120"> </a>
<a name="ln6121">      if (fermataText == &quot;normal&quot; || fermataText == &quot;&quot;)</a>
<a name="ln6122">            _fermataSymbol = SymId::fermataAbove;</a>
<a name="ln6123">      else if (fermataText == &quot;angled&quot;)</a>
<a name="ln6124">            _fermataSymbol = SymId::fermataShortAbove;</a>
<a name="ln6125">      else if (fermataText == &quot;square&quot;)</a>
<a name="ln6126">            _fermataSymbol = SymId::fermataLongAbove;</a>
<a name="ln6127">      else</a>
<a name="ln6128">            _logger-&gt;logError(QString(&quot;unknown fermata '%1'&quot;).arg(fermataText), &amp;_e);</a>
<a name="ln6129"> </a>
<a name="ln6130">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;fermata&quot;);</a>
<a name="ln6131">      }</a>
<a name="ln6132"> </a>
<a name="ln6133">//---------------------------------------------------------</a>
<a name="ln6134">//   tuplet</a>
<a name="ln6135">//---------------------------------------------------------</a>
<a name="ln6136"> </a>
<a name="ln6137">/**</a>
<a name="ln6138"> Parse the /score-partwise/part/measure/note/notations/tuplet node.</a>
<a name="ln6139"> */</a>
<a name="ln6140"> </a>
<a name="ln6141">void MusicXMLParserNotations::tuplet()</a>
<a name="ln6142">      {</a>
<a name="ln6143">      Q_ASSERT(_e.isStartElement() &amp;&amp; _e.name() == &quot;tuplet&quot;);</a>
<a name="ln6144"> </a>
<a name="ln6145">      QString tupletType       = _e.attributes().value(&quot;type&quot;).toString();</a>
<a name="ln6146">      // QString tupletPlacement  = _e.attributes().value(&quot;placement&quot;).toString(); not used (TODO)</a>
<a name="ln6147">      QString tupletBracket    = _e.attributes().value(&quot;bracket&quot;).toString();</a>
<a name="ln6148">      QString tupletShowNumber = _e.attributes().value(&quot;show-number&quot;).toString();</a>
<a name="ln6149"> </a>
<a name="ln6150">      // ignore possible children (currently not supported)</a>
<a name="ln6151">      _e.skipCurrentElement();</a>
<a name="ln6152"> </a>
<a name="ln6153">      if (tupletType == &quot;start&quot;)</a>
<a name="ln6154">            _tupletDesc.type = MxmlStartStop::START;</a>
<a name="ln6155">      else if (tupletType == &quot;stop&quot;)</a>
<a name="ln6156">            _tupletDesc.type = MxmlStartStop::STOP;</a>
<a name="ln6157">      else if (tupletType != &quot;&quot; &amp;&amp; tupletType != &quot;start&quot; &amp;&amp; tupletType != &quot;stop&quot;) {</a>
<a name="ln6158">            _logger-&gt;logError(QString(&quot;unknown tuplet type '%1'&quot;).arg(tupletType), &amp;_e);</a>
<a name="ln6159">            }</a>
<a name="ln6160"> </a>
<a name="ln6161">      // set bracket, leave at default if unspecified</a>
<a name="ln6162">      if (tupletBracket == &quot;yes&quot;)</a>
<a name="ln6163">            _tupletDesc.bracket = TupletBracketType::SHOW_BRACKET;</a>
<a name="ln6164">      else if (tupletBracket == &quot;no&quot;)</a>
<a name="ln6165">            _tupletDesc.bracket = TupletBracketType::SHOW_NO_BRACKET;</a>
<a name="ln6166"> </a>
<a name="ln6167">      // set number, default is &quot;actual&quot; (=NumberType::SHOW_NUMBER)</a>
<a name="ln6168">      if (tupletShowNumber == &quot;both&quot;)</a>
<a name="ln6169">            _tupletDesc.shownumber = TupletNumberType::SHOW_RELATION;</a>
<a name="ln6170">      else if (tupletShowNumber == &quot;none&quot;)</a>
<a name="ln6171">            _tupletDesc.shownumber = TupletNumberType::NO_TEXT;</a>
<a name="ln6172">      else</a>
<a name="ln6173">            _tupletDesc.shownumber = TupletNumberType::SHOW_NUMBER;</a>
<a name="ln6174"> </a>
<a name="ln6175">      Q_ASSERT(_e.isEndElement() &amp;&amp; _e.name() == &quot;tuplet&quot;);</a>
<a name="ln6176">      }</a>
<a name="ln6177"> </a>
<a name="ln6178">//---------------------------------------------------------</a>
<a name="ln6179">//   MusicXMLParserDirection</a>
<a name="ln6180">//---------------------------------------------------------</a>
<a name="ln6181"> </a>
<a name="ln6182">/**</a>
<a name="ln6183"> MusicXMLParserDirection constructor.</a>
<a name="ln6184"> */</a>
<a name="ln6185"> </a>
<a name="ln6186">MusicXMLParserDirection::MusicXMLParserDirection(QXmlStreamReader&amp; e,</a>
<a name="ln6187">                                                 Score* score,</a>
<a name="ln6188">                                                 const MusicXMLParserPass1&amp; pass1,</a>
<a name="ln6189">                                                 MusicXMLParserPass2&amp; pass2,</a>
<a name="ln6190">                                                 MxmlLogger* logger)</a>
<a name="ln6191">      : _e(e), _score(score), _pass1(pass1), _pass2(pass2), _logger(logger),</a>
<a name="ln6192">      _hasDefaultY(false), _defaultY(0.0), _coda(false), _segno(false),</a>
<a name="ln6193">      _tpoMetro(0), _tpoSound(0), _offset(0, 1)</a>
<a name="ln6194">      {</a>
<a name="ln6195">      // nothing</a>
<a name="ln6196">      }</a>
<a name="ln6197"> </a>
<a name="ln6198">}</a>

</code></pre>
<div class="balloon" rel="1077"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1100"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1277"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1330"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1905"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'measure' pointer was used unsafely after it was verified against nullptr. Check lines: 1895, 1905.</p></div>
<div class="balloon" rel="2903"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="3120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: "short".</p></div>
<div class="balloon" rel="3124"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="4525"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="4543"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v581/" target="_blank">V581</a> The conditional expressions of the 'if' statements situated alongside each other are identical. Check lines: 4507, 4543.</p></div>
<div class="balloon" rel="4928"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'invalidRoot' is always false.</p></div>
<div class="balloon" rel="5201"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="5682"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'note' pointer was utilized before it was verified against nullptr. Check lines: 5682, 5692.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
