
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>cmd.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2013 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">/**</a>
<a name="ln14"> \file</a>
<a name="ln15"> Handling of several GUI commands.</a>
<a name="ln16">*/</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;assert.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;types.h&quot;</a>
<a name="ln21">#include &quot;musescoreCore.h&quot;</a>
<a name="ln22">#include &quot;score.h&quot;</a>
<a name="ln23">#include &quot;utils.h&quot;</a>
<a name="ln24">#include &quot;key.h&quot;</a>
<a name="ln25">#include &quot;clef.h&quot;</a>
<a name="ln26">#include &quot;navigate.h&quot;</a>
<a name="ln27">#include &quot;slur.h&quot;</a>
<a name="ln28">#include &quot;tie.h&quot;</a>
<a name="ln29">#include &quot;note.h&quot;</a>
<a name="ln30">#include &quot;rest.h&quot;</a>
<a name="ln31">#include &quot;chord.h&quot;</a>
<a name="ln32">#include &quot;text.h&quot;</a>
<a name="ln33">#include &quot;sig.h&quot;</a>
<a name="ln34">#include &quot;staff.h&quot;</a>
<a name="ln35">#include &quot;part.h&quot;</a>
<a name="ln36">#include &quot;style.h&quot;</a>
<a name="ln37">#include &quot;page.h&quot;</a>
<a name="ln38">#include &quot;barline.h&quot;</a>
<a name="ln39">#include &quot;tuplet.h&quot;</a>
<a name="ln40">#include &quot;xml.h&quot;</a>
<a name="ln41">#include &quot;ottava.h&quot;</a>
<a name="ln42">#include &quot;trill.h&quot;</a>
<a name="ln43">#include &quot;pedal.h&quot;</a>
<a name="ln44">#include &quot;hairpin.h&quot;</a>
<a name="ln45">#include &quot;textline.h&quot;</a>
<a name="ln46">#include &quot;keysig.h&quot;</a>
<a name="ln47">#include &quot;volta.h&quot;</a>
<a name="ln48">#include &quot;dynamic.h&quot;</a>
<a name="ln49">#include &quot;box.h&quot;</a>
<a name="ln50">#include &quot;harmony.h&quot;</a>
<a name="ln51">#include &quot;system.h&quot;</a>
<a name="ln52">#include &quot;stafftext.h&quot;</a>
<a name="ln53">#include &quot;articulation.h&quot;</a>
<a name="ln54">#include &quot;layoutbreak.h&quot;</a>
<a name="ln55">#include &quot;drumset.h&quot;</a>
<a name="ln56">#include &quot;beam.h&quot;</a>
<a name="ln57">#include &quot;lyrics.h&quot;</a>
<a name="ln58">#include &quot;pitchspelling.h&quot;</a>
<a name="ln59">#include &quot;measure.h&quot;</a>
<a name="ln60">#include &quot;tempo.h&quot;</a>
<a name="ln61">#include &quot;undo.h&quot;</a>
<a name="ln62">#include &quot;timesig.h&quot;</a>
<a name="ln63">#include &quot;repeat.h&quot;</a>
<a name="ln64">#include &quot;tempotext.h&quot;</a>
<a name="ln65">#include &quot;noteevent.h&quot;</a>
<a name="ln66">#include &quot;breath.h&quot;</a>
<a name="ln67">#include &quot;stringdata.h&quot;</a>
<a name="ln68">#include &quot;stafftype.h&quot;</a>
<a name="ln69">#include &quot;segment.h&quot;</a>
<a name="ln70">#include &quot;chordlist.h&quot;</a>
<a name="ln71">#include &quot;mscore.h&quot;</a>
<a name="ln72">#include &quot;accidental.h&quot;</a>
<a name="ln73">#include &quot;sequencer.h&quot;</a>
<a name="ln74">#include &quot;tremolo.h&quot;</a>
<a name="ln75">#include &quot;rehearsalmark.h&quot;</a>
<a name="ln76">#include &quot;sym.h&quot;</a>
<a name="ln77"> </a>
<a name="ln78">namespace Ms {</a>
<a name="ln79"> </a>
<a name="ln80">//---------------------------------------------------------</a>
<a name="ln81">//   reset</a>
<a name="ln82">//---------------------------------------------------------</a>
<a name="ln83"> </a>
<a name="ln84">void CmdState::reset()</a>
<a name="ln85">      {</a>
<a name="ln86">      layoutFlags         = LayoutFlag::NO_FLAGS;</a>
<a name="ln87">      _updateMode         = UpdateMode::DoNothing;</a>
<a name="ln88">      _startTick          = Fraction(-1,1);</a>
<a name="ln89">      _endTick            = Fraction(-1,1);</a>
<a name="ln90"> </a>
<a name="ln91">      _startStaff = -1;</a>
<a name="ln92">      _endStaff = -1;</a>
<a name="ln93">      _el = nullptr;</a>
<a name="ln94">      _oneElement = true;</a>
<a name="ln95">      _mb = nullptr;</a>
<a name="ln96">      _oneMeasureBase = true;</a>
<a name="ln97">      _locked = false;</a>
<a name="ln98">      }</a>
<a name="ln99"> </a>
<a name="ln100">//---------------------------------------------------------</a>
<a name="ln101">//   setTick</a>
<a name="ln102">//---------------------------------------------------------</a>
<a name="ln103"> </a>
<a name="ln104">void CmdState::setTick(const Fraction&amp; t)</a>
<a name="ln105">      {</a>
<a name="ln106">      if (_locked)</a>
<a name="ln107">            return;</a>
<a name="ln108"> </a>
<a name="ln109">      if (_startTick == Fraction(-1,1) || t &lt; _startTick)</a>
<a name="ln110">            _startTick = t;</a>
<a name="ln111">      if (_endTick == Fraction(-1,1) || t &gt; _endTick)</a>
<a name="ln112">            _endTick = t;</a>
<a name="ln113">      setUpdateMode(UpdateMode::Layout);</a>
<a name="ln114">      }</a>
<a name="ln115"> </a>
<a name="ln116">//---------------------------------------------------------</a>
<a name="ln117">//   setStaff</a>
<a name="ln118">//---------------------------------------------------------</a>
<a name="ln119"> </a>
<a name="ln120">void CmdState::setStaff(int st)</a>
<a name="ln121">      {</a>
<a name="ln122">      Q_ASSERT(st &gt; -2);</a>
<a name="ln123">      if (_locked || st == -1)</a>
<a name="ln124">            return;</a>
<a name="ln125"> </a>
<a name="ln126">      if (_startStaff == -1 || st &lt; _startStaff)</a>
<a name="ln127">            _startStaff = st;</a>
<a name="ln128">      if (_endStaff == -1 || st &gt; _endStaff)</a>
<a name="ln129">            _endStaff = st;</a>
<a name="ln130">      }</a>
<a name="ln131"> </a>
<a name="ln132">//---------------------------------------------------------</a>
<a name="ln133">//   setMeasureBase</a>
<a name="ln134">//---------------------------------------------------------</a>
<a name="ln135"> </a>
<a name="ln136">void CmdState::setMeasureBase(const MeasureBase* mb)</a>
<a name="ln137">      {</a>
<a name="ln138">      if (!mb || _mb == mb || _locked)</a>
<a name="ln139">            return;</a>
<a name="ln140"> </a>
<a name="ln141">      _oneMeasureBase = !_mb;</a>
<a name="ln142">      _mb = mb;</a>
<a name="ln143">      }</a>
<a name="ln144"> </a>
<a name="ln145">//---------------------------------------------------------</a>
<a name="ln146">//   setElement</a>
<a name="ln147">//---------------------------------------------------------</a>
<a name="ln148"> </a>
<a name="ln149">void CmdState::setElement(const Element* e)</a>
<a name="ln150">      {</a>
<a name="ln151">      if (!e || _el == e || _locked)</a>
<a name="ln152">            return;</a>
<a name="ln153"> </a>
<a name="ln154">      _oneElement = !_el;</a>
<a name="ln155">      _el = e;</a>
<a name="ln156"> </a>
<a name="ln157">      if (_oneMeasureBase)</a>
<a name="ln158">            setMeasureBase(e-&gt;findMeasureBase());</a>
<a name="ln159">      }</a>
<a name="ln160"> </a>
<a name="ln161">//---------------------------------------------------------</a>
<a name="ln162">//   unsetElement</a>
<a name="ln163">//---------------------------------------------------------</a>
<a name="ln164"> </a>
<a name="ln165">void CmdState::unsetElement(const Element* e)</a>
<a name="ln166">      {</a>
<a name="ln167">      if (_el == e)</a>
<a name="ln168">            _el = nullptr;</a>
<a name="ln169">      if (_mb == e)</a>
<a name="ln170">            _mb = nullptr;</a>
<a name="ln171">      }</a>
<a name="ln172"> </a>
<a name="ln173">//---------------------------------------------------------</a>
<a name="ln174">//   element</a>
<a name="ln175">//---------------------------------------------------------</a>
<a name="ln176"> </a>
<a name="ln177">const Element* CmdState::element() const</a>
<a name="ln178">      {</a>
<a name="ln179">      if (_oneElement)</a>
<a name="ln180">            return _el;</a>
<a name="ln181">      if (_oneMeasureBase)</a>
<a name="ln182">            return _mb;</a>
<a name="ln183">      return nullptr;</a>
<a name="ln184">      }</a>
<a name="ln185"> </a>
<a name="ln186">//---------------------------------------------------------</a>
<a name="ln187">//   setUpdateMode</a>
<a name="ln188">//---------------------------------------------------------</a>
<a name="ln189"> </a>
<a name="ln190">void CmdState::_setUpdateMode(UpdateMode m)</a>
<a name="ln191">      {</a>
<a name="ln192">      _updateMode = m;</a>
<a name="ln193">      }</a>
<a name="ln194"> </a>
<a name="ln195">void CmdState::setUpdateMode(UpdateMode m)</a>
<a name="ln196">      {</a>
<a name="ln197">      if (int(m) &gt; int(_updateMode))</a>
<a name="ln198">            _setUpdateMode(m);</a>
<a name="ln199">      }</a>
<a name="ln200"> </a>
<a name="ln201">//---------------------------------------------------------</a>
<a name="ln202">//   startCmd</a>
<a name="ln203">///   Start a GUI command by clearing the redraw area</a>
<a name="ln204">///   and starting a user-visible undo.</a>
<a name="ln205">//---------------------------------------------------------</a>
<a name="ln206"> </a>
<a name="ln207">void Score::startCmd()</a>
<a name="ln208">      {</a>
<a name="ln209">      if (MScore::debugMode)</a>
<a name="ln210">            qDebug(&quot;===startCmd()&quot;);</a>
<a name="ln211"> </a>
<a name="ln212">      cmdState().reset();</a>
<a name="ln213"> </a>
<a name="ln214">      // Start collecting low-level undo operations for a</a>
<a name="ln215">      // user-visible undo action.</a>
<a name="ln216">      if (undoStack()-&gt;active()) {</a>
<a name="ln217">            qDebug(&quot;Score::startCmd(): cmd already active&quot;);</a>
<a name="ln218">            return;</a>
<a name="ln219">            }</a>
<a name="ln220">      undoStack()-&gt;beginMacro(this);</a>
<a name="ln221">      }</a>
<a name="ln222"> </a>
<a name="ln223">//---------------------------------------------------------</a>
<a name="ln224">//   undoRedo</a>
<a name="ln225">//---------------------------------------------------------</a>
<a name="ln226"> </a>
<a name="ln227">void Score::undoRedo(bool undo, EditData* ed)</a>
<a name="ln228">      {</a>
<a name="ln229">      if (readOnly())</a>
<a name="ln230">            return;</a>
<a name="ln231">      cmdState().reset();</a>
<a name="ln232">      if (undo)</a>
<a name="ln233">            undoStack()-&gt;undo(ed);</a>
<a name="ln234">      else</a>
<a name="ln235">            undoStack()-&gt;redo(ed);</a>
<a name="ln236">      update(false);</a>
<a name="ln237">      masterScore()-&gt;setPlaylistDirty();  // TODO: flag all individual operations</a>
<a name="ln238">      updateSelection();</a>
<a name="ln239">      }</a>
<a name="ln240"> </a>
<a name="ln241">//---------------------------------------------------------</a>
<a name="ln242">//   endCmd</a>
<a name="ln243">///   End a GUI command by (if \a undo) ending a user-visble undo</a>
<a name="ln244">///   and (always) updating the redraw area.</a>
<a name="ln245">//---------------------------------------------------------</a>
<a name="ln246"> </a>
<a name="ln247">void Score::endCmd(bool rollback)</a>
<a name="ln248">      {</a>
<a name="ln249">      if (!undoStack()-&gt;active()) {</a>
<a name="ln250">            qDebug(&quot;Score::endCmd(): no cmd active&quot;);</a>
<a name="ln251">            update();</a>
<a name="ln252">            return;</a>
<a name="ln253">            }</a>
<a name="ln254">      if (readOnly() || MScore::_error != MS_NO_ERROR)</a>
<a name="ln255">            rollback = true;</a>
<a name="ln256"> </a>
<a name="ln257">      if (rollback)</a>
<a name="ln258">            undoStack()-&gt;current()-&gt;unwind();</a>
<a name="ln259"> </a>
<a name="ln260">      update(false);</a>
<a name="ln261"> </a>
<a name="ln262">      if (MScore::debugMode)</a>
<a name="ln263">            qDebug(&quot;===endCmd() %d&quot;, undoStack()-&gt;current()-&gt;childCount());</a>
<a name="ln264">      const bool noUndo = undoStack()-&gt;current()-&gt;empty();       // nothing to undo?</a>
<a name="ln265">      undoStack()-&gt;endMacro(noUndo);</a>
<a name="ln266"> </a>
<a name="ln267">      if (dirty()) {</a>
<a name="ln268">            masterScore()-&gt;setPlaylistDirty();  // TODO: flag individual operations</a>
<a name="ln269">            masterScore()-&gt;setAutosaveDirty(true);</a>
<a name="ln270">            }</a>
<a name="ln271">      MuseScoreCore::mscoreCore-&gt;endCmd();</a>
<a name="ln272">      cmdState().reset();</a>
<a name="ln273">      }</a>
<a name="ln274"> </a>
<a name="ln275">#ifndef NDEBUG</a>
<a name="ln276">//---------------------------------------------------------</a>
<a name="ln277">//   CmdState::dump</a>
<a name="ln278">//---------------------------------------------------------</a>
<a name="ln279"> </a>
<a name="ln280">void CmdState::dump()</a>
<a name="ln281">      {</a>
<a name="ln282">      qDebug(&quot;CmdState: mode %d %d-%d&quot;, int(_updateMode), _startTick.ticks(), _endTick.ticks());</a>
<a name="ln283">      // bool _excerptsChanged     { false };</a>
<a name="ln284">      // bool _instrumentsChanged  { false };</a>
<a name="ln285"> </a>
<a name="ln286">      }</a>
<a name="ln287">#endif</a>
<a name="ln288"> </a>
<a name="ln289">//---------------------------------------------------------</a>
<a name="ln290">//   update</a>
<a name="ln291">//    layout &amp; update</a>
<a name="ln292">//---------------------------------------------------------</a>
<a name="ln293"> </a>
<a name="ln294">void Score::update(bool resetCmdState)</a>
<a name="ln295">      {</a>
<a name="ln296">      bool updateAll = false;</a>
<a name="ln297">      for (MasterScore* ms : *movements()) {</a>
<a name="ln298">            CmdState&amp; cs = ms-&gt;cmdState();</a>
<a name="ln299">            ms-&gt;deletePostponed();</a>
<a name="ln300">            if (cs.layoutRange()) {</a>
<a name="ln301">                  for (Score* s : ms-&gt;scoreList())</a>
<a name="ln302">                        s-&gt;doLayoutRange(cs.startTick(), cs.endTick());</a>
<a name="ln303">                  updateAll = true;</a>
<a name="ln304">                  }</a>
<a name="ln305">            }</a>
<a name="ln306"> </a>
<a name="ln307">      for (MasterScore* ms : *movements()) {</a>
<a name="ln308">            CmdState&amp; cs = ms-&gt;cmdState();</a>
<a name="ln309">            if (updateAll || cs.updateAll()) {</a>
<a name="ln310">                  for (Score* s : scoreList()) {</a>
<a name="ln311">                        for (MuseScoreView* v : s-&gt;viewer) {</a>
<a name="ln312">                              v-&gt;updateAll();</a>
<a name="ln313">                              }</a>
<a name="ln314">                        }</a>
<a name="ln315">                  }</a>
<a name="ln316">            else if (cs.updateRange()) {</a>
<a name="ln317">                  // updateRange updates only current score</a>
<a name="ln318">                  qreal d = spatium() * .5;</a>
<a name="ln319">                  _updateState.refresh.adjust(-d, -d, 2 * d, 2 * d);</a>
<a name="ln320">                  for (MuseScoreView* v : viewer)</a>
<a name="ln321">                        v-&gt;dataChanged(_updateState.refresh);</a>
<a name="ln322">                  _updateState.refresh = QRectF();</a>
<a name="ln323">                  }</a>
<a name="ln324">            const InputState&amp; is = inputState();</a>
<a name="ln325">            if (is.noteEntryMode() &amp;&amp; is.segment()) {</a>
<a name="ln326">                  setPlayPos(is.segment()-&gt;tick());</a>
<a name="ln327">                  }</a>
<a name="ln328">            if (playlistDirty()) {</a>
<a name="ln329">                  for (Score* s : scoreList())</a>
<a name="ln330">                        emit s-&gt;playlistChanged();</a>
<a name="ln331">                  masterScore()-&gt;setPlaylistClean();</a>
<a name="ln332">                  }</a>
<a name="ln333">            if (resetCmdState)</a>
<a name="ln334">                  cs.reset();</a>
<a name="ln335">            }</a>
<a name="ln336">      if (_selection.isRange())</a>
<a name="ln337">            _selection.updateSelectedElements();</a>
<a name="ln338">      }</a>
<a name="ln339"> </a>
<a name="ln340">//---------------------------------------------------------</a>
<a name="ln341">//   deletePostponed</a>
<a name="ln342">//---------------------------------------------------------</a>
<a name="ln343"> </a>
<a name="ln344">void Score::deletePostponed()</a>
<a name="ln345">      {</a>
<a name="ln346">      for (ScoreElement* e : _updateState._deleteList) {</a>
<a name="ln347">            if (e-&gt;isSystem()) {</a>
<a name="ln348">                  System* s = toSystem(e);</a>
<a name="ln349">                  for (SpannerSegment* ss : s-&gt;spannerSegments()) {</a>
<a name="ln350">                        if (ss-&gt;system() == s)</a>
<a name="ln351">                              ss-&gt;setSystem(0);</a>
<a name="ln352">                        }</a>
<a name="ln353">                  }</a>
<a name="ln354">            }</a>
<a name="ln355">      qDeleteAll(_updateState._deleteList);</a>
<a name="ln356">      _updateState._deleteList.clear();</a>
<a name="ln357">      }</a>
<a name="ln358"> </a>
<a name="ln359">//---------------------------------------------------------</a>
<a name="ln360">//   cmdAddSpanner</a>
<a name="ln361">//   drop VOLTA, OTTAVA, TRILL, PEDAL, DYNAMIC</a>
<a name="ln362">//        HAIRPIN, LET_RING, VIBRATO and TEXTLINE</a>
<a name="ln363">//---------------------------------------------------------</a>
<a name="ln364"> </a>
<a name="ln365">void Score::cmdAddSpanner(Spanner* spanner, const QPointF&amp; pos, bool firstStaffOnly)</a>
<a name="ln366">      {</a>
<a name="ln367">      int staffIdx;</a>
<a name="ln368">      Segment* segment;</a>
<a name="ln369">      MeasureBase* mb = pos2measure(pos, &amp;staffIdx, 0, &amp;segment, 0);</a>
<a name="ln370">      if (firstStaffOnly)</a>
<a name="ln371">            staffIdx = 0;</a>
<a name="ln372">      // ignore if we do not have a measure</a>
<a name="ln373">      if (mb == 0 || mb-&gt;type() != ElementType::MEASURE) {</a>
<a name="ln374">            qDebug(&quot;cmdAddSpanner: cannot put object here&quot;);</a>
<a name="ln375">            delete spanner;</a>
<a name="ln376">            return;</a>
<a name="ln377">            }</a>
<a name="ln378"> </a>
<a name="ln379">      // all spanners live in voice 0 (except slurs/ties)</a>
<a name="ln380">      int track = staffIdx == -1 ? -1 : staffIdx * VOICES;</a>
<a name="ln381"> </a>
<a name="ln382">      spanner-&gt;setTrack(track);</a>
<a name="ln383">      spanner-&gt;setTrack2(track);</a>
<a name="ln384"> </a>
<a name="ln385">      if (spanner-&gt;anchor() == Spanner::Anchor::SEGMENT) {</a>
<a name="ln386">            spanner-&gt;setTick(segment-&gt;tick());</a>
<a name="ln387">            Fraction lastTick = lastMeasure()-&gt;tick() + lastMeasure()-&gt;ticks();</a>
<a name="ln388">            Fraction tick2 = qMin(segment-&gt;measure()-&gt;tick() + segment-&gt;measure()-&gt;ticks(), lastTick);</a>
<a name="ln389">            spanner-&gt;setTick2(tick2);</a>
<a name="ln390">            }</a>
<a name="ln391">      else {      // Anchor::MEASURE, Anchor::CHORD, Anchor::NOTE</a>
<a name="ln392">            Measure* m = toMeasure(mb);</a>
<a name="ln393">            QRectF b(m-&gt;canvasBoundingRect());</a>
<a name="ln394"> </a>
<a name="ln395">            if (pos.x() &gt;= (b.x() + b.width() * .5) &amp;&amp; m != lastMeasureMM() &amp;&amp; m-&gt;nextMeasure()-&gt;system() == m-&gt;system())</a>
<a name="ln396">                  m = m-&gt;nextMeasure();</a>
<a name="ln397">            spanner-&gt;setTick(m-&gt;tick());</a>
<a name="ln398">            spanner-&gt;setTick2(m-&gt;endTick());</a>
<a name="ln399">            }</a>
<a name="ln400">      spanner-&gt;eraseSpannerSegments();</a>
<a name="ln401"> </a>
<a name="ln402">      undoAddElement(spanner);</a>
<a name="ln403">      select(spanner, SelectType::SINGLE, 0);</a>
<a name="ln404">      }</a>
<a name="ln405"> </a>
<a name="ln406">//---------------------------------------------------------</a>
<a name="ln407">//   cmdAddSpanner</a>
<a name="ln408">//    used when applying a spanner to a selection</a>
<a name="ln409">//---------------------------------------------------------</a>
<a name="ln410"> </a>
<a name="ln411">void Score::cmdAddSpanner(Spanner* spanner, int staffIdx, Segment* startSegment, Segment* endSegment)</a>
<a name="ln412">      {</a>
<a name="ln413">      int track = staffIdx * VOICES;</a>
<a name="ln414">      spanner-&gt;setTrack(track);</a>
<a name="ln415">      spanner-&gt;setTrack2(track);</a>
<a name="ln416">      for (auto ss : spanner-&gt;spannerSegments())</a>
<a name="ln417">            ss-&gt;setTrack(track);</a>
<a name="ln418">      spanner-&gt;setTick(startSegment-&gt;tick());</a>
<a name="ln419">      Fraction tick2;</a>
<a name="ln420">      if (!endSegment)</a>
<a name="ln421">            tick2 = lastSegment()-&gt;tick();</a>
<a name="ln422">      else if (endSegment == startSegment)</a>
<a name="ln423">            tick2 = startSegment-&gt;measure()-&gt;last()-&gt;tick();</a>
<a name="ln424">      else</a>
<a name="ln425">            tick2 = endSegment-&gt;tick();</a>
<a name="ln426">      spanner-&gt;setTick2(tick2);</a>
<a name="ln427">#if 0 // TODO</a>
<a name="ln428">      TextLine* tl = toTextLine(spanner);</a>
<a name="ln429">      if (tl) {</a>
<a name="ln430">            StyledPropertyListIdx st;</a>
<a name="ln431">            Text* t;</a>
<a name="ln432">            // begin</a>
<a name="ln433">            t = tl-&gt;beginTextElement();</a>
<a name="ln434">            if (t) {</a>
<a name="ln435">                  st = t-&gt;textStyleType();</a>
<a name="ln436">                  if (st &gt;= StyledPropertyListIdx::DEFAULT)</a>
<a name="ln437">                        t-&gt;textStyle().restyle(MScore::baseStyle().textStyle(st), textStyle(st));</a>
<a name="ln438">                  }</a>
<a name="ln439">            // continue</a>
<a name="ln440">            t = tl-&gt;continueTextElement();</a>
<a name="ln441">            if (t) {</a>
<a name="ln442">                  st = t-&gt;textStyleType();</a>
<a name="ln443">                  if (st &gt;= StyledPropertyListIdx::DEFAULT)</a>
<a name="ln444">                        t-&gt;textStyle().restyle(MScore::baseStyle().textStyle(st), textStyle(st));</a>
<a name="ln445">                  }</a>
<a name="ln446">            // end</a>
<a name="ln447">            t = tl-&gt;endTextElement();</a>
<a name="ln448">            if (t) {</a>
<a name="ln449">                  st = t-&gt;textStyleType();</a>
<a name="ln450">                  if (st &gt;= StyledPropertyListIdx::DEFAULT)</a>
<a name="ln451">                        t-&gt;textStyle().restyle(MScore::baseStyle().textStyle(st), textStyle(st));</a>
<a name="ln452">                  }</a>
<a name="ln453">            }</a>
<a name="ln454">#endif</a>
<a name="ln455">      undoAddElement(spanner);</a>
<a name="ln456">      }</a>
<a name="ln457"> </a>
<a name="ln458">//---------------------------------------------------------</a>
<a name="ln459">//   expandVoice</a>
<a name="ln460">//    fills gaps in voice with rests,</a>
<a name="ln461">//    from previous cr (or beginning of measure) to next cr (or end of measure)</a>
<a name="ln462">//---------------------------------------------------------</a>
<a name="ln463"> </a>
<a name="ln464">void Score::expandVoice(Segment* s, int track)</a>
<a name="ln465">      {</a>
<a name="ln466">      if (!s) {</a>
<a name="ln467">            qDebug(&quot;expand voice: no segment&quot;);</a>
<a name="ln468">            return;</a>
<a name="ln469">            }</a>
<a name="ln470">      if (s-&gt;element(track))</a>
<a name="ln471">            return;</a>
<a name="ln472"> </a>
<a name="ln473">      // find previous segment with cr in this track</a>
<a name="ln474">      Segment* ps;</a>
<a name="ln475">      for (ps = s; ps; ps = ps-&gt;prev(SegmentType::ChordRest)) {</a>
<a name="ln476">            if (ps-&gt;element(track))</a>
<a name="ln477">                  break;</a>
<a name="ln478">            }</a>
<a name="ln479">      if (ps) {</a>
<a name="ln480">            ChordRest* cr = toChordRest(ps-&gt;element(track));</a>
<a name="ln481">            Fraction tick = cr-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln482">            if (tick &gt; s-&gt;tick()) {</a>
<a name="ln483">                  // previous cr extends past current segment</a>
<a name="ln484">                  qDebug(&quot;expandVoice: cannot insert element here&quot;);</a>
<a name="ln485">                  return;</a>
<a name="ln486">                  }</a>
<a name="ln487">            if (cr-&gt;isChord()) {</a>
<a name="ln488">                  // previous cr ends on or before current segment</a>
<a name="ln489">                  // for chords, move ps to just after cr ends</a>
<a name="ln490">                  // so we can fill any gap that might exist</a>
<a name="ln491">                  // but don't move ps if previous cr is a rest</a>
<a name="ln492">                  // this will be combined with any new rests needed to fill up to s-&gt;tick() below</a>
<a name="ln493">                  ps = ps-&gt;measure()-&gt;undoGetSegment(SegmentType::ChordRest, tick);</a>
<a name="ln494">                  }</a>
<a name="ln495">            }</a>
<a name="ln496">      //</a>
<a name="ln497">      // fill up to s-&gt;tick() with rests</a>
<a name="ln498">      //</a>
<a name="ln499">      Measure* m = s-&gt;measure();</a>
<a name="ln500">      Fraction stick  = ps ?  ps-&gt;tick() : m-&gt;tick();</a>
<a name="ln501">      Fraction ticks  = s-&gt;tick() - stick;</a>
<a name="ln502">      if (ticks.isNotZero())</a>
<a name="ln503">            setRest(stick, track, ticks, false, 0);</a>
<a name="ln504"> </a>
<a name="ln505">      //</a>
<a name="ln506">      // fill from s-&gt;tick() until next chord/rest in measure</a>
<a name="ln507">      //</a>
<a name="ln508">      Segment* ns;</a>
<a name="ln509">      for (ns = s-&gt;next(SegmentType::ChordRest); ns; ns = ns-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln510">            if (ns-&gt;element(track))</a>
<a name="ln511">                  break;</a>
<a name="ln512">            }</a>
<a name="ln513">      ticks  = ns ? (ns-&gt;tick() - s-&gt;tick()) : (m-&gt;ticks() - s-&gt;rtick());</a>
<a name="ln514">      if (ticks == m-&gt;ticks())</a>
<a name="ln515">            addRest(s, track, TDuration(TDuration::DurationType::V_MEASURE), 0);</a>
<a name="ln516">      else</a>
<a name="ln517">            setRest(s-&gt;tick(), track, ticks, false, 0);</a>
<a name="ln518">      }</a>
<a name="ln519"> </a>
<a name="ln520">void Score::expandVoice()</a>
<a name="ln521">      {</a>
<a name="ln522">      Segment* s = _is.segment();</a>
<a name="ln523">      int track  = _is.track();</a>
<a name="ln524">      expandVoice(s, track);</a>
<a name="ln525">      }</a>
<a name="ln526"> </a>
<a name="ln527">//---------------------------------------------------------</a>
<a name="ln528">//   cmdAddInterval</a>
<a name="ln529">//---------------------------------------------------------</a>
<a name="ln530"> </a>
<a name="ln531">void Score::cmdAddInterval(int val, const std::vector&lt;Note*&gt;&amp; nl)</a>
<a name="ln532">      {</a>
<a name="ln533">      startCmd();</a>
<a name="ln534">      for (Note* on : nl) {</a>
<a name="ln535">            Note* note = new Note(this);</a>
<a name="ln536">            Chord* chord = on-&gt;chord();</a>
<a name="ln537">            note-&gt;setParent(chord);</a>
<a name="ln538">            note-&gt;setTrack(chord-&gt;track());</a>
<a name="ln539">            int valTmp = val &lt; 0 ? val+1 : val-1;</a>
<a name="ln540"> </a>
<a name="ln541">            int npitch;</a>
<a name="ln542">            int ntpc1;</a>
<a name="ln543">            int ntpc2;</a>
<a name="ln544">            bool accidental = _is.noteEntryMode() &amp;&amp; _is.accidentalType() != AccidentalType::NONE;</a>
<a name="ln545">            bool forceAccidental = false;</a>
<a name="ln546">            if (abs(valTmp) != 7 || accidental) {</a>
<a name="ln547">                  int line      = on-&gt;line() - valTmp;</a>
<a name="ln548">                  Fraction tick      = chord-&gt;tick();</a>
<a name="ln549">                  Staff* estaff = staff(on-&gt;staffIdx() + chord-&gt;staffMove());</a>
<a name="ln550">                  ClefType clef = estaff-&gt;clef(tick);</a>
<a name="ln551">                  Key key       = estaff-&gt;key(tick);</a>
<a name="ln552">                  int ntpc;</a>
<a name="ln553">                  if (accidental) {</a>
<a name="ln554">                        AccidentalVal acci = Accidental::subtype2value(_is.accidentalType());</a>
<a name="ln555">                        int step = absStep(line, clef);</a>
<a name="ln556">                        int octave = step / 7;</a>
<a name="ln557">                        npitch = step2pitch(step) + octave * 12 + int(acci);</a>
<a name="ln558">                        forceAccidental = (npitch == line2pitch(line, clef, key));</a>
<a name="ln559">                        ntpc = step2tpc(step % 7, acci);</a>
<a name="ln560">                        }</a>
<a name="ln561">                  else {</a>
<a name="ln562">                        npitch = line2pitch(line, clef, key);</a>
<a name="ln563">                        ntpc = pitch2tpc(npitch, key, Prefer::NEAREST);</a>
<a name="ln564">                        }</a>
<a name="ln565"> </a>
<a name="ln566">                  Interval v = on-&gt;part()-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln567">                  if (v.isZero())</a>
<a name="ln568">                        ntpc1 = ntpc2 = ntpc;</a>
<a name="ln569">                  else {</a>
<a name="ln570">                        if (styleB(Sid::concertPitch)) {</a>
<a name="ln571">                              v.flip();</a>
<a name="ln572">                              ntpc1 = ntpc;</a>
<a name="ln573">                              ntpc2 = Ms::transposeTpc(ntpc, v, true);</a>
<a name="ln574">                              }</a>
<a name="ln575">                        else {</a>
<a name="ln576">                              npitch += v.chromatic;</a>
<a name="ln577">                              ntpc2 = ntpc;</a>
<a name="ln578">                              ntpc1 = Ms::transposeTpc(ntpc, v, true);</a>
<a name="ln579">                              }</a>
<a name="ln580">                        }</a>
<a name="ln581">                  }</a>
<a name="ln582">            else { //special case for octave</a>
<a name="ln583">                  Interval interval(7, 12);</a>
<a name="ln584">                  if (val &lt; 0)</a>
<a name="ln585">                        interval.flip();</a>
<a name="ln586">                  transposeInterval(on-&gt;pitch(), on-&gt;tpc(), &amp;npitch, &amp;ntpc1, interval, false);</a>
<a name="ln587">                  ntpc1 = on-&gt;tpc1();</a>
<a name="ln588">                  ntpc2 = on-&gt;tpc2();</a>
<a name="ln589">                  }</a>
<a name="ln590">            if (npitch &lt; 0 || npitch &gt; 127) {</a>
<a name="ln591">                  delete note;</a>
<a name="ln592">                  endCmd();</a>
<a name="ln593">                  return;</a>
<a name="ln594">                  }</a>
<a name="ln595">            note-&gt;setPitch(npitch, ntpc1, ntpc2);</a>
<a name="ln596"> </a>
<a name="ln597">            undoAddElement(note);</a>
<a name="ln598">            if (forceAccidental) {</a>
<a name="ln599">                  Accidental* a = new Accidental(this);</a>
<a name="ln600">                  a-&gt;setAccidentalType(_is.accidentalType());</a>
<a name="ln601">                  a-&gt;setRole(AccidentalRole::USER);</a>
<a name="ln602">                  a-&gt;setParent(note);</a>
<a name="ln603">                  undoAddElement(a);</a>
<a name="ln604">                  }</a>
<a name="ln605">            setPlayNote(true);</a>
<a name="ln606"> </a>
<a name="ln607">            select(note, SelectType::SINGLE, 0);</a>
<a name="ln608">            }</a>
<a name="ln609">      if (_is.noteEntryMode())</a>
<a name="ln610">            _is.setAccidentalType(AccidentalType::NONE);</a>
<a name="ln611">      _is.moveToNextInputPos();</a>
<a name="ln612">      endCmd();</a>
<a name="ln613">      }</a>
<a name="ln614"> </a>
<a name="ln615">//---------------------------------------------------------</a>
<a name="ln616">//   setGraceNote</a>
<a name="ln617">///   Create a grace note in front of a normal note.</a>
<a name="ln618">///   \arg ch is the chord of the normal note</a>
<a name="ln619">///   \arg pitch is the pitch of the grace note</a>
<a name="ln620">///   \arg is the grace note type</a>
<a name="ln621">///   \len is the visual duration of the grace note (1/16 or 1/32)</a>
<a name="ln622">//---------------------------------------------------------</a>
<a name="ln623"> </a>
<a name="ln624">Note* Score::setGraceNote(Chord* ch, int pitch, NoteType type, int len)</a>
<a name="ln625">      {</a>
<a name="ln626">      Note* note = new Note(this);</a>
<a name="ln627">      Chord* chord = new Chord(this);</a>
<a name="ln628"> </a>
<a name="ln629">      // allow grace notes to be added to other grace notes</a>
<a name="ln630">      // by really adding to parent chord</a>
<a name="ln631">      if (ch-&gt;noteType() != NoteType::NORMAL)</a>
<a name="ln632">            ch = toChord(ch-&gt;parent());</a>
<a name="ln633"> </a>
<a name="ln634">      chord-&gt;setTrack(ch-&gt;track());</a>
<a name="ln635">      chord-&gt;setParent(ch);</a>
<a name="ln636">      chord-&gt;add(note);</a>
<a name="ln637"> </a>
<a name="ln638">      note-&gt;setPitch(pitch);</a>
<a name="ln639">      // find corresponding note within chord and use its tpc information</a>
<a name="ln640">      for (Note* n : ch-&gt;notes()) {</a>
<a name="ln641">            if (n-&gt;pitch() == pitch) {</a>
<a name="ln642">                  note-&gt;setTpc1(n-&gt;tpc1());</a>
<a name="ln643">                  note-&gt;setTpc2(n-&gt;tpc2());</a>
<a name="ln644">                  break;</a>
<a name="ln645">                  }</a>
<a name="ln646">            }</a>
<a name="ln647">      // note with same pitch not found, derive tpc from pitch / key</a>
<a name="ln648">      if (!tpcIsValid(note-&gt;tpc1()) || !tpcIsValid(note-&gt;tpc2()))</a>
<a name="ln649">            note-&gt;setTpcFromPitch();</a>
<a name="ln650"> </a>
<a name="ln651">      TDuration d;</a>
<a name="ln652">      d.setVal(len);</a>
<a name="ln653">      chord-&gt;setDurationType(d);</a>
<a name="ln654">      chord-&gt;setTicks(d.fraction());</a>
<a name="ln655">      chord-&gt;setNoteType(type);</a>
<a name="ln656">      chord-&gt;setMag(ch-&gt;staff()-&gt;mag(chord-&gt;tick()) * styleD(Sid::graceNoteMag));</a>
<a name="ln657"> </a>
<a name="ln658">      undoAddElement(chord);</a>
<a name="ln659">      select(note, SelectType::SINGLE, 0);</a>
<a name="ln660">      return note;</a>
<a name="ln661">      }</a>
<a name="ln662"> </a>
<a name="ln663">//---------------------------------------------------------</a>
<a name="ln664">//   createCRSequence</a>
<a name="ln665">//    Create a rest or chord of len f.</a>
<a name="ln666">//    If f is not a basic len, create several rests or</a>
<a name="ln667">//    tied chords.</a>
<a name="ln668">//</a>
<a name="ln669">//    f     total len of ChordRest</a>
<a name="ln670">//    cr    prototype CR</a>
<a name="ln671">//    tick  start position in measure</a>
<a name="ln672">//---------------------------------------------------------</a>
<a name="ln673"> </a>
<a name="ln674">void Score::createCRSequence(const Fraction&amp; f, ChordRest* cr, const Fraction&amp; t)</a>
<a name="ln675">      {</a>
<a name="ln676">      Fraction tick(t);</a>
<a name="ln677">      Measure* measure = cr-&gt;measure();</a>
<a name="ln678">      ChordRest* ocr = 0;</a>
<a name="ln679">      for (TDuration d : toDurationList(f, true)) {</a>
<a name="ln680">            ChordRest* ncr = toChordRest(cr-&gt;clone());</a>
<a name="ln681">            ncr-&gt;setDurationType(d);</a>
<a name="ln682">            ncr-&gt;setTicks(d.fraction());</a>
<a name="ln683">            undoAddCR(ncr, measure, measure-&gt;tick() + tick);</a>
<a name="ln684">            if (cr-&gt;isChord() &amp;&amp; ocr) {</a>
<a name="ln685">                  Chord* nc = toChord(ncr);</a>
<a name="ln686">                  Chord* oc = toChord(ocr);</a>
<a name="ln687">                  for (unsigned int i = 0; i &lt; oc-&gt;notes().size(); ++i) {</a>
<a name="ln688">                        Note* on = oc-&gt;notes()[i];</a>
<a name="ln689">                        Note* nn = nc-&gt;notes()[i];</a>
<a name="ln690">                        Tie* tie = new Tie(this);</a>
<a name="ln691">                        tie-&gt;setStartNote(on);</a>
<a name="ln692">                        tie-&gt;setEndNote(nn);</a>
<a name="ln693">                        tie-&gt;setTrack(cr-&gt;track());</a>
<a name="ln694">                        on-&gt;setTieFor(tie);</a>
<a name="ln695">                        nn-&gt;setTieBack(tie);</a>
<a name="ln696">                        undoAddElement(tie);</a>
<a name="ln697">                        }</a>
<a name="ln698">                  }</a>
<a name="ln699"> </a>
<a name="ln700">            tick += ncr-&gt;actualTicks();</a>
<a name="ln701">            ocr = ncr;</a>
<a name="ln702">            }</a>
<a name="ln703">      }</a>
<a name="ln704"> </a>
<a name="ln705">//---------------------------------------------------------</a>
<a name="ln706">//   setNoteRest</a>
<a name="ln707">//    pitch == -1  -&gt; set rest</a>
<a name="ln708">//    return segment of last created note/rest</a>
<a name="ln709">//---------------------------------------------------------</a>
<a name="ln710"> </a>
<a name="ln711">Segment* Score::setNoteRest(Segment* segment, int track, NoteVal nval, Fraction sd, Direction stemDirection, bool forceAccidental, bool rhythmic)</a>
<a name="ln712">      {</a>
<a name="ln713">      Q_ASSERT(segment-&gt;segmentType() == SegmentType::ChordRest);</a>
<a name="ln714"> </a>
<a name="ln715">      bool isRest   = nval.pitch == -1;</a>
<a name="ln716">      Fraction tick = segment-&gt;tick();</a>
<a name="ln717">      Element* nr   = 0;</a>
<a name="ln718">      Tie* tie      = 0;</a>
<a name="ln719">      ChordRest* cr = toChordRest(segment-&gt;element(track));</a>
<a name="ln720"> </a>
<a name="ln721">      Measure* measure = 0;</a>
<a name="ln722">      for (;;) {</a>
<a name="ln723">            if (track % VOICES)</a>
<a name="ln724">                  expandVoice(segment, track);</a>
<a name="ln725"> </a>
<a name="ln726">            // the returned gap ends at the measure boundary or at tuplet end</a>
<a name="ln727">            Fraction dd = makeGap(segment, track, sd, cr ? cr-&gt;tuplet() : 0);</a>
<a name="ln728"> </a>
<a name="ln729">            if (dd.isZero()) {</a>
<a name="ln730">                  qDebug(&quot;cannot get gap at %d type: %d/%d&quot;, tick.ticks(), sd.numerator(),</a>
<a name="ln731">                     sd.denominator());</a>
<a name="ln732">                  break;</a>
<a name="ln733">                  }</a>
<a name="ln734"> </a>
<a name="ln735">            measure = segment-&gt;measure();</a>
<a name="ln736">            std::vector&lt;TDuration&gt; dl;</a>
<a name="ln737">            if (rhythmic)</a>
<a name="ln738">                  dl = toRhythmicDurationList(dd, isRest, segment-&gt;rtick(), sigmap()-&gt;timesig(tick).nominal(), measure, 1);</a>
<a name="ln739">            else</a>
<a name="ln740">                  dl = toDurationList(dd, true);</a>
<a name="ln741">            size_t n = dl.size();</a>
<a name="ln742">            for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln743">                  const TDuration&amp; d = dl[i];</a>
<a name="ln744">                  ChordRest* ncr;</a>
<a name="ln745">                  Note* note = 0;</a>
<a name="ln746">                  Tie* addTie = 0;</a>
<a name="ln747">                  if (isRest) {</a>
<a name="ln748">                        nr = ncr = new Rest(this);</a>
<a name="ln749">                        nr-&gt;setTrack(track);</a>
<a name="ln750">                        ncr-&gt;setDurationType(d);</a>
<a name="ln751">                        ncr-&gt;setTicks(d == TDuration::DurationType::V_MEASURE ? measure-&gt;ticks() : d.fraction());</a>
<a name="ln752">                        }</a>
<a name="ln753">                  else {</a>
<a name="ln754">                        nr = note = new Note(this);</a>
<a name="ln755"> </a>
<a name="ln756">                        if (tie) {</a>
<a name="ln757">                              tie-&gt;setEndNote(note);</a>
<a name="ln758">                              note-&gt;setTieBack(tie);</a>
<a name="ln759">                              addTie = tie;</a>
<a name="ln760">                              }</a>
<a name="ln761">                        Chord* chord = new Chord(this);</a>
<a name="ln762">                        chord-&gt;setTrack(track);</a>
<a name="ln763">                        chord-&gt;setDurationType(d);</a>
<a name="ln764">                        chord-&gt;setTicks(d.fraction());</a>
<a name="ln765">                        chord-&gt;setStemDirection(stemDirection);</a>
<a name="ln766">                        chord-&gt;add(note);</a>
<a name="ln767">                        note-&gt;setNval(nval, tick);</a>
<a name="ln768">                        if (forceAccidental) {</a>
<a name="ln769">                              int tpc = styleB(Sid::concertPitch) ? nval.tpc1 : nval.tpc2;</a>
<a name="ln770">                              AccidentalVal alter = tpc2alter(tpc);</a>
<a name="ln771">                              AccidentalType at = Accidental::value2subtype(alter);</a>
<a name="ln772">                              Accidental* a = new Accidental(this);</a>
<a name="ln773">                              a-&gt;setAccidentalType(at);</a>
<a name="ln774">                              a-&gt;setRole(AccidentalRole::USER);</a>
<a name="ln775">                              note-&gt;add(a);</a>
<a name="ln776">                              }</a>
<a name="ln777">                        ncr = chord;</a>
<a name="ln778">                        if (i+1 &lt; n) {</a>
<a name="ln779">                              tie = new Tie(this);</a>
<a name="ln780">                              tie-&gt;setStartNote(note);</a>
<a name="ln781">                              tie-&gt;setTrack(track);</a>
<a name="ln782">                              note-&gt;setTieFor(tie);</a>
<a name="ln783">                              }</a>
<a name="ln784">                        }</a>
<a name="ln785">                  ncr-&gt;setTuplet(cr ? cr-&gt;tuplet() : 0);</a>
<a name="ln786">                  undoAddCR(ncr, measure, tick);</a>
<a name="ln787">                  if (addTie)</a>
<a name="ln788">                        undoAddElement(addTie);</a>
<a name="ln789">                  setPlayNote(true);</a>
<a name="ln790">                  segment = ncr-&gt;segment();</a>
<a name="ln791">                  tick += ncr-&gt;actualTicks();</a>
<a name="ln792">                  }</a>
<a name="ln793"> </a>
<a name="ln794">            sd -= dd;</a>
<a name="ln795">            if (sd.isZero())</a>
<a name="ln796">                  break;</a>
<a name="ln797"> </a>
<a name="ln798">            Segment* nseg = tick2segment(tick, false, SegmentType::ChordRest);</a>
<a name="ln799">            if (nseg == 0) {</a>
<a name="ln800">                  qDebug(&quot;reached end of score&quot;);</a>
<a name="ln801">                  break;</a>
<a name="ln802">                  }</a>
<a name="ln803">            segment = nseg;</a>
<a name="ln804"> </a>
<a name="ln805">            cr = toChordRest(segment-&gt;element(track));</a>
<a name="ln806"> </a>
<a name="ln807">            if (cr == 0) {</a>
<a name="ln808">                  if (track % VOICES)</a>
<a name="ln809">                        cr = addRest(segment, track, TDuration(TDuration::DurationType::V_MEASURE), 0);</a>
<a name="ln810">                  else {</a>
<a name="ln811">                        qDebug(&quot;no rest in voice 0&quot;);</a>
<a name="ln812">                        break;</a>
<a name="ln813">                        }</a>
<a name="ln814">                  }</a>
<a name="ln815">            //</a>
<a name="ln816">            //  Note does not fit on current measure, create Tie to</a>
<a name="ln817">            //  next part of note</a>
<a name="ln818">            if (!isRest) {</a>
<a name="ln819">                  tie = new Tie(this);</a>
<a name="ln820">                  tie-&gt;setStartNote((Note*)nr);</a>
<a name="ln821">                  tie-&gt;setTrack(nr-&gt;track());</a>
<a name="ln822">                  ((Note*)nr)-&gt;setTieFor(tie);</a>
<a name="ln823">                  }</a>
<a name="ln824">            }</a>
<a name="ln825">      if (tie)</a>
<a name="ln826">            connectTies();</a>
<a name="ln827">      if (nr) {</a>
<a name="ln828">            if (_is.slur() &amp;&amp; nr-&gt;type() == ElementType::NOTE) {</a>
<a name="ln829">                  // If the start element was the same as the end element when the slur was created,</a>
<a name="ln830">                  // the end grip of the front slur segment was given an x-offset of 3.0 * spatium().</a>
<a name="ln831">                  // Now that the slur is about to be given a new end element, this should be reset.</a>
<a name="ln832">                  if (_is.slur()-&gt;endElement() == _is.slur()-&gt;startElement())</a>
<a name="ln833">                        _is.slur()-&gt;frontSegment()-&gt;reset();</a>
<a name="ln834">                  //</a>
<a name="ln835">                  // extend slur</a>
<a name="ln836">                  //</a>
<a name="ln837">                  Chord* chord = toNote(nr)-&gt;chord();</a>
<a name="ln838">                  _is.slur()-&gt;undoChangeProperty(Pid::SPANNER_TICKS, chord-&gt;tick() - _is.slur()-&gt;tick());</a>
<a name="ln839">                  for (ScoreElement* se : _is.slur()-&gt;linkList()) {</a>
<a name="ln840">                        Slur* slur = toSlur(se);</a>
<a name="ln841">                        for (ScoreElement* ee : chord-&gt;linkList()) {</a>
<a name="ln842">                              Element* e = static_cast&lt;Element*&gt;(ee);</a>
<a name="ln843">                              if (e-&gt;score() == slur-&gt;score() &amp;&amp; e-&gt;track() == slur-&gt;track2()) {</a>
<a name="ln844">                                    slur-&gt;score()-&gt;undo(new ChangeSpannerElements(slur, slur-&gt;startElement(), e));</a>
<a name="ln845">                                    break;</a>
<a name="ln846">                                    }</a>
<a name="ln847">                              }</a>
<a name="ln848">                        }</a>
<a name="ln849">                  }</a>
<a name="ln850">            select(nr, SelectType::SINGLE, 0);</a>
<a name="ln851">            }</a>
<a name="ln852">      return segment;</a>
<a name="ln853">      }</a>
<a name="ln854"> </a>
<a name="ln855">//---------------------------------------------------------</a>
<a name="ln856">//   makeGap</a>
<a name="ln857">//    make time gap at tick by removing/shortening</a>
<a name="ln858">//    chord/rest</a>
<a name="ln859">//</a>
<a name="ln860">//    if keepChord, the chord at tick is not removed</a>
<a name="ln861">//</a>
<a name="ln862">//    gap does not exceed measure or scope of tuplet</a>
<a name="ln863">//</a>
<a name="ln864">//    return size of actual gap</a>
<a name="ln865">//---------------------------------------------------------</a>
<a name="ln866"> </a>
<a name="ln867">Fraction Score::makeGap(Segment* segment, int track, const Fraction&amp; _sd, Tuplet* tuplet, bool keepChord)</a>
<a name="ln868">      {</a>
<a name="ln869">      Q_ASSERT(_sd.numerator());</a>
<a name="ln870"> </a>
<a name="ln871">      Measure* measure = segment-&gt;measure();</a>
<a name="ln872">      Fraction accumulated;</a>
<a name="ln873">      Fraction sd = _sd;</a>
<a name="ln874"> </a>
<a name="ln875">      //</a>
<a name="ln876">      // remember first segment which should</a>
<a name="ln877">      // not be deleted (it may contain other elements we want to preserve)</a>
<a name="ln878">      //</a>
<a name="ln879">      Segment* firstSegment = segment;</a>
<a name="ln880">      const Fraction firstSegmentEnd = firstSegment-&gt;tick() + firstSegment-&gt;ticks();</a>
<a name="ln881">      Fraction nextTick = segment-&gt;tick();</a>
<a name="ln882"> </a>
<a name="ln883">      for (Segment* seg = firstSegment; seg; seg = seg-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln884">            //</a>
<a name="ln885">            // voices != 0 may have gaps:</a>
<a name="ln886">            //</a>
<a name="ln887">            ChordRest* cr = toChordRest(seg-&gt;element(track));</a>
<a name="ln888">            if (!cr) {</a>
<a name="ln889">                  if (seg-&gt;tick() &lt; nextTick)</a>
<a name="ln890">                        continue;</a>
<a name="ln891">                  Segment* seg1 = seg-&gt;next(SegmentType::ChordRest);</a>
<a name="ln892">                  Fraction tick2     = seg1 ? seg1-&gt;tick() : seg-&gt;measure()-&gt;tick() + seg-&gt;measure()-&gt;ticks();</a>
<a name="ln893">                  segment       = seg;</a>
<a name="ln894">                  Fraction td(tick2 - seg-&gt;tick());</a>
<a name="ln895">                  if (td &gt; sd)</a>
<a name="ln896">                        td = sd;</a>
<a name="ln897">                  accumulated += td;</a>
<a name="ln898">                  sd -= td;</a>
<a name="ln899">                  if (sd.isZero())</a>
<a name="ln900">                        break;</a>
<a name="ln901">                  nextTick = tick2;</a>
<a name="ln902">                  continue;</a>
<a name="ln903">                  }</a>
<a name="ln904">            if (seg-&gt;tick() &gt; nextTick) {</a>
<a name="ln905">                  // there was a gap</a>
<a name="ln906">                  Fraction td(seg-&gt;tick() - nextTick);</a>
<a name="ln907">                  if (td &gt; sd)</a>
<a name="ln908">                        td = sd;</a>
<a name="ln909">                  accumulated += td;</a>
<a name="ln910">                  sd -= td;</a>
<a name="ln911">                  if (sd.isZero())</a>
<a name="ln912">                        break;</a>
<a name="ln913">                  }</a>
<a name="ln914">            //</a>
<a name="ln915">            // limit to tuplet level</a>
<a name="ln916">            //</a>
<a name="ln917">            if (tuplet) {</a>
<a name="ln918">                  bool tupletEnd = true;</a>
<a name="ln919">                  Tuplet* t = cr-&gt;tuplet();</a>
<a name="ln920">                  while (t) {</a>
<a name="ln921">                        if (cr-&gt;tuplet() == tuplet) {</a>
<a name="ln922">                              tupletEnd = false;</a>
<a name="ln923">                              break;</a>
<a name="ln924">                              }</a>
<a name="ln925">                        t = t-&gt;tuplet();</a>
<a name="ln926">                        }</a>
<a name="ln927">                  if (tupletEnd)</a>
<a name="ln928">                        break;</a>
<a name="ln929">                  }</a>
<a name="ln930">            Fraction td(cr-&gt;ticks());</a>
<a name="ln931"> </a>
<a name="ln932">            // remove tremolo between 2 notes, if present</a>
<a name="ln933">            if (cr-&gt;isChord()) {</a>
<a name="ln934">                  Chord* c = toChord(cr);</a>
<a name="ln935">                  if (c-&gt;tremolo()) {</a>
<a name="ln936">                        Tremolo* tremolo = c-&gt;tremolo();</a>
<a name="ln937">                        if (tremolo-&gt;twoNotes())</a>
<a name="ln938">                              undoRemoveElement(tremolo);</a>
<a name="ln939">                        }</a>
<a name="ln940">                  }</a>
<a name="ln941">            Tuplet* ltuplet = cr-&gt;tuplet();</a>
<a name="ln942">            if (ltuplet != tuplet) {</a>
<a name="ln943">                  //</a>
<a name="ln944">                  // Current location points to the start of a (nested)tuplet.</a>
<a name="ln945">                  // We have to remove the complete tuplet.</a>
<a name="ln946"> </a>
<a name="ln947">                  // get top level tuplet</a>
<a name="ln948">                  while (ltuplet-&gt;tuplet())</a>
<a name="ln949">                        ltuplet = ltuplet-&gt;tuplet();</a>
<a name="ln950"> </a>
<a name="ln951">                  // get last segment of tuplet, drilling down to leaf nodes as necessary</a>
<a name="ln952">                  Tuplet* t = ltuplet;</a>
<a name="ln953">                  while (t-&gt;elements().back()-&gt;isTuplet())</a>
<a name="ln954">                        t = toTuplet(t-&gt;elements().back());</a>
<a name="ln955">                  seg = toChordRest(t-&gt;elements().back())-&gt;segment();</a>
<a name="ln956"> </a>
<a name="ln957">                  // now delete the full tuplet</a>
<a name="ln958">                  td = ltuplet-&gt;ticks();</a>
<a name="ln959">                  cmdDeleteTuplet(ltuplet, false);</a>
<a name="ln960">                  tuplet = 0;</a>
<a name="ln961">                  }</a>
<a name="ln962">            else {</a>
<a name="ln963">                  if (seg != firstSegment || !keepChord)</a>
<a name="ln964">                        undoRemoveElement(cr);</a>
<a name="ln965">                  // even if there was a tuplet, we didn't remove it</a>
<a name="ln966">                  ltuplet = 0;</a>
<a name="ln967">                  }</a>
<a name="ln968">            Fraction timeStretch = cr-&gt;staff()-&gt;timeStretch(cr-&gt;tick());</a>
<a name="ln969">            nextTick += actualTicks(td, tuplet, timeStretch);</a>
<a name="ln970">            if (sd &lt; td) {</a>
<a name="ln971">                  //</a>
<a name="ln972">                  // we removed too much</a>
<a name="ln973">                  //</a>
<a name="ln974">                  accumulated = _sd;</a>
<a name="ln975">                  Fraction rd = td - sd;</a>
<a name="ln976"> </a>
<a name="ln977">                  std::vector&lt;TDuration&gt; dList = toDurationList(rd, false);</a>
<a name="ln978">                  if (dList.empty())</a>
<a name="ln979">                        break;</a>
<a name="ln980"> </a>
<a name="ln981">                  Fraction tick = cr-&gt;tick() + actualTicks(sd, tuplet, timeStretch);</a>
<a name="ln982"> </a>
<a name="ln983">                  if ((tuplet == 0) &amp;&amp; (((measure-&gt;tick() - tick).ticks() % dList[0].ticks().ticks()) == 0)) {</a>
<a name="ln984">                        for (TDuration d : dList) {</a>
<a name="ln985">                              if (ltuplet) {</a>
<a name="ln986">                                    // take care not to recreate tuplet we just deleted</a>
<a name="ln987">                                    Rest* r = setRest(tick, track, d.fraction(), false, 0, false);</a>
<a name="ln988">                                    tick += r-&gt;actualTicks();</a>
<a name="ln989">                                    }</a>
<a name="ln990">                              else {</a>
<a name="ln991">                                    tick += addClone(cr, tick, d)-&gt;actualTicks();</a>
<a name="ln992">                                    }</a>
<a name="ln993">                              }</a>
<a name="ln994">                        }</a>
<a name="ln995">                  else {</a>
<a name="ln996">                        for (size_t i = dList.size(); i &gt; 0; --i) { // loop needs to be in this reverse order</a>
<a name="ln997">                              if (ltuplet) {</a>
<a name="ln998">                                    // take care not to recreate tuplet we just deleted</a>
<a name="ln999">                                    Rest* r = setRest(tick, track, dList[i-1].fraction(), false, 0, false);</a>
<a name="ln1000">                                    tick += r-&gt;actualTicks();</a>
<a name="ln1001">                                    }</a>
<a name="ln1002">                              else {</a>
<a name="ln1003">                                    tick += addClone(cr, tick, dList[i-1])-&gt;actualTicks();</a>
<a name="ln1004">                                    }</a>
<a name="ln1005">                              }</a>
<a name="ln1006">                        }</a>
<a name="ln1007">                  break;</a>
<a name="ln1008">                  }</a>
<a name="ln1009">            accumulated += td;</a>
<a name="ln1010">            sd          -= td;</a>
<a name="ln1011">            if (sd.isZero())</a>
<a name="ln1012">                  break;</a>
<a name="ln1013">            }</a>
<a name="ln1014">//      Fraction ticks = measure-&gt;tick() + measure-&gt;ticks() - segment-&gt;tick();</a>
<a name="ln1015">//      Fraction td = Fraction::fromTicks(ticks);</a>
<a name="ln1016">// NEEDS REVIEW !!</a>
<a name="ln1017">// once the statement below is removed, these two lines do nothing</a>
<a name="ln1018">//      if (td &gt; sd)</a>
<a name="ln1019">//            td = sd;</a>
<a name="ln1020">// ???  accumulated should already contain the total value of the created gap: line 749, 811 or 838</a>
<a name="ln1021">//      this line creates a qreal-sized gap if the needed gap crosses a measure boundary</a>
<a name="ln1022">//      by adding again the duration already added in line 838</a>
<a name="ln1023">//      accumulated += td;</a>
<a name="ln1024"> </a>
<a name="ln1025">      const Fraction t1 = firstSegmentEnd;</a>
<a name="ln1026">      const Fraction t2 = firstSegment-&gt;tick() + accumulated;</a>
<a name="ln1027">      if (t1 &lt; t2) {</a>
<a name="ln1028">            Segment* s1 = tick2rightSegment(t1);</a>
<a name="ln1029">            Segment* s2 = tick2rightSegment(t2);</a>
<a name="ln1030">            typedef SelectionFilterType Sel;</a>
<a name="ln1031">            // chord symbols can exist without chord/rest so they should not be removed</a>
<a name="ln1032">            constexpr Sel filter = static_cast&lt;Sel&gt;(int(Sel::ALL) &amp; ~int(Sel::CHORD_SYMBOL));</a>
<a name="ln1033">            deleteAnnotationsFromRange(s1, s2, track, track + 1, filter);</a>
<a name="ln1034">            deleteSpannersFromRange(t1, t2, track, track + 1, filter);</a>
<a name="ln1035">            }</a>
<a name="ln1036"> </a>
<a name="ln1037">      return accumulated;</a>
<a name="ln1038">      }</a>
<a name="ln1039"> </a>
<a name="ln1040">//---------------------------------------------------------</a>
<a name="ln1041">//   makeGap1</a>
<a name="ln1042">//    make time gap for each voice</a>
<a name="ln1043">//    starting at tick+voiceOffset[voice] by removing/shortening</a>
<a name="ln1044">//    chord/rest</a>
<a name="ln1045">//    - cr is top level (not part of a tuplet)</a>
<a name="ln1046">//    - do not stop at measure end</a>
<a name="ln1047">//---------------------------------------------------------</a>
<a name="ln1048"> </a>
<a name="ln1049">bool Score::makeGap1(const Fraction&amp; baseTick, int staffIdx, const Fraction&amp; len, int voiceOffset[VOICES])</a>
<a name="ln1050">      {</a>
<a name="ln1051">      Segment* seg = tick2segment(baseTick, true, SegmentType::ChordRest);</a>
<a name="ln1052">      if (!seg) {</a>
<a name="ln1053">            qDebug(&quot;no segment to paste at tick %d&quot;, baseTick.ticks());</a>
<a name="ln1054">            return false;</a>
<a name="ln1055">            }</a>
<a name="ln1056">      int strack = staffIdx * VOICES;</a>
<a name="ln1057">      for (int track = strack; track &lt; strack + VOICES; track++) {</a>
<a name="ln1058">            if (voiceOffset[track-strack] == -1)</a>
<a name="ln1059">                  continue;</a>
<a name="ln1060">            Fraction tick = baseTick + Fraction::fromTicks(voiceOffset[track-strack]);</a>
<a name="ln1061">            Measure* m   = tick2measure(tick);</a>
<a name="ln1062">            if ((track % VOICES) &amp;&amp; !m-&gt;hasVoices(staffIdx))</a>
<a name="ln1063">                  continue;</a>
<a name="ln1064"> </a>
<a name="ln1065">            Fraction newLen = len - Fraction::fromTicks(voiceOffset[track-strack]);</a>
<a name="ln1066">            Q_ASSERT(newLen.numerator() != 0);</a>
<a name="ln1067"> </a>
<a name="ln1068">            if (newLen &gt; Fraction(0,1)) {</a>
<a name="ln1069">                  const Fraction endTick = tick + newLen;</a>
<a name="ln1070">                  deleteAnnotationsFromRange(tick2rightSegment(tick), tick2rightSegment(endTick), track, track + 1, selectionFilter());</a>
<a name="ln1071">                  deleteSpannersFromRange(tick, endTick, track, track + 1, selectionFilter());</a>
<a name="ln1072">                  }</a>
<a name="ln1073"> </a>
<a name="ln1074">            seg = m-&gt;undoGetSegment(SegmentType::ChordRest, tick);</a>
<a name="ln1075">            bool result = makeGapVoice(seg, track, newLen, tick);</a>
<a name="ln1076">            if (track == strack &amp;&amp; !result) // makeGap failed for first voice</a>
<a name="ln1077">                  return false;</a>
<a name="ln1078">            }</a>
<a name="ln1079">      return true;</a>
<a name="ln1080">      }</a>
<a name="ln1081"> </a>
<a name="ln1082">bool Score::makeGapVoice(Segment* seg, int track, Fraction len, const Fraction&amp; tick)</a>
<a name="ln1083">      {</a>
<a name="ln1084">      ChordRest* cr = 0;</a>
<a name="ln1085">      cr = toChordRest(seg-&gt;element(track));</a>
<a name="ln1086">      if (!cr) {</a>
<a name="ln1087">            // check if we are in the middle of a chord/rest</a>
<a name="ln1088">            Segment* seg1 = seg-&gt;prev(SegmentType::ChordRest);</a>
<a name="ln1089">            for (;;) {</a>
<a name="ln1090">                  if (seg1 == 0) {</a>
<a name="ln1091">                        if (!(track % VOICES))</a>
<a name="ln1092">                              qDebug(&quot;no segment before tick %d&quot;, tick.ticks());</a>
<a name="ln1093">                        // this happens only for voices other than voice 1</a>
<a name="ln1094">                        expandVoice(seg, track);</a>
<a name="ln1095">                        return makeGapVoice(seg,track,len,tick);</a>
<a name="ln1096">                        }</a>
<a name="ln1097">                  if (seg1-&gt;element(track))</a>
<a name="ln1098">                        break;</a>
<a name="ln1099">                  seg1 = seg1-&gt;prev(SegmentType::ChordRest);</a>
<a name="ln1100">                  }</a>
<a name="ln1101">            ChordRest* cr1 = toChordRest(seg1-&gt;element(track));</a>
<a name="ln1102">            Fraction srcF = cr1-&gt;ticks();</a>
<a name="ln1103">            Fraction dstF = tick - cr1-&gt;tick();</a>
<a name="ln1104">            std::vector&lt;TDuration&gt; dList = toDurationList(dstF, true);</a>
<a name="ln1105">            size_t n = dList.size();</a>
<a name="ln1106">            undoChangeChordRestLen(cr1, TDuration(dList[0]));</a>
<a name="ln1107">            if (n &gt; 1) {</a>
<a name="ln1108">                  Fraction crtick = cr1-&gt;tick() + cr1-&gt;actualTicks();</a>
<a name="ln1109">                  Measure* measure = tick2measure(crtick);</a>
<a name="ln1110">                  if (cr1-&gt;type() == ElementType::CHORD) {</a>
<a name="ln1111">                        // split Chord</a>
<a name="ln1112">                        Chord* c = toChord(cr1);</a>
<a name="ln1113">                        for (size_t i = 1; i &lt; n; ++i) {</a>
<a name="ln1114">                              TDuration d = dList[i];</a>
<a name="ln1115">                              Chord* c2 = addChord(crtick, d, c, true, c-&gt;tuplet());</a>
<a name="ln1116">                              c = c2;</a>
<a name="ln1117">                              seg1 = c-&gt;segment();</a>
<a name="ln1118">                              crtick += c-&gt;actualTicks();</a>
<a name="ln1119">                              }</a>
<a name="ln1120">                        }</a>
<a name="ln1121">                  else {</a>
<a name="ln1122">                        // split Rest</a>
<a name="ln1123">                        Rest* r       = toRest(cr1);</a>
<a name="ln1124">                        for (size_t i = 1; i &lt; n; ++i) {</a>
<a name="ln1125">                              TDuration d = dList[i];</a>
<a name="ln1126">                              Rest* r2      = toRest(r-&gt;clone());</a>
<a name="ln1127">                              r2-&gt;setTicks(d.fraction());</a>
<a name="ln1128">                              r2-&gt;setDurationType(d);</a>
<a name="ln1129">                              undoAddCR(r2, measure, crtick);</a>
<a name="ln1130">                              seg1 = r2-&gt;segment();</a>
<a name="ln1131">                              crtick += r2-&gt;actualTicks();</a>
<a name="ln1132">                              }</a>
<a name="ln1133">                        }</a>
<a name="ln1134">                  }</a>
<a name="ln1135">            setRest(tick, track, srcF - dstF, true, 0);</a>
<a name="ln1136">            for (;;) {</a>
<a name="ln1137">                  seg1 = seg1-&gt;next1(SegmentType::ChordRest);</a>
<a name="ln1138">                  if (seg1 == 0) {</a>
<a name="ln1139">                        qDebug(&quot;no segment&quot;);</a>
<a name="ln1140">                        return false;</a>
<a name="ln1141">                        }</a>
<a name="ln1142">                  if (seg1-&gt;element(track)) {</a>
<a name="ln1143">                        cr = toChordRest(seg1-&gt;element(track));</a>
<a name="ln1144">                        break;</a>
<a name="ln1145">                        }</a>
<a name="ln1146">                  }</a>
<a name="ln1147">            }</a>
<a name="ln1148"> </a>
<a name="ln1149">      for (;;) {</a>
<a name="ln1150">            if (!cr) {</a>
<a name="ln1151">                  qDebug(&quot;cannot make gap&quot;);</a>
<a name="ln1152">                  return false;</a>
<a name="ln1153">                  }</a>
<a name="ln1154">            Fraction l = makeGap(cr-&gt;segment(), cr-&gt;track(), len, 0);</a>
<a name="ln1155">            if (l.isZero()) {</a>
<a name="ln1156">                  qDebug(&quot;returns zero gap&quot;);</a>
<a name="ln1157">                  return false;</a>
<a name="ln1158">                  }</a>
<a name="ln1159">            len -= l;</a>
<a name="ln1160">            if (len.isZero())</a>
<a name="ln1161">                  break;</a>
<a name="ln1162">            // go to next cr</a>
<a name="ln1163">            Measure* m = cr-&gt;measure()-&gt;nextMeasure();</a>
<a name="ln1164">            if (m == 0) {</a>
<a name="ln1165">                  qDebug(&quot;EOS reached&quot;);</a>
<a name="ln1166">                  insertMeasure(ElementType::MEASURE, 0, false);</a>
<a name="ln1167">                  m = cr-&gt;measure()-&gt;nextMeasure();</a>
<a name="ln1168">                  if (m == 0) {</a>
<a name="ln1169">                        qDebug(&quot;===EOS reached&quot;);</a>
<a name="ln1170">                        return true;</a>
<a name="ln1171">                        }</a>
<a name="ln1172">                  }</a>
<a name="ln1173">            // first segment in measure was removed, have to recreate it</a>
<a name="ln1174">            Segment* s = m-&gt;undoGetSegment(SegmentType::ChordRest, m-&gt;tick());</a>
<a name="ln1175">            int t  = cr-&gt;track();</a>
<a name="ln1176">            cr = toChordRest(s-&gt;element(t));</a>
<a name="ln1177">            if (cr == 0) {</a>
<a name="ln1178">                  addRest(s, t, TDuration(TDuration::DurationType::V_MEASURE), 0);</a>
<a name="ln1179">                  cr = toChordRest(s-&gt;element(t));</a>
<a name="ln1180">                  }</a>
<a name="ln1181">            }</a>
<a name="ln1182">      return true;</a>
<a name="ln1183">      }</a>
<a name="ln1184"> </a>
<a name="ln1185">//---------------------------------------------------------</a>
<a name="ln1186">//   splitGapToMeasureBoundaries</a>
<a name="ln1187">//    cr  - start of gap</a>
<a name="ln1188">//    gap - gap len</a>
<a name="ln1189">//---------------------------------------------------------</a>
<a name="ln1190"> </a>
<a name="ln1191">QList&lt;Fraction&gt; Score::splitGapToMeasureBoundaries(ChordRest* cr, Fraction gap)</a>
<a name="ln1192">      {</a>
<a name="ln1193">      QList&lt;Fraction&gt; flist;</a>
<a name="ln1194"> </a>
<a name="ln1195">      Tuplet* tuplet = cr-&gt;tuplet();</a>
<a name="ln1196">      if (tuplet) {</a>
<a name="ln1197">            Fraction rest = tuplet-&gt;elementsDuration();</a>
<a name="ln1198">            for (DurationElement* de : tuplet-&gt;elements()) {</a>
<a name="ln1199">                  if (de == cr)</a>
<a name="ln1200">                        break;</a>
<a name="ln1201">                  rest -= de-&gt;ticks();</a>
<a name="ln1202">                  }</a>
<a name="ln1203">            if (rest &lt; gap)</a>
<a name="ln1204">                  qDebug(&quot;does not fit in tuplet&quot;);</a>
<a name="ln1205">            else</a>
<a name="ln1206">                  flist.append(gap);</a>
<a name="ln1207">            return flist;</a>
<a name="ln1208">            }</a>
<a name="ln1209"> </a>
<a name="ln1210">      Segment* s = cr-&gt;segment();</a>
<a name="ln1211">      while (gap &gt; Fraction(0,1)) {</a>
<a name="ln1212">            Measure* m    = s-&gt;measure();</a>
<a name="ln1213">            Fraction timeStretch = cr-&gt;staff()-&gt;timeStretch(s-&gt;tick());</a>
<a name="ln1214">            Fraction rest = (m-&gt;ticks() - s-&gt;rtick()) * timeStretch;</a>
<a name="ln1215">            if (rest &gt;= gap) {</a>
<a name="ln1216">                  flist.append(gap);</a>
<a name="ln1217">                  return flist;</a>
<a name="ln1218">                  }</a>
<a name="ln1219">            flist.append(rest);</a>
<a name="ln1220">            gap -= rest;</a>
<a name="ln1221">            m = m-&gt;nextMeasure();</a>
<a name="ln1222">            if (m == 0)</a>
<a name="ln1223">                  return flist;</a>
<a name="ln1224">            s = m-&gt;first(SegmentType::ChordRest);</a>
<a name="ln1225">            }</a>
<a name="ln1226">      return flist;</a>
<a name="ln1227">      }</a>
<a name="ln1228"> </a>
<a name="ln1229">//---------------------------------------------------------</a>
<a name="ln1230">//   changeCRlen</a>
<a name="ln1231">//---------------------------------------------------------</a>
<a name="ln1232"> </a>
<a name="ln1233">void Score::changeCRlen(ChordRest* cr, const TDuration&amp; d)</a>
<a name="ln1234">      {</a>
<a name="ln1235">      Fraction dstF;</a>
<a name="ln1236">      if (d.type() == TDuration::DurationType::V_MEASURE)</a>
<a name="ln1237">            dstF = cr-&gt;measure()-&gt;stretchedLen(cr-&gt;staff());</a>
<a name="ln1238">      else</a>
<a name="ln1239">            dstF = d.fraction();</a>
<a name="ln1240">      changeCRlen(cr, dstF);</a>
<a name="ln1241">      }</a>
<a name="ln1242"> </a>
<a name="ln1243">void Score::changeCRlen(ChordRest* cr, const Fraction&amp; dstF, bool fillWithRest)</a>
<a name="ln1244">      {</a>
<a name="ln1245">      if (cr-&gt;isRepeatMeasure()) {</a>
<a name="ln1246">            // it is not clear what should this</a>
<a name="ln1247">            // operation mean for measure repeats.</a>
<a name="ln1248">            return;</a>
<a name="ln1249">            }</a>
<a name="ln1250">      Fraction srcF(cr-&gt;ticks());</a>
<a name="ln1251">      if (srcF == dstF) {</a>
<a name="ln1252">            if (cr-&gt;isFullMeasureRest())</a>
<a name="ln1253">                  undoChangeChordRestLen(cr, dstF);</a>
<a name="ln1254">            return;</a>
<a name="ln1255">            }</a>
<a name="ln1256"> </a>
<a name="ln1257">      //keep selected element if any</a>
<a name="ln1258">      Element* selElement = selection().isSingle() ? getSelectedElement() : 0;</a>
<a name="ln1259"> </a>
<a name="ln1260">      int track      = cr-&gt;track();</a>
<a name="ln1261">      Tuplet* tuplet = cr-&gt;tuplet();</a>
<a name="ln1262"> </a>
<a name="ln1263">      if (srcF &gt; dstF) {</a>
<a name="ln1264">            //</a>
<a name="ln1265">            // make shorter and fill with rest</a>
<a name="ln1266">            //</a>
<a name="ln1267">            deselectAll();</a>
<a name="ln1268">            if (cr-&gt;isChord()) {</a>
<a name="ln1269">                  //</a>
<a name="ln1270">                  // remove ties and tremolo between 2 notes</a>
<a name="ln1271">                  //</a>
<a name="ln1272">                  Chord* c = toChord(cr);</a>
<a name="ln1273">                  if (c-&gt;tremolo()) {</a>
<a name="ln1274">                        Tremolo* tremolo = c-&gt;tremolo();</a>
<a name="ln1275">                        if (tremolo-&gt;twoNotes())</a>
<a name="ln1276">                              undoRemoveElement(tremolo);</a>
<a name="ln1277">                        }</a>
<a name="ln1278">                  foreach (Note* n, c-&gt;notes()) {</a>
<a name="ln1279">                        if (n-&gt;tieFor())</a>
<a name="ln1280">                              undoRemoveElement(n-&gt;tieFor());</a>
<a name="ln1281">                        }</a>
<a name="ln1282">                  }</a>
<a name="ln1283">            Fraction timeStretch = cr-&gt;staff()-&gt;timeStretch(cr-&gt;tick());</a>
<a name="ln1284">            std::vector&lt;TDuration&gt; dList = toDurationList(dstF, true);</a>
<a name="ln1285">            undoChangeChordRestLen(cr, dList[0]);</a>
<a name="ln1286">            Fraction tick2 = cr-&gt;tick();</a>
<a name="ln1287">            for (unsigned i = 1; i &lt; dList.size(); ++i) {</a>
<a name="ln1288">                  tick2 += actualTicks(dList[i-1].ticks(), tuplet, timeStretch);</a>
<a name="ln1289">                  TDuration d = dList[i];</a>
<a name="ln1290">                  setRest(tick2, track, d.fraction(), (d.dots() &gt; 0), tuplet);</a>
<a name="ln1291">                  }</a>
<a name="ln1292">            if (fillWithRest)</a>
<a name="ln1293">                  setRest(cr-&gt;tick() + cr-&gt;actualTicks(), track, srcF - dstF, false, tuplet);</a>
<a name="ln1294"> </a>
<a name="ln1295">            if (selElement)</a>
<a name="ln1296">                  select(selElement, SelectType::SINGLE, 0);</a>
<a name="ln1297">            return;</a>
<a name="ln1298">            }</a>
<a name="ln1299"> </a>
<a name="ln1300">      //</a>
<a name="ln1301">      // make longer</a>
<a name="ln1302">      //</a>
<a name="ln1303">      // split required len into Measures</a>
<a name="ln1304">      QList&lt;Fraction&gt; flist = splitGapToMeasureBoundaries(cr, dstF);</a>
<a name="ln1305">      if (flist.empty())</a>
<a name="ln1306">            return;</a>
<a name="ln1307"> </a>
<a name="ln1308">      deselectAll();</a>
<a name="ln1309"> </a>
<a name="ln1310">      Fraction tick  = cr-&gt;tick();</a>
<a name="ln1311">      Fraction f     = dstF;</a>
<a name="ln1312">      ChordRest* cr1 = cr;</a>
<a name="ln1313">      Chord* oc      = 0;</a>
<a name="ln1314"> </a>
<a name="ln1315">      bool first = true;</a>
<a name="ln1316">      for (Fraction f2 : flist) {</a>
<a name="ln1317">            f  -= f2;</a>
<a name="ln1318">            makeGap(cr1-&gt;segment(), cr1-&gt;track(), f2, tuplet, first);</a>
<a name="ln1319"> </a>
<a name="ln1320">            if (cr-&gt;isRest()) {</a>
<a name="ln1321">                  Fraction timeStretch = cr1-&gt;staff()-&gt;timeStretch(cr1-&gt;tick());</a>
<a name="ln1322">                  Rest* r = toRest(cr);</a>
<a name="ln1323">                  if (first) {</a>
<a name="ln1324">                        std::vector&lt;TDuration&gt; dList = toDurationList(f2, true);</a>
<a name="ln1325">                        undoChangeChordRestLen(cr, dList[0]);</a>
<a name="ln1326">                        Fraction tick2 = cr-&gt;tick();</a>
<a name="ln1327">                        for (unsigned i = 1; i &lt; dList.size(); ++i) {</a>
<a name="ln1328">                              tick2 += actualTicks(dList[i-1].ticks(), tuplet, timeStretch);</a>
<a name="ln1329">                              TDuration d = dList[i];</a>
<a name="ln1330">                              setRest(tick2, track, d.fraction(), (d.dots() &gt; 0), tuplet);</a>
<a name="ln1331">                              }</a>
<a name="ln1332">                        }</a>
<a name="ln1333">                  else {</a>
<a name="ln1334">                        r = setRest(tick, track, f2, false, tuplet);</a>
<a name="ln1335">                        }</a>
<a name="ln1336">                  if (first) {</a>
<a name="ln1337">                        select(r, SelectType::SINGLE, 0);</a>
<a name="ln1338">                        first = false;</a>
<a name="ln1339">                        }</a>
<a name="ln1340">                  tick += actualTicks(f2, tuplet, timeStretch);</a>
<a name="ln1341">                  }</a>
<a name="ln1342">            else {</a>
<a name="ln1343">                  std::vector&lt;TDuration&gt; dList = toDurationList(f2, true);</a>
<a name="ln1344">                  Measure* measure             = tick2measure(tick);</a>
<a name="ln1345">                  Fraction etick                    = measure-&gt;tick();</a>
<a name="ln1346"> </a>
<a name="ln1347">                  if (((tick - etick).ticks() % dList[0].ticks().ticks()) == 0) {</a>
<a name="ln1348">                        for (TDuration du : dList) {</a>
<a name="ln1349">                              bool genTie;</a>
<a name="ln1350">                              Chord* cc;</a>
<a name="ln1351">                              if (oc) {</a>
<a name="ln1352">                                    genTie = true;</a>
<a name="ln1353">                                    cc = oc;</a>
<a name="ln1354">                                    oc = addChord(tick, du, cc, genTie, tuplet);</a>
<a name="ln1355">                                    }</a>
<a name="ln1356">                              else {</a>
<a name="ln1357">                                    genTie = false;</a>
<a name="ln1358">                                    cc = toChord(cr);</a>
<a name="ln1359">                                    undoChangeChordRestLen(cr, du);</a>
<a name="ln1360">                                    oc = cc;</a>
<a name="ln1361">                                    }</a>
<a name="ln1362">                              if (oc &amp;&amp; first) {</a>
<a name="ln1363">                                    if (!selElement)</a>
<a name="ln1364">                                          select(oc, SelectType::SINGLE, 0);</a>
<a name="ln1365">                                    else</a>
<a name="ln1366">                                          select(selElement, SelectType::SINGLE, 0);</a>
<a name="ln1367">                                    first = false;</a>
<a name="ln1368">                                    }</a>
<a name="ln1369">                              if (oc)</a>
<a name="ln1370">                                    tick += oc-&gt;actualTicks();</a>
<a name="ln1371">                              }</a>
<a name="ln1372">                        }</a>
<a name="ln1373">                  else {</a>
<a name="ln1374">                        for (size_t i = dList.size(); i &gt; 0; --i) { // loop probably needs to be in this reverse order</a>
<a name="ln1375">                              bool genTie;</a>
<a name="ln1376">                              Chord* cc;</a>
<a name="ln1377">                              if (oc) {</a>
<a name="ln1378">                                    genTie = true;</a>
<a name="ln1379">                                    cc = oc;</a>
<a name="ln1380">                                    oc = addChord(tick, dList[i-1], cc, genTie, tuplet);</a>
<a name="ln1381">                                    }</a>
<a name="ln1382">                              else {</a>
<a name="ln1383">                                    genTie = false;</a>
<a name="ln1384">                                    cc = toChord(cr);</a>
<a name="ln1385">                                    undoChangeChordRestLen(cr, dList[i-1]);</a>
<a name="ln1386">                                    oc = cc;</a>
<a name="ln1387">                                    }</a>
<a name="ln1388">                              if (first) {</a>
<a name="ln1389">                                    // select(oc, SelectType::SINGLE, 0);</a>
<a name="ln1390">                                    if (selElement)</a>
<a name="ln1391">                                          select(selElement, SelectType::SINGLE, 0);</a>
<a name="ln1392">                                    first = false;</a>
<a name="ln1393">                                    }</a>
<a name="ln1394">                              tick += oc-&gt;actualTicks();</a>
<a name="ln1395">                              }</a>
<a name="ln1396">                        }</a>
<a name="ln1397">                  }</a>
<a name="ln1398">            Measure* m  = cr1-&gt;measure();</a>
<a name="ln1399">            Measure* m1 = m-&gt;nextMeasure();</a>
<a name="ln1400">            if (m1 == 0)</a>
<a name="ln1401">                  break;</a>
<a name="ln1402">            Segment* s = m1-&gt;first(SegmentType::ChordRest);</a>
<a name="ln1403">            expandVoice(s, track);</a>
<a name="ln1404">            cr1 = toChordRest(s-&gt;element(track));</a>
<a name="ln1405">            }</a>
<a name="ln1406">      connectTies();</a>
<a name="ln1407">      }</a>
<a name="ln1408"> </a>
<a name="ln1409">//---------------------------------------------------------</a>
<a name="ln1410">//   upDownChromatic</a>
<a name="ln1411">//---------------------------------------------------------</a>
<a name="ln1412"> </a>
<a name="ln1413">static void upDownChromatic(bool up, int pitch, Note* n, Key key, int tpc1, int tpc2, int&amp; newPitch, int&amp; newTpc1, int&amp; newTpc2)</a>
<a name="ln1414">      {</a>
<a name="ln1415">      if (up &amp;&amp; pitch &lt; 127) {</a>
<a name="ln1416">            newPitch = pitch + 1;</a>
<a name="ln1417">            if (n-&gt;concertPitch()) {</a>
<a name="ln1418">                  if (tpc1 &gt; Tpc::TPC_A + int(key))</a>
<a name="ln1419">                        newTpc1 = tpc1 - 5;   // up semitone diatonic</a>
<a name="ln1420">                  else</a>
<a name="ln1421">                        newTpc1 = tpc1 + 7;   // up semitone chromatic</a>
<a name="ln1422">                  newTpc2 = n-&gt;transposeTpc(newTpc1);</a>
<a name="ln1423">                  }</a>
<a name="ln1424">            else {</a>
<a name="ln1425">                  if (tpc2 &gt; Tpc::TPC_A + int(key))</a>
<a name="ln1426">                        newTpc2 = tpc2 - 5;   // up semitone diatonic</a>
<a name="ln1427">                  else</a>
<a name="ln1428">                        newTpc2 = tpc2 + 7;   // up semitone chromatic</a>
<a name="ln1429">                  newTpc1 = n-&gt;transposeTpc(newTpc2);</a>
<a name="ln1430">                  }</a>
<a name="ln1431">            }</a>
<a name="ln1432">      else if (!up &amp;&amp; pitch &gt; 0) {</a>
<a name="ln1433">            newPitch = pitch - 1;</a>
<a name="ln1434">            if (n-&gt;concertPitch()) {</a>
<a name="ln1435">                  if (tpc1 &gt; Tpc::TPC_C + int(key))</a>
<a name="ln1436">                        newTpc1 = tpc1 - 7;   // down semitone chromatic</a>
<a name="ln1437">                  else</a>
<a name="ln1438">                        newTpc1 = tpc1 + 5;   // down semitone diatonic</a>
<a name="ln1439">                  newTpc2 = n-&gt;transposeTpc(newTpc1);</a>
<a name="ln1440">                  }</a>
<a name="ln1441">            else {</a>
<a name="ln1442">                  if (tpc2 &gt; Tpc::TPC_C + int(key))</a>
<a name="ln1443">                        newTpc2 = tpc2 - 7;   // down semitone chromatic</a>
<a name="ln1444">                  else</a>
<a name="ln1445">                        newTpc2 = tpc2 + 5;   // down semitone diatonic</a>
<a name="ln1446">                  newTpc1 = n-&gt;transposeTpc(newTpc2);</a>
<a name="ln1447">                  }</a>
<a name="ln1448">            }</a>
<a name="ln1449">      }</a>
<a name="ln1450"> </a>
<a name="ln1451">//---------------------------------------------------------</a>
<a name="ln1452">//   setTpc</a>
<a name="ln1453">//---------------------------------------------------------</a>
<a name="ln1454"> </a>
<a name="ln1455">static void setTpc(Note* oNote, int tpc, int&amp; newTpc1, int&amp; newTpc2)</a>
<a name="ln1456">      {</a>
<a name="ln1457">      if (oNote-&gt;concertPitch()) {</a>
<a name="ln1458">            newTpc1 = tpc;</a>
<a name="ln1459">            newTpc2 = oNote-&gt;transposeTpc(tpc);</a>
<a name="ln1460">            }</a>
<a name="ln1461">      else {</a>
<a name="ln1462">            newTpc2 = tpc;</a>
<a name="ln1463">            newTpc1 = oNote-&gt;transposeTpc(tpc);</a>
<a name="ln1464">            }</a>
<a name="ln1465">      }</a>
<a name="ln1466"> </a>
<a name="ln1467">//---------------------------------------------------------</a>
<a name="ln1468">//   upDown</a>
<a name="ln1469">///   Increment/decrement pitch of note by one or by an octave.</a>
<a name="ln1470">//---------------------------------------------------------</a>
<a name="ln1471"> </a>
<a name="ln1472">void Score::upDown(bool up, UpDownMode mode)</a>
<a name="ln1473">      {</a>
<a name="ln1474">      QList&lt;Note*&gt; el = selection().uniqueNotes();</a>
<a name="ln1475"> </a>
<a name="ln1476">      for (Note* oNote : el) {</a>
<a name="ln1477">            Fraction tick     = oNote-&gt;chord()-&gt;tick();</a>
<a name="ln1478">            Staff* staff = oNote-&gt;staff();</a>
<a name="ln1479">            Part* part   = staff-&gt;part();</a>
<a name="ln1480">            Key key      = staff-&gt;key(tick);</a>
<a name="ln1481">            int tpc1     = oNote-&gt;tpc1();</a>
<a name="ln1482">            int tpc2     = oNote-&gt;tpc2();</a>
<a name="ln1483">            int pitch    = oNote-&gt;pitch();</a>
<a name="ln1484">            int newTpc1  = tpc1;      // default to unchanged</a>
<a name="ln1485">            int newTpc2  = tpc2;      // default to unchanged</a>
<a name="ln1486">            int newPitch = pitch;     // default to unchanged</a>
<a name="ln1487">            int string   = oNote-&gt;string();</a>
<a name="ln1488">            int fret     = oNote-&gt;fret();</a>
<a name="ln1489"> </a>
<a name="ln1490">            switch (staff-&gt;staffType(oNote-&gt;chord()-&gt;tick())-&gt;group()) {</a>
<a name="ln1491">                  case StaffGroup::PERCUSSION:</a>
<a name="ln1492">                        {</a>
<a name="ln1493">                        const Drumset* ds = part-&gt;instrument()-&gt;drumset();</a>
<a name="ln1494">                        if (ds) {</a>
<a name="ln1495">                              newPitch = up ? ds-&gt;nextPitch(pitch) : ds-&gt;prevPitch(pitch);</a>
<a name="ln1496">                              newTpc1 = pitch2tpc(newPitch, Key::C, Prefer::NEAREST);</a>
<a name="ln1497">                              newTpc2 = newTpc1;</a>
<a name="ln1498">                              }</a>
<a name="ln1499">                        }</a>
<a name="ln1500">                        break;</a>
<a name="ln1501">                  case StaffGroup::TAB:</a>
<a name="ln1502">                        {</a>
<a name="ln1503">                        const StringData* stringData = part-&gt;instrument()-&gt;stringData();</a>
<a name="ln1504">                        switch (mode) {</a>
<a name="ln1505">                              case UpDownMode::OCTAVE:          // move same note to next string, if possible</a>
<a name="ln1506">                                    {</a>
<a name="ln1507">                                    const StaffType* stt = staff-&gt;staffType(tick);</a>
<a name="ln1508">                                    string = stt-&gt;physStringToVisual(string);</a>
<a name="ln1509">                                    string += (up ? -1 : 1);</a>
<a name="ln1510">                                    if (string &lt; 0 || string &gt;= stringData-&gt;strings())</a>
<a name="ln1511">                                          return;           // no next string to move to</a>
<a name="ln1512">                                    string = stt-&gt;visualStringToPhys(string);</a>
<a name="ln1513">                                    fret = stringData-&gt;fret(pitch, string, staff, tick);</a>
<a name="ln1514">                                    if (fret == -1)          // can't have that note on that string</a>
<a name="ln1515">                                          return;</a>
<a name="ln1516">                                    // newPitch and newTpc remain unchanged</a>
<a name="ln1517">                                    }</a>
<a name="ln1518">                                    break;</a>
<a name="ln1519"> </a>
<a name="ln1520">                              case UpDownMode::DIATONIC:        // increase / decrease the pitch,</a>
<a name="ln1521">                                                            // letting the algorithm to choose fret &amp; string</a>
<a name="ln1522">                                    upDownChromatic(up, pitch, oNote, key, tpc1, tpc2, newPitch, newTpc1, newTpc2);</a>
<a name="ln1523">                                    break;</a>
<a name="ln1524"> </a>
<a name="ln1525">                              case UpDownMode::CHROMATIC:       // increase / decrease the fret</a>
<a name="ln1526">                                    {                       // without changing the string</a>
<a name="ln1527">                                    // compute new fret</a>
<a name="ln1528">                                    if (!stringData-&gt;frets()) {</a>
<a name="ln1529">                                          qDebug(&quot;upDown tab chromatic: no frets?&quot;);</a>
<a name="ln1530">                                          return;</a>
<a name="ln1531">                                          }</a>
<a name="ln1532">                                    fret += (up ? 1 : -1);</a>
<a name="ln1533">                                    if (fret &lt; 0 || fret &gt; stringData-&gt;frets()) {</a>
<a name="ln1534">                                          qDebug(&quot;upDown tab in-string: out of fret range&quot;);</a>
<a name="ln1535">                                          return;</a>
<a name="ln1536">                                          }</a>
<a name="ln1537">                                    // update pitch and tpc's and check it matches stringData</a>
<a name="ln1538">                                    upDownChromatic(up, pitch, oNote, key, tpc1, tpc2, newPitch, newTpc1, newTpc2);</a>
<a name="ln1539">                                    if (newPitch != stringData-&gt;getPitch(string, fret, staff, tick) ) {</a>
<a name="ln1540">                                          // oh-oh: something went very wrong!</a>
<a name="ln1541">                                          qDebug(&quot;upDown tab in-string: pitch mismatch&quot;);</a>
<a name="ln1542">                                          return;</a>
<a name="ln1543">                                    }</a>
<a name="ln1544">                                    // store the fretting change before undoChangePitch() chooses</a>
<a name="ln1545">                                    // a fretting of its own liking!</a>
<a name="ln1546">                                    oNote-&gt;undoChangeProperty(Pid::FRET, fret);</a>
<a name="ln1547">                                    }</a>
<a name="ln1548">                                    break;</a>
<a name="ln1549">                              }</a>
<a name="ln1550">                        }</a>
<a name="ln1551">                        break;</a>
<a name="ln1552">                  case StaffGroup::STANDARD:</a>
<a name="ln1553">                        switch (mode) {</a>
<a name="ln1554">                              case UpDownMode::OCTAVE:</a>
<a name="ln1555">                                    if (up) {</a>
<a name="ln1556">                                          if (pitch &lt; 116)</a>
<a name="ln1557">                                                newPitch = pitch + 12;</a>
<a name="ln1558">                                          }</a>
<a name="ln1559">                                    else {</a>
<a name="ln1560">                                          if (pitch &gt; 11)</a>
<a name="ln1561">                                                newPitch = pitch - 12;</a>
<a name="ln1562">                                          }</a>
<a name="ln1563">                                    // newTpc remains unchanged</a>
<a name="ln1564">                                    break;</a>
<a name="ln1565"> </a>
<a name="ln1566">                              case UpDownMode::CHROMATIC:</a>
<a name="ln1567">                                    upDownChromatic(up, pitch, oNote, key, tpc1, tpc2, newPitch, newTpc1, newTpc2);</a>
<a name="ln1568">                                    break;</a>
<a name="ln1569"> </a>
<a name="ln1570">                              case UpDownMode::DIATONIC:</a>
<a name="ln1571">                                    {</a>
<a name="ln1572">                                    int tpc = oNote-&gt;tpc();</a>
<a name="ln1573">                                    if (up) {</a>
<a name="ln1574">                                          if (tpc &gt; Tpc::TPC_A + int(key)) {</a>
<a name="ln1575">                                                if (pitch &lt; 127) {</a>
<a name="ln1576">                                                      newPitch = pitch + 1;</a>
<a name="ln1577">                                                      setTpc(oNote, tpc - 5, newTpc1, newTpc2);</a>
<a name="ln1578">                                                      }</a>
<a name="ln1579">                                                }</a>
<a name="ln1580">                                          else {</a>
<a name="ln1581">                                                if (pitch &lt; 126) {</a>
<a name="ln1582">                                                      newPitch = pitch + 2;</a>
<a name="ln1583">                                                      setTpc(oNote, tpc + 2, newTpc1, newTpc2);</a>
<a name="ln1584">                                                      }</a>
<a name="ln1585">                                                }</a>
<a name="ln1586">                                          }</a>
<a name="ln1587">                                    else {</a>
<a name="ln1588">                                          if (tpc &gt; Tpc::TPC_C + int(key)) {</a>
<a name="ln1589">                                                if (pitch &gt; 1) {</a>
<a name="ln1590">                                                      newPitch = pitch - 2;</a>
<a name="ln1591">                                                      setTpc(oNote, tpc - 2, newTpc1, newTpc2);</a>
<a name="ln1592">                                                      }</a>
<a name="ln1593">                                                }</a>
<a name="ln1594">                                          else {</a>
<a name="ln1595">                                                if (pitch &gt; 0) {</a>
<a name="ln1596">                                                      newPitch = pitch - 1;</a>
<a name="ln1597">                                                      setTpc(oNote, tpc + 5, newTpc1, newTpc2);</a>
<a name="ln1598">                                                      }</a>
<a name="ln1599">                                                }</a>
<a name="ln1600">                                          }</a>
<a name="ln1601">                                    }</a>
<a name="ln1602">                                    break;</a>
<a name="ln1603">                              }</a>
<a name="ln1604">                        break;</a>
<a name="ln1605">                  }</a>
<a name="ln1606"> </a>
<a name="ln1607">            if ((oNote-&gt;pitch() != newPitch) || (oNote-&gt;tpc1() != newTpc1) || oNote-&gt;tpc2() != newTpc2) {</a>
<a name="ln1608">                  // remove accidental if present to make sure</a>
<a name="ln1609">                  // user added accidentals are removed here</a>
<a name="ln1610">                  // unless it's an octave change</a>
<a name="ln1611">                  // in this case courtesy accidentals are preserved</a>
<a name="ln1612">                  // because they're now harder to be re-entered due to the revised note-input workflow</a>
<a name="ln1613">                  if (mode != UpDownMode::OCTAVE) {</a>
<a name="ln1614">                        auto l = oNote-&gt;linkList();</a>
<a name="ln1615">                        for (ScoreElement* e : l) {</a>
<a name="ln1616">                              Note* ln = toNote(e);</a>
<a name="ln1617">                              if (ln-&gt;accidental())</a>
<a name="ln1618">                                    undo(new RemoveElement(ln-&gt;accidental()));</a>
<a name="ln1619">                              }</a>
<a name="ln1620">                        }</a>
<a name="ln1621">                  undoChangePitch(oNote, newPitch, newTpc1, newTpc2);</a>
<a name="ln1622">                  }</a>
<a name="ln1623"> </a>
<a name="ln1624">            // store fret change only if undoChangePitch has not been called,</a>
<a name="ln1625">            // as undoChangePitch() already manages fret changes, if necessary</a>
<a name="ln1626">            else if (staff-&gt;staffType(tick)-&gt;group() == StaffGroup::TAB) {</a>
<a name="ln1627">                  bool refret = false;</a>
<a name="ln1628">                  if (oNote-&gt;string() != string) {</a>
<a name="ln1629">                        oNote-&gt;undoChangeProperty(Pid::STRING, string);</a>
<a name="ln1630">                        refret = true;</a>
<a name="ln1631">                        }</a>
<a name="ln1632">                  if (oNote-&gt;fret() != fret) {</a>
<a name="ln1633">                        oNote-&gt;undoChangeProperty(Pid::FRET, fret);</a>
<a name="ln1634">                        refret = true;</a>
<a name="ln1635">                        }</a>
<a name="ln1636">                  if (refret) {</a>
<a name="ln1637">                        const StringData* stringData = part-&gt;instrument()-&gt;stringData();</a>
<a name="ln1638">                        stringData-&gt;fretChords(oNote-&gt;chord());</a>
<a name="ln1639">                        }</a>
<a name="ln1640">                  }</a>
<a name="ln1641"> </a>
<a name="ln1642">            // play new note with velocity 80 for 0.3 sec:</a>
<a name="ln1643">            setPlayNote(true);</a>
<a name="ln1644">            }</a>
<a name="ln1645">      setSelectionChanged(true);</a>
<a name="ln1646">      }</a>
<a name="ln1647"> </a>
<a name="ln1648">//---------------------------------------------------------</a>
<a name="ln1649">//   upDownDelta</a>
<a name="ln1650">///   Add the delta to the pitch of note.</a>
<a name="ln1651">//---------------------------------------------------------</a>
<a name="ln1652"> </a>
<a name="ln1653">void Score::upDownDelta(int pitchDelta)</a>
<a name="ln1654">      {</a>
<a name="ln1655">      while (pitchDelta &gt; 0) {</a>
<a name="ln1656">            upDown(true, UpDownMode::CHROMATIC);</a>
<a name="ln1657">            pitchDelta--;</a>
<a name="ln1658">            }</a>
<a name="ln1659"> </a>
<a name="ln1660">      while (pitchDelta &lt; 0) {</a>
<a name="ln1661">            upDown(false, UpDownMode::CHROMATIC);</a>
<a name="ln1662">            pitchDelta++;</a>
<a name="ln1663">            }</a>
<a name="ln1664">      }</a>
<a name="ln1665"> </a>
<a name="ln1666">//---------------------------------------------------------</a>
<a name="ln1667">//   addArticulation</a>
<a name="ln1668">///   Add attribute \a attr to all selected notes/rests.</a>
<a name="ln1669">///</a>
<a name="ln1670">///   Called from padToggle() to add note prefix/accent.</a>
<a name="ln1671">//---------------------------------------------------------</a>
<a name="ln1672"> </a>
<a name="ln1673">void Score::addArticulation(SymId attr)</a>
<a name="ln1674">      {</a>
<a name="ln1675">      QSet&lt;Chord*&gt; set;</a>
<a name="ln1676">      for (Element* el : selection().elements()) {</a>
<a name="ln1677">            if (el-&gt;isNote() || el-&gt;isChord()) {</a>
<a name="ln1678">                  Chord* cr = 0;</a>
<a name="ln1679">                  // apply articulation on a given chord only once</a>
<a name="ln1680">                  if (el-&gt;isNote()) {</a>
<a name="ln1681">                        cr = toNote(el)-&gt;chord();</a>
<a name="ln1682">                        if (set.contains(cr))</a>
<a name="ln1683">                              continue;</a>
<a name="ln1684">                        }</a>
<a name="ln1685">                  Articulation* na = new Articulation(this);</a>
<a name="ln1686">                  na-&gt;setSymId(attr);</a>
<a name="ln1687">                  if (!addArticulation(el, na))</a>
<a name="ln1688">                        delete na;</a>
<a name="ln1689">                  if (cr)</a>
<a name="ln1690">                        set.insert(cr);</a>
<a name="ln1691">                  }</a>
<a name="ln1692">            }</a>
<a name="ln1693">      }</a>
<a name="ln1694"> </a>
<a name="ln1695">//---------------------------------------------------------</a>
<a name="ln1696">//   toggleAccidental</a>
<a name="ln1697">//---------------------------------------------------------</a>
<a name="ln1698"> </a>
<a name="ln1699">void Score::toggleAccidental(AccidentalType at, const EditData&amp; ed)</a>
<a name="ln1700">      {</a>
<a name="ln1701">      if (_is.accidentalType() == at)</a>
<a name="ln1702">            at = AccidentalType::NONE;</a>
<a name="ln1703">      if (noteEntryMode()) {</a>
<a name="ln1704">            _is.setAccidentalType(at);</a>
<a name="ln1705">            _is.setRest(false);</a>
<a name="ln1706">            }</a>
<a name="ln1707">      else {</a>
<a name="ln1708">            if (selection().isNone()) {</a>
<a name="ln1709">                  ed.view-&gt;startNoteEntryMode();</a>
<a name="ln1710">                  _is.setAccidentalType(at);</a>
<a name="ln1711">                  _is.setDuration(TDuration::DurationType::V_QUARTER);</a>
<a name="ln1712">                  _is.setRest(false);</a>
<a name="ln1713">                  }</a>
<a name="ln1714">            else</a>
<a name="ln1715">                  changeAccidental(at);</a>
<a name="ln1716">            }</a>
<a name="ln1717">      }</a>
<a name="ln1718">//---------------------------------------------------------</a>
<a name="ln1719">//   changeAccidental</a>
<a name="ln1720">///   Change accidental to subtype \a idx for all selected</a>
<a name="ln1721">///   notes.</a>
<a name="ln1722">//---------------------------------------------------------</a>
<a name="ln1723"> </a>
<a name="ln1724">void Score::changeAccidental(AccidentalType idx)</a>
<a name="ln1725">      {</a>
<a name="ln1726">      foreach(Note* note, selection().noteList())</a>
<a name="ln1727">            changeAccidental(note, idx);</a>
<a name="ln1728">      }</a>
<a name="ln1729"> </a>
<a name="ln1730">//---------------------------------------------------------</a>
<a name="ln1731">//   changeAccidental2</a>
<a name="ln1732">//---------------------------------------------------------</a>
<a name="ln1733"> </a>
<a name="ln1734">static void changeAccidental2(Note* n, int pitch, int tpc)</a>
<a name="ln1735">      {</a>
<a name="ln1736">      Score* score  = n-&gt;score();</a>
<a name="ln1737">      Chord* chord  = n-&gt;chord();</a>
<a name="ln1738">      Staff* st     = chord-&gt;staff();</a>
<a name="ln1739">      int fret      = n-&gt;fret();</a>
<a name="ln1740">      int string    = n-&gt;string();</a>
<a name="ln1741"> </a>
<a name="ln1742">      if (st-&gt;isTabStaff(chord-&gt;tick())) {</a>
<a name="ln1743">            if (pitch != n-&gt;pitch()) {</a>
<a name="ln1744">                  //</a>
<a name="ln1745">                  // as pitch has changed, calculate new</a>
<a name="ln1746">                  // string &amp; fret</a>
<a name="ln1747">                  //</a>
<a name="ln1748">                  const StringData* stringData = n-&gt;part()-&gt;instrument()-&gt;stringData();</a>
<a name="ln1749">                  if (stringData)</a>
<a name="ln1750">                        stringData-&gt;convertPitch(pitch, st, chord-&gt;tick(), &amp;string, &amp;fret);</a>
<a name="ln1751">                  }</a>
<a name="ln1752">            }</a>
<a name="ln1753">      int tpc1;</a>
<a name="ln1754">      int tpc2 = n-&gt;transposeTpc(tpc);</a>
<a name="ln1755">      if (score-&gt;styleB(Sid::concertPitch))</a>
<a name="ln1756">            tpc1 = tpc;</a>
<a name="ln1757">      else {</a>
<a name="ln1758">            tpc1 = tpc2;</a>
<a name="ln1759">            tpc2 = tpc;</a>
<a name="ln1760">            }</a>
<a name="ln1761"> </a>
<a name="ln1762">      if (!st-&gt;isTabStaff(chord-&gt;tick())) {</a>
<a name="ln1763">            //</a>
<a name="ln1764">            // handle ties</a>
<a name="ln1765">            //</a>
<a name="ln1766">            if (n-&gt;tieBack()) {</a>
<a name="ln1767">                  if (pitch != n-&gt;pitch()) {</a>
<a name="ln1768">                        score-&gt;undoRemoveElement(n-&gt;tieBack());</a>
<a name="ln1769">                        if (n-&gt;tieFor())</a>
<a name="ln1770">                              score-&gt;undoRemoveElement(n-&gt;tieFor());</a>
<a name="ln1771">                        }</a>
<a name="ln1772">                  }</a>
<a name="ln1773">            else {</a>
<a name="ln1774">                  Note* nn = n;</a>
<a name="ln1775">                  while (nn-&gt;tieFor()) {</a>
<a name="ln1776">                        nn = nn-&gt;tieFor()-&gt;endNote();</a>
<a name="ln1777">                        score-&gt;undo(new ChangePitch(nn, pitch, tpc1, tpc2));</a>
<a name="ln1778">                        }</a>
<a name="ln1779">                  }</a>
<a name="ln1780">            }</a>
<a name="ln1781">      score-&gt;undoChangePitch(n, pitch, tpc1, tpc2);</a>
<a name="ln1782">      }</a>
<a name="ln1783"> </a>
<a name="ln1784">//---------------------------------------------------------</a>
<a name="ln1785">//   changeAccidental</a>
<a name="ln1786">///   Change accidental to subtype \accidental for</a>
<a name="ln1787">///   note \a note.</a>
<a name="ln1788">//---------------------------------------------------------</a>
<a name="ln1789"> </a>
<a name="ln1790">void Score::changeAccidental(Note* note, AccidentalType accidental)</a>
<a name="ln1791">      {</a>
<a name="ln1792">      Chord* chord = note-&gt;chord();</a>
<a name="ln1793">      if (!chord)</a>
<a name="ln1794">            return;</a>
<a name="ln1795">      Segment* segment = chord-&gt;segment();</a>
<a name="ln1796">      if (!segment)</a>
<a name="ln1797">            return;</a>
<a name="ln1798">      Measure* measure = segment-&gt;measure();</a>
<a name="ln1799">      if (!measure)</a>
<a name="ln1800">            return;</a>
<a name="ln1801">      Fraction tick = segment-&gt;tick();</a>
<a name="ln1802">      Staff* estaff = staff(chord-&gt;staffIdx() + chord-&gt;staffMove());</a>
<a name="ln1803">      if (!estaff)</a>
<a name="ln1804">            return;</a>
<a name="ln1805">      ClefType clef = estaff-&gt;clef(tick);</a>
<a name="ln1806">      int step      = ClefInfo::pitchOffset(clef) - note-&gt;line();</a>
<a name="ln1807">      while (step &lt; 0)</a>
<a name="ln1808">            step += 7;</a>
<a name="ln1809">      step %= 7;</a>
<a name="ln1810">      //</a>
<a name="ln1811">      // accidental change may result in pitch change</a>
<a name="ln1812">      //</a>
<a name="ln1813">      AccidentalVal acc2 = measure-&gt;findAccidental(note);</a>
<a name="ln1814">      AccidentalVal acc = (accidental == AccidentalType::NONE) ? acc2 : Accidental::subtype2value(accidental);</a>
<a name="ln1815"> </a>
<a name="ln1816">      int pitch = line2pitch(note-&gt;line(), clef, Key::C) + int(acc);</a>
<a name="ln1817">      if (!note-&gt;concertPitch())</a>
<a name="ln1818">            pitch += note-&gt;transposition();</a>
<a name="ln1819"> </a>
<a name="ln1820">      int tpc = step2tpc(step, acc);</a>
<a name="ln1821"> </a>
<a name="ln1822">      bool forceRemove = false;</a>
<a name="ln1823">      bool forceAdd = false;</a>
<a name="ln1824"> </a>
<a name="ln1825">      // delete accidental</a>
<a name="ln1826">      // both for this note and for any linked notes</a>
<a name="ln1827">      if (accidental == AccidentalType::NONE)</a>
<a name="ln1828">            forceRemove = true;</a>
<a name="ln1829"> </a>
<a name="ln1830">      // precautionary or microtonal accidental</a>
<a name="ln1831">      // either way, we display it unconditionally</a>
<a name="ln1832">      // both for this note and for any linked notes</a>
<a name="ln1833">      else if (acc == acc2 || pitch == note-&gt;pitch() || Accidental::isMicrotonal(accidental))</a>
<a name="ln1834">            forceAdd = true;</a>
<a name="ln1835"> </a>
<a name="ln1836">      for (ScoreElement* se : note-&gt;linkList()) {</a>
<a name="ln1837">            Note* ln = toNote(se);</a>
<a name="ln1838">            if (ln-&gt;concertPitch() != note-&gt;concertPitch())</a>
<a name="ln1839">                  continue;</a>
<a name="ln1840">            Score* lns    = ln-&gt;score();</a>
<a name="ln1841">            Accidental* a = ln-&gt;accidental();</a>
<a name="ln1842">            if (forceRemove) {</a>
<a name="ln1843">                  if (a)</a>
<a name="ln1844">                        lns-&gt;undoRemoveElement(a);</a>
<a name="ln1845">                  if (ln-&gt;tieBack())</a>
<a name="ln1846">                        continue;</a>
<a name="ln1847">                  }</a>
<a name="ln1848">            else if (forceAdd) {</a>
<a name="ln1849">                  if (a)</a>
<a name="ln1850">                        undoRemoveElement(a);</a>
<a name="ln1851">                  Accidental* a1 = new Accidental(lns);</a>
<a name="ln1852">                  a1-&gt;setParent(ln);</a>
<a name="ln1853">                  a1-&gt;setAccidentalType(accidental);</a>
<a name="ln1854">                  a1-&gt;setRole(AccidentalRole::USER);</a>
<a name="ln1855">                  lns-&gt;undoAddElement(a1);</a>
<a name="ln1856">                  }</a>
<a name="ln1857">            changeAccidental2(ln, pitch, tpc);</a>
<a name="ln1858">            }</a>
<a name="ln1859">      setPlayNote(true);</a>
<a name="ln1860">      setSelectionChanged(true);</a>
<a name="ln1861">      }</a>
<a name="ln1862"> </a>
<a name="ln1863">//---------------------------------------------------------</a>
<a name="ln1864">//   addArticulation</a>
<a name="ln1865">//---------------------------------------------------------</a>
<a name="ln1866"> </a>
<a name="ln1867">bool Score::addArticulation(Element* el, Articulation* a)</a>
<a name="ln1868">      {</a>
<a name="ln1869">      Chord* c;</a>
<a name="ln1870">      if (el-&gt;isNote())</a>
<a name="ln1871">            c = toNote(el)-&gt;chord();</a>
<a name="ln1872">      else if (el-&gt;isChord())</a>
<a name="ln1873">            c = toChord(el);</a>
<a name="ln1874">      else</a>
<a name="ln1875">            return false;</a>
<a name="ln1876">      Articulation* oa = c-&gt;hasArticulation(a);</a>
<a name="ln1877">      if (oa) {</a>
<a name="ln1878">            undoRemoveElement(oa);</a>
<a name="ln1879">            return false;</a>
<a name="ln1880">            }</a>
<a name="ln1881">      a-&gt;setParent(c);</a>
<a name="ln1882">      a-&gt;setTrack(c-&gt;track()); // make sure it propagates between score and parts</a>
<a name="ln1883">      undoAddElement(a);</a>
<a name="ln1884">      return true;</a>
<a name="ln1885">      }</a>
<a name="ln1886"> </a>
<a name="ln1887">//---------------------------------------------------------</a>
<a name="ln1888">//   resetUserStretch</a>
<a name="ln1889">//---------------------------------------------------------</a>
<a name="ln1890"> </a>
<a name="ln1891">void Score::resetUserStretch()</a>
<a name="ln1892">      {</a>
<a name="ln1893">      Measure* m1;</a>
<a name="ln1894">      Measure* m2;</a>
<a name="ln1895">      // retrieve span of selection</a>
<a name="ln1896">      Segment* s1 = _selection.startSegment();</a>
<a name="ln1897">      Segment* s2 = _selection.endSegment();</a>
<a name="ln1898">      // if either segment is not returned by the selection</a>
<a name="ln1899">      // (for instance, no selection) fall back to first/last measure</a>
<a name="ln1900">      if (!s1)</a>
<a name="ln1901">            m1 = firstMeasureMM();</a>
<a name="ln1902">      else</a>
<a name="ln1903">            m1 = s1-&gt;measure();</a>
<a name="ln1904">      if (!s2)</a>
<a name="ln1905">            m2 = lastMeasureMM();</a>
<a name="ln1906">      else</a>
<a name="ln1907">            m2 = s2-&gt;measure();</a>
<a name="ln1908">      if (!m1 || !m2)               // should not happen!</a>
<a name="ln1909">            return;</a>
<a name="ln1910"> </a>
<a name="ln1911">      for (Measure* m = m1; m; m = m-&gt;nextMeasureMM()) {</a>
<a name="ln1912">            m-&gt;undoChangeProperty(Pid::USER_STRETCH, 1.0);</a>
<a name="ln1913">            if (m == m2)</a>
<a name="ln1914">                  break;</a>
<a name="ln1915">            }</a>
<a name="ln1916">      }</a>
<a name="ln1917"> </a>
<a name="ln1918">//---------------------------------------------------------</a>
<a name="ln1919">//   moveUp</a>
<a name="ln1920">//---------------------------------------------------------</a>
<a name="ln1921"> </a>
<a name="ln1922">void Score::moveUp(ChordRest* cr)</a>
<a name="ln1923">      {</a>
<a name="ln1924">      Staff* staff  = cr-&gt;staff();</a>
<a name="ln1925">      Part* part    = staff-&gt;part();</a>
<a name="ln1926">      int rstaff    = staff-&gt;rstaff();</a>
<a name="ln1927">      int staffMove = cr-&gt;staffMove();</a>
<a name="ln1928"> </a>
<a name="ln1929">      if ((staffMove == -1) || (rstaff + staffMove &lt;= 0))</a>
<a name="ln1930">            return;</a>
<a name="ln1931"> </a>
<a name="ln1932">      QList&lt;Staff*&gt;* staves = part-&gt;staves();</a>
<a name="ln1933">      // we know that staffMove+rstaff-1 index exists due to the previous condition.</a>
<a name="ln1934">      if (staff-&gt;staffType(cr-&gt;tick())-&gt;group() != StaffGroup::STANDARD ||</a>
<a name="ln1935">          staves-&gt;at(rstaff+staffMove-1)-&gt;staffType(cr-&gt;tick())-&gt;group() != StaffGroup::STANDARD) {</a>
<a name="ln1936">            qDebug(&quot;User attempted to move a note from/to a staff which does not use standard notation - ignoring.&quot;);</a>
<a name="ln1937">            }</a>
<a name="ln1938">      else  {</a>
<a name="ln1939">            // move the chord up a staff</a>
<a name="ln1940">            undo(new ChangeChordStaffMove(cr, staffMove - 1));</a>
<a name="ln1941">            }</a>
<a name="ln1942">      }</a>
<a name="ln1943"> </a>
<a name="ln1944">//---------------------------------------------------------</a>
<a name="ln1945">//   moveDown</a>
<a name="ln1946">//---------------------------------------------------------</a>
<a name="ln1947"> </a>
<a name="ln1948">void Score::moveDown(ChordRest* cr)</a>
<a name="ln1949">      {</a>
<a name="ln1950">      Staff* staff  = cr-&gt;staff();</a>
<a name="ln1951">      Part* part    = staff-&gt;part();</a>
<a name="ln1952">      int rstaff    = staff-&gt;rstaff();</a>
<a name="ln1953">      int staffMove = cr-&gt;staffMove();</a>
<a name="ln1954">      // calculate the number of staves available so that we know whether there is another staff to move down to</a>
<a name="ln1955">      int rstaves   = part-&gt;nstaves();</a>
<a name="ln1956"> </a>
<a name="ln1957">      if ((staffMove == 1) || (rstaff + staffMove &gt;= rstaves - 1)) {</a>
<a name="ln1958">            qDebug(&quot;moveDown staffMove==%d  rstaff %d rstaves %d&quot;, staffMove, rstaff, rstaves);</a>
<a name="ln1959">            return;</a>
<a name="ln1960">            }</a>
<a name="ln1961"> </a>
<a name="ln1962">      QList&lt;Staff*&gt;* staves = part-&gt;staves();</a>
<a name="ln1963">      // we know that staffMove+rstaff+1 index exists due to the previous condition.</a>
<a name="ln1964">      if (staff-&gt;staffType(cr-&gt;tick())-&gt;group() != StaffGroup::STANDARD ||</a>
<a name="ln1965">          staves-&gt;at(staffMove+rstaff+1)-&gt;staffType(cr-&gt;tick())-&gt;group() != StaffGroup::STANDARD) {</a>
<a name="ln1966">            qDebug(&quot;User attempted to move a note from/to a staff which does not use standard notation - ignoring.&quot;);</a>
<a name="ln1967">            }</a>
<a name="ln1968">      else  {</a>
<a name="ln1969">            // move the chord down a staff</a>
<a name="ln1970">            undo(new ChangeChordStaffMove(cr, staffMove + 1));</a>
<a name="ln1971">            }</a>
<a name="ln1972">      }</a>
<a name="ln1973"> </a>
<a name="ln1974">//---------------------------------------------------------</a>
<a name="ln1975">//   cmdAddStretch</a>
<a name="ln1976">//---------------------------------------------------------</a>
<a name="ln1977"> </a>
<a name="ln1978">void Score::cmdAddStretch(qreal val)</a>
<a name="ln1979">      {</a>
<a name="ln1980">      if (!selection().isRange())</a>
<a name="ln1981">            return;</a>
<a name="ln1982">      Fraction startTick = selection().tickStart();</a>
<a name="ln1983">      Fraction endTick   = selection().tickEnd();</a>
<a name="ln1984">      for (Measure* m = firstMeasureMM(); m; m = m-&gt;nextMeasureMM()) {</a>
<a name="ln1985">            if (m-&gt;tick() &lt; startTick)</a>
<a name="ln1986">                  continue;</a>
<a name="ln1987">            if (m-&gt;tick() &gt;= endTick)</a>
<a name="ln1988">                  break;</a>
<a name="ln1989">            qreal stretch = m-&gt;userStretch();</a>
<a name="ln1990">            stretch += val;</a>
<a name="ln1991">            if (stretch &lt; 0)</a>
<a name="ln1992">                  stretch = 0;</a>
<a name="ln1993">            m-&gt;undoChangeProperty(Pid::USER_STRETCH, stretch);</a>
<a name="ln1994">            }</a>
<a name="ln1995">      }</a>
<a name="ln1996"> </a>
<a name="ln1997">//---------------------------------------------------------</a>
<a name="ln1998">//   cmdResetBeamMode</a>
<a name="ln1999">//---------------------------------------------------------</a>
<a name="ln2000"> </a>
<a name="ln2001">void Score::cmdResetBeamMode()</a>
<a name="ln2002">      {</a>
<a name="ln2003">      bool noSelection = selection().isNone();</a>
<a name="ln2004">      if (noSelection)</a>
<a name="ln2005">            cmdSelectAll();</a>
<a name="ln2006">      else if (!selection().isRange()) {</a>
<a name="ln2007">            qDebug(&quot;no system or staff selected&quot;);</a>
<a name="ln2008">            return;</a>
<a name="ln2009">            }</a>
<a name="ln2010"> </a>
<a name="ln2011">      Fraction endTick = selection().tickEnd();</a>
<a name="ln2012"> </a>
<a name="ln2013">      for (Segment* seg = selection().firstChordRestSegment(); seg &amp;&amp; seg-&gt;tick() &lt; endTick; seg = seg-&gt;next1(SegmentType::ChordRest)) {</a>
<a name="ln2014">            for (int track = selection().staffStart() * VOICES; track &lt; selection().staffEnd() * VOICES; ++track) {</a>
<a name="ln2015">                  ChordRest* cr = toChordRest(seg-&gt;element(track));</a>
<a name="ln2016">                  if (cr == 0)</a>
<a name="ln2017">                        continue;</a>
<a name="ln2018">                  if (cr-&gt;type() == ElementType::CHORD) {</a>
<a name="ln2019">                        if (cr-&gt;beamMode() != Beam::Mode::AUTO)</a>
<a name="ln2020">                              cr-&gt;undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::AUTO));</a>
<a name="ln2021">                        }</a>
<a name="ln2022">                  else if (cr-&gt;type() == ElementType::REST) {</a>
<a name="ln2023">                        if (cr-&gt;beamMode() != Beam::Mode::NONE)</a>
<a name="ln2024">                              cr-&gt;undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::NONE));</a>
<a name="ln2025">                        }</a>
<a name="ln2026">                  }</a>
<a name="ln2027">            }</a>
<a name="ln2028">      if (noSelection)</a>
<a name="ln2029">            deselectAll();</a>
<a name="ln2030">      }</a>
<a name="ln2031"> </a>
<a name="ln2032">//---------------------------------------------------------</a>
<a name="ln2033">//   cmdResetStyle</a>
<a name="ln2034">//---------------------------------------------------------</a>
<a name="ln2035"> </a>
<a name="ln2036">void Score::cmdResetStyle()</a>
<a name="ln2037">      {</a>
<a name="ln2038">      style().reset(this);</a>
<a name="ln2039">      }</a>
<a name="ln2040"> </a>
<a name="ln2041">//---------------------------------------------------------</a>
<a name="ln2042">//   cmdResetNoteAndRestGroupings</a>
<a name="ln2043">//---------------------------------------------------------</a>
<a name="ln2044"> </a>
<a name="ln2045">void Score::cmdResetNoteAndRestGroupings()</a>
<a name="ln2046">      {</a>
<a name="ln2047">      bool noSelection = selection().isNone();</a>
<a name="ln2048">      if (noSelection)</a>
<a name="ln2049">            cmdSelectAll();</a>
<a name="ln2050">      else if (!selection().isRange()) {</a>
<a name="ln2051">            qDebug(&quot;no system or staff selected&quot;);</a>
<a name="ln2052">            return;</a>
<a name="ln2053">            }</a>
<a name="ln2054"> </a>
<a name="ln2055">      // save selection values because selection changes during grouping</a>
<a name="ln2056">      Fraction sTick = selection().tickStart();</a>
<a name="ln2057">      Fraction eTick = selection().tickEnd();</a>
<a name="ln2058">      int sStaff = selection().staffStart();</a>
<a name="ln2059">      int eStaff = selection().staffEnd();</a>
<a name="ln2060"> </a>
<a name="ln2061">      startCmd();</a>
<a name="ln2062">      for (int staff = sStaff; staff &lt; eStaff; staff++) {</a>
<a name="ln2063">            int sTrack = staff * VOICES;</a>
<a name="ln2064">            int eTrack = sTrack + VOICES;</a>
<a name="ln2065">            for (int track = sTrack; track &lt; eTrack; track++) {</a>
<a name="ln2066">                  if (selectionFilter().canSelectVoice(track))</a>
<a name="ln2067">                        regroupNotesAndRests(sTick, eTick, track);</a>
<a name="ln2068">                  }</a>
<a name="ln2069">            }</a>
<a name="ln2070">      endCmd();</a>
<a name="ln2071">      if (noSelection)</a>
<a name="ln2072">            deselectAll();</a>
<a name="ln2073">      }</a>
<a name="ln2074"> </a>
<a name="ln2075">//---------------------------------------------------------</a>
<a name="ln2076">//   resetElementShapePosition</a>
<a name="ln2077">//    For use with Score::scanElements.</a>
<a name="ln2078">//    Reset positions and autoplacement for the given</a>
<a name="ln2079">//    element.</a>
<a name="ln2080">//---------------------------------------------------------</a>
<a name="ln2081"> </a>
<a name="ln2082">static void resetElementPosition(void*, Element* e)</a>
<a name="ln2083">      {</a>
<a name="ln2084">      if (e-&gt;generated())</a>
<a name="ln2085">            return;</a>
<a name="ln2086">      e-&gt;undoResetProperty(Pid::AUTOPLACE);</a>
<a name="ln2087">      e-&gt;undoResetProperty(Pid::OFFSET);</a>
<a name="ln2088">      e-&gt;setOffsetChanged(false);</a>
<a name="ln2089">      if (e-&gt;isSpanner())</a>
<a name="ln2090">            e-&gt;undoResetProperty(Pid::OFFSET2);</a>
<a name="ln2091">      }</a>
<a name="ln2092"> </a>
<a name="ln2093">//---------------------------------------------------------</a>
<a name="ln2094">//   cmdResetAllPositions</a>
<a name="ln2095">//---------------------------------------------------------</a>
<a name="ln2096"> </a>
<a name="ln2097">void Score::cmdResetAllPositions()</a>
<a name="ln2098">      {</a>
<a name="ln2099">      startCmd();</a>
<a name="ln2100">      scanElements(nullptr, resetElementPosition);</a>
<a name="ln2101">      endCmd();</a>
<a name="ln2102">      }</a>
<a name="ln2103"> </a>
<a name="ln2104">//---------------------------------------------------------</a>
<a name="ln2105">//   processMidiInput</a>
<a name="ln2106">//---------------------------------------------------------</a>
<a name="ln2107"> </a>
<a name="ln2108">bool Score::processMidiInput()</a>
<a name="ln2109">      {</a>
<a name="ln2110">      if (midiInputQueue()-&gt;empty())</a>
<a name="ln2111">            return false;</a>
<a name="ln2112"> </a>
<a name="ln2113">      if (MScore::debugMode)</a>
<a name="ln2114">          qDebug(&quot;processMidiInput&quot;);</a>
<a name="ln2115"> </a>
<a name="ln2116">      NoteEntryMethod entryMethod = _is.noteEntryMethod();</a>
<a name="ln2117">      bool cmdActive = false;</a>
<a name="ln2118">      while (!midiInputQueue()-&gt;empty()) {</a>
<a name="ln2119">            MidiInputEvent ev = midiInputQueue()-&gt;dequeue();</a>
<a name="ln2120">            for (auto itr = activeMidiPitches()-&gt;begin(); itr != activeMidiPitches()-&gt;end();) {</a>
<a name="ln2121">                  if ((*itr).pitch == ev.pitch)</a>
<a name="ln2122">                        itr = activeMidiPitches()-&gt;erase(itr);</a>
<a name="ln2123">                  else</a>
<a name="ln2124">                        ++itr;</a>
<a name="ln2125">                  }</a>
<a name="ln2126">            if (MScore::debugMode)</a>
<a name="ln2127">                  qDebug(&quot;&lt;-- !noteentry dequeue %i&quot;, ev.pitch);</a>
<a name="ln2128">            if (!noteEntryMode()</a>
<a name="ln2129">                        || entryMethod == NoteEntryMethod::REALTIME_AUTO</a>
<a name="ln2130">                        || entryMethod == NoteEntryMethod::REALTIME_MANUAL) {</a>
<a name="ln2131">                  int staffIdx = selection().staffStart();</a>
<a name="ln2132">                  Part* p;</a>
<a name="ln2133">                  if (staffIdx &lt; 0 || staffIdx &gt;= nstaves())</a>
<a name="ln2134">                        p = staff(0)-&gt;part();</a>
<a name="ln2135">                  else</a>
<a name="ln2136">                        p = staff(staffIdx)-&gt;part();</a>
<a name="ln2137">                  if (p) {</a>
<a name="ln2138">                        if (!styleB(Sid::concertPitch)) {</a>
<a name="ln2139">                              ev.pitch += p-&gt;instrument(selection().tickStart())-&gt;transpose().chromatic;</a>
<a name="ln2140">                              }</a>
<a name="ln2141">                        MScore::seq-&gt;startNote(</a>
<a name="ln2142">                                          p-&gt;instrument()-&gt;channel(0)-&gt;channel(),</a>
<a name="ln2143">                                          ev.pitch,</a>
<a name="ln2144">                                          ev.velocity,</a>
<a name="ln2145">                                          0.0);</a>
<a name="ln2146">                        }</a>
<a name="ln2147">                  }</a>
<a name="ln2148">            if (noteEntryMode()) {</a>
<a name="ln2149">                  if (ev.velocity == 0) {</a>
<a name="ln2150">                        // delete note in realtime mode</a>
<a name="ln2151">                        //Chord* chord = toChord(_is.cr());</a>
<a name="ln2152">                        //std::vector&lt;Note*&gt; notes = chord-&gt;notes();</a>
<a name="ln2153">                        if (entryMethod == NoteEntryMethod::REALTIME_AUTO || entryMethod == NoteEntryMethod::REALTIME_MANUAL) {</a>
<a name="ln2154">                              if (_is.cr()-&gt;isChord()) {</a>
<a name="ln2155">                                    Note* n = toChord(_is.cr())-&gt;findNote(ev.pitch);</a>
<a name="ln2156">                                    if (n) {</a>
<a name="ln2157">                                          qDebug(&quot;Pitches match! Note %i, Pitch %i&quot;, n-&gt;pitch(), ev.pitch);</a>
<a name="ln2158">                                          if (!cmdActive) {</a>
<a name="ln2159">                                                startCmd();</a>
<a name="ln2160">                                                cmdActive = true;</a>
<a name="ln2161">                                                }</a>
<a name="ln2162">                                          deleteItem(n-&gt;tieBack());</a>
<a name="ln2163">                                          deleteItem(n);</a>
<a name="ln2164">                                          }</a>
<a name="ln2165">                                    }</a>
<a name="ln2166">                              }</a>
<a name="ln2167">                        continue;</a>
<a name="ln2168">                        }</a>
<a name="ln2169">                  if (!cmdActive) {</a>
<a name="ln2170">                        startCmd();</a>
<a name="ln2171">                        cmdActive = true;</a>
<a name="ln2172">                        }</a>
<a name="ln2173">                  if (activeMidiPitches()-&gt;empty())</a>
<a name="ln2174">                        ev.chord = false;</a>
<a name="ln2175">                  else</a>
<a name="ln2176">                        ev.chord = true;</a>
<a name="ln2177"> </a>
<a name="ln2178">                  // holding shift while inputting midi will add the new pitch to the prior existing chord</a>
<a name="ln2179">                  if (qApp-&gt;keyboardModifiers() &amp; Qt::ShiftModifier) {</a>
<a name="ln2180">                        Element* cr = _is.lastSegment()-&gt;element(_is.track());</a>
<a name="ln2181">                        if (cr &amp;&amp; cr-&gt;isChord())</a>
<a name="ln2182">                              ev.chord = true;</a>
<a name="ln2183">                        }</a>
<a name="ln2184"> </a>
<a name="ln2185">                  // TODO: add shadow note instead of real note in realtime modes</a>
<a name="ln2186">                  // (note becomes real when realtime-advance triggered).</a>
<a name="ln2187">                  addMidiPitch(ev.pitch, ev.chord);</a>
<a name="ln2188">                  activeMidiPitches()-&gt;push_back(ev);</a>
<a name="ln2189">                  }</a>
<a name="ln2190">            }</a>
<a name="ln2191">      if (cmdActive) {</a>
<a name="ln2192">            endCmd();</a>
<a name="ln2193">            //after relayout</a>
<a name="ln2194">            Element* e = inputState().cr();</a>
<a name="ln2195">            if (e) {</a>
<a name="ln2196">                  for(MuseScoreView* v : viewer)</a>
<a name="ln2197">                        v-&gt;adjustCanvasPosition(e, false);</a>
<a name="ln2198">                  }</a>
<a name="ln2199">            return true;</a>
<a name="ln2200">            }</a>
<a name="ln2201">      return false;</a>
<a name="ln2202">      }</a>
<a name="ln2203"> </a>
<a name="ln2204">//---------------------------------------------------------</a>
<a name="ln2205">//   move</a>
<a name="ln2206">//    move current selection</a>
<a name="ln2207">//---------------------------------------------------------</a>
<a name="ln2208"> </a>
<a name="ln2209">Element* Score::move(const QString&amp; cmd)</a>
<a name="ln2210">      {</a>
<a name="ln2211">      ChordRest* cr;</a>
<a name="ln2212">      if (noteEntryMode()) {</a>
<a name="ln2213">            // if selection exists and is grace note, use it</a>
<a name="ln2214">            // otherwise use chord/rest at input position</a>
<a name="ln2215">            // also use it if we are moving to next chord</a>
<a name="ln2216">            // to catch up with the cursor and not move the selection by 2 positions</a>
<a name="ln2217">            cr = selection().cr();</a>
<a name="ln2218">            if (cr &amp;&amp; (cr-&gt;isGrace() || cmd == &quot;next-chord&quot; || cmd == &quot;prev-chord&quot;))</a>
<a name="ln2219">                  ;</a>
<a name="ln2220">            else</a>
<a name="ln2221">                  cr = inputState().cr();</a>
<a name="ln2222">            }</a>
<a name="ln2223">      else if (selection().activeCR())</a>
<a name="ln2224">            cr = selection().activeCR();</a>
<a name="ln2225">      else</a>
<a name="ln2226">            cr = selection().lastChordRest();</a>
<a name="ln2227"> </a>
<a name="ln2228">      // no chord/rest found? look for another type of element</a>
<a name="ln2229">      if (cr == 0) {</a>
<a name="ln2230">            if (selection().elements().empty())</a>
<a name="ln2231">                  return 0;</a>
<a name="ln2232">            // retrieve last element of section list</a>
<a name="ln2233">            Element* el = selection().elements().last();</a>
<a name="ln2234">            Element* trg = 0;</a>
<a name="ln2235"> </a>
<a name="ln2236">            // get parent of element and process accordingly:</a>
<a name="ln2237">            // trg is the element to select on &quot;next-chord&quot; cmd</a>
<a name="ln2238">            // cr is the ChordRest to move from on other cmd's</a>
<a name="ln2239">            int track = el-&gt;track();            // keep note of element track</a>
<a name="ln2240">            el = el-&gt;parent();</a>
<a name="ln2241">            // element with no parent (eg, a newly-added line) - no way to find context</a>
<a name="ln2242">            if (!el)</a>
<a name="ln2243">                  return 0;</a>
<a name="ln2244">            switch (el-&gt;type()) {</a>
<a name="ln2245">                  case ElementType::NOTE:           // a note is a valid target</a>
<a name="ln2246">                        trg = el;</a>
<a name="ln2247">                        cr  = toNote(el)-&gt;chord();</a>
<a name="ln2248">                        break;</a>
<a name="ln2249">                  case ElementType::CHORD:          // a chord or a rest are valid targets</a>
<a name="ln2250">                  case ElementType::REST:</a>
<a name="ln2251">                        trg = el;</a>
<a name="ln2252">                        cr  = toChordRest(trg);</a>
<a name="ln2253">                        break;</a>
<a name="ln2254">                  case ElementType::SEGMENT: {      // from segment go to top chordrest in segment</a>
<a name="ln2255">                        Segment* seg  = toSegment(el);</a>
<a name="ln2256">                        // if segment is not chord/rest or grace, move to next chord/rest or grace segment</a>
<a name="ln2257">                        if (!seg-&gt;isChordRest()) {</a>
<a name="ln2258">                              seg = seg-&gt;next1(SegmentType::ChordRest);</a>
<a name="ln2259">                              if (seg == 0)     // if none found, return failure</a>
<a name="ln2260">                                    return 0;</a>
<a name="ln2261">                              }</a>
<a name="ln2262">                        // segment for sure contains chords/rests,</a>
<a name="ln2263">                        int size = int(seg-&gt;elist().size());</a>
<a name="ln2264">                        // if segment has a chord/rest in original element track, use it</a>
<a name="ln2265">                        if (track &gt; -1 &amp;&amp; track &lt; size &amp;&amp; seg-&gt;element(track)) {</a>
<a name="ln2266">                              trg  = seg-&gt;element(track);</a>
<a name="ln2267">                              cr = toChordRest(trg);</a>
<a name="ln2268">                              break;</a>
<a name="ln2269">                              }</a>
<a name="ln2270">                        // if not, get topmost chord/rest</a>
<a name="ln2271">                        for (int i = 0; i &lt; size; i++)</a>
<a name="ln2272">                              if (seg-&gt;element(i)) {</a>
<a name="ln2273">                                    trg  = seg-&gt;element(i);</a>
<a name="ln2274">                                    cr = toChordRest(trg);</a>
<a name="ln2275">                                    break;</a>
<a name="ln2276">                                    }</a>
<a name="ln2277">                        break;</a>
<a name="ln2278">                        }</a>
<a name="ln2279">                  default:                      // on anything else, return failure</a>
<a name="ln2280">                        return 0;</a>
<a name="ln2281">                  }</a>
<a name="ln2282"> </a>
<a name="ln2283">            // if something found and command is forward, the element found is the destination</a>
<a name="ln2284">            if (trg &amp;&amp; cmd == &quot;next-chord&quot;) {</a>
<a name="ln2285">                  // if chord, go to topmost note</a>
<a name="ln2286">                  if (trg-&gt;type() == ElementType::CHORD)</a>
<a name="ln2287">                        trg = toChord(trg)-&gt;upNote();</a>
<a name="ln2288">                  setPlayNote(true);</a>
<a name="ln2289">                  select(trg, SelectType::SINGLE, 0);</a>
<a name="ln2290">                  return trg;</a>
<a name="ln2291">                  }</a>
<a name="ln2292">            // if no chordrest found, do nothing</a>
<a name="ln2293">            if (cr == 0)</a>
<a name="ln2294">                  return 0;</a>
<a name="ln2295">            // if some chordrest found, continue with default processing</a>
<a name="ln2296">            }</a>
<a name="ln2297"> </a>
<a name="ln2298">      Element* el = 0;</a>
<a name="ln2299">      Segment* ois = noteEntryMode() ? _is.segment() : nullptr;</a>
<a name="ln2300">      Measure* oim = ois ? ois-&gt;measure() : nullptr;</a>
<a name="ln2301"> </a>
<a name="ln2302">      if (cmd == &quot;next-chord&quot;) {</a>
<a name="ln2303">            // note input cursor</a>
<a name="ln2304">            if (noteEntryMode())</a>
<a name="ln2305">                  _is.moveToNextInputPos();</a>
<a name="ln2306"> </a>
<a name="ln2307">            // selection &quot;cursor&quot;</a>
<a name="ln2308">            // find next chordrest, which might be a grace note</a>
<a name="ln2309">            // this may override note input cursor</a>
<a name="ln2310">            el = nextChordRest(cr);</a>
<a name="ln2311">            while (el &amp;&amp; el-&gt;isRest() &amp;&amp; toRest(el)-&gt;isGap())</a>
<a name="ln2312">                  el = nextChordRest(toChordRest(el));</a>
<a name="ln2313">            if (el &amp;&amp; noteEntryMode()) {</a>
<a name="ln2314">                  // do not use if not in original or new measure (don't skip measures)</a>
<a name="ln2315">                  Measure* m = toChordRest(el)-&gt;measure();</a>
<a name="ln2316">                  Segment* nis = _is.segment();</a>
<a name="ln2317">                  Measure* nim = nis ? nis-&gt;measure() : nullptr;</a>
<a name="ln2318">                  if (m != oim &amp;&amp; m != nim)</a>
<a name="ln2319">                        el = cr;</a>
<a name="ln2320">                  // do not use if new input segment is current cr</a>
<a name="ln2321">                  // this means input cursor just caught up to current selection</a>
<a name="ln2322">                  else if (cr &amp;&amp; nis == cr-&gt;segment())</a>
<a name="ln2323">                        el = cr;</a>
<a name="ln2324">                  }</a>
<a name="ln2325">            else if (!el)</a>
<a name="ln2326">                  el = cr;</a>
<a name="ln2327">            }</a>
<a name="ln2328">      else if (cmd == &quot;prev-chord&quot;) {</a>
<a name="ln2329">            // note input cursor</a>
<a name="ln2330">            if (noteEntryMode() &amp;&amp; _is.segment()) {</a>
<a name="ln2331">                  Measure* m = _is.segment()-&gt;measure();</a>
<a name="ln2332">                  Segment* s = _is.segment()-&gt;prev1(SegmentType::ChordRest);</a>
<a name="ln2333">                  int track = _is.track();</a>
<a name="ln2334">                  for (; s; s = s-&gt;prev1(SegmentType::ChordRest)) {</a>
<a name="ln2335">                        if (s-&gt;element(track) || (s-&gt;measure() != m &amp;&amp; s-&gt;rtick().isZero())) {</a>
<a name="ln2336">                              if (s-&gt;element(track)) {</a>
<a name="ln2337">                                    if (s-&gt;element(track)-&gt;isRest() &amp;&amp; toRest(s-&gt;element(track))-&gt;isGap())</a>
<a name="ln2338">                                          continue;</a>
<a name="ln2339">                                    }</a>
<a name="ln2340">                              break;</a>
<a name="ln2341">                              }</a>
<a name="ln2342">                        }</a>
<a name="ln2343">                  _is.moveInputPos(s);</a>
<a name="ln2344">                  }</a>
<a name="ln2345"> </a>
<a name="ln2346">            // selection &quot;cursor&quot;</a>
<a name="ln2347">            // find previous chordrest, which might be a grace note</a>
<a name="ln2348">            // this may override note input cursor</a>
<a name="ln2349">            el = prevChordRest(cr);</a>
<a name="ln2350">            while (el &amp;&amp; el-&gt;isRest() &amp;&amp; toRest(el)-&gt;isGap())</a>
<a name="ln2351">                  el = prevChordRest(toChordRest(el));</a>
<a name="ln2352">            if (el &amp;&amp; noteEntryMode()) {</a>
<a name="ln2353">                  // do not use if not in original or new measure (don't skip measures)</a>
<a name="ln2354">                  Measure* m = toChordRest(el)-&gt;measure();</a>
<a name="ln2355">                  Segment* nis = _is.segment();</a>
<a name="ln2356">                  Measure* nim = nis ? nis-&gt;measure() : nullptr;</a>
<a name="ln2357">                  if (m != oim &amp;&amp; m != nim)</a>
<a name="ln2358">                        el = cr;</a>
<a name="ln2359">                  // do not use if new input segment is current cr</a>
<a name="ln2360">                  // this means input cursor just caught up to current selection</a>
<a name="ln2361">                  else if (cr &amp;&amp; nis == cr-&gt;segment())</a>
<a name="ln2362">                        el = cr;</a>
<a name="ln2363">                  }</a>
<a name="ln2364">            else if (!el)</a>
<a name="ln2365">                  el = cr;</a>
<a name="ln2366"> </a>
<a name="ln2367">            }</a>
<a name="ln2368">      else if (cmd == &quot;next-measure&quot;) {</a>
<a name="ln2369">            el = nextMeasure(cr);</a>
<a name="ln2370">            if (noteEntryMode())</a>
<a name="ln2371">                  _is.moveInputPos(el);</a>
<a name="ln2372">            }</a>
<a name="ln2373">      else if (cmd == &quot;prev-measure&quot;) {</a>
<a name="ln2374">            el = prevMeasure(cr);</a>
<a name="ln2375">            if (noteEntryMode())</a>
<a name="ln2376">                  _is.moveInputPos(el);</a>
<a name="ln2377">            }</a>
<a name="ln2378">      else if (cmd == &quot;next-track&quot;) {</a>
<a name="ln2379">            el = nextTrack(cr);</a>
<a name="ln2380">            if (noteEntryMode())</a>
<a name="ln2381">                  _is.moveInputPos(el);</a>
<a name="ln2382">            }</a>
<a name="ln2383">      else if (cmd == &quot;prev-track&quot;) {</a>
<a name="ln2384">            el = prevTrack(cr);</a>
<a name="ln2385">            if (noteEntryMode())</a>
<a name="ln2386">                  _is.moveInputPos(el);</a>
<a name="ln2387">            }</a>
<a name="ln2388"> </a>
<a name="ln2389">      if (el) {</a>
<a name="ln2390">            if (el-&gt;type() == ElementType::CHORD)</a>
<a name="ln2391">                  el = toChord(el)-&gt;upNote();       // originally downNote</a>
<a name="ln2392">            setPlayNote(true);</a>
<a name="ln2393">            if (noteEntryMode()) {</a>
<a name="ln2394">                  // if cursor moved into a gap, selection cannot follow</a>
<a name="ln2395">                  // only select &amp; play el if it was not already selected (does not normally happen)</a>
<a name="ln2396">                  if (_is.cr() || !el-&gt;selected())</a>
<a name="ln2397">                        select(el, SelectType::SINGLE, 0);</a>
<a name="ln2398">                  else</a>
<a name="ln2399">                        setPlayNote(false);</a>
<a name="ln2400">                  for (MuseScoreView* view : viewer)</a>
<a name="ln2401">                        view-&gt;moveCursor();</a>
<a name="ln2402">                  }</a>
<a name="ln2403">            else {</a>
<a name="ln2404">                  select(el, SelectType::SINGLE, 0);</a>
<a name="ln2405">                  }</a>
<a name="ln2406">            }</a>
<a name="ln2407">      return el;</a>
<a name="ln2408">      }</a>
<a name="ln2409"> </a>
<a name="ln2410">//---------------------------------------------------------</a>
<a name="ln2411">//   selectMove</a>
<a name="ln2412">//---------------------------------------------------------</a>
<a name="ln2413"> </a>
<a name="ln2414">Element* Score::selectMove(const QString&amp; cmd)</a>
<a name="ln2415">      {</a>
<a name="ln2416">      ChordRest* cr;</a>
<a name="ln2417">      if (selection().activeCR())</a>
<a name="ln2418">            cr = selection().activeCR();</a>
<a name="ln2419">      else</a>
<a name="ln2420">            cr = selection().lastChordRest();</a>
<a name="ln2421">      if (cr == 0 &amp;&amp; noteEntryMode())</a>
<a name="ln2422">            cr = inputState().cr();</a>
<a name="ln2423">      if (cr == 0)</a>
<a name="ln2424">            return 0;</a>
<a name="ln2425"> </a>
<a name="ln2426">      ChordRest* el = 0;</a>
<a name="ln2427">      if (cmd == &quot;select-next-chord&quot;)</a>
<a name="ln2428">            el = nextChordRest(cr, true);</a>
<a name="ln2429">      else if (cmd == &quot;select-prev-chord&quot;)</a>
<a name="ln2430">            el = prevChordRest(cr, true);</a>
<a name="ln2431">      else if (cmd == &quot;select-next-measure&quot;)</a>
<a name="ln2432">            el = nextMeasure(cr, true, true);</a>
<a name="ln2433">      else if (cmd == &quot;select-prev-measure&quot;)</a>
<a name="ln2434">            el = prevMeasure(cr, true);</a>
<a name="ln2435">      else if (cmd == &quot;select-begin-line&quot;) {</a>
<a name="ln2436">            Measure* measure = cr-&gt;segment()-&gt;measure()-&gt;system()-&gt;firstMeasure();</a>
<a name="ln2437">            if (!measure)</a>
<a name="ln2438">                  return 0;</a>
<a name="ln2439">            el = measure-&gt;first()-&gt;nextChordRest(cr-&gt;track());</a>
<a name="ln2440">            }</a>
<a name="ln2441">      else if (cmd == &quot;select-end-line&quot;) {</a>
<a name="ln2442">            Measure* measure = cr-&gt;segment()-&gt;measure()-&gt;system()-&gt;lastMeasure();</a>
<a name="ln2443">            if (!measure)</a>
<a name="ln2444">                  return 0;</a>
<a name="ln2445">            el = measure-&gt;last()-&gt;nextChordRest(cr-&gt;track(), true);</a>
<a name="ln2446">            }</a>
<a name="ln2447">      else if (cmd == &quot;select-begin-score&quot;) {</a>
<a name="ln2448">            Measure* measure = firstMeasureMM();</a>
<a name="ln2449">            if (!measure)</a>
<a name="ln2450">                  return 0;</a>
<a name="ln2451">            el = measure-&gt;first()-&gt;nextChordRest(cr-&gt;track());</a>
<a name="ln2452">            }</a>
<a name="ln2453">      else if (cmd == &quot;select-end-score&quot;) {</a>
<a name="ln2454">            Measure* measure = lastMeasureMM();</a>
<a name="ln2455">            if (!measure)</a>
<a name="ln2456">                  return 0;</a>
<a name="ln2457">            el = measure-&gt;last()-&gt;nextChordRest(cr-&gt;track(), true);</a>
<a name="ln2458">            }</a>
<a name="ln2459">      else if (cmd == &quot;select-staff-above&quot;)</a>
<a name="ln2460">            el = upStaff(cr);</a>
<a name="ln2461">      else if (cmd == &quot;select-staff-below&quot;)</a>
<a name="ln2462">            el = downStaff(cr);</a>
<a name="ln2463">      if (el)</a>
<a name="ln2464">            select(el, SelectType::RANGE, el-&gt;staffIdx());</a>
<a name="ln2465">      return el;</a>
<a name="ln2466">      }</a>
<a name="ln2467"> </a>
<a name="ln2468">//---------------------------------------------------------</a>
<a name="ln2469">//   cmdMirrorNoteHead</a>
<a name="ln2470">//---------------------------------------------------------</a>
<a name="ln2471"> </a>
<a name="ln2472">void Score::cmdMirrorNoteHead()</a>
<a name="ln2473">      {</a>
<a name="ln2474">      const QList&lt;Element*&gt;&amp; el = selection().elements();</a>
<a name="ln2475">      for (Element* e : el) {</a>
<a name="ln2476">            if (e-&gt;isNote()) {</a>
<a name="ln2477">                  Note* note = toNote(e);</a>
<a name="ln2478">                  if (note-&gt;staff() &amp;&amp; note-&gt;staff()-&gt;isTabStaff(note-&gt;chord()-&gt;tick()))</a>
<a name="ln2479">                        e-&gt;undoChangeProperty(Pid::GHOST, !note-&gt;ghost());</a>
<a name="ln2480">                  else {</a>
<a name="ln2481">                        MScore::DirectionH d = note-&gt;userMirror();</a>
<a name="ln2482">                        if (d == MScore::DirectionH::AUTO)</a>
<a name="ln2483">                              d = note-&gt;chord()-&gt;up() ? MScore::DirectionH::RIGHT : MScore::DirectionH::LEFT;</a>
<a name="ln2484">                        else</a>
<a name="ln2485">                              d = d == MScore::DirectionH::LEFT ? MScore::DirectionH::RIGHT : MScore::DirectionH::LEFT;</a>
<a name="ln2486">                        undoChangeUserMirror(note, d);</a>
<a name="ln2487">                        }</a>
<a name="ln2488">                  }</a>
<a name="ln2489">            else if (e-&gt;isHairpinSegment()) {</a>
<a name="ln2490">                  Hairpin* h = toHairpinSegment(e)-&gt;hairpin();</a>
<a name="ln2491">                  HairpinType st = h-&gt;hairpinType();</a>
<a name="ln2492">                  switch (st)  {</a>
<a name="ln2493">                        case HairpinType::CRESC_HAIRPIN:</a>
<a name="ln2494">                              st = HairpinType::DECRESC_HAIRPIN;</a>
<a name="ln2495">                              break;</a>
<a name="ln2496">                        case HairpinType::DECRESC_HAIRPIN:</a>
<a name="ln2497">                              st = HairpinType::CRESC_HAIRPIN;</a>
<a name="ln2498">                              break;</a>
<a name="ln2499">                        case HairpinType::CRESC_LINE:</a>
<a name="ln2500">                              st = HairpinType::DECRESC_LINE;</a>
<a name="ln2501">                              break;</a>
<a name="ln2502">                        case HairpinType::DECRESC_LINE:</a>
<a name="ln2503">                              st = HairpinType::CRESC_LINE;</a>
<a name="ln2504">                              break;</a>
<a name="ln2505">                        case HairpinType::INVALID:</a>
<a name="ln2506">                              break;</a>
<a name="ln2507">                        }</a>
<a name="ln2508">                  h-&gt;undoChangeProperty(Pid::HAIRPIN_TYPE, int(st));</a>
<a name="ln2509">                  }</a>
<a name="ln2510">            }</a>
<a name="ln2511">      }</a>
<a name="ln2512"> </a>
<a name="ln2513">//---------------------------------------------------------</a>
<a name="ln2514">//   cmdIncDecDuration</a>
<a name="ln2515">//     When stepDotted is false and nSteps is 1 or -1, will halve or double the duration</a>
<a name="ln2516">//     When stepDotted is true, will step by nearest dotted or undotted note</a>
<a name="ln2517">//---------------------------------------------------------</a>
<a name="ln2518"> </a>
<a name="ln2519">void Score::cmdIncDecDuration(int nSteps, bool stepDotted)</a>
<a name="ln2520">      {</a>
<a name="ln2521">      Element* el = selection().element();</a>
<a name="ln2522">      if (el == 0)</a>
<a name="ln2523">            return;</a>
<a name="ln2524">      if (el-&gt;isNote())</a>
<a name="ln2525">            el = el-&gt;parent();</a>
<a name="ln2526">      if (!el-&gt;isChordRest())</a>
<a name="ln2527">            return;</a>
<a name="ln2528"> </a>
<a name="ln2529">      ChordRest* cr = toChordRest(el);</a>
<a name="ln2530"> </a>
<a name="ln2531">      // if measure rest is selected as input, then the correct initialDuration will be the</a>
<a name="ln2532">      // duration of the measure's time signature, else is just the input state's duration</a>
<a name="ln2533">      TDuration initialDuration = (cr-&gt;durationType() == TDuration::DurationType::V_MEASURE) ? TDuration(cr-&gt;measure()-&gt;timesig()) : _is.duration();</a>
<a name="ln2534">      TDuration d = initialDuration.shiftRetainDots(nSteps, stepDotted);</a>
<a name="ln2535">      if (!d.isValid())</a>
<a name="ln2536">            return;</a>
<a name="ln2537">      if (cr-&gt;isChord() &amp;&amp; (toChord(cr)-&gt;noteType() != NoteType::NORMAL)) {</a>
<a name="ln2538">            //</a>
<a name="ln2539">            // handle appoggiatura and acciaccatura</a>
<a name="ln2540">            //</a>
<a name="ln2541">            undoChangeChordRestLen(cr, d);</a>
<a name="ln2542">            }</a>
<a name="ln2543">      else</a>
<a name="ln2544">            changeCRlen(cr, d);</a>
<a name="ln2545">      _is.setDuration(d);</a>
<a name="ln2546">      nextInputPos(cr, false);</a>
<a name="ln2547">      }</a>
<a name="ln2548"> </a>
<a name="ln2549">//---------------------------------------------------------</a>
<a name="ln2550">//   cmdAddBracket</a>
<a name="ln2551">//---------------------------------------------------------</a>
<a name="ln2552"> </a>
<a name="ln2553">void Score::cmdAddBracket()</a>
<a name="ln2554">      {</a>
<a name="ln2555">      for (Element* el : selection().elements()) {</a>
<a name="ln2556">            if (el-&gt;type() == ElementType::ACCIDENTAL) {</a>
<a name="ln2557">                  Accidental* acc = toAccidental(el);</a>
<a name="ln2558">                  acc-&gt;undoChangeProperty(Pid::ACCIDENTAL_BRACKET, int(AccidentalBracket::BRACKET));</a>
<a name="ln2559">                  }</a>
<a name="ln2560">            }</a>
<a name="ln2561">      }</a>
<a name="ln2562"> </a>
<a name="ln2563">//---------------------------------------------------------</a>
<a name="ln2564">//   cmdAddParentheses</a>
<a name="ln2565">//---------------------------------------------------------</a>
<a name="ln2566"> </a>
<a name="ln2567">void Score::cmdAddParentheses()</a>
<a name="ln2568">      {</a>
<a name="ln2569">      for (Element* el : selection().elements()) {</a>
<a name="ln2570">            if (el-&gt;type() == ElementType::NOTE) {</a>
<a name="ln2571">                  Note* n = toNote(el);</a>
<a name="ln2572">                  n-&gt;addParentheses();</a>
<a name="ln2573">                  }</a>
<a name="ln2574">            else if (el-&gt;type() == ElementType::ACCIDENTAL) {</a>
<a name="ln2575">                  Accidental* acc = toAccidental(el);</a>
<a name="ln2576">                  acc-&gt;undoChangeProperty(Pid::ACCIDENTAL_BRACKET, int(AccidentalBracket::PARENTHESIS));</a>
<a name="ln2577">                  }</a>
<a name="ln2578">            else if (el-&gt;type() == ElementType::HARMONY) {</a>
<a name="ln2579">                  Harmony* h = toHarmony(el);</a>
<a name="ln2580">                  h-&gt;setLeftParen(true);</a>
<a name="ln2581">                  h-&gt;setRightParen(true);</a>
<a name="ln2582">                  h-&gt;render();</a>
<a name="ln2583">                  }</a>
<a name="ln2584">            else if (el-&gt;type() == ElementType::TIMESIG) {</a>
<a name="ln2585">                  TimeSig* ts = toTimeSig(el);</a>
<a name="ln2586">                  ts-&gt;setLargeParentheses(true);</a>
<a name="ln2587">                  }</a>
<a name="ln2588">            }</a>
<a name="ln2589">      }</a>
<a name="ln2590"> </a>
<a name="ln2591"> </a>
<a name="ln2592">//---------------------------------------------------------</a>
<a name="ln2593">//   cmdMoveRest</a>
<a name="ln2594">//---------------------------------------------------------</a>
<a name="ln2595"> </a>
<a name="ln2596">void Score::cmdMoveRest(Rest* rest, Direction dir)</a>
<a name="ln2597">      {</a>
<a name="ln2598">      QPointF pos(rest-&gt;offset());</a>
<a name="ln2599">      if (dir == Direction::UP)</a>
<a name="ln2600">            pos.ry() -= spatium();</a>
<a name="ln2601">      else if (dir == Direction::DOWN)</a>
<a name="ln2602">            pos.ry() += spatium();</a>
<a name="ln2603">      rest-&gt;undoChangeProperty(Pid::OFFSET, pos);</a>
<a name="ln2604">      }</a>
<a name="ln2605"> </a>
<a name="ln2606">//---------------------------------------------------------</a>
<a name="ln2607">//   cmdMoveLyrics</a>
<a name="ln2608">//---------------------------------------------------------</a>
<a name="ln2609"> </a>
<a name="ln2610">void Score::cmdMoveLyrics(Lyrics* lyrics, Direction dir)</a>
<a name="ln2611">      {</a>
<a name="ln2612">      int verse = lyrics-&gt;no() + (dir == Direction::UP ? -1 : 1);</a>
<a name="ln2613">      if (verse &lt; 0)</a>
<a name="ln2614">            return;</a>
<a name="ln2615">      lyrics-&gt;undoChangeProperty(Pid::VERSE, verse);</a>
<a name="ln2616">      }</a>
<a name="ln2617"> </a>
<a name="ln2618">//---------------------------------------------------------</a>
<a name="ln2619">//   cmdInsertClef</a>
<a name="ln2620">//---------------------------------------------------------</a>
<a name="ln2621"> </a>
<a name="ln2622">void Score::cmdInsertClef(ClefType type)</a>
<a name="ln2623">      {</a>
<a name="ln2624">      if (!noteEntryMode())</a>
<a name="ln2625">            return;</a>
<a name="ln2626">      undoChangeClef(staff(inputTrack()/VOICES), inputState().cr(), type);</a>
<a name="ln2627">      }</a>
<a name="ln2628"> </a>
<a name="ln2629">//---------------------------------------------------------</a>
<a name="ln2630">//   cmdInsertClef</a>
<a name="ln2631">//    insert clef before cr</a>
<a name="ln2632">//---------------------------------------------------------</a>
<a name="ln2633"> </a>
<a name="ln2634">void Score::cmdInsertClef(Clef* clef, ChordRest* cr)</a>
<a name="ln2635">      {</a>
<a name="ln2636">      undoChangeClef(cr-&gt;staff(), cr, clef-&gt;clefType());</a>
<a name="ln2637">      delete clef;</a>
<a name="ln2638">      }</a>
<a name="ln2639"> </a>
<a name="ln2640">//---------------------------------------------------------</a>
<a name="ln2641">//   cmdAddGrace</a>
<a name="ln2642">///   adds grace note of specified type to selected notes</a>
<a name="ln2643">//---------------------------------------------------------</a>
<a name="ln2644"> </a>
<a name="ln2645">void Score::cmdAddGrace (NoteType graceType, int duration)</a>
<a name="ln2646">      {</a>
<a name="ln2647">      const QList&lt;Element*&gt; copyOfElements = selection().elements();</a>
<a name="ln2648">      for (Element* e : copyOfElements) {</a>
<a name="ln2649">            if (e-&gt;type() == ElementType::NOTE) {</a>
<a name="ln2650">                  Note* n = toNote(e);</a>
<a name="ln2651">                  setGraceNote(n-&gt;chord(), n-&gt;pitch(), graceType, duration);</a>
<a name="ln2652">                  }</a>
<a name="ln2653">            }</a>
<a name="ln2654">      }</a>
<a name="ln2655"> </a>
<a name="ln2656">//---------------------------------------------------------</a>
<a name="ln2657">//   cmdExplode</a>
<a name="ln2658">///   explodes contents of top selected staff into subsequent staves</a>
<a name="ln2659">//---------------------------------------------------------</a>
<a name="ln2660"> </a>
<a name="ln2661">void Score::cmdExplode()</a>
<a name="ln2662">      {</a>
<a name="ln2663">      if (!selection().isRange())</a>
<a name="ln2664">            return;</a>
<a name="ln2665"> </a>
<a name="ln2666">      int srcStaff  = selection().staffStart();</a>
<a name="ln2667">      int lastStaff = selection().staffEnd();</a>
<a name="ln2668">      int srcTrack  = srcStaff * VOICES;</a>
<a name="ln2669"> </a>
<a name="ln2670">      // reset selection to top staff only</a>
<a name="ln2671">      // force complete measures</a>
<a name="ln2672">      Segment* startSegment = selection().startSegment();</a>
<a name="ln2673">      Segment* endSegment = selection().endSegment();</a>
<a name="ln2674">      Measure* startMeasure = startSegment-&gt;measure();</a>
<a name="ln2675">      Measure* endMeasure = endSegment ? endSegment-&gt;measure() : lastMeasure();</a>
<a name="ln2676"> </a>
<a name="ln2677">      Fraction lTick = endMeasure-&gt;endTick();</a>
<a name="ln2678">      bool voice = false;</a>
<a name="ln2679"> </a>
<a name="ln2680">      for (Measure* m = startMeasure; m &amp;&amp; m-&gt;tick() != lTick; m = m-&gt;nextMeasure()) {</a>
<a name="ln2681">            if (m-&gt;hasVoices(srcStaff)) {</a>
<a name="ln2682">                  voice = true;</a>
<a name="ln2683">                  break;</a>
<a name="ln2684">                  }</a>
<a name="ln2685">            }</a>
<a name="ln2686">      if (! voice) {</a>
<a name="ln2687">            // force complete measures</a>
<a name="ln2688">            deselectAll();</a>
<a name="ln2689">            select(startMeasure, SelectType::RANGE, srcStaff);</a>
<a name="ln2690">            select(endMeasure, SelectType::RANGE, srcStaff);</a>
<a name="ln2691">            startSegment = selection().startSegment();</a>
<a name="ln2692">            endSegment = selection().endSegment();</a>
<a name="ln2693">            if (srcStaff == lastStaff - 1) {</a>
<a name="ln2694">                  // only one staff was selected up front - determine number of staves</a>
<a name="ln2695">                  // loop through all chords looking for maximum number of notes</a>
<a name="ln2696">                  int n = 0;</a>
<a name="ln2697">                  for (Segment* s = startSegment; s &amp;&amp; s != endSegment; s = s-&gt;next1()) {</a>
<a name="ln2698">                        Element* e = s-&gt;element(srcTrack);</a>
<a name="ln2699">                        if (e &amp;&amp; e-&gt;type() == ElementType::CHORD) {</a>
<a name="ln2700">                              Chord* c = toChord(e);</a>
<a name="ln2701">                              n = qMax(n, int(c-&gt;notes().size()));</a>
<a name="ln2702">                              }</a>
<a name="ln2703">                        }</a>
<a name="ln2704">                  lastStaff = qMin(nstaves(), srcStaff + n);</a>
<a name="ln2705">                  }</a>
<a name="ln2706"> </a>
<a name="ln2707">            const QByteArray mimeData(selection().mimeData());</a>
<a name="ln2708">            // copy to all destination staves</a>
<a name="ln2709">            Segment* firstCRSegment = startMeasure-&gt;tick2segment(startMeasure-&gt;tick());</a>
<a name="ln2710">            for (int i = 1; srcStaff + i &lt; lastStaff; ++i) {</a>
<a name="ln2711">                  int track = (srcStaff + i) * VOICES;</a>
<a name="ln2712">                  ChordRest* cr = toChordRest(firstCRSegment-&gt;element(track));</a>
<a name="ln2713">                  if (cr) {</a>
<a name="ln2714">                        XmlReader e(mimeData);</a>
<a name="ln2715">                        e.setPasteMode(true);</a>
<a name="ln2716">                        pasteStaff(e, cr-&gt;segment(), cr-&gt;staffIdx());</a>
<a name="ln2717">                        }</a>
<a name="ln2718">                  }</a>
<a name="ln2719"> </a>
<a name="ln2720">            // loop through each staff removing all but one note from each chord</a>
<a name="ln2721">            for (int i = 0; srcStaff + i &lt; lastStaff; ++i) {</a>
<a name="ln2722">                  int track = (srcStaff + i) * VOICES;</a>
<a name="ln2723">                  for (Segment* s = startSegment; s &amp;&amp; s != endSegment; s = s-&gt;next1()) {</a>
<a name="ln2724">                        Element* e = s-&gt;element(track);</a>
<a name="ln2725">                        if (e &amp;&amp; e-&gt;type() == ElementType::CHORD) {</a>
<a name="ln2726">                              Chord* c = toChord(e);</a>
<a name="ln2727">                              std::vector&lt;Note*&gt; notes = c-&gt;notes();</a>
<a name="ln2728">                              int nnotes = int(notes.size());</a>
<a name="ln2729">                              // keep note &quot;i&quot; from top, which is backwards from nnotes - 1</a>
<a name="ln2730">                              // reuse notes if there are more instruments than notes</a>
<a name="ln2731">                              int stavesPerNote = qMax((lastStaff - srcStaff) / nnotes, 1);</a>
<a name="ln2732">                              int keepIndex = qMax(nnotes - 1 - (i / stavesPerNote), 0);</a>
<a name="ln2733">                              Note* keepNote = c-&gt;notes()[keepIndex];</a>
<a name="ln2734">                              foreach (Note* n, notes) {</a>
<a name="ln2735">                                    if (n != keepNote)</a>
<a name="ln2736">                                          undoRemoveElement(n);</a>
<a name="ln2737">                                    }</a>
<a name="ln2738">                              }</a>
<a name="ln2739">                        }</a>
<a name="ln2740">                  }</a>
<a name="ln2741">            }</a>
<a name="ln2742">      else {</a>
<a name="ln2743">            int sTracks[VOICES];</a>
<a name="ln2744">            int dTracks[VOICES];</a>
<a name="ln2745">            if (srcStaff == lastStaff - 1)</a>
<a name="ln2746">                  lastStaff = qMin(nstaves(), srcStaff + VOICES);</a>
<a name="ln2747"> </a>
<a name="ln2748">            for (int i = 0; i &lt; VOICES; i++) {</a>
<a name="ln2749">                  sTracks[i] = -1;</a>
<a name="ln2750">                  dTracks[i] = -1;</a>
<a name="ln2751">                  }</a>
<a name="ln2752">            int full = 0;</a>
<a name="ln2753"> </a>
<a name="ln2754">            for (Segment* seg = startSegment; seg &amp;&amp; seg-&gt;tick() &lt; lTick; seg = seg-&gt;next1()) {</a>
<a name="ln2755">                  for (int i = srcTrack; i &lt; srcTrack + VOICES &amp;&amp; full != VOICES; i++) {</a>
<a name="ln2756">                        bool t = true;</a>
<a name="ln2757">                        for (int j = 0; j &lt; VOICES; j++) {</a>
<a name="ln2758">                              if (i == sTracks[j]) {</a>
<a name="ln2759">                                    t = false;</a>
<a name="ln2760">                                    break;</a>
<a name="ln2761">                                    }</a>
<a name="ln2762">                              }</a>
<a name="ln2763"> </a>
<a name="ln2764">                        if (!seg-&gt;measure()-&gt;hasVoice(i) || seg-&gt;measure()-&gt;isOnlyRests(i) || !t)</a>
<a name="ln2765">                              continue;</a>
<a name="ln2766">                        sTracks[full] = i;</a>
<a name="ln2767"> </a>
<a name="ln2768">                        for(int j = srcTrack + full * VOICES; j &lt; lastStaff * VOICES; j++) {</a>
<a name="ln2769">                              if (i == j) {</a>
<a name="ln2770">                                    dTracks[full] = j;</a>
<a name="ln2771">                                    break;</a>
<a name="ln2772">                                    }</a>
<a name="ln2773">                              for(Measure* m = seg-&gt;measure(); m &amp;&amp; m-&gt;tick() &lt; lTick; m = m-&gt;nextMeasure()) {</a>
<a name="ln2774">                                    if (!m-&gt;hasVoice(j) || (m-&gt;hasVoice(j) &amp;&amp; m-&gt;isOnlyRests(j)))</a>
<a name="ln2775">                                          dTracks[full] = j;</a>
<a name="ln2776">                                    else {</a>
<a name="ln2777">                                          dTracks[full] = -1;</a>
<a name="ln2778">                                          break;</a>
<a name="ln2779">                                          }</a>
<a name="ln2780">                                    }</a>
<a name="ln2781">                              if (dTracks[full] != -1)</a>
<a name="ln2782">                                    break;</a>
<a name="ln2783">                              }</a>
<a name="ln2784">                        full++;</a>
<a name="ln2785">                        }</a>
<a name="ln2786">                  }</a>
<a name="ln2787"> </a>
<a name="ln2788">            for (int i = srcTrack, j = 0; i &lt; lastStaff * VOICES &amp;&amp; j &lt; VOICES ; i += VOICES, j++) {</a>
<a name="ln2789">                  int strack = sTracks[j % VOICES];</a>
<a name="ln2790">                  int dtrack = dTracks[j % VOICES];</a>
<a name="ln2791">                  if (strack != -1 &amp;&amp; strack != dtrack &amp;&amp; dtrack != -1)</a>
<a name="ln2792">                        undo(new CloneVoice(startSegment, lTick, startSegment, strack, dtrack, -1, false));</a>
<a name="ln2793">                  }</a>
<a name="ln2794">            }</a>
<a name="ln2795"> </a>
<a name="ln2796">      // select exploded region</a>
<a name="ln2797">      deselectAll();</a>
<a name="ln2798">      select(startMeasure, SelectType::RANGE, srcStaff);</a>
<a name="ln2799">      select(endMeasure, SelectType::RANGE, lastStaff - 1);</a>
<a name="ln2800">      }</a>
<a name="ln2801"> </a>
<a name="ln2802">//---------------------------------------------------------</a>
<a name="ln2803">//   cmdImplode</a>
<a name="ln2804">///   implodes contents of selected staves into top staff</a>
<a name="ln2805">///   for single staff, merge voices</a>
<a name="ln2806">//---------------------------------------------------------</a>
<a name="ln2807"> </a>
<a name="ln2808">void Score::cmdImplode()</a>
<a name="ln2809">      {</a>
<a name="ln2810">      if (!selection().isRange())</a>
<a name="ln2811">            return;</a>
<a name="ln2812"> </a>
<a name="ln2813">      int dstStaff   = selection().staffStart();</a>
<a name="ln2814">      int endStaff   = selection().staffEnd();</a>
<a name="ln2815">      int dstTrack   = dstStaff * VOICES;</a>
<a name="ln2816">      int startTrack = dstStaff * VOICES;</a>
<a name="ln2817">      int endTrack   = endStaff * VOICES;</a>
<a name="ln2818">      Segment* startSegment = selection().startSegment();</a>
<a name="ln2819">      Segment* endSegment = selection().endSegment();</a>
<a name="ln2820">      Measure* startMeasure = startSegment-&gt;measure();</a>
<a name="ln2821">      Measure* endMeasure = endSegment ? endSegment-&gt;measure() : lastMeasure();</a>
<a name="ln2822">      Fraction startTick       = startSegment-&gt;tick();</a>
<a name="ln2823">      Fraction endTick         = endSegment ? endSegment-&gt;tick() : lastMeasure()-&gt;endTick();</a>
<a name="ln2824">      Q_ASSERT(startMeasure &amp;&amp; endMeasure);</a>
<a name="ln2825"> </a>
<a name="ln2826">      // if single staff selected, combine voices</a>
<a name="ln2827">      // otherwise combine staves</a>
<a name="ln2828">      if (dstStaff == endStaff - 1) {</a>
<a name="ln2829"> </a>
<a name="ln2830">            // loop through segments adding notes to chord on top staff</a>
<a name="ln2831">            for (Segment* s = startSegment; s &amp;&amp; s != endSegment; s = s-&gt;next1()) {</a>
<a name="ln2832">                  if (!s-&gt;isChordRestType())</a>
<a name="ln2833">                        continue;</a>
<a name="ln2834">                  Element* dst = s-&gt;element(dstTrack);</a>
<a name="ln2835">                  if (dst &amp;&amp; dst-&gt;isChord()) {</a>
<a name="ln2836">                        Chord* dstChord = toChord(dst);</a>
<a name="ln2837">                        // see if we are tying in to this chord</a>
<a name="ln2838">                        Chord* tied = 0;</a>
<a name="ln2839">                        for (Note* n : dstChord-&gt;notes()) {</a>
<a name="ln2840">                              if (n-&gt;tieBack()) {</a>
<a name="ln2841">                                    tied = n-&gt;tieBack()-&gt;startNote()-&gt;chord();</a>
<a name="ln2842">                                    break;</a>
<a name="ln2843">                                    }</a>
<a name="ln2844">                              }</a>
<a name="ln2845">                        // loop through each subsequent staff (or track within staff)</a>
<a name="ln2846">                        // looking for notes to add</a>
<a name="ln2847">                        for (int srcTrack = startTrack + 1; srcTrack &lt; endTrack; srcTrack++) {</a>
<a name="ln2848">                              Element* src = s-&gt;element(srcTrack);</a>
<a name="ln2849">                              if (src &amp;&amp; src-&gt;isChord()) {</a>
<a name="ln2850">                                    Chord* srcChord = toChord(src);</a>
<a name="ln2851">                                    // when combining voices, skip if not same duration</a>
<a name="ln2852">                                    if (srcChord-&gt;ticks() != dstChord-&gt;ticks())</a>
<a name="ln2853">                                          continue;</a>
<a name="ln2854">                                    // add notes</a>
<a name="ln2855">                                    for (Note* n : srcChord-&gt;notes()) {</a>
<a name="ln2856">                                          NoteVal nv(n-&gt;pitch());</a>
<a name="ln2857">                                          nv.tpc1 = n-&gt;tpc1();</a>
<a name="ln2858">                                          // skip duplicates</a>
<a name="ln2859">                                          if (dstChord-&gt;findNote(nv.pitch))</a>
<a name="ln2860">                                                continue;</a>
<a name="ln2861">                                          Note* nn = addNote(dstChord, nv);</a>
<a name="ln2862">                                          // add tie to this note if original chord was tied</a>
<a name="ln2863">                                          if (tied) {</a>
<a name="ln2864">                                                // find note to tie to</a>
<a name="ln2865">                                                for (Note *tn : tied-&gt;notes()) {</a>
<a name="ln2866">                                                      if (nn-&gt;pitch() == tn-&gt;pitch() &amp;&amp; nn-&gt;tpc() == tn-&gt;tpc() &amp;&amp; !tn-&gt;tieFor()) {</a>
<a name="ln2867">                                                            // found note to tie</a>
<a name="ln2868">                                                            Tie* tie = new Tie(this);</a>
<a name="ln2869">                                                            tie-&gt;setStartNote(tn);</a>
<a name="ln2870">                                                            tie-&gt;setEndNote(nn);</a>
<a name="ln2871">                                                            tie-&gt;setTrack(tn-&gt;track());</a>
<a name="ln2872">                                                            undoAddElement(tie);</a>
<a name="ln2873">                                                            }</a>
<a name="ln2874">                                                      }</a>
<a name="ln2875">                                                }</a>
<a name="ln2876">                                          }</a>
<a name="ln2877">                                    }</a>
<a name="ln2878">                              // delete chordrest from source track if possible</a>
<a name="ln2879">                              if (src &amp;&amp; src-&gt;voice())</a>
<a name="ln2880">                                    undoRemoveElement(src);</a>
<a name="ln2881">                              }</a>
<a name="ln2882">                        }</a>
<a name="ln2883">                  // TODO - use first voice that actually has a note and implode remaining voices on it?</a>
<a name="ln2884">                  // see https://musescore.org/en/node/174111</a>
<a name="ln2885">                  else if (dst) {</a>
<a name="ln2886">                        // destination track has something, but it isn't a chord</a>
<a name="ln2887">                        // remove rests from other voices if in &quot;voice mode&quot;</a>
<a name="ln2888">                        for (int i = 1; i &lt; VOICES; ++i) {</a>
<a name="ln2889">                              Element* e = s-&gt;element(dstTrack + i);</a>
<a name="ln2890">                              if (e &amp;&amp; e-&gt;isRest())</a>
<a name="ln2891">                                    undoRemoveElement(e);</a>
<a name="ln2892">                              }</a>
<a name="ln2893">                        }</a>
<a name="ln2894">                  }</a>
<a name="ln2895">            // delete orphaned spanners (TODO: figure out solution to reconnect orphaned spanners to their cloned notes)</a>
<a name="ln2896">            checkSpanner(startTick, endTick);</a>
<a name="ln2897">            }</a>
<a name="ln2898">      else {</a>
<a name="ln2899">            int tracks[VOICES];</a>
<a name="ln2900">            for (int i = 0; i &lt; VOICES; i++)</a>
<a name="ln2901">                  tracks[i] = -1;</a>
<a name="ln2902">            int full = 0;</a>
<a name="ln2903"> </a>
<a name="ln2904">            // identify tracks to combine, storing the source track numbers in tracks[]</a>
<a name="ln2905">            // first four non-empty tracks to win</a>
<a name="ln2906">            for (int track = startTrack; track &lt; endTrack &amp;&amp; full &lt; VOICES; ++track) {</a>
<a name="ln2907">                  Measure* m = startMeasure;</a>
<a name="ln2908">                  do {</a>
<a name="ln2909">                        if (m-&gt;hasVoice(track) &amp;&amp; !m-&gt;isOnlyRests(track)) {</a>
<a name="ln2910">                              tracks[full++] = track;</a>
<a name="ln2911">                              break;</a>
<a name="ln2912">                              }</a>
<a name="ln2913">                        } while ((m != endMeasure) &amp;&amp; (m = m-&gt;nextMeasure()));</a>
<a name="ln2914">                  }</a>
<a name="ln2915"> </a>
<a name="ln2916">            // clone source tracks into destination</a>
<a name="ln2917">            for (int i = dstTrack; i &lt; dstTrack + VOICES; i++) {</a>
<a name="ln2918">                  int strack = tracks[i % VOICES];</a>
<a name="ln2919">                  if (strack != -1 &amp;&amp; strack != i) {</a>
<a name="ln2920">                        undo( new CloneVoice(startSegment, endTick, startSegment, strack, i, i, false));</a>
<a name="ln2921">                        }</a>
<a name="ln2922">                  }</a>
<a name="ln2923">            }</a>
<a name="ln2924"> </a>
<a name="ln2925">      // select destination staff only</a>
<a name="ln2926">      deselectAll();</a>
<a name="ln2927">      select(startMeasure, SelectType::RANGE, dstStaff);</a>
<a name="ln2928">      select(endMeasure, SelectType::RANGE, dstStaff);</a>
<a name="ln2929">      }</a>
<a name="ln2930"> </a>
<a name="ln2931">//---------------------------------------------------------</a>
<a name="ln2932">//   cmdSlashFill</a>
<a name="ln2933">///   fills selected region with slashes</a>
<a name="ln2934">//---------------------------------------------------------</a>
<a name="ln2935"> </a>
<a name="ln2936">void Score::cmdSlashFill()</a>
<a name="ln2937">      {</a>
<a name="ln2938">      int startStaff = selection().staffStart();</a>
<a name="ln2939">      int endStaff = selection().staffEnd();</a>
<a name="ln2940">      Segment* startSegment = selection().startSegment();</a>
<a name="ln2941">      if (!startSegment) // empty score?</a>
<a name="ln2942">            return;</a>
<a name="ln2943"> </a>
<a name="ln2944">      Segment* endSegment = selection().endSegment();</a>
<a name="ln2945"> </a>
<a name="ln2946">      // operate on measures underlying mmrests</a>
<a name="ln2947">      if (startSegment &amp;&amp; startSegment-&gt;measure() &amp;&amp; startSegment-&gt;measure()-&gt;isMMRest())</a>
<a name="ln2948">            startSegment = startSegment-&gt;measure()-&gt;mmRestFirst()-&gt;first();</a>
<a name="ln2949">      if (endSegment &amp;&amp; endSegment-&gt;measure() &amp;&amp; endSegment-&gt;measure()-&gt;isMMRest())</a>
<a name="ln2950">            endSegment = endSegment-&gt;measure()-&gt;mmRestLast()-&gt;last();</a>
<a name="ln2951"> </a>
<a name="ln2952">      Fraction endTick = endSegment ? endSegment-&gt;tick() : lastSegment()-&gt;tick() + Fraction::fromTicks(1);</a>
<a name="ln2953">      Chord* firstSlash = 0;</a>
<a name="ln2954">      Chord* lastSlash = 0;</a>
<a name="ln2955"> </a>
<a name="ln2956">      // loop through staves in selection</a>
<a name="ln2957">      for (int staffIdx = startStaff; staffIdx &lt; endStaff; ++staffIdx) {</a>
<a name="ln2958">            int track = staffIdx * VOICES;</a>
<a name="ln2959">            int voice = -1;</a>
<a name="ln2960">            // loop through segments adding slashes on each beat</a>
<a name="ln2961">            for (Segment* s = startSegment; s &amp;&amp; s-&gt;tick() &lt; endTick; s = s-&gt;next1()) {</a>
<a name="ln2962">                  if (s-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln2963">                        continue;</a>
<a name="ln2964">                  // determine beat type based on time signature</a>
<a name="ln2965">                  int d = s-&gt;measure()-&gt;timesig().denominator();</a>
<a name="ln2966">                  int n = (d &gt; 4 &amp;&amp; s-&gt;measure()-&gt;timesig().numerator() % 3 == 0) ? 3 : 1;</a>
<a name="ln2967">                  Fraction f(n, d);</a>
<a name="ln2968">                  // skip over any leading segments before next (first) beat</a>
<a name="ln2969">                  if (s-&gt;rtick().ticks() % f.ticks())</a>
<a name="ln2970">                        continue;</a>
<a name="ln2971">                  // determine voice to use - first available voice for this measure / staff</a>
<a name="ln2972">                  if (voice == -1 || s-&gt;rtick().isZero()) {</a>
<a name="ln2973">                        bool needGap[VOICES];</a>
<a name="ln2974">                        for (voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln2975">                              needGap[voice] = false;</a>
<a name="ln2976">                              ChordRest* cr = toChordRest(s-&gt;element(track + voice));</a>
<a name="ln2977">                              // no chordrest == treat as ordinary rest for purpose of determining availbility of voice</a>
<a name="ln2978">                              // but also, we will need to make a gap for this voice if we do end up choosing it</a>
<a name="ln2979">                              if (!cr)</a>
<a name="ln2980">                                    needGap[voice] = true;</a>
<a name="ln2981">                              // chord == keep looking for an available voice</a>
<a name="ln2982">                              else if (cr-&gt;type() == ElementType::CHORD)</a>
<a name="ln2983">                                    continue;</a>
<a name="ln2984">                              // full measure rest == OK to use voice</a>
<a name="ln2985">                              else if (cr-&gt;durationType() == TDuration::DurationType::V_MEASURE)</a>
<a name="ln2986">                                    break;</a>
<a name="ln2987">                              // no chordrest or ordinary rest == OK to use voice</a>
<a name="ln2988">                              // if there are nothing but rests for duration of measure / selection</a>
<a name="ln2989">                              bool ok = true;</a>
<a name="ln2990">                              for (Segment* ns = s-&gt;next(SegmentType::ChordRest); ns &amp;&amp; ns != endSegment; ns = ns-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln2991">                                    ChordRest* ncr = toChordRest(ns-&gt;element(track + voice));</a>
<a name="ln2992">                                    if (ncr &amp;&amp; ncr-&gt;type() == ElementType::CHORD) {</a>
<a name="ln2993">                                          ok = false;</a>
<a name="ln2994">                                          break;</a>
<a name="ln2995">                                          }</a>
<a name="ln2996">                                    }</a>
<a name="ln2997">                              if (ok)</a>
<a name="ln2998">                                    break;</a>
<a name="ln2999">                              }</a>
<a name="ln3000">                        // no available voices, just use voice 0</a>
<a name="ln3001">                        if (voice == VOICES)</a>
<a name="ln3002">                              voice = 0;</a>
<a name="ln3003">                        // no cr was found in segment for this voice, so make gap</a>
<a name="ln3004">                        if (needGap[voice])</a>
<a name="ln3005">                              makeGapVoice(s, track + voice, f, s-&gt;tick());</a>
<a name="ln3006">                        }</a>
<a name="ln3007">                  // construct note</a>
<a name="ln3008">                  int line = 0;</a>
<a name="ln3009">                  bool error = false;</a>
<a name="ln3010">                  NoteVal nv;</a>
<a name="ln3011">                  if (staff(staffIdx)-&gt;staffType(s-&gt;tick())-&gt;group() == StaffGroup::TAB)</a>
<a name="ln3012">                        line = staff(staffIdx)-&gt;lines(s-&gt;tick()) / 2;</a>
<a name="ln3013">                  else</a>
<a name="ln3014">                        line = staff(staffIdx)-&gt;middleLine(s-&gt;tick());     // staff(staffIdx)-&gt;lines() - 1;</a>
<a name="ln3015">                  if (staff(staffIdx)-&gt;staffType(s-&gt;tick())-&gt;group() == StaffGroup::PERCUSSION) {</a>
<a name="ln3016">                        nv.pitch = 0;</a>
<a name="ln3017">                        nv.headGroup = NoteHead::Group::HEAD_SLASH;</a>
<a name="ln3018">                        }</a>
<a name="ln3019">                  else {</a>
<a name="ln3020">                        Position p;</a>
<a name="ln3021">                        p.segment = s;</a>
<a name="ln3022">                        p.staffIdx = staffIdx;</a>
<a name="ln3023">                        p.line = line;</a>
<a name="ln3024">                        p.fret = FRET_NONE;</a>
<a name="ln3025">                        _is.setRest(false);     // needed for tab</a>
<a name="ln3026">                        nv = noteValForPosition(p, AccidentalType::NONE, error);</a>
<a name="ln3027">                        }</a>
<a name="ln3028">                  if (error)</a>
<a name="ln3029">                        continue;</a>
<a name="ln3030">                  // insert &amp; turn into slash</a>
<a name="ln3031">                  s = setNoteRest(s, track + voice, nv, f);</a>
<a name="ln3032">                  Chord* c = toChord(s-&gt;element(track + voice));</a>
<a name="ln3033">                  if (c-&gt;links()) {</a>
<a name="ln3034">                        for (ScoreElement* e : *c-&gt;links()) {</a>
<a name="ln3035">                              Chord* lc = toChord(e);</a>
<a name="ln3036">                              lc-&gt;setSlash(true, true);</a>
<a name="ln3037">                              }</a>
<a name="ln3038">                        }</a>
<a name="ln3039">                  else</a>
<a name="ln3040">                        c-&gt;setSlash(true, true);</a>
<a name="ln3041">                  lastSlash = c;</a>
<a name="ln3042">                  if (!firstSlash)</a>
<a name="ln3043">                        firstSlash = c;</a>
<a name="ln3044">                  }</a>
<a name="ln3045">            }</a>
<a name="ln3046"> </a>
<a name="ln3047">      // re-select the slashes</a>
<a name="ln3048">      deselectAll();</a>
<a name="ln3049">      if (firstSlash &amp;&amp; lastSlash) {</a>
<a name="ln3050">            select(firstSlash, SelectType::RANGE);</a>
<a name="ln3051">            select(lastSlash, SelectType::RANGE);</a>
<a name="ln3052">            }</a>
<a name="ln3053">      }</a>
<a name="ln3054"> </a>
<a name="ln3055">//---------------------------------------------------------</a>
<a name="ln3056">//   cmdSlashRhythm</a>
<a name="ln3057">///   converts rhythms in selected region to slashes</a>
<a name="ln3058">//---------------------------------------------------------</a>
<a name="ln3059"> </a>
<a name="ln3060">void Score::cmdSlashRhythm()</a>
<a name="ln3061">      {</a>
<a name="ln3062">      QList&lt;Chord*&gt; chords;</a>
<a name="ln3063">      // loop through all notes in selection</a>
<a name="ln3064">      foreach (Element* e, selection().elements()) {</a>
<a name="ln3065">            if (e-&gt;voice() &gt;= 2 &amp;&amp; e-&gt;isRest()) {</a>
<a name="ln3066">                  Rest* r = toRest(e);</a>
<a name="ln3067">                  if (r-&gt;links()) {</a>
<a name="ln3068">                        for (ScoreElement* se : *r-&gt;links()) {</a>
<a name="ln3069">                              Rest* lr = toRest(se);</a>
<a name="ln3070">                              lr-&gt;setAccent(!lr-&gt;accent());</a>
<a name="ln3071">                              }</a>
<a name="ln3072">                        }</a>
<a name="ln3073">                  else</a>
<a name="ln3074">                        r-&gt;setAccent(!r-&gt;accent());</a>
<a name="ln3075">                  continue;</a>
<a name="ln3076">                  }</a>
<a name="ln3077">            else if (e-&gt;isNote()) {</a>
<a name="ln3078">                  Note* n = toNote(e);</a>
<a name="ln3079">                  if (n-&gt;noteType() != NoteType::NORMAL)</a>
<a name="ln3080">                        continue;</a>
<a name="ln3081">                  Chord* c = n-&gt;chord();</a>
<a name="ln3082">                  // check for duplicates (chords with multiple notes)</a>
<a name="ln3083">                  if (chords.contains(c))</a>
<a name="ln3084">                        continue;</a>
<a name="ln3085">                  chords.append(c);</a>
<a name="ln3086">                  // toggle slash setting</a>
<a name="ln3087">                  if (c-&gt;links()) {</a>
<a name="ln3088">                        for (ScoreElement* se : *c-&gt;links()) {</a>
<a name="ln3089">                              Chord* lc = toChord(se);</a>
<a name="ln3090">                              lc-&gt;setSlash(!lc-&gt;slash(), false);</a>
<a name="ln3091">                              }</a>
<a name="ln3092">                        }</a>
<a name="ln3093">                  else</a>
<a name="ln3094">                        c-&gt;setSlash(!c-&gt;slash(), false);</a>
<a name="ln3095">                  }</a>
<a name="ln3096">            }</a>
<a name="ln3097">      }</a>
<a name="ln3098"> </a>
<a name="ln3099">//---------------------------------------------------------</a>
<a name="ln3100">//   cmdResequenceRehearsalMarks</a>
<a name="ln3101">///   resequences rehearsal marks within a range selection</a>
<a name="ln3102">///   or, if nothing is selected, the entire score</a>
<a name="ln3103">//---------------------------------------------------------</a>
<a name="ln3104"> </a>
<a name="ln3105">void Score::cmdResequenceRehearsalMarks()</a>
<a name="ln3106">      {</a>
<a name="ln3107">      bool noSelection = !selection().isRange();</a>
<a name="ln3108"> </a>
<a name="ln3109">      if (noSelection)</a>
<a name="ln3110">            cmdSelectAll();</a>
<a name="ln3111">      else if (!selection().isRange())</a>
<a name="ln3112">            return;</a>
<a name="ln3113"> </a>
<a name="ln3114">      RehearsalMark* last = 0;</a>
<a name="ln3115">      for (Segment* s = selection().startSegment(); s &amp;&amp; s != selection().endSegment(); s = s-&gt;next1()) {</a>
<a name="ln3116">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln3117">                  if (e-&gt;type() == ElementType::REHEARSAL_MARK) {</a>
<a name="ln3118">                        RehearsalMark* rm = toRehearsalMark(e);</a>
<a name="ln3119">                        if (last) {</a>
<a name="ln3120">                              QString rmText = nextRehearsalMarkText(last, rm);</a>
<a name="ln3121">                              for (ScoreElement* le : rm-&gt;linkList())</a>
<a name="ln3122">                                    le-&gt;undoChangeProperty(Pid::TEXT, rmText);</a>
<a name="ln3123">                              }</a>
<a name="ln3124">                        last = rm;</a>
<a name="ln3125">                        }</a>
<a name="ln3126">                  }</a>
<a name="ln3127">            }</a>
<a name="ln3128"> </a>
<a name="ln3129">      if (noSelection)</a>
<a name="ln3130">            deselectAll();</a>
<a name="ln3131">      }</a>
<a name="ln3132"> </a>
<a name="ln3133">//---------------------------------------------------------</a>
<a name="ln3134">//   addRemoveBreaks</a>
<a name="ln3135">//    interval lock</a>
<a name="ln3136">//    0        false    remove all linebreaks</a>
<a name="ln3137">//    &gt; 0      false    add linebreak every interval measure</a>
<a name="ln3138">//    d.c.     true     add linebreak at every system end</a>
<a name="ln3139">//---------------------------------------------------------</a>
<a name="ln3140"> </a>
<a name="ln3141">void Score::addRemoveBreaks(int interval, bool lock)</a>
<a name="ln3142">      {</a>
<a name="ln3143">      Segment* startSegment = selection().startSegment();</a>
<a name="ln3144">      if (!startSegment) // empty score?</a>
<a name="ln3145">            return;</a>
<a name="ln3146">      Segment* endSegment   = selection().endSegment();</a>
<a name="ln3147">      Measure* startMeasure = startSegment-&gt;measure();</a>
<a name="ln3148">      Measure* endMeasure   = endSegment ? endSegment-&gt;measure() : lastMeasureMM();</a>
<a name="ln3149">      Measure* lastMeasure  = lastMeasureMM();</a>
<a name="ln3150"> </a>
<a name="ln3151">      // loop through measures in selection</a>
<a name="ln3152">      // count mmrests as a single measure</a>
<a name="ln3153">      int count = 0;</a>
<a name="ln3154">      for (Measure* mm = startMeasure; mm; mm = mm-&gt;nextMeasureMM()) {</a>
<a name="ln3155"> </a>
<a name="ln3156">            // even though we are counting mmrests as a single measure,</a>
<a name="ln3157">            // we need to find last real measure within mmrest for the actual break</a>
<a name="ln3158">            Measure* m = mm-&gt;isMMRest() ? mm-&gt;mmRestLast() : mm;</a>
<a name="ln3159"> </a>
<a name="ln3160">            if (lock) {</a>
<a name="ln3161">                  // skip last measure of score</a>
<a name="ln3162">                  if (mm == lastMeasure)</a>
<a name="ln3163">                        break;</a>
<a name="ln3164">                  // skip if it already has a break</a>
<a name="ln3165">                  if (m-&gt;lineBreak() || m-&gt;pageBreak())</a>
<a name="ln3166">                        continue;</a>
<a name="ln3167">                  // add break if last measure of system</a>
<a name="ln3168">                  if (mm-&gt;system() &amp;&amp; mm-&gt;system()-&gt;lastMeasure() == mm)</a>
<a name="ln3169">                        m-&gt;undoSetLineBreak(true);</a>
<a name="ln3170">                  }</a>
<a name="ln3171">            else {</a>
<a name="ln3172">                  if (interval == 0) {</a>
<a name="ln3173">                        // remove line break if present</a>
<a name="ln3174">                        if (m-&gt;lineBreak())</a>
<a name="ln3175">                              m-&gt;undoSetLineBreak(false);</a>
<a name="ln3176">                        }</a>
<a name="ln3177">                  else {</a>
<a name="ln3178">                        if (++count == interval) {</a>
<a name="ln3179">                              // skip last measure of score</a>
<a name="ln3180">                              if (mm == lastMeasure)</a>
<a name="ln3181">                                    break;</a>
<a name="ln3182">                              // found place for break; add if not already one present</a>
<a name="ln3183">                              if (!(m-&gt;lineBreak() || m-&gt;pageBreak()))</a>
<a name="ln3184">                                    m-&gt;undoSetLineBreak(true);</a>
<a name="ln3185">                              // reset count</a>
<a name="ln3186">                              count = 0;</a>
<a name="ln3187">                              }</a>
<a name="ln3188">                        else if (m-&gt;lineBreak()) {</a>
<a name="ln3189">                              // remove line break if present in wrong place</a>
<a name="ln3190">                              m-&gt;undoSetLineBreak(false);</a>
<a name="ln3191">                              }</a>
<a name="ln3192">                        }</a>
<a name="ln3193">                  }</a>
<a name="ln3194"> </a>
<a name="ln3195">            if (mm == endMeasure)</a>
<a name="ln3196">                  break;</a>
<a name="ln3197">            }</a>
<a name="ln3198"> </a>
<a name="ln3199">      }</a>
<a name="ln3200"> </a>
<a name="ln3201">//---------------------------------------------------------</a>
<a name="ln3202">//   cmdRemoveEmptyTrailingMeasures</a>
<a name="ln3203">//---------------------------------------------------------</a>
<a name="ln3204"> </a>
<a name="ln3205">void Score::cmdRemoveEmptyTrailingMeasures()</a>
<a name="ln3206">      {</a>
<a name="ln3207">      MasterScore* score = masterScore();</a>
<a name="ln3208">      Measure* firstMeasure;</a>
<a name="ln3209">      Measure* lastMeasure = score-&gt;lastMeasure();</a>
<a name="ln3210">      if (!lastMeasure || !lastMeasure-&gt;isFullMeasureRest())</a>
<a name="ln3211">            return;</a>
<a name="ln3212">      firstMeasure = lastMeasure;</a>
<a name="ln3213">      for (firstMeasure = lastMeasure;;) {</a>
<a name="ln3214">            Measure* m = firstMeasure-&gt;prevMeasure();</a>
<a name="ln3215">            if (!m || !m-&gt;isFullMeasureRest())</a>
<a name="ln3216">                  break;</a>
<a name="ln3217">            firstMeasure = m;</a>
<a name="ln3218">            }</a>
<a name="ln3219">      deleteMeasures(firstMeasure, lastMeasure);</a>
<a name="ln3220">      }</a>
<a name="ln3221"> </a>
<a name="ln3222">//---------------------------------------------------------</a>
<a name="ln3223">//   cmdPitchUp</a>
<a name="ln3224">//---------------------------------------------------------</a>
<a name="ln3225"> </a>
<a name="ln3226">void Score::cmdPitchUp()</a>
<a name="ln3227">      {</a>
<a name="ln3228">      Element* el = selection().element();</a>
<a name="ln3229">      if (el &amp;&amp; el-&gt;isLyrics())</a>
<a name="ln3230">            cmdMoveLyrics(toLyrics(el), Direction::UP);</a>
<a name="ln3231">      else if (el &amp;&amp; (el-&gt;isArticulation() || el-&gt;isTextBase()))</a>
<a name="ln3232">            el-&gt;undoChangeProperty(Pid::OFFSET, el-&gt;offset() + QPointF(0.0, -MScore::nudgeStep * el-&gt;spatium()), PropertyFlags::UNSTYLED);</a>
<a name="ln3233">      else if (el &amp;&amp; el-&gt;isRest())</a>
<a name="ln3234">            cmdMoveRest(toRest(el), Direction::UP);</a>
<a name="ln3235">      else</a>
<a name="ln3236">            upDown(true, UpDownMode::CHROMATIC);</a>
<a name="ln3237">      }</a>
<a name="ln3238"> </a>
<a name="ln3239">//---------------------------------------------------------</a>
<a name="ln3240">//   cmdPitchDown</a>
<a name="ln3241">//---------------------------------------------------------</a>
<a name="ln3242"> </a>
<a name="ln3243">void Score::cmdPitchDown()</a>
<a name="ln3244">      {</a>
<a name="ln3245">      Element* el = selection().element();</a>
<a name="ln3246">      if (el &amp;&amp; el-&gt;isLyrics())</a>
<a name="ln3247">            cmdMoveLyrics(toLyrics(el), Direction::DOWN);</a>
<a name="ln3248">      else if (el &amp;&amp; (el-&gt;isArticulation() || el-&gt;isTextBase()))</a>
<a name="ln3249">            el-&gt;undoChangeProperty(Pid::OFFSET, el-&gt;offset() + QPointF(0.0, MScore::nudgeStep * el-&gt;spatium()), PropertyFlags::UNSTYLED);</a>
<a name="ln3250">      else if (el &amp;&amp; el-&gt;isRest())</a>
<a name="ln3251">            cmdMoveRest(toRest(el), Direction::DOWN);</a>
<a name="ln3252">      else</a>
<a name="ln3253">            upDown(false, UpDownMode::CHROMATIC);</a>
<a name="ln3254">      }</a>
<a name="ln3255"> </a>
<a name="ln3256">//---------------------------------------------------------</a>
<a name="ln3257">//   cmdTimeDelete</a>
<a name="ln3258">//---------------------------------------------------------</a>
<a name="ln3259"> </a>
<a name="ln3260">void Score::cmdTimeDelete()</a>
<a name="ln3261">      {</a>
<a name="ln3262">      Element* e = selection().element();</a>
<a name="ln3263">      if (e &amp;&amp; e-&gt;isBarLine() &amp;&amp; toBarLine(e)-&gt;segment()-&gt;isEndBarLineType()) {</a>
<a name="ln3264">            Measure* m = toBarLine(e)-&gt;segment()-&gt;measure();</a>
<a name="ln3265">            cmdJoinMeasure(m, m-&gt;nextMeasure());</a>
<a name="ln3266">            }</a>
<a name="ln3267">      else {</a>
<a name="ln3268">            if (_is.insertMode())</a>
<a name="ln3269">                  globalTimeDelete();</a>
<a name="ln3270">            else</a>
<a name="ln3271">                  localTimeDelete();</a>
<a name="ln3272">            }</a>
<a name="ln3273">      }</a>
<a name="ln3274"> </a>
<a name="ln3275">//---------------------------------------------------------</a>
<a name="ln3276">//   cmdPitchUpOctave</a>
<a name="ln3277">//---------------------------------------------------------</a>
<a name="ln3278"> </a>
<a name="ln3279">void Score::cmdPitchUpOctave()</a>
<a name="ln3280">      {</a>
<a name="ln3281">      Element* el = selection().element();</a>
<a name="ln3282">      if (el &amp;&amp; (el-&gt;isArticulation() || el-&gt;isTextBase()))</a>
<a name="ln3283">            el-&gt;undoChangeProperty(Pid::OFFSET, el-&gt;offset() + QPointF(0.0, -MScore::nudgeStep10 * el-&gt;spatium()), PropertyFlags::UNSTYLED);</a>
<a name="ln3284">      else</a>
<a name="ln3285">            upDown(true, UpDownMode::OCTAVE);</a>
<a name="ln3286">      }</a>
<a name="ln3287"> </a>
<a name="ln3288">//---------------------------------------------------------</a>
<a name="ln3289">//   cmdPitchDownOctave</a>
<a name="ln3290">//---------------------------------------------------------</a>
<a name="ln3291"> </a>
<a name="ln3292">void Score::cmdPitchDownOctave()</a>
<a name="ln3293">      {</a>
<a name="ln3294">      Element* el = selection().element();</a>
<a name="ln3295">      if (el &amp;&amp; (el-&gt;isArticulation() || el-&gt;isTextBase()))</a>
<a name="ln3296">            el-&gt;undoChangeProperty(Pid::OFFSET, el-&gt;offset() + QPointF(0.0, MScore::nudgeStep10 * el-&gt;spatium()), PropertyFlags::UNSTYLED);</a>
<a name="ln3297">      else</a>
<a name="ln3298">            upDown(false, UpDownMode::OCTAVE);</a>
<a name="ln3299">      }</a>
<a name="ln3300"> </a>
<a name="ln3301">//---------------------------------------------------------</a>
<a name="ln3302">//   cmdPadNoteInclreaseTAB</a>
<a name="ln3303">//---------------------------------------------------------</a>
<a name="ln3304"> </a>
<a name="ln3305">void Score::cmdPadNoteIncreaseTAB(const EditData&amp; ed)</a>
<a name="ln3306">      {</a>
<a name="ln3307">      switch (_is.duration().type() ) {</a>
<a name="ln3308">// cycle back from longest to shortest?</a>
<a name="ln3309">//          case TDuration::V_LONG:</a>
<a name="ln3310">//                padToggle(Pad::NOTE128, ed);</a>
<a name="ln3311">//                break;</a>
<a name="ln3312">            case TDuration::DurationType::V_BREVE:</a>
<a name="ln3313">                  padToggle(Pad::NOTE00, ed);</a>
<a name="ln3314">                  break;</a>
<a name="ln3315">            case TDuration::DurationType::V_WHOLE:</a>
<a name="ln3316">                  padToggle(Pad::NOTE0, ed);</a>
<a name="ln3317">                  break;</a>
<a name="ln3318">            case TDuration::DurationType::V_HALF:</a>
<a name="ln3319">                  padToggle(Pad::NOTE1, ed);</a>
<a name="ln3320">                  break;</a>
<a name="ln3321">            case TDuration::DurationType::V_QUARTER:</a>
<a name="ln3322">                  padToggle(Pad::NOTE2, ed);</a>
<a name="ln3323">                  break;</a>
<a name="ln3324">            case TDuration::DurationType::V_EIGHTH:</a>
<a name="ln3325">                  padToggle(Pad::NOTE4, ed);</a>
<a name="ln3326">                  break;</a>
<a name="ln3327">            case TDuration::DurationType::V_16TH:</a>
<a name="ln3328">                  padToggle(Pad::NOTE8, ed);</a>
<a name="ln3329">                  break;</a>
<a name="ln3330">            case TDuration::DurationType::V_32ND:</a>
<a name="ln3331">                  padToggle(Pad::NOTE16, ed);</a>
<a name="ln3332">                  break;</a>
<a name="ln3333">            case TDuration::DurationType::V_64TH:</a>
<a name="ln3334">                  padToggle(Pad::NOTE32, ed);</a>
<a name="ln3335">                  break;</a>
<a name="ln3336">            case TDuration::DurationType::V_128TH:</a>
<a name="ln3337">                  padToggle(Pad::NOTE64, ed);</a>
<a name="ln3338">                  break;</a>
<a name="ln3339">            default:</a>
<a name="ln3340">                  break;</a>
<a name="ln3341">            }</a>
<a name="ln3342">      }</a>
<a name="ln3343"> </a>
<a name="ln3344">//---------------------------------------------------------</a>
<a name="ln3345">//   cmdPadNoteDecreaseTAB</a>
<a name="ln3346">//---------------------------------------------------------</a>
<a name="ln3347"> </a>
<a name="ln3348">void Score::cmdPadNoteDecreaseTAB(const EditData&amp; ed)</a>
<a name="ln3349">      {</a>
<a name="ln3350">      switch (_is.duration().type() ) {</a>
<a name="ln3351">            case TDuration::DurationType::V_LONG:</a>
<a name="ln3352">                  padToggle(Pad::NOTE0, ed);</a>
<a name="ln3353">                  break;</a>
<a name="ln3354">            case TDuration::DurationType::V_BREVE:</a>
<a name="ln3355">                  padToggle(Pad::NOTE1, ed);</a>
<a name="ln3356">                  break;</a>
<a name="ln3357">            case TDuration::DurationType::V_WHOLE:</a>
<a name="ln3358">                  padToggle(Pad::NOTE2, ed);</a>
<a name="ln3359">                  break;</a>
<a name="ln3360">            case TDuration::DurationType::V_HALF:</a>
<a name="ln3361">                  padToggle(Pad::NOTE4, ed);</a>
<a name="ln3362">                  break;</a>
<a name="ln3363">            case TDuration::DurationType::V_QUARTER:</a>
<a name="ln3364">                  padToggle(Pad::NOTE8, ed);</a>
<a name="ln3365">                  break;</a>
<a name="ln3366">            case TDuration::DurationType::V_EIGHTH:</a>
<a name="ln3367">                  padToggle(Pad::NOTE16, ed);</a>
<a name="ln3368">                  break;</a>
<a name="ln3369">            case TDuration::DurationType::V_16TH:</a>
<a name="ln3370">                  padToggle(Pad::NOTE32, ed);</a>
<a name="ln3371">                  break;</a>
<a name="ln3372">            case TDuration::DurationType::V_32ND:</a>
<a name="ln3373">                  padToggle(Pad::NOTE64, ed);</a>
<a name="ln3374">                  break;</a>
<a name="ln3375">            case TDuration::DurationType::V_64TH:</a>
<a name="ln3376">                  padToggle(Pad::NOTE128, ed);</a>
<a name="ln3377">                  break;</a>
<a name="ln3378">// cycle back from shortest to longest?</a>
<a name="ln3379">//          case TDuration::DurationType::V_128TH:</a>
<a name="ln3380">//                padToggle(Pad::NOTE00, ed);</a>
<a name="ln3381">//                break;</a>
<a name="ln3382">            default:</a>
<a name="ln3383">                  break;</a>
<a name="ln3384">            }</a>
<a name="ln3385">      }</a>
<a name="ln3386"> </a>
<a name="ln3387">//---------------------------------------------------------</a>
<a name="ln3388">//   cmdToggleLayoutBreak</a>
<a name="ln3389">//---------------------------------------------------------</a>
<a name="ln3390"> </a>
<a name="ln3391">void Score::cmdToggleLayoutBreak(LayoutBreak::Type type)</a>
<a name="ln3392">      {</a>
<a name="ln3393">      // find measure(s)</a>
<a name="ln3394">      QList&lt;MeasureBase*&gt; mbl;</a>
<a name="ln3395">      if (selection().isRange()) {</a>
<a name="ln3396">            Measure* startMeasure = nullptr;</a>
<a name="ln3397">            Measure* endMeasure = nullptr;</a>
<a name="ln3398">            if (!selection().measureRange(&amp;startMeasure, &amp;endMeasure))</a>
<a name="ln3399">                  return;</a>
<a name="ln3400">            if (!startMeasure || !endMeasure)</a>
<a name="ln3401">                  return;</a>
<a name="ln3402">#if 1</a>
<a name="ln3403">            // toggle break on the last measure of the range</a>
<a name="ln3404">            mbl.append(endMeasure);</a>
<a name="ln3405">            // if more than one measure selected,</a>
<a name="ln3406">            // also toggle break *before* the range (to try to fit selection on a single line)</a>
<a name="ln3407">            if (startMeasure != endMeasure &amp;&amp; startMeasure-&gt;prev())</a>
<a name="ln3408">                  mbl.append(startMeasure-&gt;prev());</a>
<a name="ln3409">#else</a>
<a name="ln3410">            // toggle breaks throughout the selection</a>
<a name="ln3411">            for (Measure* m = startMeasure; m; m = m-&gt;nextMeasure()) {</a>
<a name="ln3412">                  mbl.append(m);</a>
<a name="ln3413">                  if (m == endMeasure)</a>
<a name="ln3414">                        break;</a>
<a name="ln3415">                  }</a>
<a name="ln3416">#endif</a>
<a name="ln3417">            }</a>
<a name="ln3418">      else {</a>
<a name="ln3419">            MeasureBase* mb = nullptr;</a>
<a name="ln3420">            for (Element* el : selection().elements()) {</a>
<a name="ln3421">                  switch (el-&gt;type()) {</a>
<a name="ln3422">                        case ElementType::HBOX:</a>
<a name="ln3423">                        case ElementType::VBOX:</a>
<a name="ln3424">                        case ElementType::TBOX:</a>
<a name="ln3425">                              mb = toMeasureBase(el);</a>
<a name="ln3426">                              break;</a>
<a name="ln3427">                        default: {</a>
<a name="ln3428">                              // find measure</a>
<a name="ln3429">                              Measure* measure = toMeasure(el-&gt;findMeasure());</a>
<a name="ln3430">                              // for start repeat, attach break to previous measure</a>
<a name="ln3431">                              if (measure &amp;&amp; el-&gt;isBarLine()) {</a>
<a name="ln3432">                                    BarLine* bl = toBarLine(el);</a>
<a name="ln3433">                                    if (bl-&gt;barLineType() == BarLineType::START_REPEAT)</a>
<a name="ln3434">                                          measure = measure-&gt;prevMeasure();</a>
<a name="ln3435">                                    }</a>
<a name="ln3436">                              // if measure is mmrest, then propagate to last original measure</a>
<a name="ln3437">                              if (measure)</a>
<a name="ln3438">                                    mb = measure-&gt;isMMRest() ? measure-&gt;mmRestLast() : measure;</a>
<a name="ln3439">                              }</a>
<a name="ln3440">                        }</a>
<a name="ln3441">                  }</a>
<a name="ln3442">            if (mb)</a>
<a name="ln3443">                  mbl.append(mb);</a>
<a name="ln3444">            }</a>
<a name="ln3445">      // toggle the breaks</a>
<a name="ln3446">      for (MeasureBase* mb: mbl) {</a>
<a name="ln3447">            if (mb) {</a>
<a name="ln3448">                  bool val = false;</a>
<a name="ln3449">                  switch (type) {</a>
<a name="ln3450">                        case LayoutBreak::Type::LINE:</a>
<a name="ln3451">                              val = !mb-&gt;lineBreak();</a>
<a name="ln3452">                              mb-&gt;undoSetBreak(val, type);</a>
<a name="ln3453">                              // remove page break if appropriate</a>
<a name="ln3454">                              if (val &amp;&amp; mb-&gt;pageBreak())</a>
<a name="ln3455">                                    mb-&gt;undoSetBreak(false, LayoutBreak::Type::PAGE);</a>
<a name="ln3456">                              break;</a>
<a name="ln3457">                        case LayoutBreak::Type::PAGE:</a>
<a name="ln3458">                              val = !mb-&gt;pageBreak();</a>
<a name="ln3459">                              mb-&gt;undoSetBreak(val, type);</a>
<a name="ln3460">                              // remove line break if appropriate</a>
<a name="ln3461">                              if (val &amp;&amp; mb-&gt;lineBreak())</a>
<a name="ln3462">                                    mb-&gt;undoSetBreak(false, LayoutBreak::Type::LINE);</a>
<a name="ln3463">                              break;</a>
<a name="ln3464">                        case LayoutBreak::Type::SECTION:</a>
<a name="ln3465">                              val = !mb-&gt;sectionBreak();</a>
<a name="ln3466">                              mb-&gt;undoSetBreak(val, type);</a>
<a name="ln3467">                              break;</a>
<a name="ln3468">                        default:</a>
<a name="ln3469">                              break;</a>
<a name="ln3470">                        }</a>
<a name="ln3471">                  }</a>
<a name="ln3472">            }</a>
<a name="ln3473">      }</a>
<a name="ln3474"> </a>
<a name="ln3475">//---------------------------------------------------------</a>
<a name="ln3476">//   cmdToggleMmrest</a>
<a name="ln3477">//---------------------------------------------------------</a>
<a name="ln3478"> </a>
<a name="ln3479">void Score::cmdToggleMmrest()</a>
<a name="ln3480">      {</a>
<a name="ln3481">      bool val = !styleB(Sid::createMultiMeasureRests);</a>
<a name="ln3482">      deselectAll();</a>
<a name="ln3483">      undo(new ChangeStyleVal(this, Sid::createMultiMeasureRests, val));</a>
<a name="ln3484">      }</a>
<a name="ln3485"> </a>
<a name="ln3486">//---------------------------------------------------------</a>
<a name="ln3487">//   cmdToggleHideEmpty</a>
<a name="ln3488">//---------------------------------------------------------</a>
<a name="ln3489"> </a>
<a name="ln3490">void Score::cmdToggleHideEmpty()</a>
<a name="ln3491">      {</a>
<a name="ln3492">      bool val = !styleB(Sid::hideEmptyStaves);</a>
<a name="ln3493">      deselectAll();</a>
<a name="ln3494">      undo(new ChangeStyleVal(this, Sid::hideEmptyStaves, val));</a>
<a name="ln3495">      }</a>
<a name="ln3496"> </a>
<a name="ln3497">//---------------------------------------------------------</a>
<a name="ln3498">//   cmdSetVisible</a>
<a name="ln3499">//---------------------------------------------------------</a>
<a name="ln3500"> </a>
<a name="ln3501">void Score::cmdSetVisible()</a>
<a name="ln3502">      {</a>
<a name="ln3503">      for (Element* e : selection().elements())</a>
<a name="ln3504">            undo(new ChangeProperty(e, Pid::VISIBLE, true));</a>
<a name="ln3505">      }</a>
<a name="ln3506"> </a>
<a name="ln3507">//---------------------------------------------------------</a>
<a name="ln3508">//   cmdUnsetVisible</a>
<a name="ln3509">//---------------------------------------------------------</a>
<a name="ln3510"> </a>
<a name="ln3511">void Score::cmdUnsetVisible()</a>
<a name="ln3512">      {</a>
<a name="ln3513">      for (Element* e : selection().elements())</a>
<a name="ln3514">            undo(new ChangeProperty(e, Pid::VISIBLE, false));</a>
<a name="ln3515">      }</a>
<a name="ln3516"> </a>
<a name="ln3517">//---------------------------------------------------------</a>
<a name="ln3518">//   cmdAddPitch</a>
<a name="ln3519">///   insert note or add note to chord</a>
<a name="ln3520">//    c d e f g a b entered:</a>
<a name="ln3521">//---------------------------------------------------------</a>
<a name="ln3522"> </a>
<a name="ln3523">void Score::cmdAddPitch(const EditData&amp; ed, int note, bool addFlag, bool insert)</a>
<a name="ln3524">      {</a>
<a name="ln3525">      InputState&amp; is = inputState();</a>
<a name="ln3526">      if (is.track() == -1)          // invalid state</a>
<a name="ln3527">            return;</a>
<a name="ln3528">      if (is.segment() == 0) {</a>
<a name="ln3529">            qDebug(&quot;cannot enter notes here (no chord rest at current position)&quot;);</a>
<a name="ln3530">            return;</a>
<a name="ln3531">            }</a>
<a name="ln3532">      is.setRest(false);</a>
<a name="ln3533">      const Drumset* ds = is.drumset();</a>
<a name="ln3534">      int octave = 4;</a>
<a name="ln3535">      if (ds) {</a>
<a name="ln3536">            char note1 = &quot;CDEFGAB&quot;[note];</a>
<a name="ln3537">            int pitch = -1;</a>
<a name="ln3538">            int voice = 0;</a>
<a name="ln3539">            for (int i = 0; i &lt; 127; ++i) {</a>
<a name="ln3540">                  if (!ds-&gt;isValid(i))</a>
<a name="ln3541">                        continue;</a>
<a name="ln3542">                  if (ds-&gt;shortcut(i) &amp;&amp; (ds-&gt;shortcut(i) == note1)) {</a>
<a name="ln3543">                        pitch = i;</a>
<a name="ln3544">                        voice = ds-&gt;voice(i);</a>
<a name="ln3545">                        break;</a>
<a name="ln3546">                        }</a>
<a name="ln3547">                  }</a>
<a name="ln3548">            if (pitch == -1) {</a>
<a name="ln3549">                  qDebug(&quot;  shortcut %c not defined in drumset&quot;, note1);</a>
<a name="ln3550">                  return;</a>
<a name="ln3551">                  }</a>
<a name="ln3552">            is.setDrumNote(pitch);</a>
<a name="ln3553">            is.setTrack((is.track() / VOICES) * VOICES + voice);</a>
<a name="ln3554">            octave = pitch / 12;</a>
<a name="ln3555">            if (is.segment()) {</a>
<a name="ln3556">                  Segment* seg = is.segment();</a>
<a name="ln3557">                  while (seg) {</a>
<a name="ln3558">                        if (seg-&gt;element(is.track()))</a>
<a name="ln3559">                              break;</a>
<a name="ln3560">                        seg = seg-&gt;prev(SegmentType::ChordRest);</a>
<a name="ln3561">                        }</a>
<a name="ln3562">                  if (seg)</a>
<a name="ln3563">                        is.setSegment(seg);</a>
<a name="ln3564">                  else</a>
<a name="ln3565">                        is.setSegment(is.segment()-&gt;measure()-&gt;first(SegmentType::ChordRest));</a>
<a name="ln3566">                  }</a>
<a name="ln3567">            }</a>
<a name="ln3568">      else {</a>
<a name="ln3569">            static const int tab[] = { 0, 2, 4, 5, 7, 9, 11 };</a>
<a name="ln3570"> </a>
<a name="ln3571">            // if adding notes, add above the upNote of the current chord</a>
<a name="ln3572">            Element* el = selection().element();</a>
<a name="ln3573">            if (addFlag &amp;&amp; el &amp;&amp; el-&gt;isNote()) {</a>
<a name="ln3574">                  Chord* chord = toNote(el)-&gt;chord();</a>
<a name="ln3575">                  Note* n      = chord-&gt;upNote();</a>
<a name="ln3576">                  octave = n-&gt;epitch() / 12;</a>
<a name="ln3577">                  int tpc = n-&gt;tpc();</a>
<a name="ln3578">                  if (tpc == Tpc::TPC_C_BB || tpc == Tpc::TPC_C_B)</a>
<a name="ln3579">                        ++octave;</a>
<a name="ln3580">                  else if (tpc == Tpc::TPC_B_S || tpc == Tpc::TPC_B_SS)</a>
<a name="ln3581">                        --octave;</a>
<a name="ln3582">                  if (note &lt;= tpc2step(tpc))</a>
<a name="ln3583">                        octave++;</a>
<a name="ln3584">                  }</a>
<a name="ln3585">            else {</a>
<a name="ln3586">                  int curPitch = 60;</a>
<a name="ln3587">                  if (is.segment()) {</a>
<a name="ln3588">                        Staff* staff = Score::staff(is.track() / VOICES);</a>
<a name="ln3589">                        Segment* seg = is.segment()-&gt;prev1(SegmentType::ChordRest | SegmentType::Clef | SegmentType::HeaderClef);</a>
<a name="ln3590">                        while (seg) {</a>
<a name="ln3591">                              if (seg-&gt;isChordRestType()) {</a>
<a name="ln3592">                                    Element* p = seg-&gt;element(is.track());</a>
<a name="ln3593">                                    if (p &amp;&amp; p-&gt;isChord()) {</a>
<a name="ln3594">                                          curPitch = toChord(p)-&gt;downNote()-&gt;epitch();</a>
<a name="ln3595">                                          break;</a>
<a name="ln3596">                                          }</a>
<a name="ln3597">                                    }</a>
<a name="ln3598">                              else if (seg-&gt;isClefType() || seg-&gt;isHeaderClefType()) {</a>
<a name="ln3599">                                    Element* p = seg-&gt;element( (is.track() / VOICES) * VOICES); // clef on voice 1</a>
<a name="ln3600">                                    if (p &amp;&amp; p-&gt;isClef()) {</a>
<a name="ln3601">                                          Clef* clef = toClef(p);</a>
<a name="ln3602">                                          // check if it's an actual change or just a courtesy</a>
<a name="ln3603">                                          ClefType ctb = staff-&gt;clef(clef-&gt;tick() - Fraction::fromTicks(1));</a>
<a name="ln3604">                                          if (ctb != clef-&gt;clefType() || clef-&gt;tick().isZero()) {</a>
<a name="ln3605">                                                curPitch = line2pitch(4, clef-&gt;clefType(), Key::C); // C 72 for treble clef</a>
<a name="ln3606">                                                break;</a>
<a name="ln3607">                                                }</a>
<a name="ln3608">                                          }</a>
<a name="ln3609">                                    }</a>
<a name="ln3610">                              seg = seg-&gt;prev1MM(SegmentType::ChordRest | SegmentType::Clef | SegmentType::HeaderClef);</a>
<a name="ln3611">                              }</a>
<a name="ln3612">                        octave = curPitch / 12;</a>
<a name="ln3613">                        }</a>
<a name="ln3614"> </a>
<a name="ln3615">                  int delta = octave * 12 + tab[note] - curPitch;</a>
<a name="ln3616">                  if (delta &gt; 6)</a>
<a name="ln3617">                        --octave;</a>
<a name="ln3618">                  else if (delta &lt; -6)</a>
<a name="ln3619">                        ++octave;</a>
<a name="ln3620">                  }</a>
<a name="ln3621">            }</a>
<a name="ln3622">      ed.view-&gt;startNoteEntryMode();</a>
<a name="ln3623"> </a>
<a name="ln3624">      int step = octave * 7 + note;</a>
<a name="ln3625">      cmdAddPitch(step,  addFlag, insert);</a>
<a name="ln3626">      ed.view-&gt;adjustCanvasPosition(is.cr(), false);</a>
<a name="ln3627">      }</a>
<a name="ln3628"> </a>
<a name="ln3629">void Score::cmdAddPitch(int step, bool addFlag, bool insert)</a>
<a name="ln3630">      {</a>
<a name="ln3631">      insert = insert || inputState().usingNoteEntryMethod(NoteEntryMethod::TIMEWISE);</a>
<a name="ln3632">      Position pos;</a>
<a name="ln3633">      if (addFlag) {</a>
<a name="ln3634">            Element* el = selection().element();</a>
<a name="ln3635">            if (el &amp;&amp; el-&gt;isNote()) {</a>
<a name="ln3636">                  Note* selectedNote = toNote(el);</a>
<a name="ln3637">                  Chord* chord  = selectedNote-&gt;chord();</a>
<a name="ln3638">                  Segment* seg  = chord-&gt;segment();</a>
<a name="ln3639">                  pos.segment   = seg;</a>
<a name="ln3640">                  pos.staffIdx  = selectedNote-&gt;track() / VOICES;</a>
<a name="ln3641">                  ClefType clef = staff(pos.staffIdx)-&gt;clef(seg-&gt;tick());</a>
<a name="ln3642">                  pos.line      = relStep(step, clef);</a>
<a name="ln3643">                  bool error;</a>
<a name="ln3644">                  NoteVal nval = noteValForPosition(pos, _is.accidentalType(), error);</a>
<a name="ln3645">                  if (error)</a>
<a name="ln3646">                        return;</a>
<a name="ln3647">                  bool forceAccidental = false;</a>
<a name="ln3648">                  if (_is.accidentalType() != AccidentalType::NONE) {</a>
<a name="ln3649">                        NoteVal nval2 = noteValForPosition(pos, AccidentalType::NONE, error);</a>
<a name="ln3650">                        forceAccidental = (nval.pitch == nval2.pitch);</a>
<a name="ln3651">                        }</a>
<a name="ln3652">                  addNote(chord, nval, forceAccidental);</a>
<a name="ln3653">                  _is.setAccidentalType(AccidentalType::NONE);</a>
<a name="ln3654">                  return;</a>
<a name="ln3655">                  }</a>
<a name="ln3656">            }</a>
<a name="ln3657"> </a>
<a name="ln3658">      pos.segment   = inputState().segment();</a>
<a name="ln3659">      pos.staffIdx  = inputState().track() / VOICES;</a>
<a name="ln3660">      ClefType clef = staff(pos.staffIdx)-&gt;clef(pos.segment-&gt;tick());</a>
<a name="ln3661">      pos.line      = relStep(step, clef);</a>
<a name="ln3662"> </a>
<a name="ln3663">      if (inputState().usingNoteEntryMethod(NoteEntryMethod::REPITCH))</a>
<a name="ln3664">            repitchNote(pos, !addFlag);</a>
<a name="ln3665">      else {</a>
<a name="ln3666">            if (insert)</a>
<a name="ln3667">                  insertChord(pos);</a>
<a name="ln3668">            else</a>
<a name="ln3669">                  putNote(pos, !addFlag);</a>
<a name="ln3670">            }</a>
<a name="ln3671">      _is.setAccidentalType(AccidentalType::NONE);</a>
<a name="ln3672">      }</a>
<a name="ln3673"> </a>
<a name="ln3674">//---------------------------------------------------------</a>
<a name="ln3675">//   cmdToggleVisible</a>
<a name="ln3676">//---------------------------------------------------------</a>
<a name="ln3677"> </a>
<a name="ln3678">void Score::cmdToggleVisible()</a>
<a name="ln3679">      {</a>
<a name="ln3680">      QSet&lt;Element*&gt; spanners;</a>
<a name="ln3681">      for (Element* e : selection().elements()) {</a>
<a name="ln3682">            if (e-&gt;isBracket())     // ignore</a>
<a name="ln3683">                  continue;</a>
<a name="ln3684">            if (e-&gt;isNoteDot() &amp;&amp; selection().elements().contains(e-&gt;parent()))</a>
<a name="ln3685">                  // already handled in ScoreElement::undoChangeProperty(); don't toggle twice</a>
<a name="ln3686">                  continue;</a>
<a name="ln3687">            bool spannerSegment = e-&gt;isSpannerSegment();</a>
<a name="ln3688">            if (!spannerSegment || !spanners.contains(toSpannerSegment(e)-&gt;spanner()))</a>
<a name="ln3689">                  e-&gt;undoChangeProperty(Pid::VISIBLE, !e-&gt;getProperty(Pid::VISIBLE).toBool());</a>
<a name="ln3690">            if (spannerSegment)</a>
<a name="ln3691">                  spanners.insert(toSpannerSegment(e)-&gt;spanner());</a>
<a name="ln3692">            }</a>
<a name="ln3693">      }</a>
<a name="ln3694"> </a>
<a name="ln3695">//---------------------------------------------------------</a>
<a name="ln3696">//   cmdAddFret</a>
<a name="ln3697">///   insert note with given fret on current string</a>
<a name="ln3698">//---------------------------------------------------------</a>
<a name="ln3699"> </a>
<a name="ln3700">void Score::cmdAddFret(int fret)</a>
<a name="ln3701">      {</a>
<a name="ln3702">      InputState&amp; is = inputState();</a>
<a name="ln3703">      if (is.track() == -1)                     // invalid state</a>
<a name="ln3704">            return;</a>
<a name="ln3705">      if (!is.segment()) {</a>
<a name="ln3706">            qDebug(&quot;cannot enter notes here (no chord rest at current position)&quot;);</a>
<a name="ln3707">            return;</a>
<a name="ln3708">            }</a>
<a name="ln3709">      Position pos;</a>
<a name="ln3710">      pos.segment   = is.segment();</a>
<a name="ln3711">      pos.staffIdx  = is.track() / VOICES;</a>
<a name="ln3712">      pos.line      = staff(pos.staffIdx)-&gt;staffType(is.tick())-&gt;physStringToVisual(is.string());</a>
<a name="ln3713">      pos.fret      = fret;</a>
<a name="ln3714">      putNote(pos, false);</a>
<a name="ln3715">      }</a>
<a name="ln3716"> </a>
<a name="ln3717">//---------------------------------------------------------</a>
<a name="ln3718">//   cmdRelayout</a>
<a name="ln3719">//---------------------------------------------------------</a>
<a name="ln3720"> </a>
<a name="ln3721">void Score::cmdRelayout()</a>
<a name="ln3722">      {</a>
<a name="ln3723">      setLayoutAll();</a>
<a name="ln3724">      }</a>
<a name="ln3725"> </a>
<a name="ln3726">//---------------------------------------------------------</a>
<a name="ln3727">//   cmdToggleAutoplace</a>
<a name="ln3728">//---------------------------------------------------------</a>
<a name="ln3729"> </a>
<a name="ln3730">void Score::cmdToggleAutoplace(bool all)</a>
<a name="ln3731">      {</a>
<a name="ln3732">      if (all) {</a>
<a name="ln3733">            bool val = !styleB(Sid::autoplaceEnabled);</a>
<a name="ln3734">            undoChangeStyleVal(Sid::autoplaceEnabled, val);</a>
<a name="ln3735">            setLayoutAll();</a>
<a name="ln3736">            }</a>
<a name="ln3737">      else {</a>
<a name="ln3738">            QSet&lt;Element*&gt; spanners;</a>
<a name="ln3739">            for (Element* e : selection().elements()) {</a>
<a name="ln3740">                  if (e-&gt;isSpannerSegment()) {</a>
<a name="ln3741">                        if (Element* ee = e-&gt;propertyDelegate(Pid::AUTOPLACE))</a>
<a name="ln3742">                              e = ee;</a>
<a name="ln3743">                        // spanner segments may each have their own autoplace setting</a>
<a name="ln3744">                        // but if they delegate to spanner, only toggle once</a>
<a name="ln3745">                        if (e-&gt;isSpanner()) {</a>
<a name="ln3746">                              if (spanners.contains(e))</a>
<a name="ln3747">                                    continue;</a>
<a name="ln3748">                              spanners.insert(e);</a>
<a name="ln3749">                              }</a>
<a name="ln3750">                        }</a>
<a name="ln3751">                  PropertyFlags pf = e-&gt;propertyFlags(Pid::AUTOPLACE);</a>
<a name="ln3752">                  if (pf == PropertyFlags::STYLED)</a>
<a name="ln3753">                        pf = PropertyFlags::UNSTYLED;</a>
<a name="ln3754">                  e-&gt;undoChangeProperty(Pid::AUTOPLACE, !e-&gt;getProperty(Pid::AUTOPLACE).toBool(), pf);</a>
<a name="ln3755">                  }</a>
<a name="ln3756">            }</a>
<a name="ln3757">      }</a>
<a name="ln3758"> </a>
<a name="ln3759">//---------------------------------------------------------</a>
<a name="ln3760">//   cmd</a>
<a name="ln3761">//---------------------------------------------------------</a>
<a name="ln3762"> </a>
<a name="ln3763">void Score::cmd(const QAction* a, EditData&amp; ed)</a>
<a name="ln3764">      {</a>
<a name="ln3765">      QString cmd(a ? a-&gt;data().toString() : &quot;&quot;);</a>
<a name="ln3766">      if (MScore::debugMode)</a>
<a name="ln3767">            qDebug(&quot;&lt;%s&gt;&quot;, qPrintable(cmd));</a>
<a name="ln3768"> </a>
<a name="ln3769">      struct ScoreCmd {</a>
<a name="ln3770">            const char* name;</a>
<a name="ln3771">            std::function&lt;void(Score* cs, EditData&amp; ed)&gt; cmd;</a>
<a name="ln3772">            };</a>
<a name="ln3773">      static const std::vector&lt;ScoreCmd&gt; cmdList {</a>
<a name="ln3774">            { &quot;note-c&quot;,                     [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 0, false, false);                        }},</a>
<a name="ln3775">            { &quot;note-d&quot;,                     [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 1, false, false);                        }},</a>
<a name="ln3776">            { &quot;note-e&quot;,                     [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 2, false, false);                        }},</a>
<a name="ln3777">            { &quot;note-f&quot;,                     [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 3, false, false);                        }},</a>
<a name="ln3778">            { &quot;note-g&quot;,                     [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 4, false, false);                        }},</a>
<a name="ln3779">            { &quot;note-a&quot;,                     [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 5, false, false);                        }},</a>
<a name="ln3780">            { &quot;note-b&quot;,                     [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 6, false, false);                        }},</a>
<a name="ln3781">            { &quot;chord-c&quot;,                    [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 0, true, false);                         }},</a>
<a name="ln3782">            { &quot;chord-d&quot;,                    [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 1, true, false);                         }},</a>
<a name="ln3783">            { &quot;chord-e&quot;,                    [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 2, true, false);                         }},</a>
<a name="ln3784">            { &quot;chord-f&quot;,                    [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 3, true, false);                         }},</a>
<a name="ln3785">            { &quot;chord-g&quot;,                    [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 4, true, false);                         }},</a>
<a name="ln3786">            { &quot;chord-a&quot;,                    [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 5, true, false);                         }},</a>
<a name="ln3787">            { &quot;chord-b&quot;,                    [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 6, true, false);                         }},</a>
<a name="ln3788">            { &quot;insert-c&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 0, false, true);                         }},</a>
<a name="ln3789">            { &quot;insert-d&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 1, false, true);                         }},</a>
<a name="ln3790">            { &quot;insert-e&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 2, false, true);                         }},</a>
<a name="ln3791">            { &quot;insert-f&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 3, false, true);                         }},</a>
<a name="ln3792">            { &quot;insert-g&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 4, false, true);                         }},</a>
<a name="ln3793">            { &quot;insert-a&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 5, false, true);                         }},</a>
<a name="ln3794">            { &quot;insert-b&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;cmdAddPitch(ed, 6, false, true);                         }},</a>
<a name="ln3795">            { &quot;fret-0&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(0);                                              }},</a>
<a name="ln3796">            { &quot;fret-1&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(1);                                              }},</a>
<a name="ln3797">            { &quot;fret-2&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(2);                                              }},</a>
<a name="ln3798">            { &quot;fret-3&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(3);                                              }},</a>
<a name="ln3799">            { &quot;fret-4&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(4);                                              }},</a>
<a name="ln3800">            { &quot;fret-5&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(5);                                              }},</a>
<a name="ln3801">            { &quot;fret-6&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(6);                                              }},</a>
<a name="ln3802">            { &quot;fret-7&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(7);                                              }},</a>
<a name="ln3803">            { &quot;fret-8&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(8);                                              }},</a>
<a name="ln3804">            { &quot;fret-9&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(9);                                              }},</a>
<a name="ln3805">            { &quot;fret-10&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(10);                                             }},</a>
<a name="ln3806">            { &quot;fret-11&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(11);                                             }},</a>
<a name="ln3807">            { &quot;fret-12&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(12);                                             }},</a>
<a name="ln3808">            { &quot;fret-13&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(13);                                             }},</a>
<a name="ln3809">            { &quot;fret-14&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddFret(14);                                             }},</a>
<a name="ln3810">            { &quot;toggle-visible&quot;,             [](Score* cs, EditData&amp;){ cs-&gt;cmdToggleVisible();                                         }},</a>
<a name="ln3811">            { &quot;reset-stretch&quot;,              [](Score* cs, EditData&amp;){ cs-&gt;resetUserStretch();                                         }},</a>
<a name="ln3812">            { &quot;mirror-note&quot;,                [](Score* cs, EditData&amp;){ cs-&gt;cmdMirrorNoteHead();                                        }},</a>
<a name="ln3813">            { &quot;double-duration&quot;,            [](Score* cs, EditData&amp;){ cs-&gt;cmdDoubleDuration();                                        }},</a>
<a name="ln3814">            { &quot;half-duration&quot;,              [](Score* cs, EditData&amp;){ cs-&gt;cmdHalfDuration();                                          }},</a>
<a name="ln3815">            { &quot;inc-duration-dotted&quot;,        [](Score* cs, EditData&amp;){ cs-&gt;cmdIncDurationDotted();                                     }},</a>
<a name="ln3816">            { &quot;dec-duration-dotted&quot;,        [](Score* cs, EditData&amp;){ cs-&gt;cmdDecDurationDotted();                                     }},</a>
<a name="ln3817">            { &quot;add-staccato&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;addArticulation(SymId::articStaccatoAbove);                 }},</a>
<a name="ln3818">            { &quot;add-tenuto&quot;,                 [](Score* cs, EditData&amp;){ cs-&gt;addArticulation(SymId::articTenutoAbove);                   }},</a>
<a name="ln3819">            { &quot;add-marcato&quot;,                [](Score* cs, EditData&amp;){ cs-&gt;addArticulation(SymId::articMarcatoAbove);                  }},</a>
<a name="ln3820">            { &quot;add-sforzato&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;addArticulation(SymId::articAccentAbove);                   }},</a>
<a name="ln3821">            { &quot;add-trill&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;addArticulation(SymId::ornamentTrill);                      }},</a>
<a name="ln3822">            { &quot;add-up-bow&quot;,                 [](Score* cs, EditData&amp;){ cs-&gt;addArticulation(SymId::stringsUpBow);                       }},</a>
<a name="ln3823">            { &quot;add-down-bow&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;addArticulation(SymId::stringsDownBow);                     }},</a>
<a name="ln3824">            { &quot;add-8va&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddOttava(OttavaType::OTTAVA_8VA);                       }},</a>
<a name="ln3825">            { &quot;add-8vb&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddOttava(OttavaType::OTTAVA_8VB);                       }},</a>
<a name="ln3826">            { &quot;note-longa&quot;,                 [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE00, ed);                              }},</a>
<a name="ln3827">            { &quot;note-longa-TAB&quot;,             [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE00, ed);                              }},</a>
<a name="ln3828">            { &quot;note-breve&quot;,                 [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE0, ed);                               }},</a>
<a name="ln3829">            { &quot;note-breve-TAB&quot;,             [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE0, ed);                               }},</a>
<a name="ln3830">            { &quot;pad-note-1&quot;,                 [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE1, ed);                               }},</a>
<a name="ln3831">            { &quot;pad-note-1-TAB&quot;,             [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE1, ed);                               }},</a>
<a name="ln3832">            { &quot;pad-note-2&quot;,                 [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE2, ed);                               }},</a>
<a name="ln3833">            { &quot;pad-note-2-TAB&quot;,             [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE2, ed);                               }},</a>
<a name="ln3834">            { &quot;pad-note-4&quot;,                 [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE4, ed);                               }},</a>
<a name="ln3835">            { &quot;pad-note-4-TAB&quot;,             [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE4, ed);                               }},</a>
<a name="ln3836">            { &quot;pad-note-8&quot;,                 [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE8, ed);                               }},</a>
<a name="ln3837">            { &quot;pad-note-8-TAB&quot;,             [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE8, ed);                               }},</a>
<a name="ln3838">            { &quot;pad-note-16&quot;,                [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE16, ed);                              }},</a>
<a name="ln3839">            { &quot;pad-note-16-TAB&quot;,            [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE16, ed);                              }},</a>
<a name="ln3840">            { &quot;pad-note-32&quot;,                [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE32, ed);                              }},</a>
<a name="ln3841">            { &quot;pad-note-32-TAB&quot;,            [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE32, ed);                              }},</a>
<a name="ln3842">            { &quot;pad-note-64&quot;,                [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE64, ed);                              }},</a>
<a name="ln3843">            { &quot;pad-note-64-TAB&quot;,            [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE64, ed);                              }},</a>
<a name="ln3844">            { &quot;pad-note-128&quot;,               [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE128, ed);                             }},</a>
<a name="ln3845">            { &quot;pad-note-128-TAB&quot;,           [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::NOTE128, ed);                             }},</a>
<a name="ln3846">            { &quot;reset-style&quot;,                [](Score* cs, EditData&amp;){ cs-&gt;cmdResetStyle();                                            }},</a>
<a name="ln3847">            { &quot;reset-beammode&quot;,             [](Score* cs, EditData&amp;){ cs-&gt;cmdResetBeamMode();                                         }},</a>
<a name="ln3848">            { &quot;reset-groupings&quot;,            [](Score* cs, EditData&amp;){ cs-&gt;cmdResetNoteAndRestGroupings();                             }},</a>
<a name="ln3849">            { &quot;clef-violin&quot;,                [](Score* cs, EditData&amp;){ cs-&gt;cmdInsertClef(ClefType::G);                                 }},</a>
<a name="ln3850">            { &quot;clef-bass&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;cmdInsertClef(ClefType::F);                                 }},</a>
<a name="ln3851">            { &quot;voice-x12&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;cmdExchangeVoice(0, 1);                                     }},</a>
<a name="ln3852">            { &quot;voice-x13&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;cmdExchangeVoice(0, 2);                                     }},</a>
<a name="ln3853">            { &quot;voice-x14&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;cmdExchangeVoice(0, 3);                                     }},</a>
<a name="ln3854">            { &quot;voice-x23&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;cmdExchangeVoice(1, 2);                                     }},</a>
<a name="ln3855">            { &quot;voice-x24&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;cmdExchangeVoice(1, 3);                                     }},</a>
<a name="ln3856">            { &quot;voice-x34&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;cmdExchangeVoice(2, 3);                                     }},</a>
<a name="ln3857">            { &quot;pad-rest&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::REST, ed);                                }},</a>
<a name="ln3858">            { &quot;pad-dot&quot;,                    [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::DOT, ed);                                 }},</a>
<a name="ln3859">            { &quot;pad-dotdot&quot;,                 [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::DOTDOT, ed);                              }},</a>
<a name="ln3860">            { &quot;pad-dot3&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::DOT3, ed);                                }},</a>
<a name="ln3861">            { &quot;pad-dot4&quot;,                   [](Score* cs, EditData&amp; ed){ cs-&gt;padToggle(Pad::DOT4, ed);                                }},</a>
<a name="ln3862">            { &quot;beam-start&quot;,                 [](Score* cs, EditData&amp;){ cs-&gt;cmdSetBeamMode(Beam::Mode::BEGIN);                          }},</a>
<a name="ln3863">            { &quot;beam-mid&quot;,                   [](Score* cs, EditData&amp;){ cs-&gt;cmdSetBeamMode(Beam::Mode::MID);                            }},</a>
<a name="ln3864">            { &quot;no-beam&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdSetBeamMode(Beam::Mode::NONE);                           }},</a>
<a name="ln3865">            { &quot;beam32&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdSetBeamMode(Beam::Mode::BEGIN32);                        }},</a>
<a name="ln3866">            { &quot;beam64&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdSetBeamMode(Beam::Mode::BEGIN64);                        }},</a>
<a name="ln3867">            { &quot;auto-beam&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;cmdSetBeamMode(Beam::Mode::AUTO);                           }},</a>
<a name="ln3868">            { &quot;sharp2&quot;,                     [](Score* cs, EditData&amp; ed){ cs-&gt;toggleAccidental(AccidentalType::SHARP2, ed);            }},</a>
<a name="ln3869">            { &quot;sharp&quot;,                      [](Score* cs, EditData&amp; ed){ cs-&gt;toggleAccidental(AccidentalType::SHARP, ed);             }},</a>
<a name="ln3870">            { &quot;nat&quot;,                        [](Score* cs, EditData&amp; ed){ cs-&gt;toggleAccidental(AccidentalType::NATURAL, ed);           }},</a>
<a name="ln3871">            { &quot;flat&quot;,                       [](Score* cs, EditData&amp; ed){ cs-&gt;toggleAccidental(AccidentalType::FLAT, ed);              }},</a>
<a name="ln3872">            { &quot;flat2&quot;,                      [](Score* cs, EditData&amp; ed){ cs-&gt;toggleAccidental(AccidentalType::FLAT2, ed);             }},</a>
<a name="ln3873">            { &quot;flip&quot;,                       [](Score* cs, EditData&amp;){ cs-&gt;cmdFlip();                                                  }},</a>
<a name="ln3874">            { &quot;stretch+&quot;,                   [](Score* cs, EditData&amp;){ cs-&gt;cmdAddStretch(0.1);                                         }},</a>
<a name="ln3875">            { &quot;stretch-&quot;,                   [](Score* cs, EditData&amp;){ cs-&gt;cmdAddStretch(-0.1);                                        }},</a>
<a name="ln3876">            { &quot;pitch-spell&quot;,                [](Score* cs, EditData&amp;){ cs-&gt;spell();                                                    }},</a>
<a name="ln3877">            { &quot;select-all&quot;,                 [](Score* cs, EditData&amp;){ cs-&gt;cmdSelectAll();                                             }},</a>
<a name="ln3878">            { &quot;select-section&quot;,             [](Score* cs, EditData&amp;){ cs-&gt;cmdSelectSection();                                         }},</a>
<a name="ln3879">            { &quot;add-brackets&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;cmdAddBracket();                                            }},</a>
<a name="ln3880">            { &quot;add-parentheses&quot;,            [](Score* cs, EditData&amp;){ cs-&gt;cmdAddParentheses();                                        }},</a>
<a name="ln3881">            { &quot;acciaccatura&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;cmdAddGrace(NoteType::ACCIACCATURA, MScore::division / 2);  }},</a>
<a name="ln3882">            { &quot;appoggiatura&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;cmdAddGrace(NoteType::APPOGGIATURA, MScore::division / 2);  }},</a>
<a name="ln3883">            { &quot;grace4&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdAddGrace(NoteType::GRACE4, MScore::division);            }},</a>
<a name="ln3884">            { &quot;grace16&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddGrace(NoteType::GRACE16, MScore::division / 4);       }},</a>
<a name="ln3885">            { &quot;grace32&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdAddGrace(NoteType::GRACE32, MScore::division / 8);       }},</a>
<a name="ln3886">            { &quot;grace8after&quot;,                [](Score* cs, EditData&amp;){ cs-&gt;cmdAddGrace(NoteType::GRACE8_AFTER, MScore::division / 2);  }},</a>
<a name="ln3887">            { &quot;grace16after&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;cmdAddGrace(NoteType::GRACE16_AFTER, MScore::division / 4); }},</a>
<a name="ln3888">            { &quot;grace32after&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;cmdAddGrace(NoteType::GRACE32_AFTER, MScore::division / 8); }},</a>
<a name="ln3889">            { &quot;explode&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt;cmdExplode();                                               }},</a>
<a name="ln3890">            { &quot;implode&quot;,                    [](Score* cs, EditData&amp;){ cs-&gt; cmdImplode();                                               }},</a>
<a name="ln3891">            { &quot;slash-fill&quot;,                 [](Score* cs, EditData&amp;){ cs-&gt;cmdSlashFill();                                             }},</a>
<a name="ln3892">            { &quot;slash-rhythm&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;cmdSlashRhythm();                                           }},</a>
<a name="ln3893">            { &quot;resequence-rehearsal-marks&quot;, [](Score* cs, EditData&amp;){ cs-&gt;cmdResequenceRehearsalMarks();                              }},</a>
<a name="ln3894">            { &quot;del-empty-measures&quot;,         [](Score* cs, EditData&amp;){ cs-&gt;cmdRemoveEmptyTrailingMeasures();                           }},</a>
<a name="ln3895">            { &quot;add-audio&quot;,                  [](Score* cs, EditData&amp;){ cs-&gt;addAudioTrack();                                            }},</a>
<a name="ln3896">            { &quot;transpose-up&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;transposeSemitone(1);                                       }},</a>
<a name="ln3897">            { &quot;transpose-down&quot;,             [](Score* cs, EditData&amp;){ cs-&gt;transposeSemitone(-1);                                      }},</a>
<a name="ln3898">            { &quot;delete&quot;,                     [](Score* cs, EditData&amp;){ cs-&gt;cmdDeleteSelection();                                       }},</a>
<a name="ln3899">            { &quot;full-measure-rest&quot;,          [](Score* cs, EditData&amp;){ cs-&gt;cmdFullMeasureRest();                                       }},</a>
<a name="ln3900">            { &quot;toggle-insert-mode&quot;,         [](Score* cs, EditData&amp;){ cs-&gt;_is.setInsertMode(!cs-&gt;_is.insertMode());                       }},</a>
<a name="ln3901">            { &quot;pitch-up&quot;,                   [](Score* cs, EditData&amp;){ cs-&gt;cmdPitchUp();                                               }},</a>
<a name="ln3902">            { &quot;pitch-down&quot;,                 [](Score* cs, EditData&amp;){ cs-&gt;cmdPitchDown();                                             }},</a>
<a name="ln3903">            { &quot;time-delete&quot;,                [](Score* cs, EditData&amp;){ cs-&gt;cmdTimeDelete();                                            }},</a>
<a name="ln3904">            { &quot;pitch-up-octave&quot;,            [](Score* cs, EditData&amp;){ cs-&gt;cmdPitchUpOctave();                                         }},</a>
<a name="ln3905">            { &quot;pitch-down-octave&quot;,          [](Score* cs, EditData&amp;){ cs-&gt;cmdPitchDownOctave();                                       }},</a>
<a name="ln3906">            { &quot;pad-note-increase&quot;,          [](Score* cs, EditData&amp; ed){ cs-&gt;cmdPadNoteIncreaseTAB(ed);                               }},</a>
<a name="ln3907">            { &quot;pad-note-decrease&quot;,          [](Score* cs, EditData&amp; ed){ cs-&gt;cmdPadNoteDecreaseTAB(ed);                               }},</a>
<a name="ln3908">            { &quot;pad-note-increase-TAB&quot;,      [](Score* cs, EditData&amp; ed){ cs-&gt;cmdPadNoteIncreaseTAB(ed);                               }},</a>
<a name="ln3909">            { &quot;pad-note-decrease-TAB&quot;,      [](Score* cs, EditData&amp; ed){ cs-&gt;cmdPadNoteDecreaseTAB(ed);                               }},</a>
<a name="ln3910">            { &quot;toggle-mmrest&quot;,              [](Score* cs, EditData&amp;){ cs-&gt;cmdToggleMmrest();                                          }},</a>
<a name="ln3911">            { &quot;toggle-hide-empty&quot;,          [](Score* cs, EditData&amp;){ cs-&gt;cmdToggleHideEmpty();                                       }},</a>
<a name="ln3912">            { &quot;set-visible&quot;,                [](Score* cs, EditData&amp;){ cs-&gt;cmdSetVisible();                                            }},</a>
<a name="ln3913">            { &quot;unset-visible&quot;,              [](Score* cs, EditData&amp;){ cs-&gt;cmdUnsetVisible();                                          }},</a>
<a name="ln3914">            { &quot;system-break&quot;,               [](Score* cs, EditData&amp;){ cs-&gt;cmdToggleLayoutBreak(LayoutBreak::Type::LINE);              }},</a>
<a name="ln3915">            { &quot;page-break&quot;,                 [](Score* cs, EditData&amp;){ cs-&gt;cmdToggleLayoutBreak(LayoutBreak::Type::PAGE);              }},</a>
<a name="ln3916">            { &quot;section-break&quot;,              [](Score* cs, EditData&amp;){ cs-&gt;cmdToggleLayoutBreak(LayoutBreak::Type::SECTION);           }},</a>
<a name="ln3917">            { &quot;relayout&quot;,                   [](Score* cs, EditData&amp;){ cs-&gt;cmdRelayout();                                              }},</a>
<a name="ln3918">            { &quot;toggle-autoplace&quot;,           [](Score* cs, EditData&amp;){ cs-&gt;cmdToggleAutoplace(false);                                  }},</a>
<a name="ln3919">            { &quot;autoplace-enabled&quot;,          [](Score* cs, EditData&amp;){ cs-&gt;cmdToggleAutoplace(true);                                   }},</a>
<a name="ln3920">            };</a>
<a name="ln3921"> </a>
<a name="ln3922">      for (const auto&amp; c : cmdList) {</a>
<a name="ln3923">            if (cmd == c.name) {</a>
<a name="ln3924">                  startCmd();</a>
<a name="ln3925">                  c.cmd(this, ed);</a>
<a name="ln3926">                  endCmd();</a>
<a name="ln3927">                  return;</a>
<a name="ln3928">                  }</a>
<a name="ln3929">            }</a>
<a name="ln3930">      qDebug(&quot;unknown cmd &lt;%s&gt;&quot;, qPrintable(cmd));</a>
<a name="ln3931">      }</a>
<a name="ln3932"> </a>
<a name="ln3933"> </a>
<a name="ln3934">}</a>
<a name="ln3935"> </a>

</code></pre>
<div class="balloon" rel="1749"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'stringData' is always true.</p></div>
<div class="balloon" rel="2322"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: cr.</p></div>
<div class="balloon" rel="2361"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: cr.</p></div>
<div class="balloon" rel="2774"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions '!m->hasVoice(j)' and 'm->hasVoice(j)'. </p></div>
<div class="balloon" rel="2947"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: startSegment.</p></div>
<div class="balloon" rel="3024"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'p.fret' variable was assigned the same value.</p></div>
<div class="balloon" rel="3767"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="3930"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
