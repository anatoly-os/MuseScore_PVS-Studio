
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>cffload.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***************************************************************************/</a>
<a name="ln2">/*                                                                         */</a>
<a name="ln3">/*  cffload.c                                                              */</a>
<a name="ln4">/*                                                                         */</a>
<a name="ln5">/*    OpenType and CFF data/program tables loader (body).                  */</a>
<a name="ln6">/*                                                                         */</a>
<a name="ln7">/*  Copyright 1996-2015 by                                                 */</a>
<a name="ln8">/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</a>
<a name="ln9">/*                                                                         */</a>
<a name="ln10">/*  This file is part of the FreeType project, and may only be used,       */</a>
<a name="ln11">/*  modified, and distributed under the terms of the FreeType project      */</a>
<a name="ln12">/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</a>
<a name="ln13">/*  this file you indicate that you have read the license and              */</a>
<a name="ln14">/*  understand and accept it fully.                                        */</a>
<a name="ln15">/*                                                                         */</a>
<a name="ln16">/***************************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;ft2build.h&gt;</a>
<a name="ln20">#include FT_INTERNAL_DEBUG_H</a>
<a name="ln21">#include FT_INTERNAL_OBJECTS_H</a>
<a name="ln22">#include FT_INTERNAL_STREAM_H</a>
<a name="ln23">#include FT_TRUETYPE_TAGS_H</a>
<a name="ln24">#include FT_TYPE1_TABLES_H</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;cffload.h&quot;</a>
<a name="ln27">#include &quot;cffparse.h&quot;</a>
<a name="ln28"> </a>
<a name="ln29">#include &quot;cfferrs.h&quot;</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">#if 1</a>
<a name="ln33"> </a>
<a name="ln34">  static const FT_UShort  cff_isoadobe_charset[229] =</a>
<a name="ln35">  {</a>
<a name="ln36">      0,   1,   2,   3,   4,   5,   6,   7,</a>
<a name="ln37">      8,   9,  10,  11,  12,  13,  14,  15,</a>
<a name="ln38">     16,  17,  18,  19,  20,  21,  22,  23,</a>
<a name="ln39">     24,  25,  26,  27,  28,  29,  30,  31,</a>
<a name="ln40">     32,  33,  34,  35,  36,  37,  38,  39,</a>
<a name="ln41">     40,  41,  42,  43,  44,  45,  46,  47,</a>
<a name="ln42">     48,  49,  50,  51,  52,  53,  54,  55,</a>
<a name="ln43">     56,  57,  58,  59,  60,  61,  62,  63,</a>
<a name="ln44">     64,  65,  66,  67,  68,  69,  70,  71,</a>
<a name="ln45">     72,  73,  74,  75,  76,  77,  78,  79,</a>
<a name="ln46">     80,  81,  82,  83,  84,  85,  86,  87,</a>
<a name="ln47">     88,  89,  90,  91,  92,  93,  94,  95,</a>
<a name="ln48">     96,  97,  98,  99, 100, 101, 102, 103,</a>
<a name="ln49">    104, 105, 106, 107, 108, 109, 110, 111,</a>
<a name="ln50">    112, 113, 114, 115, 116, 117, 118, 119,</a>
<a name="ln51">    120, 121, 122, 123, 124, 125, 126, 127,</a>
<a name="ln52">    128, 129, 130, 131, 132, 133, 134, 135,</a>
<a name="ln53">    136, 137, 138, 139, 140, 141, 142, 143,</a>
<a name="ln54">    144, 145, 146, 147, 148, 149, 150, 151,</a>
<a name="ln55">    152, 153, 154, 155, 156, 157, 158, 159,</a>
<a name="ln56">    160, 161, 162, 163, 164, 165, 166, 167,</a>
<a name="ln57">    168, 169, 170, 171, 172, 173, 174, 175,</a>
<a name="ln58">    176, 177, 178, 179, 180, 181, 182, 183,</a>
<a name="ln59">    184, 185, 186, 187, 188, 189, 190, 191,</a>
<a name="ln60">    192, 193, 194, 195, 196, 197, 198, 199,</a>
<a name="ln61">    200, 201, 202, 203, 204, 205, 206, 207,</a>
<a name="ln62">    208, 209, 210, 211, 212, 213, 214, 215,</a>
<a name="ln63">    216, 217, 218, 219, 220, 221, 222, 223,</a>
<a name="ln64">    224, 225, 226, 227, 228</a>
<a name="ln65">  };</a>
<a name="ln66"> </a>
<a name="ln67">  static const FT_UShort  cff_expert_charset[166] =</a>
<a name="ln68">  {</a>
<a name="ln69">      0,   1, 229, 230, 231, 232, 233, 234,</a>
<a name="ln70">    235, 236, 237, 238,  13,  14,  15,  99,</a>
<a name="ln71">    239, 240, 241, 242, 243, 244, 245, 246,</a>
<a name="ln72">    247, 248,  27,  28, 249, 250, 251, 252,</a>
<a name="ln73">    253, 254, 255, 256, 257, 258, 259, 260,</a>
<a name="ln74">    261, 262, 263, 264, 265, 266, 109, 110,</a>
<a name="ln75">    267, 268, 269, 270, 271, 272, 273, 274,</a>
<a name="ln76">    275, 276, 277, 278, 279, 280, 281, 282,</a>
<a name="ln77">    283, 284, 285, 286, 287, 288, 289, 290,</a>
<a name="ln78">    291, 292, 293, 294, 295, 296, 297, 298,</a>
<a name="ln79">    299, 300, 301, 302, 303, 304, 305, 306,</a>
<a name="ln80">    307, 308, 309, 310, 311, 312, 313, 314,</a>
<a name="ln81">    315, 316, 317, 318, 158, 155, 163, 319,</a>
<a name="ln82">    320, 321, 322, 323, 324, 325, 326, 150,</a>
<a name="ln83">    164, 169, 327, 328, 329, 330, 331, 332,</a>
<a name="ln84">    333, 334, 335, 336, 337, 338, 339, 340,</a>
<a name="ln85">    341, 342, 343, 344, 345, 346, 347, 348,</a>
<a name="ln86">    349, 350, 351, 352, 353, 354, 355, 356,</a>
<a name="ln87">    357, 358, 359, 360, 361, 362, 363, 364,</a>
<a name="ln88">    365, 366, 367, 368, 369, 370, 371, 372,</a>
<a name="ln89">    373, 374, 375, 376, 377, 378</a>
<a name="ln90">  };</a>
<a name="ln91"> </a>
<a name="ln92">  static const FT_UShort  cff_expertsubset_charset[87] =</a>
<a name="ln93">  {</a>
<a name="ln94">      0,   1, 231, 232, 235, 236, 237, 238,</a>
<a name="ln95">     13,  14,  15,  99, 239, 240, 241, 242,</a>
<a name="ln96">    243, 244, 245, 246, 247, 248,  27,  28,</a>
<a name="ln97">    249, 250, 251, 253, 254, 255, 256, 257,</a>
<a name="ln98">    258, 259, 260, 261, 262, 263, 264, 265,</a>
<a name="ln99">    266, 109, 110, 267, 268, 269, 270, 272,</a>
<a name="ln100">    300, 301, 302, 305, 314, 315, 158, 155,</a>
<a name="ln101">    163, 320, 321, 322, 323, 324, 325, 326,</a>
<a name="ln102">    150, 164, 169, 327, 328, 329, 330, 331,</a>
<a name="ln103">    332, 333, 334, 335, 336, 337, 338, 339,</a>
<a name="ln104">    340, 341, 342, 343, 344, 345, 346</a>
<a name="ln105">  };</a>
<a name="ln106"> </a>
<a name="ln107">  static const FT_UShort  cff_standard_encoding[256] =</a>
<a name="ln108">  {</a>
<a name="ln109">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln110">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln111">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln112">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln113">      1,   2,   3,   4,   5,   6,   7,   8,</a>
<a name="ln114">      9,  10,  11,  12,  13,  14,  15,  16,</a>
<a name="ln115">     17,  18,  19,  20,  21,  22,  23,  24,</a>
<a name="ln116">     25,  26,  27,  28,  29,  30,  31,  32,</a>
<a name="ln117">     33,  34,  35,  36,  37,  38,  39,  40,</a>
<a name="ln118">     41,  42,  43,  44,  45,  46,  47,  48,</a>
<a name="ln119">     49,  50,  51,  52,  53,  54,  55,  56,</a>
<a name="ln120">     57,  58,  59,  60,  61,  62,  63,  64,</a>
<a name="ln121">     65,  66,  67,  68,  69,  70,  71,  72,</a>
<a name="ln122">     73,  74,  75,  76,  77,  78,  79,  80,</a>
<a name="ln123">     81,  82,  83,  84,  85,  86,  87,  88,</a>
<a name="ln124">     89,  90,  91,  92,  93,  94,  95,   0,</a>
<a name="ln125">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln126">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln127">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln128">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln129">      0,  96,  97,  98,  99, 100, 101, 102,</a>
<a name="ln130">    103, 104, 105, 106, 107, 108, 109, 110,</a>
<a name="ln131">      0, 111, 112, 113, 114,   0, 115, 116,</a>
<a name="ln132">    117, 118, 119, 120, 121, 122,   0, 123,</a>
<a name="ln133">      0, 124, 125, 126, 127, 128, 129, 130,</a>
<a name="ln134">    131,   0, 132, 133,   0, 134, 135, 136,</a>
<a name="ln135">    137,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln136">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln137">      0, 138,   0, 139,   0,   0,   0,   0,</a>
<a name="ln138">    140, 141, 142, 143,   0,   0,   0,   0,</a>
<a name="ln139">      0, 144,   0,   0,   0, 145,   0,   0,</a>
<a name="ln140">    146, 147, 148, 149,   0,   0,   0,   0</a>
<a name="ln141">  };</a>
<a name="ln142"> </a>
<a name="ln143">  static const FT_UShort  cff_expert_encoding[256] =</a>
<a name="ln144">  {</a>
<a name="ln145">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln146">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln147">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln148">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln149">      1, 229, 230,   0, 231, 232, 233, 234,</a>
<a name="ln150">    235, 236, 237, 238,  13,  14,  15,  99,</a>
<a name="ln151">    239, 240, 241, 242, 243, 244, 245, 246,</a>
<a name="ln152">    247, 248,  27,  28, 249, 250, 251, 252,</a>
<a name="ln153">      0, 253, 254, 255, 256, 257,   0,   0,</a>
<a name="ln154">      0, 258,   0,   0, 259, 260, 261, 262,</a>
<a name="ln155">      0,   0, 263, 264, 265,   0, 266, 109,</a>
<a name="ln156">    110, 267, 268, 269,   0, 270, 271, 272,</a>
<a name="ln157">    273, 274, 275, 276, 277, 278, 279, 280,</a>
<a name="ln158">    281, 282, 283, 284, 285, 286, 287, 288,</a>
<a name="ln159">    289, 290, 291, 292, 293, 294, 295, 296,</a>
<a name="ln160">    297, 298, 299, 300, 301, 302, 303,   0,</a>
<a name="ln161">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln162">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln163">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln164">      0,   0,   0,   0,   0,   0,   0,   0,</a>
<a name="ln165">      0, 304, 305, 306,   0,   0, 307, 308,</a>
<a name="ln166">    309, 310, 311,   0, 312,   0,   0, 312,</a>
<a name="ln167">      0,   0, 314, 315,   0,   0, 316, 317,</a>
<a name="ln168">    318,   0,   0,   0, 158, 155, 163, 319,</a>
<a name="ln169">    320, 321, 322, 323, 324, 325,   0,   0,</a>
<a name="ln170">    326, 150, 164, 169, 327, 328, 329, 330,</a>
<a name="ln171">    331, 332, 333, 334, 335, 336, 337, 338,</a>
<a name="ln172">    339, 340, 341, 342, 343, 344, 345, 346,</a>
<a name="ln173">    347, 348, 349, 350, 351, 352, 353, 354,</a>
<a name="ln174">    355, 356, 357, 358, 359, 360, 361, 362,</a>
<a name="ln175">    363, 364, 365, 366, 367, 368, 369, 370,</a>
<a name="ln176">    371, 372, 373, 374, 375, 376, 377, 378</a>
<a name="ln177">  };</a>
<a name="ln178"> </a>
<a name="ln179">#endif /* 1 */</a>
<a name="ln180"> </a>
<a name="ln181"> </a>
<a name="ln182">  FT_LOCAL_DEF( FT_UShort )</a>
<a name="ln183">  cff_get_standard_encoding( FT_UInt  charcode )</a>
<a name="ln184">  {</a>
<a name="ln185">    return (FT_UShort)( charcode &lt; 256 ? cff_standard_encoding[charcode]</a>
<a name="ln186">                                       : 0 );</a>
<a name="ln187">  }</a>
<a name="ln188"> </a>
<a name="ln189"> </a>
<a name="ln190">  /*************************************************************************/</a>
<a name="ln191">  /*                                                                       */</a>
<a name="ln192">  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</a>
<a name="ln193">  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</a>
<a name="ln194">  /* messages during execution.                                            */</a>
<a name="ln195">  /*                                                                       */</a>
<a name="ln196">#undef  FT_COMPONENT</a>
<a name="ln197">#define FT_COMPONENT  trace_cffload</a>
<a name="ln198"> </a>
<a name="ln199"> </a>
<a name="ln200">  /* read an offset from the index's stream current position */</a>
<a name="ln201">  static FT_ULong</a>
<a name="ln202">  cff_index_read_offset( CFF_Index  idx,</a>
<a name="ln203">                         FT_Error  *errorp )</a>
<a name="ln204">  {</a>
<a name="ln205">    FT_Error   error;</a>
<a name="ln206">    FT_Stream  stream = idx-&gt;stream;</a>
<a name="ln207">    FT_Byte    tmp[4];</a>
<a name="ln208">    FT_ULong   result = 0;</a>
<a name="ln209"> </a>
<a name="ln210"> </a>
<a name="ln211">    if ( !FT_STREAM_READ( tmp, idx-&gt;off_size ) )</a>
<a name="ln212">    {</a>
<a name="ln213">      FT_Int  nn;</a>
<a name="ln214"> </a>
<a name="ln215"> </a>
<a name="ln216">      for ( nn = 0; nn &lt; idx-&gt;off_size; nn++ )</a>
<a name="ln217">        result = ( result &lt;&lt; 8 ) | tmp[nn];</a>
<a name="ln218">    }</a>
<a name="ln219"> </a>
<a name="ln220">    *errorp = error;</a>
<a name="ln221">    return result;</a>
<a name="ln222">  }</a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225">  static FT_Error</a>
<a name="ln226">  cff_index_init( CFF_Index  idx,</a>
<a name="ln227">                  FT_Stream  stream,</a>
<a name="ln228">                  FT_Bool    load )</a>
<a name="ln229">  {</a>
<a name="ln230">    FT_Error   error;</a>
<a name="ln231">    FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln232">    FT_UShort  count;</a>
<a name="ln233"> </a>
<a name="ln234"> </a>
<a name="ln235">    FT_MEM_ZERO( idx, sizeof ( *idx ) );</a>
<a name="ln236"> </a>
<a name="ln237">    idx-&gt;stream = stream;</a>
<a name="ln238">    idx-&gt;start  = FT_STREAM_POS();</a>
<a name="ln239">    if ( !FT_READ_USHORT( count ) &amp;&amp;</a>
<a name="ln240">         count &gt; 0                )</a>
<a name="ln241">    {</a>
<a name="ln242">      FT_Byte   offsize;</a>
<a name="ln243">      FT_ULong  size;</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">      /* there is at least one element; read the offset size,           */</a>
<a name="ln247">      /* then access the offset table to compute the index's total size */</a>
<a name="ln248">      if ( FT_READ_BYTE( offsize ) )</a>
<a name="ln249">        goto Exit;</a>
<a name="ln250"> </a>
<a name="ln251">      if ( offsize &lt; 1 || offsize &gt; 4 )</a>
<a name="ln252">      {</a>
<a name="ln253">        error = FT_THROW( Invalid_Table );</a>
<a name="ln254">        goto Exit;</a>
<a name="ln255">      }</a>
<a name="ln256"> </a>
<a name="ln257">      idx-&gt;count    = count;</a>
<a name="ln258">      idx-&gt;off_size = offsize;</a>
<a name="ln259">      size          = (FT_ULong)( count + 1 ) * offsize;</a>
<a name="ln260"> </a>
<a name="ln261">      idx-&gt;data_offset = idx-&gt;start + 3 + size;</a>
<a name="ln262"> </a>
<a name="ln263">      if ( FT_STREAM_SKIP( size - offsize ) )</a>
<a name="ln264">        goto Exit;</a>
<a name="ln265"> </a>
<a name="ln266">      size = cff_index_read_offset( idx, &amp;error );</a>
<a name="ln267">      if ( error )</a>
<a name="ln268">        goto Exit;</a>
<a name="ln269"> </a>
<a name="ln270">      if ( size == 0 )</a>
<a name="ln271">      {</a>
<a name="ln272">        error = FT_THROW( Invalid_Table );</a>
<a name="ln273">        goto Exit;</a>
<a name="ln274">      }</a>
<a name="ln275"> </a>
<a name="ln276">      idx-&gt;data_size = --size;</a>
<a name="ln277"> </a>
<a name="ln278">      if ( load )</a>
<a name="ln279">      {</a>
<a name="ln280">        /* load the data */</a>
<a name="ln281">        if ( FT_FRAME_EXTRACT( size, idx-&gt;bytes ) )</a>
<a name="ln282">          goto Exit;</a>
<a name="ln283">      }</a>
<a name="ln284">      else</a>
<a name="ln285">      {</a>
<a name="ln286">        /* skip the data */</a>
<a name="ln287">        if ( FT_STREAM_SKIP( size ) )</a>
<a name="ln288">          goto Exit;</a>
<a name="ln289">      }</a>
<a name="ln290">    }</a>
<a name="ln291"> </a>
<a name="ln292">  Exit:</a>
<a name="ln293">    if ( error )</a>
<a name="ln294">      FT_FREE( idx-&gt;offsets );</a>
<a name="ln295"> </a>
<a name="ln296">    return error;</a>
<a name="ln297">  }</a>
<a name="ln298"> </a>
<a name="ln299"> </a>
<a name="ln300">  static void</a>
<a name="ln301">  cff_index_done( CFF_Index  idx )</a>
<a name="ln302">  {</a>
<a name="ln303">    if ( idx-&gt;stream )</a>
<a name="ln304">    {</a>
<a name="ln305">      FT_Stream  stream = idx-&gt;stream;</a>
<a name="ln306">      FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln307"> </a>
<a name="ln308"> </a>
<a name="ln309">      if ( idx-&gt;bytes )</a>
<a name="ln310">        FT_FRAME_RELEASE( idx-&gt;bytes );</a>
<a name="ln311"> </a>
<a name="ln312">      FT_FREE( idx-&gt;offsets );</a>
<a name="ln313">      FT_MEM_ZERO( idx, sizeof ( *idx ) );</a>
<a name="ln314">    }</a>
<a name="ln315">  }</a>
<a name="ln316"> </a>
<a name="ln317"> </a>
<a name="ln318">  static FT_Error</a>
<a name="ln319">  cff_index_load_offsets( CFF_Index  idx )</a>
<a name="ln320">  {</a>
<a name="ln321">    FT_Error   error  = FT_Err_Ok;</a>
<a name="ln322">    FT_Stream  stream = idx-&gt;stream;</a>
<a name="ln323">    FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln324"> </a>
<a name="ln325"> </a>
<a name="ln326">    if ( idx-&gt;count &gt; 0 &amp;&amp; idx-&gt;offsets == NULL )</a>
<a name="ln327">    {</a>
<a name="ln328">      FT_Byte    offsize = idx-&gt;off_size;</a>
<a name="ln329">      FT_ULong   data_size;</a>
<a name="ln330">      FT_Byte*   p;</a>
<a name="ln331">      FT_Byte*   p_end;</a>
<a name="ln332">      FT_ULong*  poff;</a>
<a name="ln333"> </a>
<a name="ln334"> </a>
<a name="ln335">      data_size = (FT_ULong)( idx-&gt;count + 1 ) * offsize;</a>
<a name="ln336"> </a>
<a name="ln337">      if ( FT_NEW_ARRAY( idx-&gt;offsets, idx-&gt;count + 1 ) ||</a>
<a name="ln338">           FT_STREAM_SEEK( idx-&gt;start + 3 )             ||</a>
<a name="ln339">           FT_FRAME_ENTER( data_size )                  )</a>
<a name="ln340">        goto Exit;</a>
<a name="ln341"> </a>
<a name="ln342">      poff   = idx-&gt;offsets;</a>
<a name="ln343">      p      = (FT_Byte*)stream-&gt;cursor;</a>
<a name="ln344">      p_end  = p + data_size;</a>
<a name="ln345"> </a>
<a name="ln346">      switch ( offsize )</a>
<a name="ln347">      {</a>
<a name="ln348">      case 1:</a>
<a name="ln349">        for ( ; p &lt; p_end; p++, poff++ )</a>
<a name="ln350">          poff[0] = p[0];</a>
<a name="ln351">        break;</a>
<a name="ln352"> </a>
<a name="ln353">      case 2:</a>
<a name="ln354">        for ( ; p &lt; p_end; p += 2, poff++ )</a>
<a name="ln355">          poff[0] = FT_PEEK_USHORT( p );</a>
<a name="ln356">        break;</a>
<a name="ln357"> </a>
<a name="ln358">      case 3:</a>
<a name="ln359">        for ( ; p &lt; p_end; p += 3, poff++ )</a>
<a name="ln360">          poff[0] = FT_PEEK_UOFF3( p );</a>
<a name="ln361">        break;</a>
<a name="ln362"> </a>
<a name="ln363">      default:</a>
<a name="ln364">        for ( ; p &lt; p_end; p += 4, poff++ )</a>
<a name="ln365">          poff[0] = FT_PEEK_ULONG( p );</a>
<a name="ln366">      }</a>
<a name="ln367"> </a>
<a name="ln368">      FT_FRAME_EXIT();</a>
<a name="ln369">    }</a>
<a name="ln370"> </a>
<a name="ln371">  Exit:</a>
<a name="ln372">    if ( error )</a>
<a name="ln373">      FT_FREE( idx-&gt;offsets );</a>
<a name="ln374"> </a>
<a name="ln375">    return error;</a>
<a name="ln376">  }</a>
<a name="ln377"> </a>
<a name="ln378"> </a>
<a name="ln379">  /* Allocate a table containing pointers to an index's elements. */</a>
<a name="ln380">  /* The `pool' argument makes this function convert the index    */</a>
<a name="ln381">  /* entries to C-style strings (this is, NULL-terminated).       */</a>
<a name="ln382">  static FT_Error</a>
<a name="ln383">  cff_index_get_pointers( CFF_Index   idx,</a>
<a name="ln384">                          FT_Byte***  table,</a>
<a name="ln385">                          FT_Byte**   pool )</a>
<a name="ln386">  {</a>
<a name="ln387">    FT_Error   error     = FT_Err_Ok;</a>
<a name="ln388">    FT_Memory  memory    = idx-&gt;stream-&gt;memory;</a>
<a name="ln389"> </a>
<a name="ln390">    FT_Byte**  t         = NULL;</a>
<a name="ln391">    FT_Byte*   new_bytes = NULL;</a>
<a name="ln392"> </a>
<a name="ln393"> </a>
<a name="ln394">    *table = NULL;</a>
<a name="ln395"> </a>
<a name="ln396">    if ( idx-&gt;offsets == NULL )</a>
<a name="ln397">    {</a>
<a name="ln398">      error = cff_index_load_offsets( idx );</a>
<a name="ln399">      if ( error )</a>
<a name="ln400">        goto Exit;</a>
<a name="ln401">    }</a>
<a name="ln402"> </a>
<a name="ln403">    if ( idx-&gt;count &gt; 0                                        &amp;&amp;</a>
<a name="ln404">         !FT_NEW_ARRAY( t, idx-&gt;count + 1 )                    &amp;&amp;</a>
<a name="ln405">         ( !pool || !FT_ALLOC( new_bytes,</a>
<a name="ln406">                               idx-&gt;data_size + idx-&gt;count ) ) )</a>
<a name="ln407">    {</a>
<a name="ln408">      FT_ULong  n, cur_offset;</a>
<a name="ln409">      FT_ULong  extra = 0;</a>
<a name="ln410">      FT_Byte*  org_bytes = idx-&gt;bytes;</a>
<a name="ln411"> </a>
<a name="ln412"> </a>
<a name="ln413">      /* at this point, `idx-&gt;offsets' can't be NULL */</a>
<a name="ln414">      cur_offset = idx-&gt;offsets[0] - 1;</a>
<a name="ln415"> </a>
<a name="ln416">      /* sanity check */</a>
<a name="ln417">      if ( cur_offset != 0 )</a>
<a name="ln418">      {</a>
<a name="ln419">        FT_TRACE0(( &quot;cff_index_get_pointers:&quot;</a>
<a name="ln420">                    &quot; invalid first offset value %d set to zero\n&quot;,</a>
<a name="ln421">                    cur_offset ));</a>
<a name="ln422">        cur_offset = 0;</a>
<a name="ln423">      }</a>
<a name="ln424"> </a>
<a name="ln425">      if ( !pool )</a>
<a name="ln426">        t[0] = org_bytes + cur_offset;</a>
<a name="ln427">      else</a>
<a name="ln428">        t[0] = new_bytes + cur_offset;</a>
<a name="ln429"> </a>
<a name="ln430">      for ( n = 1; n &lt;= idx-&gt;count; n++ )</a>
<a name="ln431">      {</a>
<a name="ln432">        FT_ULong  next_offset = idx-&gt;offsets[n] - 1;</a>
<a name="ln433"> </a>
<a name="ln434"> </a>
<a name="ln435">        /* two sanity checks for invalid offset tables */</a>
<a name="ln436">        if ( next_offset &lt; cur_offset )</a>
<a name="ln437">          next_offset = cur_offset;</a>
<a name="ln438">        else if ( next_offset &gt; idx-&gt;data_size )</a>
<a name="ln439">          next_offset = idx-&gt;data_size;</a>
<a name="ln440"> </a>
<a name="ln441">        if ( !pool )</a>
<a name="ln442">          t[n] = org_bytes + next_offset;</a>
<a name="ln443">        else</a>
<a name="ln444">        {</a>
<a name="ln445">          t[n] = new_bytes + next_offset + extra;</a>
<a name="ln446"> </a>
<a name="ln447">          if ( next_offset != cur_offset )</a>
<a name="ln448">          {</a>
<a name="ln449">            FT_MEM_COPY( t[n - 1], org_bytes + cur_offset, t[n] - t[n - 1] );</a>
<a name="ln450">            t[n][0] = '\0';</a>
<a name="ln451">            t[n]   += 1;</a>
<a name="ln452">            extra++;</a>
<a name="ln453">          }</a>
<a name="ln454">        }</a>
<a name="ln455"> </a>
<a name="ln456">        cur_offset = next_offset;</a>
<a name="ln457">      }</a>
<a name="ln458">      *table = t;</a>
<a name="ln459"> </a>
<a name="ln460">      if ( pool )</a>
<a name="ln461">        *pool = new_bytes;</a>
<a name="ln462">    }</a>
<a name="ln463"> </a>
<a name="ln464">  Exit:</a>
<a name="ln465">    return error;</a>
<a name="ln466">  }</a>
<a name="ln467"> </a>
<a name="ln468"> </a>
<a name="ln469">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln470">  cff_index_access_element( CFF_Index  idx,</a>
<a name="ln471">                            FT_UInt    element,</a>
<a name="ln472">                            FT_Byte**  pbytes,</a>
<a name="ln473">                            FT_ULong*  pbyte_len )</a>
<a name="ln474">  {</a>
<a name="ln475">    FT_Error  error = FT_Err_Ok;</a>
<a name="ln476"> </a>
<a name="ln477"> </a>
<a name="ln478">    if ( idx &amp;&amp; idx-&gt;count &gt; element )</a>
<a name="ln479">    {</a>
<a name="ln480">      /* compute start and end offsets */</a>
<a name="ln481">      FT_Stream  stream = idx-&gt;stream;</a>
<a name="ln482">      FT_ULong   off1, off2 = 0;</a>
<a name="ln483"> </a>
<a name="ln484"> </a>
<a name="ln485">      /* load offsets from file or the offset table */</a>
<a name="ln486">      if ( !idx-&gt;offsets )</a>
<a name="ln487">      {</a>
<a name="ln488">        FT_ULong  pos = element * idx-&gt;off_size;</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">        if ( FT_STREAM_SEEK( idx-&gt;start + 3 + pos ) )</a>
<a name="ln492">          goto Exit;</a>
<a name="ln493"> </a>
<a name="ln494">        off1 = cff_index_read_offset( idx, &amp;error );</a>
<a name="ln495">        if ( error )</a>
<a name="ln496">          goto Exit;</a>
<a name="ln497"> </a>
<a name="ln498">        if ( off1 != 0 )</a>
<a name="ln499">        {</a>
<a name="ln500">          do</a>
<a name="ln501">          {</a>
<a name="ln502">            element++;</a>
<a name="ln503">            off2 = cff_index_read_offset( idx, &amp;error );</a>
<a name="ln504">          }</a>
<a name="ln505">          while ( off2 == 0 &amp;&amp; element &lt; idx-&gt;count );</a>
<a name="ln506">        }</a>
<a name="ln507">      }</a>
<a name="ln508">      else   /* use offsets table */</a>
<a name="ln509">      {</a>
<a name="ln510">        off1 = idx-&gt;offsets[element];</a>
<a name="ln511">        if ( off1 )</a>
<a name="ln512">        {</a>
<a name="ln513">          do</a>
<a name="ln514">          {</a>
<a name="ln515">            element++;</a>
<a name="ln516">            off2 = idx-&gt;offsets[element];</a>
<a name="ln517"> </a>
<a name="ln518">          } while ( off2 == 0 &amp;&amp; element &lt; idx-&gt;count );</a>
<a name="ln519">        }</a>
<a name="ln520">      }</a>
<a name="ln521"> </a>
<a name="ln522">      /* XXX: should check off2 does not exceed the end of this entry; */</a>
<a name="ln523">      /*      at present, only truncate off2 at the end of this stream */</a>
<a name="ln524">      if ( off2 &gt; stream-&gt;size + 1                    ||</a>
<a name="ln525">           idx-&gt;data_offset &gt; stream-&gt;size - off2 + 1 )</a>
<a name="ln526">      {</a>
<a name="ln527">        FT_ERROR(( &quot;cff_index_access_element:&quot;</a>
<a name="ln528">                   &quot; offset to next entry (%d)&quot;</a>
<a name="ln529">                   &quot; exceeds the end of stream (%d)\n&quot;,</a>
<a name="ln530">                   off2, stream-&gt;size - idx-&gt;data_offset + 1 ));</a>
<a name="ln531">        off2 = stream-&gt;size - idx-&gt;data_offset + 1;</a>
<a name="ln532">      }</a>
<a name="ln533"> </a>
<a name="ln534">      /* access element */</a>
<a name="ln535">      if ( off1 &amp;&amp; off2 &gt; off1 )</a>
<a name="ln536">      {</a>
<a name="ln537">        *pbyte_len = off2 - off1;</a>
<a name="ln538"> </a>
<a name="ln539">        if ( idx-&gt;bytes )</a>
<a name="ln540">        {</a>
<a name="ln541">          /* this index was completely loaded in memory, that's easy */</a>
<a name="ln542">          *pbytes = idx-&gt;bytes + off1 - 1;</a>
<a name="ln543">        }</a>
<a name="ln544">        else</a>
<a name="ln545">        {</a>
<a name="ln546">          /* this index is still on disk/file, access it through a frame */</a>
<a name="ln547">          if ( FT_STREAM_SEEK( idx-&gt;data_offset + off1 - 1 ) ||</a>
<a name="ln548">               FT_FRAME_EXTRACT( off2 - off1, *pbytes )      )</a>
<a name="ln549">            goto Exit;</a>
<a name="ln550">        }</a>
<a name="ln551">      }</a>
<a name="ln552">      else</a>
<a name="ln553">      {</a>
<a name="ln554">        /* empty index element */</a>
<a name="ln555">        *pbytes    = 0;</a>
<a name="ln556">        *pbyte_len = 0;</a>
<a name="ln557">      }</a>
<a name="ln558">    }</a>
<a name="ln559">    else</a>
<a name="ln560">      error = FT_THROW( Invalid_Argument );</a>
<a name="ln561"> </a>
<a name="ln562">  Exit:</a>
<a name="ln563">    return error;</a>
<a name="ln564">  }</a>
<a name="ln565"> </a>
<a name="ln566"> </a>
<a name="ln567">  FT_LOCAL_DEF( void )</a>
<a name="ln568">  cff_index_forget_element( CFF_Index  idx,</a>
<a name="ln569">                            FT_Byte**  pbytes )</a>
<a name="ln570">  {</a>
<a name="ln571">    if ( idx-&gt;bytes == 0 )</a>
<a name="ln572">    {</a>
<a name="ln573">      FT_Stream  stream = idx-&gt;stream;</a>
<a name="ln574"> </a>
<a name="ln575"> </a>
<a name="ln576">      FT_FRAME_RELEASE( *pbytes );</a>
<a name="ln577">    }</a>
<a name="ln578">  }</a>
<a name="ln579"> </a>
<a name="ln580"> </a>
<a name="ln581">  /* get an entry from Name INDEX */</a>
<a name="ln582">  FT_LOCAL_DEF( FT_String* )</a>
<a name="ln583">  cff_index_get_name( CFF_Font  font,</a>
<a name="ln584">                      FT_UInt   element )</a>
<a name="ln585">  {</a>
<a name="ln586">    CFF_Index   idx = &amp;font-&gt;name_index;</a>
<a name="ln587">    FT_Memory   memory = idx-&gt;stream-&gt;memory;</a>
<a name="ln588">    FT_Byte*    bytes;</a>
<a name="ln589">    FT_ULong    byte_len;</a>
<a name="ln590">    FT_Error    error;</a>
<a name="ln591">    FT_String*  name = 0;</a>
<a name="ln592"> </a>
<a name="ln593"> </a>
<a name="ln594">    error = cff_index_access_element( idx, element, &amp;bytes, &amp;byte_len );</a>
<a name="ln595">    if ( error )</a>
<a name="ln596">      goto Exit;</a>
<a name="ln597"> </a>
<a name="ln598">    if ( !FT_ALLOC( name, byte_len + 1 ) )</a>
<a name="ln599">    {</a>
<a name="ln600">      FT_MEM_COPY( name, bytes, byte_len );</a>
<a name="ln601">      name[byte_len] = 0;</a>
<a name="ln602">    }</a>
<a name="ln603">    cff_index_forget_element( idx, &amp;bytes );</a>
<a name="ln604"> </a>
<a name="ln605">  Exit:</a>
<a name="ln606">    return name;</a>
<a name="ln607">  }</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">  /* get an entry from String INDEX */</a>
<a name="ln611">  FT_LOCAL_DEF( FT_String* )</a>
<a name="ln612">  cff_index_get_string( CFF_Font  font,</a>
<a name="ln613">                        FT_UInt   element )</a>
<a name="ln614">  {</a>
<a name="ln615">    return ( element &lt; font-&gt;num_strings )</a>
<a name="ln616">             ? (FT_String*)font-&gt;strings[element]</a>
<a name="ln617">             : NULL;</a>
<a name="ln618">  }</a>
<a name="ln619"> </a>
<a name="ln620"> </a>
<a name="ln621">  FT_LOCAL_DEF( FT_String* )</a>
<a name="ln622">  cff_index_get_sid_string( CFF_Font  font,</a>
<a name="ln623">                            FT_UInt   sid )</a>
<a name="ln624">  {</a>
<a name="ln625">    /* value 0xFFFFU indicates a missing dictionary entry */</a>
<a name="ln626">    if ( sid == 0xFFFFU )</a>
<a name="ln627">      return NULL;</a>
<a name="ln628"> </a>
<a name="ln629">    /* if it is not a standard string, return it */</a>
<a name="ln630">    if ( sid &gt; 390 )</a>
<a name="ln631">      return cff_index_get_string( font, sid - 391 );</a>
<a name="ln632"> </a>
<a name="ln633">    /* CID-keyed CFF fonts don't have glyph names */</a>
<a name="ln634">    if ( !font-&gt;psnames )</a>
<a name="ln635">      return NULL;</a>
<a name="ln636"> </a>
<a name="ln637">    /* this is a standard string */</a>
<a name="ln638">    return (FT_String *)font-&gt;psnames-&gt;adobe_std_strings( sid );</a>
<a name="ln639">  }</a>
<a name="ln640"> </a>
<a name="ln641"> </a>
<a name="ln642">  /*************************************************************************/</a>
<a name="ln643">  /*************************************************************************/</a>
<a name="ln644">  /***                                                                   ***/</a>
<a name="ln645">  /***   FD Select table support                                         ***/</a>
<a name="ln646">  /***                                                                   ***/</a>
<a name="ln647">  /*************************************************************************/</a>
<a name="ln648">  /*************************************************************************/</a>
<a name="ln649"> </a>
<a name="ln650"> </a>
<a name="ln651">  static void</a>
<a name="ln652">  CFF_Done_FD_Select( CFF_FDSelect  fdselect,</a>
<a name="ln653">                      FT_Stream     stream )</a>
<a name="ln654">  {</a>
<a name="ln655">    if ( fdselect-&gt;data )</a>
<a name="ln656">      FT_FRAME_RELEASE( fdselect-&gt;data );</a>
<a name="ln657"> </a>
<a name="ln658">    fdselect-&gt;data_size   = 0;</a>
<a name="ln659">    fdselect-&gt;format      = 0;</a>
<a name="ln660">    fdselect-&gt;range_count = 0;</a>
<a name="ln661">  }</a>
<a name="ln662"> </a>
<a name="ln663"> </a>
<a name="ln664">  static FT_Error</a>
<a name="ln665">  CFF_Load_FD_Select( CFF_FDSelect  fdselect,</a>
<a name="ln666">                      FT_UInt       num_glyphs,</a>
<a name="ln667">                      FT_Stream     stream,</a>
<a name="ln668">                      FT_ULong      offset )</a>
<a name="ln669">  {</a>
<a name="ln670">    FT_Error  error;</a>
<a name="ln671">    FT_Byte   format;</a>
<a name="ln672">    FT_UInt   num_ranges;</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">    /* read format */</a>
<a name="ln676">    if ( FT_STREAM_SEEK( offset ) || FT_READ_BYTE( format ) )</a>
<a name="ln677">      goto Exit;</a>
<a name="ln678"> </a>
<a name="ln679">    fdselect-&gt;format      = format;</a>
<a name="ln680">    fdselect-&gt;cache_count = 0;   /* clear cache */</a>
<a name="ln681"> </a>
<a name="ln682">    switch ( format )</a>
<a name="ln683">    {</a>
<a name="ln684">    case 0:     /* format 0, that's simple */</a>
<a name="ln685">      fdselect-&gt;data_size = num_glyphs;</a>
<a name="ln686">      goto Load_Data;</a>
<a name="ln687"> </a>
<a name="ln688">    case 3:     /* format 3, a tad more complex */</a>
<a name="ln689">      if ( FT_READ_USHORT( num_ranges ) )</a>
<a name="ln690">        goto Exit;</a>
<a name="ln691"> </a>
<a name="ln692">      if ( !num_ranges )</a>
<a name="ln693">      {</a>
<a name="ln694">        FT_TRACE0(( &quot;CFF_Load_FD_Select: empty FDSelect array\n&quot; ));</a>
<a name="ln695">        error = FT_THROW( Invalid_File_Format );</a>
<a name="ln696">        goto Exit;</a>
<a name="ln697">      }</a>
<a name="ln698"> </a>
<a name="ln699">      fdselect-&gt;data_size = num_ranges * 3 + 2;</a>
<a name="ln700"> </a>
<a name="ln701">    Load_Data:</a>
<a name="ln702">      if ( FT_FRAME_EXTRACT( fdselect-&gt;data_size, fdselect-&gt;data ) )</a>
<a name="ln703">        goto Exit;</a>
<a name="ln704">      break;</a>
<a name="ln705"> </a>
<a name="ln706">    default:    /* hmm... that's wrong */</a>
<a name="ln707">      error = FT_THROW( Invalid_File_Format );</a>
<a name="ln708">    }</a>
<a name="ln709"> </a>
<a name="ln710">  Exit:</a>
<a name="ln711">    return error;</a>
<a name="ln712">  }</a>
<a name="ln713"> </a>
<a name="ln714"> </a>
<a name="ln715">  FT_LOCAL_DEF( FT_Byte )</a>
<a name="ln716">  cff_fd_select_get( CFF_FDSelect  fdselect,</a>
<a name="ln717">                     FT_UInt       glyph_index )</a>
<a name="ln718">  {</a>
<a name="ln719">    FT_Byte  fd = 0;</a>
<a name="ln720"> </a>
<a name="ln721"> </a>
<a name="ln722">    switch ( fdselect-&gt;format )</a>
<a name="ln723">    {</a>
<a name="ln724">    case 0:</a>
<a name="ln725">      fd = fdselect-&gt;data[glyph_index];</a>
<a name="ln726">      break;</a>
<a name="ln727"> </a>
<a name="ln728">    case 3:</a>
<a name="ln729">      /* first, compare to the cache */</a>
<a name="ln730">      if ( (FT_UInt)( glyph_index - fdselect-&gt;cache_first ) &lt;</a>
<a name="ln731">                        fdselect-&gt;cache_count )</a>
<a name="ln732">      {</a>
<a name="ln733">        fd = fdselect-&gt;cache_fd;</a>
<a name="ln734">        break;</a>
<a name="ln735">      }</a>
<a name="ln736"> </a>
<a name="ln737">      /* then, look up the ranges array */</a>
<a name="ln738">      {</a>
<a name="ln739">        FT_Byte*  p       = fdselect-&gt;data;</a>
<a name="ln740">        FT_Byte*  p_limit = p + fdselect-&gt;data_size;</a>
<a name="ln741">        FT_Byte   fd2;</a>
<a name="ln742">        FT_UInt   first, limit;</a>
<a name="ln743"> </a>
<a name="ln744"> </a>
<a name="ln745">        first = FT_NEXT_USHORT( p );</a>
<a name="ln746">        do</a>
<a name="ln747">        {</a>
<a name="ln748">          if ( glyph_index &lt; first )</a>
<a name="ln749">            break;</a>
<a name="ln750"> </a>
<a name="ln751">          fd2   = *p++;</a>
<a name="ln752">          limit = FT_NEXT_USHORT( p );</a>
<a name="ln753"> </a>
<a name="ln754">          if ( glyph_index &lt; limit )</a>
<a name="ln755">          {</a>
<a name="ln756">            fd = fd2;</a>
<a name="ln757"> </a>
<a name="ln758">            /* update cache */</a>
<a name="ln759">            fdselect-&gt;cache_first = first;</a>
<a name="ln760">            fdselect-&gt;cache_count = limit - first;</a>
<a name="ln761">            fdselect-&gt;cache_fd    = fd2;</a>
<a name="ln762">            break;</a>
<a name="ln763">          }</a>
<a name="ln764">          first = limit;</a>
<a name="ln765"> </a>
<a name="ln766">        } while ( p &lt; p_limit );</a>
<a name="ln767">      }</a>
<a name="ln768">      break;</a>
<a name="ln769"> </a>
<a name="ln770">    default:</a>
<a name="ln771">      ;</a>
<a name="ln772">    }</a>
<a name="ln773"> </a>
<a name="ln774">    return fd;</a>
<a name="ln775">  }</a>
<a name="ln776"> </a>
<a name="ln777"> </a>
<a name="ln778">  /*************************************************************************/</a>
<a name="ln779">  /*************************************************************************/</a>
<a name="ln780">  /***                                                                   ***/</a>
<a name="ln781">  /***   CFF font support                                                ***/</a>
<a name="ln782">  /***                                                                   ***/</a>
<a name="ln783">  /*************************************************************************/</a>
<a name="ln784">  /*************************************************************************/</a>
<a name="ln785"> </a>
<a name="ln786">  static FT_Error</a>
<a name="ln787">  cff_charset_compute_cids( CFF_Charset  charset,</a>
<a name="ln788">                            FT_UInt      num_glyphs,</a>
<a name="ln789">                            FT_Memory    memory )</a>
<a name="ln790">  {</a>
<a name="ln791">    FT_Error   error   = FT_Err_Ok;</a>
<a name="ln792">    FT_UInt    i;</a>
<a name="ln793">    FT_Long    j;</a>
<a name="ln794">    FT_UShort  max_cid = 0;</a>
<a name="ln795"> </a>
<a name="ln796"> </a>
<a name="ln797">    if ( charset-&gt;max_cid &gt; 0 )</a>
<a name="ln798">      goto Exit;</a>
<a name="ln799"> </a>
<a name="ln800">    for ( i = 0; i &lt; num_glyphs; i++ )</a>
<a name="ln801">    {</a>
<a name="ln802">      if ( charset-&gt;sids[i] &gt; max_cid )</a>
<a name="ln803">        max_cid = charset-&gt;sids[i];</a>
<a name="ln804">    }</a>
<a name="ln805"> </a>
<a name="ln806">    if ( FT_NEW_ARRAY( charset-&gt;cids, (FT_ULong)max_cid + 1 ) )</a>
<a name="ln807">      goto Exit;</a>
<a name="ln808"> </a>
<a name="ln809">    /* When multiple GIDs map to the same CID, we choose the lowest */</a>
<a name="ln810">    /* GID.  This is not described in any spec, but it matches the  */</a>
<a name="ln811">    /* behaviour of recent Acroread versions.                       */</a>
<a name="ln812">    for ( j = (FT_Long)num_glyphs - 1; j &gt;= 0 ; j-- )</a>
<a name="ln813">      charset-&gt;cids[charset-&gt;sids[j]] = (FT_UShort)j;</a>
<a name="ln814"> </a>
<a name="ln815">    charset-&gt;max_cid    = max_cid;</a>
<a name="ln816">    charset-&gt;num_glyphs = num_glyphs;</a>
<a name="ln817"> </a>
<a name="ln818">  Exit:</a>
<a name="ln819">    return error;</a>
<a name="ln820">  }</a>
<a name="ln821"> </a>
<a name="ln822"> </a>
<a name="ln823">  FT_LOCAL_DEF( FT_UInt )</a>
<a name="ln824">  cff_charset_cid_to_gindex( CFF_Charset  charset,</a>
<a name="ln825">                             FT_UInt      cid )</a>
<a name="ln826">  {</a>
<a name="ln827">    FT_UInt  result = 0;</a>
<a name="ln828"> </a>
<a name="ln829"> </a>
<a name="ln830">    if ( cid &lt;= charset-&gt;max_cid )</a>
<a name="ln831">      result = charset-&gt;cids[cid];</a>
<a name="ln832"> </a>
<a name="ln833">    return result;</a>
<a name="ln834">  }</a>
<a name="ln835"> </a>
<a name="ln836"> </a>
<a name="ln837">  static void</a>
<a name="ln838">  cff_charset_free_cids( CFF_Charset  charset,</a>
<a name="ln839">                         FT_Memory    memory )</a>
<a name="ln840">  {</a>
<a name="ln841">    FT_FREE( charset-&gt;cids );</a>
<a name="ln842">    charset-&gt;max_cid = 0;</a>
<a name="ln843">  }</a>
<a name="ln844"> </a>
<a name="ln845"> </a>
<a name="ln846">  static void</a>
<a name="ln847">  cff_charset_done( CFF_Charset  charset,</a>
<a name="ln848">                    FT_Stream    stream )</a>
<a name="ln849">  {</a>
<a name="ln850">    FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln851"> </a>
<a name="ln852"> </a>
<a name="ln853">    cff_charset_free_cids( charset, memory );</a>
<a name="ln854"> </a>
<a name="ln855">    FT_FREE( charset-&gt;sids );</a>
<a name="ln856">    charset-&gt;format = 0;</a>
<a name="ln857">    charset-&gt;offset = 0;</a>
<a name="ln858">  }</a>
<a name="ln859"> </a>
<a name="ln860"> </a>
<a name="ln861">  static FT_Error</a>
<a name="ln862">  cff_charset_load( CFF_Charset  charset,</a>
<a name="ln863">                    FT_UInt      num_glyphs,</a>
<a name="ln864">                    FT_Stream    stream,</a>
<a name="ln865">                    FT_ULong     base_offset,</a>
<a name="ln866">                    FT_ULong     offset,</a>
<a name="ln867">                    FT_Bool      invert )</a>
<a name="ln868">  {</a>
<a name="ln869">    FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln870">    FT_Error   error  = FT_Err_Ok;</a>
<a name="ln871">    FT_UShort  glyph_sid;</a>
<a name="ln872"> </a>
<a name="ln873"> </a>
<a name="ln874">    /* If the the offset is greater than 2, we have to parse the */</a>
<a name="ln875">    /* charset table.                                            */</a>
<a name="ln876">    if ( offset &gt; 2 )</a>
<a name="ln877">    {</a>
<a name="ln878">      FT_UInt  j;</a>
<a name="ln879"> </a>
<a name="ln880"> </a>
<a name="ln881">      charset-&gt;offset = base_offset + offset;</a>
<a name="ln882"> </a>
<a name="ln883">      /* Get the format of the table. */</a>
<a name="ln884">      if ( FT_STREAM_SEEK( charset-&gt;offset ) ||</a>
<a name="ln885">           FT_READ_BYTE( charset-&gt;format )   )</a>
<a name="ln886">        goto Exit;</a>
<a name="ln887"> </a>
<a name="ln888">      /* Allocate memory for sids. */</a>
<a name="ln889">      if ( FT_NEW_ARRAY( charset-&gt;sids, num_glyphs ) )</a>
<a name="ln890">        goto Exit;</a>
<a name="ln891"> </a>
<a name="ln892">      /* assign the .notdef glyph */</a>
<a name="ln893">      charset-&gt;sids[0] = 0;</a>
<a name="ln894"> </a>
<a name="ln895">      switch ( charset-&gt;format )</a>
<a name="ln896">      {</a>
<a name="ln897">      case 0:</a>
<a name="ln898">        if ( num_glyphs &gt; 0 )</a>
<a name="ln899">        {</a>
<a name="ln900">          if ( FT_FRAME_ENTER( ( num_glyphs - 1 ) * 2 ) )</a>
<a name="ln901">            goto Exit;</a>
<a name="ln902"> </a>
<a name="ln903">          for ( j = 1; j &lt; num_glyphs; j++ )</a>
<a name="ln904">            charset-&gt;sids[j] = FT_GET_USHORT();</a>
<a name="ln905"> </a>
<a name="ln906">          FT_FRAME_EXIT();</a>
<a name="ln907">        }</a>
<a name="ln908">        break;</a>
<a name="ln909"> </a>
<a name="ln910">      case 1:</a>
<a name="ln911">      case 2:</a>
<a name="ln912">        {</a>
<a name="ln913">          FT_UInt  nleft;</a>
<a name="ln914">          FT_UInt  i;</a>
<a name="ln915"> </a>
<a name="ln916"> </a>
<a name="ln917">          j = 1;</a>
<a name="ln918"> </a>
<a name="ln919">          while ( j &lt; num_glyphs )</a>
<a name="ln920">          {</a>
<a name="ln921">            /* Read the first glyph sid of the range. */</a>
<a name="ln922">            if ( FT_READ_USHORT( glyph_sid ) )</a>
<a name="ln923">              goto Exit;</a>
<a name="ln924"> </a>
<a name="ln925">            /* Read the number of glyphs in the range.  */</a>
<a name="ln926">            if ( charset-&gt;format == 2 )</a>
<a name="ln927">            {</a>
<a name="ln928">              if ( FT_READ_USHORT( nleft ) )</a>
<a name="ln929">                goto Exit;</a>
<a name="ln930">            }</a>
<a name="ln931">            else</a>
<a name="ln932">            {</a>
<a name="ln933">              if ( FT_READ_BYTE( nleft ) )</a>
<a name="ln934">                goto Exit;</a>
<a name="ln935">            }</a>
<a name="ln936"> </a>
<a name="ln937">            /* try to rescue some of the SIDs if `nleft' is too large */</a>
<a name="ln938">            if ( glyph_sid &gt; 0xFFFFL - nleft )</a>
<a name="ln939">            {</a>
<a name="ln940">              FT_ERROR(( &quot;cff_charset_load: invalid SID range trimmed&quot;</a>
<a name="ln941">                         &quot; nleft=%d -&gt; %d\n&quot;, nleft, 0xFFFFL - glyph_sid ));</a>
<a name="ln942">              nleft = ( FT_UInt )( 0xFFFFL - glyph_sid );</a>
<a name="ln943">            }</a>
<a name="ln944"> </a>
<a name="ln945">            /* Fill in the range of sids -- `nleft + 1' glyphs. */</a>
<a name="ln946">            for ( i = 0; j &lt; num_glyphs &amp;&amp; i &lt;= nleft; i++, j++, glyph_sid++ )</a>
<a name="ln947">              charset-&gt;sids[j] = glyph_sid;</a>
<a name="ln948">          }</a>
<a name="ln949">        }</a>
<a name="ln950">        break;</a>
<a name="ln951"> </a>
<a name="ln952">      default:</a>
<a name="ln953">        FT_ERROR(( &quot;cff_charset_load: invalid table format\n&quot; ));</a>
<a name="ln954">        error = FT_THROW( Invalid_File_Format );</a>
<a name="ln955">        goto Exit;</a>
<a name="ln956">      }</a>
<a name="ln957">    }</a>
<a name="ln958">    else</a>
<a name="ln959">    {</a>
<a name="ln960">      /* Parse default tables corresponding to offset == 0, 1, or 2.  */</a>
<a name="ln961">      /* CFF specification intimates the following:                   */</a>
<a name="ln962">      /*                                                              */</a>
<a name="ln963">      /* In order to use a predefined charset, the following must be  */</a>
<a name="ln964">      /* true: The charset constructed for the glyphs in the font's   */</a>
<a name="ln965">      /* charstrings dictionary must match the predefined charset in  */</a>
<a name="ln966">      /* the first num_glyphs.                                        */</a>
<a name="ln967"> </a>
<a name="ln968">      charset-&gt;offset = offset;  /* record charset type */</a>
<a name="ln969"> </a>
<a name="ln970">      switch ( (FT_UInt)offset )</a>
<a name="ln971">      {</a>
<a name="ln972">      case 0:</a>
<a name="ln973">        if ( num_glyphs &gt; 229 )</a>
<a name="ln974">        {</a>
<a name="ln975">          FT_ERROR(( &quot;cff_charset_load: implicit charset larger than\n&quot;</a>
<a name="ln976">                     &quot;predefined charset (Adobe ISO-Latin)\n&quot; ));</a>
<a name="ln977">          error = FT_THROW( Invalid_File_Format );</a>
<a name="ln978">          goto Exit;</a>
<a name="ln979">        }</a>
<a name="ln980"> </a>
<a name="ln981">        /* Allocate memory for sids. */</a>
<a name="ln982">        if ( FT_NEW_ARRAY( charset-&gt;sids, num_glyphs ) )</a>
<a name="ln983">          goto Exit;</a>
<a name="ln984"> </a>
<a name="ln985">        /* Copy the predefined charset into the allocated memory. */</a>
<a name="ln986">        FT_ARRAY_COPY( charset-&gt;sids, cff_isoadobe_charset, num_glyphs );</a>
<a name="ln987"> </a>
<a name="ln988">        break;</a>
<a name="ln989"> </a>
<a name="ln990">      case 1:</a>
<a name="ln991">        if ( num_glyphs &gt; 166 )</a>
<a name="ln992">        {</a>
<a name="ln993">          FT_ERROR(( &quot;cff_charset_load: implicit charset larger than\n&quot;</a>
<a name="ln994">                     &quot;predefined charset (Adobe Expert)\n&quot; ));</a>
<a name="ln995">          error = FT_THROW( Invalid_File_Format );</a>
<a name="ln996">          goto Exit;</a>
<a name="ln997">        }</a>
<a name="ln998"> </a>
<a name="ln999">        /* Allocate memory for sids. */</a>
<a name="ln1000">        if ( FT_NEW_ARRAY( charset-&gt;sids, num_glyphs ) )</a>
<a name="ln1001">          goto Exit;</a>
<a name="ln1002"> </a>
<a name="ln1003">        /* Copy the predefined charset into the allocated memory.     */</a>
<a name="ln1004">        FT_ARRAY_COPY( charset-&gt;sids, cff_expert_charset, num_glyphs );</a>
<a name="ln1005"> </a>
<a name="ln1006">        break;</a>
<a name="ln1007"> </a>
<a name="ln1008">      case 2:</a>
<a name="ln1009">        if ( num_glyphs &gt; 87 )</a>
<a name="ln1010">        {</a>
<a name="ln1011">          FT_ERROR(( &quot;cff_charset_load: implicit charset larger than\n&quot;</a>
<a name="ln1012">                     &quot;predefined charset (Adobe Expert Subset)\n&quot; ));</a>
<a name="ln1013">          error = FT_THROW( Invalid_File_Format );</a>
<a name="ln1014">          goto Exit;</a>
<a name="ln1015">        }</a>
<a name="ln1016"> </a>
<a name="ln1017">        /* Allocate memory for sids. */</a>
<a name="ln1018">        if ( FT_NEW_ARRAY( charset-&gt;sids, num_glyphs ) )</a>
<a name="ln1019">          goto Exit;</a>
<a name="ln1020"> </a>
<a name="ln1021">        /* Copy the predefined charset into the allocated memory.     */</a>
<a name="ln1022">        FT_ARRAY_COPY( charset-&gt;sids, cff_expertsubset_charset, num_glyphs );</a>
<a name="ln1023"> </a>
<a name="ln1024">        break;</a>
<a name="ln1025"> </a>
<a name="ln1026">      default:</a>
<a name="ln1027">        error = FT_THROW( Invalid_File_Format );</a>
<a name="ln1028">        goto Exit;</a>
<a name="ln1029">      }</a>
<a name="ln1030">    }</a>
<a name="ln1031"> </a>
<a name="ln1032">    /* we have to invert the `sids' array for subsetted CID-keyed fonts */</a>
<a name="ln1033">    if ( invert )</a>
<a name="ln1034">      error = cff_charset_compute_cids( charset, num_glyphs, memory );</a>
<a name="ln1035"> </a>
<a name="ln1036">  Exit:</a>
<a name="ln1037">    /* Clean up if there was an error. */</a>
<a name="ln1038">    if ( error )</a>
<a name="ln1039">    {</a>
<a name="ln1040">      FT_FREE( charset-&gt;sids );</a>
<a name="ln1041">      FT_FREE( charset-&gt;cids );</a>
<a name="ln1042">      charset-&gt;format = 0;</a>
<a name="ln1043">      charset-&gt;offset = 0;</a>
<a name="ln1044">      charset-&gt;sids   = 0;</a>
<a name="ln1045">    }</a>
<a name="ln1046"> </a>
<a name="ln1047">    return error;</a>
<a name="ln1048">  }</a>
<a name="ln1049"> </a>
<a name="ln1050"> </a>
<a name="ln1051">  static void</a>
<a name="ln1052">  cff_encoding_done( CFF_Encoding  encoding )</a>
<a name="ln1053">  {</a>
<a name="ln1054">    encoding-&gt;format = 0;</a>
<a name="ln1055">    encoding-&gt;offset = 0;</a>
<a name="ln1056">    encoding-&gt;count  = 0;</a>
<a name="ln1057">  }</a>
<a name="ln1058"> </a>
<a name="ln1059"> </a>
<a name="ln1060">  static FT_Error</a>
<a name="ln1061">  cff_encoding_load( CFF_Encoding  encoding,</a>
<a name="ln1062">                     CFF_Charset   charset,</a>
<a name="ln1063">                     FT_UInt       num_glyphs,</a>
<a name="ln1064">                     FT_Stream     stream,</a>
<a name="ln1065">                     FT_ULong      base_offset,</a>
<a name="ln1066">                     FT_ULong      offset )</a>
<a name="ln1067">  {</a>
<a name="ln1068">    FT_Error   error = FT_Err_Ok;</a>
<a name="ln1069">    FT_UInt    count;</a>
<a name="ln1070">    FT_UInt    j;</a>
<a name="ln1071">    FT_UShort  glyph_sid;</a>
<a name="ln1072">    FT_UInt    glyph_code;</a>
<a name="ln1073"> </a>
<a name="ln1074"> </a>
<a name="ln1075">    /* Check for charset-&gt;sids.  If we do not have this, we fail. */</a>
<a name="ln1076">    if ( !charset-&gt;sids )</a>
<a name="ln1077">    {</a>
<a name="ln1078">      error = FT_THROW( Invalid_File_Format );</a>
<a name="ln1079">      goto Exit;</a>
<a name="ln1080">    }</a>
<a name="ln1081"> </a>
<a name="ln1082">    /* Zero out the code to gid/sid mappings. */</a>
<a name="ln1083">    for ( j = 0; j &lt; 256; j++ )</a>
<a name="ln1084">    {</a>
<a name="ln1085">      encoding-&gt;sids [j] = 0;</a>
<a name="ln1086">      encoding-&gt;codes[j] = 0;</a>
<a name="ln1087">    }</a>
<a name="ln1088"> </a>
<a name="ln1089">    /* Note: The encoding table in a CFF font is indexed by glyph index;  */</a>
<a name="ln1090">    /* the first encoded glyph index is 1.  Hence, we read the character  */</a>
<a name="ln1091">    /* code (`glyph_code') at index j and make the assignment:            */</a>
<a name="ln1092">    /*                                                                    */</a>
<a name="ln1093">    /*    encoding-&gt;codes[glyph_code] = j + 1                             */</a>
<a name="ln1094">    /*                                                                    */</a>
<a name="ln1095">    /* We also make the assignment:                                       */</a>
<a name="ln1096">    /*                                                                    */</a>
<a name="ln1097">    /*    encoding-&gt;sids[glyph_code] = charset-&gt;sids[j + 1]               */</a>
<a name="ln1098">    /*                                                                    */</a>
<a name="ln1099">    /* This gives us both a code to GID and a code to SID mapping.        */</a>
<a name="ln1100"> </a>
<a name="ln1101">    if ( offset &gt; 1 )</a>
<a name="ln1102">    {</a>
<a name="ln1103">      encoding-&gt;offset = base_offset + offset;</a>
<a name="ln1104"> </a>
<a name="ln1105">      /* we need to parse the table to determine its size */</a>
<a name="ln1106">      if ( FT_STREAM_SEEK( encoding-&gt;offset ) ||</a>
<a name="ln1107">           FT_READ_BYTE( encoding-&gt;format )   ||</a>
<a name="ln1108">           FT_READ_BYTE( count )              )</a>
<a name="ln1109">        goto Exit;</a>
<a name="ln1110"> </a>
<a name="ln1111">      switch ( encoding-&gt;format &amp; 0x7F )</a>
<a name="ln1112">      {</a>
<a name="ln1113">      case 0:</a>
<a name="ln1114">        {</a>
<a name="ln1115">          FT_Byte*  p;</a>
<a name="ln1116"> </a>
<a name="ln1117"> </a>
<a name="ln1118">          /* By convention, GID 0 is always &quot;.notdef&quot; and is never */</a>
<a name="ln1119">          /* coded in the font.  Hence, the number of codes found  */</a>
<a name="ln1120">          /* in the table is `count+1'.                            */</a>
<a name="ln1121">          /*                                                       */</a>
<a name="ln1122">          encoding-&gt;count = count + 1;</a>
<a name="ln1123"> </a>
<a name="ln1124">          if ( FT_FRAME_ENTER( count ) )</a>
<a name="ln1125">            goto Exit;</a>
<a name="ln1126"> </a>
<a name="ln1127">          p = (FT_Byte*)stream-&gt;cursor;</a>
<a name="ln1128"> </a>
<a name="ln1129">          for ( j = 1; j &lt;= count; j++ )</a>
<a name="ln1130">          {</a>
<a name="ln1131">            glyph_code = *p++;</a>
<a name="ln1132"> </a>
<a name="ln1133">            /* Make sure j is not too big. */</a>
<a name="ln1134">            if ( j &lt; num_glyphs )</a>
<a name="ln1135">            {</a>
<a name="ln1136">              /* Assign code to GID mapping. */</a>
<a name="ln1137">              encoding-&gt;codes[glyph_code] = (FT_UShort)j;</a>
<a name="ln1138"> </a>
<a name="ln1139">              /* Assign code to SID mapping. */</a>
<a name="ln1140">              encoding-&gt;sids[glyph_code] = charset-&gt;sids[j];</a>
<a name="ln1141">            }</a>
<a name="ln1142">          }</a>
<a name="ln1143"> </a>
<a name="ln1144">          FT_FRAME_EXIT();</a>
<a name="ln1145">        }</a>
<a name="ln1146">        break;</a>
<a name="ln1147"> </a>
<a name="ln1148">      case 1:</a>
<a name="ln1149">        {</a>
<a name="ln1150">          FT_UInt  nleft;</a>
<a name="ln1151">          FT_UInt  i = 1;</a>
<a name="ln1152">          FT_UInt  k;</a>
<a name="ln1153"> </a>
<a name="ln1154"> </a>
<a name="ln1155">          encoding-&gt;count = 0;</a>
<a name="ln1156"> </a>
<a name="ln1157">          /* Parse the Format1 ranges. */</a>
<a name="ln1158">          for ( j = 0;  j &lt; count; j++, i += nleft )</a>
<a name="ln1159">          {</a>
<a name="ln1160">            /* Read the first glyph code of the range. */</a>
<a name="ln1161">            if ( FT_READ_BYTE( glyph_code ) )</a>
<a name="ln1162">              goto Exit;</a>
<a name="ln1163"> </a>
<a name="ln1164">            /* Read the number of codes in the range. */</a>
<a name="ln1165">            if ( FT_READ_BYTE( nleft ) )</a>
<a name="ln1166">              goto Exit;</a>
<a name="ln1167"> </a>
<a name="ln1168">            /* Increment nleft, so we read `nleft + 1' codes/sids. */</a>
<a name="ln1169">            nleft++;</a>
<a name="ln1170"> </a>
<a name="ln1171">            /* compute max number of character codes */</a>
<a name="ln1172">            if ( (FT_UInt)nleft &gt; encoding-&gt;count )</a>
<a name="ln1173">              encoding-&gt;count = nleft;</a>
<a name="ln1174"> </a>
<a name="ln1175">            /* Fill in the range of codes/sids. */</a>
<a name="ln1176">            for ( k = i; k &lt; nleft + i; k++, glyph_code++ )</a>
<a name="ln1177">            {</a>
<a name="ln1178">              /* Make sure k is not too big. */</a>
<a name="ln1179">              if ( k &lt; num_glyphs &amp;&amp; glyph_code &lt; 256 )</a>
<a name="ln1180">              {</a>
<a name="ln1181">                /* Assign code to GID mapping. */</a>
<a name="ln1182">                encoding-&gt;codes[glyph_code] = (FT_UShort)k;</a>
<a name="ln1183"> </a>
<a name="ln1184">                /* Assign code to SID mapping. */</a>
<a name="ln1185">                encoding-&gt;sids[glyph_code] = charset-&gt;sids[k];</a>
<a name="ln1186">              }</a>
<a name="ln1187">            }</a>
<a name="ln1188">          }</a>
<a name="ln1189"> </a>
<a name="ln1190">          /* simple check; one never knows what can be found in a font */</a>
<a name="ln1191">          if ( encoding-&gt;count &gt; 256 )</a>
<a name="ln1192">            encoding-&gt;count = 256;</a>
<a name="ln1193">        }</a>
<a name="ln1194">        break;</a>
<a name="ln1195"> </a>
<a name="ln1196">      default:</a>
<a name="ln1197">        FT_ERROR(( &quot;cff_encoding_load: invalid table format\n&quot; ));</a>
<a name="ln1198">        error = FT_THROW( Invalid_File_Format );</a>
<a name="ln1199">        goto Exit;</a>
<a name="ln1200">      }</a>
<a name="ln1201"> </a>
<a name="ln1202">      /* Parse supplemental encodings, if any. */</a>
<a name="ln1203">      if ( encoding-&gt;format &amp; 0x80 )</a>
<a name="ln1204">      {</a>
<a name="ln1205">        FT_UInt  gindex;</a>
<a name="ln1206"> </a>
<a name="ln1207"> </a>
<a name="ln1208">        /* count supplements */</a>
<a name="ln1209">        if ( FT_READ_BYTE( count ) )</a>
<a name="ln1210">          goto Exit;</a>
<a name="ln1211"> </a>
<a name="ln1212">        for ( j = 0; j &lt; count; j++ )</a>
<a name="ln1213">        {</a>
<a name="ln1214">          /* Read supplemental glyph code. */</a>
<a name="ln1215">          if ( FT_READ_BYTE( glyph_code ) )</a>
<a name="ln1216">            goto Exit;</a>
<a name="ln1217"> </a>
<a name="ln1218">          /* Read the SID associated with this glyph code. */</a>
<a name="ln1219">          if ( FT_READ_USHORT( glyph_sid ) )</a>
<a name="ln1220">            goto Exit;</a>
<a name="ln1221"> </a>
<a name="ln1222">          /* Assign code to SID mapping. */</a>
<a name="ln1223">          encoding-&gt;sids[glyph_code] = glyph_sid;</a>
<a name="ln1224"> </a>
<a name="ln1225">          /* First, look up GID which has been assigned to */</a>
<a name="ln1226">          /* SID glyph_sid.                                */</a>
<a name="ln1227">          for ( gindex = 0; gindex &lt; num_glyphs; gindex++ )</a>
<a name="ln1228">          {</a>
<a name="ln1229">            if ( charset-&gt;sids[gindex] == glyph_sid )</a>
<a name="ln1230">            {</a>
<a name="ln1231">              encoding-&gt;codes[glyph_code] = (FT_UShort)gindex;</a>
<a name="ln1232">              break;</a>
<a name="ln1233">            }</a>
<a name="ln1234">          }</a>
<a name="ln1235">        }</a>
<a name="ln1236">      }</a>
<a name="ln1237">    }</a>
<a name="ln1238">    else</a>
<a name="ln1239">    {</a>
<a name="ln1240">      /* We take into account the fact a CFF font can use a predefined */</a>
<a name="ln1241">      /* encoding without containing all of the glyphs encoded by this */</a>
<a name="ln1242">      /* encoding (see the note at the end of section 12 in the CFF    */</a>
<a name="ln1243">      /* specification).                                               */</a>
<a name="ln1244"> </a>
<a name="ln1245">      switch ( (FT_UInt)offset )</a>
<a name="ln1246">      {</a>
<a name="ln1247">      case 0:</a>
<a name="ln1248">        /* First, copy the code to SID mapping. */</a>
<a name="ln1249">        FT_ARRAY_COPY( encoding-&gt;sids, cff_standard_encoding, 256 );</a>
<a name="ln1250">        goto Populate;</a>
<a name="ln1251"> </a>
<a name="ln1252">      case 1:</a>
<a name="ln1253">        /* First, copy the code to SID mapping. */</a>
<a name="ln1254">        FT_ARRAY_COPY( encoding-&gt;sids, cff_expert_encoding, 256 );</a>
<a name="ln1255"> </a>
<a name="ln1256">      Populate:</a>
<a name="ln1257">        /* Construct code to GID mapping from code to SID mapping */</a>
<a name="ln1258">        /* and charset.                                           */</a>
<a name="ln1259"> </a>
<a name="ln1260">        encoding-&gt;count = 0;</a>
<a name="ln1261"> </a>
<a name="ln1262">        error = cff_charset_compute_cids( charset, num_glyphs,</a>
<a name="ln1263">                                          stream-&gt;memory );</a>
<a name="ln1264">        if ( error )</a>
<a name="ln1265">          goto Exit;</a>
<a name="ln1266"> </a>
<a name="ln1267">        for ( j = 0; j &lt; 256; j++ )</a>
<a name="ln1268">        {</a>
<a name="ln1269">          FT_UInt  sid = encoding-&gt;sids[j];</a>
<a name="ln1270">          FT_UInt  gid = 0;</a>
<a name="ln1271"> </a>
<a name="ln1272"> </a>
<a name="ln1273">          if ( sid )</a>
<a name="ln1274">            gid = cff_charset_cid_to_gindex( charset, sid );</a>
<a name="ln1275"> </a>
<a name="ln1276">          if ( gid != 0 )</a>
<a name="ln1277">          {</a>
<a name="ln1278">            encoding-&gt;codes[j] = (FT_UShort)gid;</a>
<a name="ln1279">            encoding-&gt;count    = j + 1;</a>
<a name="ln1280">          }</a>
<a name="ln1281">          else</a>
<a name="ln1282">          {</a>
<a name="ln1283">            encoding-&gt;codes[j] = 0;</a>
<a name="ln1284">            encoding-&gt;sids [j] = 0;</a>
<a name="ln1285">          }</a>
<a name="ln1286">        }</a>
<a name="ln1287">        break;</a>
<a name="ln1288"> </a>
<a name="ln1289">      default:</a>
<a name="ln1290">        FT_ERROR(( &quot;cff_encoding_load: invalid table format\n&quot; ));</a>
<a name="ln1291">        error = FT_THROW( Invalid_File_Format );</a>
<a name="ln1292">        goto Exit;</a>
<a name="ln1293">      }</a>
<a name="ln1294">    }</a>
<a name="ln1295"> </a>
<a name="ln1296">  Exit:</a>
<a name="ln1297"> </a>
<a name="ln1298">    /* Clean up if there was an error. */</a>
<a name="ln1299">    return error;</a>
<a name="ln1300">  }</a>
<a name="ln1301"> </a>
<a name="ln1302"> </a>
<a name="ln1303">  static FT_Error</a>
<a name="ln1304">  cff_subfont_load( CFF_SubFont  font,</a>
<a name="ln1305">                    CFF_Index    idx,</a>
<a name="ln1306">                    FT_UInt      font_index,</a>
<a name="ln1307">                    FT_Stream    stream,</a>
<a name="ln1308">                    FT_ULong     base_offset,</a>
<a name="ln1309">                    FT_Library   library )</a>
<a name="ln1310">  {</a>
<a name="ln1311">    FT_Error         error;</a>
<a name="ln1312">    CFF_ParserRec    parser;</a>
<a name="ln1313">    FT_Byte*         dict = NULL;</a>
<a name="ln1314">    FT_ULong         dict_len;</a>
<a name="ln1315">    CFF_FontRecDict  top  = &amp;font-&gt;font_dict;</a>
<a name="ln1316">    CFF_Private      priv = &amp;font-&gt;private_dict;</a>
<a name="ln1317"> </a>
<a name="ln1318"> </a>
<a name="ln1319">    cff_parser_init( &amp;parser, CFF_CODE_TOPDICT, &amp;font-&gt;font_dict, library );</a>
<a name="ln1320"> </a>
<a name="ln1321">    /* set defaults */</a>
<a name="ln1322">    FT_MEM_ZERO( top, sizeof ( *top ) );</a>
<a name="ln1323"> </a>
<a name="ln1324">    top-&gt;underline_position  = -( 100L &lt;&lt; 16 );</a>
<a name="ln1325">    top-&gt;underline_thickness = 50L &lt;&lt; 16;</a>
<a name="ln1326">    top-&gt;charstring_type     = 2;</a>
<a name="ln1327">    top-&gt;font_matrix.xx      = 0x10000L;</a>
<a name="ln1328">    top-&gt;font_matrix.yy      = 0x10000L;</a>
<a name="ln1329">    top-&gt;cid_count           = 8720;</a>
<a name="ln1330"> </a>
<a name="ln1331">    /* we use the implementation specific SID value 0xFFFF to indicate */</a>
<a name="ln1332">    /* missing entries                                                 */</a>
<a name="ln1333">    top-&gt;version             = 0xFFFFU;</a>
<a name="ln1334">    top-&gt;notice              = 0xFFFFU;</a>
<a name="ln1335">    top-&gt;copyright           = 0xFFFFU;</a>
<a name="ln1336">    top-&gt;full_name           = 0xFFFFU;</a>
<a name="ln1337">    top-&gt;family_name         = 0xFFFFU;</a>
<a name="ln1338">    top-&gt;weight              = 0xFFFFU;</a>
<a name="ln1339">    top-&gt;embedded_postscript = 0xFFFFU;</a>
<a name="ln1340"> </a>
<a name="ln1341">    top-&gt;cid_registry        = 0xFFFFU;</a>
<a name="ln1342">    top-&gt;cid_ordering        = 0xFFFFU;</a>
<a name="ln1343">    top-&gt;cid_font_name       = 0xFFFFU;</a>
<a name="ln1344"> </a>
<a name="ln1345">    error = cff_index_access_element( idx, font_index, &amp;dict, &amp;dict_len );</a>
<a name="ln1346">    if ( !error )</a>
<a name="ln1347">    {</a>
<a name="ln1348">      FT_TRACE4(( &quot; top dictionary:\n&quot; ));</a>
<a name="ln1349">      error = cff_parser_run( &amp;parser, dict, dict + dict_len );</a>
<a name="ln1350">    }</a>
<a name="ln1351"> </a>
<a name="ln1352">    cff_index_forget_element( idx, &amp;dict );</a>
<a name="ln1353"> </a>
<a name="ln1354">    if ( error )</a>
<a name="ln1355">      goto Exit;</a>
<a name="ln1356"> </a>
<a name="ln1357">    /* if it is a CID font, we stop there */</a>
<a name="ln1358">    if ( top-&gt;cid_registry != 0xFFFFU )</a>
<a name="ln1359">      goto Exit;</a>
<a name="ln1360"> </a>
<a name="ln1361">    /* parse the private dictionary, if any */</a>
<a name="ln1362">    if ( top-&gt;private_offset &amp;&amp; top-&gt;private_size )</a>
<a name="ln1363">    {</a>
<a name="ln1364">      /* set defaults */</a>
<a name="ln1365">      FT_MEM_ZERO( priv, sizeof ( *priv ) );</a>
<a name="ln1366"> </a>
<a name="ln1367">      priv-&gt;blue_shift       = 7;</a>
<a name="ln1368">      priv-&gt;blue_fuzz        = 1;</a>
<a name="ln1369">      priv-&gt;lenIV            = -1;</a>
<a name="ln1370">      priv-&gt;expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );</a>
<a name="ln1371">      priv-&gt;blue_scale       = (FT_Fixed)( 0.039625 * 0x10000L * 1000 );</a>
<a name="ln1372"> </a>
<a name="ln1373">      cff_parser_init( &amp;parser, CFF_CODE_PRIVATE, priv, library );</a>
<a name="ln1374"> </a>
<a name="ln1375">      if ( FT_STREAM_SEEK( base_offset + font-&gt;font_dict.private_offset ) ||</a>
<a name="ln1376">           FT_FRAME_ENTER( font-&gt;font_dict.private_size )                 )</a>
<a name="ln1377">        goto Exit;</a>
<a name="ln1378"> </a>
<a name="ln1379">      FT_TRACE4(( &quot; private dictionary:\n&quot; ));</a>
<a name="ln1380">      error = cff_parser_run( &amp;parser,</a>
<a name="ln1381">                              (FT_Byte*)stream-&gt;cursor,</a>
<a name="ln1382">                              (FT_Byte*)stream-&gt;limit );</a>
<a name="ln1383">      FT_FRAME_EXIT();</a>
<a name="ln1384">      if ( error )</a>
<a name="ln1385">        goto Exit;</a>
<a name="ln1386"> </a>
<a name="ln1387">      /* ensure that `num_blue_values' is even */</a>
<a name="ln1388">      priv-&gt;num_blue_values &amp;= ~1;</a>
<a name="ln1389">    }</a>
<a name="ln1390"> </a>
<a name="ln1391">    /* read the local subrs, if any */</a>
<a name="ln1392">    if ( priv-&gt;local_subrs_offset )</a>
<a name="ln1393">    {</a>
<a name="ln1394">      if ( FT_STREAM_SEEK( base_offset + top-&gt;private_offset +</a>
<a name="ln1395">                           priv-&gt;local_subrs_offset ) )</a>
<a name="ln1396">        goto Exit;</a>
<a name="ln1397"> </a>
<a name="ln1398">      error = cff_index_init( &amp;font-&gt;local_subrs_index, stream, 1 );</a>
<a name="ln1399">      if ( error )</a>
<a name="ln1400">        goto Exit;</a>
<a name="ln1401"> </a>
<a name="ln1402">      error = cff_index_get_pointers( &amp;font-&gt;local_subrs_index,</a>
<a name="ln1403">                                      &amp;font-&gt;local_subrs, NULL );</a>
<a name="ln1404">      if ( error )</a>
<a name="ln1405">        goto Exit;</a>
<a name="ln1406">    }</a>
<a name="ln1407"> </a>
<a name="ln1408">  Exit:</a>
<a name="ln1409">    return error;</a>
<a name="ln1410">  }</a>
<a name="ln1411"> </a>
<a name="ln1412"> </a>
<a name="ln1413">  static void</a>
<a name="ln1414">  cff_subfont_done( FT_Memory    memory,</a>
<a name="ln1415">                    CFF_SubFont  subfont )</a>
<a name="ln1416">  {</a>
<a name="ln1417">    if ( subfont )</a>
<a name="ln1418">    {</a>
<a name="ln1419">      cff_index_done( &amp;subfont-&gt;local_subrs_index );</a>
<a name="ln1420">      FT_FREE( subfont-&gt;local_subrs );</a>
<a name="ln1421">    }</a>
<a name="ln1422">  }</a>
<a name="ln1423"> </a>
<a name="ln1424"> </a>
<a name="ln1425">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln1426">  cff_font_load( FT_Library library,</a>
<a name="ln1427">                 FT_Stream  stream,</a>
<a name="ln1428">                 FT_Int     face_index,</a>
<a name="ln1429">                 CFF_Font   font,</a>
<a name="ln1430">                 FT_Bool    pure_cff )</a>
<a name="ln1431">  {</a>
<a name="ln1432">    static const FT_Frame_Field  cff_header_fields[] =</a>
<a name="ln1433">    {</a>
<a name="ln1434">#undef  FT_STRUCTURE</a>
<a name="ln1435">#define FT_STRUCTURE  CFF_FontRec</a>
<a name="ln1436"> </a>
<a name="ln1437">      FT_FRAME_START( 4 ),</a>
<a name="ln1438">        FT_FRAME_BYTE( version_major ),</a>
<a name="ln1439">        FT_FRAME_BYTE( version_minor ),</a>
<a name="ln1440">        FT_FRAME_BYTE( header_size ),</a>
<a name="ln1441">        FT_FRAME_BYTE( absolute_offsize ),</a>
<a name="ln1442">      FT_FRAME_END</a>
<a name="ln1443">    };</a>
<a name="ln1444"> </a>
<a name="ln1445">    FT_Error         error;</a>
<a name="ln1446">    FT_Memory        memory = stream-&gt;memory;</a>
<a name="ln1447">    FT_ULong         base_offset;</a>
<a name="ln1448">    CFF_FontRecDict  dict;</a>
<a name="ln1449">    CFF_IndexRec     string_index;</a>
<a name="ln1450">    FT_UInt          subfont_index;</a>
<a name="ln1451"> </a>
<a name="ln1452"> </a>
<a name="ln1453">    FT_ZERO( font );</a>
<a name="ln1454">    FT_ZERO( &amp;string_index );</a>
<a name="ln1455"> </a>
<a name="ln1456">    font-&gt;stream = stream;</a>
<a name="ln1457">    font-&gt;memory = memory;</a>
<a name="ln1458">    dict         = &amp;font-&gt;top_font.font_dict;</a>
<a name="ln1459">    base_offset  = FT_STREAM_POS();</a>
<a name="ln1460"> </a>
<a name="ln1461">    /* read CFF font header */</a>
<a name="ln1462">    if ( FT_STREAM_READ_FIELDS( cff_header_fields, font ) )</a>
<a name="ln1463">      goto Exit;</a>
<a name="ln1464"> </a>
<a name="ln1465">    /* check format */</a>
<a name="ln1466">    if ( font-&gt;version_major   != 1 ||</a>
<a name="ln1467">         font-&gt;header_size      &lt; 4 ||</a>
<a name="ln1468">         font-&gt;absolute_offsize &gt; 4 )</a>
<a name="ln1469">    {</a>
<a name="ln1470">      FT_TRACE2(( &quot;  not a CFF font header\n&quot; ));</a>
<a name="ln1471">      error = FT_THROW( Unknown_File_Format );</a>
<a name="ln1472">      goto Exit;</a>
<a name="ln1473">    }</a>
<a name="ln1474"> </a>
<a name="ln1475">    /* skip the rest of the header */</a>
<a name="ln1476">    if ( FT_STREAM_SKIP( font-&gt;header_size - 4 ) )</a>
<a name="ln1477">      goto Exit;</a>
<a name="ln1478"> </a>
<a name="ln1479">    /* read the name, top dict, string and global subrs index */</a>
<a name="ln1480">    if ( FT_SET_ERROR( cff_index_init( &amp;font-&gt;name_index,</a>
<a name="ln1481">                                       stream, 0 ) )                  ||</a>
<a name="ln1482">         FT_SET_ERROR( cff_index_init( &amp;font-&gt;font_dict_index,</a>
<a name="ln1483">                                       stream, 0 ) )                  ||</a>
<a name="ln1484">         FT_SET_ERROR( cff_index_init( &amp;string_index,</a>
<a name="ln1485">                                       stream, 1 ) )                  ||</a>
<a name="ln1486">         FT_SET_ERROR( cff_index_init( &amp;font-&gt;global_subrs_index,</a>
<a name="ln1487">                                       stream, 1 ) )                  ||</a>
<a name="ln1488">         FT_SET_ERROR( cff_index_get_pointers( &amp;string_index,</a>
<a name="ln1489">                                               &amp;font-&gt;strings,</a>
<a name="ln1490">                                               &amp;font-&gt;string_pool ) ) )</a>
<a name="ln1491">      goto Exit;</a>
<a name="ln1492"> </a>
<a name="ln1493">    font-&gt;num_strings = string_index.count;</a>
<a name="ln1494"> </a>
<a name="ln1495">    if ( pure_cff )</a>
<a name="ln1496">    {</a>
<a name="ln1497">      /* well, we don't really forget the `disabled' fonts... */</a>
<a name="ln1498">      subfont_index = (FT_UInt)( face_index &amp; 0xFFFF );</a>
<a name="ln1499"> </a>
<a name="ln1500">      if ( face_index &gt; 0 &amp;&amp; subfont_index &gt;= font-&gt;name_index.count )</a>
<a name="ln1501">      {</a>
<a name="ln1502">        FT_ERROR(( &quot;cff_font_load:&quot;</a>
<a name="ln1503">                   &quot; invalid subfont index for pure CFF font (%d)\n&quot;,</a>
<a name="ln1504">                   subfont_index ));</a>
<a name="ln1505">        error = FT_THROW( Invalid_Argument );</a>
<a name="ln1506">        goto Exit;</a>
<a name="ln1507">      }</a>
<a name="ln1508"> </a>
<a name="ln1509">      font-&gt;num_faces = font-&gt;name_index.count;</a>
<a name="ln1510">    }</a>
<a name="ln1511">    else</a>
<a name="ln1512">    {</a>
<a name="ln1513">      subfont_index = 0;</a>
<a name="ln1514"> </a>
<a name="ln1515">      if ( font-&gt;name_index.count &gt; 1 )</a>
<a name="ln1516">      {</a>
<a name="ln1517">        FT_ERROR(( &quot;cff_font_load:&quot;</a>
<a name="ln1518">                   &quot; invalid CFF font with multiple subfonts\n&quot;</a>
<a name="ln1519">                   &quot;              &quot;</a>
<a name="ln1520">                   &quot; in SFNT wrapper\n&quot; ));</a>
<a name="ln1521">        error = FT_THROW( Invalid_File_Format );</a>
<a name="ln1522">        goto Exit;</a>
<a name="ln1523">      }</a>
<a name="ln1524">    }</a>
<a name="ln1525"> </a>
<a name="ln1526">    /* in case of a font format check, simply exit now */</a>
<a name="ln1527">    if ( face_index &lt; 0 )</a>
<a name="ln1528">      goto Exit;</a>
<a name="ln1529"> </a>
<a name="ln1530">    /* now, parse the top-level font dictionary */</a>
<a name="ln1531">    FT_TRACE4(( &quot;parsing top-level\n&quot; ));</a>
<a name="ln1532">    error = cff_subfont_load( &amp;font-&gt;top_font,</a>
<a name="ln1533">                              &amp;font-&gt;font_dict_index,</a>
<a name="ln1534">                              subfont_index,</a>
<a name="ln1535">                              stream,</a>
<a name="ln1536">                              base_offset,</a>
<a name="ln1537">                              library );</a>
<a name="ln1538">    if ( error )</a>
<a name="ln1539">      goto Exit;</a>
<a name="ln1540"> </a>
<a name="ln1541">    if ( FT_STREAM_SEEK( base_offset + dict-&gt;charstrings_offset ) )</a>
<a name="ln1542">      goto Exit;</a>
<a name="ln1543"> </a>
<a name="ln1544">    error = cff_index_init( &amp;font-&gt;charstrings_index, stream, 0 );</a>
<a name="ln1545">    if ( error )</a>
<a name="ln1546">      goto Exit;</a>
<a name="ln1547"> </a>
<a name="ln1548">    /* now, check for a CID font */</a>
<a name="ln1549">    if ( dict-&gt;cid_registry != 0xFFFFU )</a>
<a name="ln1550">    {</a>
<a name="ln1551">      CFF_IndexRec  fd_index;</a>
<a name="ln1552">      CFF_SubFont   sub = NULL;</a>
<a name="ln1553">      FT_UInt       idx;</a>
<a name="ln1554"> </a>
<a name="ln1555"> </a>
<a name="ln1556">      /* this is a CID-keyed font, we must now allocate a table of */</a>
<a name="ln1557">      /* sub-fonts, then load each of them separately              */</a>
<a name="ln1558">      if ( FT_STREAM_SEEK( base_offset + dict-&gt;cid_fd_array_offset ) )</a>
<a name="ln1559">        goto Exit;</a>
<a name="ln1560"> </a>
<a name="ln1561">      error = cff_index_init( &amp;fd_index, stream, 0 );</a>
<a name="ln1562">      if ( error )</a>
<a name="ln1563">        goto Exit;</a>
<a name="ln1564"> </a>
<a name="ln1565">      if ( fd_index.count &gt; CFF_MAX_CID_FONTS )</a>
<a name="ln1566">      {</a>
<a name="ln1567">        FT_TRACE0(( &quot;cff_font_load: FD array too large in CID font\n&quot; ));</a>
<a name="ln1568">        goto Fail_CID;</a>
<a name="ln1569">      }</a>
<a name="ln1570"> </a>
<a name="ln1571">      /* allocate &amp; read each font dict independently */</a>
<a name="ln1572">      font-&gt;num_subfonts = fd_index.count;</a>
<a name="ln1573">      if ( FT_NEW_ARRAY( sub, fd_index.count ) )</a>
<a name="ln1574">        goto Fail_CID;</a>
<a name="ln1575"> </a>
<a name="ln1576">      /* set up pointer table */</a>
<a name="ln1577">      for ( idx = 0; idx &lt; fd_index.count; idx++ )</a>
<a name="ln1578">        font-&gt;subfonts[idx] = sub + idx;</a>
<a name="ln1579"> </a>
<a name="ln1580">      /* now load each subfont independently */</a>
<a name="ln1581">      for ( idx = 0; idx &lt; fd_index.count; idx++ )</a>
<a name="ln1582">      {</a>
<a name="ln1583">        sub = font-&gt;subfonts[idx];</a>
<a name="ln1584">        FT_TRACE4(( &quot;parsing subfont %u\n&quot;, idx ));</a>
<a name="ln1585">        error = cff_subfont_load( sub, &amp;fd_index, idx,</a>
<a name="ln1586">                                  stream, base_offset, library );</a>
<a name="ln1587">        if ( error )</a>
<a name="ln1588">          goto Fail_CID;</a>
<a name="ln1589">      }</a>
<a name="ln1590"> </a>
<a name="ln1591">      /* now load the FD Select array */</a>
<a name="ln1592">      error = CFF_Load_FD_Select( &amp;font-&gt;fd_select,</a>
<a name="ln1593">                                  font-&gt;charstrings_index.count,</a>
<a name="ln1594">                                  stream,</a>
<a name="ln1595">                                  base_offset + dict-&gt;cid_fd_select_offset );</a>
<a name="ln1596"> </a>
<a name="ln1597">    Fail_CID:</a>
<a name="ln1598">      cff_index_done( &amp;fd_index );</a>
<a name="ln1599"> </a>
<a name="ln1600">      if ( error )</a>
<a name="ln1601">        goto Exit;</a>
<a name="ln1602">    }</a>
<a name="ln1603">    else</a>
<a name="ln1604">      font-&gt;num_subfonts = 0;</a>
<a name="ln1605"> </a>
<a name="ln1606">    /* read the charstrings index now */</a>
<a name="ln1607">    if ( dict-&gt;charstrings_offset == 0 )</a>
<a name="ln1608">    {</a>
<a name="ln1609">      FT_ERROR(( &quot;cff_font_load: no charstrings offset\n&quot; ));</a>
<a name="ln1610">      error = FT_THROW( Invalid_File_Format );</a>
<a name="ln1611">      goto Exit;</a>
<a name="ln1612">    }</a>
<a name="ln1613"> </a>
<a name="ln1614">    font-&gt;num_glyphs = font-&gt;charstrings_index.count;</a>
<a name="ln1615"> </a>
<a name="ln1616">    error = cff_index_get_pointers( &amp;font-&gt;global_subrs_index,</a>
<a name="ln1617">                                    &amp;font-&gt;global_subrs, NULL );</a>
<a name="ln1618"> </a>
<a name="ln1619">    if ( error )</a>
<a name="ln1620">      goto Exit;</a>
<a name="ln1621"> </a>
<a name="ln1622">    /* read the Charset and Encoding tables if available */</a>
<a name="ln1623">    if ( font-&gt;num_glyphs &gt; 0 )</a>
<a name="ln1624">    {</a>
<a name="ln1625">      FT_Bool  invert = FT_BOOL( dict-&gt;cid_registry != 0xFFFFU &amp;&amp; pure_cff );</a>
<a name="ln1626"> </a>
<a name="ln1627"> </a>
<a name="ln1628">      error = cff_charset_load( &amp;font-&gt;charset, font-&gt;num_glyphs, stream,</a>
<a name="ln1629">                                base_offset, dict-&gt;charset_offset, invert );</a>
<a name="ln1630">      if ( error )</a>
<a name="ln1631">        goto Exit;</a>
<a name="ln1632"> </a>
<a name="ln1633">      /* CID-keyed CFFs don't have an encoding */</a>
<a name="ln1634">      if ( dict-&gt;cid_registry == 0xFFFFU )</a>
<a name="ln1635">      {</a>
<a name="ln1636">        error = cff_encoding_load( &amp;font-&gt;encoding,</a>
<a name="ln1637">                                   &amp;font-&gt;charset,</a>
<a name="ln1638">                                   font-&gt;num_glyphs,</a>
<a name="ln1639">                                   stream,</a>
<a name="ln1640">                                   base_offset,</a>
<a name="ln1641">                                   dict-&gt;encoding_offset );</a>
<a name="ln1642">        if ( error )</a>
<a name="ln1643">          goto Exit;</a>
<a name="ln1644">      }</a>
<a name="ln1645">    }</a>
<a name="ln1646"> </a>
<a name="ln1647">    /* get the font name (/CIDFontName for CID-keyed fonts, */</a>
<a name="ln1648">    /* /FontName otherwise)                                 */</a>
<a name="ln1649">    font-&gt;font_name = cff_index_get_name( font, subfont_index );</a>
<a name="ln1650"> </a>
<a name="ln1651">  Exit:</a>
<a name="ln1652">    cff_index_done( &amp;string_index );</a>
<a name="ln1653"> </a>
<a name="ln1654">    return error;</a>
<a name="ln1655">  }</a>
<a name="ln1656"> </a>
<a name="ln1657"> </a>
<a name="ln1658">  FT_LOCAL_DEF( void )</a>
<a name="ln1659">  cff_font_done( CFF_Font  font )</a>
<a name="ln1660">  {</a>
<a name="ln1661">    FT_Memory  memory = font-&gt;memory;</a>
<a name="ln1662">    FT_UInt    idx;</a>
<a name="ln1663"> </a>
<a name="ln1664"> </a>
<a name="ln1665">    cff_index_done( &amp;font-&gt;global_subrs_index );</a>
<a name="ln1666">    cff_index_done( &amp;font-&gt;font_dict_index );</a>
<a name="ln1667">    cff_index_done( &amp;font-&gt;name_index );</a>
<a name="ln1668">    cff_index_done( &amp;font-&gt;charstrings_index );</a>
<a name="ln1669"> </a>
<a name="ln1670">    /* release font dictionaries, but only if working with */</a>
<a name="ln1671">    /* a CID keyed CFF font                                */</a>
<a name="ln1672">    if ( font-&gt;num_subfonts &gt; 0 )</a>
<a name="ln1673">    {</a>
<a name="ln1674">      for ( idx = 0; idx &lt; font-&gt;num_subfonts; idx++ )</a>
<a name="ln1675">        cff_subfont_done( memory, font-&gt;subfonts[idx] );</a>
<a name="ln1676"> </a>
<a name="ln1677">      /* the subfonts array has been allocated as a single block */</a>
<a name="ln1678">      FT_FREE( font-&gt;subfonts[0] );</a>
<a name="ln1679">    }</a>
<a name="ln1680"> </a>
<a name="ln1681">    cff_encoding_done( &amp;font-&gt;encoding );</a>
<a name="ln1682">    cff_charset_done( &amp;font-&gt;charset, font-&gt;stream );</a>
<a name="ln1683"> </a>
<a name="ln1684">    cff_subfont_done( memory, &amp;font-&gt;top_font );</a>
<a name="ln1685"> </a>
<a name="ln1686">    CFF_Done_FD_Select( &amp;font-&gt;fd_select, font-&gt;stream );</a>
<a name="ln1687"> </a>
<a name="ln1688">    FT_FREE( font-&gt;font_info );</a>
<a name="ln1689"> </a>
<a name="ln1690">    FT_FREE( font-&gt;font_name );</a>
<a name="ln1691">    FT_FREE( font-&gt;global_subrs );</a>
<a name="ln1692">    FT_FREE( font-&gt;strings );</a>
<a name="ln1693">    FT_FREE( font-&gt;string_pool );</a>
<a name="ln1694"> </a>
<a name="ln1695">    if ( font-&gt;cf2_instance.finalizer )</a>
<a name="ln1696">    {</a>
<a name="ln1697">      font-&gt;cf2_instance.finalizer( font-&gt;cf2_instance.data );</a>
<a name="ln1698">      FT_FREE( font-&gt;cf2_instance.data );</a>
<a name="ln1699">    }</a>
<a name="ln1700">  }</a>
<a name="ln1701"> </a>
<a name="ln1702"> </a>
<a name="ln1703">/* END */</a>

</code></pre>
<div class="balloon" rel="259"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'count + 1' operator to the 'FT_ULong' type, not the result.</p></div>
<div class="balloon" rel="335"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'idx->count + 1' operator to the 'FT_ULong' type, not the result.</p></div>
<div class="balloon" rel="1044"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'charset->sids' variable was assigned the same value.</p></div>
<div class="balloon" rel="1358"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'top->cid_registry != 0xFFFFU' is always false.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
