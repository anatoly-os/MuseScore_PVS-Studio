
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>note.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2012 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">/**</a>
<a name="ln14"> \file</a>
<a name="ln15"> Implementation of classes Note and ShadowNote.</a>
<a name="ln16">*/</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;assert.h&gt;</a>
<a name="ln19"> </a>
<a name="ln20">#include &quot;note.h&quot;</a>
<a name="ln21">#include &quot;score.h&quot;</a>
<a name="ln22">#include &quot;chord.h&quot;</a>
<a name="ln23">#include &quot;sym.h&quot;</a>
<a name="ln24">#include &quot;xml.h&quot;</a>
<a name="ln25">#include &quot;slur.h&quot;</a>
<a name="ln26">#include &quot;tie.h&quot;</a>
<a name="ln27">#include &quot;text.h&quot;</a>
<a name="ln28">#include &quot;clef.h&quot;</a>
<a name="ln29">#include &quot;staff.h&quot;</a>
<a name="ln30">#include &quot;pitchspelling.h&quot;</a>
<a name="ln31">#include &quot;arpeggio.h&quot;</a>
<a name="ln32">#include &quot;tremolo.h&quot;</a>
<a name="ln33">#include &quot;utils.h&quot;</a>
<a name="ln34">#include &quot;image.h&quot;</a>
<a name="ln35">#include &quot;system.h&quot;</a>
<a name="ln36">#include &quot;tuplet.h&quot;</a>
<a name="ln37">#include &quot;articulation.h&quot;</a>
<a name="ln38">#include &quot;drumset.h&quot;</a>
<a name="ln39">#include &quot;segment.h&quot;</a>
<a name="ln40">#include &quot;measure.h&quot;</a>
<a name="ln41">#include &quot;undo.h&quot;</a>
<a name="ln42">#include &quot;part.h&quot;</a>
<a name="ln43">#include &quot;stafftype.h&quot;</a>
<a name="ln44">#include &quot;stringdata.h&quot;</a>
<a name="ln45">#include &quot;fret.h&quot;</a>
<a name="ln46">#include &quot;harmony.h&quot;</a>
<a name="ln47">#include &quot;fingering.h&quot;</a>
<a name="ln48">#include &quot;bend.h&quot;</a>
<a name="ln49">#include &quot;accidental.h&quot;</a>
<a name="ln50">#include &quot;page.h&quot;</a>
<a name="ln51">#include &quot;icon.h&quot;</a>
<a name="ln52">#include &quot;notedot.h&quot;</a>
<a name="ln53">#include &quot;spanner.h&quot;</a>
<a name="ln54">#include &quot;glissando.h&quot;</a>
<a name="ln55">#include &quot;bagpembell.h&quot;</a>
<a name="ln56">#include &quot;hairpin.h&quot;</a>
<a name="ln57">#include &quot;textline.h&quot;</a>
<a name="ln58">#include &lt;QPointF&gt;</a>
<a name="ln59">#include &lt;QtMath&gt;</a>
<a name="ln60">#include &lt;QVector2D&gt;</a>
<a name="ln61"> </a>
<a name="ln62">namespace Ms {</a>
<a name="ln63"> </a>
<a name="ln64">//---------------------------------------------------------</a>
<a name="ln65">//   noteHeads</a>
<a name="ln66">//    notehead groups</a>
<a name="ln67">//---------------------------------------------------------</a>
<a name="ln68"> </a>
<a name="ln69">//int(NoteHead::Group::HEAD_GROUPS) - 1: &quot;-1&quot; is needed to prevent building CUSTOM_GROUP noteheads set, since it is built by users and keep a specific set of existing noteheads</a>
<a name="ln70">static const SymId noteHeads[2][int(NoteHead::Group::HEAD_GROUPS) - 1][int(NoteHead::Type::HEAD_TYPES)] = {</a>
<a name="ln71">   {     // down stem</a>
<a name="ln72">      { SymId::noteheadWhole,               SymId::noteheadHalf,                SymId::noteheadBlack,               SymId::noteheadDoubleWhole  },</a>
<a name="ln73">      { SymId::noteheadXWhole,              SymId::noteheadXHalf,               SymId::noteheadXBlack,              SymId::noteheadXDoubleWhole  },</a>
<a name="ln74">      { SymId::noteheadPlusWhole,           SymId::noteheadPlusHalf,            SymId::noteheadPlusBlack,           SymId::noteheadPlusDoubleWhole  },</a>
<a name="ln75">      { SymId::noteheadCircleXWhole,        SymId::noteheadCircleXHalf,         SymId::noteheadCircleX,             SymId::noteheadCircleXDoubleWhole},</a>
<a name="ln76">      { SymId::noteheadWholeWithX,          SymId::noteheadHalfWithX,           SymId::noteheadVoidWithX,           SymId::noteheadDoubleWholeWithX},</a>
<a name="ln77">      { SymId::noteheadTriangleUpWhole,     SymId::noteheadTriangleUpHalf,      SymId::noteheadTriangleUpBlack,     SymId::noteheadTriangleUpDoubleWhole },</a>
<a name="ln78">      { SymId::noteheadTriangleDownWhole,   SymId::noteheadTriangleDownHalf,    SymId::noteheadTriangleDownBlack,   SymId::noteheadTriangleDownDoubleWhole },</a>
<a name="ln79">      { SymId::noteheadSlashedWhole1,       SymId::noteheadSlashedHalf1,        SymId::noteheadSlashedBlack1,       SymId::noteheadSlashedDoubleWhole1 },</a>
<a name="ln80">      { SymId::noteheadSlashedWhole2,       SymId::noteheadSlashedHalf2,        SymId::noteheadSlashedBlack2,       SymId::noteheadSlashedDoubleWhole2 },</a>
<a name="ln81">      { SymId::noteheadDiamondWhole,        SymId::noteheadDiamondHalf,         SymId::noteheadDiamondBlack,        SymId::noteheadDiamondDoubleWhole  },</a>
<a name="ln82">      { SymId::noteheadDiamondWholeOld,     SymId::noteheadDiamondHalfOld,      SymId::noteheadDiamondBlackOld,     SymId::noteheadDiamondDoubleWholeOld  },</a>
<a name="ln83">      { SymId::noteheadCircledWhole,        SymId::noteheadCircledHalf,         SymId::noteheadCircledBlack,        SymId::noteheadCircledDoubleWhole  },</a>
<a name="ln84">      { SymId::noteheadCircledWholeLarge,   SymId::noteheadCircledHalfLarge,    SymId::noteheadCircledBlackLarge,   SymId::noteheadCircledDoubleWholeLarge  },</a>
<a name="ln85">      { SymId::noteheadLargeArrowUpWhole,   SymId::noteheadLargeArrowUpHalf,    SymId::noteheadLargeArrowUpBlack,   SymId::noteheadLargeArrowUpDoubleWhole  },</a>
<a name="ln86">      { SymId::noteheadWhole,               SymId::noteheadHalf,                SymId::noteheadBlack,               SymId::noteheadDoubleWholeSquare   },</a>
<a name="ln87"> </a>
<a name="ln88">      { SymId::noteheadSlashWhiteWhole,     SymId::noteheadSlashWhiteHalf,      SymId::noteheadSlashHorizontalEnds, SymId::noteheadSlashWhiteWhole},</a>
<a name="ln89"> </a>
<a name="ln90">      { SymId::noteShapeRoundWhite,         SymId::noteShapeRoundWhite,         SymId::noteShapeRoundBlack,         SymId::noteShapeRoundDoubleWhole            },</a>
<a name="ln91">      { SymId::noteShapeSquareWhite,        SymId::noteShapeSquareWhite,        SymId::noteShapeSquareBlack,        SymId::noteShapeSquareDoubleWhole           },</a>
<a name="ln92">      { SymId::noteShapeTriangleRightWhite, SymId::noteShapeTriangleRightWhite, SymId::noteShapeTriangleRightBlack, SymId::noteShapeTriangleRightDoubleWhole    },</a>
<a name="ln93">      { SymId::noteShapeDiamondWhite,       SymId::noteShapeDiamondWhite,       SymId::noteShapeDiamondBlack,       SymId::noteShapeDiamondDoubleWhole          },</a>
<a name="ln94">      { SymId::noteShapeTriangleUpWhite,    SymId::noteShapeTriangleUpWhite,    SymId::noteShapeTriangleUpBlack,    SymId::noteShapeTriangleUpDoubleWhole       },</a>
<a name="ln95">      { SymId::noteShapeMoonWhite,          SymId::noteShapeMoonWhite,          SymId::noteShapeMoonBlack,          SymId::noteShapeMoonDoubleWhole            },</a>
<a name="ln96">      { SymId::noteShapeTriangleRoundWhite, SymId::noteShapeTriangleRoundWhite, SymId::noteShapeTriangleRoundBlack, SymId::noteShapeTriangleRoundDoubleWhole    },</a>
<a name="ln97"> </a>
<a name="ln98">      { SymId::noteShapeKeystoneWhite,          SymId::noteShapeKeystoneWhite,          SymId::noteShapeKeystoneBlack,          SymId::noteShapeKeystoneDoubleWhole    },</a>
<a name="ln99">      { SymId::noteShapeQuarterMoonWhite,       SymId::noteShapeQuarterMoonWhite,       SymId::noteShapeQuarterMoonBlack,       SymId::noteShapeQuarterMoonDoubleWhole },</a>
<a name="ln100">      { SymId::noteShapeIsoscelesTriangleWhite, SymId::noteShapeIsoscelesTriangleWhite, SymId::noteShapeIsoscelesTriangleBlack, SymId::noteShapeIsoscelesTriangleDoubleWhole   },</a>
<a name="ln101">      { SymId::noteShapeMoonLeftWhite,          SymId::noteShapeMoonLeftWhite,          SymId::noteShapeMoonLeftBlack,          SymId::noteShapeMoonLeftDoubleWhole    },</a>
<a name="ln102">      { SymId::noteShapeArrowheadLeftWhite,     SymId::noteShapeArrowheadLeftWhite,     SymId::noteShapeArrowheadLeftBlack,     SymId::noteShapeArrowheadLeftDoubleWhole       },</a>
<a name="ln103">      { SymId::noteShapeTriangleRoundLeftWhite, SymId::noteShapeTriangleRoundLeftWhite, SymId::noteShapeTriangleRoundLeftBlack, SymId::noteShapeTriangleRoundLeftDoubleWhole   },</a>
<a name="ln104"> </a>
<a name="ln105">      { SymId::noteDoWhole,  SymId::noteDoHalf,  SymId::noteDoBlack,  SymId::noSym            },</a>
<a name="ln106">      { SymId::noteReWhole,  SymId::noteReHalf,  SymId::noteReBlack,  SymId::noSym            },</a>
<a name="ln107">      { SymId::noteMiWhole,  SymId::noteMiHalf,  SymId::noteMiBlack,  SymId::noSym            },</a>
<a name="ln108">      { SymId::noteFaWhole,  SymId::noteFaHalf,  SymId::noteFaBlack,  SymId::noSym            },</a>
<a name="ln109">      { SymId::noteSoWhole,  SymId::noteSoHalf,  SymId::noteSoBlack,  SymId::noSym            },</a>
<a name="ln110">      { SymId::noteLaWhole,  SymId::noteLaHalf,  SymId::noteLaBlack,  SymId::noSym            },</a>
<a name="ln111">      { SymId::noteTiWhole,  SymId::noteTiHalf,  SymId::noteTiBlack,  SymId::noSym            },</a>
<a name="ln112">      { SymId::noteSiWhole,  SymId::noteSiHalf,  SymId::noteSiBlack,  SymId::noSym            },</a>
<a name="ln113"> </a>
<a name="ln114">      { SymId::noteASharpWhole,  SymId::noteASharpHalf,  SymId::noteASharpBlack,  SymId::noSym            },</a>
<a name="ln115">      { SymId::noteAWhole,       SymId::noteAHalf,       SymId::noteABlack,       SymId::noSym            },</a>
<a name="ln116">      { SymId::noteAFlatWhole,   SymId::noteAFlatHalf,   SymId::noteAFlatBlack,   SymId::noSym            },</a>
<a name="ln117">      { SymId::noteBSharpWhole,  SymId::noteBSharpHalf,  SymId::noteBSharpBlack,  SymId::noSym            },</a>
<a name="ln118">      { SymId::noteBWhole,       SymId::noteBHalf,       SymId::noteBBlack,       SymId::noSym            },</a>
<a name="ln119">      { SymId::noteBFlatWhole,   SymId::noteBFlatHalf,   SymId::noteBFlatBlack,   SymId::noSym            },</a>
<a name="ln120">      { SymId::noteCSharpWhole,  SymId::noteCSharpHalf,  SymId::noteCSharpBlack,  SymId::noSym            },</a>
<a name="ln121">      { SymId::noteCWhole,       SymId::noteCHalf,       SymId::noteCBlack,       SymId::noSym            },</a>
<a name="ln122">      { SymId::noteCFlatWhole,   SymId::noteCFlatHalf,   SymId::noteCFlatBlack,   SymId::noSym            },</a>
<a name="ln123">      { SymId::noteDSharpWhole,  SymId::noteDSharpHalf,  SymId::noteDSharpBlack,  SymId::noSym            },</a>
<a name="ln124">      { SymId::noteDWhole,       SymId::noteDHalf,       SymId::noteDBlack,       SymId::noSym            },</a>
<a name="ln125">      { SymId::noteDFlatWhole,   SymId::noteDFlatHalf,   SymId::noteDFlatBlack,   SymId::noSym            },</a>
<a name="ln126">      { SymId::noteESharpWhole,  SymId::noteESharpHalf,  SymId::noteESharpBlack,  SymId::noSym            },</a>
<a name="ln127">      { SymId::noteEWhole,       SymId::noteEHalf,       SymId::noteEBlack,       SymId::noSym            },</a>
<a name="ln128">      { SymId::noteEFlatWhole,   SymId::noteEFlatHalf,   SymId::noteEFlatBlack,   SymId::noSym            },</a>
<a name="ln129">      { SymId::noteFSharpWhole,  SymId::noteFSharpHalf,  SymId::noteFSharpBlack,  SymId::noSym            },</a>
<a name="ln130">      { SymId::noteFWhole,       SymId::noteFHalf,       SymId::noteFBlack,       SymId::noSym            },</a>
<a name="ln131">      { SymId::noteFFlatWhole,   SymId::noteFFlatHalf,   SymId::noteFFlatBlack,   SymId::noSym            },</a>
<a name="ln132">      { SymId::noteGSharpWhole,  SymId::noteGSharpHalf,  SymId::noteGSharpBlack,  SymId::noSym            },</a>
<a name="ln133">      { SymId::noteGWhole,       SymId::noteGHalf,       SymId::noteGBlack,       SymId::noSym            },</a>
<a name="ln134">      { SymId::noteGFlatWhole,   SymId::noteGFlatHalf,   SymId::noteGFlatBlack,   SymId::noSym            },</a>
<a name="ln135">      { SymId::noteHWhole,       SymId::noteHHalf,       SymId::noteHBlack,       SymId::noSym            },</a>
<a name="ln136">      { SymId::noteHSharpWhole,  SymId::noteHSharpHalf,  SymId::noteHSharpBlack,  SymId::noSym            }</a>
<a name="ln137"> </a>
<a name="ln138">   },</a>
<a name="ln139">   {     // up stem</a>
<a name="ln140">      { SymId::noteheadWhole,               SymId::noteheadHalf,                SymId::noteheadBlack,               SymId::noteheadDoubleWhole  },</a>
<a name="ln141">      { SymId::noteheadXWhole,              SymId::noteheadXHalf,               SymId::noteheadXBlack,              SymId::noteheadXDoubleWhole       },</a>
<a name="ln142">      { SymId::noteheadPlusWhole,           SymId::noteheadPlusHalf,            SymId::noteheadPlusBlack,           SymId::noteheadPlusDoubleWhole  },</a>
<a name="ln143">      { SymId::noteheadCircleXWhole,        SymId::noteheadCircleXHalf,         SymId::noteheadCircleX,             SymId::noteheadCircleXDoubleWhole},</a>
<a name="ln144">      { SymId::noteheadWholeWithX,          SymId::noteheadHalfWithX,           SymId::noteheadVoidWithX,           SymId::noteheadDoubleWholeWithX},</a>
<a name="ln145">      { SymId::noteheadTriangleUpWhole,     SymId::noteheadTriangleUpHalf,      SymId::noteheadTriangleUpBlack,     SymId::noteheadTriangleUpDoubleWhole },</a>
<a name="ln146">      { SymId::noteheadTriangleDownWhole,   SymId::noteheadTriangleDownHalf,    SymId::noteheadTriangleDownBlack,   SymId::noteheadTriangleDownDoubleWhole },</a>
<a name="ln147">      { SymId::noteheadSlashedWhole1,       SymId::noteheadSlashedHalf1,        SymId::noteheadSlashedBlack1,       SymId::noteheadSlashedDoubleWhole1 },</a>
<a name="ln148">      { SymId::noteheadSlashedWhole2,       SymId::noteheadSlashedHalf2,        SymId::noteheadSlashedBlack2,       SymId::noteheadSlashedDoubleWhole2 },</a>
<a name="ln149">      { SymId::noteheadDiamondWhole,        SymId::noteheadDiamondHalf,         SymId::noteheadDiamondBlack,        SymId::noteheadDiamondDoubleWhole  },</a>
<a name="ln150">      { SymId::noteheadDiamondWholeOld,     SymId::noteheadDiamondHalfOld,      SymId::noteheadDiamondBlackOld,     SymId::noteheadDiamondDoubleWholeOld  },</a>
<a name="ln151">      { SymId::noteheadCircledWhole,        SymId::noteheadCircledHalf,         SymId::noteheadCircledBlack,        SymId::noteheadCircledDoubleWhole  },</a>
<a name="ln152">      { SymId::noteheadCircledWholeLarge,   SymId::noteheadCircledHalfLarge,    SymId::noteheadCircledBlackLarge,   SymId::noteheadCircledDoubleWholeLarge  },</a>
<a name="ln153">      // different from down, find source?</a>
<a name="ln154">      { SymId::noteheadLargeArrowDownWhole, SymId::noteheadLargeArrowDownHalf,  SymId::noteheadLargeArrowDownBlack, SymId::noteheadLargeArrowDownDoubleWhole  },</a>
<a name="ln155">      { SymId::noteheadWhole,               SymId::noteheadHalf,                SymId::noteheadBlack,               SymId::noteheadDoubleWholeSquare   },</a>
<a name="ln156"> </a>
<a name="ln157">      { SymId::noteheadSlashWhiteWhole,     SymId::noteheadSlashWhiteHalf,      SymId::noteheadSlashHorizontalEnds, SymId::noteheadSlashWhiteDoubleWhole},</a>
<a name="ln158"> </a>
<a name="ln159">      { SymId::noteShapeRoundWhite,         SymId::noteShapeRoundWhite,         SymId::noteShapeRoundBlack,         SymId::noteShapeRoundDoubleWhole       },</a>
<a name="ln160">      { SymId::noteShapeSquareWhite,        SymId::noteShapeSquareWhite,        SymId::noteShapeSquareBlack,        SymId::noteShapeSquareDoubleWhole      },</a>
<a name="ln161">      // different from down</a>
<a name="ln162">      { SymId::noteShapeTriangleLeftWhite,  SymId::noteShapeTriangleLeftWhite,  SymId::noteShapeTriangleLeftBlack,  SymId::noteShapeTriangleLeftDoubleWhole },</a>
<a name="ln163">      { SymId::noteShapeDiamondWhite,       SymId::noteShapeDiamondWhite,       SymId::noteShapeDiamondBlack,       SymId::noteShapeDiamondDoubleWhole      },</a>
<a name="ln164">      { SymId::noteShapeTriangleUpWhite,    SymId::noteShapeTriangleUpWhite,    SymId::noteShapeTriangleUpBlack,    SymId::noteShapeTriangleUpDoubleWhole   },</a>
<a name="ln165">      { SymId::noteShapeMoonWhite,          SymId::noteShapeMoonWhite,          SymId::noteShapeMoonBlack,          SymId::noteShapeMoonDoubleWhole         },</a>
<a name="ln166">      { SymId::noteShapeTriangleRoundWhite, SymId::noteShapeTriangleRoundWhite, SymId::noteShapeTriangleRoundBlack, SymId::noteShapeTriangleRoundDoubleWhole },</a>
<a name="ln167"> </a>
<a name="ln168">      { SymId::noteShapeKeystoneWhite,          SymId::noteShapeKeystoneWhite,          SymId::noteShapeKeystoneBlack,          SymId::noteShapeKeystoneDoubleWhole },</a>
<a name="ln169">      { SymId::noteShapeQuarterMoonWhite,       SymId::noteShapeQuarterMoonWhite,       SymId::noteShapeQuarterMoonBlack,       SymId::noteShapeQuarterMoonDoubleWhole },</a>
<a name="ln170">      { SymId::noteShapeIsoscelesTriangleWhite, SymId::noteShapeIsoscelesTriangleWhite, SymId::noteShapeIsoscelesTriangleBlack, SymId::noteShapeIsoscelesTriangleDoubleWhole },</a>
<a name="ln171">      { SymId::noteShapeMoonLeftWhite,          SymId::noteShapeMoonLeftWhite,          SymId::noteShapeMoonLeftBlack,          SymId::noteShapeMoonLeftDoubleWhole          },</a>
<a name="ln172">      { SymId::noteShapeArrowheadLeftWhite,     SymId::noteShapeArrowheadLeftWhite,     SymId::noteShapeArrowheadLeftBlack,     SymId::noteShapeArrowheadLeftDoubleWhole     },</a>
<a name="ln173">      { SymId::noteShapeTriangleRoundLeftWhite, SymId::noteShapeTriangleRoundLeftWhite, SymId::noteShapeTriangleRoundLeftBlack, SymId::noteShapeTriangleRoundLeftDoubleWhole },</a>
<a name="ln174"> </a>
<a name="ln175">      { SymId::noteDoWhole,  SymId::noteDoHalf,  SymId::noteDoBlack,  SymId::noSym            },</a>
<a name="ln176">      { SymId::noteReWhole,  SymId::noteReHalf,  SymId::noteReBlack,  SymId::noSym            },</a>
<a name="ln177">      { SymId::noteMiWhole,  SymId::noteMiHalf,  SymId::noteMiBlack,  SymId::noSym            },</a>
<a name="ln178">      { SymId::noteFaWhole,  SymId::noteFaHalf,  SymId::noteFaBlack,  SymId::noSym            },</a>
<a name="ln179">      { SymId::noteSoWhole,  SymId::noteSoHalf,  SymId::noteSoBlack,  SymId::noSym            },</a>
<a name="ln180">      { SymId::noteLaWhole,  SymId::noteLaHalf,  SymId::noteLaBlack,  SymId::noSym            },</a>
<a name="ln181">      { SymId::noteTiWhole,  SymId::noteTiHalf,  SymId::noteTiBlack,  SymId::noSym            },</a>
<a name="ln182">      { SymId::noteSiWhole,  SymId::noteSiHalf,  SymId::noteSiBlack,  SymId::noSym            },</a>
<a name="ln183"> </a>
<a name="ln184">      { SymId::noteASharpWhole,  SymId::noteASharpHalf,  SymId::noteASharpBlack,  SymId::noSym            },</a>
<a name="ln185">      { SymId::noteAWhole,       SymId::noteAHalf,       SymId::noteABlack,       SymId::noSym            },</a>
<a name="ln186">      { SymId::noteAFlatWhole,   SymId::noteAFlatHalf,   SymId::noteAFlatBlack,   SymId::noSym            },</a>
<a name="ln187">      { SymId::noteBSharpWhole,  SymId::noteBSharpHalf,  SymId::noteBSharpBlack,  SymId::noSym            },</a>
<a name="ln188">      { SymId::noteBWhole,       SymId::noteBHalf,       SymId::noteBBlack,       SymId::noSym            },</a>
<a name="ln189">      { SymId::noteBFlatWhole,   SymId::noteBFlatHalf,   SymId::noteBFlatBlack,   SymId::noSym            },</a>
<a name="ln190">      { SymId::noteCSharpWhole,  SymId::noteCSharpHalf,  SymId::noteCSharpBlack,  SymId::noSym            },</a>
<a name="ln191">      { SymId::noteCWhole,       SymId::noteCHalf,       SymId::noteCBlack,       SymId::noSym            },</a>
<a name="ln192">      { SymId::noteCFlatWhole,   SymId::noteCFlatHalf,   SymId::noteCFlatBlack,   SymId::noSym            },</a>
<a name="ln193">      { SymId::noteDSharpWhole,  SymId::noteDSharpHalf,  SymId::noteDSharpBlack,  SymId::noSym            },</a>
<a name="ln194">      { SymId::noteDWhole,       SymId::noteDHalf,       SymId::noteDBlack,       SymId::noSym            },</a>
<a name="ln195">      { SymId::noteDFlatWhole,   SymId::noteDFlatHalf,   SymId::noteDFlatBlack,   SymId::noSym            },</a>
<a name="ln196">      { SymId::noteESharpWhole,  SymId::noteESharpHalf,  SymId::noteESharpBlack,  SymId::noSym            },</a>
<a name="ln197">      { SymId::noteEWhole,       SymId::noteEHalf,       SymId::noteEBlack,       SymId::noSym            },</a>
<a name="ln198">      { SymId::noteEFlatWhole,   SymId::noteEFlatHalf,   SymId::noteEFlatBlack,   SymId::noSym            },</a>
<a name="ln199">      { SymId::noteFSharpWhole,  SymId::noteFSharpHalf,  SymId::noteFSharpBlack,  SymId::noSym            },</a>
<a name="ln200">      { SymId::noteFWhole,       SymId::noteFHalf,       SymId::noteFBlack,       SymId::noSym            },</a>
<a name="ln201">      { SymId::noteFFlatWhole,   SymId::noteFFlatHalf,   SymId::noteFFlatBlack,   SymId::noSym            },</a>
<a name="ln202">      { SymId::noteGSharpWhole,  SymId::noteGSharpHalf,  SymId::noteGSharpBlack,  SymId::noSym            },</a>
<a name="ln203">      { SymId::noteGWhole,       SymId::noteGHalf,       SymId::noteGBlack,       SymId::noSym            },</a>
<a name="ln204">      { SymId::noteGFlatWhole,   SymId::noteGFlatHalf,   SymId::noteGFlatBlack,   SymId::noSym            },</a>
<a name="ln205">      { SymId::noteHWhole,       SymId::noteHHalf,       SymId::noteHBlack,       SymId::noSym            },</a>
<a name="ln206">      { SymId::noteHSharpWhole,  SymId::noteHSharpHalf,  SymId::noteHSharpBlack,  SymId::noSym            }</a>
<a name="ln207"> </a>
<a name="ln208">   }</a>
<a name="ln209">};</a>
<a name="ln210"> </a>
<a name="ln211">struct NoteHeadName {</a>
<a name="ln212">   const char* name;</a>
<a name="ln213">   const char* username;</a>
<a name="ln214">};</a>
<a name="ln215"> </a>
<a name="ln216">// same order as NoteHead::Group</a>
<a name="ln217">static NoteHeadName noteHeadGroupNames[] = {</a>
<a name="ln218">      {&quot;normal&quot;,         QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Normal&quot;) },</a>
<a name="ln219">      {&quot;cross&quot;,          QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Cross&quot;) },</a>
<a name="ln220">      {&quot;plus&quot;,           QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Plus&quot;) },</a>
<a name="ln221">      {&quot;xcircle&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;XCircle&quot;) },</a>
<a name="ln222">      {&quot;withx&quot;,          QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;With X&quot;) },</a>
<a name="ln223">      {&quot;triangle-up&quot;,    QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Triangle Up&quot;) },</a>
<a name="ln224">      {&quot;triangle-down&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Triangle Down&quot;) },</a>
<a name="ln225">      {&quot;slashed1&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Slashed (Forwards)&quot;) },</a>
<a name="ln226">      {&quot;slashed2&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Slashed (Backwards)&quot;) },</a>
<a name="ln227">      {&quot;diamond&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Diamond&quot;) },</a>
<a name="ln228">      {&quot;diamond-old&quot;,    QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Diamond (Old)&quot;) },</a>
<a name="ln229">      {&quot;circled&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Circled&quot;) },</a>
<a name="ln230">      {&quot;circled-large&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Circled Large&quot;) },</a>
<a name="ln231">      {&quot;large-arrow&quot;,    QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Large Arrow&quot;) },</a>
<a name="ln232">      {&quot;altbrevis&quot;,      QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Alt. Brevis&quot;) },</a>
<a name="ln233"> </a>
<a name="ln234">      {&quot;slash&quot;,     QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Slash&quot;) },</a>
<a name="ln235"> </a>
<a name="ln236">      // shape notes</a>
<a name="ln237">      {&quot;sol&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Sol&quot;) },</a>
<a name="ln238">      {&quot;la&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;La&quot;) },</a>
<a name="ln239">      {&quot;fa&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Fa&quot;) },</a>
<a name="ln240">      {&quot;mi&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Mi&quot;) },</a>
<a name="ln241">      {&quot;do&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Do&quot;) },</a>
<a name="ln242">      {&quot;re&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Re&quot;) },</a>
<a name="ln243">      {&quot;ti&quot;,        QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Ti&quot;) },</a>
<a name="ln244"> </a>
<a name="ln245">      // not exposed</a>
<a name="ln246">      {&quot;do-walker&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Do (Walker)&quot;) },</a>
<a name="ln247">      {&quot;re-walker&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Re (Walker)&quot;) },</a>
<a name="ln248">      {&quot;ti-walker&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Ti (Walker)&quot;) },</a>
<a name="ln249">      {&quot;do-funk&quot;,   QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Do (Funk)&quot;) },</a>
<a name="ln250">      {&quot;re-funk&quot;,   QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Re (Funk)&quot;) },</a>
<a name="ln251">      {&quot;ti-funk&quot;,   QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Ti (Funk)&quot;) },</a>
<a name="ln252"> </a>
<a name="ln253">      // note name</a>
<a name="ln254">      {&quot;do-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;Do (Name)&quot;) },</a>
<a name="ln255">      {&quot;re-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;Re (Name)&quot;) },</a>
<a name="ln256">      {&quot;mi-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;Mi (Name)&quot;) },</a>
<a name="ln257">      {&quot;fa-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;Fa (Name)&quot;) },</a>
<a name="ln258">      {&quot;sol-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;Sol (Name)&quot;) },</a>
<a name="ln259">      {&quot;la-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;La (Name)&quot;) },</a>
<a name="ln260">      {&quot;ti-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;Ti (Name)&quot;) },</a>
<a name="ln261">      {&quot;si-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;Si (Name)&quot;) },</a>
<a name="ln262"> </a>
<a name="ln263"> </a>
<a name="ln264">      {&quot;a-sharp-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;A♯ (Name)&quot;) },</a>
<a name="ln265">      {&quot;a-name&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;A (Name)&quot;) },</a>
<a name="ln266">      {&quot;a-flat-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;A♭ (Name)&quot;) },</a>
<a name="ln267">      {&quot;b-sharp-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;B♯ (Name)&quot;) },</a>
<a name="ln268">      {&quot;b-name&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;B (Name)&quot;) },</a>
<a name="ln269">      {&quot;b-flat-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;B♭ (Name)&quot;) },</a>
<a name="ln270">      {&quot;c-sharp-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;C♯ (Name)&quot;) },</a>
<a name="ln271">      {&quot;c-name&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;C (Name)&quot;) },</a>
<a name="ln272">      {&quot;c-flat-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;C♭ (Name)&quot;) },</a>
<a name="ln273">      {&quot;d-sharp-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;D♯ (Name)&quot;) },</a>
<a name="ln274">      {&quot;d-name&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;D (Name)&quot;) },</a>
<a name="ln275">      {&quot;d-flat-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;D♭ (Name)&quot;) },</a>
<a name="ln276">      {&quot;e-sharp-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;E♯ (Name)&quot;) },</a>
<a name="ln277">      {&quot;e-name&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;E (Name)&quot;) },</a>
<a name="ln278">      {&quot;e-flat-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;E♭ (Name)&quot;) },</a>
<a name="ln279">      {&quot;f-sharp-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;F♯ (Name)&quot;) },</a>
<a name="ln280">      {&quot;f-name&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;F (Name)&quot;) },</a>
<a name="ln281">      {&quot;f-flat-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;F♭ (Name)&quot;) },</a>
<a name="ln282">      {&quot;g-sharp-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;G♯ (Name)&quot;) },</a>
<a name="ln283">      {&quot;g-name&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;G (Name)&quot;) },</a>
<a name="ln284">      {&quot;g-flat-name&quot;,  QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;G♭ (Name)&quot;) },</a>
<a name="ln285">      {&quot;h-name&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;H (Name)&quot;) },</a>
<a name="ln286">      {&quot;h-sharp-name&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;H♯ (Name)&quot;) },</a>
<a name="ln287">      {&quot;custom&quot;,       QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;,  &quot;Custom&quot;) }</a>
<a name="ln288">      };</a>
<a name="ln289"> </a>
<a name="ln290">// same order as NoteHead::Type</a>
<a name="ln291">static NoteHeadName noteHeadTypeNames[] = {</a>
<a name="ln292">      {&quot;auto&quot;,    QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Auto&quot;) },</a>
<a name="ln293">      {&quot;whole&quot;,   QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Whole&quot;) },</a>
<a name="ln294">      {&quot;half&quot;,    QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Half&quot;) },</a>
<a name="ln295">      {&quot;quarter&quot;, QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Quarter&quot;) },</a>
<a name="ln296">      {&quot;breve&quot;,   QT_TRANSLATE_NOOP(&quot;noteheadnames&quot;, &quot;Breve&quot;) },</a>
<a name="ln297">      };</a>
<a name="ln298"> </a>
<a name="ln299">//---------------------------------------------------------</a>
<a name="ln300">//   group2userName</a>
<a name="ln301">//---------------------------------------------------------</a>
<a name="ln302"> </a>
<a name="ln303">QString NoteHead::group2userName(NoteHead::Group group)</a>
<a name="ln304">      {</a>
<a name="ln305">      return qApp-&gt;translate(&quot;noteheadnames&quot;, noteHeadGroupNames[int(group)].username);</a>
<a name="ln306">      }</a>
<a name="ln307"> </a>
<a name="ln308">//---------------------------------------------------------</a>
<a name="ln309">//   type2userName</a>
<a name="ln310">//---------------------------------------------------------</a>
<a name="ln311"> </a>
<a name="ln312">QString NoteHead::type2userName(NoteHead::Type type)</a>
<a name="ln313">      {</a>
<a name="ln314">      return qApp-&gt;translate(&quot;noteheadnames&quot;, noteHeadTypeNames[int(type) + 1].username);</a>
<a name="ln315">      }</a>
<a name="ln316"> </a>
<a name="ln317">//---------------------------------------------------------</a>
<a name="ln318">//   group2name</a>
<a name="ln319">//---------------------------------------------------------</a>
<a name="ln320"> </a>
<a name="ln321">QString NoteHead::group2name(NoteHead::Group group)</a>
<a name="ln322">      {</a>
<a name="ln323">      return noteHeadGroupNames[int(group)].name;</a>
<a name="ln324">      }</a>
<a name="ln325"> </a>
<a name="ln326">//---------------------------------------------------------</a>
<a name="ln327">//   type2name</a>
<a name="ln328">//---------------------------------------------------------</a>
<a name="ln329"> </a>
<a name="ln330">QString NoteHead::type2name(NoteHead::Type type)</a>
<a name="ln331">      {</a>
<a name="ln332">      return noteHeadTypeNames[int(type) + 1].name;</a>
<a name="ln333">      }</a>
<a name="ln334"> </a>
<a name="ln335">//---------------------------------------------------------</a>
<a name="ln336">//   name2group</a>
<a name="ln337">//---------------------------------------------------------</a>
<a name="ln338"> </a>
<a name="ln339">NoteHead::Group NoteHead::name2group(QString s)</a>
<a name="ln340">      {</a>
<a name="ln341">      for (int i = 0; i &lt; int(NoteHead::Group::HEAD_GROUPS); ++i) {</a>
<a name="ln342">            if (noteHeadGroupNames[i].name == s)</a>
<a name="ln343">                  return NoteHead::Group(i);</a>
<a name="ln344">            }</a>
<a name="ln345">      return NoteHead::Group::HEAD_NORMAL;</a>
<a name="ln346">      }</a>
<a name="ln347"> </a>
<a name="ln348">//---------------------------------------------------------</a>
<a name="ln349">//   name2type</a>
<a name="ln350">//---------------------------------------------------------</a>
<a name="ln351"> </a>
<a name="ln352">NoteHead::Type NoteHead::name2type(QString s)</a>
<a name="ln353">      {</a>
<a name="ln354">      for (int i = 0; i &lt;= int(NoteHead::Type::HEAD_TYPES); ++i) {</a>
<a name="ln355">            if (noteHeadTypeNames[i].name == s)</a>
<a name="ln356">                  return NoteHead::Type(i - 1);</a>
<a name="ln357">            }</a>
<a name="ln358">      return NoteHead::Type::HEAD_AUTO;</a>
<a name="ln359">      }</a>
<a name="ln360"> </a>
<a name="ln361">//---------------------------------------------------------</a>
<a name="ln362">//   noteHead</a>
<a name="ln363">//---------------------------------------------------------</a>
<a name="ln364"> </a>
<a name="ln365">SymId Note::noteHead(int direction, NoteHead::Group group, NoteHead::Type t)</a>
<a name="ln366">      {</a>
<a name="ln367">      return noteHeads[direction][int(group)][int(t)];</a>
<a name="ln368">      }</a>
<a name="ln369"> </a>
<a name="ln370">SymId Note::noteHead(int direction, NoteHead::Group group, NoteHead::Type t, int tpc, Key key, NoteHeadScheme scheme)</a>
<a name="ln371">      {</a>
<a name="ln372">      // shortcut</a>
<a name="ln373">      if (scheme == NoteHeadScheme::HEAD_NORMAL)</a>
<a name="ln374">            return noteHeads[direction][int(group)][int(t)];</a>
<a name="ln375">      // other schemes</a>
<a name="ln376">      if (scheme == NoteHeadScheme::HEAD_PITCHNAME || scheme == NoteHeadScheme::HEAD_PITCHNAME_GERMAN) {</a>
<a name="ln377">            if (tpc == Tpc::TPC_A)</a>
<a name="ln378">                  group = NoteHead::Group::HEAD_A;</a>
<a name="ln379">            else if (tpc == Tpc::TPC_B) {</a>
<a name="ln380">                  if (scheme == NoteHeadScheme::HEAD_PITCHNAME_GERMAN)</a>
<a name="ln381">                        group = NoteHead::Group::HEAD_H;</a>
<a name="ln382">                  else</a>
<a name="ln383">                        group = NoteHead::Group::HEAD_B;</a>
<a name="ln384">                  }</a>
<a name="ln385">            else if (tpc == Tpc::TPC_C)</a>
<a name="ln386">                  group = NoteHead::Group::HEAD_C;</a>
<a name="ln387">            else if (tpc == Tpc::TPC_D)</a>
<a name="ln388">                  group = NoteHead::Group::HEAD_D;</a>
<a name="ln389">            else if (tpc == Tpc::TPC_E)</a>
<a name="ln390">                  group = NoteHead::Group::HEAD_E;</a>
<a name="ln391">            else if (tpc == Tpc::TPC_F)</a>
<a name="ln392">                  group = NoteHead::Group::HEAD_F;</a>
<a name="ln393">            else if (tpc == Tpc::TPC_G)</a>
<a name="ln394">                  group = NoteHead::Group::HEAD_G;</a>
<a name="ln395">            else if (tpc == Tpc::TPC_A_S)</a>
<a name="ln396">                  group = NoteHead::Group::HEAD_A_SHARP;</a>
<a name="ln397">            else if (tpc == Tpc::TPC_B_S)</a>
<a name="ln398">                  if (scheme == NoteHeadScheme::HEAD_PITCHNAME_GERMAN)</a>
<a name="ln399">                        group = NoteHead::Group::HEAD_H_SHARP;</a>
<a name="ln400">                  else</a>
<a name="ln401">                        group = NoteHead::Group::HEAD_B_SHARP;</a>
<a name="ln402">            else if (tpc == Tpc::TPC_C_S)</a>
<a name="ln403">                  group = NoteHead::Group::HEAD_C_SHARP;</a>
<a name="ln404">            else if (tpc == Tpc::TPC_D_S)</a>
<a name="ln405">                  group = NoteHead::Group::HEAD_D_SHARP;</a>
<a name="ln406">            else if (tpc == Tpc::TPC_E_S)</a>
<a name="ln407">                  group = NoteHead::Group::HEAD_E_SHARP;</a>
<a name="ln408">            else if (tpc == Tpc::TPC_F_S)</a>
<a name="ln409">                  group = NoteHead::Group::HEAD_F_SHARP;</a>
<a name="ln410">            else if (tpc == Tpc::TPC_G_S)</a>
<a name="ln411">                  group = NoteHead::Group::HEAD_G_SHARP;</a>
<a name="ln412">            else if (tpc == Tpc::TPC_A_B)</a>
<a name="ln413">                  group = NoteHead::Group::HEAD_A_FLAT;</a>
<a name="ln414">            else if (tpc == Tpc::TPC_B_B)</a>
<a name="ln415">                  if (scheme == NoteHeadScheme::HEAD_PITCHNAME_GERMAN)</a>
<a name="ln416">                        group = NoteHead::Group::HEAD_B;</a>
<a name="ln417">                  else</a>
<a name="ln418">                        group = NoteHead::Group::HEAD_B_FLAT;</a>
<a name="ln419">            else if (tpc == Tpc::TPC_C_B)</a>
<a name="ln420">                  group = NoteHead::Group::HEAD_C_FLAT;</a>
<a name="ln421">            else if (tpc == Tpc::TPC_D_B)</a>
<a name="ln422">                  group = NoteHead::Group::HEAD_D_FLAT;</a>
<a name="ln423">            else if (tpc == Tpc::TPC_E_B)</a>
<a name="ln424">                  group = NoteHead::Group::HEAD_E_FLAT;</a>
<a name="ln425">            else if (tpc == Tpc::TPC_F_B)</a>
<a name="ln426">                  group = NoteHead::Group::HEAD_F_FLAT;</a>
<a name="ln427">            else if (tpc == Tpc::TPC_G_B)</a>
<a name="ln428">                  group = NoteHead::Group::HEAD_G_FLAT;</a>
<a name="ln429">            }</a>
<a name="ln430">      else if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_4) {</a>
<a name="ln431">            int degree = tpc2degree(tpc, key);</a>
<a name="ln432">            switch (degree) {</a>
<a name="ln433">                  case 0:</a>
<a name="ln434">                  case 3:</a>
<a name="ln435">                        group = NoteHead::Group::HEAD_FA; break;</a>
<a name="ln436">                  case 1:</a>
<a name="ln437">                  case 4:</a>
<a name="ln438">                        group = NoteHead::Group::HEAD_SOL; break;</a>
<a name="ln439">                  case 2:</a>
<a name="ln440">                  case 5:</a>
<a name="ln441">                        group = NoteHead::Group::HEAD_LA; break;</a>
<a name="ln442">                  case 6:</a>
<a name="ln443">                        group = NoteHead::Group::HEAD_MI; break;</a>
<a name="ln444">                  }</a>
<a name="ln445">            }</a>
<a name="ln446">      else if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_AIKIN</a>
<a name="ln447">         || scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_FUNK</a>
<a name="ln448">         || scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_WALKER) {</a>
<a name="ln449">            int degree = tpc2degree(tpc, key);</a>
<a name="ln450">            switch (degree) {</a>
<a name="ln451">                  case 0:</a>
<a name="ln452">                        if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_AIKIN)</a>
<a name="ln453">                              group = NoteHead::Group::HEAD_DO;</a>
<a name="ln454">                        else if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_FUNK)</a>
<a name="ln455">                              group = NoteHead::Group::HEAD_DO_FUNK;</a>
<a name="ln456">                        else if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_WALKER)</a>
<a name="ln457">                              group = NoteHead::Group::HEAD_DO_WALKER;</a>
<a name="ln458">                        break;</a>
<a name="ln459">                  case 1:</a>
<a name="ln460">                        if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_AIKIN)</a>
<a name="ln461">                              group = NoteHead::Group::HEAD_RE;</a>
<a name="ln462">                        else if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_FUNK)</a>
<a name="ln463">                              group = NoteHead::Group::HEAD_RE_FUNK;</a>
<a name="ln464">                        else if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_WALKER)</a>
<a name="ln465">                              group = NoteHead::Group::HEAD_RE_WALKER;</a>
<a name="ln466">                        break;</a>
<a name="ln467">                  case 2:</a>
<a name="ln468">                        group = NoteHead::Group::HEAD_MI; break;</a>
<a name="ln469">                  case 3:</a>
<a name="ln470">                        group = NoteHead::Group::HEAD_FA; break;</a>
<a name="ln471">                  case 4:</a>
<a name="ln472">                        group = NoteHead::Group::HEAD_SOL; break;</a>
<a name="ln473">                  case 5:</a>
<a name="ln474">                        group = NoteHead::Group::HEAD_LA; break;</a>
<a name="ln475">                  case 6:</a>
<a name="ln476">                        if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_AIKIN)</a>
<a name="ln477">                              group = NoteHead::Group::HEAD_TI;</a>
<a name="ln478">                        else if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_FUNK)</a>
<a name="ln479">                              group = NoteHead::Group::HEAD_TI_FUNK;</a>
<a name="ln480">                        else if (scheme == NoteHeadScheme::HEAD_SHAPE_NOTE_7_WALKER)</a>
<a name="ln481">                              group = NoteHead::Group::HEAD_TI_WALKER;</a>
<a name="ln482">                        break;</a>
<a name="ln483">                  }</a>
<a name="ln484">            }</a>
<a name="ln485">      else if (scheme == NoteHeadScheme::HEAD_SOLFEGE) {</a>
<a name="ln486">            int degree = tpc2degree(tpc, key);</a>
<a name="ln487">            switch (degree) {</a>
<a name="ln488">                  case 0:</a>
<a name="ln489">                        group = NoteHead::Group::HEAD_DO_NAME; break;</a>
<a name="ln490">                  case 1:</a>
<a name="ln491">                        group = NoteHead::Group::HEAD_RE_NAME; break;</a>
<a name="ln492">                  case 2:</a>
<a name="ln493">                        group = NoteHead::Group::HEAD_MI_NAME; break;</a>
<a name="ln494">                  case 3:</a>
<a name="ln495">                        group = NoteHead::Group::HEAD_FA_NAME; break;</a>
<a name="ln496">                  case 4:</a>
<a name="ln497">                        group = NoteHead::Group::HEAD_SOL_NAME; break;</a>
<a name="ln498">                  case 5:</a>
<a name="ln499">                        group = NoteHead::Group::HEAD_LA_NAME; break;</a>
<a name="ln500">                  case 6:</a>
<a name="ln501">                        group = NoteHead::Group::HEAD_TI_NAME; break;</a>
<a name="ln502">                  }</a>
<a name="ln503">            }</a>
<a name="ln504">      else if (scheme == NoteHeadScheme::HEAD_SOLFEGE_FIXED) {</a>
<a name="ln505">            QString stepName = tpc2stepName(tpc);</a>
<a name="ln506">            if (stepName == &quot;C&quot;)</a>
<a name="ln507">                  group = NoteHead::Group::HEAD_DO_NAME;</a>
<a name="ln508">            else if (stepName == &quot;D&quot;)</a>
<a name="ln509">                  group = NoteHead::Group::HEAD_RE_NAME;</a>
<a name="ln510">            else if (stepName == &quot;E&quot;)</a>
<a name="ln511">                  group = NoteHead::Group::HEAD_MI_NAME;</a>
<a name="ln512">            else if (stepName == &quot;F&quot;)</a>
<a name="ln513">                  group = NoteHead::Group::HEAD_FA_NAME;</a>
<a name="ln514">            else if (stepName == &quot;G&quot;)</a>
<a name="ln515">                  group = NoteHead::Group::HEAD_SOL_NAME;</a>
<a name="ln516">            else if (stepName == &quot;A&quot;)</a>
<a name="ln517">                  group = NoteHead::Group::HEAD_LA_NAME;</a>
<a name="ln518">            else if (stepName == &quot;B&quot;)</a>
<a name="ln519">                  group = NoteHead::Group::HEAD_SI_NAME;</a>
<a name="ln520">            }</a>
<a name="ln521">      return noteHeads[direction][int(group)][int(t)];</a>
<a name="ln522">      };</a>
<a name="ln523"> </a>
<a name="ln524">//---------------------------------------------------------</a>
<a name="ln525">//   headGroup</a>
<a name="ln526">//   used only when dropping a notehead from the palette</a>
<a name="ln527">//   they are either half note, either double whole</a>
<a name="ln528">//---------------------------------------------------------</a>
<a name="ln529"> </a>
<a name="ln530">NoteHead::Group NoteHead::headGroup() const</a>
<a name="ln531">      {</a>
<a name="ln532">      Group group = Group::HEAD_INVALID;</a>
<a name="ln533">      for (int i = 0; i &lt; int(Group::HEAD_DO_WALKER); ++i) {</a>
<a name="ln534">            if (noteHeads[0][i][1] == _sym || noteHeads[0][i][3] == _sym) {</a>
<a name="ln535">                  group = (Group)i;</a>
<a name="ln536">                        break;</a>
<a name="ln537">                  }</a>
<a name="ln538">            }</a>
<a name="ln539">      return group;</a>
<a name="ln540">      }</a>
<a name="ln541"> </a>
<a name="ln542">//---------------------------------------------------------</a>
<a name="ln543">//   Note</a>
<a name="ln544">//---------------------------------------------------------</a>
<a name="ln545"> </a>
<a name="ln546">Note::Note(Score* s)</a>
<a name="ln547">   : Element(s, ElementFlag::MOVABLE)</a>
<a name="ln548">      {</a>
<a name="ln549">      _playEvents.append(NoteEvent());    // add default play event</a>
<a name="ln550">      _cachedNoteheadSym = SymId::noSym;</a>
<a name="ln551">      _cachedSymNull = SymId::noSym;</a>
<a name="ln552">      }</a>
<a name="ln553"> </a>
<a name="ln554">Note::~Note()</a>
<a name="ln555">      {</a>
<a name="ln556">      delete _accidental;</a>
<a name="ln557">      qDeleteAll(_el);</a>
<a name="ln558">      delete _tieFor;</a>
<a name="ln559">      qDeleteAll(_dots);</a>
<a name="ln560">      }</a>
<a name="ln561"> </a>
<a name="ln562">Note::Note(const Note&amp; n, bool link)</a>
<a name="ln563">   : Element(n)</a>
<a name="ln564">      {</a>
<a name="ln565">      if (link)</a>
<a name="ln566">            score()-&gt;undo(new Link(this, const_cast&lt;Note*&gt;(&amp;n)));</a>
<a name="ln567">      _subchannel        = n._subchannel;</a>
<a name="ln568">      _line              = n._line;</a>
<a name="ln569">      _fret              = n._fret;</a>
<a name="ln570">      _string            = n._string;</a>
<a name="ln571">      _fretConflict      = n._fretConflict;</a>
<a name="ln572">      _ghost             = n._ghost;</a>
<a name="ln573">      dragMode           = n.dragMode;</a>
<a name="ln574">      _pitch             = n._pitch;</a>
<a name="ln575">      _tpc[0]            = n._tpc[0];</a>
<a name="ln576">      _tpc[1]            = n._tpc[1];</a>
<a name="ln577">      _dotsHidden        = n._dotsHidden;</a>
<a name="ln578">      _hidden            = n._hidden;</a>
<a name="ln579">      _play              = n._play;</a>
<a name="ln580">      _tuning            = n._tuning;</a>
<a name="ln581">      _veloType          = n._veloType;</a>
<a name="ln582">      _veloOffset        = n._veloOffset;</a>
<a name="ln583">      _headGroup         = n._headGroup;</a>
<a name="ln584">      _headType          = n._headType;</a>
<a name="ln585">      _mirror            = n._mirror;</a>
<a name="ln586">      _userMirror        = n._userMirror;</a>
<a name="ln587">      _small             = n._small;</a>
<a name="ln588">      _userDotPosition   = n._userDotPosition;</a>
<a name="ln589">      _fixed             = n._fixed;</a>
<a name="ln590">      _fixedLine         = n._fixedLine;</a>
<a name="ln591">      _accidental        = 0;</a>
<a name="ln592">      _cachedNoteheadSym = n._cachedNoteheadSym;</a>
<a name="ln593">      _cachedSymNull     = n._cachedSymNull;</a>
<a name="ln594"> </a>
<a name="ln595">      if (n._accidental)</a>
<a name="ln596">            add(new Accidental(*(n._accidental)));</a>
<a name="ln597"> </a>
<a name="ln598">      // types in _el: SYMBOL, IMAGE, FINGERING, TEXT, BEND</a>
<a name="ln599">      const Staff* stf = staff();</a>
<a name="ln600">      bool tabFingering = stf-&gt;staffType(tick())-&gt;showTabFingering();</a>
<a name="ln601">      for (Element* e : n._el) {</a>
<a name="ln602">            if (e-&gt;isFingering() &amp;&amp; staff()-&gt;isTabStaff(tick()) &amp;&amp; !tabFingering)    // tablature has no fingering</a>
<a name="ln603">                  continue;</a>
<a name="ln604">            Element* ce = e-&gt;clone();</a>
<a name="ln605">            add(ce);</a>
<a name="ln606">            if (link)</a>
<a name="ln607">                  score()-&gt;undo(new Link(ce, const_cast&lt;Element*&gt;(e)));</a>
<a name="ln608">            }</a>
<a name="ln609"> </a>
<a name="ln610">      _playEvents = n._playEvents;</a>
<a name="ln611"> </a>
<a name="ln612">      if (n._tieFor) {</a>
<a name="ln613">            _tieFor = new Tie(*n._tieFor);</a>
<a name="ln614">            _tieFor-&gt;setStartNote(this);</a>
<a name="ln615">            _tieFor-&gt;setEndNote(0);</a>
<a name="ln616">            }</a>
<a name="ln617">      else</a>
<a name="ln618">            _tieFor = 0;</a>
<a name="ln619">      _tieBack  = 0;</a>
<a name="ln620">      for (NoteDot* dot : n._dots)</a>
<a name="ln621">            add(new NoteDot(*dot));</a>
<a name="ln622">      _mark      = n._mark;</a>
<a name="ln623">      }</a>
<a name="ln624"> </a>
<a name="ln625">//---------------------------------------------------------</a>
<a name="ln626">//   concertPitchIdx</a>
<a name="ln627">//---------------------------------------------------------</a>
<a name="ln628"> </a>
<a name="ln629">inline int Note::concertPitchIdx() const</a>
<a name="ln630">      {</a>
<a name="ln631">      return concertPitch() ? 0 : 1;</a>
<a name="ln632">      }</a>
<a name="ln633"> </a>
<a name="ln634">//---------------------------------------------------------</a>
<a name="ln635">//   setPitch</a>
<a name="ln636">//---------------------------------------------------------</a>
<a name="ln637"> </a>
<a name="ln638">void Note::setPitch(int val)</a>
<a name="ln639">      {</a>
<a name="ln640">      Q_ASSERT(pitchIsValid(val));</a>
<a name="ln641">      if (_pitch != val) {</a>
<a name="ln642">            _pitch = val;</a>
<a name="ln643">            score()-&gt;setPlaylistDirty();</a>
<a name="ln644">            }</a>
<a name="ln645">      }</a>
<a name="ln646"> </a>
<a name="ln647">void Note::setPitch(int pitch, int tpc1, int tpc2)</a>
<a name="ln648">      {</a>
<a name="ln649">      Q_ASSERT(tpcIsValid(tpc1));</a>
<a name="ln650">      Q_ASSERT(tpcIsValid(tpc2));</a>
<a name="ln651">      _tpc[0] = tpc1;</a>
<a name="ln652">      _tpc[1] = tpc2;</a>
<a name="ln653">      setPitch(pitch);</a>
<a name="ln654">      }</a>
<a name="ln655"> </a>
<a name="ln656">//---------------------------------------------------------</a>
<a name="ln657">//   tpc1default</a>
<a name="ln658">//---------------------------------------------------------</a>
<a name="ln659"> </a>
<a name="ln660">int Note::tpc1default(int p) const</a>
<a name="ln661">      {</a>
<a name="ln662">      Key key = Key::C;</a>
<a name="ln663">      if (staff() &amp;&amp; chord()) {</a>
<a name="ln664">            Fraction tick = chord()-&gt;tick();</a>
<a name="ln665">            key = staff()-&gt;key(tick);</a>
<a name="ln666">            if (!concertPitch()) {</a>
<a name="ln667">                  Interval interval = part()-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln668">                  if (!interval.isZero()) {</a>
<a name="ln669">                        interval.flip();</a>
<a name="ln670">                        key = transposeKey(key, interval);</a>
<a name="ln671">                        }</a>
<a name="ln672">                  }</a>
<a name="ln673">            }</a>
<a name="ln674">      return pitch2tpc(p, key, Prefer::NEAREST);</a>
<a name="ln675">      }</a>
<a name="ln676"> </a>
<a name="ln677">//---------------------------------------------------------</a>
<a name="ln678">//   tpc2default</a>
<a name="ln679">//---------------------------------------------------------</a>
<a name="ln680"> </a>
<a name="ln681">int Note::tpc2default(int p) const</a>
<a name="ln682">      {</a>
<a name="ln683">      Key key = Key::C;</a>
<a name="ln684">      if (staff() &amp;&amp; chord()) {</a>
<a name="ln685">            Fraction tick = chord()-&gt;tick();</a>
<a name="ln686">            key = staff()-&gt;key(tick);</a>
<a name="ln687">            if (concertPitch()) {</a>
<a name="ln688">                  Interval interval = part()-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln689">                  if (!interval.isZero())</a>
<a name="ln690">                        key = transposeKey(key, interval);</a>
<a name="ln691">                  }</a>
<a name="ln692">            }</a>
<a name="ln693">      return pitch2tpc(p - transposition(), key, Prefer::NEAREST);</a>
<a name="ln694">      }</a>
<a name="ln695"> </a>
<a name="ln696">//---------------------------------------------------------</a>
<a name="ln697">//   setTpcFromPitch</a>
<a name="ln698">//---------------------------------------------------------</a>
<a name="ln699"> </a>
<a name="ln700">void Note::setTpcFromPitch()</a>
<a name="ln701">      {</a>
<a name="ln702">      // works best if note is already added to score, otherwise we can't determine transposition or key</a>
<a name="ln703">      Fraction tick = chord() ? chord()-&gt;tick() : Fraction(-1,1);</a>
<a name="ln704">      Interval v = staff() ? part()-&gt;instrument(tick)-&gt;transpose() : Interval();</a>
<a name="ln705">      Key key = (staff() &amp;&amp; chord()) ? staff()-&gt;key(chord()-&gt;tick()) : Key::C;</a>
<a name="ln706">      // convert key to concert pitch</a>
<a name="ln707">      if (!concertPitch() &amp;&amp; !v.isZero())</a>
<a name="ln708">            key = transposeKey(key, v);</a>
<a name="ln709">      // set concert pitch tpc</a>
<a name="ln710">      _tpc[0] = pitch2tpc(_pitch, key, Prefer::NEAREST);</a>
<a name="ln711">      // set transposed tpc</a>
<a name="ln712">      if (v.isZero())</a>
<a name="ln713">            _tpc[1] = _tpc[0];</a>
<a name="ln714">      else {</a>
<a name="ln715">            v.flip();</a>
<a name="ln716">            _tpc[1] = Ms::transposeTpc(_tpc[0], v, true);</a>
<a name="ln717">            }</a>
<a name="ln718">      Q_ASSERT(tpcIsValid(_tpc[0]));</a>
<a name="ln719">      Q_ASSERT(tpcIsValid(_tpc[1]));</a>
<a name="ln720">      }</a>
<a name="ln721"> </a>
<a name="ln722">//---------------------------------------------------------</a>
<a name="ln723">//   setTpc</a>
<a name="ln724">//---------------------------------------------------------</a>
<a name="ln725"> </a>
<a name="ln726">void Note::setTpc(int v)</a>
<a name="ln727">      {</a>
<a name="ln728">      if (!tpcIsValid(v))</a>
<a name="ln729">            qFatal(&quot;Note::setTpc: bad tpc %d&quot;, v);</a>
<a name="ln730">      _tpc[concertPitchIdx()] = v;</a>
<a name="ln731">      }</a>
<a name="ln732"> </a>
<a name="ln733">//---------------------------------------------------------</a>
<a name="ln734">//   undoSetTpc</a>
<a name="ln735">//    change the current tpc</a>
<a name="ln736">//---------------------------------------------------------</a>
<a name="ln737"> </a>
<a name="ln738">void Note::undoSetTpc(int v)</a>
<a name="ln739">      {</a>
<a name="ln740">      if (concertPitch()) {</a>
<a name="ln741">            if (v != tpc1())</a>
<a name="ln742">                  undoChangeProperty(Pid::TPC1, v);</a>
<a name="ln743">            }</a>
<a name="ln744">      else {</a>
<a name="ln745">            if (v != tpc2())</a>
<a name="ln746">                  undoChangeProperty(Pid::TPC2, v);</a>
<a name="ln747">            }</a>
<a name="ln748">      }</a>
<a name="ln749"> </a>
<a name="ln750">//---------------------------------------------------------</a>
<a name="ln751">//   tpc</a>
<a name="ln752">//---------------------------------------------------------</a>
<a name="ln753"> </a>
<a name="ln754">int Note::tpc() const</a>
<a name="ln755">      {</a>
<a name="ln756">      return _tpc[concertPitchIdx()];</a>
<a name="ln757">      }</a>
<a name="ln758"> </a>
<a name="ln759">//---------------------------------------------------------</a>
<a name="ln760">//   tpcUserName</a>
<a name="ln761">//---------------------------------------------------------</a>
<a name="ln762"> </a>
<a name="ln763">QString Note::tpcUserName(bool explicitAccidental) const</a>
<a name="ln764">      {</a>
<a name="ln765">      QString pitchName = tpc2name(tpc(), NoteSpellingType::STANDARD, NoteCaseType::AUTO, explicitAccidental);</a>
<a name="ln766">      QString octaveName = QString::number(((epitch() + ottaveCapoFret() - static_cast&lt;int&gt;(tpc2alter(tpc()))) / 12) - 1);</a>
<a name="ln767">      return pitchName + (explicitAccidental ? &quot; &quot; : &quot;&quot;) + octaveName;</a>
<a name="ln768">      }</a>
<a name="ln769"> </a>
<a name="ln770">//---------------------------------------------------------</a>
<a name="ln771">//   transposeTpc</a>
<a name="ln772">//    return transposed tpc</a>
<a name="ln773">//    If in concertPitch mode return tpc for transposed view</a>
<a name="ln774">//    else return tpc for concert pitch view.</a>
<a name="ln775">//---------------------------------------------------------</a>
<a name="ln776"> </a>
<a name="ln777">int Note::transposeTpc(int tpc)</a>
<a name="ln778">      {</a>
<a name="ln779">      Fraction tick = chord() ? chord()-&gt;tick() : Fraction(-1,1);</a>
<a name="ln780">      Interval v = part()-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln781">      if (v.isZero())</a>
<a name="ln782">            return tpc;</a>
<a name="ln783">      if (concertPitch()) {</a>
<a name="ln784">            v.flip();</a>
<a name="ln785">            return Ms::transposeTpc(tpc, v, true);</a>
<a name="ln786">            }</a>
<a name="ln787">      else</a>
<a name="ln788">            return Ms::transposeTpc(tpc, v, true);</a>
<a name="ln789">      }</a>
<a name="ln790"> </a>
<a name="ln791">//---------------------------------------------------------</a>
<a name="ln792">//   noteHead</a>
<a name="ln793">//---------------------------------------------------------</a>
<a name="ln794"> </a>
<a name="ln795">SymId Note::noteHead() const</a>
<a name="ln796">      {</a>
<a name="ln797">      int up;</a>
<a name="ln798">      NoteHead::Type ht;</a>
<a name="ln799">      if (chord()) {</a>
<a name="ln800">            up = chord()-&gt;up();</a>
<a name="ln801">            ht = chord()-&gt;durationType().headType();</a>
<a name="ln802">            }</a>
<a name="ln803">      else {</a>
<a name="ln804">            up = 1;</a>
<a name="ln805">            ht = NoteHead::Type::HEAD_QUARTER;</a>
<a name="ln806">            }</a>
<a name="ln807">      if (_headType != NoteHead::Type::HEAD_AUTO)</a>
<a name="ln808">            ht = _headType;</a>
<a name="ln809"> </a>
<a name="ln810">      if (_headGroup == NoteHead::Group::HEAD_CUSTOM) {</a>
<a name="ln811">            if (chord() &amp;&amp; chord()-&gt;staff()) {</a>
<a name="ln812">                  const Staff* st = chord()-&gt;staff();</a>
<a name="ln813">                  if (st-&gt;staffType(chord()-&gt;tick())-&gt;isDrumStaff())</a>
<a name="ln814">                        return st-&gt;part()-&gt;instrument(chord()-&gt;tick())-&gt;drumset()-&gt;noteHeads(_pitch, ht);</a>
<a name="ln815">                  }</a>
<a name="ln816">            else {</a>
<a name="ln817">                  return _cachedNoteheadSym;</a>
<a name="ln818">                  }</a>
<a name="ln819">            }</a>
<a name="ln820"> </a>
<a name="ln821">      Key key = Key::C;</a>
<a name="ln822">      NoteHeadScheme scheme = NoteHeadScheme::HEAD_NORMAL;</a>
<a name="ln823">      if (chord() &amp;&amp; chord()-&gt;staff()){</a>
<a name="ln824">            Fraction tick = chord()-&gt;tick();</a>
<a name="ln825">            if (tick &gt;= Fraction(0,1)) {</a>
<a name="ln826">                  const Staff* st = chord()-&gt;staff();</a>
<a name="ln827">                  key    = st-&gt;key(tick);</a>
<a name="ln828">                  scheme = st-&gt;staffType(tick)-&gt;noteHeadScheme();</a>
<a name="ln829">                  }</a>
<a name="ln830">            }</a>
<a name="ln831">      SymId t = noteHead(up, _headGroup, ht, tpc(), key, scheme);</a>
<a name="ln832">      if (t == SymId::noSym) {</a>
<a name="ln833">            qDebug(&quot;invalid notehead %d/%d&quot;, int(_headGroup), int(ht));</a>
<a name="ln834">            t = noteHead(up, NoteHead::Group::HEAD_NORMAL, ht);</a>
<a name="ln835">            }</a>
<a name="ln836">      return t;</a>
<a name="ln837">      }</a>
<a name="ln838"> </a>
<a name="ln839">//---------------------------------------------------------</a>
<a name="ln840">//   headWidth</a>
<a name="ln841">//</a>
<a name="ln842">//    returns the x of the symbol bbox. It is different from headWidth() because zero point could be different from leftmost bbox position.</a>
<a name="ln843">//---------------------------------------------------------</a>
<a name="ln844">qreal Note::bboxRightPos() const</a>
<a name="ln845">      {</a>
<a name="ln846">      const auto&amp; bbox = score()-&gt;scoreFont()-&gt;bbox(noteHead(), magS());</a>
<a name="ln847">      return bbox.right();</a>
<a name="ln848">      }</a>
<a name="ln849"> </a>
<a name="ln850">//---------------------------------------------------------</a>
<a name="ln851">//   headBodyWidth</a>
<a name="ln852">//</a>
<a name="ln853">//    returns the width of the notehead &quot;body&quot;. It is actual for slashed noteheads like -O-, where O is body.</a>
<a name="ln854">//---------------------------------------------------------</a>
<a name="ln855">qreal Note::headBodyWidth() const</a>
<a name="ln856">      {</a>
<a name="ln857">      return headWidth() + 2 * bboxXShift();</a>
<a name="ln858">      }</a>
<a name="ln859"> </a>
<a name="ln860">//---------------------------------------------------------</a>
<a name="ln861">//   headWidth</a>
<a name="ln862">//</a>
<a name="ln863">//    returns the width of the symbol bbox</a>
<a name="ln864">//    or the width of the string representation of the fret mark</a>
<a name="ln865">//---------------------------------------------------------</a>
<a name="ln866"> </a>
<a name="ln867">qreal Note::headWidth() const</a>
<a name="ln868">      {</a>
<a name="ln869">      return symWidth(noteHead());</a>
<a name="ln870">      }</a>
<a name="ln871"> </a>
<a name="ln872">//---------------------------------------------------------</a>
<a name="ln873">//   bboxXShift</a>
<a name="ln874">//</a>
<a name="ln875">//    returns the x shift of the notehead bounding box</a>
<a name="ln876">//---------------------------------------------------------</a>
<a name="ln877">qreal Note::bboxXShift() const</a>
<a name="ln878">      {</a>
<a name="ln879">      const auto&amp; bbox = score()-&gt;scoreFont()-&gt;bbox(noteHead(), magS());</a>
<a name="ln880">      return bbox.bottomLeft().x();</a>
<a name="ln881">      }</a>
<a name="ln882"> </a>
<a name="ln883">//---------------------------------------------------------</a>
<a name="ln884">//   noteheadCenterX</a>
<a name="ln885">//</a>
<a name="ln886">//    returns the x coordinate of the notehead center related to the basepoint of the notehead bbox</a>
<a name="ln887">//---------------------------------------------------------</a>
<a name="ln888">qreal Note::noteheadCenterX() const</a>
<a name="ln889">      {</a>
<a name="ln890">      return score()-&gt;scoreFont()-&gt;width(noteHead(), magS()) / 2 + bboxXShift();</a>
<a name="ln891">      }</a>
<a name="ln892">//---------------------------------------------------------</a>
<a name="ln893">//   tabHeadWidth</a>
<a name="ln894">//---------------------------------------------------------</a>
<a name="ln895"> </a>
<a name="ln896">qreal Note::tabHeadWidth(const StaffType* tab) const</a>
<a name="ln897">      {</a>
<a name="ln898">      qreal val;</a>
<a name="ln899">      if (tab &amp;&amp; _fret != FRET_NONE &amp;&amp; _string != STRING_NONE) {</a>
<a name="ln900">            QFont f    = tab-&gt;fretFont();</a>
<a name="ln901">            f.setPointSizeF(tab-&gt;fretFontSize());</a>
<a name="ln902">            QFontMetricsF fm(f, MScore::paintDevice());</a>
<a name="ln903">            val  = fm.width(_fretString) * magS();</a>
<a name="ln904">            }</a>
<a name="ln905">      else</a>
<a name="ln906">            val = headWidth();</a>
<a name="ln907">      return val;</a>
<a name="ln908">      }</a>
<a name="ln909"> </a>
<a name="ln910">//---------------------------------------------------------</a>
<a name="ln911">//   headHeight</a>
<a name="ln912">//</a>
<a name="ln913">//    returns the height of the notehead symbol</a>
<a name="ln914">//    or the height of the string representation of the fret mark</a>
<a name="ln915">//---------------------------------------------------------</a>
<a name="ln916"> </a>
<a name="ln917">qreal Note::headHeight() const</a>
<a name="ln918">      {</a>
<a name="ln919">      return symHeight(noteHead());</a>
<a name="ln920">      }</a>
<a name="ln921"> </a>
<a name="ln922">//---------------------------------------------------------</a>
<a name="ln923">//   tabHeadHeight</a>
<a name="ln924">//---------------------------------------------------------</a>
<a name="ln925"> </a>
<a name="ln926">qreal Note::tabHeadHeight(const StaffType* tab) const</a>
<a name="ln927">      {</a>
<a name="ln928">      if (tab &amp;&amp; _fret != FRET_NONE &amp;&amp; _string != STRING_NONE)</a>
<a name="ln929">            return tab-&gt;fretBoxH() * magS();</a>
<a name="ln930">      return headHeight();</a>
<a name="ln931">      }</a>
<a name="ln932"> </a>
<a name="ln933">//---------------------------------------------------------</a>
<a name="ln934">//   stemDownNW</a>
<a name="ln935">//---------------------------------------------------------</a>
<a name="ln936"> </a>
<a name="ln937">QPointF Note::stemDownNW() const</a>
<a name="ln938">      {</a>
<a name="ln939">      return symStemDownNW(noteHead());</a>
<a name="ln940">      }</a>
<a name="ln941"> </a>
<a name="ln942">//---------------------------------------------------------</a>
<a name="ln943">//   stemUpSE</a>
<a name="ln944">//---------------------------------------------------------</a>
<a name="ln945"> </a>
<a name="ln946">QPointF Note::stemUpSE() const</a>
<a name="ln947">      {</a>
<a name="ln948">      return symStemUpSE(noteHead());</a>
<a name="ln949">      }</a>
<a name="ln950"> </a>
<a name="ln951">//---------------------------------------------------------</a>
<a name="ln952">//   playTicks</a>
<a name="ln953">///   Return total tick len of tied notes</a>
<a name="ln954">//---------------------------------------------------------</a>
<a name="ln955"> </a>
<a name="ln956">int Note::playTicks() const</a>
<a name="ln957">      {</a>
<a name="ln958">      Fraction stick = firstTiedNote()-&gt;chord()-&gt;tick();</a>
<a name="ln959">      const Note* note = lastTiedNote();</a>
<a name="ln960">      return (note-&gt;chord()-&gt;tick() + note-&gt;chord()-&gt;actualTicks() - stick).ticks();</a>
<a name="ln961">      }</a>
<a name="ln962"> </a>
<a name="ln963">//---------------------------------------------------------</a>
<a name="ln964">//   addSpanner</a>
<a name="ln965">//---------------------------------------------------------</a>
<a name="ln966"> </a>
<a name="ln967">void Note::addSpanner(Spanner* l)</a>
<a name="ln968">      {</a>
<a name="ln969">      Element* e = l-&gt;endElement();</a>
<a name="ln970">      if (e &amp;&amp; e-&gt;isNote()) {</a>
<a name="ln971">            Note* note = toNote(e);</a>
<a name="ln972">            note-&gt;addSpannerBack(l);</a>
<a name="ln973">            if (l-&gt;isGlissando())</a>
<a name="ln974">                 note-&gt;chord()-&gt;setEndsGlissando(true);</a>
<a name="ln975">            }</a>
<a name="ln976">      addSpannerFor(l);</a>
<a name="ln977">      }</a>
<a name="ln978"> </a>
<a name="ln979">//---------------------------------------------------------</a>
<a name="ln980">//   removeSpanner</a>
<a name="ln981">//---------------------------------------------------------</a>
<a name="ln982"> </a>
<a name="ln983">void Note::removeSpanner(Spanner* l)</a>
<a name="ln984">      {</a>
<a name="ln985">      Note* e = toNote(l-&gt;endElement());</a>
<a name="ln986">      if (e &amp;&amp; e-&gt;isNote()) {</a>
<a name="ln987">            if (!e-&gt;removeSpannerBack(l)) {</a>
<a name="ln988">                  qDebug(&quot;Note::removeSpanner(%p): cannot remove spannerBack %s %p&quot;, this, l-&gt;name(), l);</a>
<a name="ln989">                  // abort();</a>
<a name="ln990">                  }</a>
<a name="ln991">            if (l-&gt;isGlissando())</a>
<a name="ln992">                 e-&gt;chord()-&gt;updateEndsGlissando();</a>
<a name="ln993">            }</a>
<a name="ln994">      if (!removeSpannerFor(l)) {</a>
<a name="ln995">            qDebug(&quot;Note(%p): cannot remove spannerFor %s %p&quot;, this, l-&gt;name(), l);</a>
<a name="ln996">            // abort();</a>
<a name="ln997">            }</a>
<a name="ln998">      }</a>
<a name="ln999"> </a>
<a name="ln1000">//---------------------------------------------------------</a>
<a name="ln1001">//   add</a>
<a name="ln1002">//---------------------------------------------------------</a>
<a name="ln1003"> </a>
<a name="ln1004">void Note::add(Element* e)</a>
<a name="ln1005">      {</a>
<a name="ln1006">      e-&gt;setParent(this);</a>
<a name="ln1007">      e-&gt;setTrack(track());</a>
<a name="ln1008"> </a>
<a name="ln1009">      switch(e-&gt;type()) {</a>
<a name="ln1010">            case ElementType::NOTEDOT:</a>
<a name="ln1011">                  _dots.append(toNoteDot(e));</a>
<a name="ln1012">                  break;</a>
<a name="ln1013">            case ElementType::FINGERING:</a>
<a name="ln1014">            case ElementType::SYMBOL:</a>
<a name="ln1015">            case ElementType::IMAGE:</a>
<a name="ln1016">            case ElementType::TEXT:</a>
<a name="ln1017">            case ElementType::BEND:</a>
<a name="ln1018">                  _el.push_back(e);</a>
<a name="ln1019">                  break;</a>
<a name="ln1020">            case ElementType::TIE: {</a>
<a name="ln1021">                  Tie* tie = toTie(e);</a>
<a name="ln1022">                  tie-&gt;setStartNote(this);</a>
<a name="ln1023">                  tie-&gt;setTrack(track());</a>
<a name="ln1024">                  setTieFor(tie);</a>
<a name="ln1025">                  if (tie-&gt;endNote())</a>
<a name="ln1026">                        tie-&gt;endNote()-&gt;setTieBack(tie);</a>
<a name="ln1027">                  }</a>
<a name="ln1028">                  break;</a>
<a name="ln1029">            case ElementType::ACCIDENTAL:</a>
<a name="ln1030">                  _accidental = toAccidental(e);</a>
<a name="ln1031">                  break;</a>
<a name="ln1032">            case ElementType::TEXTLINE:</a>
<a name="ln1033">            case ElementType::GLISSANDO:</a>
<a name="ln1034">                  addSpanner(toSpanner(e));</a>
<a name="ln1035">                  break;</a>
<a name="ln1036">            default:</a>
<a name="ln1037">                  qDebug(&quot;Note::add() not impl. %s&quot;, e-&gt;name());</a>
<a name="ln1038">                  break;</a>
<a name="ln1039">            }</a>
<a name="ln1040">      triggerLayout();</a>
<a name="ln1041">      }</a>
<a name="ln1042"> </a>
<a name="ln1043">//---------------------------------------------------------</a>
<a name="ln1044">//   remove</a>
<a name="ln1045">//---------------------------------------------------------</a>
<a name="ln1046"> </a>
<a name="ln1047">void Note::remove(Element* e)</a>
<a name="ln1048">      {</a>
<a name="ln1049">      switch(e-&gt;type()) {</a>
<a name="ln1050">            case ElementType::NOTEDOT:</a>
<a name="ln1051">                  _dots.takeLast();</a>
<a name="ln1052">                  break;</a>
<a name="ln1053"> </a>
<a name="ln1054">            case ElementType::TEXT:</a>
<a name="ln1055">            case ElementType::SYMBOL:</a>
<a name="ln1056">            case ElementType::IMAGE:</a>
<a name="ln1057">            case ElementType::FINGERING:</a>
<a name="ln1058">            case ElementType::BEND:</a>
<a name="ln1059">                  if (!_el.remove(e))</a>
<a name="ln1060">                        qDebug(&quot;Note::remove(): cannot find %s&quot;, e-&gt;name());</a>
<a name="ln1061">                  break;</a>
<a name="ln1062">            case ElementType::TIE: {</a>
<a name="ln1063">                  Tie* tie = toTie(e);</a>
<a name="ln1064">                  setTieFor(0);</a>
<a name="ln1065">                  if (tie-&gt;endNote())</a>
<a name="ln1066">                        tie-&gt;endNote()-&gt;setTieBack(0);</a>
<a name="ln1067">                  }</a>
<a name="ln1068">                  break;</a>
<a name="ln1069"> </a>
<a name="ln1070">            case ElementType::ACCIDENTAL:</a>
<a name="ln1071">                  _accidental = 0;</a>
<a name="ln1072">                  break;</a>
<a name="ln1073"> </a>
<a name="ln1074">            case ElementType::TEXTLINE:</a>
<a name="ln1075">            case ElementType::GLISSANDO:</a>
<a name="ln1076">                  removeSpanner(toSpanner(e));</a>
<a name="ln1077">                  break;</a>
<a name="ln1078"> </a>
<a name="ln1079">            default:</a>
<a name="ln1080">                  qDebug(&quot;Note::remove() not impl. %s&quot;, e-&gt;name());</a>
<a name="ln1081">                  break;</a>
<a name="ln1082">            }</a>
<a name="ln1083">      triggerLayout();</a>
<a name="ln1084">      }</a>
<a name="ln1085"> </a>
<a name="ln1086">//---------------------------------------------------------</a>
<a name="ln1087">//   isNoteName</a>
<a name="ln1088">//---------------------------------------------------------</a>
<a name="ln1089"> </a>
<a name="ln1090">bool Note::isNoteName() const</a>
<a name="ln1091">      {</a>
<a name="ln1092">      if (chord() &amp;&amp; chord()-&gt;staff()) {</a>
<a name="ln1093">            const Staff* st = staff();</a>
<a name="ln1094">            NoteHeadScheme s = st-&gt;staffType(tick())-&gt;noteHeadScheme();</a>
<a name="ln1095">            return s == NoteHeadScheme::HEAD_PITCHNAME || s == NoteHeadScheme::HEAD_PITCHNAME_GERMAN || s == NoteHeadScheme::HEAD_SOLFEGE || s == NoteHeadScheme::HEAD_SOLFEGE_FIXED;</a>
<a name="ln1096">            }</a>
<a name="ln1097">      return false;</a>
<a name="ln1098">      }</a>
<a name="ln1099"> </a>
<a name="ln1100">//---------------------------------------------------------</a>
<a name="ln1101">//   draw</a>
<a name="ln1102">//---------------------------------------------------------</a>
<a name="ln1103"> </a>
<a name="ln1104">void Note::draw(QPainter* painter) const</a>
<a name="ln1105">      {</a>
<a name="ln1106">      if (_hidden)</a>
<a name="ln1107">            return;</a>
<a name="ln1108"> </a>
<a name="ln1109">      QColor c(curColor());</a>
<a name="ln1110">      painter-&gt;setPen(c);</a>
<a name="ln1111">      bool tablature = staff() &amp;&amp; staff()-&gt;isTabStaff(chord()-&gt;tick());</a>
<a name="ln1112"> </a>
<a name="ln1113">      // tablature</a>
<a name="ln1114">      if (tablature) {</a>
<a name="ln1115">            const Staff* st = staff();</a>
<a name="ln1116">            const StaffType* tab = st-&gt;staffType(tick());</a>
<a name="ln1117">            if (tieBack() &amp;&amp; !tab-&gt;showBackTied()) {</a>
<a name="ln1118">                  if (chord()-&gt;measure()-&gt;system() == tieBack()-&gt;startNote()-&gt;chord()-&gt;measure()-&gt;system() &amp;&amp; el().size() == 0)</a>
<a name="ln1119">                        // fret should be hidden, so return without drawing it</a>
<a name="ln1120">                        return;</a>
<a name="ln1121">                  }</a>
<a name="ln1122">            // draw background, if required (to hide a segment of string line or to show a fretting conflict)</a>
<a name="ln1123">            if (!tab-&gt;linesThrough() || fretConflict()) {</a>
<a name="ln1124">                  qreal d  = spatium() * .1;</a>
<a name="ln1125">                  QRectF bb = QRectF(bbox().x()-d, tab-&gt;fretMaskY() * magS(), bbox().width() + 2 * d, tab-&gt;fretMaskH()*magS());</a>
<a name="ln1126">                  // we do not know which viewer did this draw() call</a>
<a name="ln1127">                  // so update all:</a>
<a name="ln1128">                  if (!score()-&gt;getViewer().empty()) {</a>
<a name="ln1129">                        for (MuseScoreView* view : score()-&gt;getViewer())</a>
<a name="ln1130">                              view-&gt;drawBackground(painter, bb);</a>
<a name="ln1131">                        }</a>
<a name="ln1132">                  else</a>
<a name="ln1133">                        painter-&gt;fillRect(bb, Qt::white);</a>
<a name="ln1134"> </a>
<a name="ln1135">                  if (fretConflict() &amp;&amp; !score()-&gt;printing() &amp;&amp; score()-&gt;showUnprintable()) {          //on fret conflict, draw on red background</a>
<a name="ln1136">                        painter-&gt;save();</a>
<a name="ln1137">                        painter-&gt;setPen(Qt::red);</a>
<a name="ln1138">                        painter-&gt;setBrush(QBrush(QColor(Qt::red)));</a>
<a name="ln1139">                        painter-&gt;drawRect(bb);</a>
<a name="ln1140">                        painter-&gt;restore();</a>
<a name="ln1141">                        }</a>
<a name="ln1142">                  }</a>
<a name="ln1143">            QFont f(tab-&gt;fretFont());</a>
<a name="ln1144">            f.setPointSizeF(f.pointSizeF() * magS() * MScore::pixelRatio);</a>
<a name="ln1145">            painter-&gt;setFont(f);</a>
<a name="ln1146">            painter-&gt;setPen(c);</a>
<a name="ln1147">            painter-&gt;drawText(QPointF(bbox().x(), tab-&gt;fretFontYOffset()), _fretString);</a>
<a name="ln1148">            }</a>
<a name="ln1149"> </a>
<a name="ln1150">      // NOT tablature</a>
<a name="ln1151"> </a>
<a name="ln1152">      else {</a>
<a name="ln1153">            // skip drawing, if second note of a cross-measure value</a>
<a name="ln1154">            if (chord()-&gt;crossMeasure() == CrossMeasure::SECOND)</a>
<a name="ln1155">                  return;</a>
<a name="ln1156">            // warn if pitch extends usable range of instrument</a>
<a name="ln1157">            // by coloring the notehead</a>
<a name="ln1158">            if (chord() &amp;&amp; chord()-&gt;segment() &amp;&amp; staff()</a>
<a name="ln1159">               &amp;&amp; !score()-&gt;printing() &amp;&amp; MScore::warnPitchRange &amp;&amp; !staff()-&gt;isDrumStaff(chord()-&gt;tick())) {</a>
<a name="ln1160">                  const Instrument* in = part()-&gt;instrument(chord()-&gt;tick());</a>
<a name="ln1161">                  int i = ppitch();</a>
<a name="ln1162">                  if (i &lt; in-&gt;minPitchP() || i &gt; in-&gt;maxPitchP())</a>
<a name="ln1163">                        painter-&gt;setPen(selected() ? Qt::darkRed : Qt::red);</a>
<a name="ln1164">                  else if (i &lt; in-&gt;minPitchA() || i &gt; in-&gt;maxPitchA())</a>
<a name="ln1165">                        painter-&gt;setPen(selected() ? QColor(&quot;#565600&quot;) : Qt::darkYellow);</a>
<a name="ln1166">                  }</a>
<a name="ln1167">            // draw blank notehead to avoid staff and ledger lines</a>
<a name="ln1168">            if (_cachedSymNull != SymId::noSym) {</a>
<a name="ln1169">                  painter-&gt;save();</a>
<a name="ln1170">                  painter-&gt;setPen(Qt::white);</a>
<a name="ln1171">                  drawSymbol(_cachedSymNull, painter);</a>
<a name="ln1172">                  painter-&gt;restore();</a>
<a name="ln1173">                  }</a>
<a name="ln1174">            drawSymbol(_cachedNoteheadSym, painter);</a>
<a name="ln1175">            }</a>
<a name="ln1176">      }</a>
<a name="ln1177"> </a>
<a name="ln1178">//--------------------------------------------------</a>
<a name="ln1179">//   Note::write</a>
<a name="ln1180">//---------------------------------------------------------</a>
<a name="ln1181"> </a>
<a name="ln1182">void Note::write(XmlWriter&amp; xml) const</a>
<a name="ln1183">      {</a>
<a name="ln1184">      xml.stag(this);</a>
<a name="ln1185">      Element::writeProperties(xml);</a>
<a name="ln1186"> </a>
<a name="ln1187">      if (_accidental)</a>
<a name="ln1188">            _accidental-&gt;write(xml);</a>
<a name="ln1189">      _el.write(xml);</a>
<a name="ln1190">      bool write_dots = false;</a>
<a name="ln1191">      for (NoteDot* dot : _dots)</a>
<a name="ln1192">            if (!dot-&gt;offset().isNull() || !dot-&gt;visible() || dot-&gt;color() != Qt::black || dot-&gt;visible() != visible()) {</a>
<a name="ln1193">                  write_dots = true;</a>
<a name="ln1194">                  break;</a>
<a name="ln1195">                  }</a>
<a name="ln1196">      if (write_dots)</a>
<a name="ln1197">            for (NoteDot* dot : _dots)</a>
<a name="ln1198">                  dot-&gt;write(xml);</a>
<a name="ln1199">      if (_tieFor)</a>
<a name="ln1200">            _tieFor-&gt;writeSpannerStart(xml, this, track());</a>
<a name="ln1201">      if (_tieBack)</a>
<a name="ln1202">            _tieBack-&gt;writeSpannerEnd(xml, this, track());</a>
<a name="ln1203">      if ((chord() == 0 || chord()-&gt;playEventType() != PlayEventType::Auto) &amp;&amp; !_playEvents.empty()) {</a>
<a name="ln1204">            xml.stag(&quot;Events&quot;);</a>
<a name="ln1205">            for (const NoteEvent&amp; e : _playEvents)</a>
<a name="ln1206">                  e.write(xml);</a>
<a name="ln1207">            xml.etag();</a>
<a name="ln1208">            }</a>
<a name="ln1209">      for (Pid id : { Pid::PITCH, Pid::TPC1, Pid::TPC2, Pid::SMALL, Pid::MIRROR_HEAD, Pid::DOT_POSITION,</a>
<a name="ln1210">         Pid::HEAD_GROUP, Pid::VELO_OFFSET, Pid::PLAY, Pid::TUNING, Pid::FRET, Pid::STRING,</a>
<a name="ln1211">         Pid::GHOST, Pid::HEAD_TYPE, Pid::VELO_TYPE, Pid::FIXED, Pid::FIXED_LINE</a>
<a name="ln1212">            }) {</a>
<a name="ln1213">            writeProperty(xml, id);</a>
<a name="ln1214">            }</a>
<a name="ln1215"> </a>
<a name="ln1216">      for (Spanner* e : _spannerFor)</a>
<a name="ln1217">            e-&gt;writeSpannerStart(xml, this, track());</a>
<a name="ln1218">      for (Spanner* e : _spannerBack)</a>
<a name="ln1219">            e-&gt;writeSpannerEnd(xml, this, track());</a>
<a name="ln1220"> </a>
<a name="ln1221">      xml.etag();</a>
<a name="ln1222">      }</a>
<a name="ln1223"> </a>
<a name="ln1224">//---------------------------------------------------------</a>
<a name="ln1225">//   Note::read</a>
<a name="ln1226">//---------------------------------------------------------</a>
<a name="ln1227"> </a>
<a name="ln1228">void Note::read(XmlReader&amp; e)</a>
<a name="ln1229">      {</a>
<a name="ln1230">      setTpc1(Tpc::TPC_INVALID);</a>
<a name="ln1231">      setTpc2(Tpc::TPC_INVALID);</a>
<a name="ln1232"> </a>
<a name="ln1233">      while (e.readNextStartElement()) {</a>
<a name="ln1234">            if (readProperties(e))</a>
<a name="ln1235">                  ;</a>
<a name="ln1236">            else</a>
<a name="ln1237">                  e.unknown();</a>
<a name="ln1238">            }</a>
<a name="ln1239">      // ensure sane values:</a>
<a name="ln1240">      _pitch = limit(_pitch, 0, 127);</a>
<a name="ln1241"> </a>
<a name="ln1242">      if (!tpcIsValid(_tpc[0]) &amp;&amp; !tpcIsValid(_tpc[1])) {</a>
<a name="ln1243">            Key key = (staff() &amp;&amp; chord()) ? staff()-&gt;key(chord()-&gt;tick()) : Key::C;</a>
<a name="ln1244">            int tpc = pitch2tpc(_pitch, key, Prefer::NEAREST);</a>
<a name="ln1245">            if (concertPitch())</a>
<a name="ln1246">                  _tpc[0] = tpc;</a>
<a name="ln1247">            else</a>
<a name="ln1248">                  _tpc[1] = tpc;</a>
<a name="ln1249">            }</a>
<a name="ln1250">      if (!(tpcIsValid(_tpc[0]) &amp;&amp; tpcIsValid(_tpc[1]))) {</a>
<a name="ln1251">            Fraction tick = chord() ? chord()-&gt;tick() : Fraction(-1,1);</a>
<a name="ln1252">            Interval v = staff() ? part()-&gt;instrument(tick)-&gt;transpose() : Interval();</a>
<a name="ln1253">            if (tpcIsValid(_tpc[0])) {</a>
<a name="ln1254">                  v.flip();</a>
<a name="ln1255">                  if (v.isZero())</a>
<a name="ln1256">                        _tpc[1] = _tpc[0];</a>
<a name="ln1257">                  else</a>
<a name="ln1258">                        _tpc[1] = Ms::transposeTpc(_tpc[0], v, true);</a>
<a name="ln1259">                  }</a>
<a name="ln1260">            else {</a>
<a name="ln1261">                  if (v.isZero())</a>
<a name="ln1262">                        _tpc[0] = _tpc[1];</a>
<a name="ln1263">                  else</a>
<a name="ln1264">                        _tpc[0] = Ms::transposeTpc(_tpc[1], v, true);</a>
<a name="ln1265">                  }</a>
<a name="ln1266">            }</a>
<a name="ln1267"> </a>
<a name="ln1268">      // check consistency of pitch, tpc1, tpc2, and transposition</a>
<a name="ln1269">      // see note in InstrumentChange::read() about a known case of tpc corruption produced in 2.0.x</a>
<a name="ln1270">      // but since there are other causes of tpc corruption (eg, https://musescore.org/en/node/74746)</a>
<a name="ln1271">      // including perhaps some we don't know about yet,</a>
<a name="ln1272">      // we will attempt to fix some problems here regardless of version</a>
<a name="ln1273"> </a>
<a name="ln1274">      if (staff() &amp;&amp; !staff()-&gt;isDrumStaff(e.tick()) &amp;&amp; !e.pasteMode() &amp;&amp; !MScore::testMode) {</a>
<a name="ln1275">            int tpc1Pitch = (tpc2pitch(_tpc[0]) + 12) % 12;</a>
<a name="ln1276">            int tpc2Pitch = (tpc2pitch(_tpc[1]) + 12) % 12;</a>
<a name="ln1277">            int soundingPitch = _pitch % 12;</a>
<a name="ln1278">            if (tpc1Pitch != soundingPitch) {</a>
<a name="ln1279">                  qDebug(&quot;bad tpc1 - soundingPitch = %d, tpc1 = %d&quot;, soundingPitch, tpc1Pitch);</a>
<a name="ln1280">                  _pitch += tpc1Pitch - soundingPitch;</a>
<a name="ln1281">                  }</a>
<a name="ln1282">            if (staff()) {</a>
<a name="ln1283">                  Interval v = staff()-&gt;part()-&gt;instrument(e.tick())-&gt;transpose();</a>
<a name="ln1284">                  int writtenPitch = (_pitch - v.chromatic) % 12;</a>
<a name="ln1285">                  if (tpc2Pitch != writtenPitch) {</a>
<a name="ln1286">                        qDebug(&quot;bad tpc2 - writtenPitch = %d, tpc2 = %d&quot;, writtenPitch, tpc2Pitch);</a>
<a name="ln1287">                        if (concertPitch()) {</a>
<a name="ln1288">                              // assume we want to keep sounding pitch</a>
<a name="ln1289">                              // so fix written pitch (tpc only)</a>
<a name="ln1290">                              v.flip();</a>
<a name="ln1291">                              _tpc[1] = Ms::transposeTpc(_tpc[0], v, true);</a>
<a name="ln1292">                              }</a>
<a name="ln1293">                        else {</a>
<a name="ln1294">                              // assume we want to keep written pitch</a>
<a name="ln1295">                              // so fix sounding pitch (both tpc and pitch)</a>
<a name="ln1296">                              _tpc[0] = Ms::transposeTpc(_tpc[1], v, true);</a>
<a name="ln1297">                              _pitch += tpc2Pitch - writtenPitch;</a>
<a name="ln1298">                              }</a>
<a name="ln1299">                        }</a>
<a name="ln1300">                  }</a>
<a name="ln1301">            }</a>
<a name="ln1302">      }</a>
<a name="ln1303"> </a>
<a name="ln1304">//---------------------------------------------------------</a>
<a name="ln1305">//   readProperties</a>
<a name="ln1306">//---------------------------------------------------------</a>
<a name="ln1307"> </a>
<a name="ln1308">bool Note::readProperties(XmlReader&amp; e)</a>
<a name="ln1309">      {</a>
<a name="ln1310">      const QStringRef&amp; tag(e.name());</a>
<a name="ln1311"> </a>
<a name="ln1312">      if (tag == &quot;pitch&quot;)</a>
<a name="ln1313">            _pitch = e.readInt();</a>
<a name="ln1314">      else if (tag == &quot;tpc&quot;) {</a>
<a name="ln1315">            _tpc[0] = e.readInt();</a>
<a name="ln1316">            _tpc[1] = _tpc[0];</a>
<a name="ln1317">            }</a>
<a name="ln1318">      else if (tag == &quot;track&quot;)            // for performance</a>
<a name="ln1319">            setTrack(e.readInt());</a>
<a name="ln1320">      else if (tag == &quot;Accidental&quot;) {</a>
<a name="ln1321">            Accidental* a = new Accidental(score());</a>
<a name="ln1322">            a-&gt;setTrack(track());</a>
<a name="ln1323">            a-&gt;read(e);</a>
<a name="ln1324">            add(a);</a>
<a name="ln1325">            }</a>
<a name="ln1326">      else if (tag == &quot;Spanner&quot;)</a>
<a name="ln1327">            Spanner::readSpanner(e, this, track());</a>
<a name="ln1328">      else if (tag == &quot;tpc2&quot;)</a>
<a name="ln1329">            _tpc[1] = e.readInt();</a>
<a name="ln1330">      else if (tag == &quot;small&quot;)</a>
<a name="ln1331">            setSmall(e.readInt());</a>
<a name="ln1332">      else if (tag == &quot;mirror&quot;)</a>
<a name="ln1333">            readProperty(e, Pid::MIRROR_HEAD);</a>
<a name="ln1334">      else if (tag == &quot;dotPosition&quot;)</a>
<a name="ln1335">            readProperty(e, Pid::DOT_POSITION);</a>
<a name="ln1336">      else if (tag == &quot;fixed&quot;)</a>
<a name="ln1337">            setFixed(e.readBool());</a>
<a name="ln1338">      else if (tag == &quot;fixedLine&quot;)</a>
<a name="ln1339">            setFixedLine(e.readInt());</a>
<a name="ln1340">      else if (tag == &quot;head&quot;)</a>
<a name="ln1341">            readProperty(e, Pid::HEAD_GROUP);</a>
<a name="ln1342">      else if (tag == &quot;velocity&quot;)</a>
<a name="ln1343">            setVeloOffset(e.readInt());</a>
<a name="ln1344">      else if (tag == &quot;play&quot;)</a>
<a name="ln1345">            setPlay(e.readInt());</a>
<a name="ln1346">      else if (tag == &quot;tuning&quot;)</a>
<a name="ln1347">            setTuning(e.readDouble());</a>
<a name="ln1348">      else if (tag == &quot;fret&quot;)</a>
<a name="ln1349">            setFret(e.readInt());</a>
<a name="ln1350">      else if (tag == &quot;string&quot;)</a>
<a name="ln1351">            setString(e.readInt());</a>
<a name="ln1352">      else if (tag == &quot;ghost&quot;)</a>
<a name="ln1353">            setGhost(e.readInt());</a>
<a name="ln1354">      else if (tag == &quot;headType&quot;)</a>
<a name="ln1355">            readProperty(e, Pid::HEAD_TYPE);</a>
<a name="ln1356">      else if (tag == &quot;veloType&quot;)</a>
<a name="ln1357">            readProperty(e, Pid::VELO_TYPE);</a>
<a name="ln1358">      else if (tag == &quot;line&quot;)</a>
<a name="ln1359">            setLine(e.readInt());</a>
<a name="ln1360">      else if (tag == &quot;Fingering&quot;) {</a>
<a name="ln1361">            Fingering* f = new Fingering(score());</a>
<a name="ln1362">            f-&gt;setTrack(track());</a>
<a name="ln1363">            f-&gt;read(e);</a>
<a name="ln1364">            add(f);</a>
<a name="ln1365">            }</a>
<a name="ln1366">      else if (tag == &quot;Symbol&quot;) {</a>
<a name="ln1367">            Symbol* s = new Symbol(score());</a>
<a name="ln1368">            s-&gt;setTrack(track());</a>
<a name="ln1369">            s-&gt;read(e);</a>
<a name="ln1370">            add(s);</a>
<a name="ln1371">            }</a>
<a name="ln1372">      else if (tag == &quot;Image&quot;) {</a>
<a name="ln1373">            if (MScore::noImages)</a>
<a name="ln1374">                  e.skipCurrentElement();</a>
<a name="ln1375">            else {</a>
<a name="ln1376">                  Image* image = new Image(score());</a>
<a name="ln1377">                  image-&gt;setTrack(track());</a>
<a name="ln1378">                  image-&gt;read(e);</a>
<a name="ln1379">                  add(image);</a>
<a name="ln1380">                  }</a>
<a name="ln1381">            }</a>
<a name="ln1382">      else if (tag == &quot;Bend&quot;) {</a>
<a name="ln1383">            Bend* b = new Bend(score());</a>
<a name="ln1384">            b-&gt;setTrack(track());</a>
<a name="ln1385">            b-&gt;read(e);</a>
<a name="ln1386">            add(b);</a>
<a name="ln1387">            }</a>
<a name="ln1388">      else if (tag == &quot;NoteDot&quot;) {</a>
<a name="ln1389">            NoteDot* dot = new NoteDot(score());</a>
<a name="ln1390">            dot-&gt;read(e);</a>
<a name="ln1391">            add(dot);</a>
<a name="ln1392">            }</a>
<a name="ln1393">      else if (tag == &quot;Events&quot;) {</a>
<a name="ln1394">            _playEvents.clear();    // remove default event</a>
<a name="ln1395">            while (e.readNextStartElement()) {</a>
<a name="ln1396">                  const QStringRef&amp; t(e.name());</a>
<a name="ln1397">                  if (t == &quot;Event&quot;) {</a>
<a name="ln1398">                        NoteEvent ne;</a>
<a name="ln1399">                        ne.read(e);</a>
<a name="ln1400">                        _playEvents.append(ne);</a>
<a name="ln1401">                        }</a>
<a name="ln1402">                  else</a>
<a name="ln1403">                        e.unknown();</a>
<a name="ln1404">                  }</a>
<a name="ln1405">            if (chord())</a>
<a name="ln1406">                  chord()-&gt;setPlayEventType(PlayEventType::User);</a>
<a name="ln1407">            }</a>
<a name="ln1408">      else if (tag == &quot;offset&quot;)</a>
<a name="ln1409">            Element::readProperties(e);</a>
<a name="ln1410">      else if (Element::readProperties(e))</a>
<a name="ln1411">            ;</a>
<a name="ln1412">      else</a>
<a name="ln1413">            return false;</a>
<a name="ln1414">      return true;</a>
<a name="ln1415">      }</a>
<a name="ln1416"> </a>
<a name="ln1417">//---------------------------------------------------------</a>
<a name="ln1418">//   Note::readAddConnector</a>
<a name="ln1419">//---------------------------------------------------------</a>
<a name="ln1420"> </a>
<a name="ln1421">void Note::readAddConnector(ConnectorInfoReader* info, bool pasteMode)</a>
<a name="ln1422">      {</a>
<a name="ln1423">      const ElementType type = info-&gt;type();</a>
<a name="ln1424">      const Location&amp; l = info-&gt;location();</a>
<a name="ln1425">      switch(type) {</a>
<a name="ln1426">            case ElementType::TIE:</a>
<a name="ln1427">            case ElementType::TEXTLINE:</a>
<a name="ln1428">            case ElementType::GLISSANDO:</a>
<a name="ln1429">                  {</a>
<a name="ln1430">                  Spanner* sp = toSpanner(info-&gt;connector());</a>
<a name="ln1431">                  if (info-&gt;isStart()) {</a>
<a name="ln1432">                        sp-&gt;setTrack(l.track());</a>
<a name="ln1433">                        sp-&gt;setTick(tick());</a>
<a name="ln1434">                        if (sp-&gt;isTie()) {</a>
<a name="ln1435">                              Note* n = this;</a>
<a name="ln1436">                              while (n-&gt;tieFor())</a>
<a name="ln1437">                                    n = n-&gt;tieFor()-&gt;endNote();</a>
<a name="ln1438">                              Tie* tie = toTie(sp);</a>
<a name="ln1439">                              tie-&gt;setParent(n);</a>
<a name="ln1440">                              tie-&gt;setStartNote(n);</a>
<a name="ln1441">                              n-&gt;_tieFor = tie;</a>
<a name="ln1442">                              }</a>
<a name="ln1443">                        else {</a>
<a name="ln1444">                              sp-&gt;setAnchor(Spanner::Anchor::NOTE);</a>
<a name="ln1445">                              sp-&gt;setStartElement(this);</a>
<a name="ln1446">                              addSpannerFor(sp);</a>
<a name="ln1447">                              sp-&gt;setParent(this);</a>
<a name="ln1448">                              }</a>
<a name="ln1449">                        }</a>
<a name="ln1450">                  else if (info-&gt;isEnd()) {</a>
<a name="ln1451">                        sp-&gt;setTrack2(l.track());</a>
<a name="ln1452">                        sp-&gt;setTick2(tick());</a>
<a name="ln1453">                        sp-&gt;setEndElement(this);</a>
<a name="ln1454">                        if (sp-&gt;isTie())</a>
<a name="ln1455">                              _tieBack = toTie(sp);</a>
<a name="ln1456">                        else {</a>
<a name="ln1457">                              if (sp-&gt;isGlissando() &amp;&amp; parent() &amp;&amp; parent()-&gt;isChord())</a>
<a name="ln1458">                                    toChord(parent())-&gt;setEndsGlissando(true);</a>
<a name="ln1459">                              addSpannerBack(sp);</a>
<a name="ln1460">                              }</a>
<a name="ln1461"> </a>
<a name="ln1462">                        // As spanners get added after being fully read, they</a>
<a name="ln1463">                        // do not get cloned with the note when pasting to</a>
<a name="ln1464">                        // linked staves. So add this spanner explicitly.</a>
<a name="ln1465">                        if (pasteMode)</a>
<a name="ln1466">                              score()-&gt;undoAddElement(sp);</a>
<a name="ln1467">                        }</a>
<a name="ln1468">                  }</a>
<a name="ln1469">            default:</a>
<a name="ln1470">                  break;</a>
<a name="ln1471">            }</a>
<a name="ln1472">      }</a>
<a name="ln1473"> </a>
<a name="ln1474">//---------------------------------------------------------</a>
<a name="ln1475">//   transposition</a>
<a name="ln1476">//---------------------------------------------------------</a>
<a name="ln1477"> </a>
<a name="ln1478">int Note::transposition() const</a>
<a name="ln1479">      {</a>
<a name="ln1480">      Fraction tick = chord() ? chord()-&gt;tick() : Fraction(-1,1);</a>
<a name="ln1481">      return staff() ? part()-&gt;instrument(tick)-&gt;transpose().chromatic : 0;</a>
<a name="ln1482">      }</a>
<a name="ln1483"> </a>
<a name="ln1484">//---------------------------------------------------------</a>
<a name="ln1485">//   NoteEditData</a>
<a name="ln1486">//---------------------------------------------------------</a>
<a name="ln1487"> </a>
<a name="ln1488">class NoteEditData : public ElementEditData {</a>
<a name="ln1489">   public:</a>
<a name="ln1490">      enum EditMode {</a>
<a name="ln1491">            EditMode_ChangePitch = 0,</a>
<a name="ln1492">            EditMode_AddSpacing,</a>
<a name="ln1493">            EditMode_Undefined,</a>
<a name="ln1494">            };</a>
<a name="ln1495"> </a>
<a name="ln1496">      int line = 0;</a>
<a name="ln1497">      int string = 0;</a>
<a name="ln1498">      EditMode mode = EditMode_Undefined;</a>
<a name="ln1499">      QPointF delta;</a>
<a name="ln1500"> </a>
<a name="ln1501">      virtual EditDataType type() override      { return EditDataType::NoteEditData; }</a>
<a name="ln1502"> </a>
<a name="ln1503">      static constexpr double MODE_TRANSITION_LIMIT_DEGREES = 15.0;</a>
<a name="ln1504"> </a>
<a name="ln1505">      static inline EditMode editModeByDragDirection(const qreal&amp; deltaX, const qreal&amp; deltaY)</a>
<a name="ln1506">            {</a>
<a name="ln1507">            qreal x = qAbs(deltaX);</a>
<a name="ln1508">            qreal y = qAbs(deltaY);</a>
<a name="ln1509"> </a>
<a name="ln1510">            QVector2D normalizedVector(x, y);</a>
<a name="ln1511"> </a>
<a name="ln1512">            normalizedVector.normalize();</a>
<a name="ln1513"> </a>
<a name="ln1514">            float radians = QVector2D::dotProduct(normalizedVector, QVector2D(1, 0));</a>
<a name="ln1515"> </a>
<a name="ln1516">            qreal degrees = (qAcos(radians) * 180.0) / M_PI;</a>
<a name="ln1517"> </a>
<a name="ln1518">            qDebug() &lt;&lt; &quot;NOTE DRAG DEGREES &quot; &lt;&lt; degrees;</a>
<a name="ln1519"> </a>
<a name="ln1520">            if (degrees &gt;= MODE_TRANSITION_LIMIT_DEGREES)</a>
<a name="ln1521">                  return NoteEditData::EditMode_ChangePitch;</a>
<a name="ln1522">            else</a>
<a name="ln1523">                  return NoteEditData::EditMode_AddSpacing;</a>
<a name="ln1524">            }</a>
<a name="ln1525">      };</a>
<a name="ln1526"> </a>
<a name="ln1527">//---------------------------------------------------------</a>
<a name="ln1528">//   acceptDrop</a>
<a name="ln1529">//---------------------------------------------------------</a>
<a name="ln1530"> </a>
<a name="ln1531">bool Note::acceptDrop(EditData&amp; data) const</a>
<a name="ln1532">      {</a>
<a name="ln1533">      Element* e = data.dropElement;</a>
<a name="ln1534">      ElementType type = e-&gt;type();</a>
<a name="ln1535">      if (type == ElementType::GLISSANDO) {</a>
<a name="ln1536">            for (auto ee : _spannerFor)</a>
<a name="ln1537">                  if (ee-&gt;isGlissando()) {</a>
<a name="ln1538">                        return false;</a>
<a name="ln1539">                  }</a>
<a name="ln1540">            return true;</a>
<a name="ln1541">            }</a>
<a name="ln1542">      const Staff* st   = staff();</a>
<a name="ln1543">      bool isTablature  = st-&gt;isTabStaff(tick());</a>
<a name="ln1544">      bool tabFingering = st-&gt;staffType(tick())-&gt;showTabFingering();</a>
<a name="ln1545">      return (type == ElementType::ARTICULATION</a>
<a name="ln1546">         || type == ElementType::FERMATA</a>
<a name="ln1547">         || type == ElementType::CHORDLINE</a>
<a name="ln1548">         || type == ElementType::TEXT</a>
<a name="ln1549">         || type == ElementType::REHEARSAL_MARK</a>
<a name="ln1550">         || (type == ElementType::FINGERING &amp;&amp; (!isTablature || tabFingering))</a>
<a name="ln1551">         || type == ElementType::ACCIDENTAL</a>
<a name="ln1552">         || type == ElementType::BREATH</a>
<a name="ln1553">         || type == ElementType::ARPEGGIO</a>
<a name="ln1554">         || type == ElementType::NOTEHEAD</a>
<a name="ln1555">         || type == ElementType::NOTE</a>
<a name="ln1556">         || type == ElementType::TREMOLO</a>
<a name="ln1557">         || type == ElementType::STAFF_STATE</a>
<a name="ln1558">         || type == ElementType::INSTRUMENT_CHANGE</a>
<a name="ln1559">         || type == ElementType::IMAGE</a>
<a name="ln1560">         || type == ElementType::CHORD</a>
<a name="ln1561">         || type == ElementType::HARMONY</a>
<a name="ln1562">         || type == ElementType::DYNAMIC</a>
<a name="ln1563">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::ACCIACCATURA)</a>
<a name="ln1564">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::APPOGGIATURA)</a>
<a name="ln1565">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::GRACE4)</a>
<a name="ln1566">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::GRACE16)</a>
<a name="ln1567">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::GRACE32)</a>
<a name="ln1568">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::GRACE8_AFTER)</a>
<a name="ln1569">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::GRACE16_AFTER)</a>
<a name="ln1570">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::GRACE32_AFTER)</a>
<a name="ln1571">         || (noteType() == NoteType::NORMAL &amp;&amp; type == ElementType::BAGPIPE_EMBELLISHMENT)</a>
<a name="ln1572">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::SBEAM)</a>
<a name="ln1573">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::MBEAM)</a>
<a name="ln1574">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::NBEAM)</a>
<a name="ln1575">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::BEAM32)</a>
<a name="ln1576">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::BEAM64)</a>
<a name="ln1577">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::AUTOBEAM)</a>
<a name="ln1578">         || (type == ElementType::ICON &amp;&amp; toIcon(e)-&gt;iconType() == IconType::PARENTHESES)</a>
<a name="ln1579">         || (type == ElementType::SYMBOL)</a>
<a name="ln1580">         || (type == ElementType::CLEF)</a>
<a name="ln1581">         || (type == ElementType::KEYSIG)</a>
<a name="ln1582">         || (type == ElementType::TIMESIG)</a>
<a name="ln1583">         || (type == ElementType::BAR_LINE)</a>
<a name="ln1584">         || (type == ElementType::SLUR)</a>
<a name="ln1585">         || (type == ElementType::HAIRPIN)</a>
<a name="ln1586">         || (type == ElementType::STAFF_TEXT)</a>
<a name="ln1587">         || (type == ElementType::SYSTEM_TEXT)</a>
<a name="ln1588">         || (type == ElementType::STICKING)</a>
<a name="ln1589">         || (type == ElementType::TEMPO_TEXT)</a>
<a name="ln1590">         || (type == ElementType::BEND)</a>
<a name="ln1591">         || (type == ElementType::TREMOLOBAR)</a>
<a name="ln1592">         || (type == ElementType::FRET_DIAGRAM)</a>
<a name="ln1593">         || (type == ElementType::FIGURED_BASS)</a>
<a name="ln1594">         || (type == ElementType::LYRICS));</a>
<a name="ln1595">      }</a>
<a name="ln1596"> </a>
<a name="ln1597">//---------------------------------------------------------</a>
<a name="ln1598">//   drop</a>
<a name="ln1599">//---------------------------------------------------------</a>
<a name="ln1600"> </a>
<a name="ln1601">Element* Note::drop(EditData&amp; data)</a>
<a name="ln1602">      {</a>
<a name="ln1603">      Element* e = data.dropElement;</a>
<a name="ln1604"> </a>
<a name="ln1605">      const Staff* st = staff();</a>
<a name="ln1606">      bool isTablature = st-&gt;isTabStaff(tick());</a>
<a name="ln1607">      bool tabFingering = st-&gt;staffType(tick())-&gt;showTabFingering();</a>
<a name="ln1608">      Chord* ch = chord();</a>
<a name="ln1609"> </a>
<a name="ln1610">      switch(e-&gt;type()) {</a>
<a name="ln1611">            case ElementType::REHEARSAL_MARK:</a>
<a name="ln1612">                  return ch-&gt;drop(data);</a>
<a name="ln1613"> </a>
<a name="ln1614">            case ElementType::SYMBOL:</a>
<a name="ln1615">            case ElementType::IMAGE:</a>
<a name="ln1616">                  e-&gt;setParent(this);</a>
<a name="ln1617">                  score()-&gt;undoAddElement(e);</a>
<a name="ln1618">                  return e;</a>
<a name="ln1619"> </a>
<a name="ln1620">            case ElementType::FINGERING:</a>
<a name="ln1621">                  if (!isTablature || tabFingering) {</a>
<a name="ln1622">                        e-&gt;setParent(this);</a>
<a name="ln1623">                        score()-&gt;undoAddElement(e);</a>
<a name="ln1624">                        return e;</a>
<a name="ln1625">                        }</a>
<a name="ln1626">                  else</a>
<a name="ln1627">                        delete e;</a>
<a name="ln1628">                  return 0;</a>
<a name="ln1629"> </a>
<a name="ln1630">            case ElementType::SLUR:</a>
<a name="ln1631">                  data.view-&gt;addSlur(chord(), nullptr, toSlur(e));</a>
<a name="ln1632">                  delete e;</a>
<a name="ln1633">                  return 0;</a>
<a name="ln1634"> </a>
<a name="ln1635">            case ElementType::HAIRPIN:</a>
<a name="ln1636">                  // forward this event to a chord</a>
<a name="ln1637">                  return chord()-&gt;drop(data);</a>
<a name="ln1638"> </a>
<a name="ln1639">            case ElementType::LYRICS:</a>
<a name="ln1640">                  e-&gt;setParent(ch);</a>
<a name="ln1641">                  e-&gt;setTrack(track());</a>
<a name="ln1642">                  score()-&gt;undoAddElement(e);</a>
<a name="ln1643">                  return e;</a>
<a name="ln1644"> </a>
<a name="ln1645">            case ElementType::ACCIDENTAL:</a>
<a name="ln1646">                  score()-&gt;changeAccidental(this, toAccidental(e)-&gt;accidentalType());</a>
<a name="ln1647">                  break;</a>
<a name="ln1648"> </a>
<a name="ln1649">            case ElementType::BEND:</a>
<a name="ln1650">                  e-&gt;setParent(this);</a>
<a name="ln1651">                  e-&gt;setTrack(track());</a>
<a name="ln1652">                  score()-&gt;undoAddElement(e);</a>
<a name="ln1653">                  return e;</a>
<a name="ln1654"> </a>
<a name="ln1655">            case ElementType::NOTEHEAD:</a>
<a name="ln1656">                  {</a>
<a name="ln1657">                  NoteHead* s = toNoteHead(e);</a>
<a name="ln1658">                  NoteHead::Group group = s-&gt;headGroup();</a>
<a name="ln1659">                  if (group == NoteHead::Group::HEAD_INVALID) {</a>
<a name="ln1660">                        qDebug(&quot;unknown notehead&quot;);</a>
<a name="ln1661">                        group = NoteHead::Group::HEAD_NORMAL;</a>
<a name="ln1662">                        }</a>
<a name="ln1663">                  delete s;</a>
<a name="ln1664"> </a>
<a name="ln1665">                  if (group != _headGroup) {</a>
<a name="ln1666">                        if (links()) {</a>
<a name="ln1667">                              for (ScoreElement* se : *links()) {</a>
<a name="ln1668">                                    se-&gt;undoChangeProperty(Pid::HEAD_GROUP, int(group));</a>
<a name="ln1669">                                    Note* note = toNote(se);</a>
<a name="ln1670">                                    if (note-&gt;staff() &amp;&amp; note-&gt;staff()-&gt;isTabStaff(ch-&gt;tick()) &amp;&amp; group == NoteHead::Group::HEAD_CROSS)</a>
<a name="ln1671">                                          se-&gt;undoChangeProperty(Pid::GHOST, true);</a>
<a name="ln1672">                                    }</a>
<a name="ln1673">                              }</a>
<a name="ln1674">                        else {</a>
<a name="ln1675">                              undoChangeProperty(Pid::HEAD_GROUP, int(group));</a>
<a name="ln1676">                              }</a>
<a name="ln1677">                        }</a>
<a name="ln1678">                  }</a>
<a name="ln1679">                  break;</a>
<a name="ln1680"> </a>
<a name="ln1681">            case ElementType::ICON:</a>
<a name="ln1682">                  {</a>
<a name="ln1683">                  switch (toIcon(e)-&gt;iconType()) {</a>
<a name="ln1684">                        case IconType::ACCIACCATURA:</a>
<a name="ln1685">                              score()-&gt;setGraceNote(ch, pitch(), NoteType::ACCIACCATURA, MScore::division/2);</a>
<a name="ln1686">                              break;</a>
<a name="ln1687">                        case IconType::APPOGGIATURA:</a>
<a name="ln1688">                              score()-&gt;setGraceNote(ch, pitch(), NoteType::APPOGGIATURA, MScore::division/2);</a>
<a name="ln1689">                              break;</a>
<a name="ln1690">                        case IconType::GRACE4:</a>
<a name="ln1691">                              score()-&gt;setGraceNote(ch, pitch(), NoteType::GRACE4, MScore::division);</a>
<a name="ln1692">                              break;</a>
<a name="ln1693">                        case IconType::GRACE16:</a>
<a name="ln1694">                              score()-&gt;setGraceNote(ch, pitch(), NoteType::GRACE16,  MScore::division/4);</a>
<a name="ln1695">                              break;</a>
<a name="ln1696">                        case IconType::GRACE32:</a>
<a name="ln1697">                              score()-&gt;setGraceNote(ch, pitch(), NoteType::GRACE32, MScore::division/8);</a>
<a name="ln1698">                              break;</a>
<a name="ln1699">                        case IconType::GRACE8_AFTER:</a>
<a name="ln1700">                              score()-&gt;setGraceNote(ch, pitch(), NoteType::GRACE8_AFTER, MScore::division/2);</a>
<a name="ln1701">                              break;</a>
<a name="ln1702">                        case IconType::GRACE16_AFTER:</a>
<a name="ln1703">                              score()-&gt;setGraceNote(ch, pitch(), NoteType::GRACE16_AFTER, MScore::division/4);</a>
<a name="ln1704">                              break;</a>
<a name="ln1705">                        case IconType::GRACE32_AFTER:</a>
<a name="ln1706">                              score()-&gt;setGraceNote(ch, pitch(), NoteType::GRACE32_AFTER, MScore::division/8);</a>
<a name="ln1707">                              break;</a>
<a name="ln1708">                        case IconType::SBEAM:</a>
<a name="ln1709">                        case IconType::MBEAM:</a>
<a name="ln1710">                        case IconType::NBEAM:</a>
<a name="ln1711">                        case IconType::BEAM32:</a>
<a name="ln1712">                        case IconType::BEAM64:</a>
<a name="ln1713">                        case IconType::AUTOBEAM:</a>
<a name="ln1714">                              return ch-&gt;drop(data);</a>
<a name="ln1715">                              break;</a>
<a name="ln1716">                        case IconType::PARENTHESES:</a>
<a name="ln1717">                              addParentheses();</a>
<a name="ln1718">                              break;</a>
<a name="ln1719">                        default:</a>
<a name="ln1720">                              break;</a>
<a name="ln1721">                        }</a>
<a name="ln1722">                  }</a>
<a name="ln1723">                  delete e;</a>
<a name="ln1724">                  break;</a>
<a name="ln1725"> </a>
<a name="ln1726">            case ElementType::BAGPIPE_EMBELLISHMENT:</a>
<a name="ln1727">                  {</a>
<a name="ln1728">                  BagpipeEmbellishment* b = toBagpipeEmbellishment(e);</a>
<a name="ln1729">                  noteList nl = b-&gt;getNoteList();</a>
<a name="ln1730">                  // add grace notes in reverse order, as setGraceNote adds a grace note</a>
<a name="ln1731">                  // before the current note</a>
<a name="ln1732">                  for (int i = nl.size() - 1; i &gt;= 0; --i) {</a>
<a name="ln1733">                        int p = BagpipeEmbellishment::BagpipeNoteInfoList[nl.at(i)].pitch;</a>
<a name="ln1734">                        score()-&gt;setGraceNote(ch, p, NoteType::GRACE32, MScore::division/8);</a>
<a name="ln1735">                        }</a>
<a name="ln1736">                  }</a>
<a name="ln1737">                  delete e;</a>
<a name="ln1738">                  break;</a>
<a name="ln1739"> </a>
<a name="ln1740">            case ElementType::NOTE:</a>
<a name="ln1741">                  {</a>
<a name="ln1742">                  // calculate correct transposed tpc</a>
<a name="ln1743">                  Note* n = toNote(e);</a>
<a name="ln1744">                  Interval v = part()-&gt;instrument(ch-&gt;tick())-&gt;transpose();</a>
<a name="ln1745">                  v.flip();</a>
<a name="ln1746">                  n-&gt;setTpc2(Ms::transposeTpc(n-&gt;tpc1(), v, true));</a>
<a name="ln1747">                  // replace this note with new note</a>
<a name="ln1748">                  n-&gt;setParent(ch);</a>
<a name="ln1749">                  score()-&gt;undoRemoveElement(this);</a>
<a name="ln1750">                  score()-&gt;undoAddElement(n);</a>
<a name="ln1751">                  }</a>
<a name="ln1752">                  break;</a>
<a name="ln1753"> </a>
<a name="ln1754">            case ElementType::GLISSANDO:</a>
<a name="ln1755">                  {</a>
<a name="ln1756">                  for (auto ee : _spannerFor) {</a>
<a name="ln1757">                        if (ee-&gt;type() == ElementType::GLISSANDO) {</a>
<a name="ln1758">                              qDebug(&quot;there is already a glissando&quot;);</a>
<a name="ln1759">                              delete e;</a>
<a name="ln1760">                              return 0;</a>
<a name="ln1761">                              }</a>
<a name="ln1762">                        }</a>
<a name="ln1763"> </a>
<a name="ln1764">                  // this is the glissando initial note, look for a suitable final note</a>
<a name="ln1765">                  Note* finalNote = Glissando::guessFinalNote(chord());</a>
<a name="ln1766">                  if (finalNote) {</a>
<a name="ln1767">                        // init glissando data</a>
<a name="ln1768">                        Glissando* gliss = toGlissando(e);</a>
<a name="ln1769">                        gliss-&gt;setAnchor(Spanner::Anchor::NOTE);</a>
<a name="ln1770">                        gliss-&gt;setStartElement(this);</a>
<a name="ln1771">                        gliss-&gt;setEndElement(finalNote);</a>
<a name="ln1772">                        gliss-&gt;setTick(ch-&gt;tick());</a>
<a name="ln1773">                        gliss-&gt;setTick2(finalNote-&gt;chord()-&gt;tick());</a>
<a name="ln1774">                        gliss-&gt;setTrack(track());</a>
<a name="ln1775">                        gliss-&gt;setTrack2(finalNote-&gt;track());</a>
<a name="ln1776">                        // in TAB, use straight line with no text</a>
<a name="ln1777">                        if (staff()-&gt;isTabStaff(finalNote-&gt;chord()-&gt;tick())) {</a>
<a name="ln1778">                              gliss-&gt;setGlissandoType(GlissandoType::STRAIGHT);</a>
<a name="ln1779">                              gliss-&gt;setShowText(false);</a>
<a name="ln1780">                              }</a>
<a name="ln1781">                        gliss-&gt;setParent(this);</a>
<a name="ln1782">                        score()-&gt;undoAddElement(e);</a>
<a name="ln1783">                        }</a>
<a name="ln1784">                  else {</a>
<a name="ln1785">                        qDebug(&quot;no segment for second note of glissando found&quot;);</a>
<a name="ln1786">                        delete e;</a>
<a name="ln1787">                        return 0;</a>
<a name="ln1788">                        }</a>
<a name="ln1789">                  }</a>
<a name="ln1790">                  break;</a>
<a name="ln1791"> </a>
<a name="ln1792">            case ElementType::CHORD:</a>
<a name="ln1793">                  {</a>
<a name="ln1794">                  Chord* c      = toChord(e);</a>
<a name="ln1795">                  Note* n       = c-&gt;upNote();</a>
<a name="ln1796">                  Direction dir = c-&gt;stemDirection();</a>
<a name="ln1797">                  int t         = (staff2track(staffIdx()) + n-&gt;voice());</a>
<a name="ln1798">                  score()-&gt;select(0, SelectType::SINGLE, 0);</a>
<a name="ln1799">                  NoteVal nval;</a>
<a name="ln1800">                  nval.pitch = n-&gt;pitch();</a>
<a name="ln1801">                  nval.headGroup = n-&gt;headGroup();</a>
<a name="ln1802">                  Segment* seg = score()-&gt;setNoteRest(chord()-&gt;segment(), t, nval,</a>
<a name="ln1803">                     score()-&gt;inputState().duration().fraction(), dir);</a>
<a name="ln1804">                  ChordRest* cr = toChordRest(seg-&gt;element(t));</a>
<a name="ln1805">                  if (cr)</a>
<a name="ln1806">                        score()-&gt;nextInputPos(cr, true);</a>
<a name="ln1807">                  delete e;</a>
<a name="ln1808">                  }</a>
<a name="ln1809">                  break;</a>
<a name="ln1810"> </a>
<a name="ln1811">            default:</a>
<a name="ln1812">                  return ch-&gt;drop(data);</a>
<a name="ln1813">            }</a>
<a name="ln1814">      return 0;</a>
<a name="ln1815">      }</a>
<a name="ln1816"> </a>
<a name="ln1817">//---------------------------------------------------------</a>
<a name="ln1818">//   addParentheses</a>
<a name="ln1819">//---------------------------------------------------------</a>
<a name="ln1820"> </a>
<a name="ln1821">void Note::addParentheses()</a>
<a name="ln1822">      {</a>
<a name="ln1823">      Symbol* s = new Symbol(score());</a>
<a name="ln1824">      s-&gt;setSym(SymId::noteheadParenthesisLeft);</a>
<a name="ln1825">      s-&gt;setParent(this);</a>
<a name="ln1826">      score()-&gt;undoAddElement(s);</a>
<a name="ln1827">      s = new Symbol(score());</a>
<a name="ln1828">      s-&gt;setSym(SymId::noteheadParenthesisRight);</a>
<a name="ln1829">      s-&gt;setParent(this);</a>
<a name="ln1830">      score()-&gt;undoAddElement(s);</a>
<a name="ln1831">      }</a>
<a name="ln1832"> </a>
<a name="ln1833">//---------------------------------------------------------</a>
<a name="ln1834">//   setDotY</a>
<a name="ln1835">//---------------------------------------------------------</a>
<a name="ln1836"> </a>
<a name="ln1837">void Note::setDotY(Direction pos)</a>
<a name="ln1838">      {</a>
<a name="ln1839">      bool onLine = false;</a>
<a name="ln1840">      qreal y = 0;</a>
<a name="ln1841"> </a>
<a name="ln1842">      if (staff()-&gt;isTabStaff(chord()-&gt;tick())) {</a>
<a name="ln1843">            // with TAB's, dotPosX is not set:</a>
<a name="ln1844">            // get dot X from width of fret text and use TAB default spacing</a>
<a name="ln1845">            const Staff* st = staff();</a>
<a name="ln1846">            const StaffType* tab = st-&gt;staffType(tick());</a>
<a name="ln1847">            if (tab-&gt;stemThrough() ) {</a>
<a name="ln1848">                  // if fret mark on lines, use standard processing</a>
<a name="ln1849">                  if (tab-&gt;onLines())</a>
<a name="ln1850">                        onLine = true;</a>
<a name="ln1851">                  else</a>
<a name="ln1852">                        // if fret marks above lines, raise the dots by half line distance</a>
<a name="ln1853">                        y = -0.5;</a>
<a name="ln1854">                  }</a>
<a name="ln1855">            // if stems beside staff, do nothing</a>
<a name="ln1856">            else</a>
<a name="ln1857">                  return;</a>
<a name="ln1858">            }</a>
<a name="ln1859">      else</a>
<a name="ln1860">            onLine = !(line() &amp; 1);</a>
<a name="ln1861"> </a>
<a name="ln1862">      bool oddVoice = voice() &amp; 1;</a>
<a name="ln1863">      if (onLine) {</a>
<a name="ln1864">            // displace dots by half spatium up or down according to voice</a>
<a name="ln1865">            if (pos == Direction::AUTO)</a>
<a name="ln1866">                  y = oddVoice ? 0.5 : -0.5;</a>
<a name="ln1867">            else if (pos == Direction::UP)</a>
<a name="ln1868">                  y = -0.5;</a>
<a name="ln1869">            else</a>
<a name="ln1870">                  y = 0.5;</a>
<a name="ln1871">            }</a>
<a name="ln1872">      else {</a>
<a name="ln1873">            if (pos == Direction::UP &amp;&amp; !oddVoice)</a>
<a name="ln1874">                  y -= 1.0;</a>
<a name="ln1875">            else if (pos == Direction::DOWN &amp;&amp; oddVoice)</a>
<a name="ln1876">                  y += 1.0;</a>
<a name="ln1877">            }</a>
<a name="ln1878">      y *= spatium() * staff()-&gt;lineDistance(tick());</a>
<a name="ln1879"> </a>
<a name="ln1880">      // apply to dots</a>
<a name="ln1881"> </a>
<a name="ln1882">      int cdots = chord()-&gt;dots();</a>
<a name="ln1883">      int ndots = _dots.size();</a>
<a name="ln1884"> </a>
<a name="ln1885">      int n = cdots - ndots;</a>
<a name="ln1886">      for (int i = 0; i &lt; n; ++i) {</a>
<a name="ln1887">            NoteDot* dot = new NoteDot(score());</a>
<a name="ln1888">            dot-&gt;setParent(this);</a>
<a name="ln1889">            dot-&gt;setTrack(track());  // needed to know the staff it belongs to (and detect tablature)</a>
<a name="ln1890">            dot-&gt;setVisible(visible());</a>
<a name="ln1891">            score()-&gt;undoAddElement(dot);</a>
<a name="ln1892">            }</a>
<a name="ln1893">      if (n &lt; 0) {</a>
<a name="ln1894">            for (int i = 0; i &lt; -n; ++i)</a>
<a name="ln1895">                  score()-&gt;undoRemoveElement(_dots.back());</a>
<a name="ln1896">            }</a>
<a name="ln1897">      for (NoteDot* dot : _dots) {</a>
<a name="ln1898">            dot-&gt;layout();</a>
<a name="ln1899">            dot-&gt;rypos() = y;</a>
<a name="ln1900">            }</a>
<a name="ln1901">      }</a>
<a name="ln1902"> </a>
<a name="ln1903">//---------------------------------------------------------</a>
<a name="ln1904">//   layout</a>
<a name="ln1905">//---------------------------------------------------------</a>
<a name="ln1906"> </a>
<a name="ln1907">void Note::layout()</a>
<a name="ln1908">      {</a>
<a name="ln1909">      bool useTablature = staff() &amp;&amp; staff()-&gt;isTabStaff(chord()-&gt;tick());</a>
<a name="ln1910">      if (useTablature) {</a>
<a name="ln1911">            const Staff* st = staff();</a>
<a name="ln1912">            const StaffType* tab = st-&gt;staffType(tick());</a>
<a name="ln1913">            qreal mags = magS();</a>
<a name="ln1914">            bool paren = false;</a>
<a name="ln1915">            if (tieBack() &amp;&amp; !tab-&gt;showBackTied()) {</a>
<a name="ln1916">                  if (chord()-&gt;measure() != tieBack()-&gt;startNote()-&gt;chord()-&gt;measure() || el().size() &gt; 0)</a>
<a name="ln1917">                        paren = true;</a>
<a name="ln1918">                  }</a>
<a name="ln1919">            // not complete but we need systems to be layouted to add parenthesis</a>
<a name="ln1920">            if (fixed())</a>
<a name="ln1921">                  _fretString = &quot;/&quot;;</a>
<a name="ln1922">            else</a>
<a name="ln1923">                  _fretString = tab-&gt;fretString(_fret, _string, _ghost);</a>
<a name="ln1924">            if (paren)</a>
<a name="ln1925">                  _fretString = QString(&quot;(%1)&quot;).arg(_fretString);</a>
<a name="ln1926">            qreal w = tabHeadWidth(tab); // !! use _fretString</a>
<a name="ln1927">            bbox().setRect(0.0, tab-&gt;fretBoxY() * mags, w, tab-&gt;fretBoxH() * mags);</a>
<a name="ln1928">            }</a>
<a name="ln1929">      else {</a>
<a name="ln1930">            SymId nh = noteHead();</a>
<a name="ln1931">            _cachedNoteheadSym = nh;</a>
<a name="ln1932">            if (isNoteName()) {</a>
<a name="ln1933">                  _cachedSymNull = SymId::noteEmptyBlack;</a>
<a name="ln1934">                  NoteHead::Type ht = _headType == NoteHead::Type::HEAD_AUTO ? chord()-&gt;durationType().headType() : _headType;</a>
<a name="ln1935">                  if (ht == NoteHead::Type::HEAD_WHOLE)</a>
<a name="ln1936">                        _cachedSymNull = SymId::noteEmptyWhole;</a>
<a name="ln1937">                  else if (ht == NoteHead::Type::HEAD_HALF)</a>
<a name="ln1938">                        _cachedSymNull = SymId::noteEmptyHalf;</a>
<a name="ln1939">                  }</a>
<a name="ln1940">            else</a>
<a name="ln1941">                  _cachedSymNull = SymId::noSym;</a>
<a name="ln1942">            setbbox(symBbox(nh));</a>
<a name="ln1943">            }</a>
<a name="ln1944">      }</a>
<a name="ln1945"> </a>
<a name="ln1946">//---------------------------------------------------------</a>
<a name="ln1947">//   layout2</a>
<a name="ln1948">//    called after final position of note is set</a>
<a name="ln1949">//---------------------------------------------------------</a>
<a name="ln1950"> </a>
<a name="ln1951">void Note::layout2()</a>
<a name="ln1952">      {</a>
<a name="ln1953">      // for standard staves this is done in Score::layoutChords3()</a>
<a name="ln1954">      // so that the results are available there</a>
<a name="ln1955"> </a>
<a name="ln1956">      int dots = chord()-&gt;dots();</a>
<a name="ln1957">      if (dots) {</a>
<a name="ln1958">            qreal d  = score()-&gt;point(score()-&gt;styleS(Sid::dotNoteDistance)) * mag();</a>
<a name="ln1959">            qreal dd = score()-&gt;point(score()-&gt;styleS(Sid::dotDotDistance)) * mag();</a>
<a name="ln1960">            qreal x  = chord()-&gt;dotPosX() - pos().x() - chord()-&gt;pos().x();</a>
<a name="ln1961">            // if TAB and stems through staff</a>
<a name="ln1962">            if (staff()-&gt;isTabStaff(chord()-&gt;tick())) {</a>
<a name="ln1963">                  const Staff* st = staff();</a>
<a name="ln1964">                  const StaffType* tab = st-&gt;staffType(tick());</a>
<a name="ln1965">                  if (tab-&gt;stemThrough()) {</a>
<a name="ln1966">                        // with TAB's, dot Y is not calculated during layoutChords3(),</a>
<a name="ln1967">                        // as layoutChords3() is not even called for TAB's;</a>
<a name="ln1968">                        // setDotY() actually also manages creation/deletion of NoteDot's</a>
<a name="ln1969">                        setDotY(Direction::AUTO);</a>
<a name="ln1970"> </a>
<a name="ln1971">                        // use TAB default note-to-dot spacing</a>
<a name="ln1972">                        dd = STAFFTYPE_TAB_DEFAULTDOTDIST_X * spatium();</a>
<a name="ln1973">                        d = dd * 0.5;</a>
<a name="ln1974">                        }</a>
<a name="ln1975">                  }</a>
<a name="ln1976">            // apply to dots</a>
<a name="ln1977">            qreal xx = x + d;</a>
<a name="ln1978">            for (NoteDot* dot : _dots) {</a>
<a name="ln1979">                  dot-&gt;rxpos() = xx;</a>
<a name="ln1980">                  xx += dd;</a>
<a name="ln1981">                  }</a>
<a name="ln1982">            }</a>
<a name="ln1983"> </a>
<a name="ln1984">      // layout elements attached to note</a>
<a name="ln1985">      for (Element* e : _el) {</a>
<a name="ln1986">            if (!score()-&gt;tagIsValid(e-&gt;tag()))</a>
<a name="ln1987">                  continue;</a>
<a name="ln1988">            e-&gt;setMag(mag());</a>
<a name="ln1989">            if (e-&gt;isSymbol()) {</a>
<a name="ln1990">                  qreal w = headWidth();</a>
<a name="ln1991">                  Symbol* sym = toSymbol(e);</a>
<a name="ln1992">                  e-&gt;layout();</a>
<a name="ln1993">                  if (sym-&gt;sym() == SymId::noteheadParenthesisRight) {</a>
<a name="ln1994">                        if (staff()-&gt;isTabStaff(chord()-&gt;tick())) {</a>
<a name="ln1995">                              const Staff* st = staff();</a>
<a name="ln1996">                              const StaffType* tab = st-&gt;staffType(tick());</a>
<a name="ln1997">                              w = tabHeadWidth(tab);</a>
<a name="ln1998">                              }</a>
<a name="ln1999">                        e-&gt;rxpos() += w;</a>
<a name="ln2000">                        }</a>
<a name="ln2001">                  else if (sym-&gt;sym() == SymId::noteheadParenthesisLeft) {</a>
<a name="ln2002">                        e-&gt;rxpos() -= symWidth(SymId::noteheadParenthesisLeft);</a>
<a name="ln2003">                        }</a>
<a name="ln2004">                  }</a>
<a name="ln2005">            else if (e-&gt;isFingering()) {</a>
<a name="ln2006">                  Fingering* f = toFingering(e);</a>
<a name="ln2007">                  if (f-&gt;propertyFlags(Pid::PLACEMENT) == PropertyFlags::STYLED)</a>
<a name="ln2008">                        f-&gt;setPlacement(f-&gt;calculatePlacement());</a>
<a name="ln2009">                  // layout fingerings that are placed relative to notehead</a>
<a name="ln2010">                  // fingerings placed relative to chord will be laid out later</a>
<a name="ln2011">                  if (f-&gt;layoutType() == ElementType::NOTE)</a>
<a name="ln2012">                        f-&gt;layout();</a>
<a name="ln2013">                  }</a>
<a name="ln2014">            else {</a>
<a name="ln2015">                  e-&gt;layout();</a>
<a name="ln2016">                  }</a>
<a name="ln2017">            }</a>
<a name="ln2018">      }</a>
<a name="ln2019"> </a>
<a name="ln2020">//---------------------------------------------------------</a>
<a name="ln2021">//   dotIsUp</a>
<a name="ln2022">//---------------------------------------------------------</a>
<a name="ln2023"> </a>
<a name="ln2024">bool Note::dotIsUp() const</a>
<a name="ln2025">      {</a>
<a name="ln2026">      if (_dots.empty())</a>
<a name="ln2027">            return true;</a>
<a name="ln2028">      if (_userDotPosition == Direction::AUTO)</a>
<a name="ln2029">            return _dots[0]-&gt;y() &lt; spatium() * .1;</a>
<a name="ln2030">      else</a>
<a name="ln2031">            return (_userDotPosition == Direction::UP);</a>
<a name="ln2032">      }</a>
<a name="ln2033"> </a>
<a name="ln2034">//---------------------------------------------------------</a>
<a name="ln2035">//   updateAccidental</a>
<a name="ln2036">//    set _accidental and _line depending on tpc</a>
<a name="ln2037">//---------------------------------------------------------</a>
<a name="ln2038"> </a>
<a name="ln2039">void Note::updateAccidental(AccidentalState* as)</a>
<a name="ln2040">      {</a>
<a name="ln2041">      int relLine = absStep(tpc(), epitch());</a>
<a name="ln2042"> </a>
<a name="ln2043">      // don't touch accidentals that don't concern tpc such as</a>
<a name="ln2044">      // quarter tones</a>
<a name="ln2045">      if (!(_accidental &amp;&amp; Accidental::isMicrotonal(_accidental-&gt;accidentalType()))) {</a>
<a name="ln2046">            // calculate accidental</a>
<a name="ln2047">            AccidentalType acci = AccidentalType::NONE;</a>
<a name="ln2048"> </a>
<a name="ln2049">            AccidentalVal accVal = tpc2alter(tpc());</a>
<a name="ln2050">            bool error = false;</a>
<a name="ln2051">            int eRelLine = absStep(tpc(), epitch()+ottaveCapoFret());</a>
<a name="ln2052">            AccidentalVal relLineAccVal = as-&gt;accidentalVal(eRelLine, error);</a>
<a name="ln2053">            if (error) {</a>
<a name="ln2054">                  qDebug(&quot;error accidetalVal&quot;);</a>
<a name="ln2055">                  return;</a>
<a name="ln2056">                  }</a>
<a name="ln2057">            if ((accVal != relLineAccVal) || hidden() || as-&gt;tieContext(eRelLine)) {</a>
<a name="ln2058">                  as-&gt;setAccidentalVal(eRelLine, accVal, _tieBack != 0 &amp;&amp; _accidental == 0);</a>
<a name="ln2059">                  acci = Accidental::value2subtype(accVal);</a>
<a name="ln2060">                  // if previous tied note has same tpc, don't show accidental</a>
<a name="ln2061">                  if (_tieBack &amp;&amp; _tieBack-&gt;startNote()-&gt;tpc1() == tpc1())</a>
<a name="ln2062">                        acci = AccidentalType::NONE;</a>
<a name="ln2063">                  else if (acci == AccidentalType::NONE)</a>
<a name="ln2064">                        acci = AccidentalType::NATURAL;</a>
<a name="ln2065">                  }</a>
<a name="ln2066">            if (acci != AccidentalType::NONE &amp;&amp; !_hidden) {</a>
<a name="ln2067">                  if (_accidental == 0) {</a>
<a name="ln2068">                        Accidental* a = new Accidental(score());</a>
<a name="ln2069">                        a-&gt;setParent(this);</a>
<a name="ln2070">                        a-&gt;setAccidentalType(acci);</a>
<a name="ln2071">                        score()-&gt;undoAddElement(a);</a>
<a name="ln2072">                        }</a>
<a name="ln2073">                  else if (_accidental-&gt;accidentalType() != acci) {</a>
<a name="ln2074">                        Accidental* a = _accidental-&gt;clone();</a>
<a name="ln2075">                        a-&gt;setParent(this);</a>
<a name="ln2076">                        a-&gt;setAccidentalType(acci);</a>
<a name="ln2077">                        score()-&gt;undoChangeElement(_accidental, a);</a>
<a name="ln2078">                        }</a>
<a name="ln2079">                  }</a>
<a name="ln2080">            else {</a>
<a name="ln2081">                  if (_accidental) {</a>
<a name="ln2082">                        // remove this if it was AUTO:</a>
<a name="ln2083">                        if (_accidental-&gt;role() == AccidentalRole::AUTO)</a>
<a name="ln2084">                              score()-&gt;undoRemoveElement(_accidental);</a>
<a name="ln2085">                        else {</a>
<a name="ln2086">                              // keep it, but update type if needed</a>
<a name="ln2087">                              acci = Accidental::value2subtype(accVal);</a>
<a name="ln2088">                              if (acci == AccidentalType::NONE)</a>
<a name="ln2089">                                    acci = AccidentalType::NATURAL;</a>
<a name="ln2090">                              if (_accidental-&gt;accidentalType() != acci) {</a>
<a name="ln2091">                                    Accidental* a = _accidental-&gt;clone();</a>
<a name="ln2092">                                    a-&gt;setParent(this);</a>
<a name="ln2093">                                    a-&gt;setAccidentalType(acci);</a>
<a name="ln2094">                                    score()-&gt;undoChangeElement(_accidental, a);</a>
<a name="ln2095">                                    }</a>
<a name="ln2096">                              }</a>
<a name="ln2097">                        }</a>
<a name="ln2098">                  }</a>
<a name="ln2099">            }</a>
<a name="ln2100"> </a>
<a name="ln2101">      else {</a>
<a name="ln2102">            // microtonal accidentals playback as naturals</a>
<a name="ln2103">            // in 1.X, they had no effect on accidental state of measure</a>
<a name="ln2104">            // ultimetely, they should probably get their own state</a>
<a name="ln2105">            // for now, at least change state to natural, so subsequent notes playback as might be expected</a>
<a name="ln2106">            // this is an incompatible change, but better to break it for 2.0 than wait until later</a>
<a name="ln2107">            AccidentalVal accVal = Accidental::subtype2value(_accidental-&gt;accidentalType());</a>
<a name="ln2108">            as-&gt;setAccidentalVal(relLine, accVal, _tieBack != 0 &amp;&amp; _accidental == 0);</a>
<a name="ln2109">            }</a>
<a name="ln2110"> </a>
<a name="ln2111">      updateRelLine(relLine, true);</a>
<a name="ln2112">      }</a>
<a name="ln2113"> </a>
<a name="ln2114">//---------------------------------------------------------</a>
<a name="ln2115">//   noteType</a>
<a name="ln2116">//---------------------------------------------------------</a>
<a name="ln2117"> </a>
<a name="ln2118">NoteType Note::noteType() const</a>
<a name="ln2119">      {</a>
<a name="ln2120">      return chord()-&gt;noteType();</a>
<a name="ln2121">      }</a>
<a name="ln2122"> </a>
<a name="ln2123">//---------------------------------------------------------</a>
<a name="ln2124">//   noteTypeUserName</a>
<a name="ln2125">//---------------------------------------------------------</a>
<a name="ln2126"> </a>
<a name="ln2127">QString Note::noteTypeUserName() const</a>
<a name="ln2128">      {</a>
<a name="ln2129">      switch (noteType()) {</a>
<a name="ln2130">            case NoteType::ACCIACCATURA:</a>
<a name="ln2131">                  return QObject::tr(&quot;Acciaccatura&quot;);</a>
<a name="ln2132">            case NoteType::APPOGGIATURA:</a>
<a name="ln2133">                  return QObject::tr(&quot;Appoggiatura&quot;);</a>
<a name="ln2134">            case NoteType::GRACE8_AFTER:</a>
<a name="ln2135">            case NoteType::GRACE16_AFTER:</a>
<a name="ln2136">            case NoteType::GRACE32_AFTER:</a>
<a name="ln2137">                  return QObject::tr(&quot;Grace note after&quot;);</a>
<a name="ln2138">            case NoteType::GRACE4:</a>
<a name="ln2139">            case NoteType::GRACE16:</a>
<a name="ln2140">            case NoteType::GRACE32:</a>
<a name="ln2141">                  return QObject::tr(&quot;Grace note before&quot;);</a>
<a name="ln2142">            default:</a>
<a name="ln2143">                  return QObject::tr(&quot;Note&quot;);</a>
<a name="ln2144">            }</a>
<a name="ln2145">      }</a>
<a name="ln2146"> </a>
<a name="ln2147">//---------------------------------------------------------</a>
<a name="ln2148">//   scanElements</a>
<a name="ln2149">//---------------------------------------------------------</a>
<a name="ln2150"> </a>
<a name="ln2151">void Note::scanElements(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln2152">      {</a>
<a name="ln2153">      func(data, this);</a>
<a name="ln2154">      // tie segments are collected from System</a>
<a name="ln2155">      //      if (_tieFor &amp;&amp; !staff()-&gt;isTabStaff(chord-&gt;tick()))  // no ties in tablature</a>
<a name="ln2156">      //            _tieFor-&gt;scanElements(data, func, all);</a>
<a name="ln2157">      for (Element* e : _el) {</a>
<a name="ln2158">            if (score()-&gt;tagIsValid(e-&gt;tag()))</a>
<a name="ln2159">                  e-&gt;scanElements(data, func, all);</a>
<a name="ln2160">            }</a>
<a name="ln2161">      for (Spanner* sp : _spannerFor)</a>
<a name="ln2162">            sp-&gt;scanElements(data, func, all);</a>
<a name="ln2163"> </a>
<a name="ln2164">      if (!dragMode &amp;&amp; _accidental)</a>
<a name="ln2165">            func(data, _accidental);</a>
<a name="ln2166">      for (NoteDot* dot : _dots)</a>
<a name="ln2167">            func(data, dot);</a>
<a name="ln2168">      if (_tieFor &amp;&amp; !_tieFor-&gt;spannerSegments().empty())</a>
<a name="ln2169">            _tieFor-&gt;spannerSegments().front()-&gt;scanElements(data, func, all);</a>
<a name="ln2170">      if (_tieBack &amp;&amp; _tieBack-&gt;spannerSegments().size() &gt; 1)</a>
<a name="ln2171">            _tieBack-&gt;spannerSegments().back()-&gt;scanElements(data, func, all);</a>
<a name="ln2172">      }</a>
<a name="ln2173"> </a>
<a name="ln2174">//---------------------------------------------------------</a>
<a name="ln2175">//   setTrack</a>
<a name="ln2176">//---------------------------------------------------------</a>
<a name="ln2177"> </a>
<a name="ln2178">void Note::setTrack(int val)</a>
<a name="ln2179">      {</a>
<a name="ln2180">      Element::setTrack(val);</a>
<a name="ln2181">      if (_tieFor) {</a>
<a name="ln2182">            _tieFor-&gt;setTrack(val);</a>
<a name="ln2183">            for (SpannerSegment* seg : _tieFor-&gt;spannerSegments())</a>
<a name="ln2184">                  seg-&gt;setTrack(val);</a>
<a name="ln2185">            }</a>
<a name="ln2186">      for (Spanner* s : _spannerFor) {</a>
<a name="ln2187">            s-&gt;setTrack(val);</a>
<a name="ln2188">            }</a>
<a name="ln2189">      for (Spanner* s : _spannerBack) {</a>
<a name="ln2190">            s-&gt;setTrack2(val);</a>
<a name="ln2191">            }</a>
<a name="ln2192">      for (Element* e : _el)</a>
<a name="ln2193">            e-&gt;setTrack(val);</a>
<a name="ln2194">      if (_accidental)</a>
<a name="ln2195">            _accidental-&gt;setTrack(val);</a>
<a name="ln2196">      if (!chord())     // if note is dragged with shift+ctrl</a>
<a name="ln2197">            return;</a>
<a name="ln2198">      for (NoteDot* dot : _dots)</a>
<a name="ln2199">            dot-&gt;setTrack(val);</a>
<a name="ln2200">      }</a>
<a name="ln2201"> </a>
<a name="ln2202">//---------------------------------------------------------</a>
<a name="ln2203">//    reset</a>
<a name="ln2204">//---------------------------------------------------------</a>
<a name="ln2205"> </a>
<a name="ln2206">void Note::reset()</a>
<a name="ln2207">      {</a>
<a name="ln2208">      undoChangeProperty(Pid::OFFSET, QPointF());</a>
<a name="ln2209">      chord()-&gt;undoChangeProperty(Pid::OFFSET, QPointF());</a>
<a name="ln2210">      chord()-&gt;undoChangeProperty(Pid::STEM_DIRECTION, QVariant::fromValue&lt;Direction&gt;(Direction::AUTO));</a>
<a name="ln2211">      }</a>
<a name="ln2212"> </a>
<a name="ln2213">//---------------------------------------------------------</a>
<a name="ln2214">//   mag</a>
<a name="ln2215">//---------------------------------------------------------</a>
<a name="ln2216"> </a>
<a name="ln2217">qreal Note::mag() const</a>
<a name="ln2218">      {</a>
<a name="ln2219">      qreal m = chord()-&gt;mag();</a>
<a name="ln2220">      if (_small)</a>
<a name="ln2221">            m *= score()-&gt;styleD(Sid::smallNoteMag);</a>
<a name="ln2222">      return m;</a>
<a name="ln2223">      }</a>
<a name="ln2224"> </a>
<a name="ln2225">//---------------------------------------------------------</a>
<a name="ln2226">//   setSmall</a>
<a name="ln2227">//---------------------------------------------------------</a>
<a name="ln2228"> </a>
<a name="ln2229">void Note::setSmall(bool val)</a>
<a name="ln2230">      {</a>
<a name="ln2231">      _small = val;</a>
<a name="ln2232">      }</a>
<a name="ln2233"> </a>
<a name="ln2234">//---------------------------------------------------------</a>
<a name="ln2235">//   line</a>
<a name="ln2236">//---------------------------------------------------------</a>
<a name="ln2237"> </a>
<a name="ln2238">int Note::line() const</a>
<a name="ln2239">      {</a>
<a name="ln2240">      return fixed() ? _fixedLine : _line;</a>
<a name="ln2241">      }</a>
<a name="ln2242"> </a>
<a name="ln2243">//---------------------------------------------------------</a>
<a name="ln2244">//   setString</a>
<a name="ln2245">//---------------------------------------------------------</a>
<a name="ln2246"> </a>
<a name="ln2247">void Note::setString(int val)</a>
<a name="ln2248">      {</a>
<a name="ln2249">      _string = val;</a>
<a name="ln2250">      rypos() = _string * spatium() * 1.5;</a>
<a name="ln2251">      }</a>
<a name="ln2252"> </a>
<a name="ln2253">//---------------------------------------------------------</a>
<a name="ln2254">//   setHeadGroup</a>
<a name="ln2255">//---------------------------------------------------------</a>
<a name="ln2256"> </a>
<a name="ln2257">void Note::setHeadGroup(NoteHead::Group val)</a>
<a name="ln2258">      {</a>
<a name="ln2259">      Q_ASSERT(int(val) &gt;= 0 &amp;&amp; int(val) &lt; int(NoteHead::Group::HEAD_GROUPS));</a>
<a name="ln2260">      _headGroup = val;</a>
<a name="ln2261">      }</a>
<a name="ln2262"> </a>
<a name="ln2263">//---------------------------------------------------------</a>
<a name="ln2264">//   ottaveCapoFret</a>
<a name="ln2265">//    offset added by Ottava's and Capo Fret.</a>
<a name="ln2266">//---------------------------------------------------------</a>
<a name="ln2267"> </a>
<a name="ln2268">int Note::ottaveCapoFret() const</a>
<a name="ln2269">      {</a>
<a name="ln2270">      Chord* ch = chord();</a>
<a name="ln2271">      int capoFretId = staff()-&gt;capo(ch-&gt;segment()-&gt;tick());</a>
<a name="ln2272">      if (capoFretId != 0)</a>
<a name="ln2273">            capoFretId -= 1;</a>
<a name="ln2274"> </a>
<a name="ln2275">      return staff()-&gt;pitchOffset(ch-&gt;segment()-&gt;tick()) + capoFretId;</a>
<a name="ln2276">      }</a>
<a name="ln2277"> </a>
<a name="ln2278">//---------------------------------------------------------</a>
<a name="ln2279">//   ppitch</a>
<a name="ln2280">//    playback pitch</a>
<a name="ln2281">//---------------------------------------------------------</a>
<a name="ln2282"> </a>
<a name="ln2283">int Note::ppitch() const</a>
<a name="ln2284">      {</a>
<a name="ln2285">      Chord* ch = chord();</a>
<a name="ln2286">      // if staff is drum</a>
<a name="ln2287">      // match tremolo and articulation between variants and chord</a>
<a name="ln2288">      if (play() &amp;&amp; ch &amp;&amp; ch-&gt;staff() &amp;&amp; ch-&gt;staff()-&gt;isDrumStaff(ch-&gt;tick())) {</a>
<a name="ln2289">            const Drumset* ds = ch-&gt;staff()-&gt;part()-&gt;instrument(ch-&gt;tick())-&gt;drumset();</a>
<a name="ln2290">            if (ds) {</a>
<a name="ln2291">                  DrumInstrumentVariant div = ds-&gt;findVariant(_pitch, ch-&gt;articulations(), ch-&gt;tremolo());</a>
<a name="ln2292">                  if (div.pitch != INVALID_PITCH)</a>
<a name="ln2293">                        return div.pitch;</a>
<a name="ln2294">                  }</a>
<a name="ln2295">            }</a>
<a name="ln2296"> </a>
<a name="ln2297">      return _pitch + ottaveCapoFret();</a>
<a name="ln2298">      }</a>
<a name="ln2299"> </a>
<a name="ln2300">//---------------------------------------------------------</a>
<a name="ln2301">//   epitch</a>
<a name="ln2302">//    effective pitch, i.e. a pitch which is visible in the</a>
<a name="ln2303">//    currently used written notation.</a>
<a name="ln2304">//    honours transposing instruments</a>
<a name="ln2305">//---------------------------------------------------------</a>
<a name="ln2306"> </a>
<a name="ln2307">int Note::epitch() const</a>
<a name="ln2308">      {</a>
<a name="ln2309">      return _pitch - (concertPitch() ? 0 : transposition());</a>
<a name="ln2310">      }</a>
<a name="ln2311"> </a>
<a name="ln2312">//---------------------------------------------------------</a>
<a name="ln2313">//   customizeVelocity</a>
<a name="ln2314">//    Input is the global velocity determined by dynamic</a>
<a name="ln2315">//    signs and crescende/decrescendo etc.</a>
<a name="ln2316">//    Returns the actual play velocity for this note</a>
<a name="ln2317">//    modified by veloOffset</a>
<a name="ln2318">//---------------------------------------------------------</a>
<a name="ln2319"> </a>
<a name="ln2320">int Note::customizeVelocity(int velo) const</a>
<a name="ln2321">      {</a>
<a name="ln2322">      if (veloType() == ValueType::OFFSET_VAL)</a>
<a name="ln2323">            velo = velo + (velo * veloOffset()) / 100;</a>
<a name="ln2324">      else if (veloType() == ValueType::USER_VAL)</a>
<a name="ln2325">            velo = veloOffset();</a>
<a name="ln2326">      return limit(velo, 1, 127);</a>
<a name="ln2327">      }</a>
<a name="ln2328"> </a>
<a name="ln2329">//---------------------------------------------------------</a>
<a name="ln2330">//   startDrag</a>
<a name="ln2331">//---------------------------------------------------------</a>
<a name="ln2332"> </a>
<a name="ln2333">void Note::startDrag(EditData&amp; ed)</a>
<a name="ln2334">      {</a>
<a name="ln2335">      NoteEditData* ned = new NoteEditData();</a>
<a name="ln2336">      ned-&gt;e      = this;</a>
<a name="ln2337">      ned-&gt;line   = _line;</a>
<a name="ln2338">      ned-&gt;string = _string;</a>
<a name="ln2339">      ned-&gt;pushProperty(Pid::PITCH);</a>
<a name="ln2340">      ned-&gt;pushProperty(Pid::TPC1);</a>
<a name="ln2341">      ned-&gt;pushProperty(Pid::TPC2);</a>
<a name="ln2342">      ned-&gt;pushProperty(Pid::FRET);</a>
<a name="ln2343">      ned-&gt;pushProperty(Pid::STRING);</a>
<a name="ln2344"> </a>
<a name="ln2345">      ed.addData(ned);</a>
<a name="ln2346">      }</a>
<a name="ln2347"> </a>
<a name="ln2348">//---------------------------------------------------------</a>
<a name="ln2349">//   drag</a>
<a name="ln2350">//---------------------------------------------------------</a>
<a name="ln2351"> </a>
<a name="ln2352">QRectF Note::drag(EditData&amp; ed)</a>
<a name="ln2353">      {</a>
<a name="ln2354">      NoteEditData* noteEditData = static_cast&lt;NoteEditData*&gt;(ed.getData(this));</a>
<a name="ln2355"> </a>
<a name="ln2356">      QPointF delta = ed.pos - ed.lastPos;</a>
<a name="ln2357">      noteEditData-&gt;delta = delta;</a>
<a name="ln2358"> </a>
<a name="ln2359">      if (noteEditData-&gt;mode == NoteEditData::EditMode_Undefined) {</a>
<a name="ln2360">            noteEditData-&gt;mode = NoteEditData::editModeByDragDirection(delta.x(), delta.y());</a>
<a name="ln2361">            }</a>
<a name="ln2362"> </a>
<a name="ln2363">      if (noteEditData-&gt;mode == NoteEditData::EditMode_AddSpacing)</a>
<a name="ln2364">            horizontalDrag(ed);</a>
<a name="ln2365">      else if (noteEditData-&gt;mode == NoteEditData::EditMode_ChangePitch)</a>
<a name="ln2366">            verticalDrag(ed);</a>
<a name="ln2367"> </a>
<a name="ln2368">      return QRectF();</a>
<a name="ln2369">      }</a>
<a name="ln2370"> </a>
<a name="ln2371">//---------------------------------------------------------</a>
<a name="ln2372">//   endDrag</a>
<a name="ln2373">//---------------------------------------------------------</a>
<a name="ln2374"> </a>
<a name="ln2375">void Note::endDrag(EditData&amp; ed)</a>
<a name="ln2376">      {</a>
<a name="ln2377">      NoteEditData* ned = static_cast&lt;NoteEditData*&gt;(ed.getData(this));</a>
<a name="ln2378">      for (Note* nn : tiedNotes()) {</a>
<a name="ln2379">            for (PropertyData pd : ned-&gt;propertyData) {</a>
<a name="ln2380">                  setPropertyFlags(pd.id, pd.f); // reset initial property flags state</a>
<a name="ln2381">                  score()-&gt;undoPropertyChanged(nn, pd.id, pd.data);</a>
<a name="ln2382">                  }</a>
<a name="ln2383">          }</a>
<a name="ln2384">      }</a>
<a name="ln2385"> </a>
<a name="ln2386">//---------------------------------------------------------</a>
<a name="ln2387">//   editDrag</a>
<a name="ln2388">//---------------------------------------------------------</a>
<a name="ln2389"> </a>
<a name="ln2390">void Note::editDrag(EditData&amp; editData)</a>
<a name="ln2391">      {</a>
<a name="ln2392">      Chord* ch = chord();</a>
<a name="ln2393"> </a>
<a name="ln2394">      if (ch-&gt;notes().size() == 1) {</a>
<a name="ln2395">            // if the chord contains only this note, then move the whole chord</a>
<a name="ln2396">            // including stem, flag etc.</a>
<a name="ln2397">            ch-&gt;undoChangeProperty(Pid::OFFSET, ch-&gt;offset() + offset() + editData.delta);</a>
<a name="ln2398">            setOffset(QPointF());</a>
<a name="ln2399">            }</a>
<a name="ln2400">      else</a>
<a name="ln2401">            setOffset(offset() + editData.delta);</a>
<a name="ln2402"> </a>
<a name="ln2403">      triggerLayout();</a>
<a name="ln2404">      }</a>
<a name="ln2405"> </a>
<a name="ln2406">//---------------------------------------------------------</a>
<a name="ln2407">//   verticalDrag</a>
<a name="ln2408">//---------------------------------------------------------</a>
<a name="ln2409"> </a>
<a name="ln2410">void Note::verticalDrag(EditData &amp;ed)</a>
<a name="ln2411">      {</a>
<a name="ln2412">      Fraction _tick      = chord()-&gt;tick();</a>
<a name="ln2413">      const Staff* stf    = staff();</a>
<a name="ln2414">      const StaffType* st = stf-&gt;staffType(_tick);</a>
<a name="ln2415"> </a>
<a name="ln2416">      if (st-&gt;isDrumStaff())</a>
<a name="ln2417">            return;</a>
<a name="ln2418"> </a>
<a name="ln2419">      NoteEditData* ned   = static_cast&lt;NoteEditData*&gt;(ed.getData(this));</a>
<a name="ln2420"> </a>
<a name="ln2421">      qreal _spatium      = spatium();</a>
<a name="ln2422">      bool tab            = st-&gt;isTabStaff();</a>
<a name="ln2423">      qreal step          = _spatium * (tab ? st-&gt;lineDistance().val() : 0.5);</a>
<a name="ln2424">      int lineOffset      = lrint(ed.delta.y() / step);</a>
<a name="ln2425"> </a>
<a name="ln2426">      if (tab) {</a>
<a name="ln2427">            const StringData* strData = staff()-&gt;part()-&gt;instrument()-&gt;stringData();</a>
<a name="ln2428">            int nString = ned-&gt;string + (st-&gt;upsideDown() ? -lineOffset : lineOffset);</a>
<a name="ln2429">            int nFret   = strData-&gt;fret(_pitch, nString, staff(), _tick);</a>
<a name="ln2430"> </a>
<a name="ln2431">            if (nFret &gt;= 0) {                    // no fret?</a>
<a name="ln2432">                  if (fret() != nFret || string() != nString) {</a>
<a name="ln2433">                        for (Note* nn : tiedNotes()) {</a>
<a name="ln2434">                              nn-&gt;setFret(nFret);</a>
<a name="ln2435">                              nn-&gt;setString(nString);</a>
<a name="ln2436">                              strData-&gt;fretChords(nn-&gt;chord());</a>
<a name="ln2437">                              nn-&gt;triggerLayout();</a>
<a name="ln2438">                              }</a>
<a name="ln2439">                        }</a>
<a name="ln2440">                  }</a>
<a name="ln2441">            }</a>
<a name="ln2442">      else {</a>
<a name="ln2443">            Key key = staff()-&gt;key(_tick);</a>
<a name="ln2444">            int idx = chord()-&gt;vStaffIdx();</a>
<a name="ln2445">            int newPitch = line2pitch(ned-&gt;line + lineOffset, score()-&gt;staff(idx)-&gt;clef(_tick), key);</a>
<a name="ln2446"> </a>
<a name="ln2447">            if (!concertPitch()) {</a>
<a name="ln2448">                  Interval interval = staff()-&gt;part()-&gt;instrument(_tick)-&gt;transpose();</a>
<a name="ln2449">                  newPitch += interval.chromatic;</a>
<a name="ln2450">                  }</a>
<a name="ln2451"> </a>
<a name="ln2452">            int newTpc1 = pitch2tpc(newPitch, key, Prefer::NEAREST);</a>
<a name="ln2453">            int newTpc2 = pitch2tpc(newPitch - transposition(), key, Prefer::NEAREST);</a>
<a name="ln2454">            for (Note* nn : tiedNotes()) {</a>
<a name="ln2455">                  nn-&gt;setPitch(newPitch, newTpc1, newTpc2);</a>
<a name="ln2456">                  nn-&gt;triggerLayout();</a>
<a name="ln2457">                  }</a>
<a name="ln2458">            }</a>
<a name="ln2459">      }</a>
<a name="ln2460"> </a>
<a name="ln2461">//---------------------------------------------------------</a>
<a name="ln2462">//   normalizeLeftDragDelta</a>
<a name="ln2463">//---------------------------------------------------------</a>
<a name="ln2464"> </a>
<a name="ln2465">void Note::normalizeLeftDragDelta(Segment* seg, EditData &amp;ed, NoteEditData* ned)</a>
<a name="ln2466">      {</a>
<a name="ln2467">      Segment* previous = seg-&gt;prev();</a>
<a name="ln2468"> </a>
<a name="ln2469">      if (previous) {</a>
<a name="ln2470"> </a>
<a name="ln2471">            qreal minDist = previous-&gt;minHorizontalCollidingDistance(seg);</a>
<a name="ln2472"> </a>
<a name="ln2473">            qreal diff = (ed.pos.x()) - (previous-&gt;pageX() + minDist);</a>
<a name="ln2474"> </a>
<a name="ln2475">            qreal distanceBetweenSegments = (previous-&gt;pageX() + minDist) - seg-&gt;pageX();</a>
<a name="ln2476"> </a>
<a name="ln2477">            if (diff &lt; 0)</a>
<a name="ln2478">                  ned-&gt;delta.setX(distanceBetweenSegments);</a>
<a name="ln2479">            }</a>
<a name="ln2480">      else {</a>
<a name="ln2481">            Measure* measure = seg-&gt;measure();</a>
<a name="ln2482"> </a>
<a name="ln2483">            qreal minDist = score()-&gt;styleP(Sid::barNoteDistance);</a>
<a name="ln2484"> </a>
<a name="ln2485">            qreal diff = (ed.pos.x()) - (measure-&gt;pageX() + minDist);</a>
<a name="ln2486"> </a>
<a name="ln2487">            qreal distanceBetweenSegments = (measure-&gt;pageX() + minDist) - seg-&gt;pageX();</a>
<a name="ln2488"> </a>
<a name="ln2489">            if (diff &lt; 0)</a>
<a name="ln2490">                  ned-&gt;delta.setX(distanceBetweenSegments);</a>
<a name="ln2491">            }</a>
<a name="ln2492">      }</a>
<a name="ln2493"> </a>
<a name="ln2494">//---------------------------------------------------------</a>
<a name="ln2495">//   horizontalDrag</a>
<a name="ln2496">//---------------------------------------------------------</a>
<a name="ln2497"> </a>
<a name="ln2498">void Note::horizontalDrag(EditData &amp;ed)</a>
<a name="ln2499">      {</a>
<a name="ln2500">      Chord* ch = chord();</a>
<a name="ln2501">      Segment* seg = ch-&gt;segment();</a>
<a name="ln2502"> </a>
<a name="ln2503">      NoteEditData* ned = static_cast&lt;NoteEditData*&gt;(ed.getData(this));</a>
<a name="ln2504"> </a>
<a name="ln2505">      // adjust segment on plain drag or Shift+cursor,</a>
<a name="ln2506">      // adjust note/chord for Ctrl+drag or plain cursor</a>
<a name="ln2507">      if (seg &amp;&amp;</a>
<a name="ln2508">          (((ed.buttons &amp; Qt::LeftButton) &amp;&amp; !(ed.modifiers &amp; Qt::ControlModifier))</a>
<a name="ln2509">           || (ed.modifiers &amp; Qt::ShiftModifier))) {</a>
<a name="ln2510"> </a>
<a name="ln2511">            if (ed.delta.x() &lt; 0)</a>
<a name="ln2512">                  normalizeLeftDragDelta(seg, ed, ned);</a>
<a name="ln2513">            }</a>
<a name="ln2514"> </a>
<a name="ln2515">      const Spatium deltaSp = Spatium(ned-&gt;delta.x() / spatium());</a>
<a name="ln2516"> </a>
<a name="ln2517">      if (seg-&gt;extraLeadingSpace() + deltaSp &lt; Spatium(0)) {</a>
<a name="ln2518">          return;</a>
<a name="ln2519">      }</a>
<a name="ln2520"> </a>
<a name="ln2521">      seg-&gt;undoChangeProperty(Pid::LEADING_SPACE, seg-&gt;extraLeadingSpace() + deltaSp);</a>
<a name="ln2522"> </a>
<a name="ln2523">      triggerLayout();</a>
<a name="ln2524">      }</a>
<a name="ln2525"> </a>
<a name="ln2526">//---------------------------------------------------------</a>
<a name="ln2527">//   updateRelLine</a>
<a name="ln2528">//    calculate the real note line depending on clef,</a>
<a name="ln2529">//    _line is the absolute line</a>
<a name="ln2530">//---------------------------------------------------------</a>
<a name="ln2531"> </a>
<a name="ln2532">void Note::updateRelLine(int relLine, bool undoable)</a>
<a name="ln2533">      {</a>
<a name="ln2534">      if (!staff())</a>
<a name="ln2535">            return;</a>
<a name="ln2536">      // int idx      = staffIdx() + chord()-&gt;staffMove();</a>
<a name="ln2537">      Q_ASSERT(staffIdx() == chord()-&gt;staffIdx());</a>
<a name="ln2538">      int idx      = chord()-&gt;vStaffIdx();</a>
<a name="ln2539"> </a>
<a name="ln2540">      const Staff* staff  = score()-&gt;staff(idx);</a>
<a name="ln2541">      const StaffType* st = staff-&gt;staffType(tick());</a>
<a name="ln2542"> </a>
<a name="ln2543">      if (chord()-&gt;staffMove()) {</a>
<a name="ln2544">            // check that destination staff makes sense (might have been deleted)</a>
<a name="ln2545">            int minStaff = part()-&gt;startTrack() / VOICES;</a>
<a name="ln2546">            int maxStaff = part()-&gt;endTrack() / VOICES;</a>
<a name="ln2547">            const Staff* stf = this-&gt;staff();</a>
<a name="ln2548">            if (idx &lt; minStaff || idx &gt;= maxStaff || st-&gt;group() != stf-&gt;staffType(tick())-&gt;group()) {</a>
<a name="ln2549">                  qDebug(&quot;staffMove out of scope %d + %d min %d max %d&quot;,</a>
<a name="ln2550">                     staffIdx(), chord()-&gt;staffMove(), minStaff, maxStaff);</a>
<a name="ln2551">                  chord()-&gt;undoChangeProperty(Pid::STAFF_MOVE, 0);</a>
<a name="ln2552">                  }</a>
<a name="ln2553">            }</a>
<a name="ln2554"> </a>
<a name="ln2555">      ClefType clef = staff-&gt;clef(chord()-&gt;tick());</a>
<a name="ln2556">      int line      = relStep(relLine, clef);</a>
<a name="ln2557"> </a>
<a name="ln2558">      if (undoable &amp;&amp; (_line != INVALID_LINE) &amp;&amp; (line != _line))</a>
<a name="ln2559">            undoChangeProperty(Pid::LINE, line);</a>
<a name="ln2560">      else</a>
<a name="ln2561">            setLine(line);</a>
<a name="ln2562"> </a>
<a name="ln2563">      int off  = st-&gt;stepOffset();</a>
<a name="ln2564">      qreal ld = st-&gt;lineDistance().val();</a>
<a name="ln2565">      rypos()  = (_line + off * 2.0) * spatium() * .5 * ld;</a>
<a name="ln2566">      }</a>
<a name="ln2567"> </a>
<a name="ln2568">//---------------------------------------------------------</a>
<a name="ln2569">//   updateLine</a>
<a name="ln2570">//---------------------------------------------------------</a>
<a name="ln2571"> </a>
<a name="ln2572">void Note::updateLine()</a>
<a name="ln2573">      {</a>
<a name="ln2574">      int relLine = absStep(tpc(), epitch());</a>
<a name="ln2575">      updateRelLine(relLine, false);</a>
<a name="ln2576">      }</a>
<a name="ln2577"> </a>
<a name="ln2578">//---------------------------------------------------------</a>
<a name="ln2579">//   setNval</a>
<a name="ln2580">//    set note properties from NoteVal</a>
<a name="ln2581">//---------------------------------------------------------</a>
<a name="ln2582"> </a>
<a name="ln2583">void Note::setNval(const NoteVal&amp; nval, Fraction tick)</a>
<a name="ln2584">      {</a>
<a name="ln2585">      setPitch(nval.pitch);</a>
<a name="ln2586">      _fret   = nval.fret;</a>
<a name="ln2587">      _string = nval.string;</a>
<a name="ln2588"> </a>
<a name="ln2589">      _tpc[0] = nval.tpc1;</a>
<a name="ln2590">      _tpc[1] = nval.tpc2;</a>
<a name="ln2591"> </a>
<a name="ln2592">      if (tick == Fraction(-1,1) &amp;&amp; chord())</a>
<a name="ln2593">            tick = chord()-&gt;tick();</a>
<a name="ln2594">      Interval v = part()-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln2595">      if (nval.tpc1 == Tpc::TPC_INVALID) {</a>
<a name="ln2596">            Key key = staff()-&gt;key(tick);</a>
<a name="ln2597">            if (!concertPitch() &amp;&amp; !v.isZero())</a>
<a name="ln2598">                  key = transposeKey(key, v);</a>
<a name="ln2599">            _tpc[0] = pitch2tpc(nval.pitch, key, Prefer::NEAREST);</a>
<a name="ln2600">            }</a>
<a name="ln2601">      if (nval.tpc2 == Tpc::TPC_INVALID) {</a>
<a name="ln2602">            if (v.isZero())</a>
<a name="ln2603">                  _tpc[1] = _tpc[0];</a>
<a name="ln2604">            else {</a>
<a name="ln2605">                  v.flip();</a>
<a name="ln2606">                  _tpc[1] = Ms::transposeTpc(_tpc[0], v, true);</a>
<a name="ln2607">                  }</a>
<a name="ln2608">            }</a>
<a name="ln2609"> </a>
<a name="ln2610">      _headGroup = NoteHead::Group(nval.headGroup);</a>
<a name="ln2611">      }</a>
<a name="ln2612"> </a>
<a name="ln2613">//---------------------------------------------------------</a>
<a name="ln2614">//   localSpatiumChanged</a>
<a name="ln2615">//---------------------------------------------------------</a>
<a name="ln2616"> </a>
<a name="ln2617">void Note::localSpatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln2618">      {</a>
<a name="ln2619">      Element::localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2620">      for (Element* e : dots())</a>
<a name="ln2621">            e-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2622">      for (Element* e : el())</a>
<a name="ln2623">            e-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2624">      for (Spanner* spanner : spannerBack()) {</a>
<a name="ln2625">            for (auto k : spanner-&gt;spannerSegments())</a>
<a name="ln2626">                  k-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2627">            }</a>
<a name="ln2628">      }</a>
<a name="ln2629"> </a>
<a name="ln2630">//---------------------------------------------------------</a>
<a name="ln2631">//   getProperty</a>
<a name="ln2632">//---------------------------------------------------------</a>
<a name="ln2633"> </a>
<a name="ln2634">QVariant Note::getProperty(Pid propertyId) const</a>
<a name="ln2635">      {</a>
<a name="ln2636">      switch (propertyId) {</a>
<a name="ln2637">            case Pid::PITCH:</a>
<a name="ln2638">                  return pitch();</a>
<a name="ln2639">            case Pid::TPC1:</a>
<a name="ln2640">                  return _tpc[0];</a>
<a name="ln2641">            case Pid::TPC2:</a>
<a name="ln2642">                  return _tpc[1];</a>
<a name="ln2643">            case Pid::SMALL:</a>
<a name="ln2644">                  return small();</a>
<a name="ln2645">            case Pid::MIRROR_HEAD:</a>
<a name="ln2646">                  return int(userMirror());</a>
<a name="ln2647">            case Pid::DOT_POSITION:</a>
<a name="ln2648">                  return QVariant::fromValue&lt;Direction&gt;(userDotPosition());</a>
<a name="ln2649">            case Pid::HEAD_GROUP:</a>
<a name="ln2650">                  return int(headGroup());</a>
<a name="ln2651">            case Pid::VELO_OFFSET:</a>
<a name="ln2652">                  return veloOffset();</a>
<a name="ln2653">            case Pid::TUNING:</a>
<a name="ln2654">                  return tuning();</a>
<a name="ln2655">            case Pid::FRET:</a>
<a name="ln2656">                  return fret();</a>
<a name="ln2657">            case Pid::STRING:</a>
<a name="ln2658">                  return string();</a>
<a name="ln2659">            case Pid::GHOST:</a>
<a name="ln2660">                  return ghost();</a>
<a name="ln2661">            case Pid::HEAD_TYPE:</a>
<a name="ln2662">                  return int(headType());</a>
<a name="ln2663">            case Pid::VELO_TYPE:</a>
<a name="ln2664">                  return int(veloType());</a>
<a name="ln2665">            case Pid::PLAY:</a>
<a name="ln2666">                  return play();</a>
<a name="ln2667">            case Pid::LINE:</a>
<a name="ln2668">                  return _line;</a>
<a name="ln2669">            case Pid::FIXED:</a>
<a name="ln2670">                  return fixed();</a>
<a name="ln2671">            case Pid::FIXED_LINE:</a>
<a name="ln2672">                  return fixedLine();</a>
<a name="ln2673">            default:</a>
<a name="ln2674">                  break;</a>
<a name="ln2675">            }</a>
<a name="ln2676">      return Element::getProperty(propertyId);</a>
<a name="ln2677">      }</a>
<a name="ln2678"> </a>
<a name="ln2679">//---------------------------------------------------------</a>
<a name="ln2680">//   setProperty</a>
<a name="ln2681">//---------------------------------------------------------</a>
<a name="ln2682"> </a>
<a name="ln2683">bool Note::setProperty(Pid propertyId, const QVariant&amp; v)</a>
<a name="ln2684">      {</a>
<a name="ln2685">      Measure* m = chord() ? chord()-&gt;measure() : nullptr;</a>
<a name="ln2686">      switch(propertyId) {</a>
<a name="ln2687">            case Pid::PITCH:</a>
<a name="ln2688">                  setPitch(v.toInt());</a>
<a name="ln2689">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln2690">                  break;</a>
<a name="ln2691">            case Pid::TPC1:</a>
<a name="ln2692">                  _tpc[0] = v.toInt();</a>
<a name="ln2693">                  break;</a>
<a name="ln2694">            case Pid::TPC2:</a>
<a name="ln2695">                  _tpc[1] = v.toInt();</a>
<a name="ln2696">                  break;</a>
<a name="ln2697">            case Pid::LINE:</a>
<a name="ln2698">                  setLine(v.toInt());</a>
<a name="ln2699">                  break;</a>
<a name="ln2700">            case Pid::SMALL:</a>
<a name="ln2701">                  setSmall(v.toBool());</a>
<a name="ln2702">                  break;</a>
<a name="ln2703">            case Pid::MIRROR_HEAD:</a>
<a name="ln2704">                  setUserMirror(MScore::DirectionH(v.toInt()));</a>
<a name="ln2705">                  break;</a>
<a name="ln2706">            case Pid::DOT_POSITION:</a>
<a name="ln2707">                  setUserDotPosition(v.value&lt;Direction&gt;());</a>
<a name="ln2708">                  triggerLayout();</a>
<a name="ln2709">                  return true;</a>
<a name="ln2710">            case Pid::HEAD_GROUP:</a>
<a name="ln2711">                  setHeadGroup(NoteHead::Group(v.toInt()));</a>
<a name="ln2712">                  break;</a>
<a name="ln2713">            case Pid::VELO_OFFSET:</a>
<a name="ln2714">                  setVeloOffset(v.toInt());</a>
<a name="ln2715">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln2716">                  break;</a>
<a name="ln2717">            case Pid::TUNING:</a>
<a name="ln2718">                  setTuning(v.toDouble());</a>
<a name="ln2719">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln2720">                  break;</a>
<a name="ln2721">            case Pid::FRET:</a>
<a name="ln2722">                  setFret(v.toInt());</a>
<a name="ln2723">                  break;</a>
<a name="ln2724">            case Pid::STRING:</a>
<a name="ln2725">                  setString(v.toInt());</a>
<a name="ln2726">                  break;</a>
<a name="ln2727">            case Pid::GHOST:</a>
<a name="ln2728">                  setGhost(v.toBool());</a>
<a name="ln2729">                  break;</a>
<a name="ln2730">            case Pid::HEAD_TYPE:</a>
<a name="ln2731">                  setHeadType(NoteHead::Type(v.toInt()));</a>
<a name="ln2732">                  break;</a>
<a name="ln2733">            case Pid::VELO_TYPE:</a>
<a name="ln2734">                  setVeloType(ValueType(v.toInt()));</a>
<a name="ln2735">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln2736">                  break;</a>
<a name="ln2737">            case Pid::VISIBLE: {</a>
<a name="ln2738">                  setVisible(v.toBool());</a>
<a name="ln2739">                  if (m)</a>
<a name="ln2740">                        m-&gt;checkMultiVoices(chord()-&gt;staffIdx());</a>
<a name="ln2741">                  break;</a>
<a name="ln2742">                  }</a>
<a name="ln2743">            case Pid::PLAY:</a>
<a name="ln2744">                  setPlay(v.toBool());</a>
<a name="ln2745">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln2746">                  break;</a>
<a name="ln2747">            case Pid::FIXED:</a>
<a name="ln2748">                  setFixed(v.toBool());</a>
<a name="ln2749">                  break;</a>
<a name="ln2750">            case Pid::FIXED_LINE:</a>
<a name="ln2751">                  setFixedLine(v.toInt());</a>
<a name="ln2752">                  break;</a>
<a name="ln2753">            default:</a>
<a name="ln2754">                  if (!Element::setProperty(propertyId, v))</a>
<a name="ln2755">                        return false;</a>
<a name="ln2756">                  break;</a>
<a name="ln2757">            }</a>
<a name="ln2758">      triggerLayout();</a>
<a name="ln2759">      return true;</a>
<a name="ln2760">      }</a>
<a name="ln2761"> </a>
<a name="ln2762">//---------------------------------------------------------</a>
<a name="ln2763">//   undoChangeDotsVisible</a>
<a name="ln2764">//---------------------------------------------------------</a>
<a name="ln2765"> </a>
<a name="ln2766">void Note::undoChangeDotsVisible(bool v)</a>
<a name="ln2767">      {</a>
<a name="ln2768">      for (NoteDot* dot : _dots)</a>
<a name="ln2769">            dot-&gt;undoChangeProperty(Pid::VISIBLE, QVariant(v));</a>
<a name="ln2770">      }</a>
<a name="ln2771"> </a>
<a name="ln2772">//---------------------------------------------------------</a>
<a name="ln2773">//   propertyDefault</a>
<a name="ln2774">//---------------------------------------------------------</a>
<a name="ln2775"> </a>
<a name="ln2776">QVariant Note::propertyDefault(Pid propertyId) const</a>
<a name="ln2777">      {</a>
<a name="ln2778">      switch(propertyId) {</a>
<a name="ln2779">            case Pid::GHOST:</a>
<a name="ln2780">            case Pid::SMALL:</a>
<a name="ln2781">                  return false;</a>
<a name="ln2782">            case Pid::MIRROR_HEAD:</a>
<a name="ln2783">                  return int(MScore::DirectionH::AUTO);</a>
<a name="ln2784">            case Pid::DOT_POSITION:</a>
<a name="ln2785">                  return QVariant::fromValue&lt;Direction&gt;(Direction::AUTO);</a>
<a name="ln2786">            case Pid::HEAD_GROUP:</a>
<a name="ln2787">                  return int(NoteHead::Group::HEAD_NORMAL);</a>
<a name="ln2788">            case Pid::VELO_OFFSET:</a>
<a name="ln2789">                  return 0;</a>
<a name="ln2790">            case Pid::TUNING:</a>
<a name="ln2791">                  return 0.0;</a>
<a name="ln2792">            case Pid::FRET:</a>
<a name="ln2793">            case Pid::STRING:</a>
<a name="ln2794">                  return -1;</a>
<a name="ln2795">            case Pid::HEAD_TYPE:</a>
<a name="ln2796">                  return int(NoteHead::Type::HEAD_AUTO);</a>
<a name="ln2797">            case Pid::VELO_TYPE:</a>
<a name="ln2798">                  return int (ValueType::OFFSET_VAL);</a>
<a name="ln2799">            case Pid::PLAY:</a>
<a name="ln2800">                  return true;</a>
<a name="ln2801">            case Pid::FIXED:</a>
<a name="ln2802">                  return false;</a>
<a name="ln2803">            case Pid::FIXED_LINE:</a>
<a name="ln2804">                  return 0;</a>
<a name="ln2805">            case Pid::TPC2:</a>
<a name="ln2806">                  return getProperty(Pid::TPC1);</a>
<a name="ln2807">            case Pid::PITCH:</a>
<a name="ln2808">            case Pid::TPC1:</a>
<a name="ln2809">                  return QVariant();</a>
<a name="ln2810">            default:</a>
<a name="ln2811">                  break;</a>
<a name="ln2812">            }</a>
<a name="ln2813">      return Element::propertyDefault(propertyId);</a>
<a name="ln2814">      }</a>
<a name="ln2815"> </a>
<a name="ln2816">//---------------------------------------------------------</a>
<a name="ln2817">//   propertyUserValue</a>
<a name="ln2818">//---------------------------------------------------------</a>
<a name="ln2819"> </a>
<a name="ln2820">QString Note::propertyUserValue(Pid pid) const</a>
<a name="ln2821">      {</a>
<a name="ln2822">      switch(pid) {</a>
<a name="ln2823">            case Pid::PITCH:</a>
<a name="ln2824">                  return tpcUserName();</a>
<a name="ln2825">            case Pid::TPC1:</a>
<a name="ln2826">            case Pid::TPC2:</a>
<a name="ln2827">                  {</a>
<a name="ln2828">                  int idx = (pid == Pid::TPC1) ? 0 : 1;</a>
<a name="ln2829">                  int tpc = _tpc[idx];</a>
<a name="ln2830">                  return tpc2name(tpc, NoteSpellingType::STANDARD, NoteCaseType::AUTO, false);</a>
<a name="ln2831">                  }</a>
<a name="ln2832">            default:</a>
<a name="ln2833">                  return Element::propertyUserValue(pid);</a>
<a name="ln2834">            }</a>
<a name="ln2835">      }</a>
<a name="ln2836"> </a>
<a name="ln2837">//---------------------------------------------------------</a>
<a name="ln2838">//   setHeadType</a>
<a name="ln2839">//---------------------------------------------------------</a>
<a name="ln2840"> </a>
<a name="ln2841">void Note::setHeadType(NoteHead::Type t)</a>
<a name="ln2842">      {</a>
<a name="ln2843">      _headType = t;</a>
<a name="ln2844">      }</a>
<a name="ln2845"> </a>
<a name="ln2846">//---------------------------------------------------------</a>
<a name="ln2847">//   setOnTimeOffset</a>
<a name="ln2848">//---------------------------------------------------------</a>
<a name="ln2849"> </a>
<a name="ln2850">void Note::setOnTimeOffset(int val)</a>
<a name="ln2851">      {</a>
<a name="ln2852">      _playEvents[0].setOntime(val);</a>
<a name="ln2853">      chord()-&gt;setPlayEventType(PlayEventType::User);</a>
<a name="ln2854">      }</a>
<a name="ln2855"> </a>
<a name="ln2856">//---------------------------------------------------------</a>
<a name="ln2857">//   setOffTimeOffset</a>
<a name="ln2858">//---------------------------------------------------------</a>
<a name="ln2859"> </a>
<a name="ln2860">void Note::setOffTimeOffset(int val)</a>
<a name="ln2861">      {</a>
<a name="ln2862">      _playEvents[0].setLen(val - _playEvents[0].ontime());</a>
<a name="ln2863">      chord()-&gt;setPlayEventType(PlayEventType::User);</a>
<a name="ln2864">      }</a>
<a name="ln2865"> </a>
<a name="ln2866">//---------------------------------------------------------</a>
<a name="ln2867">//   setScore</a>
<a name="ln2868">//---------------------------------------------------------</a>
<a name="ln2869"> </a>
<a name="ln2870">void Note::setScore(Score* s)</a>
<a name="ln2871">      {</a>
<a name="ln2872">      Element::setScore(s);</a>
<a name="ln2873">      if (_tieFor)</a>
<a name="ln2874">            _tieFor-&gt;setScore(s);</a>
<a name="ln2875">      if (_accidental)</a>
<a name="ln2876">            _accidental-&gt;setScore(s);</a>
<a name="ln2877">      for (NoteDot* dot : _dots)</a>
<a name="ln2878">            dot-&gt;setScore(s);</a>
<a name="ln2879">      for (Element* el : _el)</a>
<a name="ln2880">            el-&gt;setScore(s);</a>
<a name="ln2881">      }</a>
<a name="ln2882"> </a>
<a name="ln2883">//---------------------------------------------------------</a>
<a name="ln2884">//   accessibleInfo</a>
<a name="ln2885">//---------------------------------------------------------</a>
<a name="ln2886"> </a>
<a name="ln2887">QString Note::accessibleInfo() const</a>
<a name="ln2888">      {</a>
<a name="ln2889">      QString duration = chord()-&gt;durationUserName();</a>
<a name="ln2890">      QString voice = QObject::tr(&quot;Voice: %1&quot;).arg(QString::number(track() % VOICES + 1));</a>
<a name="ln2891">      QString pitchName;</a>
<a name="ln2892">      const Drumset* drumset = part()-&gt;instrument()-&gt;drumset();</a>
<a name="ln2893">      if (fixed() &amp;&amp; headGroup() == NoteHead::Group::HEAD_SLASH)</a>
<a name="ln2894">            pitchName = chord()-&gt;noStem() ? QObject::tr(&quot;Beat slash&quot;) : QObject::tr(&quot;Rhythm slash&quot;);</a>
<a name="ln2895">      else if (staff()-&gt;isDrumStaff(tick()) &amp;&amp; drumset)</a>
<a name="ln2896">            pitchName = qApp-&gt;translate(&quot;drumset&quot;, drumset-&gt;name(pitch()).toUtf8().constData());</a>
<a name="ln2897">      else if (staff()-&gt;isTabStaff(tick()))</a>
<a name="ln2898">            pitchName = QObject::tr(&quot;%1; String %2; Fret %3&quot;).arg(tpcUserName(false)).arg(QString::number(string() + 1)).arg(QString::number(fret()));</a>
<a name="ln2899">      else</a>
<a name="ln2900">            pitchName = tpcUserName(false);</a>
<a name="ln2901">      return QObject::tr(&quot;%1; Pitch: %2; Duration: %3%4&quot;).arg(noteTypeUserName()).arg(pitchName).arg(duration).arg((chord()-&gt;isGrace() ? &quot;&quot; : QString(&quot;; %1&quot;).arg(voice)));</a>
<a name="ln2902">      }</a>
<a name="ln2903"> </a>
<a name="ln2904">//---------------------------------------------------------</a>
<a name="ln2905">//   screenReaderInfo</a>
<a name="ln2906">//---------------------------------------------------------</a>
<a name="ln2907"> </a>
<a name="ln2908">QString Note::screenReaderInfo() const</a>
<a name="ln2909">      {</a>
<a name="ln2910">      QString duration = chord()-&gt;durationUserName();</a>
<a name="ln2911">      Measure* m = chord()-&gt;measure();</a>
<a name="ln2912">      bool voices = m ? m-&gt;hasVoices(staffIdx()) : false;</a>
<a name="ln2913">      QString voice = voices ? QObject::tr(&quot;Voice: %1&quot;).arg(QString::number(track() % VOICES + 1)) : &quot;&quot;;</a>
<a name="ln2914">      QString pitchName;</a>
<a name="ln2915">      const Drumset* drumset = part()-&gt;instrument()-&gt;drumset();</a>
<a name="ln2916">      if (fixed() &amp;&amp; headGroup() == NoteHead::Group::HEAD_SLASH)</a>
<a name="ln2917">            pitchName = chord()-&gt;noStem() ? QObject::tr(&quot;Beat Slash&quot;) : QObject::tr(&quot;Rhythm Slash&quot;);</a>
<a name="ln2918">      else if (staff()-&gt;isDrumStaff(tick()) &amp;&amp; drumset)</a>
<a name="ln2919">            pitchName = qApp-&gt;translate(&quot;drumset&quot;, drumset-&gt;name(pitch()).toUtf8().constData());</a>
<a name="ln2920">      else if (staff()-&gt;isTabStaff(tick()))</a>
<a name="ln2921">            pitchName = QObject::tr(&quot;%1 String %2 Fret %3&quot;).arg(tpcUserName(true)).arg(QString::number(string() + 1)).arg(QString::number(fret()));</a>
<a name="ln2922">      else</a>
<a name="ln2923">            pitchName = tpcUserName(true);</a>
<a name="ln2924">      return QString(&quot;%1 %2 %3%4&quot;).arg(noteTypeUserName()).arg(pitchName).arg(duration).arg((chord()-&gt;isGrace() ? &quot;&quot; : QString(&quot;; %1&quot;).arg(voice)));</a>
<a name="ln2925">      }</a>
<a name="ln2926"> </a>
<a name="ln2927">//---------------------------------------------------------</a>
<a name="ln2928">//   accessibleExtraInfo</a>
<a name="ln2929">//---------------------------------------------------------</a>
<a name="ln2930"> </a>
<a name="ln2931">QString Note::accessibleExtraInfo() const</a>
<a name="ln2932">      {</a>
<a name="ln2933">      QString rez = &quot;&quot;;</a>
<a name="ln2934">      if (accidental()) {</a>
<a name="ln2935">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(accidental()-&gt;screenReaderInfo());</a>
<a name="ln2936">            }</a>
<a name="ln2937">      if (!el().empty()) {</a>
<a name="ln2938">            for (Element* e : el()) {</a>
<a name="ln2939">                  if (!score()-&gt;selectionFilter().canSelect(e)) continue;</a>
<a name="ln2940">                  rez = QString(&quot;%1 %2&quot;).arg(rez).arg(e-&gt;screenReaderInfo());</a>
<a name="ln2941">                  }</a>
<a name="ln2942">            }</a>
<a name="ln2943">      if (tieFor())</a>
<a name="ln2944">            rez = QObject::tr(&quot;%1 Start of %2&quot;).arg(rez).arg(tieFor()-&gt;screenReaderInfo());</a>
<a name="ln2945"> </a>
<a name="ln2946">      if (tieBack())</a>
<a name="ln2947">            rez = QObject::tr(&quot;%1 End of %2&quot;).arg(rez).arg(tieBack()-&gt;screenReaderInfo());</a>
<a name="ln2948"> </a>
<a name="ln2949">      if (!spannerFor().empty()) {</a>
<a name="ln2950">            for (Spanner* s : spannerFor()) {</a>
<a name="ln2951">                  if (!score()-&gt;selectionFilter().canSelect(s))</a>
<a name="ln2952">                        continue;</a>
<a name="ln2953">                  rez = QObject::tr(&quot;%1 Start of %2&quot;).arg(rez).arg(s-&gt;screenReaderInfo());</a>
<a name="ln2954">                  }</a>
<a name="ln2955">            }</a>
<a name="ln2956">      if (!spannerBack().empty()) {</a>
<a name="ln2957">            for (Spanner* s : spannerBack()) {</a>
<a name="ln2958">                  if (!score()-&gt;selectionFilter().canSelect(s))</a>
<a name="ln2959">                        continue;</a>
<a name="ln2960">                  rez = QObject::tr(&quot;%1 End of %2&quot;).arg(rez).arg(s-&gt;screenReaderInfo());</a>
<a name="ln2961">                  }</a>
<a name="ln2962">            }</a>
<a name="ln2963"> </a>
<a name="ln2964">      // only read extra information for top note of chord</a>
<a name="ln2965">      // (it is reached directly on next/previous element)</a>
<a name="ln2966">      if (this == chord()-&gt;upNote())</a>
<a name="ln2967">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(chord()-&gt;accessibleExtraInfo());</a>
<a name="ln2968"> </a>
<a name="ln2969">      return rez;</a>
<a name="ln2970">      }</a>
<a name="ln2971"> </a>
<a name="ln2972">//---------------------------------------------------------</a>
<a name="ln2973">//   noteVal</a>
<a name="ln2974">//---------------------------------------------------------</a>
<a name="ln2975"> </a>
<a name="ln2976">NoteVal Note::noteVal() const</a>
<a name="ln2977">      {</a>
<a name="ln2978">      NoteVal nval;</a>
<a name="ln2979">      nval.pitch     = pitch();</a>
<a name="ln2980">      nval.tpc1      = tpc1();</a>
<a name="ln2981">      nval.tpc2      = tpc2();</a>
<a name="ln2982">      nval.fret      = fret();</a>
<a name="ln2983">      nval.string    = string();</a>
<a name="ln2984">      nval.headGroup = headGroup();</a>
<a name="ln2985">      return nval;</a>
<a name="ln2986">      }</a>
<a name="ln2987"> </a>
<a name="ln2988">//---------------------------------------------------------</a>
<a name="ln2989">//   qmlDotsCount</a>
<a name="ln2990">//    returns number of dots for plugins</a>
<a name="ln2991">//---------------------------------------------------------</a>
<a name="ln2992"> </a>
<a name="ln2993">int Note::qmlDotsCount()</a>
<a name="ln2994">      {</a>
<a name="ln2995">      return _dots.size();</a>
<a name="ln2996">      }</a>
<a name="ln2997"> </a>
<a name="ln2998">//---------------------------------------------------------</a>
<a name="ln2999">//   subtypeName</a>
<a name="ln3000">//---------------------------------------------------------</a>
<a name="ln3001"> </a>
<a name="ln3002">QString Note::subtypeName() const</a>
<a name="ln3003">      {</a>
<a name="ln3004">      return NoteHead::group2userName(_headGroup);</a>
<a name="ln3005">      }</a>
<a name="ln3006"> </a>
<a name="ln3007">//---------------------------------------------------------</a>
<a name="ln3008">//   nextInEl</a>
<a name="ln3009">//   returns next element in _el</a>
<a name="ln3010">//---------------------------------------------------------</a>
<a name="ln3011"> </a>
<a name="ln3012">Element* Note::nextInEl(Element* e)</a>
<a name="ln3013">      {</a>
<a name="ln3014">      if (e == _el.back())</a>
<a name="ln3015">            return nullptr;</a>
<a name="ln3016">      auto i = std::find(_el.begin(), _el.end(), e);</a>
<a name="ln3017">      if (i == _el.end())</a>
<a name="ln3018">            return nullptr;</a>
<a name="ln3019">      return *(i+1);</a>
<a name="ln3020">      }</a>
<a name="ln3021"> </a>
<a name="ln3022">//---------------------------------------------------------</a>
<a name="ln3023">//   prevInEl</a>
<a name="ln3024">//   returns prev element in _el</a>
<a name="ln3025">//---------------------------------------------------------</a>
<a name="ln3026"> </a>
<a name="ln3027">Element* Note::prevInEl(Element* e)</a>
<a name="ln3028">      {</a>
<a name="ln3029">      if (e == _el.front())</a>
<a name="ln3030">            return nullptr;</a>
<a name="ln3031">      auto i = std::find(_el.begin(), _el.end(), e);</a>
<a name="ln3032">      if (i == _el.end())</a>
<a name="ln3033">            return nullptr;</a>
<a name="ln3034">      return *(i-1);</a>
<a name="ln3035">      }</a>
<a name="ln3036"> </a>
<a name="ln3037">static bool tieValid(Tie* tie)</a>
<a name="ln3038">      {</a>
<a name="ln3039">      return (tie &amp;&amp; !tie-&gt;segmentsEmpty());</a>
<a name="ln3040">      }</a>
<a name="ln3041"> </a>
<a name="ln3042">//---------------------------------------------------------</a>
<a name="ln3043">//   nextElement</a>
<a name="ln3044">//---------------------------------------------------------</a>
<a name="ln3045"> </a>
<a name="ln3046">Element* Note::nextElement()</a>
<a name="ln3047">      {</a>
<a name="ln3048">      Element* e = score()-&gt;selection().element();</a>
<a name="ln3049">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty() )</a>
<a name="ln3050">            e = score()-&gt;selection().elements().first();</a>
<a name="ln3051">      switch (e-&gt;type()) {</a>
<a name="ln3052">            case ElementType::SYMBOL:</a>
<a name="ln3053">            case ElementType::IMAGE:</a>
<a name="ln3054">            case ElementType::FINGERING:</a>
<a name="ln3055">            case ElementType::TEXT:</a>
<a name="ln3056">            case ElementType::BEND: {</a>
<a name="ln3057">                  Element* next = nextInEl(e); // return next element in _el</a>
<a name="ln3058">                  if (next)</a>
<a name="ln3059">                        return next;</a>
<a name="ln3060">                  else if (tieValid(_tieFor))</a>
<a name="ln3061">                        return _tieFor-&gt;frontSegment();</a>
<a name="ln3062">                  else if (!_spannerFor.empty()) {</a>
<a name="ln3063">                        for (auto i : _spannerFor) {</a>
<a name="ln3064">                              if (i-&gt;type() == ElementType::GLISSANDO)</a>
<a name="ln3065">                                    return i-&gt;spannerSegments().front();</a>
<a name="ln3066">                              }</a>
<a name="ln3067">                        }</a>
<a name="ln3068">                  return 0;</a>
<a name="ln3069">                  }</a>
<a name="ln3070"> </a>
<a name="ln3071">            case ElementType::TIE_SEGMENT:</a>
<a name="ln3072">                  if (!_spannerFor.empty()) {</a>
<a name="ln3073">                      for (auto i : _spannerFor) {</a>
<a name="ln3074">                            if (i-&gt;type() == ElementType::GLISSANDO)</a>
<a name="ln3075">                                  return i-&gt;spannerSegments().front();</a>
<a name="ln3076">                                  }</a>
<a name="ln3077">                            }</a>
<a name="ln3078">                  return chord()-&gt;nextElement();</a>
<a name="ln3079"> </a>
<a name="ln3080">            case ElementType::GLISSANDO_SEGMENT:</a>
<a name="ln3081">                  return chord()-&gt;nextElement();</a>
<a name="ln3082"> </a>
<a name="ln3083">            case ElementType::ACCIDENTAL:</a>
<a name="ln3084">                  if (!_el.empty())</a>
<a name="ln3085">                        return _el[0];</a>
<a name="ln3086">                  if (tieValid(_tieFor))</a>
<a name="ln3087">                        return _tieFor-&gt;frontSegment();</a>
<a name="ln3088">                  if (!_spannerFor.empty()) {</a>
<a name="ln3089">                        for (auto i : _spannerFor) {</a>
<a name="ln3090">                              if (i-&gt;isGlissando())</a>
<a name="ln3091">                                    return i-&gt;spannerSegments().front();</a>
<a name="ln3092">                              }</a>
<a name="ln3093">                        }</a>
<a name="ln3094">                  return 0;</a>
<a name="ln3095"> </a>
<a name="ln3096">            case ElementType::NOTE:</a>
<a name="ln3097">                  if (!_el.empty())</a>
<a name="ln3098">                        return _el[0];</a>
<a name="ln3099">                  if (tieValid(_tieFor))</a>
<a name="ln3100">                        return _tieFor-&gt;frontSegment();</a>
<a name="ln3101">                  if (!_spannerFor.empty()) {</a>
<a name="ln3102">                        for (auto i : _spannerFor) {</a>
<a name="ln3103">                              if (i-&gt;isGlissando())</a>
<a name="ln3104">                                    return i-&gt;spannerSegments().front();</a>
<a name="ln3105">                              }</a>
<a name="ln3106">                        }</a>
<a name="ln3107">                  return 0;</a>
<a name="ln3108"> </a>
<a name="ln3109">            default:</a>
<a name="ln3110">                  return 0;</a>
<a name="ln3111">            }</a>
<a name="ln3112">      }</a>
<a name="ln3113"> </a>
<a name="ln3114">//---------------------------------------------------------</a>
<a name="ln3115">//   prevElement</a>
<a name="ln3116">//---------------------------------------------------------</a>
<a name="ln3117"> </a>
<a name="ln3118">Element* Note::prevElement()</a>
<a name="ln3119">      {</a>
<a name="ln3120">      Element* e = score()-&gt;selection().element();</a>
<a name="ln3121">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty() )</a>
<a name="ln3122">            e = score()-&gt;selection().elements().last();</a>
<a name="ln3123">      switch (e-&gt;type()) {</a>
<a name="ln3124">            case ElementType::SYMBOL:</a>
<a name="ln3125">            case ElementType::IMAGE:</a>
<a name="ln3126">            case ElementType::FINGERING:</a>
<a name="ln3127">            case ElementType::TEXT:</a>
<a name="ln3128">            case ElementType::BEND: {</a>
<a name="ln3129">                  Element* prev = prevInEl(e); // return prev element in _el</a>
<a name="ln3130">                  if (prev)</a>
<a name="ln3131">                        return prev;</a>
<a name="ln3132">                  }</a>
<a name="ln3133">                  return this;</a>
<a name="ln3134">            case ElementType::TIE_SEGMENT:</a>
<a name="ln3135">                  if (!_el.empty())</a>
<a name="ln3136">                        return _el.back();</a>
<a name="ln3137">                  return this;</a>
<a name="ln3138">            case ElementType::GLISSANDO_SEGMENT:</a>
<a name="ln3139">                  if (tieValid(_tieFor))</a>
<a name="ln3140">                        return _tieFor-&gt;frontSegment();</a>
<a name="ln3141">                  else if (!_el.empty())</a>
<a name="ln3142">                        return _el.back();</a>
<a name="ln3143">                  return this;</a>
<a name="ln3144">            case ElementType::ACCIDENTAL:</a>
<a name="ln3145">                  return this;</a>
<a name="ln3146">            default:</a>
<a name="ln3147">                  return 0;</a>
<a name="ln3148">            }</a>
<a name="ln3149">      }</a>
<a name="ln3150"> </a>
<a name="ln3151">//---------------------------------------------------------</a>
<a name="ln3152">//   lastElementBeforeSegment</a>
<a name="ln3153">//---------------------------------------------------------</a>
<a name="ln3154"> </a>
<a name="ln3155">Element* Note::lastElementBeforeSegment()</a>
<a name="ln3156">      {</a>
<a name="ln3157">      if (!_spannerFor.empty()) {</a>
<a name="ln3158">            for (auto i : _spannerFor) {</a>
<a name="ln3159">                  if (i-&gt;type() == ElementType::GLISSANDO)</a>
<a name="ln3160">                        return i-&gt;spannerSegments().front();</a>
<a name="ln3161">                  }</a>
<a name="ln3162">            }</a>
<a name="ln3163">      if (tieValid(_tieFor))</a>
<a name="ln3164">            return _tieFor-&gt;frontSegment();</a>
<a name="ln3165">      if (!_el.empty())</a>
<a name="ln3166">            return _el.back();</a>
<a name="ln3167">      return this;</a>
<a name="ln3168">      }</a>
<a name="ln3169"> </a>
<a name="ln3170">//---------------------------------------------------------</a>
<a name="ln3171">//   nextSegmentElement</a>
<a name="ln3172">//---------------------------------------------------------</a>
<a name="ln3173"> </a>
<a name="ln3174">Element* Note::nextSegmentElement()</a>
<a name="ln3175">      {</a>
<a name="ln3176">      if (chord()-&gt;isGrace())</a>
<a name="ln3177">            return Element::nextSegmentElement();</a>
<a name="ln3178"> </a>
<a name="ln3179">      const std::vector&lt;Note*&gt;&amp; notes = chord()-&gt;notes();</a>
<a name="ln3180">      if (this == notes.front())</a>
<a name="ln3181">            return chord()-&gt;nextSegmentElement();</a>
<a name="ln3182">      auto i = std::find(notes.begin(), notes.end(), this);</a>
<a name="ln3183">      return *(i-1);</a>
<a name="ln3184">      }</a>
<a name="ln3185"> </a>
<a name="ln3186">//---------------------------------------------------------</a>
<a name="ln3187">//   prevSegmentElement</a>
<a name="ln3188">//---------------------------------------------------------</a>
<a name="ln3189"> </a>
<a name="ln3190">Element* Note::prevSegmentElement()</a>
<a name="ln3191">      {</a>
<a name="ln3192">      if (chord()-&gt;isGrace())</a>
<a name="ln3193">            return Element::prevSegmentElement();</a>
<a name="ln3194"> </a>
<a name="ln3195">      const std::vector&lt;Note*&gt;&amp; notes = chord()-&gt;notes();</a>
<a name="ln3196">      if (this == notes.back())</a>
<a name="ln3197">            return chord()-&gt;prevSegmentElement();</a>
<a name="ln3198">      auto i = std::find(notes.begin(), notes.end(), this);</a>
<a name="ln3199">      return *++i;</a>
<a name="ln3200">      }</a>
<a name="ln3201"> </a>
<a name="ln3202">//---------------------------------------------------------</a>
<a name="ln3203">//   lastTiedNote</a>
<a name="ln3204">//---------------------------------------------------------</a>
<a name="ln3205"> </a>
<a name="ln3206">const Note* Note::lastTiedNote() const</a>
<a name="ln3207">      {</a>
<a name="ln3208">      std::vector&lt;const Note*&gt; notes;</a>
<a name="ln3209">      const Note* note = this;</a>
<a name="ln3210">      notes.push_back(note);</a>
<a name="ln3211">      while (note-&gt;tieFor()) {</a>
<a name="ln3212">            if (std::find(notes.begin(), notes.end(), note-&gt;tieFor()-&gt;endNote()) != notes.end())</a>
<a name="ln3213">                  break;</a>
<a name="ln3214">            if (!note-&gt;tieFor()-&gt;endNote())</a>
<a name="ln3215">                  break;</a>
<a name="ln3216">            note = note-&gt;tieFor()-&gt;endNote();</a>
<a name="ln3217">            notes.push_back(note);</a>
<a name="ln3218">            }</a>
<a name="ln3219">      return note;</a>
<a name="ln3220">      }</a>
<a name="ln3221"> </a>
<a name="ln3222">//---------------------------------------------------------</a>
<a name="ln3223">//   firstTiedNote</a>
<a name="ln3224">//    if note has ties, return last note in chain</a>
<a name="ln3225">//    - handle recursion in connected notes</a>
<a name="ln3226">//---------------------------------------------------------</a>
<a name="ln3227"> </a>
<a name="ln3228">Note* Note::firstTiedNote() const</a>
<a name="ln3229">      {</a>
<a name="ln3230">      std::vector&lt;const Note*&gt; notes;</a>
<a name="ln3231">      const Note* note = this;</a>
<a name="ln3232">      notes.push_back(note);</a>
<a name="ln3233">      while (note-&gt;tieBack()) {</a>
<a name="ln3234">            if (std::find(notes.begin(), notes.end(), note-&gt;tieBack()-&gt;startNote()) != notes.end())</a>
<a name="ln3235">                  break;</a>
<a name="ln3236">            note = note-&gt;tieBack()-&gt;startNote();</a>
<a name="ln3237">            notes.push_back(note);</a>
<a name="ln3238">            }</a>
<a name="ln3239">      return const_cast&lt;Note*&gt;(note);</a>
<a name="ln3240">      }</a>
<a name="ln3241"> </a>
<a name="ln3242">//---------------------------------------------------------</a>
<a name="ln3243">//   tiedNotes</a>
<a name="ln3244">//---------------------------------------------------------</a>
<a name="ln3245"> </a>
<a name="ln3246">std::vector&lt;Note*&gt; Note::tiedNotes() const</a>
<a name="ln3247">      {</a>
<a name="ln3248">      std::vector&lt;Note*&gt; notes;</a>
<a name="ln3249">      Note* note = firstTiedNote();</a>
<a name="ln3250"> </a>
<a name="ln3251">      notes.push_back(note);</a>
<a name="ln3252">      while (note-&gt;tieFor()) {</a>
<a name="ln3253">            Note* endNote = note-&gt;tieFor()-&gt;endNote();</a>
<a name="ln3254">            if (!endNote || std::find(notes.begin(), notes.end(), endNote) != notes.end())</a>
<a name="ln3255">                  break;</a>
<a name="ln3256">            note = endNote;</a>
<a name="ln3257">            notes.push_back(note);</a>
<a name="ln3258">            }</a>
<a name="ln3259">      return notes;</a>
<a name="ln3260">      }</a>
<a name="ln3261"> </a>
<a name="ln3262">//---------------------------------------------------------</a>
<a name="ln3263">//   unisonIndex</a>
<a name="ln3264">//---------------------------------------------------------</a>
<a name="ln3265"> </a>
<a name="ln3266">int Note::unisonIndex() const</a>
<a name="ln3267">      {</a>
<a name="ln3268">      int index = 0;</a>
<a name="ln3269">      for (Note* n : chord()-&gt;notes()) {</a>
<a name="ln3270">            if (n-&gt;pitch() == pitch()) {</a>
<a name="ln3271">                  if (n == this)</a>
<a name="ln3272">                        return index;</a>
<a name="ln3273">                  else</a>
<a name="ln3274">                        ++index;</a>
<a name="ln3275">                  }</a>
<a name="ln3276">            }</a>
<a name="ln3277">      return 0;</a>
<a name="ln3278">      }</a>
<a name="ln3279"> </a>
<a name="ln3280">//---------------------------------------------------------</a>
<a name="ln3281">//   disconnectTiedNotes</a>
<a name="ln3282">//---------------------------------------------------------</a>
<a name="ln3283"> </a>
<a name="ln3284">void Note::disconnectTiedNotes()</a>
<a name="ln3285">      {</a>
<a name="ln3286">      if (tieBack() &amp;&amp; tieBack()-&gt;startNote()) {</a>
<a name="ln3287">            tieBack()-&gt;startNote()-&gt;remove(tieBack());</a>
<a name="ln3288">            }</a>
<a name="ln3289">      if (tieFor() &amp;&amp; tieFor()-&gt;endNote()) {</a>
<a name="ln3290">            tieFor()-&gt;endNote()-&gt;setTieBack(0);</a>
<a name="ln3291">            }</a>
<a name="ln3292">      }</a>
<a name="ln3293"> </a>
<a name="ln3294">//---------------------------------------------------------</a>
<a name="ln3295">//   connectTiedNotes</a>
<a name="ln3296">//---------------------------------------------------------</a>
<a name="ln3297"> </a>
<a name="ln3298">void Note::connectTiedNotes()</a>
<a name="ln3299">      {</a>
<a name="ln3300">      if (tieBack()) {</a>
<a name="ln3301">            tieBack()-&gt;setEndNote(this);</a>
<a name="ln3302">            if (tieBack()-&gt;startNote())</a>
<a name="ln3303">                  tieBack()-&gt;startNote()-&gt;add(tieBack());</a>
<a name="ln3304">            }</a>
<a name="ln3305">      if (tieFor() &amp;&amp; tieFor()-&gt;endNote()) {</a>
<a name="ln3306">            tieFor()-&gt;endNote()-&gt;setTieBack(tieFor());</a>
<a name="ln3307">            }</a>
<a name="ln3308">      }</a>
<a name="ln3309"> </a>
<a name="ln3310">//---------------------------------------------------------</a>
<a name="ln3311">//   accidentalType</a>
<a name="ln3312">//---------------------------------------------------------</a>
<a name="ln3313"> </a>
<a name="ln3314">AccidentalType Note::accidentalType() const</a>
<a name="ln3315">      {</a>
<a name="ln3316">      return _accidental ? _accidental-&gt;accidentalType() : AccidentalType::NONE;</a>
<a name="ln3317">      }</a>
<a name="ln3318"> </a>
<a name="ln3319">//---------------------------------------------------------</a>
<a name="ln3320">//   setAccidentalType</a>
<a name="ln3321">//---------------------------------------------------------</a>
<a name="ln3322"> </a>
<a name="ln3323">void Note::setAccidentalType(AccidentalType type)</a>
<a name="ln3324">      {</a>
<a name="ln3325">      if (score())</a>
<a name="ln3326">         score()-&gt;changeAccidental(this, type);</a>
<a name="ln3327">      }</a>
<a name="ln3328"> </a>
<a name="ln3329">//---------------------------------------------------------</a>
<a name="ln3330">//   shape</a>
<a name="ln3331">//---------------------------------------------------------</a>
<a name="ln3332"> </a>
<a name="ln3333">Shape Note::shape() const</a>
<a name="ln3334">      {</a>
<a name="ln3335">      QRectF r(bbox());</a>
<a name="ln3336"> </a>
<a name="ln3337">#ifndef NDEBUG</a>
<a name="ln3338">      Shape shape(r, name());</a>
<a name="ln3339">      for (NoteDot* dot : _dots)</a>
<a name="ln3340">            shape.add(symBbox(SymId::augmentationDot).translated(dot-&gt;pos()), dot-&gt;name());</a>
<a name="ln3341">      if (_accidental)</a>
<a name="ln3342">            shape.add(_accidental-&gt;bbox().translated(_accidental-&gt;pos()), _accidental-&gt;name());</a>
<a name="ln3343">      for (auto e : _el) {</a>
<a name="ln3344">            if (e-&gt;autoplace() &amp;&amp; e-&gt;visible()) {</a>
<a name="ln3345">                  if (e-&gt;isFingering() &amp;&amp; toFingering(e)-&gt;layoutType() != ElementType::NOTE)</a>
<a name="ln3346">                        continue;</a>
<a name="ln3347">                  shape.add(e-&gt;bbox().translated(e-&gt;pos()), e-&gt;name());</a>
<a name="ln3348">                  }</a>
<a name="ln3349">            }</a>
<a name="ln3350">#else</a>
<a name="ln3351">      Shape shape(r);</a>
<a name="ln3352">      for (NoteDot* dot : _dots)</a>
<a name="ln3353">            shape.add(symBbox(SymId::augmentationDot).translated(dot-&gt;pos()));</a>
<a name="ln3354">      if (_accidental)</a>
<a name="ln3355">            shape.add(_accidental-&gt;bbox().translated(_accidental-&gt;pos()));</a>
<a name="ln3356">      for (auto e : _el) {</a>
<a name="ln3357">            if (e-&gt;autoplace() &amp;&amp; e-&gt;visible()) {</a>
<a name="ln3358">                  if (e-&gt;isFingering() &amp;&amp; toFingering(e)-&gt;layoutType() != ElementType::NOTE)</a>
<a name="ln3359">                        continue;</a>
<a name="ln3360">                  shape.add(e-&gt;bbox().translated(e-&gt;pos()));</a>
<a name="ln3361">                  }</a>
<a name="ln3362">            }</a>
<a name="ln3363">#endif</a>
<a name="ln3364">      return shape;</a>
<a name="ln3365">      }</a>
<a name="ln3366"> </a>
<a name="ln3367">//---------------------------------------------------------</a>
<a name="ln3368">//   undoUnlink</a>
<a name="ln3369">//---------------------------------------------------------</a>
<a name="ln3370"> </a>
<a name="ln3371">void Note::undoUnlink()</a>
<a name="ln3372">      {</a>
<a name="ln3373">      Element::undoUnlink();</a>
<a name="ln3374">      for (Element* e : _el)</a>
<a name="ln3375">            e-&gt;undoUnlink();</a>
<a name="ln3376">      }</a>
<a name="ln3377"> </a>
<a name="ln3378">}</a>

</code></pre>
<div class="balloon" rel="1037"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1060"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1080"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1154"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'chord()' pointer was utilized before it was verified against nullptr. Check lines: 1154, 1158.</p></div>
<div class="balloon" rel="1282"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'staff()' is always true.</p></div>
<div class="balloon" rel="2517"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'seg' pointer was used unsafely after it was verified against nullptr. Check lines: 2507, 2517.</p></div>
<div class="balloon" rel="3084"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 3084, 3097</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
