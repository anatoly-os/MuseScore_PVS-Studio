
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>line.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2012 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;line.h&quot;</a>
<a name="ln14"> </a>
<a name="ln15">#include &quot;barline.h&quot;</a>
<a name="ln16">#include &quot;chord.h&quot;</a>
<a name="ln17">#include &quot;lyrics.h&quot;</a>
<a name="ln18">#include &quot;measure.h&quot;</a>
<a name="ln19">#include &quot;note.h&quot;</a>
<a name="ln20">#include &quot;part.h&quot;</a>
<a name="ln21">#include &quot;score.h&quot;</a>
<a name="ln22">#include &quot;segment.h&quot;</a>
<a name="ln23">#include &quot;staff.h&quot;</a>
<a name="ln24">#include &quot;sym.h&quot;</a>
<a name="ln25">#include &quot;system.h&quot;</a>
<a name="ln26">#include &quot;textline.h&quot;</a>
<a name="ln27">#include &quot;utils.h&quot;</a>
<a name="ln28">#include &quot;xml.h&quot;</a>
<a name="ln29"> </a>
<a name="ln30">namespace Ms {</a>
<a name="ln31"> </a>
<a name="ln32">//---------------------------------------------------------</a>
<a name="ln33">//   LineSegment</a>
<a name="ln34">//---------------------------------------------------------</a>
<a name="ln35"> </a>
<a name="ln36">LineSegment::LineSegment(const LineSegment&amp; s)</a>
<a name="ln37">   : SpannerSegment(s)</a>
<a name="ln38">      {</a>
<a name="ln39">      }</a>
<a name="ln40"> </a>
<a name="ln41">//---------------------------------------------------------</a>
<a name="ln42">//   readProperties</a>
<a name="ln43">//---------------------------------------------------------</a>
<a name="ln44"> </a>
<a name="ln45">bool LineSegment::readProperties(XmlReader&amp; e)</a>
<a name="ln46">      {</a>
<a name="ln47">      const QStringRef&amp; tag(e.name());</a>
<a name="ln48">      if (tag == &quot;subtype&quot;)</a>
<a name="ln49">            setSpannerSegmentType(SpannerSegmentType(e.readInt()));</a>
<a name="ln50">      else if (tag == &quot;off2&quot;) {</a>
<a name="ln51">            setUserOff2(e.readPoint() * score()-&gt;spatium());</a>
<a name="ln52">            }</a>
<a name="ln53">/*      else if (tag == &quot;pos&quot;) {</a>
<a name="ln54">            setOffset(QPointF());</a>
<a name="ln55">            e.readNext();</a>
<a name="ln56">            }</a>
<a name="ln57">      */</a>
<a name="ln58">      else if (!SpannerSegment::readProperties(e)) {</a>
<a name="ln59">            e.unknown();</a>
<a name="ln60">            return false;</a>
<a name="ln61">            }</a>
<a name="ln62">      return true;</a>
<a name="ln63">      }</a>
<a name="ln64"> </a>
<a name="ln65">//---------------------------------------------------------</a>
<a name="ln66">//   read</a>
<a name="ln67">//---------------------------------------------------------</a>
<a name="ln68"> </a>
<a name="ln69">void LineSegment::read(XmlReader&amp; e)</a>
<a name="ln70">      {</a>
<a name="ln71">      while (e.readNextStartElement())</a>
<a name="ln72">            readProperties(e);</a>
<a name="ln73">      }</a>
<a name="ln74"> </a>
<a name="ln75">//---------------------------------------------------------</a>
<a name="ln76">//   gripsPositions</a>
<a name="ln77">//---------------------------------------------------------</a>
<a name="ln78"> </a>
<a name="ln79">std::vector&lt;QPointF&gt; LineSegment::gripsPositions(const EditData&amp;) const</a>
<a name="ln80">      {</a>
<a name="ln81">      std::vector&lt;QPointF&gt; grips(gripsCount());</a>
<a name="ln82">      QPointF pp(pagePos());</a>
<a name="ln83">      grips[int(Grip::START)] = pp;</a>
<a name="ln84">      grips[int(Grip::END)] = pos2() + pp;</a>
<a name="ln85">      grips[int(Grip::MIDDLE)] = pos2() * .5 + pp;</a>
<a name="ln86">      return grips;</a>
<a name="ln87">      }</a>
<a name="ln88"> </a>
<a name="ln89">//---------------------------------------------------------</a>
<a name="ln90">//   gripAnchor</a>
<a name="ln91">//    return page coordinates</a>
<a name="ln92">//---------------------------------------------------------</a>
<a name="ln93"> </a>
<a name="ln94">QPointF LineSegment::gripAnchor(Grip grip) const</a>
<a name="ln95">      {</a>
<a name="ln96">      // Middle or aperture grip have no anchor</a>
<a name="ln97">      if (!system() || grip == Grip::MIDDLE || grip == Grip::APERTURE)</a>
<a name="ln98">            return QPointF(0, 0);</a>
<a name="ln99">      // note-anchored spanners are relative to the system</a>
<a name="ln100">      qreal y = spanner()-&gt;anchor() == Spanner::Anchor::NOTE ?</a>
<a name="ln101">                  system()-&gt;pos().y() : system()-&gt;staffYpage(staffIdx());</a>
<a name="ln102">      if (isMiddleType()) {</a>
<a name="ln103">            qreal x;</a>
<a name="ln104">            switch (grip) {</a>
<a name="ln105">                  case Grip::START:</a>
<a name="ln106">                        x = system()-&gt;firstMeasure()-&gt;abbox().left();</a>
<a name="ln107">                        break;</a>
<a name="ln108">                  case Grip::END:</a>
<a name="ln109">                        x = system()-&gt;lastMeasure()-&gt;abbox().right();</a>
<a name="ln110">                        break;</a>
<a name="ln111">                  default:</a>
<a name="ln112">                        x = 0; // No Anchor</a>
<a name="ln113">                        y = 0;</a>
<a name="ln114">                        break;</a>
<a name="ln115">                  }</a>
<a name="ln116">            return QPointF(x, y);</a>
<a name="ln117">            }</a>
<a name="ln118">      else {</a>
<a name="ln119">            if ((grip == Grip::END &amp;&amp; isBeginType()) || (grip == Grip::START &amp;&amp; isEndType()))</a>
<a name="ln120">                  return QPointF(0, 0);</a>
<a name="ln121">            else {</a>
<a name="ln122">                  System* s;</a>
<a name="ln123">                  QPointF p(line()-&gt;linePos(grip, &amp;s));</a>
<a name="ln124">                  p.ry() += y - system()-&gt;pos().y();</a>
<a name="ln125">                  if (s)</a>
<a name="ln126">                        p += s-&gt;pos();    // to page coordinates</a>
<a name="ln127">                  return p;</a>
<a name="ln128">                  }</a>
<a name="ln129">            }</a>
<a name="ln130">      }</a>
<a name="ln131"> </a>
<a name="ln132">//---------------------------------------------------------</a>
<a name="ln133">//   startEditDrag</a>
<a name="ln134">//---------------------------------------------------------</a>
<a name="ln135"> </a>
<a name="ln136">void LineSegment::startEditDrag(EditData&amp; ed)</a>
<a name="ln137">      {</a>
<a name="ln138">      ElementEditData* eed = ed.getData(this);</a>
<a name="ln139">      eed-&gt;pushProperty(Pid::OFFSET);</a>
<a name="ln140">      eed-&gt;pushProperty(Pid::OFFSET2);</a>
<a name="ln141">      eed-&gt;pushProperty(Pid::AUTOPLACE);</a>
<a name="ln142">      if (ed.modifiers &amp; Qt::AltModifier)</a>
<a name="ln143">            setAutoplace(false);</a>
<a name="ln144">      }</a>
<a name="ln145"> </a>
<a name="ln146">//---------------------------------------------------------</a>
<a name="ln147">//   edit</a>
<a name="ln148">//    return true if event is accepted</a>
<a name="ln149">//---------------------------------------------------------</a>
<a name="ln150"> </a>
<a name="ln151">bool LineSegment::edit(EditData&amp; ed)</a>
<a name="ln152">      {</a>
<a name="ln153">      if (!((ed.modifiers &amp; Qt::ShiftModifier) &amp;&amp; (isSingleType() || (isBeginType() &amp;&amp; ed.curGrip == Grip::START)</a>
<a name="ln154">         || (isEndType() &amp;&amp; ed.curGrip == Grip::END))))</a>
<a name="ln155">            return false;</a>
<a name="ln156"> </a>
<a name="ln157">      LineSegment* ls       = 0;</a>
<a name="ln158">      SpannerSegmentType st = spannerSegmentType(); // may change later</a>
<a name="ln159">      SLine* l              = line();</a>
<a name="ln160">      int track             = l-&gt;track();</a>
<a name="ln161">      int track2            = l-&gt;track2();    // assumed to be same as track</a>
<a name="ln162"> </a>
<a name="ln163">      switch (l-&gt;anchor()) {</a>
<a name="ln164">            case Spanner::Anchor::SEGMENT:</a>
<a name="ln165">                  {</a>
<a name="ln166">                  Segment* s1 = spanner()-&gt;startSegment();</a>
<a name="ln167">                  Segment* s2 = spanner()-&gt;endSegment();</a>
<a name="ln168">                  // check for line going to end of score</a>
<a name="ln169">                  if (spanner()-&gt;tick2() &gt;= score()-&gt;lastSegment()-&gt;tick()) {</a>
<a name="ln170">                        // endSegment calculated above will be the last chord/rest of score</a>
<a name="ln171">                        // but that is not correct - it should be an imaginary note *after* the end of the score</a>
<a name="ln172">                        // best we can do is set s2 to lastSegment (probably the end barline)</a>
<a name="ln173">                        s2 = score()-&gt;lastSegment();</a>
<a name="ln174">                        }</a>
<a name="ln175">                  if (!s1 &amp;&amp; !s2) {</a>
<a name="ln176">                        qDebug(&quot;LineSegment::edit: no start/end segment&quot;);</a>
<a name="ln177">                        return true;</a>
<a name="ln178">                        }</a>
<a name="ln179">                  if (ed.key == Qt::Key_Left) {</a>
<a name="ln180">                        if (ed.curGrip == Grip::START)</a>
<a name="ln181">                              s1 = prevSeg1(s1, track);</a>
<a name="ln182">                        else if (ed.curGrip == Grip::END || ed.curGrip == Grip::MIDDLE)</a>
<a name="ln183">                              s2 = prevSeg1(s2, track2);</a>
<a name="ln184">                        }</a>
<a name="ln185">                  else if (ed.key == Qt::Key_Right) {</a>
<a name="ln186">                        if (ed.curGrip == Grip::START)</a>
<a name="ln187">                              s1 = nextSeg1(s1, track);</a>
<a name="ln188">                        else if (ed.curGrip == Grip::END || ed.curGrip == Grip::MIDDLE) {</a>
<a name="ln189">                              Segment* ns2 = nextSeg1(s2, track2);</a>
<a name="ln190">                              if (ns2)</a>
<a name="ln191">                                    s2 = ns2;</a>
<a name="ln192">                              else</a>
<a name="ln193">                                    s2 = score()-&gt;lastSegment();</a>
<a name="ln194">                              }</a>
<a name="ln195">                        }</a>
<a name="ln196">                  if (s1 == 0 || s2 == 0 || s1-&gt;tick() &gt;= s2-&gt;tick())</a>
<a name="ln197">                        return true;</a>
<a name="ln198">                  spanner()-&gt;undoChangeProperty(Pid::SPANNER_TICK, s1-&gt;tick());</a>
<a name="ln199">                  spanner()-&gt;undoChangeProperty(Pid::SPANNER_TICKS, s2-&gt;tick() - s1-&gt;tick());</a>
<a name="ln200">                  }</a>
<a name="ln201">                  break;</a>
<a name="ln202">            case Spanner::Anchor::NOTE:</a>
<a name="ln203">                  {</a>
<a name="ln204">                  Note* note1       = toNote(l-&gt;startElement());</a>
<a name="ln205">                  Note* note2       = toNote(l-&gt;endElement());</a>
<a name="ln206">                  Note* oldNote1    = note1;</a>
<a name="ln207">                  Note* oldNote2    = note2;</a>
<a name="ln208">                  if (!note1 &amp;&amp; !note2) {</a>
<a name="ln209">                        qDebug(&quot;LineSegment::edit: no start/end note&quot;);</a>
<a name="ln210">                        return true;            // accept the event without doing anything</a>
<a name="ln211">                        }</a>
<a name="ln212"> </a>
<a name="ln213">                  switch (ed.key) {</a>
<a name="ln214">                        case Qt::Key_Left:</a>
<a name="ln215">                              if (ed.curGrip == Grip::START)</a>
<a name="ln216">                                    note1 = prevChordNote(note1);</a>
<a name="ln217">                              else if (ed.curGrip == Grip::END || ed.curGrip == Grip::MIDDLE)</a>
<a name="ln218">                                    note2 = prevChordNote(note2);</a>
<a name="ln219">                              break;</a>
<a name="ln220">                        case Qt::Key_Right:</a>
<a name="ln221">                              if (ed.curGrip == Grip::START)</a>
<a name="ln222">                                    note1 = nextChordNote(note1);</a>
<a name="ln223">                              else if (ed.curGrip == Grip::END || ed.curGrip == Grip::MIDDLE)</a>
<a name="ln224">                                    note2 = nextChordNote(note2);</a>
<a name="ln225">                              break;</a>
<a name="ln226">                        case Qt::Key_Up:</a>
<a name="ln227">                              if (ed.curGrip == Grip::START)</a>
<a name="ln228">                                    note1 = toNote(score()-&gt;upAlt(note1));</a>
<a name="ln229">                              else if (ed.curGrip == Grip::END || ed.curGrip == Grip::MIDDLE)</a>
<a name="ln230">                                    note2 = toNote(score()-&gt;upAlt(note2));</a>
<a name="ln231">                              break;</a>
<a name="ln232">                        case Qt::Key_Down:</a>
<a name="ln233">                              if (ed.curGrip == Grip::START)</a>
<a name="ln234">                                    note1 = toNote(score()-&gt;downAlt(note1));</a>
<a name="ln235">                              else if (ed.curGrip == Grip::END || ed.curGrip == Grip::MIDDLE)</a>
<a name="ln236">                                    note2 = toNote(score()-&gt;downAlt(note2));</a>
<a name="ln237">                              break;</a>
<a name="ln238">                        default:</a>
<a name="ln239">                              return true;</a>
<a name="ln240">                        }</a>
<a name="ln241"> </a>
<a name="ln242">                  // check prevChordNote() and nextchordNote() didn't return null</a>
<a name="ln243">                  // OR Score::upAlt() and Score::downAlt() didn't return non-Note (notably rests)</a>
<a name="ln244">                  // OR spanner duration is &gt; 0</a>
<a name="ln245">                  // OR note1 and note2 didn't end up in different instruments</a>
<a name="ln246">                  // if this is the case, accepts the event and return without doing nothing</a>
<a name="ln247">                  if (!note1 || !note2</a>
<a name="ln248">                     || !note1-&gt;isNote() || !note2-&gt;isNote()</a>
<a name="ln249">                     || note1-&gt;chord()-&gt;tick() &gt;= note2-&gt;chord()-&gt;tick()</a>
<a name="ln250">                     || note1-&gt;chord()-&gt;staff()-&gt;part()-&gt;instrument(note1-&gt;chord()-&gt;tick())</a>
<a name="ln251">                     != note2-&gt;chord()-&gt;staff()-&gt;part()-&gt;instrument(note2-&gt;chord()-&gt;tick()) )</a>
<a name="ln252">                        return true;</a>
<a name="ln253">                  if (note1 != oldNote1 || note2 != oldNote2)</a>
<a name="ln254">                        score()-&gt;undoChangeSpannerElements(spanner(), note1, note2);</a>
<a name="ln255">                  }</a>
<a name="ln256">                  break;</a>
<a name="ln257">            case Spanner::Anchor::MEASURE:</a>
<a name="ln258">            case Spanner::Anchor::CHORD:</a>
<a name="ln259">                  {</a>
<a name="ln260">                  Measure* m1 = l-&gt;startMeasure();</a>
<a name="ln261">                  Measure* m2 = l-&gt;endMeasure();</a>
<a name="ln262"> </a>
<a name="ln263">                  if (ed.key == Qt::Key_Left) {</a>
<a name="ln264">                        if (ed.curGrip == Grip::START) {</a>
<a name="ln265">                              if (m1-&gt;prevMeasure())</a>
<a name="ln266">                                    m1 = m1-&gt;prevMeasure();</a>
<a name="ln267">                              }</a>
<a name="ln268">                        else if (ed.curGrip == Grip::END || ed.curGrip == Grip::MIDDLE) {</a>
<a name="ln269">                              Measure* m = m2-&gt;prevMeasure();</a>
<a name="ln270">                              if (m)</a>
<a name="ln271">                                    m2 = m;</a>
<a name="ln272">                              }</a>
<a name="ln273">                        }</a>
<a name="ln274">                  else if (ed.key == Qt::Key_Right) {</a>
<a name="ln275">                        if (ed.curGrip == Grip::START) {</a>
<a name="ln276">                              if (m1-&gt;nextMeasure())</a>
<a name="ln277">                                    m1 = m1-&gt;nextMeasure();</a>
<a name="ln278">                              }</a>
<a name="ln279">                        else if (ed.curGrip == Grip::END || ed.curGrip == Grip::MIDDLE) {</a>
<a name="ln280">                              if (m2-&gt;nextMeasure())</a>
<a name="ln281">                                    m2 = m2-&gt;nextMeasure();</a>
<a name="ln282">                              }</a>
<a name="ln283">                        }</a>
<a name="ln284">                  if (m1-&gt;tick() &gt; m2-&gt;tick())</a>
<a name="ln285">                        return true;</a>
<a name="ln286">                  if (l-&gt;startElement() != m1) {</a>
<a name="ln287">                        spanner()-&gt;undoChangeProperty(Pid::SPANNER_TICK,  m1-&gt;tick());</a>
<a name="ln288">                        spanner()-&gt;undoChangeProperty(Pid::SPANNER_TICKS, m2-&gt;endTick() - m1-&gt;tick());</a>
<a name="ln289">                        }</a>
<a name="ln290">                  else if (l-&gt;endElement() != m2) {</a>
<a name="ln291">                        spanner()-&gt;undoChangeProperty(Pid::SPANNER_TICKS, m2-&gt;endTick() - m1-&gt;tick());</a>
<a name="ln292">                        }</a>
<a name="ln293">                  }</a>
<a name="ln294">            }</a>
<a name="ln295">      triggerLayout();</a>
<a name="ln296">      l-&gt;layout();            // recompute segment list, segment type may change</a>
<a name="ln297"> </a>
<a name="ln298">      LineSegment* nls = 0;</a>
<a name="ln299">      if (st == SpannerSegmentType::SINGLE) {</a>
<a name="ln300">            if (ed.curGrip == Grip::START)</a>
<a name="ln301">                  nls = l-&gt;frontSegment();</a>
<a name="ln302">            else if (ed.curGrip == Grip::END)</a>
<a name="ln303">                  nls = l-&gt;backSegment();</a>
<a name="ln304">            }</a>
<a name="ln305">      else if (st == SpannerSegmentType::BEGIN)</a>
<a name="ln306">            nls = l-&gt;frontSegment();</a>
<a name="ln307">      else if (st == SpannerSegmentType::END)</a>
<a name="ln308">            nls = l-&gt;backSegment();</a>
<a name="ln309">      else</a>
<a name="ln310">            qDebug(&quot;spannerSegmentType %d&quot;, int(spannerSegmentType()));</a>
<a name="ln311"> </a>
<a name="ln312">      if (nls &amp;&amp; (nls != this))</a>
<a name="ln313">            ed.view-&gt;changeEditElement(nls);</a>
<a name="ln314">      if (ls)</a>
<a name="ln315">            score()-&gt;undoRemoveElement(ls);</a>
<a name="ln316"> </a>
<a name="ln317">      triggerLayout();</a>
<a name="ln318">      return true;</a>
<a name="ln319">      }</a>
<a name="ln320"> </a>
<a name="ln321">//---------------------------------------------------------</a>
<a name="ln322">//   editDrag</a>
<a name="ln323">//---------------------------------------------------------</a>
<a name="ln324"> </a>
<a name="ln325">void LineSegment::editDrag(EditData&amp; ed)</a>
<a name="ln326">      {</a>
<a name="ln327">      // Only for resizing according to the diagonal properties</a>
<a name="ln328">      QPointF deltaResize(ed.delta.x(), line()-&gt;diagonal() ? ed.delta.y() : 0.0);</a>
<a name="ln329"> </a>
<a name="ln330">      switch (ed.curGrip) {</a>
<a name="ln331">            case Grip::START: // Resize the begin of element (left grip)</a>
<a name="ln332">                  setOffset(offset() + deltaResize);</a>
<a name="ln333">                  _offset2 -= deltaResize;</a>
<a name="ln334">                  if (isStyled(Pid::OFFSET))</a>
<a name="ln335">                        setPropertyFlags(Pid::OFFSET, PropertyFlags::UNSTYLED);</a>
<a name="ln336">                  break;</a>
<a name="ln337">            case Grip::END: // Resize the end of element (right grip)</a>
<a name="ln338">                  _offset2 += deltaResize;</a>
<a name="ln339">                  break;</a>
<a name="ln340">            case Grip::MIDDLE: { // Move the element (middle grip)</a>
<a name="ln341">                  // Only for moving, no y limitation</a>
<a name="ln342">                  QPointF deltaMove(ed.delta.x(), ed.delta.y());</a>
<a name="ln343">                  setOffset(offset() + deltaMove);</a>
<a name="ln344">                  setOffsetChanged(true);</a>
<a name="ln345">                  if (isStyled(Pid::OFFSET))</a>
<a name="ln346">                        setPropertyFlags(Pid::OFFSET, PropertyFlags::UNSTYLED);</a>
<a name="ln347">                  }</a>
<a name="ln348">                  break;</a>
<a name="ln349">            default:</a>
<a name="ln350">                  break;</a>
<a name="ln351">            }</a>
<a name="ln352">      if (line()-&gt;anchor() == Spanner::Anchor::NOTE &amp;&amp; ed.isStartEndGrip()) {</a>
<a name="ln353">            //</a>
<a name="ln354">            // if we touch a different note, change anchor</a>
<a name="ln355">            //</a>
<a name="ln356">            Element* e = ed.view-&gt;elementNear(ed.pos);</a>
<a name="ln357">            if (e &amp;&amp; e-&gt;isNote()) {</a>
<a name="ln358">                  SLine* l = line();</a>
<a name="ln359">                  if (ed.curGrip == Grip::END &amp;&amp; e != line()-&gt;endElement()) {</a>
<a name="ln360">                        qDebug(&quot;LineSegment: move end anchor&quot;);</a>
<a name="ln361">                        Note* noteOld = toNote(l-&gt;endElement());</a>
<a name="ln362">                        Note* noteNew = toNote(e);</a>
<a name="ln363">                        Note* sNote   = toNote(l-&gt;startElement());</a>
<a name="ln364">                        // do not change anchor if new note is before start note</a>
<a name="ln365">                        if (sNote &amp;&amp; sNote-&gt;chord() &amp;&amp; noteNew-&gt;chord() &amp;&amp; sNote-&gt;chord()-&gt;tick() &lt; noteNew-&gt;chord()-&gt;tick()) {</a>
<a name="ln366">                              score()-&gt;undoChangeSpannerElements(l, sNote, noteNew);</a>
<a name="ln367"> </a>
<a name="ln368">                              _offset2 += noteOld-&gt;canvasPos() - noteNew-&gt;canvasPos();</a>
<a name="ln369">                              }</a>
<a name="ln370">                        }</a>
<a name="ln371">                  else if (ed.curGrip == Grip::START &amp;&amp; e != l-&gt;startElement())</a>
<a name="ln372">                        qDebug(&quot;LineSegment: move start anchor (not impl.)&quot;);</a>
<a name="ln373">                  }</a>
<a name="ln374">            }</a>
<a name="ln375">      triggerLayout();</a>
<a name="ln376">      }</a>
<a name="ln377"> </a>
<a name="ln378">//---------------------------------------------------------</a>
<a name="ln379">//   spatiumChanged</a>
<a name="ln380">//---------------------------------------------------------</a>
<a name="ln381"> </a>
<a name="ln382">void LineSegment::spatiumChanged(qreal ov, qreal nv)</a>
<a name="ln383">      {</a>
<a name="ln384">      Element::spatiumChanged(ov, nv);</a>
<a name="ln385">      _offset2 *= nv / ov;</a>
<a name="ln386">      }</a>
<a name="ln387"> </a>
<a name="ln388">//---------------------------------------------------------</a>
<a name="ln389">//   localSpatiumChanged</a>
<a name="ln390">//---------------------------------------------------------</a>
<a name="ln391"> </a>
<a name="ln392">void LineSegment::localSpatiumChanged(qreal ov, qreal nv)</a>
<a name="ln393">      {</a>
<a name="ln394">      Element::localSpatiumChanged(ov, nv);</a>
<a name="ln395">      _offset2 *= nv / ov;</a>
<a name="ln396">      }</a>
<a name="ln397"> </a>
<a name="ln398">//---------------------------------------------------------</a>
<a name="ln399">//   propertyDelegate</a>
<a name="ln400">//---------------------------------------------------------</a>
<a name="ln401"> </a>
<a name="ln402">Element* LineSegment::propertyDelegate(Pid pid)</a>
<a name="ln403">      {</a>
<a name="ln404">      if (pid == Pid::DIAGONAL</a>
<a name="ln405">         || pid == Pid::COLOR</a>
<a name="ln406">         || pid ==   Pid::LINE_WIDTH</a>
<a name="ln407">         || pid ==   Pid::LINE_STYLE</a>
<a name="ln408">         || pid ==   Pid::DASH_LINE_LEN</a>
<a name="ln409">         || pid ==   Pid::DASH_GAP_LEN)</a>
<a name="ln410">            return spanner();</a>
<a name="ln411">      return SpannerSegment::propertyDelegate(pid);</a>
<a name="ln412">      }</a>
<a name="ln413"> </a>
<a name="ln414">//---------------------------------------------------------</a>
<a name="ln415">//   dragAnchor</a>
<a name="ln416">//---------------------------------------------------------</a>
<a name="ln417"> </a>
<a name="ln418">QLineF LineSegment::dragAnchor() const</a>
<a name="ln419">      {</a>
<a name="ln420">      if (spannerSegmentType() != SpannerSegmentType::SINGLE &amp;&amp; spannerSegmentType() != SpannerSegmentType::BEGIN)</a>
<a name="ln421">            return QLineF();</a>
<a name="ln422">      System* s;</a>
<a name="ln423">      QPointF p = line()-&gt;linePos(Grip::START, &amp;s);</a>
<a name="ln424">      p += QPointF(s-&gt;canvasPos().x(), s-&gt;staffCanvasYpage(line()-&gt;staffIdx()));</a>
<a name="ln425"> </a>
<a name="ln426">      return QLineF(p, canvasPos());</a>
<a name="ln427">      }</a>
<a name="ln428"> </a>
<a name="ln429">//---------------------------------------------------------</a>
<a name="ln430">//   SLine</a>
<a name="ln431">//---------------------------------------------------------</a>
<a name="ln432"> </a>
<a name="ln433">SLine::SLine(Score* s, ElementFlags f)</a>
<a name="ln434">   : Spanner(s, f)</a>
<a name="ln435">      {</a>
<a name="ln436">      setTrack(0);</a>
<a name="ln437">      _lineWidth = 0.15 * spatium();</a>
<a name="ln438">      }</a>
<a name="ln439"> </a>
<a name="ln440">SLine::SLine(const SLine&amp; s)</a>
<a name="ln441">   : Spanner(s)</a>
<a name="ln442">      {</a>
<a name="ln443">      _diagonal    = s._diagonal;</a>
<a name="ln444">      _lineWidth   = s._lineWidth;</a>
<a name="ln445">      _lineColor   = s._lineColor;</a>
<a name="ln446">      _lineStyle   = s._lineStyle;</a>
<a name="ln447">      _dashLineLen = s._dashLineLen;</a>
<a name="ln448">      _dashGapLen  = s._dashGapLen;</a>
<a name="ln449">      }</a>
<a name="ln450"> </a>
<a name="ln451">//---------------------------------------------------------</a>
<a name="ln452">//   linePos</a>
<a name="ln453">//    Anchor::NOTE: return anchor note position in system coordinates</a>
<a name="ln454">//    Other:        return (x position (relative to what?), 0)</a>
<a name="ln455">//---------------------------------------------------------</a>
<a name="ln456"> </a>
<a name="ln457">QPointF SLine::linePos(Grip grip, System** sys) const</a>
<a name="ln458">      {</a>
<a name="ln459">      qreal x = 0.0;</a>
<a name="ln460">      qreal sp = staff()-&gt;spatium(tick());</a>
<a name="ln461">      switch (anchor()) {</a>
<a name="ln462">            case Spanner::Anchor::SEGMENT:</a>
<a name="ln463">                  {</a>
<a name="ln464">                  ChordRest* cr;</a>
<a name="ln465">                  if (grip == Grip::START) {</a>
<a name="ln466">                        cr = toChordRest(startElement());</a>
<a name="ln467">                        if (cr &amp;&amp; type() == ElementType::OTTAVA) {</a>
<a name="ln468">                              // some sources say to center the text over the notehead</a>
<a name="ln469">                              // others say to start the text just to left of notehead</a>
<a name="ln470">                              // some say to include accidental, others don't</a>
<a name="ln471">                              // our compromise - left align, but account for accidental</a>
<a name="ln472">                              if (cr-&gt;durationType() == TDuration::DurationType::V_MEASURE &amp;&amp; !cr-&gt;measure()-&gt;hasVoices(cr-&gt;staffIdx()))</a>
<a name="ln473">                                    x = cr-&gt;x();            // center for measure rests</a>
<a name="ln474">//TODO                              else if (cr-&gt;spaceLw &gt; 0.0)</a>
<a name="ln475">//                                    x = -cr-&gt;spaceLw;  // account for accidentals, etc</a>
<a name="ln476">                              }</a>
<a name="ln477">                        }</a>
<a name="ln478">                  else {</a>
<a name="ln479">                        cr = toChordRest(endElement());</a>
<a name="ln480">                        if (isOttava()) {</a>
<a name="ln481">                              if (cr &amp;&amp; cr-&gt;durationType() == TDuration::DurationType::V_MEASURE) {</a>
<a name="ln482">                                    x = cr-&gt;x() + cr-&gt;width() + sp;</a>
<a name="ln483">                                    }</a>
<a name="ln484">                              else if (cr) {</a>
<a name="ln485">                                    // lay out just past right edge of all notes for this segment on this staff</a>
<a name="ln486"> </a>
<a name="ln487">                                    Segment* s = cr-&gt;segment();</a>
<a name="ln488"> </a>
<a name="ln489">                                    int startTrack = staffIdx() * VOICES;</a>
<a name="ln490">                                    int endTrack   = startTrack + VOICES;</a>
<a name="ln491">                                    qreal width    = 0.0;</a>
<a name="ln492"> </a>
<a name="ln493">                                    // don’t consider full measure rests, which are centered</a>
<a name="ln494">                                    // (TODO: what if there is only a full measure rest?)</a>
<a name="ln495"> </a>
<a name="ln496">                                    for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln497">                                          ChordRest* cr1 = toChordRest(s-&gt;element(track));</a>
<a name="ln498">                                          if (!cr1)</a>
<a name="ln499">                                                continue;</a>
<a name="ln500">                                          if (cr1-&gt;isChord()) {</a>
<a name="ln501">                                                for (Note* n : toChord(cr1)-&gt;notes())</a>
<a name="ln502">                                                      width = qMax(width, n-&gt;shape().right() + n-&gt;pos().x() + cr1-&gt;pos().x());</a>
<a name="ln503">                                                }</a>
<a name="ln504">                                          else if (cr1-&gt;isRest() &amp;&amp; (cr1-&gt;actualDurationType() != TDuration::DurationType::V_MEASURE))</a>
<a name="ln505">                                                width = qMax(width, cr1-&gt;bbox().right() + cr1-&gt;pos().x());</a>
<a name="ln506">                                          }</a>
<a name="ln507"> </a>
<a name="ln508">                                    x = width + sp;</a>
<a name="ln509"> </a>
<a name="ln510">                                    // extend past chord/rest</a>
<a name="ln511">                                    // but don't overlap next chord/rest</a>
<a name="ln512"> </a>
<a name="ln513">                                    bool crFound = false;</a>
<a name="ln514">                                    int n = staffIdx() * VOICES;</a>
<a name="ln515">                                    Segment* ns = s-&gt;next();</a>
<a name="ln516">                                    while (ns) {</a>
<a name="ln517">                                          for (int i = 0; i &lt; VOICES; ++i) {</a>
<a name="ln518">                                                if (ns-&gt;element(n + i)) {</a>
<a name="ln519">                                                      crFound = true;</a>
<a name="ln520">                                                      break;</a>
<a name="ln521">                                                      }</a>
<a name="ln522">                                                }</a>
<a name="ln523">                                          if (crFound)</a>
<a name="ln524">                                                break;</a>
<a name="ln525">                                          ns = ns-&gt;next();</a>
<a name="ln526">                                          }</a>
<a name="ln527">                                    if (crFound) {</a>
<a name="ln528">                                          qreal nextNoteDistance = ns-&gt;x() - s-&gt;x() + lineWidth();</a>
<a name="ln529">                                          if (x &gt; nextNoteDistance)</a>
<a name="ln530">                                                x = qMax(width, nextNoteDistance);</a>
<a name="ln531">                                          }</a>
<a name="ln532">                                    }</a>
<a name="ln533">                              }</a>
<a name="ln534">                        else if (isLyricsLine() &amp;&amp; toLyrics(parent())-&gt;ticks() &gt; Fraction(0,1)) {</a>
<a name="ln535">                              // melisma line</a>
<a name="ln536">                              // it is possible CR won't be in correct track</a>
<a name="ln537">                              // prefer element in current track if available</a>
<a name="ln538">                              if (!cr)</a>
<a name="ln539">                                    qDebug(&quot;no end for lyricsline segment - start %d, ticks %d&quot;, tick().ticks(), ticks().ticks());</a>
<a name="ln540">                              else if (cr-&gt;track() != track()) {</a>
<a name="ln541">                                    Element* e = cr-&gt;segment()-&gt;element(track());</a>
<a name="ln542">                                    if (e)</a>
<a name="ln543">                                          cr = toChordRest(e);</a>
<a name="ln544">                                    }</a>
<a name="ln545"> </a>
<a name="ln546">                              // layout to right edge of CR</a>
<a name="ln547">                              bool extendToEnd = true; // extend to end or start element?</a>
<a name="ln548">                              if (cr == toChordRest(startElement()))</a>
<a name="ln549">                                    extendToEnd = false;</a>
<a name="ln550">                              else if (cr) {</a>
<a name="ln551">                                    // if next segment is a chord with lyrics which spans to the left</a>
<a name="ln552">                                    // then do not extend to the right edge of end element.</a>
<a name="ln553">                                    Segment* seg = cr-&gt;segment();</a>
<a name="ln554">                                    seg = seg-&gt;next(SegmentType::ChordRest);</a>
<a name="ln555">                                    if (seg) {</a>
<a name="ln556">                                          ChordRest* cr2 = seg-&gt;cr(cr-&gt;track());</a>
<a name="ln557">                                          if (cr2 &amp;&amp; !cr2-&gt;lyrics().empty())</a>
<a name="ln558">                                                extendToEnd = false;</a>
<a name="ln559">                                          }</a>
<a name="ln560">                                    }</a>
<a name="ln561">                              ChordRest* right = extendToEnd ? cr : toChordRest(startElement());</a>
<a name="ln562">                              if (right) {</a>
<a name="ln563">                                    qreal maxRight = 0.0;</a>
<a name="ln564">                                    if (right-&gt;isChord()) {</a>
<a name="ln565">                                          // chord bbox() is unreliable, look at notes</a>
<a name="ln566">                                          // this also allows us to more easily ignore ledger lines</a>
<a name="ln567">                                          for (Note* n : toChord(right)-&gt;notes())</a>
<a name="ln568">                                                maxRight = qMax(maxRight, right-&gt;x() + n-&gt;x() + n-&gt;bboxRightPos());</a>
<a name="ln569">                                          }</a>
<a name="ln570">                                    else {</a>
<a name="ln571">                                          // rest - won't normally happen</a>
<a name="ln572">                                          maxRight = right-&gt;x() + right-&gt;width();</a>
<a name="ln573">                                          }</a>
<a name="ln574">                                    x = maxRight;</a>
<a name="ln575">                                    }</a>
<a name="ln576">                             }</a>
<a name="ln577">                        else if (isHairpin() || isTrill() || isVibrato() || isTextLine() || isLyricsLine()) {</a>
<a name="ln578">                              // (for LYRICSLINE, this is hyphen; melisma line is handled above)</a>
<a name="ln579">                              // lay out to just before next chordrest on this staff, or barline</a>
<a name="ln580">                              // tick2 actually tells us the right chordrest to look for</a>
<a name="ln581">                              if (cr &amp;&amp; endElement()-&gt;parent() &amp;&amp; endElement()-&gt;parent()-&gt;type() == ElementType::SEGMENT) {</a>
<a name="ln582">                                    qreal x2 = cr-&gt;x() /* TODO + cr-&gt;space().rw() */;</a>
<a name="ln583">                                    Segment* currentSeg = toSegment(endElement()-&gt;parent());</a>
<a name="ln584">                                    Segment* seg = score()-&gt;tick2segmentMM(tick2(), false, SegmentType::ChordRest);</a>
<a name="ln585">                                    if (!seg) {</a>
<a name="ln586">                                          // no end segment found, use measure width</a>
<a name="ln587">                                          x2 = endElement()-&gt;parent()-&gt;parent()-&gt;width() - sp;</a>
<a name="ln588">                                          }</a>
<a name="ln589">                                    else if (currentSeg-&gt;measure() == seg-&gt;measure()) {</a>
<a name="ln590">                                          // next chordrest found in same measure;</a>
<a name="ln591">                                          // end line 1sp to left</a>
<a name="ln592">                                          x2 = qMax(x2, seg-&gt;x() - sp);</a>
<a name="ln593">                                          }</a>
<a name="ln594">                                    else {</a>
<a name="ln595">                                          // next chordrest is in next measure</a>
<a name="ln596">                                          // lay out to end (barline) of current measure instead</a>
<a name="ln597">                                          seg = currentSeg-&gt;next(SegmentType::EndBarLine);</a>
<a name="ln598">                                          if (!seg)</a>
<a name="ln599">                                                seg = currentSeg-&gt;measure()-&gt;last();</a>
<a name="ln600">                                          // allow lyrics hyphen to extend to barline</a>
<a name="ln601">                                          // other lines stop 1sp short</a>
<a name="ln602">                                          qreal gap = (type() == ElementType::LYRICSLINE) ? 0.0 : sp;</a>
<a name="ln603">                                          qreal x3 = seg-&gt;enabled() ? seg-&gt;x() : seg-&gt;measure()-&gt;width();</a>
<a name="ln604">                                          x2 = qMax(x2, x3 - gap);</a>
<a name="ln605">                                          }</a>
<a name="ln606">                                    x = x2 - endElement()-&gt;parent()-&gt;x();</a>
<a name="ln607">                                    }</a>
<a name="ln608">                              }</a>
<a name="ln609">                        }</a>
<a name="ln610"> </a>
<a name="ln611">                  Fraction t = grip == Grip::START ? tick() : tick2();</a>
<a name="ln612">                  Measure* m = cr ? cr-&gt;measure() : score()-&gt;tick2measure(t);</a>
<a name="ln613"> </a>
<a name="ln614">                  if (m) {</a>
<a name="ln615">                        x += cr ? cr-&gt;segment()-&gt;pos().x() + m-&gt;pos().x() : m-&gt;tick2pos(t);</a>
<a name="ln616">                        *sys = m-&gt;system();</a>
<a name="ln617">                        }</a>
<a name="ln618">                  else</a>
<a name="ln619">                        *sys = 0;</a>
<a name="ln620">                  }</a>
<a name="ln621">                  break;</a>
<a name="ln622"> </a>
<a name="ln623">            case Spanner::Anchor::MEASURE:</a>
<a name="ln624">                  {</a>
<a name="ln625">                  // anchor() == Anchor::MEASURE</a>
<a name="ln626">                  const Measure* m;</a>
<a name="ln627">                  if (grip == Grip::START) {</a>
<a name="ln628">                        m = startMeasure();</a>
<a name="ln629">                        // start after clef/keysig/timesig/barline</a>
<a name="ln630">                        qreal offset = 0.0;</a>
<a name="ln631">                        Segment* s = m-&gt;first(SegmentType::ChordRest);</a>
<a name="ln632">                        if (s) {</a>
<a name="ln633">                              s = s-&gt;prev();</a>
<a name="ln634">                              if (s &amp;&amp; s-&gt;enabled()) {</a>
<a name="ln635">                                    offset = s-&gt;x();</a>
<a name="ln636">                                    Element* e = s-&gt;element(staffIdx() * VOICES);</a>
<a name="ln637">                                    if (e)</a>
<a name="ln638">                                          offset += e-&gt;width();</a>
<a name="ln639">                                    }</a>
<a name="ln640">                              }</a>
<a name="ln641">                        x = m-&gt;pos().x() + offset;</a>
<a name="ln642">                        if (score()-&gt;styleB(Sid::createMultiMeasureRests) &amp;&amp; m-&gt;hasMMRest()) {</a>
<a name="ln643">                              x = m-&gt;mmRest()-&gt;pos().x();</a>
<a name="ln644">                              }</a>
<a name="ln645">                        }</a>
<a name="ln646">                  else {</a>
<a name="ln647">                        qreal _spatium = spatium();</a>
<a name="ln648"> </a>
<a name="ln649">                        if (score()-&gt;styleB(Sid::createMultiMeasureRests)) {</a>
<a name="ln650">                              // find the actual measure where the volta should stop</a>
<a name="ln651">                              m = startMeasure();</a>
<a name="ln652">                              if (m-&gt;hasMMRest())</a>
<a name="ln653">                                    m = m-&gt;mmRest();</a>
<a name="ln654">                              while (m-&gt;nextMeasureMM() &amp;&amp; (m-&gt;endTick() &lt; tick2()))</a>
<a name="ln655">                                    m = m-&gt;nextMeasureMM();</a>
<a name="ln656">                              }</a>
<a name="ln657">                        else {</a>
<a name="ln658">                              m = endMeasure();</a>
<a name="ln659">                              }</a>
<a name="ln660"> </a>
<a name="ln661">                        // back up to barline (skip courtesy elements)</a>
<a name="ln662">                        Segment* seg = m-&gt;last();</a>
<a name="ln663">                        while (seg &amp;&amp; seg-&gt;segmentType() != SegmentType::EndBarLine)</a>
<a name="ln664">                              seg = seg-&gt;prev();</a>
<a name="ln665">                        if (!seg || !seg-&gt;enabled()) {</a>
<a name="ln666">                              // no end bar line; look for BeginBarLine or StartRepeatBarLine of next measure</a>
<a name="ln667">                              Measure* nm = m-&gt;nextMeasure();</a>
<a name="ln668">                              if (nm-&gt;system() == m-&gt;system())</a>
<a name="ln669">                                    seg = nm-&gt;first(SegmentType::BeginBarLine|SegmentType::StartRepeatBarLine);</a>
<a name="ln670">                              }</a>
<a name="ln671">                        qreal mwidth = seg &amp;&amp; seg-&gt;measure() == m ? seg-&gt;x() : m-&gt;bbox().right();</a>
<a name="ln672">                        x = m-&gt;pos().x() + mwidth;</a>
<a name="ln673">                        // align to barline</a>
<a name="ln674">                        if (seg &amp;&amp; (seg-&gt;segmentType() &amp; SegmentType::BarLineType)) {</a>
<a name="ln675">                              Element* e = seg-&gt;element(0);</a>
<a name="ln676">                              if (e &amp;&amp; e-&gt;type() == ElementType::BAR_LINE) {</a>
<a name="ln677">                                    BarLineType blt = toBarLine(e)-&gt;barLineType();</a>
<a name="ln678">                                    switch (blt) {</a>
<a name="ln679">                                          case BarLineType::END_REPEAT:</a>
<a name="ln680">                                                // skip dots</a>
<a name="ln681">                                                x += symWidth(SymId::repeatDot);</a>
<a name="ln682">                                                x += score()-&gt;styleS(Sid::endBarDistance).val() * _spatium;</a>
<a name="ln683">                                                // fall through</a>
<a name="ln684">                                          case BarLineType::DOUBLE:</a>
<a name="ln685">                                                // center on leftmost (thinner) barline</a>
<a name="ln686">                                                x += score()-&gt;styleS(Sid::doubleBarWidth).val() * _spatium * 0.5;</a>
<a name="ln687">                                                break;</a>
<a name="ln688">                                          case BarLineType::START_REPEAT:</a>
<a name="ln689">                                                // center on leftmost (thicker) barline</a>
<a name="ln690">                                                x += score()-&gt;styleS(Sid::endBarWidth).val() * _spatium * 0.5;</a>
<a name="ln691">                                                break;</a>
<a name="ln692">                                          default:</a>
<a name="ln693">                                                // center on barline</a>
<a name="ln694">                                                x += score()-&gt;styleS(Sid::barWidth).val() * _spatium * 0.5;</a>
<a name="ln695">                                                break;</a>
<a name="ln696">                                          }</a>
<a name="ln697">                                    }</a>
<a name="ln698">                              }</a>
<a name="ln699">                        }</a>
<a name="ln700">                  if (score()-&gt;styleB(Sid::createMultiMeasureRests))</a>
<a name="ln701">                        m = m-&gt;mmRest1();</a>
<a name="ln702">                  Q_ASSERT(m-&gt;system());</a>
<a name="ln703">                  *sys = m-&gt;system();</a>
<a name="ln704">                  }</a>
<a name="ln705">                  break;</a>
<a name="ln706"> </a>
<a name="ln707">            case Spanner::Anchor::NOTE: {</a>
<a name="ln708">                  Element* e = grip == Grip::START ? startElement() : endElement();</a>
<a name="ln709">                  if (!e)</a>
<a name="ln710">                        return QPointF();</a>
<a name="ln711">                  Note* n = toNote(e);</a>
<a name="ln712">                  System* s = n-&gt;chord()-&gt;segment()-&gt;system();</a>
<a name="ln713">                  if (s == 0) {</a>
<a name="ln714">                        qDebug(&quot;no system: %s  start %s chord parent %s\n&quot;, name(), n-&gt;name(), n-&gt;chord()-&gt;parent()-&gt;name());</a>
<a name="ln715">                        return QPointF();</a>
<a name="ln716">                        }</a>
<a name="ln717">                  *sys = s;</a>
<a name="ln718">                  // return the position of the anchor note relative to the system</a>
<a name="ln719">//                  QPointF     elemPagePos = e-&gt;pagePos();                   // DEBUG</a>
<a name="ln720">//                  QPointF     systPagePos = s-&gt;pagePos();</a>
<a name="ln721">//                  qreal       staffYPage  = s-&gt;staffYpage(e-&gt;staffIdx());</a>
<a name="ln722">                  QPointF p = n-&gt;pagePos() - s-&gt;pagePos();</a>
<a name="ln723">                  if (!isGlissando())</a>
<a name="ln724">                        p.rx() += n-&gt;headWidth() * 0.5;</a>
<a name="ln725">                  return p;</a>
<a name="ln726">                  }</a>
<a name="ln727"> </a>
<a name="ln728">            case Spanner::Anchor::CHORD:</a>
<a name="ln729">                  qFatal(&quot;Sline::linePos(): anchor not implemented&quot;);</a>
<a name="ln730">                  break;</a>
<a name="ln731">            }</a>
<a name="ln732">      return QPointF(x, 0.0);</a>
<a name="ln733">      }</a>
<a name="ln734"> </a>
<a name="ln735">//---------------------------------------------------------</a>
<a name="ln736">//   layoutSystem</a>
<a name="ln737">//    layout spannersegment for system</a>
<a name="ln738">//---------------------------------------------------------</a>
<a name="ln739"> </a>
<a name="ln740">SpannerSegment* SLine::layoutSystem(System* system)</a>
<a name="ln741">      {</a>
<a name="ln742">      Fraction stick = system-&gt;firstMeasure()-&gt;tick();</a>
<a name="ln743">      Fraction etick = system-&gt;lastMeasure()-&gt;endTick();</a>
<a name="ln744"> </a>
<a name="ln745">      LineSegment* lineSegm = toLineSegment(getNextLayoutSystemSegment(system, [this]() { return createLineSegment(); }));</a>
<a name="ln746"> </a>
<a name="ln747">      SpannerSegmentType sst;</a>
<a name="ln748">      if (tick() &gt;= stick) {</a>
<a name="ln749">            //</a>
<a name="ln750">            // this is the first call to layoutSystem,</a>
<a name="ln751">            // processing the first line segment</a>
<a name="ln752">            //</a>
<a name="ln753">            computeStartElement();</a>
<a name="ln754">            computeEndElement();</a>
<a name="ln755">            sst = tick2() &lt;= etick ? SpannerSegmentType::SINGLE : SpannerSegmentType::BEGIN;</a>
<a name="ln756">            }</a>
<a name="ln757">      else if (tick() &lt; stick &amp;&amp; tick2() &gt; etick) {</a>
<a name="ln758">            sst = SpannerSegmentType::MIDDLE;</a>
<a name="ln759">            }</a>
<a name="ln760">      else {</a>
<a name="ln761">            //</a>
<a name="ln762">            // this is the last call to layoutSystem</a>
<a name="ln763">            // processing the last line segment</a>
<a name="ln764">            //</a>
<a name="ln765">            sst = SpannerSegmentType::END;</a>
<a name="ln766">            }</a>
<a name="ln767">      lineSegm-&gt;setSpannerSegmentType(sst);</a>
<a name="ln768"> </a>
<a name="ln769">      switch (sst) {</a>
<a name="ln770">            case SpannerSegmentType::SINGLE: {</a>
<a name="ln771">                  System* s;</a>
<a name="ln772">                  QPointF p1 = linePos(Grip::START, &amp;s);</a>
<a name="ln773">                  QPointF p2 = linePos(Grip::END,   &amp;s);</a>
<a name="ln774">                  qreal len = p2.x() - p1.x();</a>
<a name="ln775">                  lineSegm-&gt;setPos(p1);</a>
<a name="ln776">                  lineSegm-&gt;setPos2(QPointF(len, p2.y() - p1.y()));</a>
<a name="ln777">                  }</a>
<a name="ln778">                  break;</a>
<a name="ln779">            case SpannerSegmentType::BEGIN: {</a>
<a name="ln780">                  System* s;</a>
<a name="ln781">                  QPointF p1 = linePos(Grip::START, &amp;s);</a>
<a name="ln782">                  lineSegm-&gt;setPos(p1);</a>
<a name="ln783">                  qreal x2 = system-&gt;bbox().right();</a>
<a name="ln784">                  lineSegm-&gt;setPos2(QPointF(x2 - p1.x(), 0.0));</a>
<a name="ln785">                  }</a>
<a name="ln786">                  break;</a>
<a name="ln787">            case SpannerSegmentType::MIDDLE: {</a>
<a name="ln788">                  Measure* firstMeasure = system-&gt;firstMeasure();</a>
<a name="ln789">                  Segment* firstCRSeg   = firstMeasure-&gt;first(SegmentType::ChordRest);</a>
<a name="ln790">                  qreal x1              = (firstCRSeg ? firstCRSeg-&gt;pos().x() : 0) + firstMeasure-&gt;pos().x();</a>
<a name="ln791">                  qreal x2              = system-&gt;bbox().right();</a>
<a name="ln792">                  System* s;</a>
<a name="ln793">                  QPointF p1 = linePos(Grip::START, &amp;s);</a>
<a name="ln794">                  lineSegm-&gt;setPos(QPointF(x1, p1.y()));</a>
<a name="ln795">                  lineSegm-&gt;setPos2(QPointF(x2 - x1, 0.0));</a>
<a name="ln796">                  }</a>
<a name="ln797">                  break;</a>
<a name="ln798">            case SpannerSegmentType::END: {</a>
<a name="ln799">                  qreal offset = 0.0;</a>
<a name="ln800">                  System* s;</a>
<a name="ln801">                  QPointF p2 = linePos(Grip::END,   &amp;s);</a>
<a name="ln802">                  Measure* firstMeas  = system-&gt;firstMeasure();</a>
<a name="ln803">                  Segment* firstCRSeg = firstMeas-&gt;first(SegmentType::ChordRest);</a>
<a name="ln804">                  if (anchor() == Anchor::SEGMENT || anchor() == Anchor::MEASURE) {</a>
<a name="ln805">                        // start line just after previous element (eg, key signature)</a>
<a name="ln806">                        firstCRSeg = firstCRSeg-&gt;prev();</a>
<a name="ln807">                        Element* e = firstCRSeg ? firstCRSeg-&gt;element(staffIdx() * VOICES) : nullptr;</a>
<a name="ln808">                        if (e)</a>
<a name="ln809">                              offset = e-&gt;width();</a>
<a name="ln810">                        }</a>
<a name="ln811">                  qreal x1  = (firstCRSeg ? firstCRSeg-&gt;pos().x() : 0) + firstMeas-&gt;pos().x() + offset;</a>
<a name="ln812">                  qreal len = p2.x() - x1;</a>
<a name="ln813">                  lineSegm-&gt;setPos(QPointF(p2.x() - len, p2.y()));</a>
<a name="ln814">                  lineSegm-&gt;setPos2(QPointF(len, 0.0));</a>
<a name="ln815">                  }</a>
<a name="ln816">                  break;</a>
<a name="ln817">            }</a>
<a name="ln818">      lineSegm-&gt;layout();</a>
<a name="ln819">      return lineSegm;</a>
<a name="ln820">      }</a>
<a name="ln821"> </a>
<a name="ln822">//---------------------------------------------------------</a>
<a name="ln823">//   layout</a>
<a name="ln824">//    compute segments from tick1 tick2</a>
<a name="ln825">//    (used for palette, edit mode, and layout of note lines and glissandi)</a>
<a name="ln826">//---------------------------------------------------------</a>
<a name="ln827"> </a>
<a name="ln828">void SLine::layout()</a>
<a name="ln829">      {</a>
<a name="ln830">      if (score() == gscore || (tick() == Fraction(-1,1)) || (tick2() == Fraction::fromTicks(1))) {</a>
<a name="ln831">            //</a>
<a name="ln832">            // when used in a palette or while dragging from palette,</a>
<a name="ln833">            // SLine has no parent and</a>
<a name="ln834">            // tick and tick2 has no meaning so no layout is</a>
<a name="ln835">            // possible and needed</a>
<a name="ln836">            //</a>
<a name="ln837">            setLen(gscore-&gt;spatium() * 7);</a>
<a name="ln838">            if (!spannerSegments().empty()) {</a>
<a name="ln839">                  LineSegment* lineSegm = frontSegment();</a>
<a name="ln840">                  lineSegm-&gt;layout();</a>
<a name="ln841">                  setbbox(lineSegm-&gt;bbox());</a>
<a name="ln842">                  }</a>
<a name="ln843">            return;</a>
<a name="ln844">            }</a>
<a name="ln845"> </a>
<a name="ln846">      computeStartElement();</a>
<a name="ln847">      computeEndElement();</a>
<a name="ln848"> </a>
<a name="ln849">      System* s1;</a>
<a name="ln850">      System* s2;</a>
<a name="ln851">      QPointF p1(linePos(Grip::START, &amp;s1));</a>
<a name="ln852">      QPointF p2(linePos(Grip::END,   &amp;s2));</a>
<a name="ln853"> </a>
<a name="ln854">      const QList&lt;System*&gt;&amp; systems = score()-&gt;systems();</a>
<a name="ln855">      int sysIdx1 = systems.indexOf(s1);</a>
<a name="ln856">      int sysIdx2 = systems.indexOf(s2);</a>
<a name="ln857">      int segmentsNeeded = 0;</a>
<a name="ln858"> </a>
<a name="ln859">      if (sysIdx1 == -1 || sysIdx2 == -1)</a>
<a name="ln860">            return;</a>
<a name="ln861"> </a>
<a name="ln862">      for (int i = sysIdx1; i &lt;= sysIdx2;  ++i) {</a>
<a name="ln863">            if (systems.at(i)-&gt;vbox())</a>
<a name="ln864">                  continue;</a>
<a name="ln865">            ++segmentsNeeded;</a>
<a name="ln866">            }</a>
<a name="ln867"> </a>
<a name="ln868">      int segCount = int(spannerSegments().size());</a>
<a name="ln869"> </a>
<a name="ln870">      if (segmentsNeeded != segCount) {</a>
<a name="ln871">            fixupSegments(segmentsNeeded, [this]() { return createLineSegment(); });</a>
<a name="ln872">            if (segmentsNeeded &gt; segCount) {</a>
<a name="ln873">                  for (int i = segCount; i &lt; segmentsNeeded; ++i) {</a>
<a name="ln874">                        LineSegment* lineSegm = segmentAt(i);</a>
<a name="ln875">                        // set user offset to previous segment's offset</a>
<a name="ln876">                        if (segCount &gt; 0)</a>
<a name="ln877">                              lineSegm-&gt;setOffset(QPointF(0, segmentAt(i-1)-&gt;offset().y()));</a>
<a name="ln878">                        else</a>
<a name="ln879">                              lineSegm-&gt;setOffset(QPointF(0, offset().y()));</a>
<a name="ln880">                        }</a>
<a name="ln881">                  }</a>
<a name="ln882">            }</a>
<a name="ln883"> </a>
<a name="ln884">      int segIdx = 0;</a>
<a name="ln885">      for (int i = sysIdx1; i &lt;= sysIdx2; ++i) {</a>
<a name="ln886">            System* system = systems.at(i);</a>
<a name="ln887">            if (system-&gt;vbox())</a>
<a name="ln888">                  continue;</a>
<a name="ln889">            LineSegment* lineSegm = segmentAt(segIdx++);</a>
<a name="ln890">            lineSegm-&gt;setTrack(track());       // DEBUG</a>
<a name="ln891">            lineSegm-&gt;setSystem(system);</a>
<a name="ln892"> </a>
<a name="ln893">            Measure* firstMeas = system-&gt;firstMeasure();</a>
<a name="ln894">            Segment* firstCRSeg = firstMeas-&gt;first(SegmentType::ChordRest);</a>
<a name="ln895"> </a>
<a name="ln896">            if (sysIdx1 == sysIdx2) {</a>
<a name="ln897">                  // single segment</a>
<a name="ln898">                  lineSegm-&gt;setSpannerSegmentType(SpannerSegmentType::SINGLE);</a>
<a name="ln899">                  qreal len = p2.x() - p1.x();</a>
<a name="ln900">                  // enforcing a minimum length would be possible but inadvisable</a>
<a name="ln901">                  // the line length calculations are tuned well enough that this should not be needed</a>
<a name="ln902">                  //if (anchor() == Anchor::SEGMENT &amp;&amp; type() != ElementType::PEDAL)</a>
<a name="ln903">                  //      len = qMax(1.0 * spatium(), len);</a>
<a name="ln904">                  lineSegm-&gt;setPos(p1);</a>
<a name="ln905">                  lineSegm-&gt;setPos2(QPointF(len, p2.y() - p1.y()));</a>
<a name="ln906">                  }</a>
<a name="ln907">            else if (i == sysIdx1) {</a>
<a name="ln908">                  // start segment</a>
<a name="ln909">                  lineSegm-&gt;setSpannerSegmentType(SpannerSegmentType::BEGIN);</a>
<a name="ln910">                  lineSegm-&gt;setPos(p1);</a>
<a name="ln911">                  qreal x2 = system-&gt;bbox().right();</a>
<a name="ln912">                  lineSegm-&gt;setPos2(QPointF(x2 - p1.x(), 0.0));</a>
<a name="ln913">                  }</a>
<a name="ln914">            else if (i &gt; 0 &amp;&amp; i != sysIdx2) {</a>
<a name="ln915">                  // middle segment</a>
<a name="ln916">                  lineSegm-&gt;setSpannerSegmentType(SpannerSegmentType::MIDDLE);</a>
<a name="ln917">                  qreal x1 = (firstCRSeg ? firstCRSeg-&gt;pos().x() : 0) + firstMeas-&gt;pos().x();</a>
<a name="ln918">                  qreal x2 = system-&gt;bbox().right();</a>
<a name="ln919">                  lineSegm-&gt;setPos(QPointF(x1, p1.y()));</a>
<a name="ln920">                  lineSegm-&gt;setPos2(QPointF(x2 - x1, 0.0));</a>
<a name="ln921">                  }</a>
<a name="ln922">            else if (i == sysIdx2) {</a>
<a name="ln923">                  // end segment</a>
<a name="ln924">                  qreal offset = 0.0;</a>
<a name="ln925">                  qreal minLen = 0.0;</a>
<a name="ln926">                  if (anchor() == Anchor::SEGMENT || anchor() == Anchor::MEASURE) {</a>
<a name="ln927">                        // start line just after previous element (eg, key signature)</a>
<a name="ln928">                        firstCRSeg = firstCRSeg-&gt;prev();</a>
<a name="ln929">                        Element* e = firstCRSeg ? firstCRSeg-&gt;element(staffIdx() * VOICES) : nullptr;</a>
<a name="ln930">                        if (e)</a>
<a name="ln931">                              offset = e-&gt;width();</a>
<a name="ln932">                        // enforcing a minimum length would be possible but inadvisable</a>
<a name="ln933">                        // the line length calculations are tuned well enough that this should not be needed</a>
<a name="ln934">                        //if (type() != ElementType::PEDAL)</a>
<a name="ln935">                        //      minLen = 1.0 * spatium();</a>
<a name="ln936">                        }</a>
<a name="ln937">                  qreal x1 = (firstCRSeg ? firstCRSeg-&gt;pos().x() : 0) + firstMeas-&gt;pos().x() + offset;</a>
<a name="ln938">                  qreal len = qMax(minLen, p2.x() - x1);</a>
<a name="ln939">                  lineSegm-&gt;setSpannerSegmentType(SpannerSegmentType::END);</a>
<a name="ln940">                  lineSegm-&gt;setPos(QPointF(p2.x() - len, p2.y()));</a>
<a name="ln941">                  lineSegm-&gt;setPos2(QPointF(len, 0.0));</a>
<a name="ln942">                  }</a>
<a name="ln943">            lineSegm-&gt;layout();</a>
<a name="ln944">            }</a>
<a name="ln945">      }</a>
<a name="ln946"> </a>
<a name="ln947">//---------------------------------------------------------</a>
<a name="ln948">//   writeProperties</a>
<a name="ln949">//    write properties different from prototype</a>
<a name="ln950">//---------------------------------------------------------</a>
<a name="ln951"> </a>
<a name="ln952">void SLine::writeProperties(XmlWriter&amp; xml) const</a>
<a name="ln953">      {</a>
<a name="ln954">      if (!endElement()) {</a>
<a name="ln955">            ((Spanner*)this)-&gt;computeEndElement();                // HACK</a>
<a name="ln956">            if (!endElement())</a>
<a name="ln957">                  xml.tag(&quot;ticks&quot;, ticks());</a>
<a name="ln958">            }</a>
<a name="ln959">      Spanner::writeProperties(xml);</a>
<a name="ln960">      if (_diagonal)</a>
<a name="ln961">            xml.tag(&quot;diagonal&quot;, _diagonal);</a>
<a name="ln962">      writeProperty(xml, Pid::LINE_WIDTH);</a>
<a name="ln963">      writeProperty(xml, Pid::LINE_STYLE);</a>
<a name="ln964">      writeProperty(xml, Pid::COLOR);</a>
<a name="ln965">      writeProperty(xml, Pid::ANCHOR);</a>
<a name="ln966">      writeProperty(xml, Pid::DASH_LINE_LEN);</a>
<a name="ln967">      writeProperty(xml, Pid::DASH_GAP_LEN);</a>
<a name="ln968">      if (score() == gscore) {</a>
<a name="ln969">            // when used as icon</a>
<a name="ln970">            if (!spannerSegments().empty()) {</a>
<a name="ln971">                  const LineSegment* s = frontSegment();</a>
<a name="ln972">                  xml.tag(&quot;length&quot;, s-&gt;pos2().x());</a>
<a name="ln973">                  }</a>
<a name="ln974">            else</a>
<a name="ln975">                  xml.tag(&quot;length&quot;, spatium() * 4);</a>
<a name="ln976">            return;</a>
<a name="ln977">            }</a>
<a name="ln978">      //</a>
<a name="ln979">      // check if user has modified the default layout</a>
<a name="ln980">      //</a>
<a name="ln981">      bool modified = false;</a>
<a name="ln982">      for (const SpannerSegment* seg : spannerSegments()) {</a>
<a name="ln983">            if (!seg-&gt;autoplace() || !seg-&gt;visible() ||</a>
<a name="ln984">               (seg-&gt;propertyFlags(Pid::MIN_DISTANCE) == PropertyFlags::UNSTYLED || seg-&gt;getProperty(Pid::MIN_DISTANCE) != seg-&gt;propertyDefault(Pid::MIN_DISTANCE)) ||</a>
<a name="ln985">               (!seg-&gt;isStyled(Pid::OFFSET) &amp;&amp; (!seg-&gt;offset().isNull() || !seg-&gt;userOff2().isNull()))) {</a>
<a name="ln986">                  modified = true;</a>
<a name="ln987">                  break;</a>
<a name="ln988">                  }</a>
<a name="ln989">            }</a>
<a name="ln990">      if (!modified)</a>
<a name="ln991">            return;</a>
<a name="ln992"> </a>
<a name="ln993">      //</a>
<a name="ln994">      // write user modified layout and other segment properties</a>
<a name="ln995">      //</a>
<a name="ln996">      qreal _spatium = score()-&gt;spatium();</a>
<a name="ln997">      for (const SpannerSegment* seg : spannerSegments()) {</a>
<a name="ln998">            xml.stag(&quot;Segment&quot;, seg);</a>
<a name="ln999">            xml.tag(&quot;subtype&quot;, int(seg-&gt;spannerSegmentType()));</a>
<a name="ln1000">            // TODO:</a>
<a name="ln1001">            // NOSTYLE offset written in Element::writeProperties,</a>
<a name="ln1002">            // so we probably don't need to duplicate it here</a>
<a name="ln1003">            // see https://musescore.org/en/node/286848</a>
<a name="ln1004">            //if (seg-&gt;propertyFlags(Pid::OFFSET) &amp; PropertyFlags::UNSTYLED)</a>
<a name="ln1005">            xml.tag(&quot;offset&quot;, seg-&gt;offset() / _spatium);</a>
<a name="ln1006">            xml.tag(&quot;off2&quot;, seg-&gt;userOff2() / _spatium);</a>
<a name="ln1007">            seg-&gt;writeProperty(xml, Pid::MIN_DISTANCE);</a>
<a name="ln1008">            seg-&gt;Element::writeProperties(xml);</a>
<a name="ln1009">            xml.etag();</a>
<a name="ln1010">            }</a>
<a name="ln1011">      }</a>
<a name="ln1012"> </a>
<a name="ln1013">//---------------------------------------------------------</a>
<a name="ln1014">//   readProperties</a>
<a name="ln1015">//---------------------------------------------------------</a>
<a name="ln1016"> </a>
<a name="ln1017">bool SLine::readProperties(XmlReader&amp; e)</a>
<a name="ln1018">      {</a>
<a name="ln1019">      const QStringRef&amp; tag(e.name());</a>
<a name="ln1020"> </a>
<a name="ln1021">      if (tag == &quot;tick2&quot;) {                // obsolete</a>
<a name="ln1022">            if (tick() == Fraction(-1,1)) // not necessarily set (for first note of score?) #30151</a>
<a name="ln1023">                  setTick(e.tick());</a>
<a name="ln1024">            setTick2(Fraction::fromTicks(e.readInt()));</a>
<a name="ln1025">            }</a>
<a name="ln1026">      else if (tag == &quot;tick&quot;)             // obsolete</a>
<a name="ln1027">            setTick(Fraction::fromTicks(e.readInt()));</a>
<a name="ln1028">      else if (tag == &quot;ticks&quot;)</a>
<a name="ln1029">            setTicks(Fraction::fromTicks(e.readInt()));</a>
<a name="ln1030">      else if (tag == &quot;Segment&quot;) {</a>
<a name="ln1031">            LineSegment* ls = createLineSegment();</a>
<a name="ln1032">            ls-&gt;setTrack(track()); // needed in read to get the right staff mag</a>
<a name="ln1033">            ls-&gt;read(e);</a>
<a name="ln1034">            add(ls);</a>
<a name="ln1035">            ls-&gt;setVisible(visible());</a>
<a name="ln1036">            }</a>
<a name="ln1037">      else if (tag == &quot;length&quot;)</a>
<a name="ln1038">            setLen(e.readDouble());</a>
<a name="ln1039">      else if (tag == &quot;diagonal&quot;)</a>
<a name="ln1040">            setDiagonal(e.readInt());</a>
<a name="ln1041">      else if (tag == &quot;anchor&quot;)</a>
<a name="ln1042">            setAnchor(Anchor(e.readInt()));</a>
<a name="ln1043">      else if (tag == &quot;lineWidth&quot;)</a>
<a name="ln1044">            _lineWidth = e.readDouble() * spatium();</a>
<a name="ln1045">      else if (tag == &quot;lineStyle&quot;)</a>
<a name="ln1046">            _lineStyle = Qt::PenStyle(e.readInt());</a>
<a name="ln1047">      else if (tag == &quot;dashLineLength&quot;)</a>
<a name="ln1048">            _dashLineLen = e.readDouble();</a>
<a name="ln1049">      else if (tag == &quot;dashGapLength&quot;)</a>
<a name="ln1050">            _dashGapLen = e.readDouble();</a>
<a name="ln1051">      else if (tag == &quot;lineColor&quot;)</a>
<a name="ln1052">            _lineColor = e.readColor();</a>
<a name="ln1053">      else if (tag == &quot;color&quot;)</a>
<a name="ln1054">            _lineColor = e.readColor();</a>
<a name="ln1055">      else if (!Spanner::readProperties(e))</a>
<a name="ln1056">            return false;</a>
<a name="ln1057">      return true;</a>
<a name="ln1058">      }</a>
<a name="ln1059"> </a>
<a name="ln1060">//---------------------------------------------------------</a>
<a name="ln1061">//   setLen</a>
<a name="ln1062">//    used to create an element suitable for palette</a>
<a name="ln1063">//---------------------------------------------------------</a>
<a name="ln1064"> </a>
<a name="ln1065">void SLine::setLen(qreal l)</a>
<a name="ln1066">      {</a>
<a name="ln1067">      if (spannerSegments().empty())</a>
<a name="ln1068">            add(createLineSegment());</a>
<a name="ln1069">      LineSegment* s = frontSegment();</a>
<a name="ln1070">      s-&gt;setPos(QPointF());</a>
<a name="ln1071">      s-&gt;setPos2(QPointF(l, 0));</a>
<a name="ln1072">      }</a>
<a name="ln1073"> </a>
<a name="ln1074">//---------------------------------------------------------</a>
<a name="ln1075">//   bbox</a>
<a name="ln1076">//    used by palette: only one segment</a>
<a name="ln1077">//---------------------------------------------------------</a>
<a name="ln1078"> </a>
<a name="ln1079">const QRectF&amp; SLine::bbox() const</a>
<a name="ln1080">      {</a>
<a name="ln1081">      if (spannerSegments().empty())</a>
<a name="ln1082">            setbbox(QRectF());</a>
<a name="ln1083">      else</a>
<a name="ln1084">            setbbox(segmentAt(0)-&gt;bbox());</a>
<a name="ln1085">      return Element::bbox();</a>
<a name="ln1086">      }</a>
<a name="ln1087"> </a>
<a name="ln1088">//---------------------------------------------------------</a>
<a name="ln1089">//   write</a>
<a name="ln1090">//---------------------------------------------------------</a>
<a name="ln1091"> </a>
<a name="ln1092">void SLine::write(XmlWriter&amp; xml) const</a>
<a name="ln1093">      {</a>
<a name="ln1094">      xml.stag(this);</a>
<a name="ln1095">      SLine::writeProperties(xml);</a>
<a name="ln1096">      xml.etag();</a>
<a name="ln1097">      }</a>
<a name="ln1098"> </a>
<a name="ln1099">//---------------------------------------------------------</a>
<a name="ln1100">//   read</a>
<a name="ln1101">//---------------------------------------------------------</a>
<a name="ln1102"> </a>
<a name="ln1103">void SLine::read(XmlReader&amp; e)</a>
<a name="ln1104">      {</a>
<a name="ln1105">      eraseSpannerSegments();</a>
<a name="ln1106"> </a>
<a name="ln1107">      if (score()-&gt;mscVersion() &lt; 301)</a>
<a name="ln1108">            e.addSpanner(e.intAttribute(&quot;id&quot;, -1), this);</a>
<a name="ln1109"> </a>
<a name="ln1110">      while (e.readNextStartElement()) {</a>
<a name="ln1111">            if (!SLine::readProperties(e))</a>
<a name="ln1112">                  e.unknown();</a>
<a name="ln1113">            }</a>
<a name="ln1114">      }</a>
<a name="ln1115"> </a>
<a name="ln1116">//---------------------------------------------------------</a>
<a name="ln1117">//   getProperty</a>
<a name="ln1118">//---------------------------------------------------------</a>
<a name="ln1119"> </a>
<a name="ln1120">QVariant SLine::getProperty(Pid id) const</a>
<a name="ln1121">      {</a>
<a name="ln1122">      switch (id) {</a>
<a name="ln1123">            case Pid::DIAGONAL:</a>
<a name="ln1124">                  return _diagonal;</a>
<a name="ln1125">            case Pid::COLOR:</a>
<a name="ln1126">                  return _lineColor;</a>
<a name="ln1127">            case Pid::LINE_WIDTH:</a>
<a name="ln1128">                  return _lineWidth;</a>
<a name="ln1129">            case Pid::LINE_STYLE:</a>
<a name="ln1130">                  return QVariant(int(_lineStyle));</a>
<a name="ln1131">            case Pid::DASH_LINE_LEN:</a>
<a name="ln1132">                  return dashLineLen();</a>
<a name="ln1133">            case Pid::DASH_GAP_LEN:</a>
<a name="ln1134">                  return dashGapLen();</a>
<a name="ln1135">            default:</a>
<a name="ln1136">                  return Spanner::getProperty(id);</a>
<a name="ln1137">            }</a>
<a name="ln1138">      }</a>
<a name="ln1139"> </a>
<a name="ln1140">//---------------------------------------------------------</a>
<a name="ln1141">//   setProperty</a>
<a name="ln1142">//---------------------------------------------------------</a>
<a name="ln1143"> </a>
<a name="ln1144">bool SLine::setProperty(Pid id, const QVariant&amp; v)</a>
<a name="ln1145">      {</a>
<a name="ln1146">      switch (id) {</a>
<a name="ln1147">            case Pid::DIAGONAL:</a>
<a name="ln1148">                  _diagonal = v.toBool();</a>
<a name="ln1149">                  break;</a>
<a name="ln1150">            case Pid::COLOR:</a>
<a name="ln1151">                  _lineColor = v.value&lt;QColor&gt;();</a>
<a name="ln1152">                  break;</a>
<a name="ln1153">            case Pid::LINE_WIDTH:</a>
<a name="ln1154">                  _lineWidth = v.toReal();</a>
<a name="ln1155">                  break;</a>
<a name="ln1156">            case Pid::LINE_STYLE:</a>
<a name="ln1157">                  _lineStyle = Qt::PenStyle(v.toInt());</a>
<a name="ln1158">                  break;</a>
<a name="ln1159">            case Pid::DASH_LINE_LEN:</a>
<a name="ln1160">                  setDashLineLen(v.toDouble());</a>
<a name="ln1161">                  break;</a>
<a name="ln1162">            case Pid::DASH_GAP_LEN:</a>
<a name="ln1163">                  setDashGapLen(v.toDouble());</a>
<a name="ln1164">                  break;</a>
<a name="ln1165">            default:</a>
<a name="ln1166">                  return Spanner::setProperty(id, v);</a>
<a name="ln1167">            }</a>
<a name="ln1168">      triggerLayout();</a>
<a name="ln1169">      return true;</a>
<a name="ln1170">      }</a>
<a name="ln1171"> </a>
<a name="ln1172">//---------------------------------------------------------</a>
<a name="ln1173">//   propertyDefault</a>
<a name="ln1174">//---------------------------------------------------------</a>
<a name="ln1175"> </a>
<a name="ln1176">QVariant SLine::propertyDefault(Pid pid) const</a>
<a name="ln1177">      {</a>
<a name="ln1178">      switch (pid) {</a>
<a name="ln1179">            case Pid::DIAGONAL:</a>
<a name="ln1180">                  return false;</a>
<a name="ln1181">            case Pid::COLOR:</a>
<a name="ln1182">                  return MScore::defaultColor;</a>
<a name="ln1183">            case Pid::LINE_WIDTH:</a>
<a name="ln1184">                  if (propertyFlags(pid) != PropertyFlags::NOSTYLE)</a>
<a name="ln1185">                        return Spanner::propertyDefault(pid);</a>
<a name="ln1186">                  return 0.15 * spatium();</a>
<a name="ln1187">            case Pid::LINE_STYLE:</a>
<a name="ln1188">                  if (propertyFlags(pid) != PropertyFlags::NOSTYLE)</a>
<a name="ln1189">                        return Spanner::propertyDefault(pid);</a>
<a name="ln1190">                  return int(Qt::SolidLine);</a>
<a name="ln1191">            case Pid::DASH_LINE_LEN:</a>
<a name="ln1192">            case Pid::DASH_GAP_LEN:</a>
<a name="ln1193">                  if (propertyFlags(pid) != PropertyFlags::NOSTYLE)</a>
<a name="ln1194">                        return Spanner::propertyDefault(pid);</a>
<a name="ln1195">                  return 5.0;</a>
<a name="ln1196">            default:</a>
<a name="ln1197">                  return Spanner::propertyDefault(pid);</a>
<a name="ln1198">            }</a>
<a name="ln1199">      }</a>
<a name="ln1200"> </a>
<a name="ln1201">}</a>
<a name="ln1202"> </a>

</code></pre>
<div class="balloon" rel="314"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'ls' is always false.</p></div>
<div class="balloon" rel="956"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!endElement()' is always true.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
