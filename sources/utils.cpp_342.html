
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>utils.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;config.h&quot;</a>
<a name="ln14">#include &quot;score.h&quot;</a>
<a name="ln15">#include &quot;page.h&quot;</a>
<a name="ln16">#include &quot;segment.h&quot;</a>
<a name="ln17">#include &quot;clef.h&quot;</a>
<a name="ln18">#include &quot;utils.h&quot;</a>
<a name="ln19">#include &quot;system.h&quot;</a>
<a name="ln20">#include &quot;measure.h&quot;</a>
<a name="ln21">#include &quot;pitchspelling.h&quot;</a>
<a name="ln22">#include &quot;chordrest.h&quot;</a>
<a name="ln23">#include &quot;part.h&quot;</a>
<a name="ln24">#include &quot;staff.h&quot;</a>
<a name="ln25">#include &quot;note.h&quot;</a>
<a name="ln26">#include &quot;chord.h&quot;</a>
<a name="ln27">#include &quot;key.h&quot;</a>
<a name="ln28">#include &quot;sig.h&quot;</a>
<a name="ln29">#include &quot;tuplet.h&quot;</a>
<a name="ln30">#include &quot;sym.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">namespace Ms {</a>
<a name="ln33"> </a>
<a name="ln34">//---------------------------------------------------------</a>
<a name="ln35">//   handleRect</a>
<a name="ln36">//---------------------------------------------------------</a>
<a name="ln37"> </a>
<a name="ln38">QRectF handleRect(const QPointF&amp; pos)</a>
<a name="ln39">      {</a>
<a name="ln40">      return QRectF(pos.x()-4, pos.y()-4, 8, 8);</a>
<a name="ln41">      }</a>
<a name="ln42"> </a>
<a name="ln43">//---------------------------------------------------------</a>
<a name="ln44">//   tick2measure</a>
<a name="ln45">//---------------------------------------------------------</a>
<a name="ln46"> </a>
<a name="ln47">Measure* Score::tick2measure(const Fraction&amp; tick) const</a>
<a name="ln48">      {</a>
<a name="ln49">      if (tick == Fraction(-1,1))   // special number</a>
<a name="ln50">            return lastMeasure();</a>
<a name="ln51">      if (tick &lt;= Fraction(0,1))</a>
<a name="ln52">            return firstMeasure();</a>
<a name="ln53"> </a>
<a name="ln54">      Measure* lm = 0;</a>
<a name="ln55">      for (Measure* m = firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln56">            if (tick &lt; m-&gt;tick()) {</a>
<a name="ln57">                  Q_ASSERT(lm);</a>
<a name="ln58">                  return lm;</a>
<a name="ln59">                  }</a>
<a name="ln60">            lm = m;</a>
<a name="ln61">            }</a>
<a name="ln62">      // check last measure</a>
<a name="ln63">      if (lm &amp;&amp; (tick &gt;= lm-&gt;tick()) &amp;&amp; (tick &lt;= lm-&gt;endTick()))</a>
<a name="ln64">            return lm;</a>
<a name="ln65">      qDebug(&quot;tick2measure %d (max %d) not found&quot;, tick.ticks(), lm ? lm-&gt;tick().ticks() : -1);</a>
<a name="ln66">      return 0;</a>
<a name="ln67">      }</a>
<a name="ln68"> </a>
<a name="ln69">//---------------------------------------------------------</a>
<a name="ln70">//   tick2measureMM</a>
<a name="ln71">//---------------------------------------------------------</a>
<a name="ln72"> </a>
<a name="ln73">Measure* Score::tick2measureMM(const Fraction&amp; t) const</a>
<a name="ln74">      {</a>
<a name="ln75">      Fraction tick(t);</a>
<a name="ln76">      if (tick == Fraction(-1,1))</a>
<a name="ln77">            return lastMeasureMM();</a>
<a name="ln78">      if (tick &lt; Fraction(0,1))</a>
<a name="ln79">            tick = Fraction(0,1);</a>
<a name="ln80"> </a>
<a name="ln81">      Measure* lm = 0;</a>
<a name="ln82"> </a>
<a name="ln83">      for (Measure* m = firstMeasureMM(); m; m = m-&gt;nextMeasureMM()) {</a>
<a name="ln84">            if (tick &lt; m-&gt;tick()) {</a>
<a name="ln85">                  Q_ASSERT(lm);</a>
<a name="ln86">                  return lm;</a>
<a name="ln87">                  }</a>
<a name="ln88">            lm = m;</a>
<a name="ln89">            }</a>
<a name="ln90">      // check last measure</a>
<a name="ln91">      if (lm &amp;&amp; (tick &gt;= lm-&gt;tick()) &amp;&amp; (tick &lt;= lm-&gt;endTick()))</a>
<a name="ln92">            return lm;</a>
<a name="ln93">      qDebug(&quot;tick2measureMM %d (max %d) not found&quot;, tick.ticks(), lm ? lm-&gt;tick().ticks() : -1);</a>
<a name="ln94">      return 0;</a>
<a name="ln95">      }</a>
<a name="ln96"> </a>
<a name="ln97">//---------------------------------------------------------</a>
<a name="ln98">//   tick2measureBase</a>
<a name="ln99">//---------------------------------------------------------</a>
<a name="ln100"> </a>
<a name="ln101">MeasureBase* Score::tick2measureBase(const Fraction&amp; tick) const</a>
<a name="ln102">      {</a>
<a name="ln103">      for (MeasureBase* mb = first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln104">            Fraction st = mb-&gt;tick();</a>
<a name="ln105">            Fraction l  = mb-&gt;ticks();</a>
<a name="ln106">            if (tick &gt;= st &amp;&amp; tick &lt; (st+l))</a>
<a name="ln107">                  return mb;</a>
<a name="ln108">            }</a>
<a name="ln109">//      qDebug(&quot;tick2measureBase %d not found&quot;, tick);</a>
<a name="ln110">      return 0;</a>
<a name="ln111">      }</a>
<a name="ln112"> </a>
<a name="ln113">//---------------------------------------------------------</a>
<a name="ln114">//   tick2segment</a>
<a name="ln115">//---------------------------------------------------------</a>
<a name="ln116"> </a>
<a name="ln117">Segment* Score::tick2segmentMM(const Fraction&amp; tick, bool first, SegmentType st) const</a>
<a name="ln118">      {</a>
<a name="ln119">      return tick2segment(tick,first,st,true);</a>
<a name="ln120">      }</a>
<a name="ln121"> </a>
<a name="ln122">Segment* Score::tick2segmentMM(const Fraction&amp; tick) const</a>
<a name="ln123">      {</a>
<a name="ln124">      return tick2segment(tick, false, SegmentType::All, true);</a>
<a name="ln125">      }</a>
<a name="ln126">Segment* Score::tick2segmentMM(const Fraction&amp; tick, bool first) const</a>
<a name="ln127">      {</a>
<a name="ln128">      return tick2segment(tick, first, SegmentType::All, true);</a>
<a name="ln129">      }</a>
<a name="ln130"> </a>
<a name="ln131">Segment* Score::tick2segment(const Fraction&amp; t, bool first, SegmentType st, bool useMMrest ) const</a>
<a name="ln132">      {</a>
<a name="ln133">      Fraction tick(t);</a>
<a name="ln134">      Measure* m;</a>
<a name="ln135">      if (useMMrest) {</a>
<a name="ln136">            m = tick2measureMM(tick);</a>
<a name="ln137">            // When mmRest force tick to the first segment of mmRest.</a>
<a name="ln138">            if (m &amp;&amp; m-&gt;isMMRest())</a>
<a name="ln139">                  tick = m-&gt;tick();</a>
<a name="ln140">            }</a>
<a name="ln141">      else</a>
<a name="ln142">            m = tick2measure(tick);</a>
<a name="ln143"> </a>
<a name="ln144">      if (m == 0) {</a>
<a name="ln145">            qDebug(&quot;no measure for tick %d&quot;, tick.ticks());</a>
<a name="ln146">            return 0;</a>
<a name="ln147">            }</a>
<a name="ln148">      for (Segment* segment   = m-&gt;first(st); segment;) {</a>
<a name="ln149">            Fraction t1       = segment-&gt;tick();</a>
<a name="ln150">            Segment* nsegment = segment-&gt;next(st);</a>
<a name="ln151">            if (tick == t1) {</a>
<a name="ln152">                  if (first)</a>
<a name="ln153">                        return segment;</a>
<a name="ln154">                  else {</a>
<a name="ln155">                        if (!nsegment || tick &lt; nsegment-&gt;tick())</a>
<a name="ln156">                              return segment;</a>
<a name="ln157">                        }</a>
<a name="ln158">                  }</a>
<a name="ln159">            segment = nsegment;</a>
<a name="ln160">            }</a>
<a name="ln161">      qDebug(&quot;no segment for tick %d (start search at %d (measure %d))&quot;, tick.ticks(), t.ticks(), m-&gt;tick().ticks());</a>
<a name="ln162">      return 0;</a>
<a name="ln163">      }</a>
<a name="ln164"> </a>
<a name="ln165">Segment* Score::tick2segment(const Fraction&amp; tick) const</a>
<a name="ln166">      {</a>
<a name="ln167">      return tick2segment(tick, false, SegmentType::All, false);</a>
<a name="ln168">      }</a>
<a name="ln169"> </a>
<a name="ln170">Segment* Score::tick2segment(const Fraction&amp; tick, bool first) const</a>
<a name="ln171">      {</a>
<a name="ln172">      return tick2segment(tick, first, SegmentType::All, false);</a>
<a name="ln173">      }</a>
<a name="ln174"> </a>
<a name="ln175">//---------------------------------------------------------</a>
<a name="ln176">//   tick2leftSegment</a>
<a name="ln177">/// return the segment at this tick position if any or</a>
<a name="ln178">/// the first segment *before* this tick position</a>
<a name="ln179">//---------------------------------------------------------</a>
<a name="ln180"> </a>
<a name="ln181">Segment* Score::tick2leftSegment(const Fraction&amp; tick, bool useMMrest) const</a>
<a name="ln182">      {</a>
<a name="ln183">      Measure* m = useMMrest ? tick2measureMM(tick) : tick2measure(tick);</a>
<a name="ln184">      if (m == 0) {</a>
<a name="ln185">            qDebug(&quot;tick2leftSegment(): not found tick %d&quot;, tick.ticks());</a>
<a name="ln186">            return 0;</a>
<a name="ln187">            }</a>
<a name="ln188">      // loop over all segments</a>
<a name="ln189">      Segment* ps = 0;</a>
<a name="ln190">      for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln191">            if (tick &lt; s-&gt;tick())</a>
<a name="ln192">                  return ps;</a>
<a name="ln193">            else if (tick == s-&gt;tick())</a>
<a name="ln194">                  return s;</a>
<a name="ln195">            ps = s;</a>
<a name="ln196">            }</a>
<a name="ln197">      return ps;</a>
<a name="ln198">      }</a>
<a name="ln199"> </a>
<a name="ln200">//---------------------------------------------------------</a>
<a name="ln201">//   tick2rightSegment</a>
<a name="ln202">/// return the segment at this tick position if any or</a>
<a name="ln203">/// the first segment *after* this tick position</a>
<a name="ln204">//---------------------------------------------------------</a>
<a name="ln205"> </a>
<a name="ln206">Segment* Score::tick2rightSegment(const Fraction&amp; tick, bool useMMrest) const</a>
<a name="ln207">      {</a>
<a name="ln208">      Measure* m = useMMrest ? tick2measureMM(tick) : tick2measure(tick);</a>
<a name="ln209">      if (m == 0) {</a>
<a name="ln210">            qDebug(&quot;tick2nearestSegment(): not found tick %d&quot;, tick.ticks());</a>
<a name="ln211">            return 0;</a>
<a name="ln212">            }</a>
<a name="ln213">      // loop over all segments</a>
<a name="ln214">      for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next1(SegmentType::ChordRest)) {</a>
<a name="ln215">            if (tick &lt;= s-&gt;tick())</a>
<a name="ln216">                  return s;</a>
<a name="ln217">            }</a>
<a name="ln218">      return 0;</a>
<a name="ln219">      }</a>
<a name="ln220"> </a>
<a name="ln221">//---------------------------------------------------------</a>
<a name="ln222">//   tick2beatType</a>
<a name="ln223">//---------------------------------------------------------</a>
<a name="ln224"> </a>
<a name="ln225">BeatType Score::tick2beatType(const Fraction&amp; tick)</a>
<a name="ln226">      {</a>
<a name="ln227">      Measure* m = tick2measure(tick);</a>
<a name="ln228">      Fraction msrTick = m-&gt;tick();</a>
<a name="ln229">      TimeSigFrac timeSig = sigmap()-&gt;timesig(msrTick).nominal();</a>
<a name="ln230"> </a>
<a name="ln231">      int rtick = (tick - msrTick).ticks();</a>
<a name="ln232"> </a>
<a name="ln233">      if (m-&gt;isAnacrusis()) // measure is incomplete (anacrusis)</a>
<a name="ln234">            rtick += timeSig.ticksPerMeasure() - m-&gt;ticks().ticks();</a>
<a name="ln235"> </a>
<a name="ln236">      return timeSig.rtick2beatType(rtick);</a>
<a name="ln237">      }</a>
<a name="ln238"> </a>
<a name="ln239">//---------------------------------------------------------</a>
<a name="ln240">//   getStaff</a>
<a name="ln241">//---------------------------------------------------------</a>
<a name="ln242"> </a>
<a name="ln243">int getStaff(System* system, const QPointF&amp; p)</a>
<a name="ln244">      {</a>
<a name="ln245">      QPointF pp = p - system-&gt;page()-&gt;pos() - system-&gt;pos();</a>
<a name="ln246">      for (int i = 0; i &lt; system-&gt;page()-&gt;score()-&gt;nstaves(); ++i) {</a>
<a name="ln247">            qreal sp = system-&gt;spatium();</a>
<a name="ln248">            QRectF r = system-&gt;bboxStaff(i).adjusted(0.0, -sp, 0.0, sp);</a>
<a name="ln249">            if (r.contains(pp))</a>
<a name="ln250">                  return i;</a>
<a name="ln251">            }</a>
<a name="ln252">      return -1;</a>
<a name="ln253">      }</a>
<a name="ln254"> </a>
<a name="ln255">//---------------------------------------------------------</a>
<a name="ln256">//   nextSeg</a>
<a name="ln257">//---------------------------------------------------------</a>
<a name="ln258"> </a>
<a name="ln259">Fraction Score::nextSeg(const Fraction&amp; tick, int track)</a>
<a name="ln260">      {</a>
<a name="ln261">      Segment* seg = tick2segment(tick);</a>
<a name="ln262">      while (seg) {</a>
<a name="ln263">            seg = seg-&gt;next1(SegmentType::ChordRest);</a>
<a name="ln264">            if (seg == 0)</a>
<a name="ln265">                  break;</a>
<a name="ln266">            if (seg-&gt;element(track))</a>
<a name="ln267">                  break;</a>
<a name="ln268">            }</a>
<a name="ln269">      return seg ? seg-&gt;tick() : Fraction(-1,1);</a>
<a name="ln270">      }</a>
<a name="ln271"> </a>
<a name="ln272">//---------------------------------------------------------</a>
<a name="ln273">//   nextSeg1</a>
<a name="ln274">//---------------------------------------------------------</a>
<a name="ln275"> </a>
<a name="ln276">Segment* nextSeg1(Segment* seg, int&amp; track)</a>
<a name="ln277">      {</a>
<a name="ln278">      int staffIdx   = track / VOICES;</a>
<a name="ln279">      int startTrack = staffIdx * VOICES;</a>
<a name="ln280">      int endTrack   = startTrack + VOICES;</a>
<a name="ln281">      while ((seg = seg-&gt;next1(SegmentType::ChordRest))) {</a>
<a name="ln282">            for (int t = startTrack; t &lt; endTrack; ++t) {</a>
<a name="ln283">                  if (seg-&gt;element(t)) {</a>
<a name="ln284">                        track = t;</a>
<a name="ln285">                        return seg;</a>
<a name="ln286">                        }</a>
<a name="ln287">                  }</a>
<a name="ln288">            }</a>
<a name="ln289">      return 0;</a>
<a name="ln290">      }</a>
<a name="ln291"> </a>
<a name="ln292">//---------------------------------------------------------</a>
<a name="ln293">//   prevSeg1</a>
<a name="ln294">//---------------------------------------------------------</a>
<a name="ln295"> </a>
<a name="ln296">Segment* prevSeg1(Segment* seg, int&amp; track)</a>
<a name="ln297">      {</a>
<a name="ln298">      int staffIdx   = track / VOICES;</a>
<a name="ln299">      int startTrack = staffIdx * VOICES;</a>
<a name="ln300">      int endTrack   = startTrack + VOICES;</a>
<a name="ln301">      while ((seg = seg-&gt;prev1(SegmentType::ChordRest))) {</a>
<a name="ln302">            for (int t = startTrack; t &lt; endTrack; ++t) {</a>
<a name="ln303">                  if (seg-&gt;element(t)) {</a>
<a name="ln304">                        track = t;</a>
<a name="ln305">                        return seg;</a>
<a name="ln306">                        }</a>
<a name="ln307">                  }</a>
<a name="ln308">            }</a>
<a name="ln309">      return 0;</a>
<a name="ln310">      }</a>
<a name="ln311"> </a>
<a name="ln312">//---------------------------------------------------------</a>
<a name="ln313">//    next/prevChordNote</a>
<a name="ln314">//</a>
<a name="ln315">//    returns the top note of the next/previous chord. If a</a>
<a name="ln316">//    chord exists in the same track as note,</a>
<a name="ln317">//    it is used. If not, the topmost existing chord is used.</a>
<a name="ln318">//    May return nullptr if there is no next/prev note</a>
<a name="ln319">//---------------------------------------------------------</a>
<a name="ln320"> </a>
<a name="ln321">Note* nextChordNote(Note* note)</a>
<a name="ln322">      {</a>
<a name="ln323">      int         track       = note-&gt;track();</a>
<a name="ln324">      int         fromTrack   = (track / VOICES) * VOICES;</a>
<a name="ln325">      int         toTrack     = fromTrack + VOICES;</a>
<a name="ln326">      // TODO : limit to same instrument, not simply to same staff!</a>
<a name="ln327">      Segment*    seg   = note-&gt;chord()-&gt;segment()-&gt;nextCR(track, true);</a>
<a name="ln328">      while (seg) {</a>
<a name="ln329">            Element*    targetElement = seg-&gt;elementAt(track);</a>
<a name="ln330">            // if a chord exists in the same track, return its top note</a>
<a name="ln331">            if (targetElement &amp;&amp; targetElement-&gt;isChord())</a>
<a name="ln332">                  return toChord(targetElement)-&gt;upNote();</a>
<a name="ln333">            // if not, return topmost chord in track range</a>
<a name="ln334">            for (int i = fromTrack ; i &lt; toTrack; i++) {</a>
<a name="ln335">                  targetElement = seg-&gt;elementAt(i);</a>
<a name="ln336">                  if (targetElement &amp;&amp; targetElement-&gt;isChord())</a>
<a name="ln337">                        return toChord(targetElement)-&gt;upNote();</a>
<a name="ln338">                  }</a>
<a name="ln339">            seg = seg-&gt;nextCR(track, true);</a>
<a name="ln340">            }</a>
<a name="ln341">      return nullptr;</a>
<a name="ln342">      }</a>
<a name="ln343"> </a>
<a name="ln344">Note* prevChordNote(Note* note)</a>
<a name="ln345">      {</a>
<a name="ln346">      int         track       = note-&gt;track();</a>
<a name="ln347">      int         fromTrack   = (track / VOICES) * VOICES;</a>
<a name="ln348">      int         toTrack     = fromTrack + VOICES;</a>
<a name="ln349">      // TODO : limit to same instrument, not simply to same staff!</a>
<a name="ln350">      Segment*    seg   = note-&gt;chord()-&gt;segment()-&gt;prev1();</a>
<a name="ln351">      while (seg) {</a>
<a name="ln352">            if (seg-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln353">                  Element*    targetElement = seg-&gt;elementAt(track);</a>
<a name="ln354">                  // if a chord exists in the same track, return its top note</a>
<a name="ln355">                  if (targetElement &amp;&amp; targetElement-&gt;isChord())</a>
<a name="ln356">                        return toChord(targetElement)-&gt;upNote();</a>
<a name="ln357">                  // if not, return topmost chord in track range</a>
<a name="ln358">                  for (int i = fromTrack ; i &lt; toTrack; i++) {</a>
<a name="ln359">                        targetElement = seg-&gt;elementAt(i);</a>
<a name="ln360">                        if (targetElement &amp;&amp; targetElement-&gt;isChord())</a>
<a name="ln361">                              return toChord(targetElement)-&gt;upNote();</a>
<a name="ln362">                        }</a>
<a name="ln363">                  }</a>
<a name="ln364">            seg = seg-&gt;prev1();</a>
<a name="ln365">            }</a>
<a name="ln366">      return nullptr;</a>
<a name="ln367">      }</a>
<a name="ln368"> </a>
<a name="ln369">//---------------------------------------------------------</a>
<a name="ln370">//   pitchKeyAdjust</a>
<a name="ln371">//    change entered note to sounding pitch dependent</a>
<a name="ln372">//    on key.</a>
<a name="ln373">//    Example: if F is entered in G-major, a Fis is played</a>
<a name="ln374">//    key -7 ... +7</a>
<a name="ln375">//---------------------------------------------------------</a>
<a name="ln376"> </a>
<a name="ln377">int pitchKeyAdjust(int step, Key key)</a>
<a name="ln378">      {</a>
<a name="ln379">      static int ptab[15][7] = {</a>
<a name="ln380">//             c  d  e  f  g   a  b</a>
<a name="ln381">            { -1, 1, 3, 4, 6,  8, 10 },     // Bes</a>
<a name="ln382">            { -1, 1, 3, 5, 6,  8, 10 },     // Ges</a>
<a name="ln383">            {  0, 1, 3, 5, 6,  8, 10 },     // Des</a>
<a name="ln384">            {  0, 1, 3, 5, 7,  8, 10 },     // As</a>
<a name="ln385">            {  0, 2, 3, 5, 7,  8, 10 },     // Es</a>
<a name="ln386">            {  0, 2, 3, 5, 7,  9, 10 },     // B</a>
<a name="ln387">            {  0, 2, 4, 5, 7,  9, 10 },     // F</a>
<a name="ln388">            {  0, 2, 4, 5, 7,  9, 11 },     // C</a>
<a name="ln389">            {  0, 2, 4, 6, 7,  9, 11 },     // G</a>
<a name="ln390">            {  1, 2, 4, 6, 7,  9, 11 },     // D</a>
<a name="ln391">            {  1, 2, 4, 6, 8,  9, 11 },     // A</a>
<a name="ln392">            {  1, 3, 4, 6, 8,  9, 11 },     // E</a>
<a name="ln393">            {  1, 3, 4, 6, 8, 10, 11 },     // H</a>
<a name="ln394">            {  1, 3, 5, 6, 8, 10, 11 },     // Fis</a>
<a name="ln395">            {  1, 3, 5, 6, 8, 10, 12 },     // Cis</a>
<a name="ln396">            };</a>
<a name="ln397">      return ptab[int(key)+7][step];</a>
<a name="ln398">      }</a>
<a name="ln399"> </a>
<a name="ln400">//---------------------------------------------------------</a>
<a name="ln401">//   y2pitch</a>
<a name="ln402">//---------------------------------------------------------</a>
<a name="ln403"> </a>
<a name="ln404">int y2pitch(qreal y, ClefType clef, qreal _spatium)</a>
<a name="ln405">      {</a>
<a name="ln406">      int l = lrint(y / _spatium * 2.0);</a>
<a name="ln407">      return line2pitch(l, clef, Key::C);</a>
<a name="ln408">      }</a>
<a name="ln409"> </a>
<a name="ln410">//---------------------------------------------------------</a>
<a name="ln411">//   line2pitch</a>
<a name="ln412">//    key  -7 ... +7</a>
<a name="ln413">//---------------------------------------------------------</a>
<a name="ln414"> </a>
<a name="ln415">int line2pitch(int line, ClefType clef, Key key)</a>
<a name="ln416">      {</a>
<a name="ln417">      int l      = ClefInfo::pitchOffset(clef) - line;</a>
<a name="ln418">      int octave = 0;</a>
<a name="ln419">      while (l &lt; 0) {</a>
<a name="ln420">            l += 7;</a>
<a name="ln421">            octave++;</a>
<a name="ln422">            }</a>
<a name="ln423">      octave += l / 7;</a>
<a name="ln424">      l       = l % 7;</a>
<a name="ln425"> </a>
<a name="ln426">      int pitch = pitchKeyAdjust(l, key) + octave * 12;</a>
<a name="ln427"> </a>
<a name="ln428">      if (pitch &gt; 127)</a>
<a name="ln429">            pitch = 127;</a>
<a name="ln430">      else if (pitch &lt; 0)</a>
<a name="ln431">            pitch = 0;</a>
<a name="ln432">      return pitch;</a>
<a name="ln433">      }</a>
<a name="ln434"> </a>
<a name="ln435">//---------------------------------------------------------</a>
<a name="ln436">//   quantizeLen</a>
<a name="ln437">//---------------------------------------------------------</a>
<a name="ln438"> </a>
<a name="ln439">int quantizeLen(int len, int raster)</a>
<a name="ln440">      {</a>
<a name="ln441">      if (raster == 0)</a>
<a name="ln442">            return len;</a>
<a name="ln443">      return int( ((float)len/raster) + 0.5 ) * raster; //round to the closest multiple of raster</a>
<a name="ln444">      }</a>
<a name="ln445"> </a>
<a name="ln446">static const char* vall[] = {</a>
<a name="ln447">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;c&quot;),</a>
<a name="ln448">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;c♯&quot;),</a>
<a name="ln449">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;d&quot;),</a>
<a name="ln450">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;d♯&quot;),</a>
<a name="ln451">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;e&quot;),</a>
<a name="ln452">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;f&quot;),</a>
<a name="ln453">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;f♯&quot;),</a>
<a name="ln454">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;g&quot;),</a>
<a name="ln455">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;g♯&quot;),</a>
<a name="ln456">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;a&quot;),</a>
<a name="ln457">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;a♯&quot;),</a>
<a name="ln458">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;b&quot;)</a>
<a name="ln459">      };</a>
<a name="ln460">static const char* valu[] = {</a>
<a name="ln461">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;C&quot;),</a>
<a name="ln462">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;C♯&quot;),</a>
<a name="ln463">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;D&quot;),</a>
<a name="ln464">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;D♯&quot;),</a>
<a name="ln465">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;E&quot;),</a>
<a name="ln466">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;F&quot;),</a>
<a name="ln467">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;F♯&quot;),</a>
<a name="ln468">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;G&quot;),</a>
<a name="ln469">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;G♯&quot;),</a>
<a name="ln470">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;A&quot;),</a>
<a name="ln471">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;A♯&quot;),</a>
<a name="ln472">      QT_TRANSLATE_NOOP(&quot;utils&quot;, &quot;B&quot;)</a>
<a name="ln473">      };</a>
<a name="ln474"> </a>
<a name="ln475">/*!</a>
<a name="ln476"> * Returns the string representation of the given pitch.</a>
<a name="ln477"> *</a>
<a name="ln478"> * Returns the latin letter name, accidental, and octave numeral.</a>
<a name="ln479"> * Uses upper case only for pitches 0-24.</a>
<a name="ln480"> *</a>
<a name="ln481"> * @param v</a>
<a name="ln482"> *  The pitch number of the note.</a>
<a name="ln483"> *</a>
<a name="ln484"> * @return</a>
<a name="ln485"> *  The string representation of the note.</a>
<a name="ln486"> */</a>
<a name="ln487">QString pitch2string(int v)</a>
<a name="ln488">      {</a>
<a name="ln489">      if (v &lt; 0 || v &gt; 127)</a>
<a name="ln490">            return QString(&quot;----&quot;);</a>
<a name="ln491">      int octave = (v / 12) - 1;</a>
<a name="ln492">      QString o;</a>
<a name="ln493">      o.sprintf(&quot;%d&quot;, octave);</a>
<a name="ln494">      int i = v % 12;</a>
<a name="ln495">      return qApp-&gt;translate(&quot;utils&quot;, octave &lt; 0 ? valu[i] : vall[i]) + o;</a>
<a name="ln496">      }</a>
<a name="ln497"> </a>
<a name="ln498">/*!</a>
<a name="ln499"> * An array of all supported interval sorted by size.</a>
<a name="ln500"> *</a>
<a name="ln501"> * Because intervals can be spelled differently, this array</a>
<a name="ln502"> * tracks all the different valid intervals. They are arranged</a>
<a name="ln503"> * in diatonic then chromatic order.</a>
<a name="ln504"> */</a>
<a name="ln505">Interval intervalList[intervalListSize] = {</a>
<a name="ln506">      // diatonic - chromatic</a>
<a name="ln507">      Interval(0, 0),         //  0 Perfect Unison</a>
<a name="ln508">      Interval(0, 1),         //  1 Augmented Unison</a>
<a name="ln509"> </a>
<a name="ln510">      Interval(1, 0),         //  2 Diminished Second</a>
<a name="ln511">      Interval(1, 1),         //  3 Minor Second</a>
<a name="ln512">      Interval(1, 2),         //  4 Major Second</a>
<a name="ln513">      Interval(1, 3),         //  5 Augmented Second</a>
<a name="ln514"> </a>
<a name="ln515">      Interval(2, 2),         //  6 Diminished Third</a>
<a name="ln516">      Interval(2, 3),         //  7 Minor Third</a>
<a name="ln517">      Interval(2, 4),         //  8 Major Third</a>
<a name="ln518">      Interval(2, 5),         //  9 Augmented Third</a>
<a name="ln519"> </a>
<a name="ln520">      Interval(3, 4),         // 10 Diminished Fourth</a>
<a name="ln521">      Interval(3, 5),         // 11 Perfect Fourth</a>
<a name="ln522">      Interval(3, 6),         // 12 Augmented Fourth</a>
<a name="ln523"> </a>
<a name="ln524">      Interval(4, 6),         // 13 Diminished Fifth</a>
<a name="ln525">      Interval(4, 7),         // 14 Perfect Fifth</a>
<a name="ln526">      Interval(4, 8),         // 15 Augmented Fifth</a>
<a name="ln527"> </a>
<a name="ln528">      Interval(5, 7),         // 16 Diminished Sixth</a>
<a name="ln529">      Interval(5, 8),         // 17 Minor Sixth</a>
<a name="ln530">      Interval(5, 9),         // 18 Major Sixth</a>
<a name="ln531">      Interval(5, 10),        // 19 Augmented Sixth</a>
<a name="ln532"> </a>
<a name="ln533">      Interval(6, 9),         // 20 Diminished Seventh</a>
<a name="ln534">      Interval(6, 10),        // 21 Minor Seventh</a>
<a name="ln535">      Interval(6, 11),        // 22 Major Seventh</a>
<a name="ln536">      Interval(6, 12),        // 23 Augmented Seventh</a>
<a name="ln537"> </a>
<a name="ln538">      Interval(7, 11),        // 24 Diminshed Octave</a>
<a name="ln539">      Interval(7, 12)         // 25 Perfect Octave</a>
<a name="ln540">      };</a>
<a name="ln541"> </a>
<a name="ln542">/*!</a>
<a name="ln543"> * Finds the most likely diatonic interval for a semitone distance.</a>
<a name="ln544"> *</a>
<a name="ln545"> * Uses the most common diatonic intervals.</a>
<a name="ln546"> *</a>
<a name="ln547"> * @param</a>
<a name="ln548"> *  The number of semitones in the chromatic interval.</a>
<a name="ln549"> *  Negative semitones will simply be made positive.</a>
<a name="ln550"> *</a>
<a name="ln551"> * @return</a>
<a name="ln552"> *  The number of diatonic steps in the interval.</a>
<a name="ln553"> */</a>
<a name="ln554"> </a>
<a name="ln555">int chromatic2diatonic(int semitones)</a>
<a name="ln556">      {</a>
<a name="ln557">      static int il[12] = {</a>
<a name="ln558">            0,    // Perfect Unison</a>
<a name="ln559">            3,    // Minor Second</a>
<a name="ln560">            4,    // Major Second</a>
<a name="ln561">            7,    // Minor Third</a>
<a name="ln562">            8,    // Major Third</a>
<a name="ln563">            11,   // Perfect Fourth</a>
<a name="ln564">            12,   // Augmented Fourth</a>
<a name="ln565">            14,   // Perfect Fifth</a>
<a name="ln566">            17,   // Minor Sixth</a>
<a name="ln567">            18,   // Major Sixth</a>
<a name="ln568">            21,   // Minor Seventh</a>
<a name="ln569">            22,   // Major Seventh</a>
<a name="ln570">            // 25    Perfect Octave</a>
<a name="ln571">            };</a>
<a name="ln572">      bool down = semitones &lt; 0;</a>
<a name="ln573">      if (down)</a>
<a name="ln574">            semitones = -semitones;</a>
<a name="ln575">      int val = semitones % 12;</a>
<a name="ln576">      int octave = semitones / 12;</a>
<a name="ln577">      int intervalIndex = il[val];</a>
<a name="ln578">      int steps = intervalList[intervalIndex].diatonic;</a>
<a name="ln579">      steps = steps + octave * 7;</a>
<a name="ln580">      return down ? -steps : steps;</a>
<a name="ln581">      }</a>
<a name="ln582"> </a>
<a name="ln583">//---------------------------------------------------------</a>
<a name="ln584">//   searchInterval</a>
<a name="ln585">//---------------------------------------------------------</a>
<a name="ln586"> </a>
<a name="ln587">int searchInterval(int steps, int semitones)</a>
<a name="ln588">      {</a>
<a name="ln589">      unsigned n = sizeof(intervalList)/sizeof(*intervalList);</a>
<a name="ln590">      for (unsigned i = 0; i &lt; n; ++i) {</a>
<a name="ln591">            if ((intervalList[i].diatonic == steps) &amp;&amp; (intervalList[i].chromatic == semitones))</a>
<a name="ln592">                  return i;</a>
<a name="ln593">            }</a>
<a name="ln594">      return -1;</a>
<a name="ln595">      }</a>
<a name="ln596"> </a>
<a name="ln597">static int _majorVersion, _minorVersion, _updateVersion;</a>
<a name="ln598"> </a>
<a name="ln599">/*!</a>
<a name="ln600"> * Returns the program version</a>
<a name="ln601"> *</a>
<a name="ln602"> * @return</a>
<a name="ln603"> *  Version in the format: MMmmuu</a>
<a name="ln604"> *  Where M=Major, m=minor, and u=update</a>
<a name="ln605"> */</a>
<a name="ln606"> </a>
<a name="ln607">int version()</a>
<a name="ln608">      {</a>
<a name="ln609">      QRegExp re(&quot;(\\d+)\\.(\\d+)\\.(\\d+)&quot;);</a>
<a name="ln610">      if (re.indexIn(VERSION) != -1) {</a>
<a name="ln611">            QStringList sl = re.capturedTexts();</a>
<a name="ln612">            if (sl.size() == 4) {</a>
<a name="ln613">                  _majorVersion = sl[1].toInt();</a>
<a name="ln614">                  _minorVersion = sl[2].toInt();</a>
<a name="ln615">                  _updateVersion = sl[3].toInt();</a>
<a name="ln616">                  return _majorVersion * 10000 + _minorVersion * 100 + _updateVersion;</a>
<a name="ln617">                  }</a>
<a name="ln618">            }</a>
<a name="ln619">      return 0;</a>
<a name="ln620">      }</a>
<a name="ln621"> </a>
<a name="ln622">//---------------------------------------------------------</a>
<a name="ln623">//   majorVersion</a>
<a name="ln624">//---------------------------------------------------------</a>
<a name="ln625"> </a>
<a name="ln626">int majorVersion()</a>
<a name="ln627">      {</a>
<a name="ln628">      version();</a>
<a name="ln629">      return _majorVersion;</a>
<a name="ln630">      }</a>
<a name="ln631"> </a>
<a name="ln632">//---------------------------------------------------------</a>
<a name="ln633">//   minorVersion</a>
<a name="ln634">//---------------------------------------------------------</a>
<a name="ln635"> </a>
<a name="ln636">int minorVersion()</a>
<a name="ln637">      {</a>
<a name="ln638">      version();</a>
<a name="ln639">      return _minorVersion;</a>
<a name="ln640">      }</a>
<a name="ln641"> </a>
<a name="ln642">//---------------------------------------------------------</a>
<a name="ln643">//   updateVersion</a>
<a name="ln644">//---------------------------------------------------------</a>
<a name="ln645"> </a>
<a name="ln646">int updateVersion()</a>
<a name="ln647">      {</a>
<a name="ln648">      version();</a>
<a name="ln649">      return _updateVersion;</a>
<a name="ln650">      }</a>
<a name="ln651"> </a>
<a name="ln652">//---------------------------------------------------------</a>
<a name="ln653">//   updateVersion</a>
<a name="ln654">///  Up to 4 digits X.X.X.X</a>
<a name="ln655">///  Each digit can be double XX.XX.XX.XX</a>
<a name="ln656">///  return true if v1 &lt; v2</a>
<a name="ln657">//---------------------------------------------------------</a>
<a name="ln658"> </a>
<a name="ln659">bool compareVersion(QString v1, QString v2)</a>
<a name="ln660">      {</a>
<a name="ln661">      auto v1l = v1.split(&quot;.&quot;);</a>
<a name="ln662">      auto v2l = v2.split(&quot;.&quot;);</a>
<a name="ln663">      int ma = qPow(100,qMax(v1l.size(), v2l.size()));</a>
<a name="ln664">      int m = ma;</a>
<a name="ln665">      int vv1 = 0;</a>
<a name="ln666">      for (int i = 0; i &lt; v1l.size(); i++) {</a>
<a name="ln667">            vv1 += (m * v1l[i].toInt());</a>
<a name="ln668">            m /= 100;</a>
<a name="ln669">            }</a>
<a name="ln670">      m = ma;</a>
<a name="ln671">      int vv2 = 0;</a>
<a name="ln672">      for (int i = 0; i &lt; v2l.size(); i++) {</a>
<a name="ln673">            vv2 += (m * v2l[i].toInt());</a>
<a name="ln674">            m /= 100;</a>
<a name="ln675">            }</a>
<a name="ln676"> </a>
<a name="ln677">      return vv1 &lt; vv2;</a>
<a name="ln678">      }</a>
<a name="ln679"> </a>
<a name="ln680">//---------------------------------------------------------</a>
<a name="ln681">//   diatonicUpDown</a>
<a name="ln682">//    used to find the second note of a trill, mordent etc.</a>
<a name="ln683">//    key  -7 ... +7</a>
<a name="ln684">//---------------------------------------------------------</a>
<a name="ln685"> </a>
<a name="ln686">int diatonicUpDown(Key k, int pitch, int steps)</a>
<a name="ln687">      {</a>
<a name="ln688">      static int ptab[15][7] = {</a>
<a name="ln689">//             c  c#   d  d#    e   f  f#   g  g#  a  a#   b</a>
<a name="ln690">            { -1,      1,       3,  4,      6,     8,      10 },     // Cb Ces</a>
<a name="ln691">            { -1,      1,       3,  5,      6,     8,      10 },     // Gb Ges</a>
<a name="ln692">            {  0,      1,       3,  5,      6,     8,      10 },     // Db Des</a>
<a name="ln693">            {  0,      1,       3,  5,      7,     8,      10 },     // Ab As</a>
<a name="ln694">            {  0,      2,       3,  5,      7,     8,      10 },     // Eb Es</a>
<a name="ln695">            {  0,      2,       3,  5,      7,     9,      10 },     // Bb B</a>
<a name="ln696">            {  0,      2,       4,  5,      7,     9,      10 },     // F  F</a>
<a name="ln697"> </a>
<a name="ln698">            {  0,      2,       4,  5,      7,     9,      11 },     // C  C</a>
<a name="ln699"> </a>
<a name="ln700">            {  0,      2,       4,  6,      7,     9,      11 },     // G  G</a>
<a name="ln701">            {  1,      2,       4,  6,      7,     9,      11 },     // D  D</a>
<a name="ln702">            {  1,      2,       4,  6,      8,     9,      11 },     // A  A</a>
<a name="ln703">            {  1,      3,       4,  6,      8,     9,      11 },     // E  E</a>
<a name="ln704">            {  1,      3,       4,  6,      8,    10,      11 },     // B  H</a>
<a name="ln705">            {  1,      3,       5,  6,      8,    10,      11 },     // F# Fis</a>
<a name="ln706">            {  1,      3,       5,  6,      8,    10,      12 },     // C# Cis</a>
<a name="ln707">            };</a>
<a name="ln708"> </a>
<a name="ln709">      int key    = int(k) + 7;</a>
<a name="ln710">      int step   = pitch % 12;</a>
<a name="ln711">      int octave = pitch / 12;</a>
<a name="ln712"> </a>
<a name="ln713">      // loop through the diatonic steps of the key looking for the given note</a>
<a name="ln714">      // or the gap where it would fit</a>
<a name="ln715">      int i = 0;</a>
<a name="ln716">      while (i &lt; 7) {</a>
<a name="ln717">            if (ptab[key][i] &gt;= step)</a>
<a name="ln718">                  break;</a>
<a name="ln719">            ++i;</a>
<a name="ln720">            }</a>
<a name="ln721"> </a>
<a name="ln722">      // neither step nor gap found</a>
<a name="ln723">      // reset to beginning</a>
<a name="ln724">      if (i == 7) {</a>
<a name="ln725">            ++octave;</a>
<a name="ln726">            i = 0;</a>
<a name="ln727">            }</a>
<a name="ln728">      // if given step not found (gap found instead), and we are stepping up</a>
<a name="ln729">      // then we've already accounted for one step</a>
<a name="ln730">      if (ptab[key][i] &gt; step &amp;&amp; steps &gt; 0)</a>
<a name="ln731">            --steps;</a>
<a name="ln732"> </a>
<a name="ln733">      // now start counting diatonic steps up or down</a>
<a name="ln734">      if (steps &gt; 0) {</a>
<a name="ln735">            // count up</a>
<a name="ln736">            while (steps--) {</a>
<a name="ln737">                  ++i;</a>
<a name="ln738">                  if (i == 7) {</a>
<a name="ln739">                        // hit last step; reset to beginning</a>
<a name="ln740">                        ++octave;</a>
<a name="ln741">                        i = 0;</a>
<a name="ln742">                        }</a>
<a name="ln743">                  }</a>
<a name="ln744">            }</a>
<a name="ln745">      else if (steps &lt; 0) {</a>
<a name="ln746">            // count down</a>
<a name="ln747">            while (steps++) {</a>
<a name="ln748">                  --i;</a>
<a name="ln749">                  if (i &lt; 0) {</a>
<a name="ln750">                        // hit first step; reset to end</a>
<a name="ln751">                        --octave;</a>
<a name="ln752">                        i = 6;</a>
<a name="ln753">                        }</a>
<a name="ln754">                  }</a>
<a name="ln755">            }</a>
<a name="ln756"> </a>
<a name="ln757">      // convert step to pitch</a>
<a name="ln758">      step = ptab[key][i];</a>
<a name="ln759">      pitch = octave * 12 + step;</a>
<a name="ln760">      if (pitch &lt; 0)</a>
<a name="ln761">            pitch = 0;</a>
<a name="ln762">      if (pitch &gt; 127)</a>
<a name="ln763">            pitch = 128;</a>
<a name="ln764">      return pitch;</a>
<a name="ln765">      }</a>
<a name="ln766"> </a>
<a name="ln767">//---------------------------------------------------------</a>
<a name="ln768">//   searchTieNote</a>
<a name="ln769">//    search Note to tie to &quot;note&quot;</a>
<a name="ln770">//---------------------------------------------------------</a>
<a name="ln771"> </a>
<a name="ln772">Note* searchTieNote(Note* note)</a>
<a name="ln773">      {</a>
<a name="ln774">      Note* note2  = 0;</a>
<a name="ln775">      Chord* chord = note-&gt;chord();</a>
<a name="ln776">      Segment* seg = chord-&gt;segment();</a>
<a name="ln777">      Part* part   = chord-&gt;part();</a>
<a name="ln778">      int strack   = part-&gt;staves()-&gt;front()-&gt;idx() * VOICES;</a>
<a name="ln779">      int etrack   = strack + part-&gt;staves()-&gt;size() * VOICES;</a>
<a name="ln780"> </a>
<a name="ln781">      if (chord-&gt;isGraceBefore()) {</a>
<a name="ln782">            chord = toChord(chord-&gt;parent());</a>
<a name="ln783"> </a>
<a name="ln784">            // try to tie to next grace note</a>
<a name="ln785"> </a>
<a name="ln786">            int index = chord-&gt;graceIndex();</a>
<a name="ln787">            for (Chord* c : chord-&gt;graceNotes()) {</a>
<a name="ln788">                  if (c-&gt;graceIndex() == index + 1) {</a>
<a name="ln789">                        note2 = c-&gt;findNote(note-&gt;pitch());</a>
<a name="ln790">                        if (note2) {</a>
<a name="ln791">//printf(&quot;found grace-grace tie\n&quot;);</a>
<a name="ln792">                              return note2;</a>
<a name="ln793">                              }</a>
<a name="ln794">                        }</a>
<a name="ln795">                  }</a>
<a name="ln796"> </a>
<a name="ln797">            // try to tie to note in parent chord</a>
<a name="ln798">            note2 = chord-&gt;findNote(note-&gt;pitch());</a>
<a name="ln799">            if (note2)</a>
<a name="ln800">                  return note2;</a>
<a name="ln801">            }</a>
<a name="ln802">      else if (chord-&gt;isGraceAfter()) {</a>
<a name="ln803">            // grace after</a>
<a name="ln804">            // we will try to tie to note in next normal chord, below</a>
<a name="ln805">            // meanwhile, set chord to parent chord so the endTick calculation will make sense</a>
<a name="ln806">            chord = toChord(chord-&gt;parent());</a>
<a name="ln807">            }</a>
<a name="ln808">      else {</a>
<a name="ln809">            // normal chord</a>
<a name="ln810">            // try to tie to grace note after if present</a>
<a name="ln811">            QVector&lt;Chord*&gt; gna = chord-&gt;graceNotesAfter();</a>
<a name="ln812">            if (!gna.empty()) {</a>
<a name="ln813">                  Chord* gc = gna[0];</a>
<a name="ln814">                  note2 = gc-&gt;findNote(note-&gt;pitch());</a>
<a name="ln815">                  if (note2)</a>
<a name="ln816">                        return note2;</a>
<a name="ln817">                  }</a>
<a name="ln818">            }</a>
<a name="ln819">      // at this point, chord is a regular chord, not a grace chord</a>
<a name="ln820">      // and we are looking for a note in the *next* chord (grace or regular)</a>
<a name="ln821"> </a>
<a name="ln822">      // calculate end of current note duration</a>
<a name="ln823">      // but err on the safe side in case there is roundoff in tick count</a>
<a name="ln824">      Fraction endTick = chord-&gt;tick() + chord-&gt;actualTicks() - Fraction(1, 4 * 480);</a>
<a name="ln825"> </a>
<a name="ln826">      int idx1 = note-&gt;unisonIndex();</a>
<a name="ln827">      while ((seg = seg-&gt;next1(SegmentType::ChordRest))) {</a>
<a name="ln828">            // skip ahead to end of current note duration as calculated above</a>
<a name="ln829">            // but just in case, stop if we find element in current track</a>
<a name="ln830">            if (seg-&gt;tick() &lt; endTick  &amp;&amp; !seg-&gt;element(chord-&gt;track()))</a>
<a name="ln831">                  continue;</a>
<a name="ln832">            for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln833">                  Element* e = seg-&gt;element(track);</a>
<a name="ln834">                  if (e == 0 || !e-&gt;isChord())</a>
<a name="ln835">                        continue;</a>
<a name="ln836">                  Chord* c = toChord(e);</a>
<a name="ln837">                  const int staffIdx = c-&gt;staffIdx() + c-&gt;staffMove();</a>
<a name="ln838">                  if (staffIdx != chord-&gt;staffIdx() + chord-&gt;staffMove()) {</a>
<a name="ln839">                        // this check is needed as we are iterating over all staves to capture cross-staff chords</a>
<a name="ln840">                        continue;</a>
<a name="ln841">                        }</a>
<a name="ln842">                  // if there are grace notes before, try to tie to first one</a>
<a name="ln843">                  QVector&lt;Chord*&gt; gnb = c-&gt;graceNotesBefore();</a>
<a name="ln844">                  if (!gnb.empty()) {</a>
<a name="ln845">                        Chord* gc = gnb[0];</a>
<a name="ln846">                        Note* gn2 = gc-&gt;findNote(note-&gt;pitch());</a>
<a name="ln847">                        if (gn2)</a>
<a name="ln848">                              return gn2;</a>
<a name="ln849">                        }</a>
<a name="ln850">                  int idx2 = 0;</a>
<a name="ln851">                  for (Note* n : c-&gt;notes()) {</a>
<a name="ln852">                        if (n-&gt;pitch() == note-&gt;pitch()) {</a>
<a name="ln853">                              if (idx1 == idx2) {</a>
<a name="ln854">                                    if (note2 == 0 || c-&gt;track() == chord-&gt;track()) {</a>
<a name="ln855">                                          note2 = n;</a>
<a name="ln856">                                          break;</a>
<a name="ln857">                                          }</a>
<a name="ln858">                                    }</a>
<a name="ln859">                              else</a>
<a name="ln860">                                    ++idx2;</a>
<a name="ln861">                              }</a>
<a name="ln862">                        }</a>
<a name="ln863">                  }</a>
<a name="ln864">            if (note2)</a>
<a name="ln865">                  break;</a>
<a name="ln866">            }</a>
<a name="ln867">      return note2;</a>
<a name="ln868">      }</a>
<a name="ln869"> </a>
<a name="ln870">//---------------------------------------------------------</a>
<a name="ln871">//   searchTieNote114</a>
<a name="ln872">//    search Note to tie to &quot;note&quot;, tie to next note in</a>
<a name="ln873">//    same voice</a>
<a name="ln874">//---------------------------------------------------------</a>
<a name="ln875"> </a>
<a name="ln876">Note* searchTieNote114(Note* note)</a>
<a name="ln877">      {</a>
<a name="ln878">      Note* note2  = 0;</a>
<a name="ln879">      Chord* chord = note-&gt;chord();</a>
<a name="ln880">      Segment* seg = chord-&gt;segment();</a>
<a name="ln881">      Part* part   = chord-&gt;part();</a>
<a name="ln882">      int strack   = part-&gt;staves()-&gt;front()-&gt;idx() * VOICES;</a>
<a name="ln883">      int etrack   = strack + part-&gt;staves()-&gt;size() * VOICES;</a>
<a name="ln884"> </a>
<a name="ln885">      while ((seg = seg-&gt;next1(SegmentType::ChordRest))) {</a>
<a name="ln886">            for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln887">                  Element* e = seg-&gt;element(track);</a>
<a name="ln888">                  if (e == 0 || (!e-&gt;isChord()) || (e-&gt;track() != chord-&gt;track()))</a>
<a name="ln889">                        continue;</a>
<a name="ln890">                  Chord* c = toChord(e);</a>
<a name="ln891">                  int staffIdx = c-&gt;staffIdx() + c-&gt;staffMove();</a>
<a name="ln892">                  if (staffIdx != chord-&gt;staffIdx() + chord-&gt;staffMove())  // cannot happen?</a>
<a name="ln893">                        continue;</a>
<a name="ln894">                  for (Note* n : c-&gt;notes()) {</a>
<a name="ln895">                        if (n-&gt;pitch() == note-&gt;pitch()) {</a>
<a name="ln896">                              if (note2 == 0 || c-&gt;track() == chord-&gt;track())</a>
<a name="ln897">                                    note2 = n;</a>
<a name="ln898">                              }</a>
<a name="ln899">                        }</a>
<a name="ln900">                  }</a>
<a name="ln901">            if (note2)</a>
<a name="ln902">                  break;</a>
<a name="ln903">            }</a>
<a name="ln904">      return note2;</a>
<a name="ln905">      }</a>
<a name="ln906"> </a>
<a name="ln907">//---------------------------------------------------------</a>
<a name="ln908">//   absStep</a>
<a name="ln909">///   Compute absolute step.</a>
<a name="ln910">///   C D E F G A B ....</a>
<a name="ln911">//---------------------------------------------------------</a>
<a name="ln912"> </a>
<a name="ln913">int absStep(int tpc, int pitch)</a>
<a name="ln914">      {</a>
<a name="ln915">      int line     = tpc2step(tpc) + (pitch / 12) * 7;</a>
<a name="ln916">      int tpcPitch = tpc2pitch(tpc);</a>
<a name="ln917"> </a>
<a name="ln918">      if (tpcPitch &lt; 0)</a>
<a name="ln919">            line += 7;</a>
<a name="ln920">      else</a>
<a name="ln921">            line -= (tpcPitch / 12) * 7;</a>
<a name="ln922">      return line;</a>
<a name="ln923">      }</a>
<a name="ln924"> </a>
<a name="ln925">int absStep(int pitch)</a>
<a name="ln926">      {</a>
<a name="ln927">      // TODO - does this need to be key-aware?</a>
<a name="ln928">      int tpc = pitch2tpc(pitch, Key::C, Prefer::NEAREST);</a>
<a name="ln929">      return absStep(tpc, pitch);</a>
<a name="ln930">      }</a>
<a name="ln931"> </a>
<a name="ln932">int absStep(int line, ClefType clef)</a>
<a name="ln933">      {</a>
<a name="ln934">      return ClefInfo::pitchOffset(clef) - line;</a>
<a name="ln935">      }</a>
<a name="ln936"> </a>
<a name="ln937">//---------------------------------------------------------</a>
<a name="ln938">//   relStep</a>
<a name="ln939">///   Compute relative step from absolute step</a>
<a name="ln940">///   which depends on actual clef. Step 0 starts on the</a>
<a name="ln941">///   first (top) staff line.</a>
<a name="ln942">//---------------------------------------------------------</a>
<a name="ln943"> </a>
<a name="ln944">int relStep(int line, ClefType clef)</a>
<a name="ln945">      {</a>
<a name="ln946">      return ClefInfo::pitchOffset(clef) - line;</a>
<a name="ln947">      }</a>
<a name="ln948"> </a>
<a name="ln949">int relStep(int pitch, int tpc, ClefType clef)</a>
<a name="ln950">      {</a>
<a name="ln951">      return relStep(absStep(tpc, pitch), clef);</a>
<a name="ln952">      }</a>
<a name="ln953"> </a>
<a name="ln954">//---------------------------------------------------------</a>
<a name="ln955">//   pitch2step</a>
<a name="ln956">//   returns one of { 0, 1, 2, 3, 4, 5, 6 }</a>
<a name="ln957">//---------------------------------------------------------</a>
<a name="ln958"> </a>
<a name="ln959">int pitch2step(int pitch)</a>
<a name="ln960">      {</a>
<a name="ln961">      //                            C  C# D  D# E  F  F# G  G# A  A# B</a>
<a name="ln962">      static const char tab[12] = { 0, 0, 1, 1, 2, 3, 3, 4, 4, 5, 5, 6 };</a>
<a name="ln963">      return tab[pitch%12];</a>
<a name="ln964">      }</a>
<a name="ln965"> </a>
<a name="ln966">//---------------------------------------------------------</a>
<a name="ln967">//   step2pitch</a>
<a name="ln968">//   returns one of { 0, 2, 4, 5, 7, 9, 11 }</a>
<a name="ln969">//---------------------------------------------------------</a>
<a name="ln970"> </a>
<a name="ln971">int step2pitch(int step)</a>
<a name="ln972">      {</a>
<a name="ln973">      static const char tab[7] = { 0, 2, 4, 5, 7, 9, 11 };</a>
<a name="ln974">      return tab[step % 7];</a>
<a name="ln975">      }</a>
<a name="ln976"> </a>
<a name="ln977">//---------------------------------------------------------</a>
<a name="ln978">//   skipTuplet</a>
<a name="ln979">//    return segment of rightmost chord/rest in a</a>
<a name="ln980">//    (possible nested) tuplet</a>
<a name="ln981">//---------------------------------------------------------</a>
<a name="ln982"> </a>
<a name="ln983">Segment* skipTuplet(Tuplet* tuplet)</a>
<a name="ln984">      {</a>
<a name="ln985">      DurationElement* nde = tuplet-&gt;elements().back();</a>
<a name="ln986">      while (nde-&gt;isTuplet()) {</a>
<a name="ln987">            tuplet = toTuplet(nde);</a>
<a name="ln988">            nde = tuplet-&gt;elements().back();</a>
<a name="ln989">            }</a>
<a name="ln990">      return toChordRest(nde)-&gt;segment();</a>
<a name="ln991">      }</a>
<a name="ln992"> </a>
<a name="ln993">//---------------------------------------------------------</a>
<a name="ln994">//   toTimeSigString</a>
<a name="ln995">//    replace ascii with bravura symbols</a>
<a name="ln996">//---------------------------------------------------------</a>
<a name="ln997"> </a>
<a name="ln998">std::vector&lt;SymId&gt; toTimeSigString(const QString&amp; s)</a>
<a name="ln999">      {</a>
<a name="ln1000">      struct Dict {</a>
<a name="ln1001">            QChar code;</a>
<a name="ln1002">            SymId id;</a>
<a name="ln1003">            };</a>
<a name="ln1004">      static const std::vector&lt;Dict&gt; dict = {</a>
<a name="ln1005">            { 43,    SymId::timeSigPlusSmall        },  // '+'</a>
<a name="ln1006">            { 48,    SymId::timeSig0                },  // '0'</a>
<a name="ln1007">            { 49,    SymId::timeSig1                },  // '1'</a>
<a name="ln1008">            { 50,    SymId::timeSig2                },  // '2'</a>
<a name="ln1009">            { 51,    SymId::timeSig3                },  // '3'</a>
<a name="ln1010">            { 52,    SymId::timeSig4                },  // '4'</a>
<a name="ln1011">            { 53,    SymId::timeSig5                },  // '5'</a>
<a name="ln1012">            { 54,    SymId::timeSig6                },  // '6'</a>
<a name="ln1013">            { 55,    SymId::timeSig7                },  // '7'</a>
<a name="ln1014">            { 56,    SymId::timeSig8                },  // '8'</a>
<a name="ln1015">            { 57,    SymId::timeSig9                },  // '9'</a>
<a name="ln1016">            { 67,    SymId::timeSigCommon           },  // 'C'</a>
<a name="ln1017">            { 40,    SymId::timeSigParensLeftSmall  },  // '('</a>
<a name="ln1018">            { 41,    SymId::timeSigParensRightSmall },  // ')'</a>
<a name="ln1019">            { 162,   SymId::timeSigCutCommon        },  // '¢'</a>
<a name="ln1020">            { 59664, SymId::mensuralProlation1      },</a>
<a name="ln1021">            { 79,    SymId::mensuralProlation2      },  // 'O'</a>
<a name="ln1022">            { 59665, SymId::mensuralProlation2      },</a>
<a name="ln1023">            { 216,   SymId::mensuralProlation3      },  // 'Ø'</a>
<a name="ln1024">            { 59666, SymId::mensuralProlation3      },</a>
<a name="ln1025">            { 59667, SymId::mensuralProlation4      },</a>
<a name="ln1026">            { 59668, SymId::mensuralProlation5      },</a>
<a name="ln1027">            { 59670, SymId::mensuralProlation7      },</a>
<a name="ln1028">            { 59671, SymId::mensuralProlation8      },</a>
<a name="ln1029">            { 59673, SymId::mensuralProlation10     },</a>
<a name="ln1030">            { 59674, SymId::mensuralProlation11     },</a>
<a name="ln1031">            };</a>
<a name="ln1032"> </a>
<a name="ln1033">      std::vector&lt;SymId&gt; d;</a>
<a name="ln1034">      for (auto c : s) {</a>
<a name="ln1035">            for (const Dict&amp; e : dict) {</a>
<a name="ln1036">                  if (c == e.code) {</a>
<a name="ln1037">                        d.push_back(e.id);</a>
<a name="ln1038">                        break;</a>
<a name="ln1039">                        }</a>
<a name="ln1040">                  }</a>
<a name="ln1041">            }</a>
<a name="ln1042">      return d;</a>
<a name="ln1043">      }</a>
<a name="ln1044"> </a>
<a name="ln1045">//---------------------------------------------------------</a>
<a name="ln1046">//   actualTicks</a>
<a name="ln1047">//---------------------------------------------------------</a>
<a name="ln1048"> </a>
<a name="ln1049">Fraction actualTicks(Fraction duration, Tuplet* tuplet, Fraction timeStretch)</a>
<a name="ln1050">      {</a>
<a name="ln1051">      Fraction f = duration / timeStretch;</a>
<a name="ln1052">      for (Tuplet* t = tuplet; t; t = t-&gt;tuplet())</a>
<a name="ln1053">            f /= t-&gt;ratio();</a>
<a name="ln1054">      return f;</a>
<a name="ln1055">      }</a>
<a name="ln1056"> </a>
<a name="ln1057">}</a>
<a name="ln1058"> </a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
