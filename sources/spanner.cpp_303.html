
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>spanner.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2010-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;connector.h&quot;</a>
<a name="ln14">#include &quot;score.h&quot;</a>
<a name="ln15">#include &quot;spanner.h&quot;</a>
<a name="ln16">#include &quot;system.h&quot;</a>
<a name="ln17">#include &quot;chordrest.h&quot;</a>
<a name="ln18">#include &quot;chord.h&quot;</a>
<a name="ln19">#include &quot;segment.h&quot;</a>
<a name="ln20">#include &quot;measure.h&quot;</a>
<a name="ln21">#include &quot;undo.h&quot;</a>
<a name="ln22">#include &quot;staff.h&quot;</a>
<a name="ln23">#include &quot;lyrics.h&quot;</a>
<a name="ln24">#include &quot;musescoreCore.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">namespace Ms {</a>
<a name="ln27"> </a>
<a name="ln28">//-----------------------------------------------------------------------------</a>
<a name="ln29">//   @@ SpannerWriter</a>
<a name="ln30">///   Helper class for writing Spanners</a>
<a name="ln31">//-----------------------------------------------------------------------------</a>
<a name="ln32"> </a>
<a name="ln33">class SpannerWriter : public ConnectorInfoWriter {</a>
<a name="ln34">   protected:</a>
<a name="ln35">      const char* tagName() const override { return &quot;Spanner&quot;; }</a>
<a name="ln36">   public:</a>
<a name="ln37">      SpannerWriter(XmlWriter&amp; xml, const Element* current, const Spanner* spanner, int track, Fraction frac, bool start);</a>
<a name="ln38"> </a>
<a name="ln39">      static void fillSpannerPosition(Location&amp; l, const MeasureBase* endpoint, const Fraction&amp; tick, bool clipboardmode);</a>
<a name="ln40">      };</a>
<a name="ln41"> </a>
<a name="ln42">//---------------------------------------------------------</a>
<a name="ln43">//   SpannerSegment</a>
<a name="ln44">//---------------------------------------------------------</a>
<a name="ln45"> </a>
<a name="ln46">SpannerSegment::SpannerSegment(Spanner* sp, Score* s, ElementFlags f)</a>
<a name="ln47">   : Element(s, f)</a>
<a name="ln48">      {</a>
<a name="ln49">      _spanner = sp;</a>
<a name="ln50">      setSpannerSegmentType(SpannerSegmentType::SINGLE);</a>
<a name="ln51">      }</a>
<a name="ln52"> </a>
<a name="ln53">SpannerSegment::SpannerSegment(Score* s, ElementFlags f)</a>
<a name="ln54">   : Element(s, f)</a>
<a name="ln55">      {</a>
<a name="ln56">      setSpannerSegmentType(SpannerSegmentType::SINGLE);</a>
<a name="ln57">      _spanner = 0;</a>
<a name="ln58">      }</a>
<a name="ln59"> </a>
<a name="ln60">SpannerSegment::SpannerSegment(const SpannerSegment&amp; s)</a>
<a name="ln61">   : Element(s)</a>
<a name="ln62">      {</a>
<a name="ln63">      _spanner            = s._spanner;</a>
<a name="ln64">      _spannerSegmentType = s._spannerSegmentType;</a>
<a name="ln65">      _p2                 = s._p2;</a>
<a name="ln66">      _offset2            = s._offset2;</a>
<a name="ln67">      }</a>
<a name="ln68"> </a>
<a name="ln69">//---------------------------------------------------------</a>
<a name="ln70">//   mag</a>
<a name="ln71">//---------------------------------------------------------</a>
<a name="ln72"> </a>
<a name="ln73">qreal SpannerSegment::mag() const</a>
<a name="ln74">      {</a>
<a name="ln75">      if (spanner()-&gt;systemFlag())</a>
<a name="ln76">            return 1.0;</a>
<a name="ln77">      return staff() ? staff()-&gt;mag(spanner()-&gt;tick()) : 1.0;</a>
<a name="ln78">      }</a>
<a name="ln79"> </a>
<a name="ln80">Fraction SpannerSegment::tick() const</a>
<a name="ln81">      {</a>
<a name="ln82">      return _spanner ? _spanner-&gt;tick() : Fraction(0, 1);</a>
<a name="ln83">      }</a>
<a name="ln84"> </a>
<a name="ln85">//---------------------------------------------------------</a>
<a name="ln86">//   setSystem</a>
<a name="ln87">//---------------------------------------------------------</a>
<a name="ln88"> </a>
<a name="ln89">void SpannerSegment::setSystem(System* s)</a>
<a name="ln90">      {</a>
<a name="ln91">      if (system() != s) {</a>
<a name="ln92">            if (system())</a>
<a name="ln93">                  system()-&gt;remove(this);</a>
<a name="ln94">            if (s)</a>
<a name="ln95">                  s-&gt;add(this);</a>
<a name="ln96">            else</a>
<a name="ln97">                  setParent(0);</a>
<a name="ln98">            }</a>
<a name="ln99">      }</a>
<a name="ln100"> </a>
<a name="ln101">//---------------------------------------------------------</a>
<a name="ln102">//   spatiumChanged</a>
<a name="ln103">//---------------------------------------------------------</a>
<a name="ln104"> </a>
<a name="ln105">void SpannerSegment::spatiumChanged(qreal ov, qreal nv) </a>
<a name="ln106">      {</a>
<a name="ln107">      Element::spatiumChanged(ov, nv);</a>
<a name="ln108">      if (sizeIsSpatiumDependent())</a>
<a name="ln109">            _offset2 *= (nv / ov);</a>
<a name="ln110">      }</a>
<a name="ln111"> </a>
<a name="ln112">//---------------------------------------------------------</a>
<a name="ln113">//   mimeData</a>
<a name="ln114">//---------------------------------------------------------</a>
<a name="ln115"> </a>
<a name="ln116">QByteArray SpannerSegment::mimeData(const QPointF&amp; dragOffset) const</a>
<a name="ln117">      {</a>
<a name="ln118">      if (dragOffset.isNull()) // where is dragOffset used?</a>
<a name="ln119">            return spanner()-&gt;mimeData(dragOffset);</a>
<a name="ln120">      return Element::mimeData(dragOffset);</a>
<a name="ln121">      }</a>
<a name="ln122"> </a>
<a name="ln123">//---------------------------------------------------------</a>
<a name="ln124">//   propertyDelegate</a>
<a name="ln125">//---------------------------------------------------------</a>
<a name="ln126"> </a>
<a name="ln127">Element* SpannerSegment::propertyDelegate(Pid pid)</a>
<a name="ln128">      {</a>
<a name="ln129">      if (pid == Pid::COLOR || pid == Pid::VISIBLE || pid == Pid::PLACEMENT)</a>
<a name="ln130">            return spanner();</a>
<a name="ln131">      return 0;</a>
<a name="ln132">      }</a>
<a name="ln133"> </a>
<a name="ln134">//---------------------------------------------------------</a>
<a name="ln135">//   getProperty</a>
<a name="ln136">//---------------------------------------------------------</a>
<a name="ln137"> </a>
<a name="ln138">QVariant SpannerSegment::getProperty(Pid pid) const</a>
<a name="ln139">      {</a>
<a name="ln140">      if (Element* e = const_cast&lt;SpannerSegment*&gt;(this)-&gt;propertyDelegate(pid))</a>
<a name="ln141">            return e-&gt;getProperty(pid);</a>
<a name="ln142">      switch (pid) {</a>
<a name="ln143">            case Pid::OFFSET2:</a>
<a name="ln144">                  return _offset2;</a>
<a name="ln145">            default:</a>
<a name="ln146">                  return Element::getProperty(pid);</a>
<a name="ln147">            }</a>
<a name="ln148">      }</a>
<a name="ln149"> </a>
<a name="ln150">//---------------------------------------------------------</a>
<a name="ln151">//   setProperty</a>
<a name="ln152">//---------------------------------------------------------</a>
<a name="ln153"> </a>
<a name="ln154">bool SpannerSegment::setProperty(Pid pid, const QVariant&amp; v)</a>
<a name="ln155">      {</a>
<a name="ln156">      if (Element* e = propertyDelegate(pid))</a>
<a name="ln157">            return e-&gt;setProperty(pid, v);</a>
<a name="ln158">      switch (pid) {</a>
<a name="ln159">            case Pid::OFFSET2:</a>
<a name="ln160">                  _offset2 = v.toPointF();</a>
<a name="ln161">                  triggerLayoutAll();</a>
<a name="ln162">                  break;</a>
<a name="ln163">            default:</a>
<a name="ln164">                  return Element::setProperty(pid, v);</a>
<a name="ln165">            }</a>
<a name="ln166">      return true;</a>
<a name="ln167">      }</a>
<a name="ln168"> </a>
<a name="ln169">//---------------------------------------------------------</a>
<a name="ln170">//   propertyDefault</a>
<a name="ln171">//---------------------------------------------------------</a>
<a name="ln172"> </a>
<a name="ln173">QVariant SpannerSegment::propertyDefault(Pid pid) const</a>
<a name="ln174">      {</a>
<a name="ln175">      if (Element* e = const_cast&lt;SpannerSegment*&gt;(this)-&gt;propertyDelegate(pid))</a>
<a name="ln176">            return e-&gt;propertyDefault(pid);</a>
<a name="ln177">      switch (pid) {</a>
<a name="ln178">            case Pid::OFFSET2:</a>
<a name="ln179">                  return QVariant();</a>
<a name="ln180">            default:</a>
<a name="ln181">                  return Element::propertyDefault(pid);</a>
<a name="ln182">            }</a>
<a name="ln183">      }</a>
<a name="ln184"> </a>
<a name="ln185">//---------------------------------------------------------</a>
<a name="ln186">//   getPropertyStyle</a>
<a name="ln187">//---------------------------------------------------------</a>
<a name="ln188"> </a>
<a name="ln189">Sid SpannerSegment::getPropertyStyle(Pid pid) const</a>
<a name="ln190">      {</a>
<a name="ln191">      if (Element* e = const_cast&lt;SpannerSegment*&gt;(this)-&gt;propertyDelegate(pid))</a>
<a name="ln192">            return e-&gt;getPropertyStyle(pid);</a>
<a name="ln193">      return Element::getPropertyStyle(pid);</a>
<a name="ln194">      }</a>
<a name="ln195"> </a>
<a name="ln196">//---------------------------------------------------------</a>
<a name="ln197">//   propertyFlags</a>
<a name="ln198">//---------------------------------------------------------</a>
<a name="ln199"> </a>
<a name="ln200">PropertyFlags SpannerSegment::propertyFlags(Pid pid) const</a>
<a name="ln201">      {</a>
<a name="ln202">      if (Element* e = const_cast&lt;SpannerSegment*&gt;(this)-&gt;propertyDelegate(pid))</a>
<a name="ln203">            return e-&gt;propertyFlags(pid);</a>
<a name="ln204">      return Element::propertyFlags(pid);</a>
<a name="ln205">      }</a>
<a name="ln206"> </a>
<a name="ln207">//---------------------------------------------------------</a>
<a name="ln208">//   resetProperty</a>
<a name="ln209">//---------------------------------------------------------</a>
<a name="ln210"> </a>
<a name="ln211">void SpannerSegment::resetProperty(Pid pid)</a>
<a name="ln212">      {</a>
<a name="ln213">      if (Element* e = propertyDelegate(pid))</a>
<a name="ln214">            return e-&gt;resetProperty(pid);</a>
<a name="ln215">      return Element::resetProperty(pid);</a>
<a name="ln216">      }</a>
<a name="ln217"> </a>
<a name="ln218">//---------------------------------------------------------</a>
<a name="ln219">//   styleChanged</a>
<a name="ln220">//---------------------------------------------------------</a>
<a name="ln221"> </a>
<a name="ln222">void SpannerSegment::styleChanged()</a>
<a name="ln223">      {</a>
<a name="ln224">      spanner()-&gt;styleChanged();</a>
<a name="ln225">      }</a>
<a name="ln226"> </a>
<a name="ln227">//---------------------------------------------------------</a>
<a name="ln228">//   reset</a>
<a name="ln229">//---------------------------------------------------------</a>
<a name="ln230"> </a>
<a name="ln231">void SpannerSegment::reset()</a>
<a name="ln232">      {</a>
<a name="ln233">      undoChangeProperty(Pid::OFFSET2, QPointF());</a>
<a name="ln234">      Element::reset();</a>
<a name="ln235">      spanner()-&gt;reset();</a>
<a name="ln236">      }</a>
<a name="ln237"> </a>
<a name="ln238">//---------------------------------------------------------</a>
<a name="ln239">//   undoChangeProperty</a>
<a name="ln240">//---------------------------------------------------------</a>
<a name="ln241"> </a>
<a name="ln242">void SpannerSegment::undoChangeProperty(Pid pid, const QVariant&amp; val, PropertyFlags ps)</a>
<a name="ln243">      {</a>
<a name="ln244">      if (pid == Pid::AUTOPLACE &amp;&amp; (val.toBool() == true &amp;&amp; !autoplace())) {</a>
<a name="ln245">            // Switching autoplacement on. Save user-defined</a>
<a name="ln246">            // placement properties to undo stack.</a>
<a name="ln247">            undoPushProperty(Pid::OFFSET2);</a>
<a name="ln248">            // other will be saved in Element::undoChangeProperty</a>
<a name="ln249">            }</a>
<a name="ln250">      Element::undoChangeProperty(pid, val, ps);</a>
<a name="ln251">      }</a>
<a name="ln252"> </a>
<a name="ln253">//---------------------------------------------------------</a>
<a name="ln254">//   setSelected</a>
<a name="ln255">//---------------------------------------------------------</a>
<a name="ln256"> </a>
<a name="ln257">void SpannerSegment::setSelected(bool f)</a>
<a name="ln258">      {</a>
<a name="ln259">      for (SpannerSegment* ss : _spanner-&gt;spannerSegments())</a>
<a name="ln260">            ss-&gt;Element::setSelected(f);</a>
<a name="ln261">      _spanner-&gt;setSelected(f);</a>
<a name="ln262">      }</a>
<a name="ln263"> </a>
<a name="ln264">//---------------------------------------------------------</a>
<a name="ln265">//   setVisible</a>
<a name="ln266">//---------------------------------------------------------</a>
<a name="ln267"> </a>
<a name="ln268">void SpannerSegment::setVisible(bool f)</a>
<a name="ln269">      {</a>
<a name="ln270">      if (_spanner) {</a>
<a name="ln271">            for (SpannerSegment* ss : _spanner-&gt;spannerSegments())</a>
<a name="ln272">                  ss-&gt;Element::setVisible(f);</a>
<a name="ln273">            _spanner-&gt;setVisible(f);</a>
<a name="ln274">            }</a>
<a name="ln275">      else</a>
<a name="ln276">            Element::setVisible(f);</a>
<a name="ln277">      }</a>
<a name="ln278"> </a>
<a name="ln279">//---------------------------------------------------------</a>
<a name="ln280">//   setColor</a>
<a name="ln281">//---------------------------------------------------------</a>
<a name="ln282"> </a>
<a name="ln283">void SpannerSegment::setColor(const QColor&amp; col)</a>
<a name="ln284">      {</a>
<a name="ln285">      if (_spanner) {</a>
<a name="ln286">            for (SpannerSegment* ss : _spanner-&gt;spannerSegments())</a>
<a name="ln287">                  ss-&gt;_color = col;</a>
<a name="ln288">            _spanner-&gt;_color = col;</a>
<a name="ln289">            }</a>
<a name="ln290">      else</a>
<a name="ln291">            _color = col;</a>
<a name="ln292">      }</a>
<a name="ln293"> </a>
<a name="ln294">//---------------------------------------------------------</a>
<a name="ln295">//   nextSegmentElement</a>
<a name="ln296">//---------------------------------------------------------</a>
<a name="ln297"> </a>
<a name="ln298">Element* SpannerSegment::nextSegmentElement()</a>
<a name="ln299">      {</a>
<a name="ln300">      return spanner()-&gt;nextSegmentElement();</a>
<a name="ln301">      }</a>
<a name="ln302"> </a>
<a name="ln303">//---------------------------------------------------------</a>
<a name="ln304">//   prevSegmentElement</a>
<a name="ln305">//---------------------------------------------------------</a>
<a name="ln306"> </a>
<a name="ln307">Element* SpannerSegment::prevSegmentElement()</a>
<a name="ln308">      {</a>
<a name="ln309">      return spanner()-&gt;prevSegmentElement();</a>
<a name="ln310">      }</a>
<a name="ln311"> </a>
<a name="ln312">//---------------------------------------------------------</a>
<a name="ln313">//   accessibleInfo</a>
<a name="ln314">//---------------------------------------------------------</a>
<a name="ln315"> </a>
<a name="ln316">QString SpannerSegment::accessibleInfo() const</a>
<a name="ln317">      {</a>
<a name="ln318">      return spanner()-&gt;accessibleInfo();</a>
<a name="ln319">      }</a>
<a name="ln320"> </a>
<a name="ln321">//---------------------------------------------------------</a>
<a name="ln322">//   triggerLayout</a>
<a name="ln323">//---------------------------------------------------------</a>
<a name="ln324"> </a>
<a name="ln325">void SpannerSegment::triggerLayout() const</a>
<a name="ln326">      {</a>
<a name="ln327">      if (_spanner)</a>
<a name="ln328">            _spanner-&gt;triggerLayout();</a>
<a name="ln329">      }</a>
<a name="ln330"> </a>
<a name="ln331">//---------------------------------------------------------</a>
<a name="ln332">//   Spanner</a>
<a name="ln333">//---------------------------------------------------------</a>
<a name="ln334"> </a>
<a name="ln335">Spanner::Spanner(Score* s, ElementFlags f)</a>
<a name="ln336">   : Element(s, f)</a>
<a name="ln337">      {</a>
<a name="ln338">      }</a>
<a name="ln339"> </a>
<a name="ln340">Spanner::Spanner(const Spanner&amp; s)</a>
<a name="ln341">   : Element(s)</a>
<a name="ln342">      {</a>
<a name="ln343">      _anchor       = s._anchor;</a>
<a name="ln344">      _startElement = s._startElement;</a>
<a name="ln345">      _endElement   = s._endElement;</a>
<a name="ln346">      _tick         = s._tick;</a>
<a name="ln347">      _ticks        = s._ticks;</a>
<a name="ln348">      _track2       = s._track2;</a>
<a name="ln349">      }</a>
<a name="ln350"> </a>
<a name="ln351">Spanner::~Spanner()</a>
<a name="ln352">      {</a>
<a name="ln353">      qDeleteAll(segments);</a>
<a name="ln354">      qDeleteAll(unusedSegments);</a>
<a name="ln355">      }</a>
<a name="ln356"> </a>
<a name="ln357">//---------------------------------------------------------</a>
<a name="ln358">//   mag</a>
<a name="ln359">//---------------------------------------------------------</a>
<a name="ln360"> </a>
<a name="ln361">qreal Spanner::mag() const</a>
<a name="ln362">      {</a>
<a name="ln363">      if (systemFlag())</a>
<a name="ln364">            return 1.0;</a>
<a name="ln365">      return staff() ? staff()-&gt;mag(tick()) : 1.0;</a>
<a name="ln366">      }</a>
<a name="ln367"> </a>
<a name="ln368">//---------------------------------------------------------</a>
<a name="ln369">//   add</a>
<a name="ln370">//---------------------------------------------------------</a>
<a name="ln371"> </a>
<a name="ln372">void Spanner::add(Element* e)</a>
<a name="ln373">      {</a>
<a name="ln374">      SpannerSegment* ls = toSpannerSegment(e);</a>
<a name="ln375">      ls-&gt;setSpanner(this);</a>
<a name="ln376">      ls-&gt;setSelected(selected());</a>
<a name="ln377">      ls-&gt;setTrack(track());</a>
<a name="ln378">//      ls-&gt;setAutoplace(autoplace());</a>
<a name="ln379">      segments.push_back(ls);</a>
<a name="ln380">      }</a>
<a name="ln381"> </a>
<a name="ln382">//---------------------------------------------------------</a>
<a name="ln383">//   remove</a>
<a name="ln384">//---------------------------------------------------------</a>
<a name="ln385"> </a>
<a name="ln386">void Spanner::remove(Element* e)</a>
<a name="ln387">      {</a>
<a name="ln388">      SpannerSegment* ss = toSpannerSegment(e);</a>
<a name="ln389">      if (ss-&gt;system())</a>
<a name="ln390">            ss-&gt;system()-&gt;remove(ss);</a>
<a name="ln391">      segments.erase(std::remove(segments.begin(), segments.end(), ss), segments.end());</a>
<a name="ln392">      }</a>
<a name="ln393"> </a>
<a name="ln394">//---------------------------------------------------------</a>
<a name="ln395">//   removeUnmanaged</a>
<a name="ln396">//</a>
<a name="ln397">//    Remove the Spanner and its segments from objects which may know about them</a>
<a name="ln398">//</a>
<a name="ln399">//    This method and the following are used for spanners which are contained within compound elements</a>
<a name="ln400">//    which manage their parts themselves without using the standard management supplied by Score;</a>
<a name="ln401">//    Example can be the LyricsLine within a Lyrics element or the FiguredBassLine within a FiguredBass</a>
<a name="ln402">//    (not implemented yet).</a>
<a name="ln403">//---------------------------------------------------------</a>
<a name="ln404"> </a>
<a name="ln405">void Spanner::removeUnmanaged()</a>
<a name="ln406">      {</a>
<a name="ln407">      for (SpannerSegment* ss : spannerSegments())</a>
<a name="ln408">            if (ss-&gt;system()) {</a>
<a name="ln409">//                  ss-&gt;system()-&gt;remove(ss);</a>
<a name="ln410">                  ss-&gt;setSystem(nullptr);</a>
<a name="ln411">                  }</a>
<a name="ln412">      score()-&gt;removeUnmanagedSpanner(this);</a>
<a name="ln413">      }</a>
<a name="ln414"> </a>
<a name="ln415">//---------------------------------------------------------</a>
<a name="ln416">//   insertTimeUnmanaged</a>
<a name="ln417">//---------------------------------------------------------</a>
<a name="ln418"> </a>
<a name="ln419">void Spanner::insertTimeUnmanaged(const Fraction&amp; fromTick, const Fraction&amp; len)</a>
<a name="ln420">      {</a>
<a name="ln421">      Fraction newTick1 = tick();</a>
<a name="ln422">      Fraction newTick2 = tick2();</a>
<a name="ln423"> </a>
<a name="ln424">      // check spanner start and end point</a>
<a name="ln425">      if (len &gt; Fraction(0,1)) {          // adding time</a>
<a name="ln426">            if (tick() &gt; fromTick)        // start after insertion point: shift start to right</a>
<a name="ln427">                  newTick1 += len;</a>
<a name="ln428">            if (tick2() &gt; fromTick)       // end after insertion point: shift end to right</a>
<a name="ln429">                  newTick2 += len;</a>
<a name="ln430">            }</a>
<a name="ln431">      if (len &lt; Fraction(0,1)) {          // removing time</a>
<a name="ln432">            Fraction toTick = fromTick - len;</a>
<a name="ln433">            if (tick() &gt; fromTick) {      // start after beginning of removed time</a>
<a name="ln434">                  if (tick() &lt; toTick) {  // start within removed time: bring start at removing point</a>
<a name="ln435">                        if (parent()) {</a>
<a name="ln436">                              parent()-&gt;remove(this);</a>
<a name="ln437">                              return;</a>
<a name="ln438">                              }</a>
<a name="ln439">                        else</a>
<a name="ln440">                              newTick1 = fromTick;</a>
<a name="ln441">                        }</a>
<a name="ln442">                  else                    // start after removed time: shift start to left</a>
<a name="ln443">                        newTick1 += len;</a>
<a name="ln444">                  }</a>
<a name="ln445">            if (tick2() &gt; fromTick) {     // end after start of removed time</a>
<a name="ln446">                  if (tick2() &lt; toTick)   // end within removed time: bring end at removing point</a>
<a name="ln447">                        newTick2 = fromTick;</a>
<a name="ln448">                  else                    // end after removed time: shift end to left</a>
<a name="ln449">                        newTick2 += len;</a>
<a name="ln450">                  }</a>
<a name="ln451">            }</a>
<a name="ln452"> </a>
<a name="ln453">      // update properties as required</a>
<a name="ln454">      if (newTick2 &lt;= newTick1) {               // if no longer any span: remove it</a>
<a name="ln455">            if (parent())</a>
<a name="ln456">                  parent()-&gt;remove(this);</a>
<a name="ln457">            }</a>
<a name="ln458">      else {                                    // if either TICKS or TICK did change, update property</a>
<a name="ln459">            if (newTick2-newTick1 != tick2()- tick())</a>
<a name="ln460">                  setProperty(Pid::SPANNER_TICKS, newTick2-newTick1);</a>
<a name="ln461">            if (newTick1 != tick())</a>
<a name="ln462">                  setProperty(Pid::SPANNER_TICK, newTick1);</a>
<a name="ln463">            }</a>
<a name="ln464">      }</a>
<a name="ln465"> </a>
<a name="ln466">//---------------------------------------------------------</a>
<a name="ln467">//   scanElements</a>
<a name="ln468">//    used in palettes</a>
<a name="ln469">//---------------------------------------------------------</a>
<a name="ln470"> </a>
<a name="ln471">void Spanner::scanElements(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln472">      {</a>
<a name="ln473">      Q_UNUSED(all);</a>
<a name="ln474">      for (SpannerSegment* seg : segments)</a>
<a name="ln475">            seg-&gt;scanElements(data, func, true);</a>
<a name="ln476">      }</a>
<a name="ln477"> </a>
<a name="ln478">//---------------------------------------------------------</a>
<a name="ln479">//   setScore</a>
<a name="ln480">//---------------------------------------------------------</a>
<a name="ln481"> </a>
<a name="ln482">void Spanner::setScore(Score* s)</a>
<a name="ln483">      {</a>
<a name="ln484">      Element::setScore(s);</a>
<a name="ln485">      foreach(SpannerSegment* seg, segments)</a>
<a name="ln486">            seg-&gt;setScore(s);</a>
<a name="ln487">      }</a>
<a name="ln488"> </a>
<a name="ln489">//---------------------------------------------------------</a>
<a name="ln490">//   getProperty</a>
<a name="ln491">//---------------------------------------------------------</a>
<a name="ln492"> </a>
<a name="ln493">QVariant Spanner::getProperty(Pid propertyId) const</a>
<a name="ln494">      {</a>
<a name="ln495">      switch (propertyId) {</a>
<a name="ln496">            case Pid::SPANNER_TICK:</a>
<a name="ln497">                  return _tick;</a>
<a name="ln498">            case Pid::SPANNER_TICKS:</a>
<a name="ln499">                  return _ticks;</a>
<a name="ln500">            case Pid::SPANNER_TRACK2:</a>
<a name="ln501">                  return track2();</a>
<a name="ln502">            case Pid::ANCHOR:</a>
<a name="ln503">                  return int(anchor());</a>
<a name="ln504">            case Pid::LOCATION_STAVES:</a>
<a name="ln505">                  return (track2() / VOICES) - (track() / VOICES);</a>
<a name="ln506">            case Pid::LOCATION_VOICES:</a>
<a name="ln507">                  return (track2() % VOICES) - (track() / VOICES);</a>
<a name="ln508">            case Pid::LOCATION_FRACTIONS:</a>
<a name="ln509">                  return _ticks;</a>
<a name="ln510">            case Pid::LOCATION_MEASURES:</a>
<a name="ln511">            case Pid::LOCATION_GRACE:</a>
<a name="ln512">            case Pid::LOCATION_NOTE:</a>
<a name="ln513">                  return Location::getLocationProperty(propertyId, startElement(), endElement());</a>
<a name="ln514">            default:</a>
<a name="ln515">                  break;</a>
<a name="ln516">            }</a>
<a name="ln517">      return Element::getProperty(propertyId);</a>
<a name="ln518">      }</a>
<a name="ln519"> </a>
<a name="ln520">//---------------------------------------------------------</a>
<a name="ln521">//   setProperty</a>
<a name="ln522">//---------------------------------------------------------</a>
<a name="ln523"> </a>
<a name="ln524">bool Spanner::setProperty(Pid propertyId, const QVariant&amp; v)</a>
<a name="ln525">      {</a>
<a name="ln526">      switch (propertyId) {</a>
<a name="ln527">            case Pid::SPANNER_TICK:</a>
<a name="ln528">                  setTick(v.value&lt;Fraction&gt;());</a>
<a name="ln529">                  setStartElement(0);     // invalidate</a>
<a name="ln530">                  setEndElement(0);       //</a>
<a name="ln531">                  if (score() &amp;&amp; score()-&gt;spannerMap().removeSpanner(this))</a>
<a name="ln532">                        score()-&gt;addSpanner(this);</a>
<a name="ln533">                  break;</a>
<a name="ln534">            case Pid::SPANNER_TICKS:</a>
<a name="ln535">                  setTicks(v.value&lt;Fraction&gt;());</a>
<a name="ln536">                  setEndElement(0);       // invalidate</a>
<a name="ln537">                  break;</a>
<a name="ln538">            case Pid::TRACK:</a>
<a name="ln539">                  setTrack(v.toInt());</a>
<a name="ln540">                  setStartElement(0);     // invalidate</a>
<a name="ln541">                  break;</a>
<a name="ln542">            case Pid::SPANNER_TRACK2:</a>
<a name="ln543">                  setTrack2(v.toInt());</a>
<a name="ln544">                  setEndElement(0);       // invalidate</a>
<a name="ln545">                  break;</a>
<a name="ln546">            case Pid::ANCHOR:</a>
<a name="ln547">                  setAnchor(Anchor(v.toInt()));</a>
<a name="ln548">                  break;</a>
<a name="ln549">            default:</a>
<a name="ln550">                  return Element::setProperty(propertyId, v);</a>
<a name="ln551">            }</a>
<a name="ln552">      triggerLayout();</a>
<a name="ln553">      return true;</a>
<a name="ln554">      }</a>
<a name="ln555"> </a>
<a name="ln556">//---------------------------------------------------------</a>
<a name="ln557">//   propertyDefault</a>
<a name="ln558">//---------------------------------------------------------</a>
<a name="ln559"> </a>
<a name="ln560">QVariant Spanner::propertyDefault(Pid propertyId) const</a>
<a name="ln561">      {</a>
<a name="ln562">      switch (propertyId) {</a>
<a name="ln563">            case Pid::ANCHOR:</a>
<a name="ln564">                  return int(Anchor::SEGMENT);</a>
<a name="ln565">            default:</a>
<a name="ln566">                  break;</a>
<a name="ln567">            }</a>
<a name="ln568">      return Element::propertyDefault(propertyId);</a>
<a name="ln569">      }</a>
<a name="ln570"> </a>
<a name="ln571">//---------------------------------------------------------</a>
<a name="ln572">//   computeStartElement</a>
<a name="ln573">//---------------------------------------------------------</a>
<a name="ln574"> </a>
<a name="ln575">void Spanner::computeStartElement()</a>
<a name="ln576">      {</a>
<a name="ln577">      switch (_anchor) {</a>
<a name="ln578">            case Anchor::SEGMENT: {</a>
<a name="ln579">                  Segment* seg = score()-&gt;tick2segmentMM(tick(), false, SegmentType::ChordRest);</a>
<a name="ln580">                  int strack = (track() / VOICES) * VOICES;</a>
<a name="ln581">                  int etrack = strack + VOICES;</a>
<a name="ln582">                  _startElement = 0;</a>
<a name="ln583">                  if (seg) {</a>
<a name="ln584">                        for (int t = strack; t &lt; etrack; ++t) {</a>
<a name="ln585">                              if (seg-&gt;element(t)) {</a>
<a name="ln586">                                    _startElement = seg-&gt;element(t);</a>
<a name="ln587">                                    break;</a>
<a name="ln588">                                    }</a>
<a name="ln589">                              }</a>
<a name="ln590">                        }</a>
<a name="ln591">                  }</a>
<a name="ln592">                  break;</a>
<a name="ln593"> </a>
<a name="ln594">            case Anchor::MEASURE:</a>
<a name="ln595">                  _startElement = score()-&gt;tick2measure(tick());</a>
<a name="ln596">                  break;</a>
<a name="ln597"> </a>
<a name="ln598">            case Anchor::CHORD:</a>
<a name="ln599">            case Anchor::NOTE:</a>
<a name="ln600">                  return;</a>
<a name="ln601">            }</a>
<a name="ln602">      }</a>
<a name="ln603"> </a>
<a name="ln604">//---------------------------------------------------------</a>
<a name="ln605">//   computeEndElement</a>
<a name="ln606">//---------------------------------------------------------</a>
<a name="ln607"> </a>
<a name="ln608">void Spanner::computeEndElement()</a>
<a name="ln609">      {</a>
<a name="ln610">      if (score()-&gt;isPalette()) {</a>
<a name="ln611">            // return immediately to prevent lots of</a>
<a name="ln612">            // &quot;no element found&quot; messages from appearing</a>
<a name="ln613">            _endElement = nullptr;</a>
<a name="ln614">            return;</a>
<a name="ln615">            }</a>
<a name="ln616"> </a>
<a name="ln617">      switch (_anchor) {</a>
<a name="ln618">            case Anchor::SEGMENT: {</a>
<a name="ln619">                  if (track2() == -1)</a>
<a name="ln620">                        setTrack2(track());</a>
<a name="ln621">                  if (ticks().isZero() &amp;&amp; isTextLine() &amp;&amp; parent())   // special case palette</a>
<a name="ln622">                        setTicks(score()-&gt;lastSegment()-&gt;tick() - _tick);</a>
<a name="ln623"> </a>
<a name="ln624">                  if (isLyricsLine() &amp;&amp; toLyricsLine(this)-&gt;isEndMelisma()) {</a>
<a name="ln625">                        // lyrics endTick should already indicate the segment we want</a>
<a name="ln626">                        // except for TEMP_MELISMA_TICKS case</a>
<a name="ln627">                        Lyrics* l = toLyricsLine(this)-&gt;lyrics();</a>
<a name="ln628">                        Fraction tick = (l-&gt;ticks().ticks() == Lyrics::TEMP_MELISMA_TICKS) ? l-&gt;tick() : l-&gt;endTick();</a>
<a name="ln629">                        Segment* s = score()-&gt;tick2segment(tick, true, SegmentType::ChordRest);</a>
<a name="ln630">                        if (!s) {</a>
<a name="ln631">                              qDebug(&quot;%s no end segment for tick %d&quot;, name(), tick.ticks());</a>
<a name="ln632">                              return;</a>
<a name="ln633">                              }</a>
<a name="ln634">                        int t = trackZeroVoice(track2());</a>
<a name="ln635">                        // take the first chordrest we can find;</a>
<a name="ln636">                        // linePos will substitute one in current voice if available</a>
<a name="ln637">                        for (int v = 0; v &lt; VOICES; ++v) {</a>
<a name="ln638">                              _endElement = s-&gt;element(t + v);</a>
<a name="ln639">                              if (_endElement)</a>
<a name="ln640">                                    break;</a>
<a name="ln641">                              }</a>
<a name="ln642">                        }</a>
<a name="ln643">                  else {</a>
<a name="ln644">                        // find last cr on this staff that ends before tick2</a>
<a name="ln645">                        _endElement = score()-&gt;findCRinStaff(tick2(), track2() / VOICES);</a>
<a name="ln646">                        }</a>
<a name="ln647">                  if (!_endElement) {</a>
<a name="ln648">                        qDebug(&quot;%s no end element for tick %d&quot;, name(), tick2().ticks());</a>
<a name="ln649">                        return;</a>
<a name="ln650">                        }</a>
<a name="ln651"> </a>
<a name="ln652">                  if (!endCR()-&gt;measure()-&gt;isMMRest()) {</a>
<a name="ln653">                        ChordRest* cr = endCR();</a>
<a name="ln654">                        Fraction nticks = cr-&gt;tick() + cr-&gt;actualTicks() - _tick;</a>
<a name="ln655">                        if ((_ticks - nticks).isNotZero()) {</a>
<a name="ln656">                              qDebug(&quot;%s ticks changed, %d -&gt; %d&quot;, name(), _ticks.ticks(), nticks.ticks());</a>
<a name="ln657">                              setTicks(nticks);</a>
<a name="ln658">                              if (isOttava())</a>
<a name="ln659">                                    staff()-&gt;updateOttava();</a>
<a name="ln660">                              }</a>
<a name="ln661">                        }</a>
<a name="ln662">                  }</a>
<a name="ln663">                  break;</a>
<a name="ln664"> </a>
<a name="ln665">            case Anchor::MEASURE:</a>
<a name="ln666">                  _endElement = score()-&gt;tick2measure(tick2() - Fraction(1, 1920));</a>
<a name="ln667">                  if (!_endElement) {</a>
<a name="ln668">                        qDebug(&quot;Spanner::computeEndElement(), measure not found for tick %d\n&quot;, tick2().ticks()-1);</a>
<a name="ln669">                        _endElement = score()-&gt;lastMeasure();</a>
<a name="ln670">                        }</a>
<a name="ln671">                  break;</a>
<a name="ln672"> </a>
<a name="ln673">            case Anchor::CHORD:</a>
<a name="ln674">            case Anchor::NOTE:</a>
<a name="ln675">                  break;</a>
<a name="ln676">            }</a>
<a name="ln677">      }</a>
<a name="ln678"> </a>
<a name="ln679">//---------------------------------------------------------</a>
<a name="ln680">//   startElementFromSpanner</a>
<a name="ln681">//</a>
<a name="ln682">//    Given a Spanner and an end element, determines a start element suitable for the end</a>
<a name="ln683">//    element of a new Spanner, so that it is 'parallel' to the old one.</a>
<a name="ln684">//    Can be used while cloning a linked Spanner, to update the cloned spanner start and end elements</a>
<a name="ln685">//    (Spanner(const Spanner&amp;) copies start and end elements from the original to the copy).</a>
<a name="ln686">//    NOTES:      Only spanners with Anchor::NOTE are currently supported.</a>
<a name="ln687">//                Going back from end to start ensures the 'other' anchor of this is already set up</a>
<a name="ln688">//                      (for instance, while cloning staves)</a>
<a name="ln689">//---------------------------------------------------------</a>
<a name="ln690"> </a>
<a name="ln691">Note* Spanner::startElementFromSpanner(Spanner* sp, Element* newEnd)</a>
<a name="ln692">      {</a>
<a name="ln693">      if (sp-&gt;anchor() != Anchor::NOTE)</a>
<a name="ln694">            return nullptr;</a>
<a name="ln695"> </a>
<a name="ln696">      Note*  oldStart   = toNote(sp-&gt;startElement());</a>
<a name="ln697">      Note*  oldEnd     = toNote(sp-&gt;endElement());</a>
<a name="ln698">      if (oldStart == nullptr || oldEnd == nullptr)</a>
<a name="ln699">            return nullptr;</a>
<a name="ln700">      Note*  newStart   = nullptr;</a>
<a name="ln701">      Score* score      = newEnd-&gt;score();</a>
<a name="ln702">      // determine the track where to expect the 'parallel' start element</a>
<a name="ln703">      int   newTrack    = (newEnd-&gt;track() - oldEnd-&gt;track()) + oldStart-&gt;track();</a>
<a name="ln704">      // look in notes linked to oldStart for a note with the</a>
<a name="ln705">      // same score as new score and appropriate track</a>
<a name="ln706">      for (ScoreElement* newEl : oldStart-&gt;linkList())</a>
<a name="ln707">            if (toNote(newEl)-&gt;score() == score &amp;&amp; toNote(newEl)-&gt;track() == newTrack) {</a>
<a name="ln708">                  newStart = toNote(newEl);</a>
<a name="ln709">                  break;</a>
<a name="ln710">            }</a>
<a name="ln711">      return newStart;</a>
<a name="ln712">      }</a>
<a name="ln713"> </a>
<a name="ln714">//---------------------------------------------------------</a>
<a name="ln715">//   endElementFromSpanner</a>
<a name="ln716">//</a>
<a name="ln717">//    Given a Spanner and a start element, determines an end element suitable for the start</a>
<a name="ln718">//    element of a new Spanner, so that it is 'parallel' to the old one.</a>
<a name="ln719">//    Can be used while cloning a linked Spanner, to update the cloned spanner start and end elements</a>
<a name="ln720">//    (Spanner(const Spanner&amp;) copies start and end elements from the original to the copy).</a>
<a name="ln721">//    NOTES:      Only spanners with Anchor::NOTE are currently supported.</a>
<a name="ln722">//---------------------------------------------------------</a>
<a name="ln723"> </a>
<a name="ln724">Note* Spanner::endElementFromSpanner(Spanner* sp, Element* newStart)</a>
<a name="ln725">      {</a>
<a name="ln726">      if (sp-&gt;anchor() != Anchor::NOTE)</a>
<a name="ln727">            return nullptr;</a>
<a name="ln728"> </a>
<a name="ln729">      Note*  oldStart   = toNote(sp-&gt;startElement());</a>
<a name="ln730">      Note*  oldEnd     = toNote(sp-&gt;endElement());</a>
<a name="ln731">      if (oldStart == nullptr || oldEnd == nullptr)</a>
<a name="ln732">            return nullptr;</a>
<a name="ln733">      Note*  newEnd     = nullptr;</a>
<a name="ln734">      Score* score      = newStart-&gt;score();</a>
<a name="ln735">      // determine the track where to expect the 'parallel' start element</a>
<a name="ln736">      int   newTrack    = newStart-&gt;track() + (oldEnd-&gt;track() - oldStart-&gt;track());</a>
<a name="ln737">      // look in notes linked to oldEnd for a note with the</a>
<a name="ln738">      // same score as new score and appropriate track</a>
<a name="ln739">      for (ScoreElement* newEl : oldEnd-&gt;linkList())</a>
<a name="ln740">            if (toNote(newEl)-&gt;score() == score &amp;&amp; toNote(newEl)-&gt;track() == newTrack) {</a>
<a name="ln741">                  newEnd = toNote(newEl);</a>
<a name="ln742">                  break;</a>
<a name="ln743">            }</a>
<a name="ln744">      return newEnd;</a>
<a name="ln745">      }</a>
<a name="ln746"> </a>
<a name="ln747">//---------------------------------------------------------</a>
<a name="ln748">//   setNoteSpan</a>
<a name="ln749">//</a>
<a name="ln750">//    Sets up all the variables congruent with given start and end note anchors.</a>
<a name="ln751">//---------------------------------------------------------</a>
<a name="ln752"> </a>
<a name="ln753">void  Spanner::setNoteSpan(Note* startNote, Note* endNote)</a>
<a name="ln754">      {</a>
<a name="ln755">      if (_anchor != Anchor::NOTE)</a>
<a name="ln756">            return;</a>
<a name="ln757"> </a>
<a name="ln758">      setScore(startNote-&gt;score());</a>
<a name="ln759">      setParent(startNote);</a>
<a name="ln760">      setStartElement(startNote);</a>
<a name="ln761">      setEndElement(endNote);</a>
<a name="ln762">      setTick(startNote-&gt;chord()-&gt;tick());</a>
<a name="ln763">      setTick2(endNote-&gt;chord()-&gt;tick());</a>
<a name="ln764">      setTrack(startNote-&gt;track());</a>
<a name="ln765">      setTrack2(endNote-&gt;track());</a>
<a name="ln766">      }</a>
<a name="ln767"> </a>
<a name="ln768">//---------------------------------------------------------</a>
<a name="ln769">//   startChord</a>
<a name="ln770">//---------------------------------------------------------</a>
<a name="ln771"> </a>
<a name="ln772">Chord* Spanner::startChord()</a>
<a name="ln773">      {</a>
<a name="ln774">      Q_ASSERT(_anchor == Anchor::CHORD);</a>
<a name="ln775">      if (!_startElement)</a>
<a name="ln776">            _startElement = score()-&gt;findCR(tick(), track());</a>
<a name="ln777">      return toChord(_startElement);</a>
<a name="ln778">      }</a>
<a name="ln779"> </a>
<a name="ln780">//---------------------------------------------------------</a>
<a name="ln781">//   endChord</a>
<a name="ln782">//---------------------------------------------------------</a>
<a name="ln783"> </a>
<a name="ln784">Chord* Spanner::endChord()</a>
<a name="ln785">      {</a>
<a name="ln786">      Q_ASSERT(_anchor == Anchor::CHORD);</a>
<a name="ln787"> </a>
<a name="ln788">      if (!_endElement &amp;&amp; type() == ElementType::SLUR) {</a>
<a name="ln789">            Segment* s = score()-&gt;tick2segmentMM(tick2(), false, SegmentType::ChordRest);</a>
<a name="ln790">            _endElement = s ? toChordRest(s-&gt;element(track2())) : nullptr;</a>
<a name="ln791">            if (!_endElement-&gt;isChord())</a>
<a name="ln792">                  _endElement = nullptr;</a>
<a name="ln793">            }</a>
<a name="ln794">      return toChord(_endElement);</a>
<a name="ln795">      }</a>
<a name="ln796"> </a>
<a name="ln797">//---------------------------------------------------------</a>
<a name="ln798">//   startCR</a>
<a name="ln799">//---------------------------------------------------------</a>
<a name="ln800"> </a>
<a name="ln801">ChordRest* Spanner::startCR()</a>
<a name="ln802">      {</a>
<a name="ln803">      Q_ASSERT(_anchor == Anchor::SEGMENT || _anchor == Anchor::CHORD);</a>
<a name="ln804">      if (!_startElement || _startElement-&gt;score() != score())</a>
<a name="ln805">            _startElement = score()-&gt;findCR(tick(), track());</a>
<a name="ln806">      return toChordRest(_startElement);</a>
<a name="ln807">      }</a>
<a name="ln808"> </a>
<a name="ln809">//---------------------------------------------------------</a>
<a name="ln810">//   endCR</a>
<a name="ln811">//---------------------------------------------------------</a>
<a name="ln812"> </a>
<a name="ln813">ChordRest* Spanner::endCR()</a>
<a name="ln814">      {</a>
<a name="ln815">      Q_ASSERT(_anchor == Anchor::SEGMENT || _anchor == Anchor::CHORD);</a>
<a name="ln816">      if ((!_endElement || _endElement-&gt;score() != score())) {</a>
<a name="ln817">            Segment* s  = score()-&gt;tick2segmentMM(tick2(), false, SegmentType::ChordRest);</a>
<a name="ln818">            const int tr2 = effectiveTrack2();</a>
<a name="ln819">            _endElement = s ? toChordRest(s-&gt;element(tr2)) : nullptr;</a>
<a name="ln820">            }</a>
<a name="ln821">      return toChordRest(_endElement);</a>
<a name="ln822">      }</a>
<a name="ln823"> </a>
<a name="ln824">//---------------------------------------------------------</a>
<a name="ln825">//   startSegment</a>
<a name="ln826">//---------------------------------------------------------</a>
<a name="ln827"> </a>
<a name="ln828">Segment* Spanner::startSegment() const</a>
<a name="ln829">      {</a>
<a name="ln830">      Q_ASSERT(score() != NULL);</a>
<a name="ln831">      return score()-&gt;tick2rightSegment(tick());</a>
<a name="ln832">      }</a>
<a name="ln833"> </a>
<a name="ln834">//---------------------------------------------------------</a>
<a name="ln835">//   endSegment</a>
<a name="ln836">//---------------------------------------------------------</a>
<a name="ln837"> </a>
<a name="ln838">Segment* Spanner::endSegment() const</a>
<a name="ln839">      {</a>
<a name="ln840">      return score()-&gt;tick2leftSegment(tick2());</a>
<a name="ln841">      }</a>
<a name="ln842"> </a>
<a name="ln843">//---------------------------------------------------------</a>
<a name="ln844">//   startMeasure</a>
<a name="ln845">//---------------------------------------------------------</a>
<a name="ln846"> </a>
<a name="ln847">Measure* Spanner::startMeasure() const</a>
<a name="ln848">      {</a>
<a name="ln849">      return toMeasure(_startElement);</a>
<a name="ln850">      }</a>
<a name="ln851"> </a>
<a name="ln852">//---------------------------------------------------------</a>
<a name="ln853">//   endMeasure</a>
<a name="ln854">//---------------------------------------------------------</a>
<a name="ln855"> </a>
<a name="ln856">Measure* Spanner::endMeasure() const</a>
<a name="ln857">      {</a>
<a name="ln858">      return toMeasure(_endElement);</a>
<a name="ln859">      }</a>
<a name="ln860"> </a>
<a name="ln861">//---------------------------------------------------------</a>
<a name="ln862">//   setSelected</a>
<a name="ln863">//---------------------------------------------------------</a>
<a name="ln864"> </a>
<a name="ln865">void Spanner::setSelected(bool f)</a>
<a name="ln866">      {</a>
<a name="ln867">      for (SpannerSegment* ss : spannerSegments())</a>
<a name="ln868">            ss-&gt;Element::setSelected(f);</a>
<a name="ln869">      Element::setSelected(f);</a>
<a name="ln870">      }</a>
<a name="ln871"> </a>
<a name="ln872">//---------------------------------------------------------</a>
<a name="ln873">//   setVisible</a>
<a name="ln874">//---------------------------------------------------------</a>
<a name="ln875"> </a>
<a name="ln876">void Spanner::setVisible(bool f)</a>
<a name="ln877">      {</a>
<a name="ln878">      for (SpannerSegment* ss : spannerSegments())</a>
<a name="ln879">            ss-&gt;Element::setVisible(f);</a>
<a name="ln880">      Element::setVisible(f);</a>
<a name="ln881">      }</a>
<a name="ln882"> </a>
<a name="ln883">//---------------------------------------------------------</a>
<a name="ln884">//   setAutoplace</a>
<a name="ln885">//---------------------------------------------------------</a>
<a name="ln886"> </a>
<a name="ln887">void Spanner::setAutoplace(bool f)</a>
<a name="ln888">      {</a>
<a name="ln889">      for (SpannerSegment* ss : spannerSegments())</a>
<a name="ln890">            ss-&gt;Element::setAutoplace(f);</a>
<a name="ln891">      Element::setAutoplace(f);</a>
<a name="ln892">      }</a>
<a name="ln893"> </a>
<a name="ln894">//---------------------------------------------------------</a>
<a name="ln895">//   setColor</a>
<a name="ln896">//---------------------------------------------------------</a>
<a name="ln897"> </a>
<a name="ln898">void Spanner::setColor(const QColor&amp; col)</a>
<a name="ln899">      {</a>
<a name="ln900">      for (SpannerSegment* ss : spannerSegments())</a>
<a name="ln901">            ss-&gt;setColor(col);</a>
<a name="ln902">      _color = col;</a>
<a name="ln903">      }</a>
<a name="ln904"> </a>
<a name="ln905">//---------------------------------------------------------</a>
<a name="ln906">//   setStartElement</a>
<a name="ln907">//---------------------------------------------------------</a>
<a name="ln908"> </a>
<a name="ln909">void Spanner::setStartElement(Element* e)</a>
<a name="ln910">      {</a>
<a name="ln911">#ifndef NDEBUG</a>
<a name="ln912">      if (_anchor == Anchor::NOTE)</a>
<a name="ln913">            Q_ASSERT(!e || e-&gt;type() == ElementType::NOTE);</a>
<a name="ln914">#endif</a>
<a name="ln915">      _startElement = e;</a>
<a name="ln916">      }</a>
<a name="ln917"> </a>
<a name="ln918">//---------------------------------------------------------</a>
<a name="ln919">//   setEndElement</a>
<a name="ln920">//---------------------------------------------------------</a>
<a name="ln921"> </a>
<a name="ln922">void Spanner::setEndElement(Element* e)</a>
<a name="ln923">      {</a>
<a name="ln924">#ifndef NDEBUG</a>
<a name="ln925">      if (_anchor == Anchor::NOTE)</a>
<a name="ln926">            Q_ASSERT(!e || e-&gt;type() == ElementType::NOTE);</a>
<a name="ln927">#endif</a>
<a name="ln928">      _endElement = e;</a>
<a name="ln929">      }</a>
<a name="ln930"> </a>
<a name="ln931">//---------------------------------------------------------</a>
<a name="ln932">//   nextSpanner</a>
<a name="ln933">//---------------------------------------------------------</a>
<a name="ln934"> </a>
<a name="ln935">Spanner* Spanner::nextSpanner(Element* e, int activeStaff)</a>
<a name="ln936">      {</a>
<a name="ln937">    std::multimap&lt;int, Spanner*&gt; mmap = score()-&gt;spanner();</a>
<a name="ln938">          auto range = mmap.equal_range(tick().ticks());</a>
<a name="ln939">          if (range.first != range.second) { // range not empty</a>
<a name="ln940">                for (auto i = range.first; i != range.second; ++i) {</a>
<a name="ln941">                      if (i-&gt;second == e) {</a>
<a name="ln942">                            while (i != range.second) {</a>
<a name="ln943">                                  ++i;</a>
<a name="ln944">                                  if (i == range.second)</a>
<a name="ln945">                                        return nullptr;</a>
<a name="ln946">                                  Spanner* s =  i-&gt;second;</a>
<a name="ln947">                                  Element* st = s-&gt;startElement();</a>
<a name="ln948">                                  if (!st)</a>
<a name="ln949">                                        continue;</a>
<a name="ln950">                                  if (s-&gt;startSegment() == toSpanner(e)-&gt;startSegment()) {</a>
<a name="ln951">                                        if (st-&gt;staffIdx() == activeStaff)</a>
<a name="ln952">                                              return s;</a>
<a name="ln953">#if 1</a>
<a name="ln954">                                        else if (st-&gt;isMeasure() &amp;&amp; activeStaff == 0)</a>
<a name="ln955">                                              return s;</a>
<a name="ln956">#else</a>
<a name="ln957">                                        // TODO: when navigating system spanners, check firstVisibleStaff()?</a>
<a name="ln958">                                        // currently, information about which staves are hidden</a>
<a name="ln959">                                        // is not exposed through navigation,</a>
<a name="ln960">                                        // so it may make more sense to continue to navigate systems elements</a>
<a name="ln961">                                        // only when actually on staff 0</a>
<a name="ln962">                                        // see also https://musescore.org/en/node/301496</a>
<a name="ln963">                                        // and https://github.com/musescore/MuseScore/pull/5755</a>
<a name="ln964">                                        else if (st-&gt;isMeasure()) {</a>
<a name="ln965">                                              SpannerSegment* ss = s-&gt;frontSegment();</a>
<a name="ln966">                                              int top = ss &amp;&amp; ss-&gt;system() ? ss-&gt;system()-&gt;firstVisibleStaff() : 0;</a>
<a name="ln967">                                              if (activeStaff == top)</a>
<a name="ln968">                                                    return s;</a>
<a name="ln969">                                              }</a>
<a name="ln970">#endif</a>
<a name="ln971">                                        }</a>
<a name="ln972">                                  //else</a>
<a name="ln973">                                        //return nullptr;</a>
<a name="ln974">                                  }</a>
<a name="ln975">                            break;</a>
<a name="ln976">                           /* else {</a>
<a name="ln977">                                  break;</a>
<a name="ln978">                                  }*/</a>
<a name="ln979">                            }</a>
<a name="ln980">                      }</a>
<a name="ln981">                 }</a>
<a name="ln982">          return nullptr;</a>
<a name="ln983">      }</a>
<a name="ln984"> </a>
<a name="ln985">//---------------------------------------------------------</a>
<a name="ln986">//   prevSpanner</a>
<a name="ln987">//---------------------------------------------------------</a>
<a name="ln988"> </a>
<a name="ln989">Spanner* Spanner::prevSpanner(Element* e, int activeStaff)</a>
<a name="ln990">      {</a>
<a name="ln991">      std::multimap&lt;int, Spanner*&gt; mmap = score()-&gt;spanner();</a>
<a name="ln992">      auto range = mmap.equal_range(tick().ticks());</a>
<a name="ln993">      if (range.first != range.second) { // range not empty</a>
<a name="ln994">            for (auto i = range.first; i != range.second; ++i) {</a>
<a name="ln995">                  if (i-&gt;second == e) {</a>
<a name="ln996">                        if (i == range.first)</a>
<a name="ln997">                              return nullptr;</a>
<a name="ln998">                        while (i != range.first) {</a>
<a name="ln999">                              --i;</a>
<a name="ln1000">                              Spanner* s =  i-&gt;second;</a>
<a name="ln1001">                              Element* st = s-&gt;startElement();</a>
<a name="ln1002">                              if (s-&gt;startSegment() == toSpanner(e)-&gt;startSegment()) {</a>
<a name="ln1003">                                    if (st-&gt;staffIdx() == activeStaff)</a>
<a name="ln1004">                                          return s;</a>
<a name="ln1005">#if 1</a>
<a name="ln1006">                                    else if (st-&gt;isMeasure() &amp;&amp; activeStaff == 0)</a>
<a name="ln1007">                                          return s;</a>
<a name="ln1008">#else</a>
<a name="ln1009">                                    // TODO: see nextSpanner()</a>
<a name="ln1010">                                    else if (st-&gt;isMeasure()) {</a>
<a name="ln1011">                                          SpannerSegment* ss = s-&gt;frontSegment();</a>
<a name="ln1012">                                          int top = ss &amp;&amp; ss-&gt;system() ? ss-&gt;system()-&gt;firstVisibleStaff() : 0;</a>
<a name="ln1013">                                          if (activeStaff == top)</a>
<a name="ln1014">                                                return s;</a>
<a name="ln1015">                                          }</a>
<a name="ln1016">#endif</a>
<a name="ln1017">                                    }</a>
<a name="ln1018">                              }</a>
<a name="ln1019">                        break;</a>
<a name="ln1020">                        }</a>
<a name="ln1021">                  }</a>
<a name="ln1022">            }</a>
<a name="ln1023">      return nullptr;</a>
<a name="ln1024">      }</a>
<a name="ln1025"> </a>
<a name="ln1026">//---------------------------------------------------------</a>
<a name="ln1027">//   nextSegmentElement</a>
<a name="ln1028">//---------------------------------------------------------</a>
<a name="ln1029"> </a>
<a name="ln1030">Element* Spanner::nextSegmentElement()</a>
<a name="ln1031">      {</a>
<a name="ln1032">      Segment* s = startSegment();</a>
<a name="ln1033">      if (s)</a>
<a name="ln1034">            return s-&gt;firstElement(staffIdx());</a>
<a name="ln1035">      return score()-&gt;lastElement();</a>
<a name="ln1036">      }</a>
<a name="ln1037"> </a>
<a name="ln1038">//---------------------------------------------------------</a>
<a name="ln1039">//   prevSegmentElement</a>
<a name="ln1040">//---------------------------------------------------------</a>
<a name="ln1041"> </a>
<a name="ln1042">Element* Spanner::prevSegmentElement()</a>
<a name="ln1043">      {</a>
<a name="ln1044">      Segment* s = endSegment();</a>
<a name="ln1045">      if (s)</a>
<a name="ln1046">            return s-&gt;lastElement(staffIdx());</a>
<a name="ln1047">      return score()-&gt;firstElement();</a>
<a name="ln1048">      }</a>
<a name="ln1049"> </a>
<a name="ln1050">//---------------------------------------------------------</a>
<a name="ln1051">//   setTick</a>
<a name="ln1052">//---------------------------------------------------------</a>
<a name="ln1053"> </a>
<a name="ln1054">void Spanner::setTick(const Fraction&amp; v)</a>
<a name="ln1055">      {</a>
<a name="ln1056">      _tick = v;</a>
<a name="ln1057">      if (score())</a>
<a name="ln1058">            score()-&gt;spannerMap().setDirty();</a>
<a name="ln1059">      }</a>
<a name="ln1060"> </a>
<a name="ln1061">//---------------------------------------------------------</a>
<a name="ln1062">//   setTick2</a>
<a name="ln1063">//---------------------------------------------------------</a>
<a name="ln1064"> </a>
<a name="ln1065">void Spanner::setTick2(const Fraction&amp; f)</a>
<a name="ln1066">      {</a>
<a name="ln1067">      setTicks(f - _tick);</a>
<a name="ln1068">      }</a>
<a name="ln1069"> </a>
<a name="ln1070">//---------------------------------------------------------</a>
<a name="ln1071">//   setTicks</a>
<a name="ln1072">//---------------------------------------------------------</a>
<a name="ln1073"> </a>
<a name="ln1074">void Spanner::setTicks(const Fraction&amp; f)</a>
<a name="ln1075">      {</a>
<a name="ln1076">      _ticks = f;</a>
<a name="ln1077">      if (score())</a>
<a name="ln1078">            score()-&gt;spannerMap().setDirty();</a>
<a name="ln1079">      }</a>
<a name="ln1080"> </a>
<a name="ln1081">//---------------------------------------------------------</a>
<a name="ln1082">//   triggerLayout</a>
<a name="ln1083">//---------------------------------------------------------</a>
<a name="ln1084"> </a>
<a name="ln1085">void Spanner::triggerLayout() const</a>
<a name="ln1086">      {</a>
<a name="ln1087">      // Spanners do not have parent even when added to a score, so can't check parent here</a>
<a name="ln1088">      const int tr2 = effectiveTrack2();</a>
<a name="ln1089">      score()-&gt;setLayout(_tick, _tick + _ticks, staffIdx(), track2staff(tr2), this);</a>
<a name="ln1090">      }</a>
<a name="ln1091"> </a>
<a name="ln1092">void Spanner::triggerLayoutAll() const</a>
<a name="ln1093">      {</a>
<a name="ln1094">      // Spanners do not have parent even when added to a score, so can't check parent here</a>
<a name="ln1095">      score()-&gt;setLayoutAll(staffIdx(), this);</a>
<a name="ln1096"> </a>
<a name="ln1097">      const int tr2 = track2();</a>
<a name="ln1098">      if (tr2 != -1 &amp;&amp; tr2 != track())</a>
<a name="ln1099">            score()-&gt;setLayoutAll(track2staff(tr2), this);</a>
<a name="ln1100">      }</a>
<a name="ln1101"> </a>
<a name="ln1102">//---------------------------------------------------------</a>
<a name="ln1103">//   pushUnusedSegment</a>
<a name="ln1104">//---------------------------------------------------------</a>
<a name="ln1105"> </a>
<a name="ln1106">void Spanner::pushUnusedSegment(SpannerSegment* seg)</a>
<a name="ln1107">      {</a>
<a name="ln1108">      if (!seg)</a>
<a name="ln1109">            return;</a>
<a name="ln1110">      seg-&gt;setSystem(nullptr);</a>
<a name="ln1111">      unusedSegments.push_back(seg);</a>
<a name="ln1112">      }</a>
<a name="ln1113"> </a>
<a name="ln1114">//---------------------------------------------------------</a>
<a name="ln1115">//   popUnusedSegment</a>
<a name="ln1116">//    Take the next unused segment for reusing it.</a>
<a name="ln1117">//    If there is no unused segments left returns nullptr.</a>
<a name="ln1118">//---------------------------------------------------------</a>
<a name="ln1119"> </a>
<a name="ln1120">SpannerSegment* Spanner::popUnusedSegment()</a>
<a name="ln1121">      {</a>
<a name="ln1122">      if (unusedSegments.empty())</a>
<a name="ln1123">            return nullptr;</a>
<a name="ln1124">      SpannerSegment* seg = unusedSegments.front();</a>
<a name="ln1125">      unusedSegments.pop_front();</a>
<a name="ln1126">      return seg;</a>
<a name="ln1127">      }</a>
<a name="ln1128"> </a>
<a name="ln1129">//---------------------------------------------------------</a>
<a name="ln1130">//   reuse</a>
<a name="ln1131">//    called when segment from unusedSegments is added</a>
<a name="ln1132">//    back to the spanner.</a>
<a name="ln1133">//---------------------------------------------------------</a>
<a name="ln1134"> </a>
<a name="ln1135">void Spanner::reuse(SpannerSegment* seg)</a>
<a name="ln1136">      {</a>
<a name="ln1137">      add(seg);</a>
<a name="ln1138">      }</a>
<a name="ln1139"> </a>
<a name="ln1140">//---------------------------------------------------------</a>
<a name="ln1141">//   reuseSegments</a>
<a name="ln1142">//    Adds \p number segments from unusedSegments to this</a>
<a name="ln1143">//    spanner via reuse() call. Returns number of new</a>
<a name="ln1144">//    segments that still need to be created, that is,</a>
<a name="ln1145">//    returns (number - nMovedSegments).</a>
<a name="ln1146">//---------------------------------------------------------</a>
<a name="ln1147"> </a>
<a name="ln1148">int Spanner::reuseSegments(int number)</a>
<a name="ln1149">      {</a>
<a name="ln1150">      while (number &gt; 0) {</a>
<a name="ln1151">            SpannerSegment* seg = popUnusedSegment();</a>
<a name="ln1152">            if (!seg)</a>
<a name="ln1153">                  break;</a>
<a name="ln1154">            reuse(seg);</a>
<a name="ln1155">            --number;</a>
<a name="ln1156">            }</a>
<a name="ln1157">      return number;</a>
<a name="ln1158">      }</a>
<a name="ln1159"> </a>
<a name="ln1160">//---------------------------------------------------------</a>
<a name="ln1161">//   fixupSegments</a>
<a name="ln1162">//    Makes number of segments match targetNumber.</a>
<a name="ln1163">//    Tries to reuse unused segments. If there are no</a>
<a name="ln1164">//    unused segments left, uses \p createSegment to create</a>
<a name="ln1165">//    the needed segments.</a>
<a name="ln1166">//    Previously unused segments are added via reuse() call</a>
<a name="ln1167">//---------------------------------------------------------</a>
<a name="ln1168"> </a>
<a name="ln1169">void Spanner::fixupSegments(unsigned int targetNumber, std::function&lt;SpannerSegment*()&gt; createSegment)</a>
<a name="ln1170">      {</a>
<a name="ln1171">      const int diff = targetNumber - int(nsegments());</a>
<a name="ln1172">      if (diff == 0)</a>
<a name="ln1173">            return;</a>
<a name="ln1174">      if (diff &gt; 0) {</a>
<a name="ln1175">            const int ncreate = reuseSegments(diff);</a>
<a name="ln1176">            for (int i = 0; i &lt; ncreate; ++i)</a>
<a name="ln1177">                  add(createSegment());</a>
<a name="ln1178">            }</a>
<a name="ln1179">      else { // diff &lt; 0</a>
<a name="ln1180">            const int nremove = -diff;</a>
<a name="ln1181">            for (int i = 0; i &lt; nremove; ++i) {</a>
<a name="ln1182">                  SpannerSegment* seg = segments.back();</a>
<a name="ln1183">                  segments.pop_back();</a>
<a name="ln1184">                  pushUnusedSegment(seg);</a>
<a name="ln1185">                  }</a>
<a name="ln1186">            }</a>
<a name="ln1187">      }</a>
<a name="ln1188"> </a>
<a name="ln1189">//---------------------------------------------------------</a>
<a name="ln1190">//   eraseSpannerSegments</a>
<a name="ln1191">//    Completely erase all spanner segments, both used and</a>
<a name="ln1192">//    unused.</a>
<a name="ln1193">//---------------------------------------------------------</a>
<a name="ln1194"> </a>
<a name="ln1195">void Spanner::eraseSpannerSegments()</a>
<a name="ln1196">      {</a>
<a name="ln1197">      qDeleteAll(segments);</a>
<a name="ln1198">      qDeleteAll(unusedSegments);</a>
<a name="ln1199">      segments.clear();</a>
<a name="ln1200">      unusedSegments.clear();</a>
<a name="ln1201">      }</a>
<a name="ln1202"> </a>
<a name="ln1203">//---------------------------------------------------------</a>
<a name="ln1204">//   layoutSystem</a>
<a name="ln1205">//---------------------------------------------------------</a>
<a name="ln1206"> </a>
<a name="ln1207">SpannerSegment* Spanner::layoutSystem(System*)</a>
<a name="ln1208">      {</a>
<a name="ln1209">      qDebug(&quot; %s&quot;, name());</a>
<a name="ln1210">      return 0;</a>
<a name="ln1211">      }</a>
<a name="ln1212"> </a>
<a name="ln1213">//---------------------------------------------------------</a>
<a name="ln1214">//   getNextLayoutSystemSegment</a>
<a name="ln1215">//---------------------------------------------------------</a>
<a name="ln1216"> </a>
<a name="ln1217">SpannerSegment* Spanner::getNextLayoutSystemSegment(System* system, std::function&lt;SpannerSegment*()&gt; createSegment)</a>
<a name="ln1218">      {</a>
<a name="ln1219">      SpannerSegment* seg = nullptr;</a>
<a name="ln1220">      for (SpannerSegment* ss : spannerSegments()) {</a>
<a name="ln1221">            if (!ss-&gt;system()) {</a>
<a name="ln1222">                  seg = ss;</a>
<a name="ln1223">                  break;</a>
<a name="ln1224">                  }</a>
<a name="ln1225">            }</a>
<a name="ln1226">      if (!seg) {</a>
<a name="ln1227">            if ((seg = popUnusedSegment()))</a>
<a name="ln1228">                  reuse(seg);</a>
<a name="ln1229">            else {</a>
<a name="ln1230">                  seg = createSegment();</a>
<a name="ln1231">                  Q_ASSERT(seg);</a>
<a name="ln1232">                  add(seg);</a>
<a name="ln1233">                  }</a>
<a name="ln1234">            }</a>
<a name="ln1235">      seg-&gt;setSystem(system);</a>
<a name="ln1236">      seg-&gt;setSpanner(this);</a>
<a name="ln1237">      seg-&gt;setTrack(track());</a>
<a name="ln1238">      seg-&gt;setVisible(visible());</a>
<a name="ln1239">      return seg;</a>
<a name="ln1240">      }</a>
<a name="ln1241"> </a>
<a name="ln1242">//---------------------------------------------------------</a>
<a name="ln1243">//   layoutSystemsDone</a>
<a name="ln1244">//    Called after layout of all systems is done so precise</a>
<a name="ln1245">//    number of systems for this spanner becomes available.</a>
<a name="ln1246">//---------------------------------------------------------</a>
<a name="ln1247"> </a>
<a name="ln1248">void Spanner::layoutSystemsDone()</a>
<a name="ln1249">      {</a>
<a name="ln1250">      std::vector&lt;SpannerSegment*&gt; validSegments;</a>
<a name="ln1251">      for (SpannerSegment* seg : segments) {</a>
<a name="ln1252">            if (seg-&gt;system())</a>
<a name="ln1253">                  validSegments.push_back(seg);</a>
<a name="ln1254">            else // TODO: score()-&gt;selection().remove(ss); needed?</a>
<a name="ln1255">                  pushUnusedSegment(seg);</a>
<a name="ln1256">            }</a>
<a name="ln1257">      segments = std::move(validSegments);</a>
<a name="ln1258">      }</a>
<a name="ln1259"> </a>
<a name="ln1260">//--------------------------------------------------</a>
<a name="ln1261">//   fraction</a>
<a name="ln1262">//---------------------------------------------------------</a>
<a name="ln1263"> </a>
<a name="ln1264">static Fraction fraction(const XmlWriter&amp; xml, const Element* current, const Fraction&amp; t)</a>
<a name="ln1265">      {</a>
<a name="ln1266">      Fraction tick(t);</a>
<a name="ln1267">      if (!xml.clipboardmode()) {</a>
<a name="ln1268">            const Measure* m = toMeasure(current-&gt;findMeasure());</a>
<a name="ln1269">            if (m)</a>
<a name="ln1270">                  tick -= m-&gt;tick();</a>
<a name="ln1271">            }</a>
<a name="ln1272">      return tick;</a>
<a name="ln1273">      }</a>
<a name="ln1274"> </a>
<a name="ln1275">//---------------------------------------------------------</a>
<a name="ln1276">//   Spanner::readProperties</a>
<a name="ln1277">//---------------------------------------------------------</a>
<a name="ln1278"> </a>
<a name="ln1279">bool Spanner::readProperties(XmlReader&amp; e)</a>
<a name="ln1280">      {</a>
<a name="ln1281">      const QStringRef tag(e.name());</a>
<a name="ln1282">      if (e.pasteMode()) {</a>
<a name="ln1283">            if (tag == &quot;ticks_f&quot;) {</a>
<a name="ln1284">                  setTicks(e.readFraction());</a>
<a name="ln1285">                  return true;</a>
<a name="ln1286">                  }</a>
<a name="ln1287">            }</a>
<a name="ln1288">      return Element::readProperties(e);</a>
<a name="ln1289">      }</a>
<a name="ln1290"> </a>
<a name="ln1291">//---------------------------------------------------------</a>
<a name="ln1292">//   Spanner::writeProperties</a>
<a name="ln1293">//---------------------------------------------------------</a>
<a name="ln1294"> </a>
<a name="ln1295">void Spanner::writeProperties(XmlWriter&amp; xml) const</a>
<a name="ln1296">      {</a>
<a name="ln1297">      if (xml.clipboardmode())</a>
<a name="ln1298">            xml.tag(&quot;ticks_f&quot;, ticks());</a>
<a name="ln1299">      Element::writeProperties(xml);</a>
<a name="ln1300">      }</a>
<a name="ln1301"> </a>
<a name="ln1302">//--------------------------------------------------</a>
<a name="ln1303">//   Spanner::writeSpannerStart</a>
<a name="ln1304">//---------------------------------------------------------</a>
<a name="ln1305"> </a>
<a name="ln1306">void Spanner::writeSpannerStart(XmlWriter&amp; xml, const Element* current, int track, Fraction tick) const</a>
<a name="ln1307">      {</a>
<a name="ln1308">      Fraction frac = fraction(xml, current, tick);</a>
<a name="ln1309">      SpannerWriter w(xml, current, this, track, frac, true);</a>
<a name="ln1310">      w.write();</a>
<a name="ln1311">      }</a>
<a name="ln1312"> </a>
<a name="ln1313">//--------------------------------------------------</a>
<a name="ln1314">//   Spanner::writeSpannerEnd</a>
<a name="ln1315">//---------------------------------------------------------</a>
<a name="ln1316"> </a>
<a name="ln1317">void Spanner::writeSpannerEnd(XmlWriter&amp; xml, const Element* current, int track, Fraction tick) const</a>
<a name="ln1318">      {</a>
<a name="ln1319">      Fraction frac = fraction(xml, current, tick);</a>
<a name="ln1320">      SpannerWriter w(xml, current, this, track, frac, false);</a>
<a name="ln1321">      w.write();</a>
<a name="ln1322">      }</a>
<a name="ln1323"> </a>
<a name="ln1324">//--------------------------------------------------</a>
<a name="ln1325">//   Spanner::readSpanner</a>
<a name="ln1326">//---------------------------------------------------------</a>
<a name="ln1327"> </a>
<a name="ln1328">void Spanner::readSpanner(XmlReader&amp; e, Element* current, int track)</a>
<a name="ln1329">      {</a>
<a name="ln1330">      std::unique_ptr&lt;ConnectorInfoReader&gt; info(new ConnectorInfoReader(e, current, track));</a>
<a name="ln1331">      ConnectorInfoReader::readConnector(std::move(info), e);</a>
<a name="ln1332">      }</a>
<a name="ln1333"> </a>
<a name="ln1334">//--------------------------------------------------</a>
<a name="ln1335">//   Spanner::readSpanner</a>
<a name="ln1336">//---------------------------------------------------------</a>
<a name="ln1337"> </a>
<a name="ln1338">void Spanner::readSpanner(XmlReader&amp; e, Score* current, int track)</a>
<a name="ln1339">      {</a>
<a name="ln1340">      std::unique_ptr&lt;ConnectorInfoReader&gt; info(new ConnectorInfoReader(e, current, track));</a>
<a name="ln1341">      ConnectorInfoReader::readConnector(std::move(info), e);</a>
<a name="ln1342">      }</a>
<a name="ln1343"> </a>
<a name="ln1344">//---------------------------------------------------------</a>
<a name="ln1345">//   SpannerWriter::fillSpannerPosition</a>
<a name="ln1346">//---------------------------------------------------------</a>
<a name="ln1347"> </a>
<a name="ln1348">void SpannerWriter::fillSpannerPosition(Location&amp; l, const MeasureBase* m, const Fraction&amp; tick, bool clipboardmode)</a>
<a name="ln1349">      {</a>
<a name="ln1350">      if (clipboardmode) {</a>
<a name="ln1351">            l.setMeasure(0);</a>
<a name="ln1352">            l.setFrac(tick);</a>
<a name="ln1353">            }</a>
<a name="ln1354">      else {</a>
<a name="ln1355">            if (!m) {</a>
<a name="ln1356">                  qWarning(&quot;fillSpannerPosition: couldn't find spanner's endpoint's measure&quot;);</a>
<a name="ln1357">                  l.setMeasure(0);</a>
<a name="ln1358">                  l.setFrac(tick);</a>
<a name="ln1359">                  return;</a>
<a name="ln1360">                  }</a>
<a name="ln1361">            l.setMeasure(m-&gt;measureIndex());</a>
<a name="ln1362">            l.setFrac(tick - m-&gt;tick());</a>
<a name="ln1363">            }</a>
<a name="ln1364">      }</a>
<a name="ln1365"> </a>
<a name="ln1366">//---------------------------------------------------------</a>
<a name="ln1367">//   SpannerWriter::SpannerWriter</a>
<a name="ln1368">//---------------------------------------------------------</a>
<a name="ln1369"> </a>
<a name="ln1370">SpannerWriter::SpannerWriter(XmlWriter&amp; xml, const Element* current, const Spanner* sp, int track, Fraction frac, bool start)</a>
<a name="ln1371">   : ConnectorInfoWriter(xml, current, sp, track, frac)</a>
<a name="ln1372">      {</a>
<a name="ln1373">      const bool clipboardmode = xml.clipboardmode();</a>
<a name="ln1374">      if (!sp-&gt;startElement() || !sp-&gt;endElement()) {</a>
<a name="ln1375">            qWarning(&quot;SpannerWriter: spanner (%s) doesn't have an endpoint!&quot;, sp-&gt;name());</a>
<a name="ln1376">            return;</a>
<a name="ln1377">            }</a>
<a name="ln1378">      if (current-&gt;isMeasure() || current-&gt;isSegment() || (sp-&gt;startElement()-&gt;type() != current-&gt;type())) {</a>
<a name="ln1379">            // (The latter is the hairpins' case, for example, though they are</a>
<a name="ln1380">            // covered by the other checks too.)</a>
<a name="ln1381">            // We cannot determine position of the spanner from its start/end</a>
<a name="ln1382">            // elements and will try to obtain this info from the spanner itself.</a>
<a name="ln1383">            if (!start) {</a>
<a name="ln1384">                  _prevLoc.setTrack(sp-&gt;track());</a>
<a name="ln1385">                  Measure* m = sp-&gt;score()-&gt;tick2measure(sp-&gt;tick());</a>
<a name="ln1386">                  fillSpannerPosition(_prevLoc, m, sp-&gt;tick(), clipboardmode);</a>
<a name="ln1387">                  }</a>
<a name="ln1388">            else {</a>
<a name="ln1389">                  const int track2 = (sp-&gt;track2() != -1) ? sp-&gt;track2() : sp-&gt;track();</a>
<a name="ln1390">                  _nextLoc.setTrack(track2);</a>
<a name="ln1391">                  Measure* m = sp-&gt;score()-&gt;tick2measure(sp-&gt;tick2());</a>
<a name="ln1392">                  fillSpannerPosition(_nextLoc, m, sp-&gt;tick2(), clipboardmode);</a>
<a name="ln1393">                  }</a>
<a name="ln1394">            }</a>
<a name="ln1395">      else {</a>
<a name="ln1396">            // We can obtain the spanner position info from its start/end</a>
<a name="ln1397">            // elements and will prefer this source of information.</a>
<a name="ln1398">            // Reason: some spanners contain no or wrong information (e.g. Ties).</a>
<a name="ln1399">            if (!start)</a>
<a name="ln1400">                  updateLocation(sp-&gt;startElement(), _prevLoc, clipboardmode);</a>
<a name="ln1401">            else</a>
<a name="ln1402">                  updateLocation(sp-&gt;endElement(), _nextLoc, clipboardmode);</a>
<a name="ln1403">            }</a>
<a name="ln1404">      }</a>
<a name="ln1405"> </a>
<a name="ln1406">//---------------------------------------------------------</a>
<a name="ln1407">//   autoplaceSpannerSegment</a>
<a name="ln1408">//---------------------------------------------------------</a>
<a name="ln1409"> </a>
<a name="ln1410">void SpannerSegment::autoplaceSpannerSegment()</a>
<a name="ln1411">      {</a>
<a name="ln1412">      if (!parent()) {</a>
<a name="ln1413">            setOffset(QPointF());</a>
<a name="ln1414">            return;</a>
<a name="ln1415">            }</a>
<a name="ln1416">      if (isStyled(Pid::OFFSET))</a>
<a name="ln1417">            setOffset(spanner()-&gt;propertyDefault(Pid::OFFSET).toPointF());</a>
<a name="ln1418"> </a>
<a name="ln1419">      if (spanner()-&gt;anchor() == Spanner::Anchor::NOTE)</a>
<a name="ln1420">            return;</a>
<a name="ln1421"> </a>
<a name="ln1422">      // rebase vertical offset on drag</a>
<a name="ln1423">      qreal rebase = 0.0;</a>
<a name="ln1424">      if (offsetChanged() != OffsetChange::NONE)</a>
<a name="ln1425">            rebase = rebaseOffset();</a>
<a name="ln1426"> </a>
<a name="ln1427">      if (autoplace()) {</a>
<a name="ln1428">            qreal sp = score()-&gt;spatium();</a>
<a name="ln1429">            if (!systemFlag() &amp;&amp; !spanner()-&gt;systemFlag())</a>
<a name="ln1430">                  sp *= staff()-&gt;mag(spanner()-&gt;tick());</a>
<a name="ln1431">            qreal md = minDistance().val() * sp;</a>
<a name="ln1432">            bool above = spanner()-&gt;placeAbove();</a>
<a name="ln1433">            SkylineLine sl(!above);</a>
<a name="ln1434">            Shape sh = shape();</a>
<a name="ln1435">            sl.add(sh.translated(pos()));</a>
<a name="ln1436">            qreal yd = 0.0;</a>
<a name="ln1437">            if (above) {</a>
<a name="ln1438">                  qreal d  = system()-&gt;topDistance(staffIdx(), sl);</a>
<a name="ln1439">                  if (d &gt; -md)</a>
<a name="ln1440">                        yd = -(d + md);</a>
<a name="ln1441">                  }</a>
<a name="ln1442">            else {</a>
<a name="ln1443">                  qreal d  = system()-&gt;bottomDistance(staffIdx(), sl);</a>
<a name="ln1444">                  if (d &gt; -md)</a>
<a name="ln1445">                        yd = d + md;</a>
<a name="ln1446">                  }</a>
<a name="ln1447">            if (yd != 0.0) {</a>
<a name="ln1448">                  if (offsetChanged() != OffsetChange::NONE) {</a>
<a name="ln1449">                        // user moved element within the skyline</a>
<a name="ln1450">                        // we may need to adjust minDistance, yd, and/or offset</a>
<a name="ln1451">                        qreal adj = pos().y() + rebase;</a>
<a name="ln1452">                        bool inStaff = above ? sh.bottom() + adj &gt; 0.0 : sh.top() + adj &lt; staff()-&gt;height();</a>
<a name="ln1453">                        rebaseMinDistance(md, yd, sp, rebase, above, inStaff);</a>
<a name="ln1454">                        }</a>
<a name="ln1455">                  rypos() += yd;</a>
<a name="ln1456">                  }</a>
<a name="ln1457">            }</a>
<a name="ln1458">      setOffsetChanged(false);</a>
<a name="ln1459">      }</a>
<a name="ln1460"> </a>
<a name="ln1461">//---------------------------------------------------------</a>
<a name="ln1462">//   undoChangeProperty</a>
<a name="ln1463">//---------------------------------------------------------</a>
<a name="ln1464"> </a>
<a name="ln1465">void Spanner::undoChangeProperty(Pid id, const QVariant&amp; v, PropertyFlags ps)</a>
<a name="ln1466">      {</a>
<a name="ln1467">      if (id == Pid::PLACEMENT) {</a>
<a name="ln1468">            ScoreElement::undoChangeProperty(id, v, ps);</a>
<a name="ln1469">            // change offset of all segments if styled</a>
<a name="ln1470"> </a>
<a name="ln1471">            for (SpannerSegment* s : segments) {</a>
<a name="ln1472">                  if (s-&gt;isStyled(Pid::OFFSET)) {</a>
<a name="ln1473">                        s-&gt;setOffset(s-&gt;propertyDefault(Pid::OFFSET).toPointF());</a>
<a name="ln1474">                        s-&gt;triggerLayout();</a>
<a name="ln1475">                        }</a>
<a name="ln1476">                  }</a>
<a name="ln1477">            MuseScoreCore::mscoreCore-&gt;updateInspector();</a>
<a name="ln1478">            return;</a>
<a name="ln1479">            }</a>
<a name="ln1480">      Element::undoChangeProperty(id, v, ps);</a>
<a name="ln1481">      }</a>
<a name="ln1482"> </a>
<a name="ln1483">}</a>
<a name="ln1484"> </a>

</code></pre>
<div class="balloon" rel="816"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v592/" target="_blank">V592</a> The expression was enclosed by parentheses twice: ((expression)). One pair of parentheses is unnecessary or misprint is present.</p></div>
<div class="balloon" rel="1209"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1375"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'warning' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
