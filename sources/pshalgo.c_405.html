
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>pshalgo.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***************************************************************************/</a>
<a name="ln2">/*                                                                         */</a>
<a name="ln3">/*  pshalgo.c                                                              */</a>
<a name="ln4">/*                                                                         */</a>
<a name="ln5">/*    PostScript hinting algorithm (body).                                 */</a>
<a name="ln6">/*                                                                         */</a>
<a name="ln7">/*  Copyright 2001-2015 by                                                 */</a>
<a name="ln8">/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</a>
<a name="ln9">/*                                                                         */</a>
<a name="ln10">/*  This file is part of the FreeType project, and may only be used        */</a>
<a name="ln11">/*  modified and distributed under the terms of the FreeType project       */</a>
<a name="ln12">/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</a>
<a name="ln13">/*  this file you indicate that you have read the license and              */</a>
<a name="ln14">/*  understand and accept it fully.                                        */</a>
<a name="ln15">/*                                                                         */</a>
<a name="ln16">/***************************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;ft2build.h&gt;</a>
<a name="ln20">#include FT_INTERNAL_OBJECTS_H</a>
<a name="ln21">#include FT_INTERNAL_DEBUG_H</a>
<a name="ln22">#include FT_INTERNAL_CALC_H</a>
<a name="ln23">#include &quot;pshalgo.h&quot;</a>
<a name="ln24"> </a>
<a name="ln25">#include &quot;pshnterr.h&quot;</a>
<a name="ln26"> </a>
<a name="ln27"> </a>
<a name="ln28">#undef  FT_COMPONENT</a>
<a name="ln29">#define FT_COMPONENT  trace_pshalgo2</a>
<a name="ln30"> </a>
<a name="ln31"> </a>
<a name="ln32">#ifdef DEBUG_HINTER</a>
<a name="ln33">  PSH_Hint_Table  ps_debug_hint_table = NULL;</a>
<a name="ln34">  PSH_HintFunc    ps_debug_hint_func  = NULL;</a>
<a name="ln35">  PSH_Glyph       ps_debug_glyph      = NULL;</a>
<a name="ln36">#endif</a>
<a name="ln37"> </a>
<a name="ln38"> </a>
<a name="ln39">#define  COMPUTE_INFLEXS  /* compute inflection points to optimize `S' */</a>
<a name="ln40">                          /* and similar glyphs                        */</a>
<a name="ln41"> </a>
<a name="ln42"> </a>
<a name="ln43">  /*************************************************************************/</a>
<a name="ln44">  /*************************************************************************/</a>
<a name="ln45">  /*****                                                               *****/</a>
<a name="ln46">  /*****                  BASIC HINTS RECORDINGS                       *****/</a>
<a name="ln47">  /*****                                                               *****/</a>
<a name="ln48">  /*************************************************************************/</a>
<a name="ln49">  /*************************************************************************/</a>
<a name="ln50"> </a>
<a name="ln51">  /* return true if two stem hints overlap */</a>
<a name="ln52">  static FT_Int</a>
<a name="ln53">  psh_hint_overlap( PSH_Hint  hint1,</a>
<a name="ln54">                    PSH_Hint  hint2 )</a>
<a name="ln55">  {</a>
<a name="ln56">    return hint1-&gt;org_pos + hint1-&gt;org_len &gt;= hint2-&gt;org_pos &amp;&amp;</a>
<a name="ln57">           hint2-&gt;org_pos + hint2-&gt;org_len &gt;= hint1-&gt;org_pos;</a>
<a name="ln58">  }</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">  /* destroy hints table */</a>
<a name="ln62">  static void</a>
<a name="ln63">  psh_hint_table_done( PSH_Hint_Table  table,</a>
<a name="ln64">                       FT_Memory       memory )</a>
<a name="ln65">  {</a>
<a name="ln66">    FT_FREE( table-&gt;zones );</a>
<a name="ln67">    table-&gt;num_zones = 0;</a>
<a name="ln68">    table-&gt;zone      = NULL;</a>
<a name="ln69"> </a>
<a name="ln70">    FT_FREE( table-&gt;sort );</a>
<a name="ln71">    FT_FREE( table-&gt;hints );</a>
<a name="ln72">    table-&gt;num_hints   = 0;</a>
<a name="ln73">    table-&gt;max_hints   = 0;</a>
<a name="ln74">    table-&gt;sort_global = NULL;</a>
<a name="ln75">  }</a>
<a name="ln76"> </a>
<a name="ln77"> </a>
<a name="ln78">  /* deactivate all hints in a table */</a>
<a name="ln79">  static void</a>
<a name="ln80">  psh_hint_table_deactivate( PSH_Hint_Table  table )</a>
<a name="ln81">  {</a>
<a name="ln82">    FT_UInt   count = table-&gt;max_hints;</a>
<a name="ln83">    PSH_Hint  hint  = table-&gt;hints;</a>
<a name="ln84"> </a>
<a name="ln85"> </a>
<a name="ln86">    for ( ; count &gt; 0; count--, hint++ )</a>
<a name="ln87">    {</a>
<a name="ln88">      psh_hint_deactivate( hint );</a>
<a name="ln89">      hint-&gt;order = -1;</a>
<a name="ln90">    }</a>
<a name="ln91">  }</a>
<a name="ln92"> </a>
<a name="ln93"> </a>
<a name="ln94">  /* internal function to record a new hint */</a>
<a name="ln95">  static void</a>
<a name="ln96">  psh_hint_table_record( PSH_Hint_Table  table,</a>
<a name="ln97">                         FT_UInt         idx )</a>
<a name="ln98">  {</a>
<a name="ln99">    PSH_Hint  hint = table-&gt;hints + idx;</a>
<a name="ln100"> </a>
<a name="ln101"> </a>
<a name="ln102">    if ( idx &gt;= table-&gt;max_hints )</a>
<a name="ln103">    {</a>
<a name="ln104">      FT_TRACE0(( &quot;psh_hint_table_record: invalid hint index %d\n&quot;, idx ));</a>
<a name="ln105">      return;</a>
<a name="ln106">    }</a>
<a name="ln107"> </a>
<a name="ln108">    /* ignore active hints */</a>
<a name="ln109">    if ( psh_hint_is_active( hint ) )</a>
<a name="ln110">      return;</a>
<a name="ln111"> </a>
<a name="ln112">    psh_hint_activate( hint );</a>
<a name="ln113"> </a>
<a name="ln114">    /* now scan the current active hint set to check */</a>
<a name="ln115">    /* whether `hint' overlaps with another hint     */</a>
<a name="ln116">    {</a>
<a name="ln117">      PSH_Hint*  sorted = table-&gt;sort_global;</a>
<a name="ln118">      FT_UInt    count  = table-&gt;num_hints;</a>
<a name="ln119">      PSH_Hint   hint2;</a>
<a name="ln120"> </a>
<a name="ln121"> </a>
<a name="ln122">      hint-&gt;parent = NULL;</a>
<a name="ln123">      for ( ; count &gt; 0; count--, sorted++ )</a>
<a name="ln124">      {</a>
<a name="ln125">        hint2 = sorted[0];</a>
<a name="ln126"> </a>
<a name="ln127">        if ( psh_hint_overlap( hint, hint2 ) )</a>
<a name="ln128">        {</a>
<a name="ln129">          hint-&gt;parent = hint2;</a>
<a name="ln130">          break;</a>
<a name="ln131">        }</a>
<a name="ln132">      }</a>
<a name="ln133">    }</a>
<a name="ln134"> </a>
<a name="ln135">    if ( table-&gt;num_hints &lt; table-&gt;max_hints )</a>
<a name="ln136">      table-&gt;sort_global[table-&gt;num_hints++] = hint;</a>
<a name="ln137">    else</a>
<a name="ln138">      FT_TRACE0(( &quot;psh_hint_table_record: too many sorted hints!  BUG!\n&quot; ));</a>
<a name="ln139">  }</a>
<a name="ln140"> </a>
<a name="ln141"> </a>
<a name="ln142">  static void</a>
<a name="ln143">  psh_hint_table_record_mask( PSH_Hint_Table  table,</a>
<a name="ln144">                              PS_Mask         hint_mask )</a>
<a name="ln145">  {</a>
<a name="ln146">    FT_Int    mask = 0, val = 0;</a>
<a name="ln147">    FT_Byte*  cursor = hint_mask-&gt;bytes;</a>
<a name="ln148">    FT_UInt   idx, limit;</a>
<a name="ln149"> </a>
<a name="ln150"> </a>
<a name="ln151">    limit = hint_mask-&gt;num_bits;</a>
<a name="ln152"> </a>
<a name="ln153">    for ( idx = 0; idx &lt; limit; idx++ )</a>
<a name="ln154">    {</a>
<a name="ln155">      if ( mask == 0 )</a>
<a name="ln156">      {</a>
<a name="ln157">        val  = *cursor++;</a>
<a name="ln158">        mask = 0x80;</a>
<a name="ln159">      }</a>
<a name="ln160"> </a>
<a name="ln161">      if ( val &amp; mask )</a>
<a name="ln162">        psh_hint_table_record( table, idx );</a>
<a name="ln163"> </a>
<a name="ln164">      mask &gt;&gt;= 1;</a>
<a name="ln165">    }</a>
<a name="ln166">  }</a>
<a name="ln167"> </a>
<a name="ln168"> </a>
<a name="ln169">  /* create hints table */</a>
<a name="ln170">  static FT_Error</a>
<a name="ln171">  psh_hint_table_init( PSH_Hint_Table  table,</a>
<a name="ln172">                       PS_Hint_Table   hints,</a>
<a name="ln173">                       PS_Mask_Table   hint_masks,</a>
<a name="ln174">                       PS_Mask_Table   counter_masks,</a>
<a name="ln175">                       FT_Memory       memory )</a>
<a name="ln176">  {</a>
<a name="ln177">    FT_UInt   count;</a>
<a name="ln178">    FT_Error  error;</a>
<a name="ln179"> </a>
<a name="ln180">    FT_UNUSED( counter_masks );</a>
<a name="ln181"> </a>
<a name="ln182"> </a>
<a name="ln183">    count = hints-&gt;num_hints;</a>
<a name="ln184"> </a>
<a name="ln185">    /* allocate our tables */</a>
<a name="ln186">    if ( FT_NEW_ARRAY( table-&gt;sort,  2 * count     ) ||</a>
<a name="ln187">         FT_NEW_ARRAY( table-&gt;hints,     count     ) ||</a>
<a name="ln188">         FT_NEW_ARRAY( table-&gt;zones, 2 * count + 1 ) )</a>
<a name="ln189">      goto Exit;</a>
<a name="ln190"> </a>
<a name="ln191">    table-&gt;max_hints   = count;</a>
<a name="ln192">    table-&gt;sort_global = table-&gt;sort + count;</a>
<a name="ln193">    table-&gt;num_hints   = 0;</a>
<a name="ln194">    table-&gt;num_zones   = 0;</a>
<a name="ln195">    table-&gt;zone        = NULL;</a>
<a name="ln196"> </a>
<a name="ln197">    /* initialize the `table-&gt;hints' array */</a>
<a name="ln198">    {</a>
<a name="ln199">      PSH_Hint  write = table-&gt;hints;</a>
<a name="ln200">      PS_Hint   read  = hints-&gt;hints;</a>
<a name="ln201"> </a>
<a name="ln202"> </a>
<a name="ln203">      for ( ; count &gt; 0; count--, write++, read++ )</a>
<a name="ln204">      {</a>
<a name="ln205">        write-&gt;org_pos = read-&gt;pos;</a>
<a name="ln206">        write-&gt;org_len = read-&gt;len;</a>
<a name="ln207">        write-&gt;flags   = read-&gt;flags;</a>
<a name="ln208">      }</a>
<a name="ln209">    }</a>
<a name="ln210"> </a>
<a name="ln211">    /* we now need to determine the initial `parent' stems; first  */</a>
<a name="ln212">    /* activate the hints that are given by the initial hint masks */</a>
<a name="ln213">    if ( hint_masks )</a>
<a name="ln214">    {</a>
<a name="ln215">      PS_Mask  mask = hint_masks-&gt;masks;</a>
<a name="ln216"> </a>
<a name="ln217"> </a>
<a name="ln218">      count             = hint_masks-&gt;num_masks;</a>
<a name="ln219">      table-&gt;hint_masks = hint_masks;</a>
<a name="ln220"> </a>
<a name="ln221">      for ( ; count &gt; 0; count--, mask++ )</a>
<a name="ln222">        psh_hint_table_record_mask( table, mask );</a>
<a name="ln223">    }</a>
<a name="ln224"> </a>
<a name="ln225">    /* finally, do a linear parse in case some hints were left alone */</a>
<a name="ln226">    if ( table-&gt;num_hints != table-&gt;max_hints )</a>
<a name="ln227">    {</a>
<a name="ln228">      FT_UInt  idx;</a>
<a name="ln229"> </a>
<a name="ln230"> </a>
<a name="ln231">      FT_TRACE0(( &quot;psh_hint_table_init: missing/incorrect hint masks\n&quot; ));</a>
<a name="ln232"> </a>
<a name="ln233">      count = table-&gt;max_hints;</a>
<a name="ln234">      for ( idx = 0; idx &lt; count; idx++ )</a>
<a name="ln235">        psh_hint_table_record( table, idx );</a>
<a name="ln236">    }</a>
<a name="ln237"> </a>
<a name="ln238">  Exit:</a>
<a name="ln239">    return error;</a>
<a name="ln240">  }</a>
<a name="ln241"> </a>
<a name="ln242"> </a>
<a name="ln243">  static void</a>
<a name="ln244">  psh_hint_table_activate_mask( PSH_Hint_Table  table,</a>
<a name="ln245">                                PS_Mask         hint_mask )</a>
<a name="ln246">  {</a>
<a name="ln247">    FT_Int    mask = 0, val = 0;</a>
<a name="ln248">    FT_Byte*  cursor = hint_mask-&gt;bytes;</a>
<a name="ln249">    FT_UInt   idx, limit, count;</a>
<a name="ln250"> </a>
<a name="ln251"> </a>
<a name="ln252">    limit = hint_mask-&gt;num_bits;</a>
<a name="ln253">    count = 0;</a>
<a name="ln254"> </a>
<a name="ln255">    psh_hint_table_deactivate( table );</a>
<a name="ln256"> </a>
<a name="ln257">    for ( idx = 0; idx &lt; limit; idx++ )</a>
<a name="ln258">    {</a>
<a name="ln259">      if ( mask == 0 )</a>
<a name="ln260">      {</a>
<a name="ln261">        val  = *cursor++;</a>
<a name="ln262">        mask = 0x80;</a>
<a name="ln263">      }</a>
<a name="ln264"> </a>
<a name="ln265">      if ( val &amp; mask )</a>
<a name="ln266">      {</a>
<a name="ln267">        PSH_Hint  hint = &amp;table-&gt;hints[idx];</a>
<a name="ln268"> </a>
<a name="ln269"> </a>
<a name="ln270">        if ( !psh_hint_is_active( hint ) )</a>
<a name="ln271">        {</a>
<a name="ln272">          FT_UInt     count2;</a>
<a name="ln273"> </a>
<a name="ln274">#if 0</a>
<a name="ln275">          PSH_Hint*  sort = table-&gt;sort;</a>
<a name="ln276">          PSH_Hint   hint2;</a>
<a name="ln277"> </a>
<a name="ln278"> </a>
<a name="ln279">          for ( count2 = count; count2 &gt; 0; count2--, sort++ )</a>
<a name="ln280">          {</a>
<a name="ln281">            hint2 = sort[0];</a>
<a name="ln282">            if ( psh_hint_overlap( hint, hint2 ) )</a>
<a name="ln283">              FT_TRACE0(( &quot;psh_hint_table_activate_mask:&quot;</a>
<a name="ln284">                          &quot; found overlapping hints\n&quot; ))</a>
<a name="ln285">          }</a>
<a name="ln286">#else</a>
<a name="ln287">          count2 = 0;</a>
<a name="ln288">#endif</a>
<a name="ln289"> </a>
<a name="ln290">          if ( count2 == 0 )</a>
<a name="ln291">          {</a>
<a name="ln292">            psh_hint_activate( hint );</a>
<a name="ln293">            if ( count &lt; table-&gt;max_hints )</a>
<a name="ln294">              table-&gt;sort[count++] = hint;</a>
<a name="ln295">            else</a>
<a name="ln296">              FT_TRACE0(( &quot;psh_hint_tableactivate_mask:&quot;</a>
<a name="ln297">                          &quot; too many active hints\n&quot; ));</a>
<a name="ln298">          }</a>
<a name="ln299">        }</a>
<a name="ln300">      }</a>
<a name="ln301"> </a>
<a name="ln302">      mask &gt;&gt;= 1;</a>
<a name="ln303">    }</a>
<a name="ln304">    table-&gt;num_hints = count;</a>
<a name="ln305"> </a>
<a name="ln306">    /* now, sort the hints; they are guaranteed to not overlap */</a>
<a name="ln307">    /* so we can compare their &quot;org_pos&quot; field directly        */</a>
<a name="ln308">    {</a>
<a name="ln309">      FT_Int     i1, i2;</a>
<a name="ln310">      PSH_Hint   hint1, hint2;</a>
<a name="ln311">      PSH_Hint*  sort = table-&gt;sort;</a>
<a name="ln312"> </a>
<a name="ln313"> </a>
<a name="ln314">      /* a simple bubble sort will do, since in 99% of cases, the hints */</a>
<a name="ln315">      /* will be already sorted -- and the sort will be linear          */</a>
<a name="ln316">      for ( i1 = 1; i1 &lt; (FT_Int)count; i1++ )</a>
<a name="ln317">      {</a>
<a name="ln318">        hint1 = sort[i1];</a>
<a name="ln319">        for ( i2 = i1 - 1; i2 &gt;= 0; i2-- )</a>
<a name="ln320">        {</a>
<a name="ln321">          hint2 = sort[i2];</a>
<a name="ln322"> </a>
<a name="ln323">          if ( hint2-&gt;org_pos &lt; hint1-&gt;org_pos )</a>
<a name="ln324">            break;</a>
<a name="ln325"> </a>
<a name="ln326">          sort[i2 + 1] = hint2;</a>
<a name="ln327">          sort[i2]     = hint1;</a>
<a name="ln328">        }</a>
<a name="ln329">      }</a>
<a name="ln330">    }</a>
<a name="ln331">  }</a>
<a name="ln332"> </a>
<a name="ln333"> </a>
<a name="ln334">  /*************************************************************************/</a>
<a name="ln335">  /*************************************************************************/</a>
<a name="ln336">  /*****                                                               *****/</a>
<a name="ln337">  /*****               HINTS GRID-FITTING AND OPTIMIZATION             *****/</a>
<a name="ln338">  /*****                                                               *****/</a>
<a name="ln339">  /*************************************************************************/</a>
<a name="ln340">  /*************************************************************************/</a>
<a name="ln341"> </a>
<a name="ln342">#if 1</a>
<a name="ln343">  static FT_Pos</a>
<a name="ln344">  psh_dimension_quantize_len( PSH_Dimension  dim,</a>
<a name="ln345">                              FT_Pos         len,</a>
<a name="ln346">                              FT_Bool        do_snapping )</a>
<a name="ln347">  {</a>
<a name="ln348">    if ( len &lt;= 64 )</a>
<a name="ln349">      len = 64;</a>
<a name="ln350">    else</a>
<a name="ln351">    {</a>
<a name="ln352">      FT_Pos  delta = len - dim-&gt;stdw.widths[0].cur;</a>
<a name="ln353"> </a>
<a name="ln354"> </a>
<a name="ln355">      if ( delta &lt; 0 )</a>
<a name="ln356">        delta = -delta;</a>
<a name="ln357"> </a>
<a name="ln358">      if ( delta &lt; 40 )</a>
<a name="ln359">      {</a>
<a name="ln360">        len = dim-&gt;stdw.widths[0].cur;</a>
<a name="ln361">        if ( len &lt; 48 )</a>
<a name="ln362">          len = 48;</a>
<a name="ln363">      }</a>
<a name="ln364"> </a>
<a name="ln365">      if ( len &lt; 3 * 64 )</a>
<a name="ln366">      {</a>
<a name="ln367">        delta = ( len &amp; 63 );</a>
<a name="ln368">        len  &amp;= -64;</a>
<a name="ln369"> </a>
<a name="ln370">        if ( delta &lt; 10 )</a>
<a name="ln371">          len += delta;</a>
<a name="ln372"> </a>
<a name="ln373">        else if ( delta &lt; 32 )</a>
<a name="ln374">          len += 10;</a>
<a name="ln375"> </a>
<a name="ln376">        else if ( delta &lt; 54 )</a>
<a name="ln377">          len += 54;</a>
<a name="ln378"> </a>
<a name="ln379">        else</a>
<a name="ln380">          len += delta;</a>
<a name="ln381">      }</a>
<a name="ln382">      else</a>
<a name="ln383">        len = FT_PIX_ROUND( len );</a>
<a name="ln384">    }</a>
<a name="ln385"> </a>
<a name="ln386">    if ( do_snapping )</a>
<a name="ln387">      len = FT_PIX_ROUND( len );</a>
<a name="ln388"> </a>
<a name="ln389">    return  len;</a>
<a name="ln390">  }</a>
<a name="ln391">#endif /* 0 */</a>
<a name="ln392"> </a>
<a name="ln393"> </a>
<a name="ln394">#ifdef DEBUG_HINTER</a>
<a name="ln395"> </a>
<a name="ln396">  static void</a>
<a name="ln397">  ps_simple_scale( PSH_Hint_Table  table,</a>
<a name="ln398">                   FT_Fixed        scale,</a>
<a name="ln399">                   FT_Fixed        delta,</a>
<a name="ln400">                   FT_Int          dimension )</a>
<a name="ln401">  {</a>
<a name="ln402">    FT_UInt  count;</a>
<a name="ln403"> </a>
<a name="ln404"> </a>
<a name="ln405">    for ( count = 0; count &lt; table-&gt;max_hints; count++ )</a>
<a name="ln406">    {</a>
<a name="ln407">      PSH_Hint  hint = table-&gt;hints + count;</a>
<a name="ln408"> </a>
<a name="ln409"> </a>
<a name="ln410">      hint-&gt;cur_pos = FT_MulFix( hint-&gt;org_pos, scale ) + delta;</a>
<a name="ln411">      hint-&gt;cur_len = FT_MulFix( hint-&gt;org_len, scale );</a>
<a name="ln412"> </a>
<a name="ln413">      if ( ps_debug_hint_func )</a>
<a name="ln414">        ps_debug_hint_func( hint, dimension );</a>
<a name="ln415">    }</a>
<a name="ln416">  }</a>
<a name="ln417"> </a>
<a name="ln418">#endif /* DEBUG_HINTER */</a>
<a name="ln419"> </a>
<a name="ln420"> </a>
<a name="ln421">  static FT_Fixed</a>
<a name="ln422">  psh_hint_snap_stem_side_delta( FT_Fixed  pos,</a>
<a name="ln423">                                 FT_Fixed  len )</a>
<a name="ln424">  {</a>
<a name="ln425">    FT_Fixed  delta1 = FT_PIX_ROUND( pos ) - pos;</a>
<a name="ln426">    FT_Fixed  delta2 = FT_PIX_ROUND( pos + len ) - pos - len;</a>
<a name="ln427"> </a>
<a name="ln428"> </a>
<a name="ln429">    if ( FT_ABS( delta1 ) &lt;= FT_ABS( delta2 ) )</a>
<a name="ln430">      return delta1;</a>
<a name="ln431">    else</a>
<a name="ln432">      return delta2;</a>
<a name="ln433">  }</a>
<a name="ln434"> </a>
<a name="ln435"> </a>
<a name="ln436">  static void</a>
<a name="ln437">  psh_hint_align( PSH_Hint     hint,</a>
<a name="ln438">                  PSH_Globals  globals,</a>
<a name="ln439">                  FT_Int       dimension,</a>
<a name="ln440">                  PSH_Glyph    glyph )</a>
<a name="ln441">  {</a>
<a name="ln442">    PSH_Dimension  dim   = &amp;globals-&gt;dimension[dimension];</a>
<a name="ln443">    FT_Fixed       scale = dim-&gt;scale_mult;</a>
<a name="ln444">    FT_Fixed       delta = dim-&gt;scale_delta;</a>
<a name="ln445"> </a>
<a name="ln446"> </a>
<a name="ln447">    if ( !psh_hint_is_fitted( hint ) )</a>
<a name="ln448">    {</a>
<a name="ln449">      FT_Pos  pos = FT_MulFix( hint-&gt;org_pos, scale ) + delta;</a>
<a name="ln450">      FT_Pos  len = FT_MulFix( hint-&gt;org_len, scale );</a>
<a name="ln451"> </a>
<a name="ln452">      FT_Int            do_snapping;</a>
<a name="ln453">      FT_Pos            fit_len;</a>
<a name="ln454">      PSH_AlignmentRec  align;</a>
<a name="ln455"> </a>
<a name="ln456"> </a>
<a name="ln457">      /* ignore stem alignments when requested through the hint flags */</a>
<a name="ln458">      if ( ( dimension == 0 &amp;&amp; !glyph-&gt;do_horz_hints ) ||</a>
<a name="ln459">           ( dimension == 1 &amp;&amp; !glyph-&gt;do_vert_hints ) )</a>
<a name="ln460">      {</a>
<a name="ln461">        hint-&gt;cur_pos = pos;</a>
<a name="ln462">        hint-&gt;cur_len = len;</a>
<a name="ln463"> </a>
<a name="ln464">        psh_hint_set_fitted( hint );</a>
<a name="ln465">        return;</a>
<a name="ln466">      }</a>
<a name="ln467"> </a>
<a name="ln468">      /* perform stem snapping when requested - this is necessary</a>
<a name="ln469">       * for monochrome and LCD hinting modes only</a>
<a name="ln470">       */</a>
<a name="ln471">      do_snapping = ( dimension == 0 &amp;&amp; glyph-&gt;do_horz_snapping ) ||</a>
<a name="ln472">                    ( dimension == 1 &amp;&amp; glyph-&gt;do_vert_snapping );</a>
<a name="ln473"> </a>
<a name="ln474">      hint-&gt;cur_len = fit_len = len;</a>
<a name="ln475"> </a>
<a name="ln476">      /* check blue zones for horizontal stems */</a>
<a name="ln477">      align.align     = PSH_BLUE_ALIGN_NONE;</a>
<a name="ln478">      align.align_bot = align.align_top = 0;</a>
<a name="ln479"> </a>
<a name="ln480">      if ( dimension == 1 )</a>
<a name="ln481">        psh_blues_snap_stem( &amp;globals-&gt;blues,</a>
<a name="ln482">                             hint-&gt;org_pos + hint-&gt;org_len,</a>
<a name="ln483">                             hint-&gt;org_pos,</a>
<a name="ln484">                             &amp;align );</a>
<a name="ln485"> </a>
<a name="ln486">      switch ( align.align )</a>
<a name="ln487">      {</a>
<a name="ln488">      case PSH_BLUE_ALIGN_TOP:</a>
<a name="ln489">        /* the top of the stem is aligned against a blue zone */</a>
<a name="ln490">        hint-&gt;cur_pos = align.align_top - fit_len;</a>
<a name="ln491">        break;</a>
<a name="ln492"> </a>
<a name="ln493">      case PSH_BLUE_ALIGN_BOT:</a>
<a name="ln494">        /* the bottom of the stem is aligned against a blue zone */</a>
<a name="ln495">        hint-&gt;cur_pos = align.align_bot;</a>
<a name="ln496">        break;</a>
<a name="ln497"> </a>
<a name="ln498">      case PSH_BLUE_ALIGN_TOP | PSH_BLUE_ALIGN_BOT:</a>
<a name="ln499">        /* both edges of the stem are aligned against blue zones */</a>
<a name="ln500">        hint-&gt;cur_pos = align.align_bot;</a>
<a name="ln501">        hint-&gt;cur_len = align.align_top - align.align_bot;</a>
<a name="ln502">        break;</a>
<a name="ln503"> </a>
<a name="ln504">      default:</a>
<a name="ln505">        {</a>
<a name="ln506">          PSH_Hint  parent = hint-&gt;parent;</a>
<a name="ln507"> </a>
<a name="ln508"> </a>
<a name="ln509">          if ( parent )</a>
<a name="ln510">          {</a>
<a name="ln511">            FT_Pos  par_org_center, par_cur_center;</a>
<a name="ln512">            FT_Pos  cur_org_center, cur_delta;</a>
<a name="ln513"> </a>
<a name="ln514"> </a>
<a name="ln515">            /* ensure that parent is already fitted */</a>
<a name="ln516">            if ( !psh_hint_is_fitted( parent ) )</a>
<a name="ln517">              psh_hint_align( parent, globals, dimension, glyph );</a>
<a name="ln518"> </a>
<a name="ln519">            /* keep original relation between hints, this is, use the */</a>
<a name="ln520">            /* scaled distance between the centers of the hints to    */</a>
<a name="ln521">            /* compute the new position                               */</a>
<a name="ln522">            par_org_center = parent-&gt;org_pos + ( parent-&gt;org_len &gt;&gt; 1 );</a>
<a name="ln523">            par_cur_center = parent-&gt;cur_pos + ( parent-&gt;cur_len &gt;&gt; 1 );</a>
<a name="ln524">            cur_org_center = hint-&gt;org_pos   + ( hint-&gt;org_len   &gt;&gt; 1 );</a>
<a name="ln525"> </a>
<a name="ln526">            cur_delta = FT_MulFix( cur_org_center - par_org_center, scale );</a>
<a name="ln527">            pos       = par_cur_center + cur_delta - ( len &gt;&gt; 1 );</a>
<a name="ln528">          }</a>
<a name="ln529"> </a>
<a name="ln530">          hint-&gt;cur_pos = pos;</a>
<a name="ln531">          hint-&gt;cur_len = fit_len;</a>
<a name="ln532"> </a>
<a name="ln533">          /* Stem adjustment tries to snap stem widths to standard</a>
<a name="ln534">           * ones.  This is important to prevent unpleasant rounding</a>
<a name="ln535">           * artefacts.</a>
<a name="ln536">           */</a>
<a name="ln537">          if ( glyph-&gt;do_stem_adjust )</a>
<a name="ln538">          {</a>
<a name="ln539">            if ( len &lt;= 64 )</a>
<a name="ln540">            {</a>
<a name="ln541">              /* the stem is less than one pixel; we will center it</a>
<a name="ln542">               * around the nearest pixel center</a>
<a name="ln543">               */</a>
<a name="ln544">              if ( len &gt;= 32 )</a>
<a name="ln545">              {</a>
<a name="ln546">                /* This is a special case where we also widen the stem</a>
<a name="ln547">                 * and align it to the pixel grid.</a>
<a name="ln548">                 *</a>
<a name="ln549">                 *   stem_center          = pos + (len/2)</a>
<a name="ln550">                 *   nearest_pixel_center = FT_ROUND(stem_center-32)+32</a>
<a name="ln551">                 *   new_pos              = nearest_pixel_center-32</a>
<a name="ln552">                 *                        = FT_ROUND(stem_center-32)</a>
<a name="ln553">                 *                        = FT_FLOOR(stem_center-32+32)</a>
<a name="ln554">                 *                        = FT_FLOOR(stem_center)</a>
<a name="ln555">                 *   new_len              = 64</a>
<a name="ln556">                 */</a>
<a name="ln557">                pos = FT_PIX_FLOOR( pos + ( len &gt;&gt; 1 ) );</a>
<a name="ln558">                len = 64;</a>
<a name="ln559">              }</a>
<a name="ln560">              else if ( len &gt; 0 )</a>
<a name="ln561">              {</a>
<a name="ln562">                /* This is a very small stem; we simply align it to the</a>
<a name="ln563">                 * pixel grid, trying to find the minimum displacement.</a>
<a name="ln564">                 *</a>
<a name="ln565">                 * left               = pos</a>
<a name="ln566">                 * right              = pos + len</a>
<a name="ln567">                 * left_nearest_edge  = ROUND(pos)</a>
<a name="ln568">                 * right_nearest_edge = ROUND(right)</a>
<a name="ln569">                 *</a>
<a name="ln570">                 * if ( ABS(left_nearest_edge - left) &lt;=</a>
<a name="ln571">                 *      ABS(right_nearest_edge - right) )</a>
<a name="ln572">                 *    new_pos = left</a>
<a name="ln573">                 * else</a>
<a name="ln574">                 *    new_pos = right</a>
<a name="ln575">                 */</a>
<a name="ln576">                FT_Pos  left_nearest  = FT_PIX_ROUND( pos );</a>
<a name="ln577">                FT_Pos  right_nearest = FT_PIX_ROUND( pos + len );</a>
<a name="ln578">                FT_Pos  left_disp     = left_nearest - pos;</a>
<a name="ln579">                FT_Pos  right_disp    = right_nearest - ( pos + len );</a>
<a name="ln580"> </a>
<a name="ln581"> </a>
<a name="ln582">                if ( left_disp &lt; 0 )</a>
<a name="ln583">                  left_disp = -left_disp;</a>
<a name="ln584">                if ( right_disp &lt; 0 )</a>
<a name="ln585">                  right_disp = -right_disp;</a>
<a name="ln586">                if ( left_disp &lt;= right_disp )</a>
<a name="ln587">                  pos = left_nearest;</a>
<a name="ln588">                else</a>
<a name="ln589">                  pos = right_nearest;</a>
<a name="ln590">              }</a>
<a name="ln591">              else</a>
<a name="ln592">              {</a>
<a name="ln593">                /* this is a ghost stem; we simply round it */</a>
<a name="ln594">                pos = FT_PIX_ROUND( pos );</a>
<a name="ln595">              }</a>
<a name="ln596">            }</a>
<a name="ln597">            else</a>
<a name="ln598">            {</a>
<a name="ln599">              len = psh_dimension_quantize_len( dim, len, 0 );</a>
<a name="ln600">            }</a>
<a name="ln601">          }</a>
<a name="ln602"> </a>
<a name="ln603">          /* now that we have a good hinted stem width, try to position */</a>
<a name="ln604">          /* the stem along a pixel grid integer coordinate             */</a>
<a name="ln605">          hint-&gt;cur_pos = pos + psh_hint_snap_stem_side_delta( pos, len );</a>
<a name="ln606">          hint-&gt;cur_len = len;</a>
<a name="ln607">        }</a>
<a name="ln608">      }</a>
<a name="ln609"> </a>
<a name="ln610">      if ( do_snapping )</a>
<a name="ln611">      {</a>
<a name="ln612">        pos = hint-&gt;cur_pos;</a>
<a name="ln613">        len = hint-&gt;cur_len;</a>
<a name="ln614"> </a>
<a name="ln615">        if ( len &lt; 64 )</a>
<a name="ln616">          len = 64;</a>
<a name="ln617">        else</a>
<a name="ln618">          len = FT_PIX_ROUND( len );</a>
<a name="ln619"> </a>
<a name="ln620">        switch ( align.align )</a>
<a name="ln621">        {</a>
<a name="ln622">          case PSH_BLUE_ALIGN_TOP:</a>
<a name="ln623">            hint-&gt;cur_pos = align.align_top - len;</a>
<a name="ln624">            hint-&gt;cur_len = len;</a>
<a name="ln625">            break;</a>
<a name="ln626"> </a>
<a name="ln627">          case PSH_BLUE_ALIGN_BOT:</a>
<a name="ln628">            hint-&gt;cur_len = len;</a>
<a name="ln629">            break;</a>
<a name="ln630"> </a>
<a name="ln631">          case PSH_BLUE_ALIGN_BOT | PSH_BLUE_ALIGN_TOP:</a>
<a name="ln632">            /* don't touch */</a>
<a name="ln633">            break;</a>
<a name="ln634"> </a>
<a name="ln635"> </a>
<a name="ln636">          default:</a>
<a name="ln637">            hint-&gt;cur_len = len;</a>
<a name="ln638">            if ( len &amp; 64 )</a>
<a name="ln639">              pos = FT_PIX_FLOOR( pos + ( len &gt;&gt; 1 ) ) + 32;</a>
<a name="ln640">            else</a>
<a name="ln641">              pos = FT_PIX_ROUND( pos + ( len &gt;&gt; 1 ) );</a>
<a name="ln642"> </a>
<a name="ln643">            hint-&gt;cur_pos = pos - ( len &gt;&gt; 1 );</a>
<a name="ln644">            hint-&gt;cur_len = len;</a>
<a name="ln645">        }</a>
<a name="ln646">      }</a>
<a name="ln647"> </a>
<a name="ln648">      psh_hint_set_fitted( hint );</a>
<a name="ln649"> </a>
<a name="ln650">#ifdef DEBUG_HINTER</a>
<a name="ln651">      if ( ps_debug_hint_func )</a>
<a name="ln652">        ps_debug_hint_func( hint, dimension );</a>
<a name="ln653">#endif</a>
<a name="ln654">    }</a>
<a name="ln655">  }</a>
<a name="ln656"> </a>
<a name="ln657"> </a>
<a name="ln658">#if 0  /* not used for now, experimental */</a>
<a name="ln659"> </a>
<a name="ln660"> /*</a>
<a name="ln661">  *  A variant to perform &quot;light&quot; hinting (i.e. FT_RENDER_MODE_LIGHT)</a>
<a name="ln662">  *  of stems</a>
<a name="ln663">  */</a>
<a name="ln664">  static void</a>
<a name="ln665">  psh_hint_align_light( PSH_Hint     hint,</a>
<a name="ln666">                        PSH_Globals  globals,</a>
<a name="ln667">                        FT_Int       dimension,</a>
<a name="ln668">                        PSH_Glyph    glyph )</a>
<a name="ln669">  {</a>
<a name="ln670">    PSH_Dimension  dim   = &amp;globals-&gt;dimension[dimension];</a>
<a name="ln671">    FT_Fixed       scale = dim-&gt;scale_mult;</a>
<a name="ln672">    FT_Fixed       delta = dim-&gt;scale_delta;</a>
<a name="ln673"> </a>
<a name="ln674"> </a>
<a name="ln675">    if ( !psh_hint_is_fitted( hint ) )</a>
<a name="ln676">    {</a>
<a name="ln677">      FT_Pos  pos = FT_MulFix( hint-&gt;org_pos, scale ) + delta;</a>
<a name="ln678">      FT_Pos  len = FT_MulFix( hint-&gt;org_len, scale );</a>
<a name="ln679"> </a>
<a name="ln680">      FT_Pos  fit_len;</a>
<a name="ln681"> </a>
<a name="ln682">      PSH_AlignmentRec  align;</a>
<a name="ln683"> </a>
<a name="ln684"> </a>
<a name="ln685">      /* ignore stem alignments when requested through the hint flags */</a>
<a name="ln686">      if ( ( dimension == 0 &amp;&amp; !glyph-&gt;do_horz_hints ) ||</a>
<a name="ln687">           ( dimension == 1 &amp;&amp; !glyph-&gt;do_vert_hints ) )</a>
<a name="ln688">      {</a>
<a name="ln689">        hint-&gt;cur_pos = pos;</a>
<a name="ln690">        hint-&gt;cur_len = len;</a>
<a name="ln691"> </a>
<a name="ln692">        psh_hint_set_fitted( hint );</a>
<a name="ln693">        return;</a>
<a name="ln694">      }</a>
<a name="ln695"> </a>
<a name="ln696">      fit_len = len;</a>
<a name="ln697"> </a>
<a name="ln698">      hint-&gt;cur_len = fit_len;</a>
<a name="ln699"> </a>
<a name="ln700">      /* check blue zones for horizontal stems */</a>
<a name="ln701">      align.align = PSH_BLUE_ALIGN_NONE;</a>
<a name="ln702">      align.align_bot = align.align_top = 0;</a>
<a name="ln703"> </a>
<a name="ln704">      if ( dimension == 1 )</a>
<a name="ln705">        psh_blues_snap_stem( &amp;globals-&gt;blues,</a>
<a name="ln706">                             hint-&gt;org_pos + hint-&gt;org_len,</a>
<a name="ln707">                             hint-&gt;org_pos,</a>
<a name="ln708">                             &amp;align );</a>
<a name="ln709"> </a>
<a name="ln710">      switch ( align.align )</a>
<a name="ln711">      {</a>
<a name="ln712">      case PSH_BLUE_ALIGN_TOP:</a>
<a name="ln713">        /* the top of the stem is aligned against a blue zone */</a>
<a name="ln714">        hint-&gt;cur_pos = align.align_top - fit_len;</a>
<a name="ln715">        break;</a>
<a name="ln716"> </a>
<a name="ln717">      case PSH_BLUE_ALIGN_BOT:</a>
<a name="ln718">        /* the bottom of the stem is aligned against a blue zone */</a>
<a name="ln719">        hint-&gt;cur_pos = align.align_bot;</a>
<a name="ln720">        break;</a>
<a name="ln721"> </a>
<a name="ln722">      case PSH_BLUE_ALIGN_TOP | PSH_BLUE_ALIGN_BOT:</a>
<a name="ln723">        /* both edges of the stem are aligned against blue zones */</a>
<a name="ln724">        hint-&gt;cur_pos = align.align_bot;</a>
<a name="ln725">        hint-&gt;cur_len = align.align_top - align.align_bot;</a>
<a name="ln726">        break;</a>
<a name="ln727"> </a>
<a name="ln728">      default:</a>
<a name="ln729">        {</a>
<a name="ln730">          PSH_Hint  parent = hint-&gt;parent;</a>
<a name="ln731"> </a>
<a name="ln732"> </a>
<a name="ln733">          if ( parent )</a>
<a name="ln734">          {</a>
<a name="ln735">            FT_Pos  par_org_center, par_cur_center;</a>
<a name="ln736">            FT_Pos  cur_org_center, cur_delta;</a>
<a name="ln737"> </a>
<a name="ln738"> </a>
<a name="ln739">            /* ensure that parent is already fitted */</a>
<a name="ln740">            if ( !psh_hint_is_fitted( parent ) )</a>
<a name="ln741">              psh_hint_align_light( parent, globals, dimension, glyph );</a>
<a name="ln742"> </a>
<a name="ln743">            par_org_center = parent-&gt;org_pos + ( parent-&gt;org_len / 2 );</a>
<a name="ln744">            par_cur_center = parent-&gt;cur_pos + ( parent-&gt;cur_len / 2 );</a>
<a name="ln745">            cur_org_center = hint-&gt;org_pos   + ( hint-&gt;org_len   / 2 );</a>
<a name="ln746"> </a>
<a name="ln747">            cur_delta = FT_MulFix( cur_org_center - par_org_center, scale );</a>
<a name="ln748">            pos       = par_cur_center + cur_delta - ( len &gt;&gt; 1 );</a>
<a name="ln749">          }</a>
<a name="ln750"> </a>
<a name="ln751">          /* Stems less than one pixel wide are easy -- we want to</a>
<a name="ln752">           * make them as dark as possible, so they must fall within</a>
<a name="ln753">           * one pixel.  If the stem is split between two pixels</a>
<a name="ln754">           * then snap the edge that is nearer to the pixel boundary</a>
<a name="ln755">           * to the pixel boundary.</a>
<a name="ln756">           */</a>
<a name="ln757">          if ( len &lt;= 64 )</a>
<a name="ln758">          {</a>
<a name="ln759">            if ( ( pos + len + 63 ) / 64  != pos / 64 + 1 )</a>
<a name="ln760">              pos += psh_hint_snap_stem_side_delta ( pos, len );</a>
<a name="ln761">          }</a>
<a name="ln762"> </a>
<a name="ln763">          /* Position stems other to minimize the amount of mid-grays.</a>
<a name="ln764">           * There are, in general, two positions that do this,</a>
<a name="ln765">           * illustrated as A) and B) below.</a>
<a name="ln766">           *</a>
<a name="ln767">           *   +                   +                   +                   +</a>
<a name="ln768">           *</a>
<a name="ln769">           * A)             |--------------------------------|</a>
<a name="ln770">           * B)   |--------------------------------|</a>
<a name="ln771">           * C)       |--------------------------------|</a>
<a name="ln772">           *</a>
<a name="ln773">           * Position A) (split the excess stem equally) should be better</a>
<a name="ln774">           * for stems of width N + f where f &lt; 0.5.</a>
<a name="ln775">           *</a>
<a name="ln776">           * Position B) (split the deficiency equally) should be better</a>
<a name="ln777">           * for stems of width N + f where f &gt; 0.5.</a>
<a name="ln778">           *</a>
<a name="ln779">           * It turns out though that minimizing the total number of lit</a>
<a name="ln780">           * pixels is also important, so position C), with one edge</a>
<a name="ln781">           * aligned with a pixel boundary is actually preferable</a>
<a name="ln782">           * to A).  There are also more possibile positions for C) than</a>
<a name="ln783">           * for A) or B), so it involves less distortion of the overall</a>
<a name="ln784">           * character shape.</a>
<a name="ln785">           */</a>
<a name="ln786">          else /* len &gt; 64 */</a>
<a name="ln787">          {</a>
<a name="ln788">            FT_Fixed  frac_len = len &amp; 63;</a>
<a name="ln789">            FT_Fixed  center = pos + ( len &gt;&gt; 1 );</a>
<a name="ln790">            FT_Fixed  delta_a, delta_b;</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">            if ( ( len / 64 ) &amp; 1 )</a>
<a name="ln794">            {</a>
<a name="ln795">              delta_a = FT_PIX_FLOOR( center ) + 32 - center;</a>
<a name="ln796">              delta_b = FT_PIX_ROUND( center ) - center;</a>
<a name="ln797">            }</a>
<a name="ln798">            else</a>
<a name="ln799">            {</a>
<a name="ln800">              delta_a = FT_PIX_ROUND( center ) - center;</a>
<a name="ln801">              delta_b = FT_PIX_FLOOR( center ) + 32 - center;</a>
<a name="ln802">            }</a>
<a name="ln803"> </a>
<a name="ln804">            /* We choose between B) and C) above based on the amount</a>
<a name="ln805">             * of fractinal stem width; for small amounts, choose</a>
<a name="ln806">             * C) always, for large amounts, B) always, and inbetween,</a>
<a name="ln807">             * pick whichever one involves less stem movement.</a>
<a name="ln808">             */</a>
<a name="ln809">            if ( frac_len &lt; 32 )</a>
<a name="ln810">            {</a>
<a name="ln811">              pos += psh_hint_snap_stem_side_delta ( pos, len );</a>
<a name="ln812">            }</a>
<a name="ln813">            else if ( frac_len &lt; 48 )</a>
<a name="ln814">            {</a>
<a name="ln815">              FT_Fixed  side_delta = psh_hint_snap_stem_side_delta ( pos,</a>
<a name="ln816">                                                                     len );</a>
<a name="ln817"> </a>
<a name="ln818">              if ( FT_ABS( side_delta ) &lt; FT_ABS( delta_b ) )</a>
<a name="ln819">                pos += side_delta;</a>
<a name="ln820">              else</a>
<a name="ln821">                pos += delta_b;</a>
<a name="ln822">            }</a>
<a name="ln823">            else</a>
<a name="ln824">            {</a>
<a name="ln825">              pos += delta_b;</a>
<a name="ln826">            }</a>
<a name="ln827">          }</a>
<a name="ln828"> </a>
<a name="ln829">          hint-&gt;cur_pos = pos;</a>
<a name="ln830">        }</a>
<a name="ln831">      }  /* switch */</a>
<a name="ln832"> </a>
<a name="ln833">      psh_hint_set_fitted( hint );</a>
<a name="ln834"> </a>
<a name="ln835">#ifdef DEBUG_HINTER</a>
<a name="ln836">      if ( ps_debug_hint_func )</a>
<a name="ln837">        ps_debug_hint_func( hint, dimension );</a>
<a name="ln838">#endif</a>
<a name="ln839">    }</a>
<a name="ln840">  }</a>
<a name="ln841"> </a>
<a name="ln842">#endif /* 0 */</a>
<a name="ln843"> </a>
<a name="ln844"> </a>
<a name="ln845">  static void</a>
<a name="ln846">  psh_hint_table_align_hints( PSH_Hint_Table  table,</a>
<a name="ln847">                              PSH_Globals     globals,</a>
<a name="ln848">                              FT_Int          dimension,</a>
<a name="ln849">                              PSH_Glyph       glyph )</a>
<a name="ln850">  {</a>
<a name="ln851">    PSH_Hint       hint;</a>
<a name="ln852">    FT_UInt        count;</a>
<a name="ln853"> </a>
<a name="ln854">#ifdef DEBUG_HINTER</a>
<a name="ln855"> </a>
<a name="ln856">    PSH_Dimension  dim   = &amp;globals-&gt;dimension[dimension];</a>
<a name="ln857">    FT_Fixed       scale = dim-&gt;scale_mult;</a>
<a name="ln858">    FT_Fixed       delta = dim-&gt;scale_delta;</a>
<a name="ln859"> </a>
<a name="ln860"> </a>
<a name="ln861">    if ( ps_debug_no_vert_hints &amp;&amp; dimension == 0 )</a>
<a name="ln862">    {</a>
<a name="ln863">      ps_simple_scale( table, scale, delta, dimension );</a>
<a name="ln864">      return;</a>
<a name="ln865">    }</a>
<a name="ln866"> </a>
<a name="ln867">    if ( ps_debug_no_horz_hints &amp;&amp; dimension == 1 )</a>
<a name="ln868">    {</a>
<a name="ln869">      ps_simple_scale( table, scale, delta, dimension );</a>
<a name="ln870">      return;</a>
<a name="ln871">    }</a>
<a name="ln872"> </a>
<a name="ln873">#endif /* DEBUG_HINTER*/</a>
<a name="ln874"> </a>
<a name="ln875">    hint  = table-&gt;hints;</a>
<a name="ln876">    count = table-&gt;max_hints;</a>
<a name="ln877"> </a>
<a name="ln878">    for ( ; count &gt; 0; count--, hint++ )</a>
<a name="ln879">      psh_hint_align( hint, globals, dimension, glyph );</a>
<a name="ln880">  }</a>
<a name="ln881"> </a>
<a name="ln882"> </a>
<a name="ln883">  /*************************************************************************/</a>
<a name="ln884">  /*************************************************************************/</a>
<a name="ln885">  /*****                                                               *****/</a>
<a name="ln886">  /*****                POINTS INTERPOLATION ROUTINES                  *****/</a>
<a name="ln887">  /*****                                                               *****/</a>
<a name="ln888">  /*************************************************************************/</a>
<a name="ln889">  /*************************************************************************/</a>
<a name="ln890"> </a>
<a name="ln891">#define xxDEBUG_ZONES</a>
<a name="ln892"> </a>
<a name="ln893"> </a>
<a name="ln894">#ifdef DEBUG_ZONES</a>
<a name="ln895"> </a>
<a name="ln896">#include FT_CONFIG_STANDARD_LIBRARY_H</a>
<a name="ln897"> </a>
<a name="ln898">  static void</a>
<a name="ln899">  psh_print_zone( PSH_Zone  zone )</a>
<a name="ln900">  {</a>
<a name="ln901">    printf( &quot;zone [scale,delta,min,max] = [%.3f,%.3f,%d,%d]\n&quot;,</a>
<a name="ln902">             zone-&gt;scale / 65536.0,</a>
<a name="ln903">             zone-&gt;delta / 64.0,</a>
<a name="ln904">             zone-&gt;min,</a>
<a name="ln905">             zone-&gt;max );</a>
<a name="ln906">  }</a>
<a name="ln907"> </a>
<a name="ln908">#endif /* DEBUG_ZONES */</a>
<a name="ln909"> </a>
<a name="ln910"> </a>
<a name="ln911">  /*************************************************************************/</a>
<a name="ln912">  /*************************************************************************/</a>
<a name="ln913">  /*****                                                               *****/</a>
<a name="ln914">  /*****                    HINTER GLYPH MANAGEMENT                    *****/</a>
<a name="ln915">  /*****                                                               *****/</a>
<a name="ln916">  /*************************************************************************/</a>
<a name="ln917">  /*************************************************************************/</a>
<a name="ln918"> </a>
<a name="ln919">#define  psh_corner_is_flat      ft_corner_is_flat</a>
<a name="ln920">#define  psh_corner_orientation  ft_corner_orientation</a>
<a name="ln921"> </a>
<a name="ln922"> </a>
<a name="ln923">#ifdef COMPUTE_INFLEXS</a>
<a name="ln924"> </a>
<a name="ln925">  /* compute all inflex points in a given glyph */</a>
<a name="ln926">  static void</a>
<a name="ln927">  psh_glyph_compute_inflections( PSH_Glyph  glyph )</a>
<a name="ln928">  {</a>
<a name="ln929">    FT_UInt  n;</a>
<a name="ln930"> </a>
<a name="ln931"> </a>
<a name="ln932">    for ( n = 0; n &lt; glyph-&gt;num_contours; n++ )</a>
<a name="ln933">    {</a>
<a name="ln934">      PSH_Point  first, start, end, before, after;</a>
<a name="ln935">      FT_Pos     in_x, in_y, out_x, out_y;</a>
<a name="ln936">      FT_Int     orient_prev, orient_cur;</a>
<a name="ln937">      FT_Int     finished = 0;</a>
<a name="ln938"> </a>
<a name="ln939"> </a>
<a name="ln940">      /* we need at least 4 points to create an inflection point */</a>
<a name="ln941">      if ( glyph-&gt;contours[n].count &lt; 4 )</a>
<a name="ln942">        continue;</a>
<a name="ln943"> </a>
<a name="ln944">      /* compute first segment in contour */</a>
<a name="ln945">      first = glyph-&gt;contours[n].start;</a>
<a name="ln946"> </a>
<a name="ln947">      start = end = first;</a>
<a name="ln948">      do</a>
<a name="ln949">      {</a>
<a name="ln950">        end = end-&gt;next;</a>
<a name="ln951">        if ( end == first )</a>
<a name="ln952">          goto Skip;</a>
<a name="ln953"> </a>
<a name="ln954">        in_x = end-&gt;org_u - start-&gt;org_u;</a>
<a name="ln955">        in_y = end-&gt;org_v - start-&gt;org_v;</a>
<a name="ln956"> </a>
<a name="ln957">      } while ( in_x == 0 &amp;&amp; in_y == 0 );</a>
<a name="ln958"> </a>
<a name="ln959">      /* extend the segment start whenever possible */</a>
<a name="ln960">      before = start;</a>
<a name="ln961">      do</a>
<a name="ln962">      {</a>
<a name="ln963">        do</a>
<a name="ln964">        {</a>
<a name="ln965">          start  = before;</a>
<a name="ln966">          before = before-&gt;prev;</a>
<a name="ln967">          if ( before == first )</a>
<a name="ln968">            goto Skip;</a>
<a name="ln969"> </a>
<a name="ln970">          out_x = start-&gt;org_u - before-&gt;org_u;</a>
<a name="ln971">          out_y = start-&gt;org_v - before-&gt;org_v;</a>
<a name="ln972"> </a>
<a name="ln973">        } while ( out_x == 0 &amp;&amp; out_y == 0 );</a>
<a name="ln974"> </a>
<a name="ln975">        orient_prev = psh_corner_orientation( in_x, in_y, out_x, out_y );</a>
<a name="ln976"> </a>
<a name="ln977">      } while ( orient_prev == 0 );</a>
<a name="ln978"> </a>
<a name="ln979">      first = start;</a>
<a name="ln980">      in_x  = out_x;</a>
<a name="ln981">      in_y  = out_y;</a>
<a name="ln982"> </a>
<a name="ln983">      /* now, process all segments in the contour */</a>
<a name="ln984">      do</a>
<a name="ln985">      {</a>
<a name="ln986">        /* first, extend current segment's end whenever possible */</a>
<a name="ln987">        after = end;</a>
<a name="ln988">        do</a>
<a name="ln989">        {</a>
<a name="ln990">          do</a>
<a name="ln991">          {</a>
<a name="ln992">            end   = after;</a>
<a name="ln993">            after = after-&gt;next;</a>
<a name="ln994">            if ( after == first )</a>
<a name="ln995">              finished = 1;</a>
<a name="ln996"> </a>
<a name="ln997">            out_x = after-&gt;org_u - end-&gt;org_u;</a>
<a name="ln998">            out_y = after-&gt;org_v - end-&gt;org_v;</a>
<a name="ln999"> </a>
<a name="ln1000">          } while ( out_x == 0 &amp;&amp; out_y == 0 );</a>
<a name="ln1001"> </a>
<a name="ln1002">          orient_cur = psh_corner_orientation( in_x, in_y, out_x, out_y );</a>
<a name="ln1003"> </a>
<a name="ln1004">        } while ( orient_cur == 0 );</a>
<a name="ln1005"> </a>
<a name="ln1006">        if ( ( orient_cur ^ orient_prev ) &lt; 0 )</a>
<a name="ln1007">        {</a>
<a name="ln1008">          do</a>
<a name="ln1009">          {</a>
<a name="ln1010">            psh_point_set_inflex( start );</a>
<a name="ln1011">            start = start-&gt;next;</a>
<a name="ln1012">          }</a>
<a name="ln1013">          while ( start != end );</a>
<a name="ln1014"> </a>
<a name="ln1015">          psh_point_set_inflex( start );</a>
<a name="ln1016">        }</a>
<a name="ln1017"> </a>
<a name="ln1018">        start       = end;</a>
<a name="ln1019">        end         = after;</a>
<a name="ln1020">        orient_prev = orient_cur;</a>
<a name="ln1021">        in_x        = out_x;</a>
<a name="ln1022">        in_y        = out_y;</a>
<a name="ln1023"> </a>
<a name="ln1024">      } while ( !finished );</a>
<a name="ln1025"> </a>
<a name="ln1026">    Skip:</a>
<a name="ln1027">      ;</a>
<a name="ln1028">    }</a>
<a name="ln1029">  }</a>
<a name="ln1030"> </a>
<a name="ln1031">#endif /* COMPUTE_INFLEXS */</a>
<a name="ln1032"> </a>
<a name="ln1033"> </a>
<a name="ln1034">  static void</a>
<a name="ln1035">  psh_glyph_done( PSH_Glyph  glyph )</a>
<a name="ln1036">  {</a>
<a name="ln1037">    FT_Memory  memory = glyph-&gt;memory;</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">    psh_hint_table_done( &amp;glyph-&gt;hint_tables[1], memory );</a>
<a name="ln1041">    psh_hint_table_done( &amp;glyph-&gt;hint_tables[0], memory );</a>
<a name="ln1042"> </a>
<a name="ln1043">    FT_FREE( glyph-&gt;points );</a>
<a name="ln1044">    FT_FREE( glyph-&gt;contours );</a>
<a name="ln1045"> </a>
<a name="ln1046">    glyph-&gt;num_points   = 0;</a>
<a name="ln1047">    glyph-&gt;num_contours = 0;</a>
<a name="ln1048"> </a>
<a name="ln1049">    glyph-&gt;memory = NULL;</a>
<a name="ln1050">  }</a>
<a name="ln1051"> </a>
<a name="ln1052"> </a>
<a name="ln1053">  static int</a>
<a name="ln1054">  psh_compute_dir( FT_Pos  dx,</a>
<a name="ln1055">                   FT_Pos  dy )</a>
<a name="ln1056">  {</a>
<a name="ln1057">    FT_Pos  ax, ay;</a>
<a name="ln1058">    int     result = PSH_DIR_NONE;</a>
<a name="ln1059"> </a>
<a name="ln1060"> </a>
<a name="ln1061">    ax = FT_ABS( dx );</a>
<a name="ln1062">    ay = FT_ABS( dy );</a>
<a name="ln1063"> </a>
<a name="ln1064">    if ( ay * 12 &lt; ax )</a>
<a name="ln1065">    {</a>
<a name="ln1066">      /* |dy| &lt;&lt;&lt; |dx|  means a near-horizontal segment */</a>
<a name="ln1067">      result = ( dx &gt;= 0 ) ? PSH_DIR_RIGHT : PSH_DIR_LEFT;</a>
<a name="ln1068">    }</a>
<a name="ln1069">    else if ( ax * 12 &lt; ay )</a>
<a name="ln1070">    {</a>
<a name="ln1071">      /* |dx| &lt;&lt;&lt; |dy|  means a near-vertical segment */</a>
<a name="ln1072">      result = ( dy &gt;= 0 ) ? PSH_DIR_UP : PSH_DIR_DOWN;</a>
<a name="ln1073">    }</a>
<a name="ln1074"> </a>
<a name="ln1075">    return result;</a>
<a name="ln1076">  }</a>
<a name="ln1077"> </a>
<a name="ln1078"> </a>
<a name="ln1079">  /* load outline point coordinates into hinter glyph */</a>
<a name="ln1080">  static void</a>
<a name="ln1081">  psh_glyph_load_points( PSH_Glyph  glyph,</a>
<a name="ln1082">                         FT_Int     dimension )</a>
<a name="ln1083">  {</a>
<a name="ln1084">    FT_Vector*  vec   = glyph-&gt;outline-&gt;points;</a>
<a name="ln1085">    PSH_Point   point = glyph-&gt;points;</a>
<a name="ln1086">    FT_UInt     count = glyph-&gt;num_points;</a>
<a name="ln1087"> </a>
<a name="ln1088"> </a>
<a name="ln1089">    for ( ; count &gt; 0; count--, point++, vec++ )</a>
<a name="ln1090">    {</a>
<a name="ln1091">      point-&gt;flags2 = 0;</a>
<a name="ln1092">      point-&gt;hint   = NULL;</a>
<a name="ln1093">      if ( dimension == 0 )</a>
<a name="ln1094">      {</a>
<a name="ln1095">        point-&gt;org_u = vec-&gt;x;</a>
<a name="ln1096">        point-&gt;org_v = vec-&gt;y;</a>
<a name="ln1097">      }</a>
<a name="ln1098">      else</a>
<a name="ln1099">      {</a>
<a name="ln1100">        point-&gt;org_u = vec-&gt;y;</a>
<a name="ln1101">        point-&gt;org_v = vec-&gt;x;</a>
<a name="ln1102">      }</a>
<a name="ln1103"> </a>
<a name="ln1104">#ifdef DEBUG_HINTER</a>
<a name="ln1105">      point-&gt;org_x = vec-&gt;x;</a>
<a name="ln1106">      point-&gt;org_y = vec-&gt;y;</a>
<a name="ln1107">#endif</a>
<a name="ln1108"> </a>
<a name="ln1109">    }</a>
<a name="ln1110">  }</a>
<a name="ln1111"> </a>
<a name="ln1112"> </a>
<a name="ln1113">  /* save hinted point coordinates back to outline */</a>
<a name="ln1114">  static void</a>
<a name="ln1115">  psh_glyph_save_points( PSH_Glyph  glyph,</a>
<a name="ln1116">                         FT_Int     dimension )</a>
<a name="ln1117">  {</a>
<a name="ln1118">    FT_UInt     n;</a>
<a name="ln1119">    PSH_Point   point = glyph-&gt;points;</a>
<a name="ln1120">    FT_Vector*  vec   = glyph-&gt;outline-&gt;points;</a>
<a name="ln1121">    char*       tags  = glyph-&gt;outline-&gt;tags;</a>
<a name="ln1122"> </a>
<a name="ln1123"> </a>
<a name="ln1124">    for ( n = 0; n &lt; glyph-&gt;num_points; n++ )</a>
<a name="ln1125">    {</a>
<a name="ln1126">      if ( dimension == 0 )</a>
<a name="ln1127">        vec[n].x = point-&gt;cur_u;</a>
<a name="ln1128">      else</a>
<a name="ln1129">        vec[n].y = point-&gt;cur_u;</a>
<a name="ln1130"> </a>
<a name="ln1131">      if ( psh_point_is_strong( point ) )</a>
<a name="ln1132">        tags[n] |= (char)( ( dimension == 0 ) ? 32 : 64 );</a>
<a name="ln1133"> </a>
<a name="ln1134">#ifdef DEBUG_HINTER</a>
<a name="ln1135"> </a>
<a name="ln1136">      if ( dimension == 0 )</a>
<a name="ln1137">      {</a>
<a name="ln1138">        point-&gt;cur_x   = point-&gt;cur_u;</a>
<a name="ln1139">        point-&gt;flags_x = point-&gt;flags2 | point-&gt;flags;</a>
<a name="ln1140">      }</a>
<a name="ln1141">      else</a>
<a name="ln1142">      {</a>
<a name="ln1143">        point-&gt;cur_y   = point-&gt;cur_u;</a>
<a name="ln1144">        point-&gt;flags_y = point-&gt;flags2 | point-&gt;flags;</a>
<a name="ln1145">      }</a>
<a name="ln1146"> </a>
<a name="ln1147">#endif</a>
<a name="ln1148"> </a>
<a name="ln1149">      point++;</a>
<a name="ln1150">    }</a>
<a name="ln1151">  }</a>
<a name="ln1152"> </a>
<a name="ln1153"> </a>
<a name="ln1154">  static FT_Error</a>
<a name="ln1155">  psh_glyph_init( PSH_Glyph    glyph,</a>
<a name="ln1156">                  FT_Outline*  outline,</a>
<a name="ln1157">                  PS_Hints     ps_hints,</a>
<a name="ln1158">                  PSH_Globals  globals )</a>
<a name="ln1159">  {</a>
<a name="ln1160">    FT_Error   error;</a>
<a name="ln1161">    FT_Memory  memory;</a>
<a name="ln1162"> </a>
<a name="ln1163"> </a>
<a name="ln1164">    /* clear all fields */</a>
<a name="ln1165">    FT_MEM_ZERO( glyph, sizeof ( *glyph ) );</a>
<a name="ln1166"> </a>
<a name="ln1167">    memory = glyph-&gt;memory = globals-&gt;memory;</a>
<a name="ln1168"> </a>
<a name="ln1169">    /* allocate and setup points + contours arrays */</a>
<a name="ln1170">    if ( FT_NEW_ARRAY( glyph-&gt;points,   outline-&gt;n_points   ) ||</a>
<a name="ln1171">         FT_NEW_ARRAY( glyph-&gt;contours, outline-&gt;n_contours ) )</a>
<a name="ln1172">      goto Exit;</a>
<a name="ln1173"> </a>
<a name="ln1174">    glyph-&gt;num_points   = (FT_UInt)outline-&gt;n_points;</a>
<a name="ln1175">    glyph-&gt;num_contours = (FT_UInt)outline-&gt;n_contours;</a>
<a name="ln1176"> </a>
<a name="ln1177">    {</a>
<a name="ln1178">      FT_UInt      first = 0, next, n;</a>
<a name="ln1179">      PSH_Point    points  = glyph-&gt;points;</a>
<a name="ln1180">      PSH_Contour  contour = glyph-&gt;contours;</a>
<a name="ln1181"> </a>
<a name="ln1182"> </a>
<a name="ln1183">      for ( n = 0; n &lt; glyph-&gt;num_contours; n++ )</a>
<a name="ln1184">      {</a>
<a name="ln1185">        FT_UInt    count;</a>
<a name="ln1186">        PSH_Point  point;</a>
<a name="ln1187"> </a>
<a name="ln1188"> </a>
<a name="ln1189">        next  = (FT_UInt)outline-&gt;contours[n] + 1;</a>
<a name="ln1190">        count = next - first;</a>
<a name="ln1191"> </a>
<a name="ln1192">        contour-&gt;start = points + first;</a>
<a name="ln1193">        contour-&gt;count = count;</a>
<a name="ln1194"> </a>
<a name="ln1195">        if ( count &gt; 0 )</a>
<a name="ln1196">        {</a>
<a name="ln1197">          point = points + first;</a>
<a name="ln1198"> </a>
<a name="ln1199">          point-&gt;prev    = points + next - 1;</a>
<a name="ln1200">          point-&gt;contour = contour;</a>
<a name="ln1201"> </a>
<a name="ln1202">          for ( ; count &gt; 1; count-- )</a>
<a name="ln1203">          {</a>
<a name="ln1204">            point[0].next = point + 1;</a>
<a name="ln1205">            point[1].prev = point;</a>
<a name="ln1206">            point++;</a>
<a name="ln1207">            point-&gt;contour = contour;</a>
<a name="ln1208">          }</a>
<a name="ln1209">          point-&gt;next = points + first;</a>
<a name="ln1210">        }</a>
<a name="ln1211"> </a>
<a name="ln1212">        contour++;</a>
<a name="ln1213">        first = next;</a>
<a name="ln1214">      }</a>
<a name="ln1215">    }</a>
<a name="ln1216"> </a>
<a name="ln1217">    {</a>
<a name="ln1218">      PSH_Point   points = glyph-&gt;points;</a>
<a name="ln1219">      PSH_Point   point  = points;</a>
<a name="ln1220">      FT_Vector*  vec    = outline-&gt;points;</a>
<a name="ln1221">      FT_UInt     n;</a>
<a name="ln1222"> </a>
<a name="ln1223"> </a>
<a name="ln1224">      for ( n = 0; n &lt; glyph-&gt;num_points; n++, point++ )</a>
<a name="ln1225">      {</a>
<a name="ln1226">        FT_Int  n_prev = (FT_Int)( point-&gt;prev - points );</a>
<a name="ln1227">        FT_Int  n_next = (FT_Int)( point-&gt;next - points );</a>
<a name="ln1228">        FT_Pos  dxi, dyi, dxo, dyo;</a>
<a name="ln1229"> </a>
<a name="ln1230"> </a>
<a name="ln1231">        if ( !( outline-&gt;tags[n] &amp; FT_CURVE_TAG_ON ) )</a>
<a name="ln1232">          point-&gt;flags = PSH_POINT_OFF;</a>
<a name="ln1233"> </a>
<a name="ln1234">        dxi = vec[n].x - vec[n_prev].x;</a>
<a name="ln1235">        dyi = vec[n].y - vec[n_prev].y;</a>
<a name="ln1236"> </a>
<a name="ln1237">        point-&gt;dir_in = (FT_Char)psh_compute_dir( dxi, dyi );</a>
<a name="ln1238"> </a>
<a name="ln1239">        dxo = vec[n_next].x - vec[n].x;</a>
<a name="ln1240">        dyo = vec[n_next].y - vec[n].y;</a>
<a name="ln1241"> </a>
<a name="ln1242">        point-&gt;dir_out = (FT_Char)psh_compute_dir( dxo, dyo );</a>
<a name="ln1243"> </a>
<a name="ln1244">        /* detect smooth points */</a>
<a name="ln1245">        if ( point-&gt;flags &amp; PSH_POINT_OFF )</a>
<a name="ln1246">          point-&gt;flags |= PSH_POINT_SMOOTH;</a>
<a name="ln1247"> </a>
<a name="ln1248">        else if ( point-&gt;dir_in == point-&gt;dir_out )</a>
<a name="ln1249">        {</a>
<a name="ln1250">          if ( point-&gt;dir_out != PSH_DIR_NONE           ||</a>
<a name="ln1251">               psh_corner_is_flat( dxi, dyi, dxo, dyo ) )</a>
<a name="ln1252">            point-&gt;flags |= PSH_POINT_SMOOTH;</a>
<a name="ln1253">        }</a>
<a name="ln1254">      }</a>
<a name="ln1255">    }</a>
<a name="ln1256"> </a>
<a name="ln1257">    glyph-&gt;outline = outline;</a>
<a name="ln1258">    glyph-&gt;globals = globals;</a>
<a name="ln1259"> </a>
<a name="ln1260">#ifdef COMPUTE_INFLEXS</a>
<a name="ln1261">    psh_glyph_load_points( glyph, 0 );</a>
<a name="ln1262">    psh_glyph_compute_inflections( glyph );</a>
<a name="ln1263">#endif /* COMPUTE_INFLEXS */</a>
<a name="ln1264"> </a>
<a name="ln1265">    /* now deal with hints tables */</a>
<a name="ln1266">    error = psh_hint_table_init( &amp;glyph-&gt;hint_tables [0],</a>
<a name="ln1267">                                 &amp;ps_hints-&gt;dimension[0].hints,</a>
<a name="ln1268">                                 &amp;ps_hints-&gt;dimension[0].masks,</a>
<a name="ln1269">                                 &amp;ps_hints-&gt;dimension[0].counters,</a>
<a name="ln1270">                                 memory );</a>
<a name="ln1271">    if ( error )</a>
<a name="ln1272">      goto Exit;</a>
<a name="ln1273"> </a>
<a name="ln1274">    error = psh_hint_table_init( &amp;glyph-&gt;hint_tables [1],</a>
<a name="ln1275">                                 &amp;ps_hints-&gt;dimension[1].hints,</a>
<a name="ln1276">                                 &amp;ps_hints-&gt;dimension[1].masks,</a>
<a name="ln1277">                                 &amp;ps_hints-&gt;dimension[1].counters,</a>
<a name="ln1278">                                 memory );</a>
<a name="ln1279">    if ( error )</a>
<a name="ln1280">      goto Exit;</a>
<a name="ln1281"> </a>
<a name="ln1282">  Exit:</a>
<a name="ln1283">    return error;</a>
<a name="ln1284">  }</a>
<a name="ln1285"> </a>
<a name="ln1286"> </a>
<a name="ln1287">  /* compute all extrema in a glyph for a given dimension */</a>
<a name="ln1288">  static void</a>
<a name="ln1289">  psh_glyph_compute_extrema( PSH_Glyph  glyph )</a>
<a name="ln1290">  {</a>
<a name="ln1291">    FT_UInt  n;</a>
<a name="ln1292"> </a>
<a name="ln1293"> </a>
<a name="ln1294">    /* first of all, compute all local extrema */</a>
<a name="ln1295">    for ( n = 0; n &lt; glyph-&gt;num_contours; n++ )</a>
<a name="ln1296">    {</a>
<a name="ln1297">      PSH_Point  first = glyph-&gt;contours[n].start;</a>
<a name="ln1298">      PSH_Point  point, before, after;</a>
<a name="ln1299"> </a>
<a name="ln1300"> </a>
<a name="ln1301">      if ( glyph-&gt;contours[n].count == 0 )</a>
<a name="ln1302">        continue;</a>
<a name="ln1303"> </a>
<a name="ln1304">      point  = first;</a>
<a name="ln1305">      before = point;</a>
<a name="ln1306"> </a>
<a name="ln1307">      do</a>
<a name="ln1308">      {</a>
<a name="ln1309">        before = before-&gt;prev;</a>
<a name="ln1310">        if ( before == first )</a>
<a name="ln1311">          goto Skip;</a>
<a name="ln1312"> </a>
<a name="ln1313">      } while ( before-&gt;org_u == point-&gt;org_u );</a>
<a name="ln1314"> </a>
<a name="ln1315">      first = point = before-&gt;next;</a>
<a name="ln1316"> </a>
<a name="ln1317">      for (;;)</a>
<a name="ln1318">      {</a>
<a name="ln1319">        after = point;</a>
<a name="ln1320">        do</a>
<a name="ln1321">        {</a>
<a name="ln1322">          after = after-&gt;next;</a>
<a name="ln1323">          if ( after == first )</a>
<a name="ln1324">            goto Next;</a>
<a name="ln1325"> </a>
<a name="ln1326">        } while ( after-&gt;org_u == point-&gt;org_u );</a>
<a name="ln1327"> </a>
<a name="ln1328">        if ( before-&gt;org_u &lt; point-&gt;org_u )</a>
<a name="ln1329">        {</a>
<a name="ln1330">          if ( after-&gt;org_u &lt; point-&gt;org_u )</a>
<a name="ln1331">          {</a>
<a name="ln1332">            /* local maximum */</a>
<a name="ln1333">            goto Extremum;</a>
<a name="ln1334">          }</a>
<a name="ln1335">        }</a>
<a name="ln1336">        else /* before-&gt;org_u &gt; point-&gt;org_u */</a>
<a name="ln1337">        {</a>
<a name="ln1338">          if ( after-&gt;org_u &gt; point-&gt;org_u )</a>
<a name="ln1339">          {</a>
<a name="ln1340">            /* local minimum */</a>
<a name="ln1341">          Extremum:</a>
<a name="ln1342">            do</a>
<a name="ln1343">            {</a>
<a name="ln1344">              psh_point_set_extremum( point );</a>
<a name="ln1345">              point = point-&gt;next;</a>
<a name="ln1346"> </a>
<a name="ln1347">            } while ( point != after );</a>
<a name="ln1348">          }</a>
<a name="ln1349">        }</a>
<a name="ln1350"> </a>
<a name="ln1351">        before = after-&gt;prev;</a>
<a name="ln1352">        point  = after;</a>
<a name="ln1353"> </a>
<a name="ln1354">      } /* for  */</a>
<a name="ln1355"> </a>
<a name="ln1356">    Next:</a>
<a name="ln1357">      ;</a>
<a name="ln1358">    }</a>
<a name="ln1359"> </a>
<a name="ln1360">    /* for each extremum, determine its direction along the */</a>
<a name="ln1361">    /* orthogonal axis                                      */</a>
<a name="ln1362">    for ( n = 0; n &lt; glyph-&gt;num_points; n++ )</a>
<a name="ln1363">    {</a>
<a name="ln1364">      PSH_Point  point, before, after;</a>
<a name="ln1365"> </a>
<a name="ln1366"> </a>
<a name="ln1367">      point  = &amp;glyph-&gt;points[n];</a>
<a name="ln1368">      before = point;</a>
<a name="ln1369">      after  = point;</a>
<a name="ln1370"> </a>
<a name="ln1371">      if ( psh_point_is_extremum( point ) )</a>
<a name="ln1372">      {</a>
<a name="ln1373">        do</a>
<a name="ln1374">        {</a>
<a name="ln1375">          before = before-&gt;prev;</a>
<a name="ln1376">          if ( before == point )</a>
<a name="ln1377">            goto Skip;</a>
<a name="ln1378"> </a>
<a name="ln1379">        } while ( before-&gt;org_v == point-&gt;org_v );</a>
<a name="ln1380"> </a>
<a name="ln1381">        do</a>
<a name="ln1382">        {</a>
<a name="ln1383">          after = after-&gt;next;</a>
<a name="ln1384">          if ( after == point )</a>
<a name="ln1385">            goto Skip;</a>
<a name="ln1386"> </a>
<a name="ln1387">        } while ( after-&gt;org_v == point-&gt;org_v );</a>
<a name="ln1388">      }</a>
<a name="ln1389"> </a>
<a name="ln1390">      if ( before-&gt;org_v &lt; point-&gt;org_v &amp;&amp;</a>
<a name="ln1391">           after-&gt;org_v  &gt; point-&gt;org_v )</a>
<a name="ln1392">      {</a>
<a name="ln1393">        psh_point_set_positive( point );</a>
<a name="ln1394">      }</a>
<a name="ln1395">      else if ( before-&gt;org_v &gt; point-&gt;org_v &amp;&amp;</a>
<a name="ln1396">                after-&gt;org_v  &lt; point-&gt;org_v )</a>
<a name="ln1397">      {</a>
<a name="ln1398">        psh_point_set_negative( point );</a>
<a name="ln1399">      }</a>
<a name="ln1400"> </a>
<a name="ln1401">    Skip:</a>
<a name="ln1402">      ;</a>
<a name="ln1403">    }</a>
<a name="ln1404">  }</a>
<a name="ln1405"> </a>
<a name="ln1406"> </a>
<a name="ln1407">  /* major_dir is the direction for points on the bottom/left of the stem; */</a>
<a name="ln1408">  /* Points on the top/right of the stem will have a direction of          */</a>
<a name="ln1409">  /* -major_dir.                                                           */</a>
<a name="ln1410"> </a>
<a name="ln1411">  static void</a>
<a name="ln1412">  psh_hint_table_find_strong_points( PSH_Hint_Table  table,</a>
<a name="ln1413">                                     PSH_Point       point,</a>
<a name="ln1414">                                     FT_UInt         count,</a>
<a name="ln1415">                                     FT_Int          threshold,</a>
<a name="ln1416">                                     FT_Int          major_dir )</a>
<a name="ln1417">  {</a>
<a name="ln1418">    PSH_Hint*  sort      = table-&gt;sort;</a>
<a name="ln1419">    FT_UInt    num_hints = table-&gt;num_hints;</a>
<a name="ln1420"> </a>
<a name="ln1421"> </a>
<a name="ln1422">    for ( ; count &gt; 0; count--, point++ )</a>
<a name="ln1423">    {</a>
<a name="ln1424">      FT_Int  point_dir = 0;</a>
<a name="ln1425">      FT_Pos  org_u     = point-&gt;org_u;</a>
<a name="ln1426"> </a>
<a name="ln1427"> </a>
<a name="ln1428">      if ( psh_point_is_strong( point ) )</a>
<a name="ln1429">        continue;</a>
<a name="ln1430"> </a>
<a name="ln1431">      if ( PSH_DIR_COMPARE( point-&gt;dir_in, major_dir ) )</a>
<a name="ln1432">        point_dir = point-&gt;dir_in;</a>
<a name="ln1433"> </a>
<a name="ln1434">      else if ( PSH_DIR_COMPARE( point-&gt;dir_out, major_dir ) )</a>
<a name="ln1435">        point_dir = point-&gt;dir_out;</a>
<a name="ln1436"> </a>
<a name="ln1437">      if ( point_dir )</a>
<a name="ln1438">      {</a>
<a name="ln1439">        if ( point_dir == major_dir )</a>
<a name="ln1440">        {</a>
<a name="ln1441">          FT_UInt  nn;</a>
<a name="ln1442"> </a>
<a name="ln1443"> </a>
<a name="ln1444">          for ( nn = 0; nn &lt; num_hints; nn++ )</a>
<a name="ln1445">          {</a>
<a name="ln1446">            PSH_Hint  hint = sort[nn];</a>
<a name="ln1447">            FT_Pos    d    = org_u - hint-&gt;org_pos;</a>
<a name="ln1448"> </a>
<a name="ln1449"> </a>
<a name="ln1450">            if ( d &lt; threshold &amp;&amp; -d &lt; threshold )</a>
<a name="ln1451">            {</a>
<a name="ln1452">              psh_point_set_strong( point );</a>
<a name="ln1453">              point-&gt;flags2 |= PSH_POINT_EDGE_MIN;</a>
<a name="ln1454">              point-&gt;hint    = hint;</a>
<a name="ln1455">              break;</a>
<a name="ln1456">            }</a>
<a name="ln1457">          }</a>
<a name="ln1458">        }</a>
<a name="ln1459">        else if ( point_dir == -major_dir )</a>
<a name="ln1460">        {</a>
<a name="ln1461">          FT_UInt  nn;</a>
<a name="ln1462"> </a>
<a name="ln1463"> </a>
<a name="ln1464">          for ( nn = 0; nn &lt; num_hints; nn++ )</a>
<a name="ln1465">          {</a>
<a name="ln1466">            PSH_Hint  hint = sort[nn];</a>
<a name="ln1467">            FT_Pos    d    = org_u - hint-&gt;org_pos - hint-&gt;org_len;</a>
<a name="ln1468"> </a>
<a name="ln1469"> </a>
<a name="ln1470">            if ( d &lt; threshold &amp;&amp; -d &lt; threshold )</a>
<a name="ln1471">            {</a>
<a name="ln1472">              psh_point_set_strong( point );</a>
<a name="ln1473">              point-&gt;flags2 |= PSH_POINT_EDGE_MAX;</a>
<a name="ln1474">              point-&gt;hint    = hint;</a>
<a name="ln1475">              break;</a>
<a name="ln1476">            }</a>
<a name="ln1477">          }</a>
<a name="ln1478">        }</a>
<a name="ln1479">      }</a>
<a name="ln1480"> </a>
<a name="ln1481">#if 1</a>
<a name="ln1482">      else if ( psh_point_is_extremum( point ) )</a>
<a name="ln1483">      {</a>
<a name="ln1484">        /* treat extrema as special cases for stem edge alignment */</a>
<a name="ln1485">        FT_UInt  nn, min_flag, max_flag;</a>
<a name="ln1486"> </a>
<a name="ln1487"> </a>
<a name="ln1488">        if ( major_dir == PSH_DIR_HORIZONTAL )</a>
<a name="ln1489">        {</a>
<a name="ln1490">          min_flag = PSH_POINT_POSITIVE;</a>
<a name="ln1491">          max_flag = PSH_POINT_NEGATIVE;</a>
<a name="ln1492">        }</a>
<a name="ln1493">        else</a>
<a name="ln1494">        {</a>
<a name="ln1495">          min_flag = PSH_POINT_NEGATIVE;</a>
<a name="ln1496">          max_flag = PSH_POINT_POSITIVE;</a>
<a name="ln1497">        }</a>
<a name="ln1498"> </a>
<a name="ln1499">        if ( point-&gt;flags2 &amp; min_flag )</a>
<a name="ln1500">        {</a>
<a name="ln1501">          for ( nn = 0; nn &lt; num_hints; nn++ )</a>
<a name="ln1502">          {</a>
<a name="ln1503">            PSH_Hint  hint = sort[nn];</a>
<a name="ln1504">            FT_Pos    d    = org_u - hint-&gt;org_pos;</a>
<a name="ln1505"> </a>
<a name="ln1506"> </a>
<a name="ln1507">            if ( d &lt; threshold &amp;&amp; -d &lt; threshold )</a>
<a name="ln1508">            {</a>
<a name="ln1509">              point-&gt;flags2 |= PSH_POINT_EDGE_MIN;</a>
<a name="ln1510">              point-&gt;hint    = hint;</a>
<a name="ln1511">              psh_point_set_strong( point );</a>
<a name="ln1512">              break;</a>
<a name="ln1513">            }</a>
<a name="ln1514">          }</a>
<a name="ln1515">        }</a>
<a name="ln1516">        else if ( point-&gt;flags2 &amp; max_flag )</a>
<a name="ln1517">        {</a>
<a name="ln1518">          for ( nn = 0; nn &lt; num_hints; nn++ )</a>
<a name="ln1519">          {</a>
<a name="ln1520">            PSH_Hint  hint = sort[nn];</a>
<a name="ln1521">            FT_Pos    d    = org_u - hint-&gt;org_pos - hint-&gt;org_len;</a>
<a name="ln1522"> </a>
<a name="ln1523"> </a>
<a name="ln1524">            if ( d &lt; threshold &amp;&amp; -d &lt; threshold )</a>
<a name="ln1525">            {</a>
<a name="ln1526">              point-&gt;flags2 |= PSH_POINT_EDGE_MAX;</a>
<a name="ln1527">              point-&gt;hint    = hint;</a>
<a name="ln1528">              psh_point_set_strong( point );</a>
<a name="ln1529">              break;</a>
<a name="ln1530">            }</a>
<a name="ln1531">          }</a>
<a name="ln1532">        }</a>
<a name="ln1533"> </a>
<a name="ln1534">        if ( point-&gt;hint == NULL )</a>
<a name="ln1535">        {</a>
<a name="ln1536">          for ( nn = 0; nn &lt; num_hints; nn++ )</a>
<a name="ln1537">          {</a>
<a name="ln1538">            PSH_Hint  hint = sort[nn];</a>
<a name="ln1539"> </a>
<a name="ln1540"> </a>
<a name="ln1541">            if ( org_u &gt;= hint-&gt;org_pos                 &amp;&amp;</a>
<a name="ln1542">                org_u &lt;= hint-&gt;org_pos + hint-&gt;org_len )</a>
<a name="ln1543">            {</a>
<a name="ln1544">              point-&gt;hint = hint;</a>
<a name="ln1545">              break;</a>
<a name="ln1546">            }</a>
<a name="ln1547">          }</a>
<a name="ln1548">        }</a>
<a name="ln1549">      }</a>
<a name="ln1550"> </a>
<a name="ln1551">#endif /* 1 */</a>
<a name="ln1552">    }</a>
<a name="ln1553">  }</a>
<a name="ln1554"> </a>
<a name="ln1555"> </a>
<a name="ln1556">  /* the accepted shift for strong points in fractional pixels */</a>
<a name="ln1557">#define PSH_STRONG_THRESHOLD  32</a>
<a name="ln1558"> </a>
<a name="ln1559">  /* the maximum shift value in font units */</a>
<a name="ln1560">#define PSH_STRONG_THRESHOLD_MAXIMUM  30</a>
<a name="ln1561"> </a>
<a name="ln1562"> </a>
<a name="ln1563">  /* find strong points in a glyph */</a>
<a name="ln1564">  static void</a>
<a name="ln1565">  psh_glyph_find_strong_points( PSH_Glyph  glyph,</a>
<a name="ln1566">                                FT_Int     dimension )</a>
<a name="ln1567">  {</a>
<a name="ln1568">    /* a point is `strong' if it is located on a stem edge and       */</a>
<a name="ln1569">    /* has an `in' or `out' tangent parallel to the hint's direction */</a>
<a name="ln1570"> </a>
<a name="ln1571">    PSH_Hint_Table  table     = &amp;glyph-&gt;hint_tables[dimension];</a>
<a name="ln1572">    PS_Mask         mask      = table-&gt;hint_masks-&gt;masks;</a>
<a name="ln1573">    FT_UInt         num_masks = table-&gt;hint_masks-&gt;num_masks;</a>
<a name="ln1574">    FT_UInt         first     = 0;</a>
<a name="ln1575">    FT_Int          major_dir = dimension == 0 ? PSH_DIR_VERTICAL</a>
<a name="ln1576">                                               : PSH_DIR_HORIZONTAL;</a>
<a name="ln1577">    PSH_Dimension   dim       = &amp;glyph-&gt;globals-&gt;dimension[dimension];</a>
<a name="ln1578">    FT_Fixed        scale     = dim-&gt;scale_mult;</a>
<a name="ln1579">    FT_Int          threshold;</a>
<a name="ln1580"> </a>
<a name="ln1581"> </a>
<a name="ln1582">    threshold = (FT_Int)FT_DivFix( PSH_STRONG_THRESHOLD, scale );</a>
<a name="ln1583">    if ( threshold &gt; PSH_STRONG_THRESHOLD_MAXIMUM )</a>
<a name="ln1584">      threshold = PSH_STRONG_THRESHOLD_MAXIMUM;</a>
<a name="ln1585"> </a>
<a name="ln1586">    /* process secondary hints to `selected' points */</a>
<a name="ln1587">    if ( num_masks &gt; 1 &amp;&amp; glyph-&gt;num_points &gt; 0 )</a>
<a name="ln1588">    {</a>
<a name="ln1589">      /* the `endchar' op can reduce the number of points */</a>
<a name="ln1590">      first = mask-&gt;end_point &gt; glyph-&gt;num_points</a>
<a name="ln1591">                ? glyph-&gt;num_points</a>
<a name="ln1592">                : mask-&gt;end_point;</a>
<a name="ln1593">      mask++;</a>
<a name="ln1594">      for ( ; num_masks &gt; 1; num_masks--, mask++ )</a>
<a name="ln1595">      {</a>
<a name="ln1596">        FT_UInt  next = FT_MIN( mask-&gt;end_point, glyph-&gt;num_points );</a>
<a name="ln1597"> </a>
<a name="ln1598"> </a>
<a name="ln1599">        if ( next &gt; first )</a>
<a name="ln1600">        {</a>
<a name="ln1601">          FT_UInt    count = next - first;</a>
<a name="ln1602">          PSH_Point  point = glyph-&gt;points + first;</a>
<a name="ln1603"> </a>
<a name="ln1604"> </a>
<a name="ln1605">          psh_hint_table_activate_mask( table, mask );</a>
<a name="ln1606"> </a>
<a name="ln1607">          psh_hint_table_find_strong_points( table, point, count,</a>
<a name="ln1608">                                             threshold, major_dir );</a>
<a name="ln1609">        }</a>
<a name="ln1610">        first = next;</a>
<a name="ln1611">      }</a>
<a name="ln1612">    }</a>
<a name="ln1613"> </a>
<a name="ln1614">    /* process primary hints for all points */</a>
<a name="ln1615">    if ( num_masks == 1 )</a>
<a name="ln1616">    {</a>
<a name="ln1617">      FT_UInt    count = glyph-&gt;num_points;</a>
<a name="ln1618">      PSH_Point  point = glyph-&gt;points;</a>
<a name="ln1619"> </a>
<a name="ln1620"> </a>
<a name="ln1621">      psh_hint_table_activate_mask( table, table-&gt;hint_masks-&gt;masks );</a>
<a name="ln1622"> </a>
<a name="ln1623">      psh_hint_table_find_strong_points( table, point, count,</a>
<a name="ln1624">                                         threshold, major_dir );</a>
<a name="ln1625">    }</a>
<a name="ln1626"> </a>
<a name="ln1627">    /* now, certain points may have been attached to a hint and */</a>
<a name="ln1628">    /* not marked as strong; update their flags then            */</a>
<a name="ln1629">    {</a>
<a name="ln1630">      FT_UInt    count = glyph-&gt;num_points;</a>
<a name="ln1631">      PSH_Point  point = glyph-&gt;points;</a>
<a name="ln1632"> </a>
<a name="ln1633"> </a>
<a name="ln1634">      for ( ; count &gt; 0; count--, point++ )</a>
<a name="ln1635">        if ( point-&gt;hint &amp;&amp; !psh_point_is_strong( point ) )</a>
<a name="ln1636">          psh_point_set_strong( point );</a>
<a name="ln1637">    }</a>
<a name="ln1638">  }</a>
<a name="ln1639"> </a>
<a name="ln1640"> </a>
<a name="ln1641">  /* find points in a glyph which are in a blue zone and have `in' or */</a>
<a name="ln1642">  /* `out' tangents parallel to the horizontal axis                   */</a>
<a name="ln1643">  static void</a>
<a name="ln1644">  psh_glyph_find_blue_points( PSH_Blues  blues,</a>
<a name="ln1645">                              PSH_Glyph  glyph )</a>
<a name="ln1646">  {</a>
<a name="ln1647">    PSH_Blue_Table  table;</a>
<a name="ln1648">    PSH_Blue_Zone   zone;</a>
<a name="ln1649">    FT_UInt         glyph_count = glyph-&gt;num_points;</a>
<a name="ln1650">    FT_UInt         blue_count;</a>
<a name="ln1651">    PSH_Point       point = glyph-&gt;points;</a>
<a name="ln1652"> </a>
<a name="ln1653"> </a>
<a name="ln1654">    for ( ; glyph_count &gt; 0; glyph_count--, point++ )</a>
<a name="ln1655">    {</a>
<a name="ln1656">      FT_Pos  y;</a>
<a name="ln1657"> </a>
<a name="ln1658"> </a>
<a name="ln1659">      /* check tangents */</a>
<a name="ln1660">      if ( !PSH_DIR_COMPARE( point-&gt;dir_in,  PSH_DIR_HORIZONTAL ) &amp;&amp;</a>
<a name="ln1661">           !PSH_DIR_COMPARE( point-&gt;dir_out, PSH_DIR_HORIZONTAL ) )</a>
<a name="ln1662">        continue;</a>
<a name="ln1663"> </a>
<a name="ln1664">      /* skip strong points */</a>
<a name="ln1665">      if ( psh_point_is_strong( point ) )</a>
<a name="ln1666">        continue;</a>
<a name="ln1667"> </a>
<a name="ln1668">      y = point-&gt;org_u;</a>
<a name="ln1669"> </a>
<a name="ln1670">      /* look up top zones */</a>
<a name="ln1671">      table      = &amp;blues-&gt;normal_top;</a>
<a name="ln1672">      blue_count = table-&gt;count;</a>
<a name="ln1673">      zone       = table-&gt;zones;</a>
<a name="ln1674"> </a>
<a name="ln1675">      for ( ; blue_count &gt; 0; blue_count--, zone++ )</a>
<a name="ln1676">      {</a>
<a name="ln1677">        FT_Pos  delta = y - zone-&gt;org_bottom;</a>
<a name="ln1678"> </a>
<a name="ln1679"> </a>
<a name="ln1680">        if ( delta &lt; -blues-&gt;blue_fuzz )</a>
<a name="ln1681">          break;</a>
<a name="ln1682"> </a>
<a name="ln1683">        if ( y &lt;= zone-&gt;org_top + blues-&gt;blue_fuzz )</a>
<a name="ln1684">          if ( blues-&gt;no_overshoots || delta &lt;= blues-&gt;blue_threshold )</a>
<a name="ln1685">          {</a>
<a name="ln1686">            point-&gt;cur_u = zone-&gt;cur_bottom;</a>
<a name="ln1687">            psh_point_set_strong( point );</a>
<a name="ln1688">            psh_point_set_fitted( point );</a>
<a name="ln1689">          }</a>
<a name="ln1690">      }</a>
<a name="ln1691"> </a>
<a name="ln1692">      /* look up bottom zones */</a>
<a name="ln1693">      table      = &amp;blues-&gt;normal_bottom;</a>
<a name="ln1694">      blue_count = table-&gt;count;</a>
<a name="ln1695">      zone       = table-&gt;zones + blue_count - 1;</a>
<a name="ln1696"> </a>
<a name="ln1697">      for ( ; blue_count &gt; 0; blue_count--, zone-- )</a>
<a name="ln1698">      {</a>
<a name="ln1699">        FT_Pos  delta = zone-&gt;org_top - y;</a>
<a name="ln1700"> </a>
<a name="ln1701"> </a>
<a name="ln1702">        if ( delta &lt; -blues-&gt;blue_fuzz )</a>
<a name="ln1703">          break;</a>
<a name="ln1704"> </a>
<a name="ln1705">        if ( y &gt;= zone-&gt;org_bottom - blues-&gt;blue_fuzz )</a>
<a name="ln1706">          if ( blues-&gt;no_overshoots || delta &lt; blues-&gt;blue_threshold )</a>
<a name="ln1707">          {</a>
<a name="ln1708">            point-&gt;cur_u = zone-&gt;cur_top;</a>
<a name="ln1709">            psh_point_set_strong( point );</a>
<a name="ln1710">            psh_point_set_fitted( point );</a>
<a name="ln1711">          }</a>
<a name="ln1712">      }</a>
<a name="ln1713">    }</a>
<a name="ln1714">  }</a>
<a name="ln1715"> </a>
<a name="ln1716"> </a>
<a name="ln1717">  /* interpolate strong points with the help of hinted coordinates */</a>
<a name="ln1718">  static void</a>
<a name="ln1719">  psh_glyph_interpolate_strong_points( PSH_Glyph  glyph,</a>
<a name="ln1720">                                       FT_Int     dimension )</a>
<a name="ln1721">  {</a>
<a name="ln1722">    PSH_Dimension  dim   = &amp;glyph-&gt;globals-&gt;dimension[dimension];</a>
<a name="ln1723">    FT_Fixed       scale = dim-&gt;scale_mult;</a>
<a name="ln1724"> </a>
<a name="ln1725">    FT_UInt        count = glyph-&gt;num_points;</a>
<a name="ln1726">    PSH_Point      point = glyph-&gt;points;</a>
<a name="ln1727"> </a>
<a name="ln1728"> </a>
<a name="ln1729">    for ( ; count &gt; 0; count--, point++ )</a>
<a name="ln1730">    {</a>
<a name="ln1731">      PSH_Hint  hint = point-&gt;hint;</a>
<a name="ln1732"> </a>
<a name="ln1733"> </a>
<a name="ln1734">      if ( hint )</a>
<a name="ln1735">      {</a>
<a name="ln1736">        FT_Pos  delta;</a>
<a name="ln1737"> </a>
<a name="ln1738"> </a>
<a name="ln1739">        if ( psh_point_is_edge_min( point ) )</a>
<a name="ln1740">          point-&gt;cur_u = hint-&gt;cur_pos;</a>
<a name="ln1741"> </a>
<a name="ln1742">        else if ( psh_point_is_edge_max( point ) )</a>
<a name="ln1743">          point-&gt;cur_u = hint-&gt;cur_pos + hint-&gt;cur_len;</a>
<a name="ln1744"> </a>
<a name="ln1745">        else</a>
<a name="ln1746">        {</a>
<a name="ln1747">          delta = point-&gt;org_u - hint-&gt;org_pos;</a>
<a name="ln1748"> </a>
<a name="ln1749">          if ( delta &lt;= 0 )</a>
<a name="ln1750">            point-&gt;cur_u = hint-&gt;cur_pos + FT_MulFix( delta, scale );</a>
<a name="ln1751"> </a>
<a name="ln1752">          else if ( delta &gt;= hint-&gt;org_len )</a>
<a name="ln1753">            point-&gt;cur_u = hint-&gt;cur_pos + hint-&gt;cur_len +</a>
<a name="ln1754">                             FT_MulFix( delta - hint-&gt;org_len, scale );</a>
<a name="ln1755"> </a>
<a name="ln1756">          else /* hint-&gt;org_len &gt; 0 */</a>
<a name="ln1757">            point-&gt;cur_u = hint-&gt;cur_pos +</a>
<a name="ln1758">                             FT_MulDiv( delta, hint-&gt;cur_len,</a>
<a name="ln1759">                                        hint-&gt;org_len );</a>
<a name="ln1760">        }</a>
<a name="ln1761">        psh_point_set_fitted( point );</a>
<a name="ln1762">      }</a>
<a name="ln1763">    }</a>
<a name="ln1764">  }</a>
<a name="ln1765"> </a>
<a name="ln1766"> </a>
<a name="ln1767">#define  PSH_MAX_STRONG_INTERNAL  16</a>
<a name="ln1768"> </a>
<a name="ln1769">  static void</a>
<a name="ln1770">  psh_glyph_interpolate_normal_points( PSH_Glyph  glyph,</a>
<a name="ln1771">                                       FT_Int     dimension )</a>
<a name="ln1772">  {</a>
<a name="ln1773"> </a>
<a name="ln1774">#if 1</a>
<a name="ln1775">    /* first technique: a point is strong if it is a local extremum */</a>
<a name="ln1776"> </a>
<a name="ln1777">    PSH_Dimension  dim    = &amp;glyph-&gt;globals-&gt;dimension[dimension];</a>
<a name="ln1778">    FT_Fixed       scale  = dim-&gt;scale_mult;</a>
<a name="ln1779">    FT_Memory      memory = glyph-&gt;memory;</a>
<a name="ln1780"> </a>
<a name="ln1781">    PSH_Point*     strongs     = NULL;</a>
<a name="ln1782">    PSH_Point      strongs_0[PSH_MAX_STRONG_INTERNAL];</a>
<a name="ln1783">    FT_UInt        num_strongs = 0;</a>
<a name="ln1784"> </a>
<a name="ln1785">    PSH_Point      points = glyph-&gt;points;</a>
<a name="ln1786">    PSH_Point      points_end = points + glyph-&gt;num_points;</a>
<a name="ln1787">    PSH_Point      point;</a>
<a name="ln1788"> </a>
<a name="ln1789"> </a>
<a name="ln1790">    /* first count the number of strong points */</a>
<a name="ln1791">    for ( point = points; point &lt; points_end; point++ )</a>
<a name="ln1792">    {</a>
<a name="ln1793">      if ( psh_point_is_strong( point ) )</a>
<a name="ln1794">        num_strongs++;</a>
<a name="ln1795">    }</a>
<a name="ln1796"> </a>
<a name="ln1797">    if ( num_strongs == 0 )  /* nothing to do here */</a>
<a name="ln1798">      return;</a>
<a name="ln1799"> </a>
<a name="ln1800">    /* allocate an array to store a list of points, */</a>
<a name="ln1801">    /* stored in increasing org_u order             */</a>
<a name="ln1802">    if ( num_strongs &lt;= PSH_MAX_STRONG_INTERNAL )</a>
<a name="ln1803">      strongs = strongs_0;</a>
<a name="ln1804">    else</a>
<a name="ln1805">    {</a>
<a name="ln1806">      FT_Error  error;</a>
<a name="ln1807"> </a>
<a name="ln1808"> </a>
<a name="ln1809">      if ( FT_NEW_ARRAY( strongs, num_strongs ) )</a>
<a name="ln1810">        return;</a>
<a name="ln1811">    }</a>
<a name="ln1812"> </a>
<a name="ln1813">    num_strongs = 0;</a>
<a name="ln1814">    for ( point = points; point &lt; points_end; point++ )</a>
<a name="ln1815">    {</a>
<a name="ln1816">      PSH_Point*  insert;</a>
<a name="ln1817"> </a>
<a name="ln1818"> </a>
<a name="ln1819">      if ( !psh_point_is_strong( point ) )</a>
<a name="ln1820">        continue;</a>
<a name="ln1821"> </a>
<a name="ln1822">      for ( insert = strongs + num_strongs; insert &gt; strongs; insert-- )</a>
<a name="ln1823">      {</a>
<a name="ln1824">        if ( insert[-1]-&gt;org_u &lt;= point-&gt;org_u )</a>
<a name="ln1825">          break;</a>
<a name="ln1826"> </a>
<a name="ln1827">        insert[0] = insert[-1];</a>
<a name="ln1828">      }</a>
<a name="ln1829">      insert[0] = point;</a>
<a name="ln1830">      num_strongs++;</a>
<a name="ln1831">    }</a>
<a name="ln1832"> </a>
<a name="ln1833">    /* now try to interpolate all normal points */</a>
<a name="ln1834">    for ( point = points; point &lt; points_end; point++ )</a>
<a name="ln1835">    {</a>
<a name="ln1836">      if ( psh_point_is_strong( point ) )</a>
<a name="ln1837">        continue;</a>
<a name="ln1838"> </a>
<a name="ln1839">      /* sometimes, some local extrema are smooth points */</a>
<a name="ln1840">      if ( psh_point_is_smooth( point ) )</a>
<a name="ln1841">      {</a>
<a name="ln1842">        if ( point-&gt;dir_in == PSH_DIR_NONE   ||</a>
<a name="ln1843">             point-&gt;dir_in != point-&gt;dir_out )</a>
<a name="ln1844">          continue;</a>
<a name="ln1845"> </a>
<a name="ln1846">        if ( !psh_point_is_extremum( point ) &amp;&amp;</a>
<a name="ln1847">             !psh_point_is_inflex( point )   )</a>
<a name="ln1848">          continue;</a>
<a name="ln1849"> </a>
<a name="ln1850">        point-&gt;flags &amp;= ~PSH_POINT_SMOOTH;</a>
<a name="ln1851">      }</a>
<a name="ln1852"> </a>
<a name="ln1853">      /* find best enclosing point coordinates then interpolate */</a>
<a name="ln1854">      {</a>
<a name="ln1855">        PSH_Point   before, after;</a>
<a name="ln1856">        FT_UInt     nn;</a>
<a name="ln1857"> </a>
<a name="ln1858"> </a>
<a name="ln1859">        for ( nn = 0; nn &lt; num_strongs; nn++ )</a>
<a name="ln1860">          if ( strongs[nn]-&gt;org_u &gt; point-&gt;org_u )</a>
<a name="ln1861">            break;</a>
<a name="ln1862"> </a>
<a name="ln1863">        if ( nn == 0 )  /* point before the first strong point */</a>
<a name="ln1864">        {</a>
<a name="ln1865">          after = strongs[0];</a>
<a name="ln1866"> </a>
<a name="ln1867">          point-&gt;cur_u = after-&gt;cur_u +</a>
<a name="ln1868">                           FT_MulFix( point-&gt;org_u - after-&gt;org_u,</a>
<a name="ln1869">                                      scale );</a>
<a name="ln1870">        }</a>
<a name="ln1871">        else</a>
<a name="ln1872">        {</a>
<a name="ln1873">          before = strongs[nn - 1];</a>
<a name="ln1874"> </a>
<a name="ln1875">          for ( nn = num_strongs; nn &gt; 0; nn-- )</a>
<a name="ln1876">            if ( strongs[nn - 1]-&gt;org_u &lt; point-&gt;org_u )</a>
<a name="ln1877">              break;</a>
<a name="ln1878"> </a>
<a name="ln1879">          if ( nn == num_strongs )  /* point is after last strong point */</a>
<a name="ln1880">          {</a>
<a name="ln1881">            before = strongs[nn - 1];</a>
<a name="ln1882"> </a>
<a name="ln1883">            point-&gt;cur_u = before-&gt;cur_u +</a>
<a name="ln1884">                             FT_MulFix( point-&gt;org_u - before-&gt;org_u,</a>
<a name="ln1885">                                        scale );</a>
<a name="ln1886">          }</a>
<a name="ln1887">          else</a>
<a name="ln1888">          {</a>
<a name="ln1889">            FT_Pos  u;</a>
<a name="ln1890"> </a>
<a name="ln1891"> </a>
<a name="ln1892">            after = strongs[nn];</a>
<a name="ln1893"> </a>
<a name="ln1894">            /* now interpolate point between before and after */</a>
<a name="ln1895">            u = point-&gt;org_u;</a>
<a name="ln1896"> </a>
<a name="ln1897">            if ( u == before-&gt;org_u )</a>
<a name="ln1898">              point-&gt;cur_u = before-&gt;cur_u;</a>
<a name="ln1899"> </a>
<a name="ln1900">            else if ( u == after-&gt;org_u )</a>
<a name="ln1901">              point-&gt;cur_u = after-&gt;cur_u;</a>
<a name="ln1902"> </a>
<a name="ln1903">            else</a>
<a name="ln1904">              point-&gt;cur_u = before-&gt;cur_u +</a>
<a name="ln1905">                               FT_MulDiv( u - before-&gt;org_u,</a>
<a name="ln1906">                                          after-&gt;cur_u - before-&gt;cur_u,</a>
<a name="ln1907">                                          after-&gt;org_u - before-&gt;org_u );</a>
<a name="ln1908">          }</a>
<a name="ln1909">        }</a>
<a name="ln1910">        psh_point_set_fitted( point );</a>
<a name="ln1911">      }</a>
<a name="ln1912">    }</a>
<a name="ln1913"> </a>
<a name="ln1914">    if ( strongs != strongs_0 )</a>
<a name="ln1915">      FT_FREE( strongs );</a>
<a name="ln1916"> </a>
<a name="ln1917">#endif /* 1 */</a>
<a name="ln1918"> </a>
<a name="ln1919">  }</a>
<a name="ln1920"> </a>
<a name="ln1921"> </a>
<a name="ln1922">  /* interpolate other points */</a>
<a name="ln1923">  static void</a>
<a name="ln1924">  psh_glyph_interpolate_other_points( PSH_Glyph  glyph,</a>
<a name="ln1925">                                      FT_Int     dimension )</a>
<a name="ln1926">  {</a>
<a name="ln1927">    PSH_Dimension  dim          = &amp;glyph-&gt;globals-&gt;dimension[dimension];</a>
<a name="ln1928">    FT_Fixed       scale        = dim-&gt;scale_mult;</a>
<a name="ln1929">    FT_Fixed       delta        = dim-&gt;scale_delta;</a>
<a name="ln1930">    PSH_Contour    contour      = glyph-&gt;contours;</a>
<a name="ln1931">    FT_UInt        num_contours = glyph-&gt;num_contours;</a>
<a name="ln1932"> </a>
<a name="ln1933"> </a>
<a name="ln1934">    for ( ; num_contours &gt; 0; num_contours--, contour++ )</a>
<a name="ln1935">    {</a>
<a name="ln1936">      PSH_Point  start = contour-&gt;start;</a>
<a name="ln1937">      PSH_Point  first, next, point;</a>
<a name="ln1938">      FT_UInt    fit_count;</a>
<a name="ln1939"> </a>
<a name="ln1940"> </a>
<a name="ln1941">      /* count the number of strong points in this contour */</a>
<a name="ln1942">      next      = start + contour-&gt;count;</a>
<a name="ln1943">      fit_count = 0;</a>
<a name="ln1944">      first     = NULL;</a>
<a name="ln1945"> </a>
<a name="ln1946">      for ( point = start; point &lt; next; point++ )</a>
<a name="ln1947">        if ( psh_point_is_fitted( point ) )</a>
<a name="ln1948">        {</a>
<a name="ln1949">          if ( !first )</a>
<a name="ln1950">            first = point;</a>
<a name="ln1951"> </a>
<a name="ln1952">          fit_count++;</a>
<a name="ln1953">        }</a>
<a name="ln1954"> </a>
<a name="ln1955">      /* if there are less than 2 fitted points in the contour, we */</a>
<a name="ln1956">      /* simply scale and eventually translate the contour points  */</a>
<a name="ln1957">      if ( fit_count &lt; 2 )</a>
<a name="ln1958">      {</a>
<a name="ln1959">        if ( fit_count == 1 )</a>
<a name="ln1960">          delta = first-&gt;cur_u - FT_MulFix( first-&gt;org_u, scale );</a>
<a name="ln1961"> </a>
<a name="ln1962">        for ( point = start; point &lt; next; point++ )</a>
<a name="ln1963">          if ( point != first )</a>
<a name="ln1964">            point-&gt;cur_u = FT_MulFix( point-&gt;org_u, scale ) + delta;</a>
<a name="ln1965"> </a>
<a name="ln1966">        goto Next_Contour;</a>
<a name="ln1967">      }</a>
<a name="ln1968"> </a>
<a name="ln1969">      /* there are more than 2 strong points in this contour; we */</a>
<a name="ln1970">      /* need to interpolate weak points between them            */</a>
<a name="ln1971">      start = first;</a>
<a name="ln1972">      do</a>
<a name="ln1973">      {</a>
<a name="ln1974">        /* skip consecutive fitted points */</a>
<a name="ln1975">        for (;;)</a>
<a name="ln1976">        {</a>
<a name="ln1977">          next = first-&gt;next;</a>
<a name="ln1978">          if ( next == start )</a>
<a name="ln1979">            goto Next_Contour;</a>
<a name="ln1980"> </a>
<a name="ln1981">          if ( !psh_point_is_fitted( next ) )</a>
<a name="ln1982">            break;</a>
<a name="ln1983"> </a>
<a name="ln1984">          first = next;</a>
<a name="ln1985">        }</a>
<a name="ln1986"> </a>
<a name="ln1987">        /* find next fitted point after unfitted one */</a>
<a name="ln1988">        for (;;)</a>
<a name="ln1989">        {</a>
<a name="ln1990">          next = next-&gt;next;</a>
<a name="ln1991">          if ( psh_point_is_fitted( next ) )</a>
<a name="ln1992">            break;</a>
<a name="ln1993">        }</a>
<a name="ln1994"> </a>
<a name="ln1995">        /* now interpolate between them */</a>
<a name="ln1996">        {</a>
<a name="ln1997">          FT_Pos    org_a, org_ab, cur_a, cur_ab;</a>
<a name="ln1998">          FT_Pos    org_c, org_ac, cur_c;</a>
<a name="ln1999">          FT_Fixed  scale_ab;</a>
<a name="ln2000"> </a>
<a name="ln2001"> </a>
<a name="ln2002">          if ( first-&gt;org_u &lt;= next-&gt;org_u )</a>
<a name="ln2003">          {</a>
<a name="ln2004">            org_a  = first-&gt;org_u;</a>
<a name="ln2005">            cur_a  = first-&gt;cur_u;</a>
<a name="ln2006">            org_ab = next-&gt;org_u - org_a;</a>
<a name="ln2007">            cur_ab = next-&gt;cur_u - cur_a;</a>
<a name="ln2008">          }</a>
<a name="ln2009">          else</a>
<a name="ln2010">          {</a>
<a name="ln2011">            org_a  = next-&gt;org_u;</a>
<a name="ln2012">            cur_a  = next-&gt;cur_u;</a>
<a name="ln2013">            org_ab = first-&gt;org_u - org_a;</a>
<a name="ln2014">            cur_ab = first-&gt;cur_u - cur_a;</a>
<a name="ln2015">          }</a>
<a name="ln2016"> </a>
<a name="ln2017">          scale_ab = 0x10000L;</a>
<a name="ln2018">          if ( org_ab &gt; 0 )</a>
<a name="ln2019">            scale_ab = FT_DivFix( cur_ab, org_ab );</a>
<a name="ln2020"> </a>
<a name="ln2021">          point = first-&gt;next;</a>
<a name="ln2022">          do</a>
<a name="ln2023">          {</a>
<a name="ln2024">            org_c  = point-&gt;org_u;</a>
<a name="ln2025">            org_ac = org_c - org_a;</a>
<a name="ln2026"> </a>
<a name="ln2027">            if ( org_ac &lt;= 0 )</a>
<a name="ln2028">            {</a>
<a name="ln2029">              /* on the left of the interpolation zone */</a>
<a name="ln2030">              cur_c = cur_a + FT_MulFix( org_ac, scale );</a>
<a name="ln2031">            }</a>
<a name="ln2032">            else if ( org_ac &gt;= org_ab )</a>
<a name="ln2033">            {</a>
<a name="ln2034">              /* on the right on the interpolation zone */</a>
<a name="ln2035">              cur_c = cur_a + cur_ab + FT_MulFix( org_ac - org_ab, scale );</a>
<a name="ln2036">            }</a>
<a name="ln2037">            else</a>
<a name="ln2038">            {</a>
<a name="ln2039">              /* within the interpolation zone */</a>
<a name="ln2040">              cur_c = cur_a + FT_MulFix( org_ac, scale_ab );</a>
<a name="ln2041">            }</a>
<a name="ln2042"> </a>
<a name="ln2043">            point-&gt;cur_u = cur_c;</a>
<a name="ln2044"> </a>
<a name="ln2045">            point = point-&gt;next;</a>
<a name="ln2046"> </a>
<a name="ln2047">          } while ( point != next );</a>
<a name="ln2048">        }</a>
<a name="ln2049"> </a>
<a name="ln2050">        /* keep going until all points in the contours have been processed */</a>
<a name="ln2051">        first = next;</a>
<a name="ln2052"> </a>
<a name="ln2053">      } while ( first != start );</a>
<a name="ln2054"> </a>
<a name="ln2055">    Next_Contour:</a>
<a name="ln2056">      ;</a>
<a name="ln2057">    }</a>
<a name="ln2058">  }</a>
<a name="ln2059"> </a>
<a name="ln2060"> </a>
<a name="ln2061">  /*************************************************************************/</a>
<a name="ln2062">  /*************************************************************************/</a>
<a name="ln2063">  /*****                                                               *****/</a>
<a name="ln2064">  /*****                     HIGH-LEVEL INTERFACE                      *****/</a>
<a name="ln2065">  /*****                                                               *****/</a>
<a name="ln2066">  /*************************************************************************/</a>
<a name="ln2067">  /*************************************************************************/</a>
<a name="ln2068"> </a>
<a name="ln2069">  FT_Error</a>
<a name="ln2070">  ps_hints_apply( PS_Hints        ps_hints,</a>
<a name="ln2071">                  FT_Outline*     outline,</a>
<a name="ln2072">                  PSH_Globals     globals,</a>
<a name="ln2073">                  FT_Render_Mode  hint_mode )</a>
<a name="ln2074">  {</a>
<a name="ln2075">    PSH_GlyphRec  glyphrec;</a>
<a name="ln2076">    PSH_Glyph     glyph = &amp;glyphrec;</a>
<a name="ln2077">    FT_Error      error;</a>
<a name="ln2078">#ifdef DEBUG_HINTER</a>
<a name="ln2079">    FT_Memory     memory;</a>
<a name="ln2080">#endif</a>
<a name="ln2081">    FT_Int        dimension;</a>
<a name="ln2082"> </a>
<a name="ln2083"> </a>
<a name="ln2084">    /* something to do? */</a>
<a name="ln2085">    if ( outline-&gt;n_points == 0 || outline-&gt;n_contours == 0 )</a>
<a name="ln2086">      return FT_Err_Ok;</a>
<a name="ln2087"> </a>
<a name="ln2088">#ifdef DEBUG_HINTER</a>
<a name="ln2089"> </a>
<a name="ln2090">    memory = globals-&gt;memory;</a>
<a name="ln2091"> </a>
<a name="ln2092">    if ( ps_debug_glyph )</a>
<a name="ln2093">    {</a>
<a name="ln2094">      psh_glyph_done( ps_debug_glyph );</a>
<a name="ln2095">      FT_FREE( ps_debug_glyph );</a>
<a name="ln2096">    }</a>
<a name="ln2097"> </a>
<a name="ln2098">    if ( FT_NEW( glyph ) )</a>
<a name="ln2099">      return error;</a>
<a name="ln2100"> </a>
<a name="ln2101">    ps_debug_glyph = glyph;</a>
<a name="ln2102"> </a>
<a name="ln2103">#endif /* DEBUG_HINTER */</a>
<a name="ln2104"> </a>
<a name="ln2105">    error = psh_glyph_init( glyph, outline, ps_hints, globals );</a>
<a name="ln2106">    if ( error )</a>
<a name="ln2107">      goto Exit;</a>
<a name="ln2108"> </a>
<a name="ln2109">    /* try to optimize the y_scale so that the top of non-capital letters</a>
<a name="ln2110">     * is aligned on a pixel boundary whenever possible</a>
<a name="ln2111">     */</a>
<a name="ln2112">    {</a>
<a name="ln2113">      PSH_Dimension  dim_x = &amp;glyph-&gt;globals-&gt;dimension[0];</a>
<a name="ln2114">      PSH_Dimension  dim_y = &amp;glyph-&gt;globals-&gt;dimension[1];</a>
<a name="ln2115"> </a>
<a name="ln2116">      FT_Fixed  x_scale = dim_x-&gt;scale_mult;</a>
<a name="ln2117">      FT_Fixed  y_scale = dim_y-&gt;scale_mult;</a>
<a name="ln2118"> </a>
<a name="ln2119">      FT_Fixed  old_x_scale = x_scale;</a>
<a name="ln2120">      FT_Fixed  old_y_scale = y_scale;</a>
<a name="ln2121"> </a>
<a name="ln2122">      FT_Fixed  scaled;</a>
<a name="ln2123">      FT_Fixed  fitted;</a>
<a name="ln2124"> </a>
<a name="ln2125">      FT_Bool  rescale = FALSE;</a>
<a name="ln2126"> </a>
<a name="ln2127"> </a>
<a name="ln2128">      scaled = FT_MulFix( globals-&gt;blues.normal_top.zones-&gt;org_ref, y_scale );</a>
<a name="ln2129">      fitted = FT_PIX_ROUND( scaled );</a>
<a name="ln2130"> </a>
<a name="ln2131">      if ( fitted != 0 &amp;&amp; scaled != fitted )</a>
<a name="ln2132">      {</a>
<a name="ln2133">        rescale = TRUE;</a>
<a name="ln2134"> </a>
<a name="ln2135">        y_scale = FT_MulDiv( y_scale, fitted, scaled );</a>
<a name="ln2136"> </a>
<a name="ln2137">        if ( fitted &lt; scaled )</a>
<a name="ln2138">          x_scale -= x_scale / 50;</a>
<a name="ln2139"> </a>
<a name="ln2140">        psh_globals_set_scale( glyph-&gt;globals, x_scale, y_scale, 0, 0 );</a>
<a name="ln2141">      }</a>
<a name="ln2142"> </a>
<a name="ln2143">      glyph-&gt;do_horz_hints = 1;</a>
<a name="ln2144">      glyph-&gt;do_vert_hints = 1;</a>
<a name="ln2145"> </a>
<a name="ln2146">      glyph-&gt;do_horz_snapping = FT_BOOL( hint_mode == FT_RENDER_MODE_MONO ||</a>
<a name="ln2147">                                         hint_mode == FT_RENDER_MODE_LCD  );</a>
<a name="ln2148"> </a>
<a name="ln2149">      glyph-&gt;do_vert_snapping = FT_BOOL( hint_mode == FT_RENDER_MODE_MONO  ||</a>
<a name="ln2150">                                         hint_mode == FT_RENDER_MODE_LCD_V );</a>
<a name="ln2151"> </a>
<a name="ln2152">      glyph-&gt;do_stem_adjust   = FT_BOOL( hint_mode != FT_RENDER_MODE_LIGHT );</a>
<a name="ln2153"> </a>
<a name="ln2154">      for ( dimension = 0; dimension &lt; 2; dimension++ )</a>
<a name="ln2155">      {</a>
<a name="ln2156">        /* load outline coordinates into glyph */</a>
<a name="ln2157">        psh_glyph_load_points( glyph, dimension );</a>
<a name="ln2158"> </a>
<a name="ln2159">        /* compute local extrema */</a>
<a name="ln2160">        psh_glyph_compute_extrema( glyph );</a>
<a name="ln2161"> </a>
<a name="ln2162">        /* compute aligned stem/hints positions */</a>
<a name="ln2163">        psh_hint_table_align_hints( &amp;glyph-&gt;hint_tables[dimension],</a>
<a name="ln2164">                                    glyph-&gt;globals,</a>
<a name="ln2165">                                    dimension,</a>
<a name="ln2166">                                    glyph );</a>
<a name="ln2167"> </a>
<a name="ln2168">        /* find strong points, align them, then interpolate others */</a>
<a name="ln2169">        psh_glyph_find_strong_points( glyph, dimension );</a>
<a name="ln2170">        if ( dimension == 1 )</a>
<a name="ln2171">          psh_glyph_find_blue_points( &amp;globals-&gt;blues, glyph );</a>
<a name="ln2172">        psh_glyph_interpolate_strong_points( glyph, dimension );</a>
<a name="ln2173">        psh_glyph_interpolate_normal_points( glyph, dimension );</a>
<a name="ln2174">        psh_glyph_interpolate_other_points( glyph, dimension );</a>
<a name="ln2175"> </a>
<a name="ln2176">        /* save hinted coordinates back to outline */</a>
<a name="ln2177">        psh_glyph_save_points( glyph, dimension );</a>
<a name="ln2178"> </a>
<a name="ln2179">        if ( rescale )</a>
<a name="ln2180">          psh_globals_set_scale( glyph-&gt;globals,</a>
<a name="ln2181">                                 old_x_scale, old_y_scale, 0, 0 );</a>
<a name="ln2182">      }</a>
<a name="ln2183">    }</a>
<a name="ln2184"> </a>
<a name="ln2185">  Exit:</a>
<a name="ln2186"> </a>
<a name="ln2187">#ifndef DEBUG_HINTER</a>
<a name="ln2188">    psh_glyph_done( glyph );</a>
<a name="ln2189">#endif</a>
<a name="ln2190"> </a>
<a name="ln2191">    return error;</a>
<a name="ln2192">  }</a>
<a name="ln2193"> </a>
<a name="ln2194"> </a>
<a name="ln2195">/* END */</a>

</code></pre>
<div class="balloon" rel="290"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'count2 == 0' is always true.</p></div>
<div class="balloon" rel="531"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'hint->cur_len' variable was assigned the same value.</p></div>
<div class="balloon" rel="644"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'hint->cur_len' variable was assigned the same value.</p></div>
<div class="balloon" rel="2128"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v619/" target="_blank">V619</a> The array 'globals->blues.normal_top.zones' is being utilized as a pointer to single object.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
