
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>edit.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2012 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;note.h&quot;</a>
<a name="ln14">#include &quot;rest.h&quot;</a>
<a name="ln15">#include &quot;chord.h&quot;</a>
<a name="ln16">#include &quot;key.h&quot;</a>
<a name="ln17">#include &quot;sig.h&quot;</a>
<a name="ln18">#include &quot;clef.h&quot;</a>
<a name="ln19">#include &quot;score.h&quot;</a>
<a name="ln20">#include &quot;slur.h&quot;</a>
<a name="ln21">#include &quot;tie.h&quot;</a>
<a name="ln22">#include &quot;hairpin.h&quot;</a>
<a name="ln23">#include &quot;segment.h&quot;</a>
<a name="ln24">#include &quot;staff.h&quot;</a>
<a name="ln25">#include &quot;part.h&quot;</a>
<a name="ln26">#include &quot;timesig.h&quot;</a>
<a name="ln27">#include &quot;page.h&quot;</a>
<a name="ln28">#include &quot;barline.h&quot;</a>
<a name="ln29">#include &quot;tuplet.h&quot;</a>
<a name="ln30">#include &quot;lyrics.h&quot;</a>
<a name="ln31">#include &quot;image.h&quot;</a>
<a name="ln32">#include &quot;keysig.h&quot;</a>
<a name="ln33">#include &quot;beam.h&quot;</a>
<a name="ln34">#include &quot;utils.h&quot;</a>
<a name="ln35">#include &quot;harmony.h&quot;</a>
<a name="ln36">#include &quot;system.h&quot;</a>
<a name="ln37">#include &quot;navigate.h&quot;</a>
<a name="ln38">#include &quot;articulation.h&quot;</a>
<a name="ln39">#include &quot;drumset.h&quot;</a>
<a name="ln40">#include &quot;measure.h&quot;</a>
<a name="ln41">#include &quot;undo.h&quot;</a>
<a name="ln42">#include &quot;tupletmap.h&quot;</a>
<a name="ln43">#include &quot;tiemap.h&quot;</a>
<a name="ln44">#include &quot;stem.h&quot;</a>
<a name="ln45">#include &quot;iname.h&quot;</a>
<a name="ln46">#include &quot;range.h&quot;</a>
<a name="ln47">#include &quot;hook.h&quot;</a>
<a name="ln48">#include &quot;repeat.h&quot;</a>
<a name="ln49">#include &quot;textframe.h&quot;</a>
<a name="ln50">#include &quot;accidental.h&quot;</a>
<a name="ln51">#include &quot;ottava.h&quot;</a>
<a name="ln52">#include &quot;instrchange.h&quot;</a>
<a name="ln53">#include &quot;bracket.h&quot;</a>
<a name="ln54">#include &quot;excerpt.h&quot;</a>
<a name="ln55">#include &quot;breath.h&quot;</a>
<a name="ln56">#include &quot;glissando.h&quot;</a>
<a name="ln57">#include &quot;fermata.h&quot;</a>
<a name="ln58"> </a>
<a name="ln59">namespace Ms {</a>
<a name="ln60"> </a>
<a name="ln61">//---------------------------------------------------------</a>
<a name="ln62">//   getSelectedNote</a>
<a name="ln63">//---------------------------------------------------------</a>
<a name="ln64"> </a>
<a name="ln65">Note* Score::getSelectedNote()</a>
<a name="ln66">      {</a>
<a name="ln67">      Element* el = selection().element();</a>
<a name="ln68">      if (el &amp;&amp; el-&gt;isNote())</a>
<a name="ln69">            return toNote(el);</a>
<a name="ln70">      MScore::setError(NO_NOTE_SELECTED);</a>
<a name="ln71">      return 0;</a>
<a name="ln72">      }</a>
<a name="ln73"> </a>
<a name="ln74">//---------------------------------------------------------</a>
<a name="ln75">//   getSelectedChordRest</a>
<a name="ln76">//---------------------------------------------------------</a>
<a name="ln77"> </a>
<a name="ln78">ChordRest* Score::getSelectedChordRest() const</a>
<a name="ln79">      {</a>
<a name="ln80">      Element* el = selection().element();</a>
<a name="ln81">      if (el) {</a>
<a name="ln82">            if (el-&gt;isNote())</a>
<a name="ln83">                  return toNote(el)-&gt;chord();</a>
<a name="ln84">            else if (el-&gt;isRest() || el-&gt;isRepeatMeasure())</a>
<a name="ln85">                  return toRest(el);</a>
<a name="ln86">            else if (el-&gt;isChord())</a>
<a name="ln87">                  return toChord(el);</a>
<a name="ln88">            }</a>
<a name="ln89">      MScore::setError(NO_NOTE_REST_SELECTED);</a>
<a name="ln90">      return 0;</a>
<a name="ln91">      }</a>
<a name="ln92"> </a>
<a name="ln93">//---------------------------------------------------------</a>
<a name="ln94">//   getSelectedChordRest2</a>
<a name="ln95">//---------------------------------------------------------</a>
<a name="ln96"> </a>
<a name="ln97">void Score::getSelectedChordRest2(ChordRest** cr1, ChordRest** cr2) const</a>
<a name="ln98">      {</a>
<a name="ln99">      *cr1 = 0;</a>
<a name="ln100">      *cr2 = 0;</a>
<a name="ln101">      foreach(Element* e, selection().elements()) {</a>
<a name="ln102">            if (e-&gt;isNote())</a>
<a name="ln103">                  e = e-&gt;parent();</a>
<a name="ln104">            if (e-&gt;isChordRest()) {</a>
<a name="ln105">                  ChordRest* cr = toChordRest(e);</a>
<a name="ln106">                  if (*cr1 == 0 || (*cr1)-&gt;tick() &gt; cr-&gt;tick())</a>
<a name="ln107">                        *cr1 = cr;</a>
<a name="ln108">                  if (*cr2 == 0 || (*cr2)-&gt;tick() &lt; cr-&gt;tick())</a>
<a name="ln109">                        *cr2 = cr;</a>
<a name="ln110">                  }</a>
<a name="ln111">            }</a>
<a name="ln112">      if (*cr1 == 0)</a>
<a name="ln113">            MScore::setError(NO_NOTE_REST_SELECTED);</a>
<a name="ln114">      if (*cr1 == *cr2)</a>
<a name="ln115">            *cr2 = 0;</a>
<a name="ln116">      }</a>
<a name="ln117"> </a>
<a name="ln118">//---------------------------------------------------------</a>
<a name="ln119">//   getSelectedChordRests</a>
<a name="ln120">//---------------------------------------------------------</a>
<a name="ln121"> </a>
<a name="ln122">QSet&lt;ChordRest*&gt; Score::getSelectedChordRests() const</a>
<a name="ln123">      {</a>
<a name="ln124">      QSet&lt;ChordRest*&gt; set;</a>
<a name="ln125">      for (Element* e : selection().elements()) {</a>
<a name="ln126">            if (e-&gt;isNote())</a>
<a name="ln127">                  e = e-&gt;parent();</a>
<a name="ln128">            if (e-&gt;isChordRest()) {</a>
<a name="ln129">                  set.insert(toChordRest(e));</a>
<a name="ln130">                  }</a>
<a name="ln131">            }</a>
<a name="ln132">      return set;</a>
<a name="ln133">      }</a>
<a name="ln134"> </a>
<a name="ln135">//---------------------------------------------------------</a>
<a name="ln136">//   pos</a>
<a name="ln137">//---------------------------------------------------------</a>
<a name="ln138"> </a>
<a name="ln139">Fraction Score::pos()</a>
<a name="ln140">      {</a>
<a name="ln141">      Element* el = selection().element();</a>
<a name="ln142">      if (selection().activeCR())</a>
<a name="ln143">            el = selection().activeCR();</a>
<a name="ln144">      if (el) {</a>
<a name="ln145">            switch (el-&gt;type()) {</a>
<a name="ln146">                  case ElementType::NOTE:</a>
<a name="ln147">                        el = el-&gt;parent();</a>
<a name="ln148">                        // fall through</a>
<a name="ln149">                  case ElementType::REPEAT_MEASURE:</a>
<a name="ln150">                  case ElementType::REST:</a>
<a name="ln151">                  case ElementType::CHORD:</a>
<a name="ln152">                        return toChordRest(el)-&gt;tick();</a>
<a name="ln153">                  default:</a>
<a name="ln154">                        break;</a>
<a name="ln155">                  }</a>
<a name="ln156">            }</a>
<a name="ln157">      return Fraction(-1, 1);</a>
<a name="ln158">      }</a>
<a name="ln159"> </a>
<a name="ln160">//---------------------------------------------------------</a>
<a name="ln161">//   addRest</a>
<a name="ln162">//    create one Rest at tick with duration d</a>
<a name="ln163">//    create segment if necessary</a>
<a name="ln164">//---------------------------------------------------------</a>
<a name="ln165"> </a>
<a name="ln166">Rest* Score::addRest(const Fraction&amp; tick, int track, TDuration d, Tuplet* tuplet)</a>
<a name="ln167">      {</a>
<a name="ln168">      Measure* measure = tick2measure(tick);</a>
<a name="ln169">      Rest* rest       = new Rest(this, d);</a>
<a name="ln170">      if (d.type() == TDuration::DurationType::V_MEASURE)</a>
<a name="ln171">            rest-&gt;setTicks(measure-&gt;stretchedLen(staff(track/VOICES)));</a>
<a name="ln172">      else</a>
<a name="ln173">            rest-&gt;setTicks(d.fraction());</a>
<a name="ln174">      rest-&gt;setTrack(track);</a>
<a name="ln175">      rest-&gt;setTuplet(tuplet);</a>
<a name="ln176">      undoAddCR(rest, measure, tick);</a>
<a name="ln177">      return rest;</a>
<a name="ln178">      }</a>
<a name="ln179"> </a>
<a name="ln180">//---------------------------------------------------------</a>
<a name="ln181">//   addRest</a>
<a name="ln182">//---------------------------------------------------------</a>
<a name="ln183"> </a>
<a name="ln184">Rest* Score::addRest(Segment* s, int track, TDuration d, Tuplet* tuplet)</a>
<a name="ln185">      {</a>
<a name="ln186">      Rest* rest = new Rest(this, d);</a>
<a name="ln187">      if (d.type() == TDuration::DurationType::V_MEASURE)</a>
<a name="ln188">            rest-&gt;setTicks(s-&gt;measure()-&gt;stretchedLen(staff(track/VOICES)));</a>
<a name="ln189">      else</a>
<a name="ln190">            rest-&gt;setTicks(d.fraction());</a>
<a name="ln191">      rest-&gt;setTrack(track);</a>
<a name="ln192">      rest-&gt;setParent(s);</a>
<a name="ln193">      rest-&gt;setTuplet(tuplet);</a>
<a name="ln194">      undoAddCR(rest, tick2measure(s-&gt;tick()), s-&gt;tick());</a>
<a name="ln195">      return rest;</a>
<a name="ln196">      }</a>
<a name="ln197"> </a>
<a name="ln198">//---------------------------------------------------------</a>
<a name="ln199">//   addChord</a>
<a name="ln200">//    Create one Chord at tick with duration d</a>
<a name="ln201">//    - create segment if necessary.</a>
<a name="ln202">//    - Use chord &quot;oc&quot; as prototype;</a>
<a name="ln203">//    - if &quot;genTie&quot; then tie to chord &quot;oc&quot;</a>
<a name="ln204">//---------------------------------------------------------</a>
<a name="ln205"> </a>
<a name="ln206">Chord* Score::addChord(const Fraction&amp; tick, TDuration d, Chord* oc, bool genTie, Tuplet* tuplet)</a>
<a name="ln207">      {</a>
<a name="ln208">      Measure* measure = tick2measure(tick);</a>
<a name="ln209">      if (measure-&gt;endTick() &lt;= tick) {</a>
<a name="ln210">            qDebug(&quot;Score::addChord(): end of score?&quot;);</a>
<a name="ln211">            return 0;</a>
<a name="ln212">            }</a>
<a name="ln213"> </a>
<a name="ln214">      Chord* chord = new Chord(this);</a>
<a name="ln215">      chord-&gt;setTuplet(tuplet);</a>
<a name="ln216">      chord-&gt;setTrack(oc-&gt;track());</a>
<a name="ln217">      chord-&gt;setDurationType(d);</a>
<a name="ln218">      chord-&gt;setTicks(d.fraction());</a>
<a name="ln219"> </a>
<a name="ln220">      for (Note* n : oc-&gt;notes()) {</a>
<a name="ln221">            Note* nn = new Note(this);</a>
<a name="ln222">            nn-&gt;setPitch(n-&gt;pitch());</a>
<a name="ln223">            nn-&gt;setTpc1(n-&gt;tpc1());</a>
<a name="ln224">            nn-&gt;setTpc2(n-&gt;tpc2());</a>
<a name="ln225">            chord-&gt;add(nn);</a>
<a name="ln226">            }</a>
<a name="ln227">      undoAddCR(chord, measure, tick);</a>
<a name="ln228"> </a>
<a name="ln229">      //</a>
<a name="ln230">      // now as both chords are in place</a>
<a name="ln231">      // (have segments as parent) we can add ties:</a>
<a name="ln232">      //</a>
<a name="ln233">      if (genTie) {</a>
<a name="ln234">            size_t n = oc-&gt;notes().size();</a>
<a name="ln235">            for(size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln236">                  Note* n1  = oc-&gt;notes()[i];</a>
<a name="ln237">                  Note* n2 = chord-&gt;notes()[i];</a>
<a name="ln238">                  Tie* tie = new Tie(this);</a>
<a name="ln239">                  tie-&gt;setStartNote(n1);</a>
<a name="ln240">                  tie-&gt;setEndNote(n2);</a>
<a name="ln241">                  tie-&gt;setTrack(n1-&gt;track());</a>
<a name="ln242">                  undoAddElement(tie);</a>
<a name="ln243">                  }</a>
<a name="ln244">            }</a>
<a name="ln245"> </a>
<a name="ln246">      return chord;</a>
<a name="ln247">      }</a>
<a name="ln248"> </a>
<a name="ln249">//---------------------------------------------------------</a>
<a name="ln250">//   addClone</a>
<a name="ln251">//---------------------------------------------------------</a>
<a name="ln252"> </a>
<a name="ln253">ChordRest* Score::addClone(ChordRest* cr, const Fraction&amp; tick, const TDuration&amp; d)</a>
<a name="ln254">      {</a>
<a name="ln255">      ChordRest* newcr;</a>
<a name="ln256">      // change a RepeatMeasure() into an Rest()</a>
<a name="ln257">      if (cr-&gt;isRepeatMeasure())</a>
<a name="ln258">            newcr = new Rest(*toRest(cr));</a>
<a name="ln259">      else</a>
<a name="ln260">            newcr = toChordRest(cr-&gt;clone());</a>
<a name="ln261">      newcr-&gt;rxpos() = 0.0;</a>
<a name="ln262">      newcr-&gt;setDurationType(d);</a>
<a name="ln263">      newcr-&gt;setTicks(d.fraction());</a>
<a name="ln264">      newcr-&gt;setTuplet(cr-&gt;tuplet());</a>
<a name="ln265">      newcr-&gt;setSelected(false);</a>
<a name="ln266"> </a>
<a name="ln267">      undoAddCR(newcr, cr-&gt;measure(), tick);</a>
<a name="ln268">      return newcr;</a>
<a name="ln269">      }</a>
<a name="ln270"> </a>
<a name="ln271">//---------------------------------------------------------</a>
<a name="ln272">//   setRest</a>
<a name="ln273">//    create one or more rests to fill &quot;l&quot;</a>
<a name="ln274">//---------------------------------------------------------</a>
<a name="ln275"> </a>
<a name="ln276">Rest* Score::setRest(const Fraction&amp; _tick, int track, const Fraction&amp; _l, bool useDots, Tuplet* tuplet, bool useFullMeasureRest)</a>
<a name="ln277">      {</a>
<a name="ln278">      Fraction l       = _l;</a>
<a name="ln279">      Fraction tick    = _tick;</a>
<a name="ln280">      Measure* measure = tick2measure(tick);</a>
<a name="ln281">      Rest* r          = 0;</a>
<a name="ln282">      Staff* staff     = Score::staff(track / VOICES);</a>
<a name="ln283"> </a>
<a name="ln284">      while (!l.isZero()) {</a>
<a name="ln285">            //</a>
<a name="ln286">            // divide into measures</a>
<a name="ln287">            //</a>
<a name="ln288">            Fraction f;</a>
<a name="ln289">            if (tuplet) {</a>
<a name="ln290">                  f = tuplet-&gt;baseLen().fraction() * tuplet-&gt;ratio().numerator();</a>
<a name="ln291">                  for (DurationElement* de : tuplet-&gt;elements()) {</a>
<a name="ln292">                        if (de-&gt;tick() &gt;= tick)</a>
<a name="ln293">                              break;</a>
<a name="ln294">                        f -= de-&gt;ticks();</a>
<a name="ln295">                        }</a>
<a name="ln296">                  //</a>
<a name="ln297">                  // restrict to tuplet len</a>
<a name="ln298">                  //</a>
<a name="ln299">                  if (f &lt; l)</a>
<a name="ln300">                        l = f;</a>
<a name="ln301">                  }</a>
<a name="ln302">            else {</a>
<a name="ln303">                  if (measure-&gt;tick() &lt; tick)</a>
<a name="ln304">                        f = measure-&gt;tick() + measure-&gt;ticks() - tick;</a>
<a name="ln305">                  else</a>
<a name="ln306">                        f = measure-&gt;ticks();</a>
<a name="ln307">                  f *= staff-&gt;timeStretch(tick);</a>
<a name="ln308">                  }</a>
<a name="ln309"> </a>
<a name="ln310">            if (f &gt; l)</a>
<a name="ln311">                  f = l;</a>
<a name="ln312"> </a>
<a name="ln313">            if ((track % VOICES) &amp;&amp; !measure-&gt;hasVoice(track) &amp;&amp; (tick == measure-&gt;tick())) {</a>
<a name="ln314">                  l -= f;</a>
<a name="ln315">                  measure = measure-&gt;nextMeasure();</a>
<a name="ln316">                  if (!measure)</a>
<a name="ln317">                        break;</a>
<a name="ln318">                  tick = measure-&gt;tick();</a>
<a name="ln319">                  continue;</a>
<a name="ln320">                  }</a>
<a name="ln321"> </a>
<a name="ln322">            if ((measure-&gt;timesig() == measure-&gt;ticks())   // not in pickup measure</a>
<a name="ln323">               &amp;&amp; (measure-&gt;tick() == tick)</a>
<a name="ln324">               &amp;&amp; (measure-&gt;stretchedLen(staff) == f)</a>
<a name="ln325">               &amp;&amp; !tuplet</a>
<a name="ln326">               &amp;&amp; (useFullMeasureRest)) {</a>
<a name="ln327">                  Rest* rest = addRest(tick, track, TDuration(TDuration::DurationType::V_MEASURE), tuplet);</a>
<a name="ln328">                  tick += rest-&gt;actualTicks();</a>
<a name="ln329">                  if (r == 0)</a>
<a name="ln330">                        r = rest;</a>
<a name="ln331">                  }</a>
<a name="ln332">            else {</a>
<a name="ln333">                  //</a>
<a name="ln334">                  // compute list of durations which will fit l</a>
<a name="ln335">                  //</a>
<a name="ln336">                  std::vector&lt;TDuration&gt; dList = toDurationList(f, useDots);</a>
<a name="ln337">                  if (dList.empty())</a>
<a name="ln338">                        return 0;</a>
<a name="ln339"> </a>
<a name="ln340">                  Rest* rest = 0;</a>
<a name="ln341">                  if (((tick - measure-&gt;tick()).ticks() % dList[0].ticks().ticks()) == 0) {</a>
<a name="ln342">                        for (const TDuration&amp; d : dList) {</a>
<a name="ln343">                              rest = addRest(tick, track, d, tuplet);</a>
<a name="ln344">                              if (r == 0)</a>
<a name="ln345">                                    r = rest;</a>
<a name="ln346">                              tick += rest-&gt;actualTicks();</a>
<a name="ln347">                              }</a>
<a name="ln348">                        }</a>
<a name="ln349">                  else {</a>
<a name="ln350">                        for (size_t i = dList.size(); i &gt; 0; --i) { // loop needs to be in this reverse order</a>
<a name="ln351">                              rest = addRest(tick, track, dList[i-1], tuplet);</a>
<a name="ln352">                              if (r == 0)</a>
<a name="ln353">                                    r = rest;</a>
<a name="ln354">                              tick += rest-&gt;actualTicks();</a>
<a name="ln355">                              }</a>
<a name="ln356">                        }</a>
<a name="ln357">                  }</a>
<a name="ln358">            l -= f;</a>
<a name="ln359"> </a>
<a name="ln360">            measure = measure-&gt;nextMeasure();</a>
<a name="ln361">            if (!measure)</a>
<a name="ln362">                  break;</a>
<a name="ln363">            tick = measure-&gt;tick();</a>
<a name="ln364">            }</a>
<a name="ln365">      return r;</a>
<a name="ln366">      }</a>
<a name="ln367"> </a>
<a name="ln368">//---------------------------------------------------------</a>
<a name="ln369">//   addNote from NoteVal</a>
<a name="ln370">//---------------------------------------------------------</a>
<a name="ln371"> </a>
<a name="ln372">Note* Score::addNote(Chord* chord, NoteVal&amp; noteVal, bool forceAccidental)</a>
<a name="ln373">      {</a>
<a name="ln374">      Note* note = new Note(this);</a>
<a name="ln375">      note-&gt;setParent(chord);</a>
<a name="ln376">      note-&gt;setTrack(chord-&gt;track());</a>
<a name="ln377">      note-&gt;setNval(noteVal);</a>
<a name="ln378">      undoAddElement(note);</a>
<a name="ln379">      if (forceAccidental) {</a>
<a name="ln380">            int tpc = styleB(Sid::concertPitch) ? noteVal.tpc1 : noteVal.tpc2;</a>
<a name="ln381">            AccidentalVal alter = tpc2alter(tpc);</a>
<a name="ln382">            AccidentalType at = Accidental::value2subtype(alter);</a>
<a name="ln383">            Accidental* a = new Accidental(this);</a>
<a name="ln384">            a-&gt;setAccidentalType(at);</a>
<a name="ln385">            a-&gt;setRole(AccidentalRole::USER);</a>
<a name="ln386">            a-&gt;setParent(note);</a>
<a name="ln387">            undoAddElement(a);</a>
<a name="ln388">            }</a>
<a name="ln389">      setPlayNote(true);</a>
<a name="ln390">      setPlayChord(true);</a>
<a name="ln391">      select(note, SelectType::SINGLE, 0);</a>
<a name="ln392">      if (!chord-&gt;staff()-&gt;isTabStaff(chord-&gt;tick())) {</a>
<a name="ln393">            NoteEntryMethod entryMethod = _is.noteEntryMethod();</a>
<a name="ln394">            if (entryMethod != NoteEntryMethod::REALTIME_AUTO &amp;&amp; entryMethod != NoteEntryMethod::REALTIME_MANUAL)</a>
<a name="ln395">                  _is.moveToNextInputPos();</a>
<a name="ln396">            }</a>
<a name="ln397">      return note;</a>
<a name="ln398">      }</a>
<a name="ln399"> </a>
<a name="ln400">//---------------------------------------------------------</a>
<a name="ln401">//   rewriteMeasures</a>
<a name="ln402">//    rewrite all measures from fm to lm (including)</a>
<a name="ln403">//    If staffIdx is valid (&gt;= 0), then rewrite a local</a>
<a name="ln404">//    timesig change.</a>
<a name="ln405">//---------------------------------------------------------</a>
<a name="ln406"> </a>
<a name="ln407">bool Score::rewriteMeasures(Measure* fm, Measure* lm, const Fraction&amp; ns, int staffIdx)</a>
<a name="ln408">      {</a>
<a name="ln409">      if (staffIdx &gt;= 0) {</a>
<a name="ln410">            // local timesig</a>
<a name="ln411">            // don't actually rewrite, just update measure rest durations</a>
<a name="ln412">            // abort if there is anything other than measure rests in range</a>
<a name="ln413">            int strack = staffIdx * VOICES;</a>
<a name="ln414">            int etrack = strack + VOICES;</a>
<a name="ln415">            for (Measure* m = fm; ; m = m-&gt;nextMeasure()) {</a>
<a name="ln416">                  for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln417">                        for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln418">                              ChordRest* cr = toChordRest(s-&gt;element(track));</a>
<a name="ln419">                              if (!cr)</a>
<a name="ln420">                                    continue;</a>
<a name="ln421">                              if (cr-&gt;isRest() &amp;&amp; cr-&gt;durationType() == TDuration::DurationType::V_MEASURE)</a>
<a name="ln422">                                    cr-&gt;undoChangeProperty(Pid::DURATION, QVariant::fromValue(ns));</a>
<a name="ln423">                              else</a>
<a name="ln424">                                    return false;</a>
<a name="ln425">                              }</a>
<a name="ln426">                        }</a>
<a name="ln427">                  if (m == lm)</a>
<a name="ln428">                        break;</a>
<a name="ln429">                  }</a>
<a name="ln430">            return true;</a>
<a name="ln431">            }</a>
<a name="ln432">      int measures = 1;</a>
<a name="ln433">      bool fmr     = true;</a>
<a name="ln434"> </a>
<a name="ln435">      // Format: chord 1 tick, chord 2 tick, tremolo, track</a>
<a name="ln436">      std::vector&lt;std::tuple&lt;Fraction, Fraction, Tremolo*, int&gt;&gt; tremoloChordTicks;</a>
<a name="ln437"> </a>
<a name="ln438">      int strack, etrack;</a>
<a name="ln439">      if (staffIdx &lt; 0) {</a>
<a name="ln440">            strack = 0;</a>
<a name="ln441">            etrack = ntracks();</a>
<a name="ln442">            }</a>
<a name="ln443">      else {</a>
<a name="ln444">            strack = staffIdx * VOICES;</a>
<a name="ln445">            etrack = strack + VOICES;</a>
<a name="ln446">            }</a>
<a name="ln447"> </a>
<a name="ln448">      for (Measure* m = fm; m; m = m-&gt;nextMeasure()) {</a>
<a name="ln449">            if (!m-&gt;isFullMeasureRest())</a>
<a name="ln450">                  fmr = false;</a>
<a name="ln451"> </a>
<a name="ln452">            for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln453">                  for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln454">                        ChordRest* cr = toChordRest(s-&gt;element(track));</a>
<a name="ln455">                        if (cr &amp;&amp; cr-&gt;isChord()) {</a>
<a name="ln456">                              Chord* chord = toChord(cr);</a>
<a name="ln457">                              if (chord-&gt;tremolo() &amp;&amp; chord-&gt;tremolo()-&gt;twoNotes()) {</a>
<a name="ln458">                                    Tremolo* trem = chord-&gt;tremolo();</a>
<a name="ln459"> </a>
<a name="ln460">                                    // Don't add same chord twice</a>
<a name="ln461">                                    if (trem-&gt;chord2() == chord)</a>
<a name="ln462">                                          continue;</a>
<a name="ln463">                                    auto newP = std::tuple&lt;Fraction, Fraction, Tremolo*, int&gt;(cr-&gt;tick(), trem-&gt;chord2()-&gt;segment()-&gt;tick(), trem, track);</a>
<a name="ln464">                                    tremoloChordTicks.push_back(newP);</a>
<a name="ln465">                                    }</a>
<a name="ln466">                              }</a>
<a name="ln467">                        }</a>
<a name="ln468">                  }</a>
<a name="ln469"> </a>
<a name="ln470">            if (m == lm)</a>
<a name="ln471">                  break;</a>
<a name="ln472">            ++measures;</a>
<a name="ln473">            }</a>
<a name="ln474"> </a>
<a name="ln475">      if (!fmr) {</a>
<a name="ln476">            // check for local time signatures</a>
<a name="ln477">            for (Measure* m = fm; m; m = m -&gt; nextMeasure()) {</a>
<a name="ln478">                  for (int si = 0; si &lt; nstaves(); ++si) {</a>
<a name="ln479">                        if (staff(si)-&gt;timeStretch(m-&gt;tick()) != Fraction(1,1)) {</a>
<a name="ln480">                              // we cannot change a staff with a local time signature</a>
<a name="ln481">                              return false;</a>
<a name="ln482">                              }</a>
<a name="ln483">                        if (m == lm)</a>
<a name="ln484">                              break;</a>
<a name="ln485">                        }</a>
<a name="ln486">                  }</a>
<a name="ln487">            }</a>
<a name="ln488"> </a>
<a name="ln489">      ScoreRange range;</a>
<a name="ln490">      range.read(fm-&gt;first(), lm-&gt;last());</a>
<a name="ln491"> </a>
<a name="ln492">      //</a>
<a name="ln493">      // calculate number of required measures = nm</a>
<a name="ln494">      //</a>
<a name="ln495">      Fraction k = range.ticks() / ns;</a>
<a name="ln496">      int nm     = (k.numerator() + k.denominator() - 1)/ k.denominator();</a>
<a name="ln497"> </a>
<a name="ln498">      Fraction nd = ns * Fraction(nm,1);</a>
<a name="ln499"> </a>
<a name="ln500">      // evtl. we have to fill the last measure</a>
<a name="ln501">      Fraction fill = nd - range.ticks();</a>
<a name="ln502">      range.fill(fill);</a>
<a name="ln503"> </a>
<a name="ln504">      for (Score* s : scoreList()) {</a>
<a name="ln505">            Measure* m1 = s-&gt;tick2measure(fm-&gt;tick());</a>
<a name="ln506">            Measure* m2 = s-&gt;tick2measure(lm-&gt;tick());</a>
<a name="ln507"> </a>
<a name="ln508">            Fraction tick1 = m1-&gt;tick();</a>
<a name="ln509">            Fraction tick2 = m2-&gt;endTick();</a>
<a name="ln510">            auto spanners = s-&gt;spannerMap().findOverlapping(tick1.ticks(), tick2.ticks());</a>
<a name="ln511">            for (auto i : spanners) {</a>
<a name="ln512">                  if (i.value-&gt;tick() &gt;= tick1)</a>
<a name="ln513">                        undo(new RemoveElement(i.value));</a>
<a name="ln514">                  }</a>
<a name="ln515">            s-&gt;undoRemoveMeasures(m1, m2);</a>
<a name="ln516"> </a>
<a name="ln517">            Measure* nfm = 0;</a>
<a name="ln518">            Measure* nlm = 0;</a>
<a name="ln519">            Fraction tick     = { 0, 1};</a>
<a name="ln520">            for (int i = 0; i &lt; nm; ++i) {</a>
<a name="ln521">                  Measure* m = new Measure(s);</a>
<a name="ln522">                  m-&gt;setPrev(nlm);</a>
<a name="ln523">                  if (nlm)</a>
<a name="ln524">                        nlm-&gt;setNext(m);</a>
<a name="ln525">                  m-&gt;setTimesig(ns);</a>
<a name="ln526">                  m-&gt;setTicks(ns);</a>
<a name="ln527">                  m-&gt;setTick(tick);</a>
<a name="ln528">                  tick += m-&gt;ticks();</a>
<a name="ln529">                  nlm = m;</a>
<a name="ln530">                  if (nfm == 0)</a>
<a name="ln531">                        nfm = m;</a>
<a name="ln532">                  }</a>
<a name="ln533">//            nlm-&gt;setEndBarLineType(m2-&gt;endBarLineType(), m2-&gt;endBarLineGenerated(),</a>
<a name="ln534">//               m2-&gt;endBarLineVisible(), m2-&gt;endBarLineColor());</a>
<a name="ln535">            //</a>
<a name="ln536">            // insert new calculated measures</a>
<a name="ln537">            //</a>
<a name="ln538">            nfm-&gt;setPrev(m1-&gt;prev());</a>
<a name="ln539">            nlm-&gt;setNext(m2-&gt;next());</a>
<a name="ln540">            s-&gt;undo(new InsertMeasures(nfm, nlm));</a>
<a name="ln541">            }</a>
<a name="ln542">      if (!fill.isZero())</a>
<a name="ln543">            undoInsertTime(lm-&gt;endTick(), fill);</a>
<a name="ln544"> </a>
<a name="ln545">      if (!range.write(masterScore(), fm-&gt;tick()))</a>
<a name="ln546">            return false;</a>
<a name="ln547">      connectTies(true);</a>
<a name="ln548"> </a>
<a name="ln549">      // Attempt to move tremolos to correct chords</a>
<a name="ln550">      for (auto tremPair : tremoloChordTicks) {</a>
<a name="ln551">            Fraction chord1Tick = std::get&lt;0&gt;(tremPair);</a>
<a name="ln552">            Fraction chord2Tick = std::get&lt;1&gt;(tremPair);</a>
<a name="ln553">            Tremolo* trem       = std::get&lt;2&gt;(tremPair);</a>
<a name="ln554">            int      track      = std::get&lt;3&gt;(tremPair);</a>
<a name="ln555"> </a>
<a name="ln556">            undo(new MoveTremolo(trem-&gt;score(), chord1Tick, chord2Tick, trem, track));</a>
<a name="ln557">            }</a>
<a name="ln558"> </a>
<a name="ln559">      if (noteEntryMode()) {</a>
<a name="ln560">            // set input cursor to possibly re-written segment</a>
<a name="ln561">            Fraction icTick = inputPos();</a>
<a name="ln562">            Segment* icSegment = tick2segment(icTick, false, SegmentType::ChordRest);</a>
<a name="ln563">            if (!icSegment) {</a>
<a name="ln564">                  // this can happen if cursor was on a rest</a>
<a name="ln565">                  // and in the rewriting it got subsumed into a full measure rest</a>
<a name="ln566">                  Measure* icMeasure = tick2measure(icTick);</a>
<a name="ln567">                  if (!icMeasure)                     // shouldn't happen, but just in case</a>
<a name="ln568">                        icMeasure = firstMeasure();</a>
<a name="ln569">                  icSegment = icMeasure-&gt;first(SegmentType::ChordRest);</a>
<a name="ln570">                  }</a>
<a name="ln571">            inputState().setSegment(icSegment);</a>
<a name="ln572">            }</a>
<a name="ln573"> </a>
<a name="ln574">      return true;</a>
<a name="ln575">      }</a>
<a name="ln576"> </a>
<a name="ln577">//---------------------------------------------------------</a>
<a name="ln578">//   rewriteMeasures</a>
<a name="ln579">//    rewrite all measures up to the next time signature or section break</a>
<a name="ln580">//---------------------------------------------------------</a>
<a name="ln581"> </a>
<a name="ln582">bool Score::rewriteMeasures(Measure* fm, const Fraction&amp; ns, int staffIdx)</a>
<a name="ln583">      {</a>
<a name="ln584">      Measure* lm  = fm;</a>
<a name="ln585">      Measure* fm1 = fm;</a>
<a name="ln586">      Measure* nm  = nullptr;</a>
<a name="ln587">      LayoutBreak* sectionBreak = nullptr;</a>
<a name="ln588"> </a>
<a name="ln589">      // disable local time sig modifications in linked staves</a>
<a name="ln590">      if (staffIdx != -1 &amp;&amp; excerpts().size() &gt; 0) {</a>
<a name="ln591">            MScore::setError(CANNOT_CHANGE_LOCAL_TIMESIG);</a>
<a name="ln592">            return false;</a>
<a name="ln593">            }</a>
<a name="ln594"> </a>
<a name="ln595">      //</a>
<a name="ln596">      // split into Measure segments fm-lm</a>
<a name="ln597">      //</a>
<a name="ln598">      for (MeasureBase* measure = fm; ; measure = measure-&gt;next()) {</a>
<a name="ln599"> </a>
<a name="ln600">            if (!measure || !measure-&gt;isMeasure() || lm-&gt;sectionBreak()</a>
<a name="ln601">              || (toMeasure(measure)-&gt;first(SegmentType::TimeSig) &amp;&amp; measure != fm))</a>
<a name="ln602">                  {</a>
<a name="ln603"> </a>
<a name="ln604">                  // save section break to reinstate after rewrite</a>
<a name="ln605">                  if (lm-&gt;sectionBreak())</a>
<a name="ln606">                        sectionBreak = new LayoutBreak(*lm-&gt;sectionBreakElement());</a>
<a name="ln607"> </a>
<a name="ln608">                  if (!rewriteMeasures(fm1, lm, ns, staffIdx)) {</a>
<a name="ln609">                        if (staffIdx &gt;= 0) {</a>
<a name="ln610">                              MScore::setError(CANNOT_CHANGE_LOCAL_TIMESIG);</a>
<a name="ln611">                              // restore measure rests that were prematurely modified</a>
<a name="ln612">                              Fraction fr(staff(staffIdx)-&gt;timeSig(fm-&gt;tick())-&gt;sig());</a>
<a name="ln613">                              for (Measure* m = fm1; m; m = m-&gt;nextMeasure()) {</a>
<a name="ln614">                                    ChordRest* cr = m-&gt;findChordRest(m-&gt;tick(), staffIdx * VOICES);</a>
<a name="ln615">                                    if (cr &amp;&amp; cr-&gt;isRest() &amp;&amp; cr-&gt;durationType() == TDuration::DurationType::V_MEASURE)</a>
<a name="ln616">                                          cr-&gt;undoChangeProperty(Pid::DURATION, QVariant::fromValue(fr));</a>
<a name="ln617">                                    else</a>
<a name="ln618">                                          break;</a>
<a name="ln619">                                    }</a>
<a name="ln620">                              }</a>
<a name="ln621">                        else {</a>
<a name="ln622">                              // this can be hit for local time signatures as well</a>
<a name="ln623">                              // (if we are rewriting all staves, but one has a local time signature)</a>
<a name="ln624">                              // TODO: detect error conditions better, have clearer error messages</a>
<a name="ln625">                              // and perform necessary fixups</a>
<a name="ln626">                              MScore::setError(TUPLET_CROSSES_BAR);</a>
<a name="ln627">                              }</a>
<a name="ln628">                        for (Measure* m = fm1; m; m = m-&gt;nextMeasure()) {</a>
<a name="ln629">                              if (m-&gt;first(SegmentType::TimeSig))</a>
<a name="ln630">                                    break;</a>
<a name="ln631">                              Fraction fr(ns);</a>
<a name="ln632">                              m-&gt;undoChangeProperty(Pid::TIMESIG_NOMINAL, QVariant::fromValue(fr));</a>
<a name="ln633">                              }</a>
<a name="ln634">                        return false;</a>
<a name="ln635">                        }</a>
<a name="ln636"> </a>
<a name="ln637">                  // after rewrite, lm is not necessarily valid</a>
<a name="ln638">                  // m is first MeasureBase after rewritten range</a>
<a name="ln639">                  // m-&gt;prevMeasure () is new last measure of range</a>
<a name="ln640">                  // set nm to first true Measure after rewritten range</a>
<a name="ln641">                  // we may use this to reinstate time signatures</a>
<a name="ln642">                  if (measure &amp;&amp; measure-&gt;prevMeasure())</a>
<a name="ln643">                        nm = measure-&gt;prevMeasure()-&gt;nextMeasure();</a>
<a name="ln644">                  else</a>
<a name="ln645">                        nm = nullptr;</a>
<a name="ln646"> </a>
<a name="ln647">                  if (sectionBreak) {</a>
<a name="ln648">                        // reinstate section break, then stop rewriting</a>
<a name="ln649">                        if (measure &amp;&amp; measure-&gt;prevMeasure()) {</a>
<a name="ln650">                              sectionBreak-&gt;setParent(measure-&gt;prevMeasure());</a>
<a name="ln651">                              undoAddElement(sectionBreak);</a>
<a name="ln652">                              }</a>
<a name="ln653">                        else if (!measure) {</a>
<a name="ln654">                              sectionBreak-&gt;setParent(lastMeasure());</a>
<a name="ln655">                              undoAddElement(sectionBreak);</a>
<a name="ln656">                              }</a>
<a name="ln657">                        else {</a>
<a name="ln658">                              qDebug(&quot;unable to restore section break&quot;);</a>
<a name="ln659">                              nm = nullptr;</a>
<a name="ln660">                              sectionBreak = nullptr;</a>
<a name="ln661">                              }</a>
<a name="ln662">                        break;</a>
<a name="ln663">                        }</a>
<a name="ln664"> </a>
<a name="ln665">                  // stop rewriting at end of score</a>
<a name="ln666">                  // or at a measure (which means we found a time signature segment)</a>
<a name="ln667">                  if (!measure || measure-&gt;isMeasure())</a>
<a name="ln668">                        break;</a>
<a name="ln669"> </a>
<a name="ln670">                  // skip frames</a>
<a name="ln671">                  while (!measure-&gt;isMeasure()) {</a>
<a name="ln672">                        if (measure-&gt;sectionBreak()) {</a>
<a name="ln673">                              // frame has a section break; we can stop skipping ahead</a>
<a name="ln674">                              sectionBreak = measure-&gt;sectionBreakElement();</a>
<a name="ln675">                              break;</a>
<a name="ln676">                              }</a>
<a name="ln677">                        measure = measure-&gt;next();</a>
<a name="ln678">                        if (!measure)</a>
<a name="ln679">                              break;</a>
<a name="ln680">                        }</a>
<a name="ln681">                  // stop rewriting if we encountered a section break on a frame</a>
<a name="ln682">                  // or if there is a time signature on first measure after the frame</a>
<a name="ln683">                  if (sectionBreak || (measure &amp;&amp; toMeasure(measure)-&gt;first(SegmentType::TimeSig)))</a>
<a name="ln684">                        break;</a>
<a name="ln685"> </a>
<a name="ln686">                  // set up for next range to rewrite</a>
<a name="ln687">                  fm1 = toMeasure(measure);</a>
<a name="ln688">                  if (fm1 == 0)</a>
<a name="ln689">                        break;</a>
<a name="ln690">                  }</a>
<a name="ln691"> </a>
<a name="ln692">            // if we didn't break the loop already,</a>
<a name="ln693">            // we must have an ordinary measure</a>
<a name="ln694">            // add measure to range to rewrite</a>
<a name="ln695">            lm = toMeasure(measure);</a>
<a name="ln696">            }</a>
<a name="ln697"> </a>
<a name="ln698">      // if any staves don't have time signatures at the point where we stopped,</a>
<a name="ln699">      // we need to reinstate their previous time signatures</a>
<a name="ln700">      if (!nm)</a>
<a name="ln701">            return true;</a>
<a name="ln702">      Segment* s = nm-&gt;undoGetSegment(SegmentType::TimeSig, nm-&gt;tick());</a>
<a name="ln703">      for (int i = 0; i &lt; nstaves(); ++i) {</a>
<a name="ln704">            if (!s-&gt;element(i * VOICES)) {</a>
<a name="ln705">                  TimeSig* ots = staff(i)-&gt;timeSig(nm-&gt;tick());</a>
<a name="ln706">                  if (ots) {</a>
<a name="ln707">                        TimeSig* nts = new TimeSig(*ots);</a>
<a name="ln708">                        nts-&gt;setParent(s);</a>
<a name="ln709">                        if (sectionBreak) {</a>
<a name="ln710">                              nts-&gt;setGenerated(false);</a>
<a name="ln711">                              nts-&gt;setShowCourtesySig(false);</a>
<a name="ln712">                              }</a>
<a name="ln713">                        undoAddElement(nts);</a>
<a name="ln714">                        }</a>
<a name="ln715">                  }</a>
<a name="ln716">            }</a>
<a name="ln717"> </a>
<a name="ln718">      return true;</a>
<a name="ln719">      }</a>
<a name="ln720"> </a>
<a name="ln721">//---------------------------------------------------------</a>
<a name="ln722">//   cmdAddTimeSig</a>
<a name="ln723">//</a>
<a name="ln724">//    Add or change time signature at measure in response</a>
<a name="ln725">//    to gui command (drop timesig on measure or timesig)</a>
<a name="ln726">//---------------------------------------------------------</a>
<a name="ln727"> </a>
<a name="ln728">void Score::cmdAddTimeSig(Measure* fm, int staffIdx, TimeSig* ts, bool local)</a>
<a name="ln729">      {</a>
<a name="ln730">      deselectAll();</a>
<a name="ln731"> </a>
<a name="ln732">      if (fm-&gt;isMMRest())</a>
<a name="ln733">            fm = fm-&gt;mmRestFirst();</a>
<a name="ln734"> </a>
<a name="ln735">      Fraction ns   = ts-&gt;sig();</a>
<a name="ln736">      Fraction tick = fm-&gt;tick();</a>
<a name="ln737">      TimeSig* lts  = staff(staffIdx)-&gt;timeSig(tick);</a>
<a name="ln738">      if (local) {</a>
<a name="ln739">            Fraction stretch = (ns / fm-&gt;timesig()).reduced();</a>
<a name="ln740">            ts-&gt;setStretch(stretch);</a>
<a name="ln741">            }</a>
<a name="ln742"> </a>
<a name="ln743">      Fraction stretch;</a>
<a name="ln744">      Fraction lsig;                // last signature</a>
<a name="ln745">      if (lts) {</a>
<a name="ln746">            stretch = lts-&gt;stretch();</a>
<a name="ln747">            lsig    = lts-&gt;sig();</a>
<a name="ln748">            }</a>
<a name="ln749">      else {</a>
<a name="ln750">            stretch.set(1,1);</a>
<a name="ln751">            lsig.set(4,4);          // set to default</a>
<a name="ln752">            }</a>
<a name="ln753"> </a>
<a name="ln754">      int track    = staffIdx * VOICES;</a>
<a name="ln755">      Segment* seg = fm-&gt;undoGetSegment(SegmentType::TimeSig, tick);</a>
<a name="ln756">      TimeSig* ots = toTimeSig(seg-&gt;element(track));</a>
<a name="ln757"> </a>
<a name="ln758">      if (ots &amp;&amp; (*ots == *ts)) {</a>
<a name="ln759">            //</a>
<a name="ln760">            //  ignore if there is already a timesig</a>
<a name="ln761">            //  with same values</a>
<a name="ln762">            //</a>
<a name="ln763">            delete ts;</a>
<a name="ln764">            return;</a>
<a name="ln765">            }</a>
<a name="ln766"> </a>
<a name="ln767">      if (ots &amp;&amp; ots-&gt;sig() == ns &amp;&amp; ots-&gt;stretch() == ts-&gt;stretch()) {</a>
<a name="ln768">            //</a>
<a name="ln769">            // the measure duration does not change,</a>
<a name="ln770">            // so its ok to just update the time signatures</a>
<a name="ln771">            //</a>
<a name="ln772">            TimeSig* nts = staff(staffIdx)-&gt;nextTimeSig(tick + Fraction::fromTicks(1));</a>
<a name="ln773">            const Fraction lmTick = nts ? nts-&gt;segment()-&gt;tick() : Fraction(-1,1);</a>
<a name="ln774">            for (Score* score : scoreList()) {</a>
<a name="ln775">                  Measure* mf = score-&gt;tick2measure(tick);</a>
<a name="ln776">                  Measure* lm = (lmTick != Fraction(-1,1)) ? score-&gt;tick2measure(lmTick) : nullptr;</a>
<a name="ln777">                  for (Measure* m = mf; m != lm; m = m-&gt;nextMeasure()) {</a>
<a name="ln778">                        bool changeActual = m-&gt;ticks() == m-&gt;timesig();</a>
<a name="ln779">                        m-&gt;undoChangeProperty(Pid::TIMESIG_NOMINAL, QVariant::fromValue(ns));</a>
<a name="ln780">                        if (changeActual)</a>
<a name="ln781">                              m-&gt;undoChangeProperty(Pid::TIMESIG_ACTUAL,  QVariant::fromValue(ns));</a>
<a name="ln782">                        }</a>
<a name="ln783">                  }</a>
<a name="ln784">            int n = nstaves();</a>
<a name="ln785">            for (int si = 0; si &lt; n; ++si) {</a>
<a name="ln786">                  TimeSig* nsig = toTimeSig(seg-&gt;element(si * VOICES));</a>
<a name="ln787">                  nsig-&gt;undoChangeProperty(Pid::SHOW_COURTESY, ts-&gt;showCourtesySig());</a>
<a name="ln788">                  nsig-&gt;undoChangeProperty(Pid::TIMESIG, QVariant::fromValue(ts-&gt;sig()));</a>
<a name="ln789">                  nsig-&gt;undoChangeProperty(Pid::TIMESIG_TYPE, int(ts-&gt;timeSigType()));</a>
<a name="ln790">                  nsig-&gt;undoChangeProperty(Pid::NUMERATOR_STRING, ts-&gt;numeratorString());</a>
<a name="ln791">                  nsig-&gt;undoChangeProperty(Pid::DENOMINATOR_STRING, ts-&gt;denominatorString());</a>
<a name="ln792">                  nsig-&gt;undoChangeProperty(Pid::TIMESIG_STRETCH, QVariant::fromValue(ts-&gt;stretch()));</a>
<a name="ln793">                  nsig-&gt;undoChangeProperty(Pid::GROUPS,  QVariant::fromValue(ts-&gt;groups()));</a>
<a name="ln794">                  nsig-&gt;setSelected(false);</a>
<a name="ln795">                  nsig-&gt;setDropTarget(0);</a>
<a name="ln796">                  }</a>
<a name="ln797">            }</a>
<a name="ln798">      else {</a>
<a name="ln799">            Score* mScore = masterScore();</a>
<a name="ln800">            Measure* mf  = mScore-&gt;tick2measure(tick);</a>
<a name="ln801"> </a>
<a name="ln802">            //</a>
<a name="ln803">            // rewrite all measures up to the next time signature</a>
<a name="ln804">            //</a>
<a name="ln805">            if (mf == mScore-&gt;firstMeasure() &amp;&amp; mf-&gt;nextMeasure() &amp;&amp; (mf-&gt;ticks() != mf-&gt;timesig())) {</a>
<a name="ln806">                  // handle upbeat</a>
<a name="ln807">                  mf-&gt;undoChangeProperty(Pid::TIMESIG_NOMINAL, QVariant::fromValue(ns));</a>
<a name="ln808">                  Measure* m = mf-&gt;nextMeasure();</a>
<a name="ln809">                  Segment* s = m-&gt;findSegment(SegmentType::TimeSig, m-&gt;tick());</a>
<a name="ln810">                  mf = s ? 0 : mf-&gt;nextMeasure();</a>
<a name="ln811">                  }</a>
<a name="ln812">            else {</a>
<a name="ln813">                  if (sigmap()-&gt;timesig(seg-&gt;tick().ticks()).nominal().identical(ns)) {</a>
<a name="ln814">                        // no change to global time signature,</a>
<a name="ln815">                        // but we need to rewrite any staves with local time signatures</a>
<a name="ln816">                        for (int i = 0; i &lt; nstaves(); ++i) {</a>
<a name="ln817">                              if (staff(i)-&gt;timeSig(tick) &amp;&amp; staff(i)-&gt;timeSig(tick)-&gt;isLocal()) {</a>
<a name="ln818">                                    if (!mScore-&gt;rewriteMeasures(mf, ns, i)) {</a>
<a name="ln819">                                          undoStack()-&gt;current()-&gt;unwind();</a>
<a name="ln820">                                          return;</a>
<a name="ln821">                                          }</a>
<a name="ln822">                                    }</a>
<a name="ln823">                              }</a>
<a name="ln824">                        mf = 0;</a>
<a name="ln825">                        }</a>
<a name="ln826">                  }</a>
<a name="ln827"> </a>
<a name="ln828">            // try to rewrite the measures first</a>
<a name="ln829">            // we will only add time signatures if this succeeds</a>
<a name="ln830">            // this means, however, that the rewrite cannot depend on the time signatures being in place</a>
<a name="ln831">            if (mf) {</a>
<a name="ln832">                  if (!mScore-&gt;rewriteMeasures(mf, ns, local ? staffIdx : -1)) {</a>
<a name="ln833">                        undoStack()-&gt;current()-&gt;unwind();</a>
<a name="ln834">                        return;</a>
<a name="ln835">                        }</a>
<a name="ln836">                  }</a>
<a name="ln837">            // add the time signatures</a>
<a name="ln838">            std::map&lt;int, TimeSig*&gt; masterTimeSigs;</a>
<a name="ln839">            for (Score* score : scoreList()) {</a>
<a name="ln840">                  Measure* nfm = score-&gt;tick2measure(tick);</a>
<a name="ln841">                  seg   = nfm-&gt;undoGetSegment(SegmentType::TimeSig, nfm-&gt;tick());</a>
<a name="ln842">                  int startStaffIdx, endStaffIdx;</a>
<a name="ln843">                  if (local) {</a>
<a name="ln844">                        if (score == this) {</a>
<a name="ln845">                              startStaffIdx = staffIdx;</a>
<a name="ln846">                              endStaffIdx   = startStaffIdx + 1;</a>
<a name="ln847">                              }</a>
<a name="ln848">                        else {</a>
<a name="ln849">                              // TODO: get index for this score</a>
<a name="ln850">                              qDebug(&quot;cmdAddTimeSig: unable to write local time signature change to linked score&quot;);</a>
<a name="ln851">                              startStaffIdx = 0;</a>
<a name="ln852">                              endStaffIdx   = 0;</a>
<a name="ln853">                              }</a>
<a name="ln854">                        }</a>
<a name="ln855">                  else {</a>
<a name="ln856">                        startStaffIdx = 0;</a>
<a name="ln857">                        endStaffIdx   = score-&gt;nstaves();</a>
<a name="ln858">                        }</a>
<a name="ln859">                  for (int si = startStaffIdx; si &lt; endStaffIdx; ++si) {</a>
<a name="ln860">                        TimeSig* nsig = toTimeSig(seg-&gt;element(si * VOICES));</a>
<a name="ln861">                        if (nsig == 0) {</a>
<a name="ln862">                              nsig = new TimeSig(*ts);</a>
<a name="ln863">                              nsig-&gt;setScore(score);</a>
<a name="ln864">                              nsig-&gt;setTrack(si * VOICES);</a>
<a name="ln865">                              nsig-&gt;setParent(seg);</a>
<a name="ln866">                              undoAddElement(nsig);</a>
<a name="ln867">                              if (score-&gt;excerpt()) {</a>
<a name="ln868">                                    const int masterTrack = score-&gt;excerpt()-&gt;tracks().key(nsig-&gt;track());</a>
<a name="ln869">                                    TimeSig* masterTimeSig = masterTimeSigs[masterTrack];</a>
<a name="ln870">                                    if (masterTimeSig)</a>
<a name="ln871">                                          undo(new Link(masterTimeSig, nsig));</a>
<a name="ln872">                                    }</a>
<a name="ln873">                              }</a>
<a name="ln874">                        else {</a>
<a name="ln875">                              nsig-&gt;undoChangeProperty(Pid::SHOW_COURTESY, ts-&gt;showCourtesySig());</a>
<a name="ln876">                              nsig-&gt;undoChangeProperty(Pid::TIMESIG_TYPE, int(ts-&gt;timeSigType()));</a>
<a name="ln877">                              nsig-&gt;undoChangeProperty(Pid::TIMESIG, QVariant::fromValue(ts-&gt;sig()));</a>
<a name="ln878">                              nsig-&gt;undoChangeProperty(Pid::NUMERATOR_STRING, ts-&gt;numeratorString());</a>
<a name="ln879">                              nsig-&gt;undoChangeProperty(Pid::DENOMINATOR_STRING, ts-&gt;denominatorString());</a>
<a name="ln880"> </a>
<a name="ln881">                              // HACK do it twice to accommodate undo</a>
<a name="ln882">                              nsig-&gt;undoChangeProperty(Pid::TIMESIG_TYPE, int(ts-&gt;timeSigType()));</a>
<a name="ln883">                              nsig-&gt;undoChangeProperty(Pid::TIMESIG_STRETCH, QVariant::fromValue(ts-&gt;stretch()));</a>
<a name="ln884">                              nsig-&gt;undoChangeProperty(Pid::GROUPS,  QVariant::fromValue(ts-&gt;groups()));</a>
<a name="ln885">                              nsig-&gt;setSelected(false);</a>
<a name="ln886">                              nsig-&gt;setDropTarget(0);       // DEBUG</a>
<a name="ln887">                              }</a>
<a name="ln888"> </a>
<a name="ln889">                        if (score-&gt;isMaster())</a>
<a name="ln890">                              masterTimeSigs[nsig-&gt;track()] = nsig;</a>
<a name="ln891">                        }</a>
<a name="ln892">                  }</a>
<a name="ln893">            }</a>
<a name="ln894">      delete ts;</a>
<a name="ln895">      }</a>
<a name="ln896"> </a>
<a name="ln897">//---------------------------------------------------------</a>
<a name="ln898">//   cmdRemoveTimeSig</a>
<a name="ln899">//---------------------------------------------------------</a>
<a name="ln900"> </a>
<a name="ln901">void Score::cmdRemoveTimeSig(TimeSig* ts)</a>
<a name="ln902">      {</a>
<a name="ln903">      if (ts-&gt;isLocal() &amp;&amp; excerpts().size() &gt; 0) {</a>
<a name="ln904">            MScore::setError(CANNOT_CHANGE_LOCAL_TIMESIG);</a>
<a name="ln905">            return;</a>
<a name="ln906">            }</a>
<a name="ln907"> </a>
<a name="ln908">      Measure* m = ts-&gt;measure();</a>
<a name="ln909">      Segment* s = ts-&gt;segment();</a>
<a name="ln910"> </a>
<a name="ln911">      //</a>
<a name="ln912">      // we cannot remove a courtesy time signature</a>
<a name="ln913">      //</a>
<a name="ln914">      if (m-&gt;tick() != s-&gt;tick())</a>
<a name="ln915">            return;</a>
<a name="ln916">      Fraction tick = m-&gt;tick();</a>
<a name="ln917"> </a>
<a name="ln918">      // if we remove all time sigs from segment, segment will be already removed by now</a>
<a name="ln919">      // but this would leave us no means of detecting that we have have measures in a local timesig</a>
<a name="ln920">      // in cases where we try deleting the local time sig</a>
<a name="ln921">      // known bug: this means we do not correctly detect non-empty measures when deleting global timesig change after a local one</a>
<a name="ln922">      // see http://musescore.org/en/node/51596</a>
<a name="ln923">      // Delete the time sig segment from the root score, we will rewriteMeasures from it</a>
<a name="ln924">      // since it contains all the music while the part doesn't</a>
<a name="ln925">      Score* rScore = masterScore();</a>
<a name="ln926">      Measure* rm = rScore-&gt;tick2measure(m-&gt;tick());</a>
<a name="ln927">      Segment* rs = rm-&gt;findSegment(SegmentType::TimeSig, s-&gt;tick());</a>
<a name="ln928">      rScore-&gt;undoRemoveElement(rs);</a>
<a name="ln929"> </a>
<a name="ln930">      Measure* pm = m-&gt;prevMeasure();</a>
<a name="ln931">      Fraction ns(pm ? pm-&gt;timesig() : Fraction(4,4));</a>
<a name="ln932"> </a>
<a name="ln933">      if (!rScore-&gt;rewriteMeasures(rm, ns, -1)) {</a>
<a name="ln934">            undoStack()-&gt;current()-&gt;unwind();</a>
<a name="ln935">            }</a>
<a name="ln936">      else {</a>
<a name="ln937">            m = tick2measure(tick);       // old m may have been replaced</a>
<a name="ln938">            // hack: fix measure rest durations for staves with local time signatures</a>
<a name="ln939">            // if a time signature was deleted to reveal a previous local one,</a>
<a name="ln940">            // then rewriteMeasures() got the measure rest durations wrong</a>
<a name="ln941">            // (if we fixed it to work for delete, it would fail for add)</a>
<a name="ln942">            // so we will fix measure rest durations here</a>
<a name="ln943">            // TODO: fix rewriteMeasures() to get this right</a>
<a name="ln944">            for (int i = 0; i &lt; nstaves(); ++i) {</a>
<a name="ln945">                  TimeSig* tsig = staff(i)-&gt;timeSig(tick);</a>
<a name="ln946">                  if (tsig &amp;&amp; tsig-&gt;isLocal()) {</a>
<a name="ln947">                        for (Measure* nm = m; nm; nm = nm-&gt;nextMeasure()) {</a>
<a name="ln948">                              // stop when time signature changes</a>
<a name="ln949">                              if (staff(i)-&gt;timeSig(nm-&gt;tick()) != tsig)</a>
<a name="ln950">                                    break;</a>
<a name="ln951">                              // fix measure rest duration</a>
<a name="ln952">                              ChordRest* cr = nm-&gt;findChordRest(nm-&gt;tick(), i * VOICES);</a>
<a name="ln953">                              if (cr &amp;&amp; cr-&gt;isRest() &amp;&amp; cr-&gt;durationType() == TDuration::DurationType::V_MEASURE)</a>
<a name="ln954">                                    cr-&gt;undoChangeProperty(Pid::DURATION, QVariant::fromValue(nm-&gt;stretchedLen(staff(i))));</a>
<a name="ln955">                                    //cr-&gt;setTicks(nm-&gt;stretchedLen(staff(i)));</a>
<a name="ln956">                              }</a>
<a name="ln957">                        }</a>
<a name="ln958">                  }</a>
<a name="ln959">            }</a>
<a name="ln960">      }</a>
<a name="ln961"> </a>
<a name="ln962">//---------------------------------------------------------</a>
<a name="ln963">//  addTiedMidiPitch</a>
<a name="ln964">//---------------------------------------------------------</a>
<a name="ln965"> </a>
<a name="ln966">Note* Score::addTiedMidiPitch(int pitch, bool addFlag, Chord* prevChord)</a>
<a name="ln967">      {</a>
<a name="ln968">      Note* n = addMidiPitch(pitch, addFlag);</a>
<a name="ln969">      if (prevChord) {</a>
<a name="ln970">            Note* nn = prevChord-&gt;findNote(n-&gt;pitch());</a>
<a name="ln971">            if (nn) {</a>
<a name="ln972">                  Tie* tie = new Tie(this);</a>
<a name="ln973">                  tie-&gt;setStartNote(nn);</a>
<a name="ln974">                  tie-&gt;setEndNote(n);</a>
<a name="ln975">                  tie-&gt;setTrack(n-&gt;track());</a>
<a name="ln976">                  n-&gt;setTieBack(tie);</a>
<a name="ln977">                  nn-&gt;setTieFor(tie);</a>
<a name="ln978">                  undoAddElement(tie);</a>
<a name="ln979">                  }</a>
<a name="ln980">            }</a>
<a name="ln981">      return n;</a>
<a name="ln982">      }</a>
<a name="ln983"> </a>
<a name="ln984">//---------------------------------------------------------</a>
<a name="ln985">//  addMidiPitch</a>
<a name="ln986">//---------------------------------------------------------</a>
<a name="ln987"> </a>
<a name="ln988">Note* Score::addMidiPitch(int pitch, bool addFlag)</a>
<a name="ln989">      {</a>
<a name="ln990">      NoteVal nval(pitch);</a>
<a name="ln991">      Staff* st = staff(inputState().track() / VOICES);</a>
<a name="ln992"> </a>
<a name="ln993">      // if transposing, interpret MIDI pitch as representing desired written pitch</a>
<a name="ln994">      // set pitch based on corresponding sounding pitch</a>
<a name="ln995">      if (!styleB(Sid::concertPitch))</a>
<a name="ln996">            nval.pitch += st-&gt;part()-&gt;instrument(inputState().tick())-&gt;transpose().chromatic;</a>
<a name="ln997">      // let addPitch calculate tpc values from pitch</a>
<a name="ln998">      //Key key   = st-&gt;key(inputState().tick());</a>
<a name="ln999">      //nval.tpc1 = pitch2tpc(nval.pitch, key, Prefer::NEAREST);</a>
<a name="ln1000">      return addPitch(nval, addFlag);</a>
<a name="ln1001">      }</a>
<a name="ln1002"> </a>
<a name="ln1003">//---------------------------------------------------------</a>
<a name="ln1004">//   searchNote</a>
<a name="ln1005">//    search for note or rest before or at tick position tick</a>
<a name="ln1006">//    in staff</a>
<a name="ln1007">//---------------------------------------------------------</a>
<a name="ln1008"> </a>
<a name="ln1009">ChordRest* Score::searchNote(const Fraction&amp; tick, int track) const</a>
<a name="ln1010">      {</a>
<a name="ln1011">      ChordRest* ipe = 0;</a>
<a name="ln1012">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln1013">      for (Segment* segment = firstSegment(st); segment; segment = segment-&gt;next1(st)) {</a>
<a name="ln1014">            ChordRest* cr = segment-&gt;cr(track);</a>
<a name="ln1015">            if (!cr)</a>
<a name="ln1016">                  continue;</a>
<a name="ln1017">            if (cr-&gt;tick() == tick)</a>
<a name="ln1018">                  return cr;</a>
<a name="ln1019">            if (cr-&gt;tick() &gt;  tick)</a>
<a name="ln1020">                  return ipe ? ipe : cr;</a>
<a name="ln1021">            ipe = cr;</a>
<a name="ln1022">            }</a>
<a name="ln1023">      return 0;</a>
<a name="ln1024">      }</a>
<a name="ln1025"> </a>
<a name="ln1026">//---------------------------------------------------------</a>
<a name="ln1027">//   regroupNotesAndRests</a>
<a name="ln1028">//    * combine consecutive rests into fewer rests of longer duration.</a>
<a name="ln1029">//    * combine tied notes/chords into fewer notes of longer duration.</a>
<a name="ln1030">//    Only operates on one voice - protects manual layout adjustment, etc.</a>
<a name="ln1031">//---------------------------------------------------------</a>
<a name="ln1032"> </a>
<a name="ln1033">void Score::regroupNotesAndRests(const Fraction&amp; startTick, const Fraction&amp; endTick, int track)</a>
<a name="ln1034">      {</a>
<a name="ln1035">      Segment* inputSegment = _is.segment(); // store this so we can get back to it later.</a>
<a name="ln1036">      Segment* seg = tick2segment(startTick, true, SegmentType::ChordRest);</a>
<a name="ln1037">      for (Measure* msr = seg-&gt;measure(); msr &amp;&amp; msr-&gt;tick() &lt; endTick; msr = msr-&gt;nextMeasure()) {</a>
<a name="ln1038">            Fraction maxTick = endTick &gt; msr-&gt;endTick() ? msr-&gt;endTick() : endTick;</a>
<a name="ln1039">            if (!seg || seg-&gt;measure() != msr)</a>
<a name="ln1040">                  seg = msr-&gt;first(SegmentType::ChordRest);</a>
<a name="ln1041">            for (; seg; seg = seg-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln1042">                  ChordRest* curr = seg-&gt;cr(track);</a>
<a name="ln1043">                  if (!curr)</a>
<a name="ln1044">                        continue; // this voice is empty here (CR overlaps with CR in other track)</a>
<a name="ln1045">                  if (seg-&gt;tick() + curr-&gt;actualTicks() &gt; maxTick)</a>
<a name="ln1046">                        break; // outside range</a>
<a name="ln1047">                  if (curr-&gt;isRest() &amp;&amp; !(curr-&gt;tuplet()) &amp;&amp; !(toRest(curr)-&gt;isGap())) {</a>
<a name="ln1048">                        // combine consecutive rests</a>
<a name="ln1049">                        ChordRest* lastRest = curr;</a>
<a name="ln1050">                        for (Segment* s = seg-&gt;next(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln1051">                              ChordRest* cr = s-&gt;cr(track);</a>
<a name="ln1052">                              if (!cr)</a>
<a name="ln1053">                                    continue; // this voice is empty here</a>
<a name="ln1054">                              if (!cr-&gt;isRest() || s-&gt;tick() + cr-&gt;actualTicks() &gt; maxTick || toRest(cr)-&gt;isGap())</a>
<a name="ln1055">                                    break; // next element in the same voice is not a rest, or it exceeds the selection, or it is a gap</a>
<a name="ln1056">                              lastRest = cr;</a>
<a name="ln1057">                              }</a>
<a name="ln1058">                        Fraction restTicks = lastRest-&gt;tick() + lastRest-&gt;ticks() - curr-&gt;tick();</a>
<a name="ln1059">                        seg = setNoteRest(seg, curr-&gt;track(), NoteVal(), restTicks, Direction::AUTO, false, true);</a>
<a name="ln1060">                        }</a>
<a name="ln1061">                  else if (curr-&gt;isChord()) {</a>
<a name="ln1062">                        // combine tied chords</a>
<a name="ln1063">                        Chord* chord = toChord(curr);</a>
<a name="ln1064">                        Chord* lastTiedChord = chord;</a>
<a name="ln1065">                        for (Chord* next = chord-&gt;nextTiedChord(); next &amp;&amp; next-&gt;tick() + next-&gt;ticks() &lt;= maxTick; next = next-&gt;nextTiedChord()) {</a>
<a name="ln1066">                              lastTiedChord = next;</a>
<a name="ln1067">                              }</a>
<a name="ln1068">                        if (!lastTiedChord)</a>
<a name="ln1069">                              lastTiedChord = chord;</a>
<a name="ln1070">                        Fraction noteTicks = lastTiedChord-&gt;tick() + lastTiedChord-&gt;ticks() - chord-&gt;tick();</a>
<a name="ln1071">                        if (!(curr-&gt;tuplet())) {</a>
<a name="ln1072">                              // store start/end note for backward/forward ties ending/starting on the group of notes being rewritten</a>
<a name="ln1073">                              size_t numNotes = chord-&gt;notes().size();</a>
<a name="ln1074">#if (!defined (_MSCVER) &amp;&amp; !defined (_MSC_VER))</a>
<a name="ln1075">                              Note* tieBack[numNotes];</a>
<a name="ln1076">                              Note* tieFor[numNotes];</a>
<a name="ln1077">#else</a>
<a name="ln1078">                              // MSVC does not support VLA. Replace with std::vector. If profiling determines that the</a>
<a name="ln1079">                              //    heap allocation is slow, an optimization might be used.</a>
<a name="ln1080">                              std::vector&lt;Note *&gt; tieBack(numNotes);</a>
<a name="ln1081">                              std::vector&lt;Note *&gt; tieFor(numNotes);</a>
<a name="ln1082">#endif</a>
<a name="ln1083">                              for (size_t i = 0; i &lt; numNotes; i++) {</a>
<a name="ln1084">                                    Note* n = chord-&gt;notes()[i];</a>
<a name="ln1085">                                    Note* nn = lastTiedChord-&gt;notes()[i];</a>
<a name="ln1086">                                    if (n-&gt;tieBack())</a>
<a name="ln1087">                                          tieBack[i] = n-&gt;tieBack()-&gt;startNote();</a>
<a name="ln1088">                                    else</a>
<a name="ln1089">                                          tieBack[i] = 0;</a>
<a name="ln1090">                                    if (nn-&gt;tieFor())</a>
<a name="ln1091">                                          tieFor[i] = nn-&gt;tieFor()-&gt;endNote();</a>
<a name="ln1092">                                    else</a>
<a name="ln1093">                                          tieFor[i] = 0;</a>
<a name="ln1094">                                    }</a>
<a name="ln1095">                              Fraction tick = seg-&gt;tick();</a>
<a name="ln1096">                              int tr        = chord-&gt;track();</a>
<a name="ln1097">                              Fraction sd   = noteTicks;</a>
<a name="ln1098">                              Tie* tie      = 0;</a>
<a name="ln1099">                              Segment* segment = seg;</a>
<a name="ln1100">                              ChordRest* cr = toChordRest(segment-&gt;element(tr));</a>
<a name="ln1101">                              Chord* nchord = toChord(chord-&gt;clone());</a>
<a name="ln1102">                              for (size_t i = 0; i &lt; numNotes; i++) { // strip ties from cloned chord</a>
<a name="ln1103">                                    Note* n = nchord-&gt;notes()[i];</a>
<a name="ln1104">                                    n-&gt;setTieFor(0);</a>
<a name="ln1105">                                    n-&gt;setTieBack(0);</a>
<a name="ln1106">                                    }</a>
<a name="ln1107">                              Chord* startChord = nchord;</a>
<a name="ln1108">                              Measure* measure = 0;</a>
<a name="ln1109">                              bool firstpart = true;</a>
<a name="ln1110">                              for (;;) {</a>
<a name="ln1111">                                    if (tr % VOICES)</a>
<a name="ln1112">                                          expandVoice(segment, tr);</a>
<a name="ln1113">                                    // the returned gap ends at the measure boundary or at tuplet end</a>
<a name="ln1114">                                    Fraction dd = makeGap(segment, tr, sd, cr-&gt;tuplet());</a>
<a name="ln1115">                                    if (dd.isZero())</a>
<a name="ln1116">                                          break;</a>
<a name="ln1117">                                    measure = segment-&gt;measure();</a>
<a name="ln1118">                                    std::vector&lt;TDuration&gt; dl;</a>
<a name="ln1119">                                    dl = toRhythmicDurationList(dd, false, segment-&gt;rtick(), sigmap()-&gt;timesig(tick.ticks()).nominal(), measure, 1);</a>
<a name="ln1120">                                    size_t n = dl.size();</a>
<a name="ln1121">                                    for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln1122">                                          const TDuration&amp; d = dl[i];</a>
<a name="ln1123">                                          Chord* nchord2 = toChord(nchord-&gt;clone());</a>
<a name="ln1124">                                          if (!firstpart)</a>
<a name="ln1125">                                                nchord2-&gt;removeMarkings(true);</a>
<a name="ln1126">                                          nchord2-&gt;setDurationType(d);</a>
<a name="ln1127">                                          nchord2-&gt;setTicks(d.fraction());</a>
<a name="ln1128">                                          std::vector&lt;Note*&gt; nl1 = nchord-&gt;notes();</a>
<a name="ln1129">                                          std::vector&lt;Note*&gt; nl2 = nchord2-&gt;notes();</a>
<a name="ln1130">                                          if (!firstpart)</a>
<a name="ln1131">                                                for (size_t j = 0; j &lt; nl1.size(); ++j) {</a>
<a name="ln1132">                                                      tie = new Tie(this);</a>
<a name="ln1133">                                                      tie-&gt;setStartNote(nl1[j]);</a>
<a name="ln1134">                                                      tie-&gt;setEndNote(nl2[j]);</a>
<a name="ln1135">                                                      tie-&gt;setTrack(tr);</a>
<a name="ln1136">                                                      nl1[j]-&gt;setTieFor(tie);</a>
<a name="ln1137">                                                      nl2[j]-&gt;setTieBack(tie);</a>
<a name="ln1138">                                                      }</a>
<a name="ln1139">                                          undoAddCR(nchord2, measure, tick);</a>
<a name="ln1140">                                          segment = nchord2-&gt;segment();</a>
<a name="ln1141">                                          tick += nchord2-&gt;actualTicks();</a>
<a name="ln1142">                                          nchord = nchord2;</a>
<a name="ln1143">                                          firstpart = false;</a>
<a name="ln1144">                                          }</a>
<a name="ln1145">                                    sd -= dd;</a>
<a name="ln1146">                                    if (sd.isZero())</a>
<a name="ln1147">                                          break;</a>
<a name="ln1148">                                    Segment* nseg = tick2segment(tick, false, SegmentType::ChordRest);</a>
<a name="ln1149">                                    if (nseg == 0)</a>
<a name="ln1150">                                          break;</a>
<a name="ln1151">                                    segment = nseg;</a>
<a name="ln1152">                                    cr = toChordRest(segment-&gt;element(tr));</a>
<a name="ln1153">                                    if (cr == 0) {</a>
<a name="ln1154">                                          if (tr % VOICES)</a>
<a name="ln1155">                                                cr = addRest(segment, tr, TDuration(TDuration::DurationType::V_MEASURE), 0);</a>
<a name="ln1156">                                          else</a>
<a name="ln1157">                                                break;</a>
<a name="ln1158">                                          }</a>
<a name="ln1159">                                    }</a>
<a name="ln1160">                              if (_is.slur()) {</a>
<a name="ln1161">                                    // extend slur</a>
<a name="ln1162">                                    _is.slur()-&gt;undoChangeProperty(Pid::SPANNER_TICKS, nchord-&gt;tick() - _is.slur()-&gt;tick());</a>
<a name="ln1163">                                    for (ScoreElement* e : _is.slur()-&gt;linkList()) {</a>
<a name="ln1164">                                          Slur* slur = toSlur(e);</a>
<a name="ln1165">                                          for (ScoreElement* ee : nchord-&gt;linkList()) {</a>
<a name="ln1166">                                                Element* e1 = static_cast&lt;Element*&gt;(ee);</a>
<a name="ln1167">                                                if (e1-&gt;score() == slur-&gt;score() &amp;&amp; e1-&gt;track() == slur-&gt;track2()) {</a>
<a name="ln1168">                                                      slur-&gt;score()-&gt;undo(new ChangeSpannerElements(slur, slur-&gt;startElement(), e1));</a>
<a name="ln1169">                                                      break;</a>
<a name="ln1170">                                                      }</a>
<a name="ln1171">                                                }</a>
<a name="ln1172">                                          }</a>
<a name="ln1173">                                    }</a>
<a name="ln1174">                              // recreate previously stored pending ties</a>
<a name="ln1175">                              for (size_t i = 0; i &lt; numNotes; i++) {</a>
<a name="ln1176">                                    Note* n = startChord-&gt;notes()[i];</a>
<a name="ln1177">                                    Note* nn = nchord-&gt;notes()[i];</a>
<a name="ln1178">                                    if (tieBack[i]) {</a>
<a name="ln1179">                                          tie = new Tie(this);</a>
<a name="ln1180">                                          tie-&gt;setStartNote(tieBack[i]);</a>
<a name="ln1181">                                          tie-&gt;setEndNote(n);</a>
<a name="ln1182">                                          tie-&gt;setTrack(track);</a>
<a name="ln1183">                                          n-&gt;setTieBack(tie);</a>
<a name="ln1184">                                          tieBack[i]-&gt;setTieFor(tie);</a>
<a name="ln1185">                                          undoAddElement(tie);</a>
<a name="ln1186">                                          }</a>
<a name="ln1187">                                    if (tieFor[i]) {</a>
<a name="ln1188">                                          tie = new Tie(this);</a>
<a name="ln1189">                                          tie-&gt;setStartNote(nn);</a>
<a name="ln1190">                                          tie-&gt;setEndNote(tieFor[i]);</a>
<a name="ln1191">                                          tie-&gt;setTrack(track);</a>
<a name="ln1192">                                          n-&gt;setTieFor(tie);</a>
<a name="ln1193">                                          tieFor[i]-&gt;setTieBack(tie);</a>
<a name="ln1194">                                          undoAddElement(tie);</a>
<a name="ln1195">                                          }</a>
<a name="ln1196">                                    }</a>
<a name="ln1197">                              if (tie) // at least one tie was created</a>
<a name="ln1198">                                    connectTies();</a>
<a name="ln1199">                              }</a>
<a name="ln1200">                        }</a>
<a name="ln1201">                  }</a>
<a name="ln1202">            }</a>
<a name="ln1203">      // now put the input state back where it was before</a>
<a name="ln1204">      _is.setSegment(inputSegment);</a>
<a name="ln1205">      }</a>
<a name="ln1206"> </a>
<a name="ln1207">//---------------------------------------------------------</a>
<a name="ln1208">//   cmdTieNoteList</a>
<a name="ln1209">//---------------------------------------------------------</a>
<a name="ln1210"> </a>
<a name="ln1211">std::vector&lt;Note*&gt; Score::cmdTieNoteList(const Selection&amp; selection, bool noteEntryMode)</a>
<a name="ln1212">      {</a>
<a name="ln1213">      Element* el = selection.element();</a>
<a name="ln1214">      if (Note* n = InputState::note(el)) {</a>
<a name="ln1215">            if (noteEntryMode)</a>
<a name="ln1216">                  return n-&gt;chord()-&gt;notes();</a>
<a name="ln1217">            else</a>
<a name="ln1218">                  return { n };</a>
<a name="ln1219">            }</a>
<a name="ln1220">      else {</a>
<a name="ln1221">            ChordRest* cr = InputState::chordRest(el);</a>
<a name="ln1222">            if (cr &amp;&amp; cr-&gt;isChord())</a>
<a name="ln1223">                  return toChord(cr)-&gt;notes();</a>
<a name="ln1224">            }</a>
<a name="ln1225">      return selection.noteList();</a>
<a name="ln1226">      }</a>
<a name="ln1227"> </a>
<a name="ln1228">//---------------------------------------------------------</a>
<a name="ln1229">//   cmdAddTie</a>
<a name="ln1230">//---------------------------------------------------------</a>
<a name="ln1231"> </a>
<a name="ln1232">void Score::cmdAddTie(bool addToChord)</a>
<a name="ln1233">      {</a>
<a name="ln1234">      const std::vector&lt;Note*&gt; noteList = cmdTieNoteList(selection(), noteEntryMode());</a>
<a name="ln1235"> </a>
<a name="ln1236">      if (noteList.empty()) {</a>
<a name="ln1237">            qDebug(&quot;no notes selected&quot;);</a>
<a name="ln1238">            return;</a>
<a name="ln1239">            }</a>
<a name="ln1240"> </a>
<a name="ln1241">      startCmd();</a>
<a name="ln1242">      Chord* lastAddedChord = 0;</a>
<a name="ln1243">      for (Note* note : noteList) {</a>
<a name="ln1244">            if (note-&gt;tieFor()) {</a>
<a name="ln1245">                  qDebug(&quot;cmdAddTie: note %p has already tie? noteFor: %p&quot;, note, note-&gt;tieFor());</a>
<a name="ln1246">                  continue;</a>
<a name="ln1247">                  }</a>
<a name="ln1248"> </a>
<a name="ln1249">            if (noteEntryMode()) {</a>
<a name="ln1250">                  ChordRest* cr = nullptr;</a>
<a name="ln1251">                  Chord* c = note-&gt;chord();</a>
<a name="ln1252"> </a>
<a name="ln1253">                  // set cursor at position after note</a>
<a name="ln1254">                  if (c-&gt;isGraceBefore()) {</a>
<a name="ln1255">                        // tie grace note before to main note</a>
<a name="ln1256">                        cr = toChord(c-&gt;parent());</a>
<a name="ln1257">                        addToChord = true;</a>
<a name="ln1258">                        }</a>
<a name="ln1259">                  else {</a>
<a name="ln1260">                        _is.setSegment(note-&gt;chord()-&gt;segment());</a>
<a name="ln1261">                        _is.moveToNextInputPos();</a>
<a name="ln1262">                        _is.setLastSegment(_is.segment());</a>
<a name="ln1263"> </a>
<a name="ln1264">                        if (_is.cr() == 0)</a>
<a name="ln1265">                              expandVoice();</a>
<a name="ln1266">                        cr = _is.cr();</a>
<a name="ln1267">                        }</a>
<a name="ln1268">                  if (cr == 0)</a>
<a name="ln1269">                        break;</a>
<a name="ln1270"> </a>
<a name="ln1271">                  bool addFlag = lastAddedChord != nullptr;</a>
<a name="ln1272"> </a>
<a name="ln1273">                  // try to re-use existing note or chord</a>
<a name="ln1274">                  Note* n = nullptr;</a>
<a name="ln1275">                  if (addToChord &amp;&amp; cr-&gt;isChord()) {</a>
<a name="ln1276">                        Chord* chord = toChord(cr);</a>
<a name="ln1277">                        Note* nn = chord-&gt;findNote(note-&gt;pitch());</a>
<a name="ln1278">                        if (nn &amp;&amp; nn-&gt;tpc() == note-&gt;tpc())</a>
<a name="ln1279">                              n = nn;           // re-use note</a>
<a name="ln1280">                        else</a>
<a name="ln1281">                              addFlag = true;   // re-use chord</a>
<a name="ln1282">                        }</a>
<a name="ln1283"> </a>
<a name="ln1284">                  // if no note to re-use, create one</a>
<a name="ln1285">                  NoteVal nval(note-&gt;noteVal());</a>
<a name="ln1286">                  if (!n)</a>
<a name="ln1287">                        n = addPitch(nval, addFlag);</a>
<a name="ln1288">                  else</a>
<a name="ln1289">                        select(n);</a>
<a name="ln1290"> </a>
<a name="ln1291">                  if (n) {</a>
<a name="ln1292">                        if (!lastAddedChord)</a>
<a name="ln1293">                              lastAddedChord = n-&gt;chord();</a>
<a name="ln1294">                        // n is not necessarily next note if duration span over measure</a>
<a name="ln1295">                        Note* nnote = searchTieNote(note);</a>
<a name="ln1296">                        while (nnote) {</a>
<a name="ln1297">                              // DEBUG: if duration spans over measure</a>
<a name="ln1298">                              // this does not set line for intermediate notes</a>
<a name="ln1299">                              // tpc was set correctly already</a>
<a name="ln1300">                              //n-&gt;setLine(note-&gt;line());</a>
<a name="ln1301">                              //n-&gt;setTpc(note-&gt;tpc());</a>
<a name="ln1302">                              Tie* tie = new Tie(this);</a>
<a name="ln1303">                              tie-&gt;setStartNote(note);</a>
<a name="ln1304">                              tie-&gt;setEndNote(nnote);</a>
<a name="ln1305">                              tie-&gt;setTrack(note-&gt;track());</a>
<a name="ln1306">tie-&gt;setTick(note-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln1307">tie-&gt;setTicks(nnote-&gt;chord()-&gt;segment()-&gt;tick() - note-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln1308">                              undoAddElement(tie);</a>
<a name="ln1309">                              if (!addFlag || nnote-&gt;chord()-&gt;tick() &gt;= lastAddedChord-&gt;tick() || nnote-&gt;chord()-&gt;isGrace()) {</a>
<a name="ln1310">                                    break;</a>
<a name="ln1311">                                    }</a>
<a name="ln1312">                              else {</a>
<a name="ln1313">                                    note = nnote;</a>
<a name="ln1314">                                    _is.setLastSegment(_is.segment());</a>
<a name="ln1315">                                    nnote = addPitch(nval, true);</a>
<a name="ln1316">                                    }</a>
<a name="ln1317">                              }</a>
<a name="ln1318">                        }</a>
<a name="ln1319">                  }</a>
<a name="ln1320">            else {</a>
<a name="ln1321">                  Note* note2 = searchTieNote(note);</a>
<a name="ln1322">                  if (note2) {</a>
<a name="ln1323">                        Tie* tie = new Tie(this);</a>
<a name="ln1324">                        tie-&gt;setStartNote(note);</a>
<a name="ln1325">                        tie-&gt;setEndNote(note2);</a>
<a name="ln1326">                        tie-&gt;setTrack(note-&gt;track());</a>
<a name="ln1327">tie-&gt;setTick(note-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln1328">tie-&gt;setTicks(note2-&gt;chord()-&gt;segment()-&gt;tick() - note-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln1329">                        undoAddElement(tie);</a>
<a name="ln1330">                        }</a>
<a name="ln1331">                  }</a>
<a name="ln1332">            }</a>
<a name="ln1333">      if (lastAddedChord)</a>
<a name="ln1334">            nextInputPos(lastAddedChord, false);</a>
<a name="ln1335">      endCmd();</a>
<a name="ln1336">      }</a>
<a name="ln1337"> </a>
<a name="ln1338">//---------------------------------------------------------</a>
<a name="ln1339">//   cmdRemoveTie</a>
<a name="ln1340">//---------------------------------------------------------</a>
<a name="ln1341"> </a>
<a name="ln1342">void Score::cmdToggleTie()</a>
<a name="ln1343">      {</a>
<a name="ln1344">      const std::vector&lt;Note*&gt; noteList = cmdTieNoteList(selection(), noteEntryMode());</a>
<a name="ln1345"> </a>
<a name="ln1346">      if (noteList.empty()) {</a>
<a name="ln1347">            qDebug(&quot;no notes selected&quot;);</a>
<a name="ln1348">            return;</a>
<a name="ln1349">            }</a>
<a name="ln1350"> </a>
<a name="ln1351">      bool canAddTies = false;</a>
<a name="ln1352">      const size_t notes = noteList.size();</a>
<a name="ln1353">      std::vector&lt;Note*&gt; tieNoteList(notes);</a>
<a name="ln1354"> </a>
<a name="ln1355">      for (size_t i = 0; i &lt; notes; ++i) {</a>
<a name="ln1356">            Note* n = noteList[i];</a>
<a name="ln1357">            if (n-&gt;tieFor()) {</a>
<a name="ln1358">                  tieNoteList[i] = nullptr;</a>
<a name="ln1359">                  }</a>
<a name="ln1360">            else {</a>
<a name="ln1361">                  Note* tieNote = searchTieNote(n);</a>
<a name="ln1362">                  tieNoteList[i] = tieNote;</a>
<a name="ln1363">                  if (tieNote)</a>
<a name="ln1364">                        canAddTies = true;</a>
<a name="ln1365">                  }</a>
<a name="ln1366">            }</a>
<a name="ln1367"> </a>
<a name="ln1368">      startCmd();</a>
<a name="ln1369"> </a>
<a name="ln1370">      if (canAddTies) {</a>
<a name="ln1371">            for (size_t i = 0; i &lt; notes; ++i) {</a>
<a name="ln1372">                  Note* note2 = tieNoteList[i];</a>
<a name="ln1373">                  if (note2) {</a>
<a name="ln1374">                        Note* note = noteList[i];</a>
<a name="ln1375"> </a>
<a name="ln1376">                        Tie* tie = new Tie(this);</a>
<a name="ln1377">                        tie-&gt;setStartNote(note);</a>
<a name="ln1378">                        tie-&gt;setEndNote(note2);</a>
<a name="ln1379">                        tie-&gt;setTrack(note-&gt;track());</a>
<a name="ln1380">                        tie-&gt;setTick(note-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln1381">                        tie-&gt;setTicks(note2-&gt;chord()-&gt;segment()-&gt;tick() - note-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln1382">                        undoAddElement(tie);</a>
<a name="ln1383">                        }</a>
<a name="ln1384">                  }</a>
<a name="ln1385">            }</a>
<a name="ln1386">      else {</a>
<a name="ln1387">            for (Note* n : noteList) {</a>
<a name="ln1388">                  Tie* tie = n-&gt;tieFor();</a>
<a name="ln1389">                  if (tie)</a>
<a name="ln1390">                        undoRemoveElement(tie);</a>
<a name="ln1391">                  }</a>
<a name="ln1392">            }</a>
<a name="ln1393"> </a>
<a name="ln1394">      endCmd();</a>
<a name="ln1395">      }</a>
<a name="ln1396"> </a>
<a name="ln1397"> </a>
<a name="ln1398">//---------------------------------------------------------</a>
<a name="ln1399">//   cmdAddOttava</a>
<a name="ln1400">//---------------------------------------------------------</a>
<a name="ln1401"> </a>
<a name="ln1402">void Score::cmdAddOttava(OttavaType type)</a>
<a name="ln1403">      {</a>
<a name="ln1404">      const Selection sel = selection(); // copy selection state before the operation.</a>
<a name="ln1405">      // add on each staff if possible</a>
<a name="ln1406">      if (sel.isRange() &amp;&amp; sel.staffStart() != sel.staffEnd() - 1) {</a>
<a name="ln1407">            for (int staffIdx = sel.staffStart() ; staffIdx &lt; sel.staffEnd(); ++staffIdx) {</a>
<a name="ln1408">                  ChordRest* cr1 = sel.firstChordRest(staffIdx * VOICES);</a>
<a name="ln1409">                  ChordRest* cr2 = sel.lastChordRest(staffIdx * VOICES);</a>
<a name="ln1410">                  if (!cr1)</a>
<a name="ln1411">                       continue;</a>
<a name="ln1412">                  if (cr2 == 0)</a>
<a name="ln1413">                       cr2 = cr1;</a>
<a name="ln1414">                  Ottava* ottava = new Ottava(this);</a>
<a name="ln1415">                  ottava-&gt;setOttavaType(type);</a>
<a name="ln1416">                  ottava-&gt;setTrack(cr1-&gt;track());</a>
<a name="ln1417">                  ottava-&gt;setTrack2(cr1-&gt;track());</a>
<a name="ln1418">                  ottava-&gt;setTick(cr1-&gt;tick());</a>
<a name="ln1419">                  ottava-&gt;setTick2(cr2-&gt;tick() + cr2-&gt;actualTicks());</a>
<a name="ln1420">                  undoAddElement(ottava);</a>
<a name="ln1421">                  }</a>
<a name="ln1422">            }</a>
<a name="ln1423">      else {</a>
<a name="ln1424">            ChordRest* cr1;</a>
<a name="ln1425">            ChordRest* cr2;</a>
<a name="ln1426">            getSelectedChordRest2(&amp;cr1, &amp;cr2);</a>
<a name="ln1427">            if (!cr1)</a>
<a name="ln1428">                  return;</a>
<a name="ln1429">            if (cr2 == 0)</a>
<a name="ln1430">                  cr2 = cr1;</a>
<a name="ln1431"> </a>
<a name="ln1432">            Ottava* ottava = new Ottava(this);</a>
<a name="ln1433">            ottava-&gt;setOttavaType(type);</a>
<a name="ln1434"> </a>
<a name="ln1435">            ottava-&gt;setTrack(cr1-&gt;track());</a>
<a name="ln1436">            ottava-&gt;setTrack2(cr1-&gt;track());</a>
<a name="ln1437">            ottava-&gt;setTick(cr1-&gt;tick());</a>
<a name="ln1438">            ottava-&gt;setTick2(cr2-&gt;tick() + cr2-&gt;actualTicks());</a>
<a name="ln1439">            undoAddElement(ottava);</a>
<a name="ln1440">            if (!noteEntryMode())</a>
<a name="ln1441">                  select(ottava, SelectType::SINGLE, 0);</a>
<a name="ln1442">            }</a>
<a name="ln1443">      }</a>
<a name="ln1444"> </a>
<a name="ln1445">//---------------------------------------------------------</a>
<a name="ln1446">//   cmdSetBeamMode</a>
<a name="ln1447">//---------------------------------------------------------</a>
<a name="ln1448"> </a>
<a name="ln1449">void Score::cmdSetBeamMode(Beam::Mode mode)</a>
<a name="ln1450">      {</a>
<a name="ln1451">      for (ChordRest* cr : getSelectedChordRests()) {</a>
<a name="ln1452">            if (cr)</a>
<a name="ln1453">                  cr-&gt;undoChangeProperty(Pid::BEAM_MODE, int(mode));</a>
<a name="ln1454">            }</a>
<a name="ln1455">      }</a>
<a name="ln1456"> </a>
<a name="ln1457">//---------------------------------------------------------</a>
<a name="ln1458">//   cmdFlip</a>
<a name="ln1459">//---------------------------------------------------------</a>
<a name="ln1460"> </a>
<a name="ln1461">void Score::cmdFlip()</a>
<a name="ln1462">      {</a>
<a name="ln1463">      const QList&lt;Element*&gt;&amp; el = selection().elements();</a>
<a name="ln1464">      if (el.empty()) {</a>
<a name="ln1465">            MScore::setError(NO_FLIPPABLE_SELECTED);</a>
<a name="ln1466">            return;</a>
<a name="ln1467">            }</a>
<a name="ln1468"> </a>
<a name="ln1469">      std::set&lt;const Element*&gt; alreadyFlippedElements;</a>
<a name="ln1470">      auto flipOnce = [&amp;alreadyFlippedElements](const Element* element, std::function&lt;void()&gt; flipFunction) -&gt; void {</a>
<a name="ln1471">            if (alreadyFlippedElements.count(element) == 0) {</a>
<a name="ln1472">                  alreadyFlippedElements.insert(element);</a>
<a name="ln1473">                  flipFunction();</a>
<a name="ln1474">                  }</a>
<a name="ln1475">            };</a>
<a name="ln1476">      for (Element* e : el) {</a>
<a name="ln1477">            if (e-&gt;isNote() || e-&gt;isStem() || e-&gt;isHook()) {</a>
<a name="ln1478">                  Chord* chord = nullptr;</a>
<a name="ln1479">                  if (e-&gt;isNote()) {</a>
<a name="ln1480">                        auto note = toNote(e);</a>
<a name="ln1481">                        chord = note-&gt;chord();</a>
<a name="ln1482">                        }</a>
<a name="ln1483">                  else if (e-&gt;isStem())</a>
<a name="ln1484">                        chord = toStem(e)-&gt;chord();</a>
<a name="ln1485">                  else</a>
<a name="ln1486">                        chord = toHook(e)-&gt;chord();</a>
<a name="ln1487"> </a>
<a name="ln1488">                  if (chord-&gt;beam()) {</a>
<a name="ln1489">                        if (!selection().isRange())</a>
<a name="ln1490">                              e = chord-&gt;beam();</a>
<a name="ln1491">                        else</a>
<a name="ln1492">                              continue;</a>
<a name="ln1493">                        }</a>
<a name="ln1494">                  else {</a>
<a name="ln1495">                        flipOnce(chord, [chord](){</a>
<a name="ln1496">                              Direction dir = chord-&gt;up() ? Direction::DOWN : Direction::UP;</a>
<a name="ln1497">                              chord-&gt;undoChangeProperty(Pid::STEM_DIRECTION, QVariant::fromValue&lt;Direction&gt;(dir));</a>
<a name="ln1498">                              });</a>
<a name="ln1499">                        }</a>
<a name="ln1500">                  }</a>
<a name="ln1501"> </a>
<a name="ln1502">            if (e-&gt;isBeam()) {</a>
<a name="ln1503">                  auto beam = toBeam(e);</a>
<a name="ln1504">                  flipOnce(beam, [beam](){</a>
<a name="ln1505">                        Direction dir = beam-&gt;up() ? Direction::DOWN : Direction::UP;</a>
<a name="ln1506">                        beam-&gt;undoChangeProperty(Pid::STEM_DIRECTION, QVariant::fromValue&lt;Direction&gt;(dir));</a>
<a name="ln1507">                        });</a>
<a name="ln1508">                  }</a>
<a name="ln1509">            else if (e-&gt;isSlurTieSegment()) {</a>
<a name="ln1510">                  auto slurTieSegment = toSlurTieSegment(e)-&gt;slurTie();</a>
<a name="ln1511">                  flipOnce(slurTieSegment, [slurTieSegment](){</a>
<a name="ln1512">                        Direction dir = slurTieSegment-&gt;up() ? Direction::DOWN : Direction::UP;</a>
<a name="ln1513">                        slurTieSegment-&gt;undoChangeProperty(Pid::SLUR_DIRECTION, QVariant::fromValue&lt;Direction&gt;(dir));</a>
<a name="ln1514">                        });</a>
<a name="ln1515">                  }</a>
<a name="ln1516">            else if (e-&gt;isArticulation()) {</a>
<a name="ln1517">                  auto articulation = toArticulation(e);</a>
<a name="ln1518">                  flipOnce(articulation, [articulation](){</a>
<a name="ln1519">                        ArticulationAnchor articAnchor = articulation-&gt;anchor();</a>
<a name="ln1520">                        switch (articAnchor) {</a>
<a name="ln1521">                              case ArticulationAnchor::TOP_CHORD:</a>
<a name="ln1522">                                    articAnchor = ArticulationAnchor::BOTTOM_CHORD;</a>
<a name="ln1523">                                    break;</a>
<a name="ln1524">                              case ArticulationAnchor::BOTTOM_CHORD:</a>
<a name="ln1525">                                    articAnchor = ArticulationAnchor::TOP_CHORD;</a>
<a name="ln1526">                                    break;</a>
<a name="ln1527">                              case ArticulationAnchor::CHORD:</a>
<a name="ln1528">                                    articAnchor = articulation-&gt;up() ? ArticulationAnchor::BOTTOM_CHORD : ArticulationAnchor::TOP_CHORD;</a>
<a name="ln1529">                                    break;</a>
<a name="ln1530">                              case ArticulationAnchor::TOP_STAFF:</a>
<a name="ln1531">                                    articAnchor = ArticulationAnchor::BOTTOM_STAFF;</a>
<a name="ln1532">                                    break;</a>
<a name="ln1533">                              case ArticulationAnchor::BOTTOM_STAFF:</a>
<a name="ln1534">                                    articAnchor = ArticulationAnchor::TOP_STAFF;</a>
<a name="ln1535">                                    break;</a>
<a name="ln1536">                              }</a>
<a name="ln1537">                        PropertyFlags pf = articulation-&gt;propertyFlags(Pid::ARTICULATION_ANCHOR);</a>
<a name="ln1538">                        if (pf == PropertyFlags::STYLED)</a>
<a name="ln1539">                                pf = PropertyFlags::UNSTYLED;</a>
<a name="ln1540">                        articulation-&gt;undoChangeProperty(Pid::ARTICULATION_ANCHOR, int(articAnchor), pf);</a>
<a name="ln1541">                        });</a>
<a name="ln1542">                  }</a>
<a name="ln1543">            else if (e-&gt;isTuplet()) {</a>
<a name="ln1544">                  auto tuplet = toTuplet(e);</a>
<a name="ln1545">                  flipOnce(tuplet, [tuplet](){</a>
<a name="ln1546">                        Direction dir = tuplet-&gt;isUp() ? Direction::DOWN : Direction::UP;</a>
<a name="ln1547">                        tuplet-&gt;undoChangeProperty(Pid::DIRECTION, QVariant::fromValue&lt;Direction&gt;(dir), PropertyFlags::UNSTYLED);</a>
<a name="ln1548">                        });</a>
<a name="ln1549">                  }</a>
<a name="ln1550">            else if (e-&gt;isNoteDot() &amp;&amp; e-&gt;parent()-&gt;isNote()) {</a>
<a name="ln1551">                  Note* note = toNote(e-&gt;parent());</a>
<a name="ln1552">                  Direction d = note-&gt;dotIsUp() ? Direction::DOWN : Direction::UP;</a>
<a name="ln1553">                  note-&gt;undoChangeProperty(Pid::DOT_POSITION, QVariant::fromValue&lt;Direction&gt;(d));</a>
<a name="ln1554">                  }</a>
<a name="ln1555">            else if (e-&gt;isTempoText()</a>
<a name="ln1556">               || e-&gt;isSystemText()</a>
<a name="ln1557">               || e-&gt;isJump()</a>
<a name="ln1558">               || e-&gt;isMarker()</a>
<a name="ln1559">               || e-&gt;isStaffText()</a>
<a name="ln1560">               || e-&gt;isSticking()</a>
<a name="ln1561">               || e-&gt;isFingering()</a>
<a name="ln1562">               || e-&gt;isDynamic()</a>
<a name="ln1563">               || e-&gt;isHarmony()</a>
<a name="ln1564">               || e-&gt;isInstrumentChange()</a>
<a name="ln1565">               || e-&gt;isRehearsalMark()</a>
<a name="ln1566">               || e-&gt;isFretDiagram()</a>
<a name="ln1567">               || e-&gt;isHairpin()</a>
<a name="ln1568">               || e-&gt;isHairpinSegment()</a>
<a name="ln1569">               || e-&gt;isOttavaSegment()</a>
<a name="ln1570">               || e-&gt;isTextLineSegment()</a>
<a name="ln1571">               || e-&gt;isPedalSegment()</a>
<a name="ln1572">               || e-&gt;isLetRingSegment()</a>
<a name="ln1573">               || e-&gt;isPalmMuteSegment()</a>
<a name="ln1574">               || e-&gt;isFermata()</a>
<a name="ln1575">               || e-&gt;isLyrics()</a>
<a name="ln1576">               || e-&gt;isTrillSegment()) {</a>
<a name="ln1577">                  e-&gt;undoChangeProperty(Pid::AUTOPLACE, true);</a>
<a name="ln1578">                  // getProperty() delegates call from spannerSegment to Spanner</a>
<a name="ln1579">                  Placement p = Placement(e-&gt;getProperty(Pid::PLACEMENT).toInt());</a>
<a name="ln1580">                  p = (p == Placement::ABOVE) ? Placement::BELOW : Placement::ABOVE;</a>
<a name="ln1581">                  // TODO: undoChangeProperty() should probably do this directly</a>
<a name="ln1582">                  // see https://musescore.org/en/node/281432</a>
<a name="ln1583">                  Element* ee = e-&gt;propertyDelegate(Pid::PLACEMENT);</a>
<a name="ln1584">                  if (!ee)</a>
<a name="ln1585">                        ee = e;</a>
<a name="ln1586">                  PropertyFlags pf = ee-&gt;propertyFlags(Pid::PLACEMENT);</a>
<a name="ln1587">                  if (pf == PropertyFlags::STYLED)</a>
<a name="ln1588">                        pf = PropertyFlags::UNSTYLED;</a>
<a name="ln1589">                  qreal oldDefaultY = ee-&gt;propertyDefault(Pid::OFFSET).toPointF().y();</a>
<a name="ln1590">                  ee-&gt;undoChangeProperty(Pid::PLACEMENT, int(p), pf);</a>
<a name="ln1591">                  // flip and rebase user offset to new default now that placement has changed</a>
<a name="ln1592">                  qreal newDefaultY = ee-&gt;propertyDefault(Pid::OFFSET).toPointF().y();</a>
<a name="ln1593">                  if (ee-&gt;isSpanner()) {</a>
<a name="ln1594">                        Spanner* spanner = toSpanner(ee);</a>
<a name="ln1595">                        for (SpannerSegment* ss : spanner-&gt;spannerSegments()) {</a>
<a name="ln1596">                              if (!ss-&gt;isStyled(Pid::OFFSET)) {</a>
<a name="ln1597">                                    QPointF off = ss-&gt;getProperty(Pid::OFFSET).toPointF();</a>
<a name="ln1598">                                    qreal oldY = off.y() - oldDefaultY;</a>
<a name="ln1599">                                    off.ry() = newDefaultY - oldY;</a>
<a name="ln1600">                                    ss-&gt;undoChangeProperty(Pid::OFFSET, off);</a>
<a name="ln1601">                                    ss-&gt;setOffsetChanged(false);</a>
<a name="ln1602">                                    }</a>
<a name="ln1603">                              }</a>
<a name="ln1604">                        }</a>
<a name="ln1605">                  else if (!ee-&gt;isStyled(Pid::OFFSET)) {</a>
<a name="ln1606">                        QPointF off = ee-&gt;getProperty(Pid::OFFSET).toPointF();</a>
<a name="ln1607">                        qreal oldY = off.y() - oldDefaultY;</a>
<a name="ln1608">                        off.ry() = newDefaultY - oldY;</a>
<a name="ln1609">                        ee-&gt;undoChangeProperty(Pid::OFFSET, off);</a>
<a name="ln1610">                        ee-&gt;setOffsetChanged(false);</a>
<a name="ln1611">                        }</a>
<a name="ln1612">                  }</a>
<a name="ln1613">            }</a>
<a name="ln1614">      }</a>
<a name="ln1615"> </a>
<a name="ln1616">//---------------------------------------------------------</a>
<a name="ln1617">//   deleteItem</a>
<a name="ln1618">//---------------------------------------------------------</a>
<a name="ln1619"> </a>
<a name="ln1620">void Score::deleteItem(Element* el)</a>
<a name="ln1621">      {</a>
<a name="ln1622">      if (!el)</a>
<a name="ln1623">            return;</a>
<a name="ln1624">      // cannot remove generated elements</a>
<a name="ln1625">      if (el-&gt;generated() &amp;&amp; !(el-&gt;isBracket() || el-&gt;isBarLine() || el-&gt;isClef()))</a>
<a name="ln1626">            return;</a>
<a name="ln1627">//      qDebug(&quot;%s&quot;, el-&gt;name());</a>
<a name="ln1628"> </a>
<a name="ln1629">      switch (el-&gt;type()) {</a>
<a name="ln1630">            case ElementType::INSTRUMENT_NAME: {</a>
<a name="ln1631">                  Part* part = el-&gt;part();</a>
<a name="ln1632">                  InstrumentName* in = toInstrumentName(el);</a>
<a name="ln1633">                  if (in-&gt;instrumentNameType() == InstrumentNameType::LONG)</a>
<a name="ln1634">                        undo(new ChangeInstrumentLong(Fraction(0,1), part, QList&lt;StaffName&gt;()));</a>
<a name="ln1635">                  else if (in-&gt;instrumentNameType() == InstrumentNameType::SHORT)</a>
<a name="ln1636">                        undo(new ChangeInstrumentShort(Fraction(0,1), part, QList&lt;StaffName&gt;()));</a>
<a name="ln1637">                  }</a>
<a name="ln1638">                  break;</a>
<a name="ln1639"> </a>
<a name="ln1640">            case ElementType::TIMESIG: {</a>
<a name="ln1641">                  // timesig might already be removed</a>
<a name="ln1642">                  TimeSig* ts = toTimeSig(el);</a>
<a name="ln1643">                  Segment* s = ts-&gt;segment();</a>
<a name="ln1644">                  Measure* m = s-&gt;measure();</a>
<a name="ln1645">                  Segment* ns = m-&gt;findSegment(s-&gt;segmentType(), s-&gt;tick());</a>
<a name="ln1646">                  if (!ns || (ns-&gt;element(ts-&gt;track()) != ts)) {</a>
<a name="ln1647">                        qDebug(&quot;deleteItem: not found&quot;);</a>
<a name="ln1648">                        break;</a>
<a name="ln1649">                        }</a>
<a name="ln1650">                  cmdRemoveTimeSig(ts);</a>
<a name="ln1651">                  }</a>
<a name="ln1652">                  break;</a>
<a name="ln1653"> </a>
<a name="ln1654">            case ElementType::KEYSIG:</a>
<a name="ln1655">                  undoRemoveElement(el);</a>
<a name="ln1656">                  break;</a>
<a name="ln1657"> </a>
<a name="ln1658">            case ElementType::NOTE:</a>
<a name="ln1659">                  {</a>
<a name="ln1660">                  Chord* chord = toChord(el-&gt;parent());</a>
<a name="ln1661">                  if (chord-&gt;notes().size() &gt; 1) {</a>
<a name="ln1662">                        undoRemoveElement(el);</a>
<a name="ln1663">                        select(chord-&gt;downNote(), SelectType::SINGLE, 0);</a>
<a name="ln1664">                        break;</a>
<a name="ln1665">                        }</a>
<a name="ln1666">                  // else fall through</a>
<a name="ln1667">                  el = chord;</a>
<a name="ln1668">                  }</a>
<a name="ln1669">                  // fall through</a>
<a name="ln1670"> </a>
<a name="ln1671">            case ElementType::CHORD:</a>
<a name="ln1672">                  {</a>
<a name="ln1673">                  Chord* chord = toChord(el);</a>
<a name="ln1674">                  removeChordRest(chord, false);</a>
<a name="ln1675"> </a>
<a name="ln1676">                  // replace with rest</a>
<a name="ln1677">                  if (chord-&gt;noteType() == NoteType::NORMAL) {</a>
<a name="ln1678">                        Rest* rest = new Rest(this, chord-&gt;durationType());</a>
<a name="ln1679">                        rest-&gt;setDurationType(chord-&gt;durationType());</a>
<a name="ln1680">                        rest-&gt;setTicks(chord-&gt;ticks());</a>
<a name="ln1681"> </a>
<a name="ln1682">                        rest-&gt;setTrack(el-&gt;track());</a>
<a name="ln1683">                        rest-&gt;setParent(chord-&gt;parent());</a>
<a name="ln1684"> </a>
<a name="ln1685">                        Segment* segment = chord-&gt;segment();</a>
<a name="ln1686">                        undoAddCR(rest, segment-&gt;measure(), segment-&gt;tick());</a>
<a name="ln1687"> </a>
<a name="ln1688">                        Tuplet* tuplet = chord-&gt;tuplet();</a>
<a name="ln1689">                        if (tuplet) {</a>
<a name="ln1690">                              QList&lt;ScoreElement*&gt; tl = tuplet-&gt;linkList();</a>
<a name="ln1691">                              for (ScoreElement* e : rest-&gt;linkList()) {</a>
<a name="ln1692">                                    DurationElement* de = toDurationElement(e);</a>
<a name="ln1693">                                    for (ScoreElement* ee : tl) {</a>
<a name="ln1694">                                          Tuplet* t = toTuplet(ee);</a>
<a name="ln1695">                                          if (t-&gt;score() == de-&gt;score() &amp;&amp; t-&gt;track() == de-&gt;track()) {</a>
<a name="ln1696">                                                de-&gt;setTuplet(t);</a>
<a name="ln1697">                                                t-&gt;add(de);</a>
<a name="ln1698">                                                break;</a>
<a name="ln1699">                                                }</a>
<a name="ln1700">                                          }</a>
<a name="ln1701">                                    }</a>
<a name="ln1702">                              }</a>
<a name="ln1703">                        //select(rest, SelectType::SINGLE, 0);</a>
<a name="ln1704">                        }</a>
<a name="ln1705">                  else  {</a>
<a name="ln1706">                        // remove segment if empty</a>
<a name="ln1707">                        Segment* seg = chord-&gt;segment();</a>
<a name="ln1708">                        if (seg-&gt;empty())</a>
<a name="ln1709">                              undoRemoveElement(seg);</a>
<a name="ln1710">                        }</a>
<a name="ln1711">                  }</a>
<a name="ln1712">                  break;</a>
<a name="ln1713"> </a>
<a name="ln1714">            case ElementType::REPEAT_MEASURE:</a>
<a name="ln1715">                  {</a>
<a name="ln1716">                  RepeatMeasure* rm = toRepeatMeasure(el);</a>
<a name="ln1717">                  removeChordRest(rm, false);</a>
<a name="ln1718">                  Rest* rest = new Rest(this);</a>
<a name="ln1719">                  rest-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln1720">                  rest-&gt;setTicks(rm-&gt;measure()-&gt;stretchedLen(rm-&gt;staff()));</a>
<a name="ln1721">                  rest-&gt;setTrack(rm-&gt;track());</a>
<a name="ln1722">                  rest-&gt;setParent(rm-&gt;parent());</a>
<a name="ln1723">                  Segment* segment = rm-&gt;segment();</a>
<a name="ln1724">                  undoAddCR(rest, segment-&gt;measure(), segment-&gt;tick());</a>
<a name="ln1725">                  }</a>
<a name="ln1726">                  // fall through</a>
<a name="ln1727"> </a>
<a name="ln1728">            case ElementType::REST:</a>
<a name="ln1729">                  //</a>
<a name="ln1730">                  // only allow for voices != 0</a>
<a name="ln1731">                  //    e.g. voice 0 rests cannot be removed</a>
<a name="ln1732">                  //</a>
<a name="ln1733">                  {</a>
<a name="ln1734">                  Rest* rest = toRest(el);</a>
<a name="ln1735">                  if (rest-&gt;tuplet() &amp;&amp; rest-&gt;tuplet()-&gt;elements().empty())</a>
<a name="ln1736">                        undoRemoveElement(rest-&gt;tuplet());</a>
<a name="ln1737">                  if (el-&gt;voice() != 0) {</a>
<a name="ln1738">                        rest-&gt;undoChangeProperty(Pid::GAP, true);</a>
<a name="ln1739">                        for (ScoreElement* r : el-&gt;linkList()) {</a>
<a name="ln1740">                              Rest* rr = toRest(r);</a>
<a name="ln1741">                              if (rr-&gt;track() % VOICES)</a>
<a name="ln1742">                                    rr-&gt;undoChangeProperty(Pid::GAP, true);</a>
<a name="ln1743">                              }</a>
<a name="ln1744"> </a>
<a name="ln1745">                        // delete them really when only gap rests are in the actual measure.</a>
<a name="ln1746">                        Measure* m = toRest(el)-&gt;measure();</a>
<a name="ln1747">                        int track = el-&gt;track();</a>
<a name="ln1748">                        if (m-&gt;isOnlyDeletedRests(track)) {</a>
<a name="ln1749">                              static const SegmentType st { SegmentType::ChordRest };</a>
<a name="ln1750">                              for (const Segment* s = m-&gt;first(st); s; s = s-&gt;next(st)) {</a>
<a name="ln1751">                                    Element* del = s-&gt;element(track);</a>
<a name="ln1752">                                    if (s-&gt;segmentType() != st || !del)</a>
<a name="ln1753">                                          continue;</a>
<a name="ln1754">                                    if (toRest(del)-&gt;isGap())</a>
<a name="ln1755">                                          undoRemoveElement(del);</a>
<a name="ln1756">                                    }</a>
<a name="ln1757">                              checkSpanner(m-&gt;tick(), m-&gt;endTick());</a>
<a name="ln1758">                              }</a>
<a name="ln1759">                        else {</a>
<a name="ln1760">                              // check if the other rest could be combined</a>
<a name="ln1761">                              Segment* s = toRest(el)-&gt;segment();</a>
<a name="ln1762"> </a>
<a name="ln1763">                              std::vector&lt;Rest*&gt; rests;</a>
<a name="ln1764">                              // find previous segment with cr in this track</a>
<a name="ln1765">                              Element* pe = 0;</a>
<a name="ln1766">                              for (Segment* ps = s-&gt;prev(SegmentType::ChordRest); ps; ps = ps-&gt;prev(SegmentType::ChordRest)) {</a>
<a name="ln1767">                                    Element* elm = ps-&gt;element(track);</a>
<a name="ln1768">                                    if (elm &amp;&amp; elm-&gt;isRest() &amp;&amp; toRest(elm)-&gt;isGap()) {</a>
<a name="ln1769">                                          pe = el;</a>
<a name="ln1770">                                          rests.push_back(toRest(elm));</a>
<a name="ln1771">                                          }</a>
<a name="ln1772">                                    else if (elm)</a>
<a name="ln1773">                                          break;</a>
<a name="ln1774">                                    }</a>
<a name="ln1775">                              // find next segment with cr in this track</a>
<a name="ln1776">                              Segment* ns;</a>
<a name="ln1777">                              Element* ne = 0;</a>
<a name="ln1778">                              for (ns = s-&gt;next(SegmentType::ChordRest); ns; ns = ns-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln1779">                                    Element* elm = ns-&gt;element(track);</a>
<a name="ln1780">                                    if (elm &amp;&amp; elm-&gt;isRest() &amp;&amp; toRest(elm)-&gt;isGap()) {</a>
<a name="ln1781">                                          ne = elm;</a>
<a name="ln1782">                                          rests.push_back(toRest(elm));</a>
<a name="ln1783">                                          }</a>
<a name="ln1784">                                    else if (elm)</a>
<a name="ln1785">                                          break;</a>
<a name="ln1786">                                    }</a>
<a name="ln1787"> </a>
<a name="ln1788">                              Fraction stick = pe ? pe-&gt;tick() : s-&gt;tick();</a>
<a name="ln1789">                              Fraction ticks = { 0, 1 };</a>
<a name="ln1790"> </a>
<a name="ln1791">                              if (ne)</a>
<a name="ln1792">                                    ticks = ne-&gt;tick() - stick + toRest(ne)-&gt;actualTicks();</a>
<a name="ln1793">                              else if (ns)</a>
<a name="ln1794">                                    ticks = ns-&gt;tick() - stick;</a>
<a name="ln1795">                              else</a>
<a name="ln1796">                                    ticks = m-&gt;ticks() + m-&gt;tick() - stick;</a>
<a name="ln1797"> </a>
<a name="ln1798">                              if (ticks != m-&gt;ticks() &amp;&amp; ticks != s-&gt;ticks()) {</a>
<a name="ln1799">                                    undoRemoveElement(rest);</a>
<a name="ln1800">                                    for (Rest* r : rests) {</a>
<a name="ln1801">                                          undoRemoveElement(r);</a>
<a name="ln1802">                                          }</a>
<a name="ln1803"> </a>
<a name="ln1804">                                    Fraction f = ticks;</a>
<a name="ln1805"> </a>
<a name="ln1806">                                    std::vector&lt;TDuration&gt; dList = toDurationList(f, true);</a>
<a name="ln1807">                                    if (dList.empty())</a>
<a name="ln1808">                                          break;</a>
<a name="ln1809"> </a>
<a name="ln1810">                                    for (const TDuration&amp; d : dList) {</a>
<a name="ln1811">                                          Rest* rr = new Rest(this);</a>
<a name="ln1812">                                          rr-&gt;setTicks(d.fraction());</a>
<a name="ln1813">                                          rr-&gt;setDurationType(d);</a>
<a name="ln1814">                                          rr-&gt;setTrack(track);</a>
<a name="ln1815">                                          rr-&gt;setGap(true);</a>
<a name="ln1816">                                          undoAddCR(rr, m, stick);</a>
<a name="ln1817">                                          }</a>
<a name="ln1818">                                    }</a>
<a name="ln1819">                              }</a>
<a name="ln1820">                        // Set input position</a>
<a name="ln1821">                        // TODO If deleted element is last of a sequence, use prev?</a>
<a name="ln1822">                        if (noteEntryMode())</a>
<a name="ln1823">                              score()-&gt;move(&quot;prev-chord&quot;);</a>
<a name="ln1824">                        }</a>
<a name="ln1825">                  }</a>
<a name="ln1826">                  break;</a>
<a name="ln1827"> </a>
<a name="ln1828">            case ElementType::ACCIDENTAL:</a>
<a name="ln1829">                  if (el-&gt;parent()-&gt;isNote())</a>
<a name="ln1830">                        changeAccidental(toNote(el-&gt;parent()), AccidentalType::NONE);</a>
<a name="ln1831">                  else</a>
<a name="ln1832">                        undoRemoveElement(el);</a>
<a name="ln1833">                  break;</a>
<a name="ln1834"> </a>
<a name="ln1835">            case ElementType::BAR_LINE: {</a>
<a name="ln1836">                  BarLine* bl = toBarLine(el);</a>
<a name="ln1837">                  Segment* s = bl-&gt;segment();</a>
<a name="ln1838">                  Measure* m = s-&gt;measure();</a>
<a name="ln1839">                  if (s-&gt;isBeginBarLineType() || s-&gt;isBarLineType()) {</a>
<a name="ln1840">                        undoRemoveElement(el);</a>
<a name="ln1841">                        }</a>
<a name="ln1842">                  else {</a>
<a name="ln1843">                        if (bl-&gt;barLineType() == BarLineType::START_REPEAT) {</a>
<a name="ln1844">                              Measure* m2 = m-&gt;isMMRest() ? m-&gt;mmRestFirst() : m;</a>
<a name="ln1845">                              for (Score* lscore : score()-&gt;scoreList()) {</a>
<a name="ln1846">                                    Measure* lmeasure = lscore-&gt;tick2measure(m2-&gt;tick());</a>
<a name="ln1847">                                    if (lmeasure)</a>
<a name="ln1848">                                          lmeasure-&gt;undoChangeProperty(Pid::REPEAT_START, false);</a>
<a name="ln1849">                                    }</a>
<a name="ln1850">                              }</a>
<a name="ln1851">                        else if (bl-&gt;barLineType() == BarLineType::END_REPEAT) {</a>
<a name="ln1852">                              Measure* m2 = m-&gt;isMMRest() ? m-&gt;mmRestLast() : m;</a>
<a name="ln1853">                              for (Score* lscore : score()-&gt;scoreList()) {</a>
<a name="ln1854">                                    Measure* lmeasure = lscore-&gt;tick2measure(m2-&gt;tick());</a>
<a name="ln1855">                                    if (lmeasure)</a>
<a name="ln1856">                                          lmeasure-&gt;undoChangeProperty(Pid::REPEAT_END, false);</a>
<a name="ln1857">                                    }</a>
<a name="ln1858">                              }</a>
<a name="ln1859">                        else {</a>
<a name="ln1860">                              bl-&gt;undoChangeProperty(Pid::BARLINE_TYPE, QVariant::fromValue(BarLineType::NORMAL));</a>
<a name="ln1861">                              }</a>
<a name="ln1862">                        }</a>
<a name="ln1863">                  }</a>
<a name="ln1864">                  break;</a>
<a name="ln1865"> </a>
<a name="ln1866">            case ElementType::TUPLET:</a>
<a name="ln1867">                  cmdDeleteTuplet(toTuplet(el), true);</a>
<a name="ln1868">                  break;</a>
<a name="ln1869"> </a>
<a name="ln1870">            case ElementType::MEASURE: {</a>
<a name="ln1871">                  Measure* m = toMeasure(el);</a>
<a name="ln1872">                  undoRemoveMeasures(m, m);</a>
<a name="ln1873">                  undoInsertTime(m-&gt;tick(), -(m-&gt;endTick() - m-&gt;tick()));</a>
<a name="ln1874">                  }</a>
<a name="ln1875">                  break;</a>
<a name="ln1876"> </a>
<a name="ln1877">            case ElementType::BRACKET:</a>
<a name="ln1878">                  undoRemoveBracket(toBracket(el));</a>
<a name="ln1879">                  break;</a>
<a name="ln1880"> </a>
<a name="ln1881">            case ElementType::LAYOUT_BREAK:</a>
<a name="ln1882">                  {</a>
<a name="ln1883">                  undoRemoveElement(el);</a>
<a name="ln1884">                  LayoutBreak* lb = toLayoutBreak(el);</a>
<a name="ln1885">                  Measure* m = lb-&gt;measure();</a>
<a name="ln1886">                  if (m-&gt;isMMRest()) {</a>
<a name="ln1887">                        // propagate to original measure</a>
<a name="ln1888">                        m = m-&gt;mmRestLast();</a>
<a name="ln1889">                        foreach(Element* e, m-&gt;el()) {</a>
<a name="ln1890">                              if (e-&gt;isLayoutBreak()) {</a>
<a name="ln1891">                                    undoRemoveElement(e);</a>
<a name="ln1892">                                    break;</a>
<a name="ln1893">                                    }</a>
<a name="ln1894">                              }</a>
<a name="ln1895">                        }</a>
<a name="ln1896">                  }</a>
<a name="ln1897">                  break;</a>
<a name="ln1898"> </a>
<a name="ln1899">            case ElementType::CLEF:</a>
<a name="ln1900">                  {</a>
<a name="ln1901">                  Clef* clef = toClef(el);</a>
<a name="ln1902">                  Measure* m = clef-&gt;measure();</a>
<a name="ln1903">                  if (m-&gt;isMMRest()) {</a>
<a name="ln1904">                        // propagate to original measure</a>
<a name="ln1905">                        m = m-&gt;mmRestLast();</a>
<a name="ln1906">                        Segment* s = m-&gt;findSegment(SegmentType::Clef, clef-&gt;segment()-&gt;tick());</a>
<a name="ln1907">                        if (s &amp;&amp; s-&gt;element(clef-&gt;track())) {</a>
<a name="ln1908">                              Clef* c = toClef(s-&gt;element(clef-&gt;track()));</a>
<a name="ln1909">                              undoRemoveElement(c);</a>
<a name="ln1910">                              }</a>
<a name="ln1911">                        }</a>
<a name="ln1912">                  else {</a>
<a name="ln1913">                        if (clef-&gt;generated()) {</a>
<a name="ln1914">                              // find the real clef if this is a cautionary one</a>
<a name="ln1915">                              if (m &amp;&amp; m-&gt;prevMeasure()) {</a>
<a name="ln1916">                                    Fraction tick = m-&gt;tick();</a>
<a name="ln1917">                                    m = m-&gt;prevMeasure();</a>
<a name="ln1918">                                    Segment* s = m-&gt;findSegment(SegmentType::Clef, tick);</a>
<a name="ln1919">                                    if (s &amp;&amp; s-&gt;element(clef-&gt;track()))</a>
<a name="ln1920">                                          clef = toClef(s-&gt;element(clef-&gt;track()));</a>
<a name="ln1921">                                    }</a>
<a name="ln1922">                              }</a>
<a name="ln1923">                        undoRemoveElement(clef);</a>
<a name="ln1924">                        }</a>
<a name="ln1925">                  }</a>
<a name="ln1926">                  break;</a>
<a name="ln1927"> </a>
<a name="ln1928">            case ElementType::REHEARSAL_MARK:</a>
<a name="ln1929">            case ElementType::TEMPO_TEXT:</a>
<a name="ln1930">                  {</a>
<a name="ln1931">                  Segment* s = toSegment(el-&gt;parent());</a>
<a name="ln1932">                  Measure* m = s-&gt;measure();</a>
<a name="ln1933">                  if (m-&gt;isMMRest()) {</a>
<a name="ln1934">                        // propagate to original measure/element</a>
<a name="ln1935">                        m = m-&gt;mmRestFirst();</a>
<a name="ln1936">                        Segment* ns = m-&gt;findSegment(SegmentType::ChordRest, s-&gt;tick());</a>
<a name="ln1937">                        for (Element* e : ns-&gt;annotations()) {</a>
<a name="ln1938">                              if (e-&gt;type() == el-&gt;type() &amp;&amp; e-&gt;track() == el-&gt;track()) {</a>
<a name="ln1939">                                    el = e;</a>
<a name="ln1940">                                    undoRemoveElement(el);</a>
<a name="ln1941">                                    break;</a>
<a name="ln1942">                                    }</a>
<a name="ln1943">                              }</a>
<a name="ln1944">                        }</a>
<a name="ln1945">                  else</a>
<a name="ln1946">                        undoRemoveElement(el);</a>
<a name="ln1947">                  }</a>
<a name="ln1948">                  break;</a>
<a name="ln1949"> </a>
<a name="ln1950">            case ElementType::OTTAVA_SEGMENT:</a>
<a name="ln1951">            case ElementType::HAIRPIN_SEGMENT:</a>
<a name="ln1952">            case ElementType::TRILL_SEGMENT:</a>
<a name="ln1953">            case ElementType::VIBRATO_SEGMENT:</a>
<a name="ln1954">            case ElementType::TEXTLINE_SEGMENT:</a>
<a name="ln1955">            case ElementType::VOLTA_SEGMENT:</a>
<a name="ln1956">            case ElementType::SLUR_SEGMENT:</a>
<a name="ln1957">            case ElementType::TIE_SEGMENT:</a>
<a name="ln1958">            case ElementType::LYRICSLINE_SEGMENT:</a>
<a name="ln1959">            case ElementType::PEDAL_SEGMENT:</a>
<a name="ln1960">            case ElementType::GLISSANDO_SEGMENT:</a>
<a name="ln1961">            case ElementType::LET_RING_SEGMENT:</a>
<a name="ln1962">            case ElementType::PALM_MUTE_SEGMENT:</a>
<a name="ln1963">                  {</a>
<a name="ln1964">                  el = toSpannerSegment(el)-&gt;spanner();</a>
<a name="ln1965">                  undoRemoveElement(el);</a>
<a name="ln1966">                  }</a>
<a name="ln1967">                  break;</a>
<a name="ln1968"> </a>
<a name="ln1969">            case ElementType::STEM_SLASH:           // cannot delete this elements</a>
<a name="ln1970">            case ElementType::HOOK:</a>
<a name="ln1971">                  qDebug(&quot;cannot remove %s&quot;, el-&gt;name());</a>
<a name="ln1972">                  break;</a>
<a name="ln1973"> </a>
<a name="ln1974">            case ElementType::TEXT:</a>
<a name="ln1975">                  if (el-&gt;parent()-&gt;isTBox())</a>
<a name="ln1976">                        el-&gt;undoChangeProperty(Pid::TEXT, QString());</a>
<a name="ln1977">                  else</a>
<a name="ln1978">                        undoRemoveElement(el);</a>
<a name="ln1979">                  break;</a>
<a name="ln1980"> </a>
<a name="ln1981">            case ElementType::INSTRUMENT_CHANGE:</a>
<a name="ln1982">                  {</a>
<a name="ln1983">                  InstrumentChange* ic = static_cast&lt;InstrumentChange*&gt;(el);</a>
<a name="ln1984">                  Fraction tickStart = ic-&gt;segment()-&gt;tick();</a>
<a name="ln1985">                  Part* part = ic-&gt;part();</a>
<a name="ln1986">                  Interval oldV = part-&gt;instrument(tickStart)-&gt;transpose();</a>
<a name="ln1987">                  undoRemoveElement(el);</a>
<a name="ln1988">                  if (part-&gt;instrument(tickStart)-&gt;transpose() != oldV) {</a>
<a name="ln1989">                        auto i = part-&gt;instruments()-&gt;upper_bound(tickStart.ticks());</a>
<a name="ln1990">                        Fraction tickEnd;</a>
<a name="ln1991">                        if (i == part-&gt;instruments()-&gt;end())</a>
<a name="ln1992">                              tickEnd = Fraction(-1, 1);</a>
<a name="ln1993">                        else</a>
<a name="ln1994">                              tickEnd = Fraction::fromTicks(i-&gt;first);</a>
<a name="ln1995">                        transpositionChanged(part, oldV, tickStart, tickEnd);</a>
<a name="ln1996">                        }</a>
<a name="ln1997">                  }</a>
<a name="ln1998">                  break;</a>
<a name="ln1999"> </a>
<a name="ln2000">            case ElementType::MARKER:</a>
<a name="ln2001">                  {</a>
<a name="ln2002">                  Measure* m = toMeasure(el-&gt;parent());</a>
<a name="ln2003">                  if (m-&gt;isMMRest()) {</a>
<a name="ln2004">                        // find corresponding marker in underlying measure</a>
<a name="ln2005">                        bool found = false;</a>
<a name="ln2006">                        // the marker may be in the first measure...</a>
<a name="ln2007">                        for (Element* e : m-&gt;mmRestFirst()-&gt;el()) {</a>
<a name="ln2008">                              if (e-&gt;isMarker() &amp;&amp; e-&gt;subtype() == el-&gt;subtype()) {</a>
<a name="ln2009">                                    undoRemoveElement(e);</a>
<a name="ln2010">                                    found = true;</a>
<a name="ln2011">                                    break;</a>
<a name="ln2012">                                    }</a>
<a name="ln2013">                              }</a>
<a name="ln2014">                        if (!found) {</a>
<a name="ln2015">                              // ...or it may be in the last measure</a>
<a name="ln2016">                              for (Element* e : m-&gt;mmRestLast()-&gt;el()) {</a>
<a name="ln2017">                                    if (e-&gt;isMarker() &amp;&amp; e-&gt;subtype() == el-&gt;subtype()) {</a>
<a name="ln2018">                                          undoRemoveElement(e);</a>
<a name="ln2019">                                          break;</a>
<a name="ln2020">                                          }</a>
<a name="ln2021">                                    }</a>
<a name="ln2022">                              }</a>
<a name="ln2023">                        }</a>
<a name="ln2024">                  // whether m is an mmrest or not, we still need to remove el</a>
<a name="ln2025">                  undoRemoveElement(el);</a>
<a name="ln2026">                  }</a>
<a name="ln2027">                  break;</a>
<a name="ln2028"> </a>
<a name="ln2029">            case ElementType::JUMP:</a>
<a name="ln2030">                  {</a>
<a name="ln2031">                  Measure* m = toMeasure(el-&gt;parent());</a>
<a name="ln2032">                  if (m-&gt;isMMRest()) {</a>
<a name="ln2033">                        // find corresponding jump in underlying measure</a>
<a name="ln2034">                        for (Element* e : m-&gt;mmRestLast()-&gt;el()) {</a>
<a name="ln2035">                              if (e-&gt;isJump() &amp;&amp; e-&gt;subtype() == el-&gt;subtype()) {</a>
<a name="ln2036">                                    undoRemoveElement(e);</a>
<a name="ln2037">                                    break;</a>
<a name="ln2038">                                    }</a>
<a name="ln2039">                              }</a>
<a name="ln2040">                        }</a>
<a name="ln2041">                  // whether m is an mmrest or not, we still need to remove el</a>
<a name="ln2042">                  undoRemoveElement(el);</a>
<a name="ln2043">                  }</a>
<a name="ln2044">                  break;</a>
<a name="ln2045"> </a>
<a name="ln2046">            default:</a>
<a name="ln2047">                  undoRemoveElement(el);</a>
<a name="ln2048">                  break;</a>
<a name="ln2049">            }</a>
<a name="ln2050">      }</a>
<a name="ln2051"> </a>
<a name="ln2052">//---------------------------------------------------------</a>
<a name="ln2053">//   deleteMeasures</a>
<a name="ln2054">//---------------------------------------------------------</a>
<a name="ln2055"> </a>
<a name="ln2056">void Score::deleteMeasures(MeasureBase* is, MeasureBase* ie)</a>
<a name="ln2057">      {</a>
<a name="ln2058">// qDebug(&quot;deleteMeasures %p %p&quot;, is, ie);</a>
<a name="ln2059"> </a>
<a name="ln2060">#if 0</a>
<a name="ln2061">      if (!selection().isRange())</a>
<a name="ln2062">            return;</a>
<a name="ln2063"> </a>
<a name="ln2064">      MeasureBase* is = selection().startSegment()-&gt;measure();</a>
<a name="ln2065">      if (is-&gt;isMeasure() &amp;&amp; toMeasure(is)-&gt;isMMRest())</a>
<a name="ln2066">            is = toMeasure(is)-&gt;mmRestFirst();</a>
<a name="ln2067">      Segment* seg    = selection().endSegment();</a>
<a name="ln2068">      MeasureBase* ie;</a>
<a name="ln2069"> </a>
<a name="ln2070">      // choose the correct last measure based on the end segment</a>
<a name="ln2071">      // this depends on whether a whole measure is selected or only a few notes within it</a>
<a name="ln2072">      if (seg)</a>
<a name="ln2073">            ie = seg-&gt;prev() ? seg-&gt;measure() : seg-&gt;measure()-&gt;prev();</a>
<a name="ln2074">      else</a>
<a name="ln2075">            ie = lastMeasure();</a>
<a name="ln2076">#endif</a>
<a name="ln2077"> </a>
<a name="ln2078">      select(0, SelectType::SINGLE, 0);</a>
<a name="ln2079"> </a>
<a name="ln2080">      // createEndBar if last measure is deleted</a>
<a name="ln2081">      bool createEndBar = false;</a>
<a name="ln2082">      if (ie-&gt;isMeasure()) {</a>
<a name="ln2083">            Measure* iem = toMeasure(ie);</a>
<a name="ln2084">            if (iem-&gt;isMMRest())</a>
<a name="ln2085">                  ie = iem = iem-&gt;mmRestLast();</a>
<a name="ln2086">//TODO            createEndBar = (iem == lastMeasureMM()) &amp;&amp; (iem-&gt;endBarLineType() == BarLineType::END);</a>
<a name="ln2087">            createEndBar = false;</a>
<a name="ln2088">            }</a>
<a name="ln2089"> </a>
<a name="ln2090"> </a>
<a name="ln2091">      // get the last deleted timesig &amp; keysig in order to restore after deletion</a>
<a name="ln2092">      KeySigEvent lastDeletedKeySigEvent;</a>
<a name="ln2093">      TimeSig* lastDeletedSig   = 0;</a>
<a name="ln2094">      KeySig* lastDeletedKeySig = 0;</a>
<a name="ln2095">      bool transposeKeySigEvent = false;</a>
<a name="ln2096"> </a>
<a name="ln2097">      for (MeasureBase* mb = ie;; mb = mb-&gt;prev()) {</a>
<a name="ln2098">            if (mb-&gt;isMeasure()) {</a>
<a name="ln2099">                  Measure* m = toMeasure(mb);</a>
<a name="ln2100">                  Segment* sts = m-&gt;findSegment(SegmentType::TimeSig, m-&gt;tick());</a>
<a name="ln2101">                  if (sts &amp;&amp; !lastDeletedSig)</a>
<a name="ln2102">                        lastDeletedSig = toTimeSig(sts-&gt;element(0));</a>
<a name="ln2103">                  sts = m-&gt;findSegment(SegmentType::KeySig, m-&gt;tick());</a>
<a name="ln2104">                  if (sts &amp;&amp; !lastDeletedKeySig) {</a>
<a name="ln2105">                        lastDeletedKeySig = toKeySig(sts-&gt;element(0));</a>
<a name="ln2106">                        if (lastDeletedKeySig) {</a>
<a name="ln2107">                              lastDeletedKeySigEvent = lastDeletedKeySig-&gt;keySigEvent();</a>
<a name="ln2108">                              if (!styleB(Sid::concertPitch) &amp;&amp; !lastDeletedKeySigEvent.isAtonal() &amp;&amp; !lastDeletedKeySigEvent.custom()) {</a>
<a name="ln2109">                                    // convert to concert pitch</a>
<a name="ln2110">                                    transposeKeySigEvent = true;</a>
<a name="ln2111">                                    Interval v = staff(0)-&gt;part()-&gt;instrument(m-&gt;tick())-&gt;transpose();</a>
<a name="ln2112">                                    if (!v.isZero())</a>
<a name="ln2113">                                          lastDeletedKeySigEvent.setKey(transposeKey(lastDeletedKeySigEvent.key(), v, lastDeletedKeySig-&gt;part()-&gt;preferSharpFlat()));</a>
<a name="ln2114">                                    }</a>
<a name="ln2115">                              }</a>
<a name="ln2116">                        }</a>
<a name="ln2117">                  if (lastDeletedSig &amp;&amp; lastDeletedKeySig)</a>
<a name="ln2118">                        break;</a>
<a name="ln2119">                  }</a>
<a name="ln2120">            if (mb == is)</a>
<a name="ln2121">                  break;</a>
<a name="ln2122">            }</a>
<a name="ln2123">      Fraction startTick = is-&gt;tick();</a>
<a name="ln2124">      Fraction endTick   = ie-&gt;tick();</a>
<a name="ln2125"> </a>
<a name="ln2126">      undoInsertTime(is-&gt;tick(), -(ie-&gt;endTick() - is-&gt;tick()));</a>
<a name="ln2127">      for (Score* score : scoreList()) {</a>
<a name="ln2128">            Measure* mis = score-&gt;tick2measure(startTick);</a>
<a name="ln2129">            Measure* mie = score-&gt;tick2measure(endTick);</a>
<a name="ln2130"> </a>
<a name="ln2131">            score-&gt;undoRemoveMeasures(mis, mie);</a>
<a name="ln2132"> </a>
<a name="ln2133">            // adjust views</a>
<a name="ln2134">            Measure* focusOn = mis-&gt;prevMeasure() ? mis-&gt;prevMeasure() : score-&gt;firstMeasure();</a>
<a name="ln2135">            for (MuseScoreView* v : score-&gt;viewer)</a>
<a name="ln2136">                  v-&gt;adjustCanvasPosition(focusOn, false);</a>
<a name="ln2137"> </a>
<a name="ln2138">            if (createEndBar) {</a>
<a name="ln2139">//                  Measure* lastMeasure = score-&gt;lastMeasure();</a>
<a name="ln2140">//TODO                  if (lastMeasure &amp;&amp; lastMeasure-&gt;endBarLineType() == BarLineType::NORMAL)</a>
<a name="ln2141">//                        score-&gt;undoChangeEndBarLineType(lastMeasure, BarLineType::END);</a>
<a name="ln2142">                  }</a>
<a name="ln2143"> </a>
<a name="ln2144">            // insert correct timesig after deletion</a>
<a name="ln2145">            Measure* mBeforeSel = mis-&gt;prevMeasure();</a>
<a name="ln2146">            Measure* mAfterSel  = mBeforeSel ? mBeforeSel-&gt;nextMeasure() : score-&gt;firstMeasure();</a>
<a name="ln2147">            if (mAfterSel &amp;&amp; lastDeletedSig) {</a>
<a name="ln2148">                  bool changed = true;</a>
<a name="ln2149">                  if (mBeforeSel) {</a>
<a name="ln2150">                        if (mBeforeSel-&gt;timesig() == mAfterSel-&gt;timesig()) {</a>
<a name="ln2151">                              changed = false;</a>
<a name="ln2152">                              }</a>
<a name="ln2153">                        }</a>
<a name="ln2154">                  Segment* s = mAfterSel-&gt;findSegment(SegmentType::TimeSig, mAfterSel-&gt;tick());</a>
<a name="ln2155">                  if (!s &amp;&amp; changed) {</a>
<a name="ln2156">                        Segment* ns = mAfterSel-&gt;undoGetSegment(SegmentType::TimeSig, mAfterSel-&gt;tick());</a>
<a name="ln2157">                        for (int staffIdx = 0; staffIdx &lt; score-&gt;nstaves(); staffIdx++) {</a>
<a name="ln2158">                              TimeSig* nts = new TimeSig(score);</a>
<a name="ln2159">                              nts-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2160">                              nts-&gt;setParent(ns);</a>
<a name="ln2161">                              nts-&gt;setSig(lastDeletedSig-&gt;sig(), lastDeletedSig-&gt;timeSigType());</a>
<a name="ln2162">                              score-&gt;undoAddElement(nts);</a>
<a name="ln2163">                              }</a>
<a name="ln2164">                        }</a>
<a name="ln2165">                  }</a>
<a name="ln2166">            // insert correct keysig if necessary</a>
<a name="ln2167">            if (mAfterSel &amp;&amp; !mBeforeSel &amp;&amp; lastDeletedKeySig) {</a>
<a name="ln2168">                  Segment* s = mAfterSel-&gt;findSegment(SegmentType::KeySig, mAfterSel-&gt;tick());</a>
<a name="ln2169">                  if (!s) {</a>
<a name="ln2170">                        Segment* ns = mAfterSel-&gt;undoGetSegment(SegmentType::KeySig, mAfterSel-&gt;tick());</a>
<a name="ln2171">                        for (int staffIdx = 0; staffIdx &lt; score-&gt;nstaves(); staffIdx++) {</a>
<a name="ln2172">                              KeySigEvent nkse = lastDeletedKeySigEvent;</a>
<a name="ln2173">                              if (transposeKeySigEvent) {</a>
<a name="ln2174">                                    Interval v = score-&gt;staff(staffIdx)-&gt;part()-&gt;instrument(Fraction(0,1))-&gt;transpose();</a>
<a name="ln2175">                                    v.flip();</a>
<a name="ln2176">                                    nkse.setKey(transposeKey(nkse.key(), v, lastDeletedKeySig-&gt;part()-&gt;preferSharpFlat()));</a>
<a name="ln2177">                                    }</a>
<a name="ln2178">                              KeySig* nks = new KeySig(score);</a>
<a name="ln2179">                              nks-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2180">                              nks-&gt;setParent(ns);</a>
<a name="ln2181">                              nks-&gt;setKeySigEvent(nkse);</a>
<a name="ln2182">                              score-&gt;undoAddElement(nks);</a>
<a name="ln2183">                              }</a>
<a name="ln2184">                        }</a>
<a name="ln2185">                  }</a>
<a name="ln2186">            }</a>
<a name="ln2187"> </a>
<a name="ln2188">      _is.setSegment(0);        // invalidate position</a>
<a name="ln2189">      }</a>
<a name="ln2190"> </a>
<a name="ln2191">//---------------------------------------------------------</a>
<a name="ln2192">//   deleteSpannersFromRange</a>
<a name="ln2193">///   Deletes spanners in the given range that match the</a>
<a name="ln2194">///   given selection filter.</a>
<a name="ln2195">//---------------------------------------------------------</a>
<a name="ln2196"> </a>
<a name="ln2197">void Score::deleteSpannersFromRange(const Fraction&amp; t1, const Fraction&amp; t2, int track1, int track2, const SelectionFilter&amp; filter)</a>
<a name="ln2198">      {</a>
<a name="ln2199">      auto spanners = _spanner.findOverlapping(t1.ticks(), t2.ticks() - 1);</a>
<a name="ln2200">      for (auto i : spanners) {</a>
<a name="ln2201">            Spanner* sp = i.value;</a>
<a name="ln2202">            if (sp-&gt;isVolta())</a>
<a name="ln2203">                  continue;</a>
<a name="ln2204">            if (!filter.canSelectVoice(sp-&gt;track()))</a>
<a name="ln2205">                  continue;</a>
<a name="ln2206">            if (sp-&gt;track() &gt;= track1 &amp;&amp; sp-&gt;track() &lt; track2) {</a>
<a name="ln2207">                  if (sp-&gt;tick() &gt;= t1 &amp;&amp; sp-&gt;tick() &lt; t2</a>
<a name="ln2208">                     &amp;&amp; sp-&gt;tick2() &gt;= t1 &amp;&amp; sp-&gt;tick2() &lt;= t2) {</a>
<a name="ln2209">                        undoRemoveElement(sp);</a>
<a name="ln2210">                        }</a>
<a name="ln2211">                  else if (sp-&gt;isSlur() &amp;&amp; ((sp-&gt;tick() &gt;= t1 &amp;&amp; sp-&gt;tick() &lt; t2)</a>
<a name="ln2212">                     || (sp-&gt;tick2() &gt;= t1 &amp;&amp; sp-&gt;tick2() &lt; t2))) {</a>
<a name="ln2213">                        undoRemoveElement(sp);</a>
<a name="ln2214">                        }</a>
<a name="ln2215">                  }</a>
<a name="ln2216">            }</a>
<a name="ln2217">      }</a>
<a name="ln2218"> </a>
<a name="ln2219">//---------------------------------------------------------</a>
<a name="ln2220">//   deleteAnnotationsFromRange</a>
<a name="ln2221">///   Deletes annotations in the given range that match the</a>
<a name="ln2222">///   given selection filter.</a>
<a name="ln2223">//---------------------------------------------------------</a>
<a name="ln2224"> </a>
<a name="ln2225">void Score::deleteAnnotationsFromRange(Segment* s1, Segment* s2, int track1, int track2, const SelectionFilter&amp; filter)</a>
<a name="ln2226">      {</a>
<a name="ln2227">      if (!s1)</a>
<a name="ln2228">            return;</a>
<a name="ln2229">      if (s2 &amp;&amp; (*s2) &lt; (*s1))</a>
<a name="ln2230">            return;</a>
<a name="ln2231"> </a>
<a name="ln2232">      for (int track = track1; track &lt; track2; ++track) {</a>
<a name="ln2233">            if (!filter.canSelectVoice(track))</a>
<a name="ln2234">                  continue;</a>
<a name="ln2235">            for (Segment* s = s1; s &amp;&amp; s != s2; s = s-&gt;next1()) {</a>
<a name="ln2236">                  const auto annotations = s-&gt;annotations(); // make a copy since we alter the list</a>
<a name="ln2237">                  for (Element* annotation : annotations) {</a>
<a name="ln2238">                        // skip if not included in selection (eg, filter)</a>
<a name="ln2239">                        if (!filter.canSelect(annotation))</a>
<a name="ln2240">                              continue;</a>
<a name="ln2241">                        if (!annotation-&gt;systemFlag() &amp;&amp; annotation-&gt;track() == track)</a>
<a name="ln2242">                              undoRemoveElement(annotation);</a>
<a name="ln2243">                        }</a>
<a name="ln2244">                  }</a>
<a name="ln2245">            }</a>
<a name="ln2246">      }</a>
<a name="ln2247"> </a>
<a name="ln2248">//---------------------------------------------------------</a>
<a name="ln2249">//   deleteRange</a>
<a name="ln2250">///   Deletes elements in the given range that match the</a>
<a name="ln2251">///   given selection filter.</a>
<a name="ln2252">///   \return A chord/rest inside the selected range</a>
<a name="ln2253">///   that can be used to establish a selection after this</a>
<a name="ln2254">///   deletion operation.</a>
<a name="ln2255">//---------------------------------------------------------</a>
<a name="ln2256"> </a>
<a name="ln2257">ChordRest* Score::deleteRange(Segment* s1, Segment* s2, int track1, int track2, const SelectionFilter&amp; filter)</a>
<a name="ln2258">      {</a>
<a name="ln2259">      ChordRest* cr = nullptr;</a>
<a name="ln2260"> </a>
<a name="ln2261">      if (s1) {</a>
<a name="ln2262">            // delete content from measures underlying mmrests</a>
<a name="ln2263">            if (s1 &amp;&amp; s1-&gt;measure() &amp;&amp; s1-&gt;measure()-&gt;isMMRest())</a>
<a name="ln2264">                  s1 = s1-&gt;measure()-&gt;mmRestFirst()-&gt;first();</a>
<a name="ln2265">            if (s2 &amp;&amp; s2-&gt;measure() &amp;&amp; s2-&gt;measure()-&gt;isMMRest())</a>
<a name="ln2266">                  s2 = s2-&gt;measure()-&gt;mmRestLast()-&gt;last();</a>
<a name="ln2267"> </a>
<a name="ln2268">            const Fraction stick1 = s1-&gt;tick();</a>
<a name="ln2269">            const Fraction stick2 = s2 ? s2-&gt;tick() : lastMeasure()-&gt;endTick();</a>
<a name="ln2270"> </a>
<a name="ln2271">            Segment* ss1 = s1;</a>
<a name="ln2272">            if (!ss1-&gt;isChordRestType())</a>
<a name="ln2273">                  ss1 = ss1-&gt;next1(SegmentType::ChordRest);</a>
<a name="ln2274">            bool fullMeasure = ss1 &amp;&amp; (ss1-&gt;measure()-&gt;first(SegmentType::ChordRest) == ss1)</a>
<a name="ln2275">                  &amp;&amp; (s2 == 0 || s2-&gt;isEndBarLineType());</a>
<a name="ln2276"> </a>
<a name="ln2277">            Fraction tick2 = s2 ? s2-&gt;tick() : Fraction(INT_MAX, 1);</a>
<a name="ln2278"> </a>
<a name="ln2279">            deleteSpannersFromRange(stick1, stick2, track1, track2, filter);</a>
<a name="ln2280"> </a>
<a name="ln2281">            for (int track = track1; track &lt; track2; ++track) {</a>
<a name="ln2282">                  if (!filter.canSelectVoice(track))</a>
<a name="ln2283">                        continue;</a>
<a name="ln2284">                  Fraction f;</a>
<a name="ln2285">                  Fraction tick  = Fraction(-1, 1);</a>
<a name="ln2286">                  Tuplet* tuplet = 0;</a>
<a name="ln2287">                  for (Segment* s = s1; s &amp;&amp; (s-&gt;tick() &lt; stick2); s = s-&gt;next1()) {</a>
<a name="ln2288">                        if (s-&gt;element(track) &amp;&amp; s-&gt;isBreathType()) {</a>
<a name="ln2289">                              deleteItem(s-&gt;element(track));</a>
<a name="ln2290">                              continue;</a>
<a name="ln2291">                              }</a>
<a name="ln2292">                        // delete annotations just from this segment and track</a>
<a name="ln2293">                        deleteAnnotationsFromRange(s, s-&gt;next1(), track, track + 1, filter);</a>
<a name="ln2294"> </a>
<a name="ln2295">                        Element* e = s-&gt;element(track);</a>
<a name="ln2296">                        if (!e)</a>
<a name="ln2297">                              continue;</a>
<a name="ln2298">                        if (!s-&gt;isChordRestType()) {</a>
<a name="ln2299">                              // do not delete TimeSig/KeySig,</a>
<a name="ln2300">                              // it doesn't make sense to do it, except on full system</a>
<a name="ln2301">                              if (s-&gt;segmentType() != SegmentType::TimeSig &amp;&amp; s-&gt;segmentType() != SegmentType::KeySig) {</a>
<a name="ln2302">                                    if (!(e-&gt;isBarLine()))</a>
<a name="ln2303">                                          undoRemoveElement(e);</a>
<a name="ln2304">                                    }</a>
<a name="ln2305">                              continue;</a>
<a name="ln2306">                              }</a>
<a name="ln2307">                        ChordRest* cr1 = toChordRest(e);</a>
<a name="ln2308">                        if (tick == Fraction(-1, 1)) {</a>
<a name="ln2309">                              // first ChordRest found:</a>
<a name="ln2310">                              Fraction offset = cr1-&gt;rtick();</a>
<a name="ln2311">                              if (cr1-&gt;measure()-&gt;tick() &gt;= s1-&gt;tick() &amp;&amp; offset.isNotZero()) {</a>
<a name="ln2312">                                    f = offset;</a>
<a name="ln2313">                                    tick = s-&gt;measure()-&gt;tick();</a>
<a name="ln2314">                                    }</a>
<a name="ln2315">                              else {</a>
<a name="ln2316">                                    tick = s-&gt;tick();</a>
<a name="ln2317">                                    f    = Fraction(0, 1);</a>
<a name="ln2318">                                    }</a>
<a name="ln2319">                              tuplet = cr1-&gt;tuplet();</a>
<a name="ln2320">                              if (tuplet &amp;&amp; (tuplet-&gt;tick() == tick) &amp;&amp; ((tuplet-&gt;tick() + tuplet-&gt;actualTicks()) &lt;= tick2) ) {</a>
<a name="ln2321">                                    // remove complete top level tuplet</a>
<a name="ln2322"> </a>
<a name="ln2323">                                    Tuplet* t = cr1-&gt;tuplet();</a>
<a name="ln2324">                                    while (t-&gt;tuplet())</a>
<a name="ln2325">                                          t = t-&gt;tuplet();</a>
<a name="ln2326">                                    cmdDeleteTuplet(t, false);</a>
<a name="ln2327">                                    f += t-&gt;ticks();</a>
<a name="ln2328">                                    tuplet = 0;</a>
<a name="ln2329">                                    continue;</a>
<a name="ln2330">                                    }</a>
<a name="ln2331">                              }</a>
<a name="ln2332">                        if (tuplet != cr1-&gt;tuplet()) {</a>
<a name="ln2333">                              Tuplet* t = cr1-&gt;tuplet();</a>
<a name="ln2334">                              if (t &amp;&amp; (((t-&gt;tick() + t-&gt;actualTicks()) &lt;= tick2) || fullMeasure)) {</a>
<a name="ln2335">                                    // remove complete top level tuplet</a>
<a name="ln2336"> </a>
<a name="ln2337">                                    while (t-&gt;tuplet())</a>
<a name="ln2338">                                          t = t-&gt;tuplet();</a>
<a name="ln2339">                                    cmdDeleteTuplet(t, false);</a>
<a name="ln2340">                                    f += t-&gt;ticks();</a>
<a name="ln2341">                                    tuplet = 0;</a>
<a name="ln2342">                                    continue;</a>
<a name="ln2343">                                    }</a>
<a name="ln2344">                              if (f.isValid())</a>
<a name="ln2345">                                    setRest(tick, track, f, false, tuplet);</a>
<a name="ln2346">                              tick = cr1-&gt;tick();</a>
<a name="ln2347">                              tuplet = cr1-&gt;tuplet();</a>
<a name="ln2348">                              removeChordRest(cr1, true);</a>
<a name="ln2349">                              f = cr1-&gt;ticks();</a>
<a name="ln2350">                              }</a>
<a name="ln2351">                        else {</a>
<a name="ln2352">                              removeChordRest(cr1, true);</a>
<a name="ln2353">                              f += cr1-&gt;ticks();</a>
<a name="ln2354">                              }</a>
<a name="ln2355">                        }</a>
<a name="ln2356">                  if (f.isValid() &amp;&amp; !f.isZero()) {</a>
<a name="ln2357">                        if (fullMeasure) {</a>
<a name="ln2358">                              // handle this as special case to be able to</a>
<a name="ln2359">                              // fix broken measures:</a>
<a name="ln2360">                              Staff* staff = Score::staff(track / VOICES);</a>
<a name="ln2361">                              for (Measure* m = s1-&gt;measure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln2362">                                    Fraction tick3   = m-&gt;tick();</a>
<a name="ln2363">                                    Fraction ff = m-&gt;stretchedLen(staff);</a>
<a name="ln2364">                                    Rest* r = setRest(tick3, track, ff, false, 0);</a>
<a name="ln2365">                                    if (!cr)</a>
<a name="ln2366">                                          cr = r;</a>
<a name="ln2367">                                    if (s2 &amp;&amp; (m == s2-&gt;measure()))</a>
<a name="ln2368">                                          break;</a>
<a name="ln2369">                                    }</a>
<a name="ln2370">                              }</a>
<a name="ln2371">                        else {</a>
<a name="ln2372">                              Rest* r = setRest(tick, track, f, false, tuplet);</a>
<a name="ln2373">                              if (!cr)</a>
<a name="ln2374">                                    cr = r;</a>
<a name="ln2375">                              }</a>
<a name="ln2376">                        }</a>
<a name="ln2377">                  }</a>
<a name="ln2378">            }</a>
<a name="ln2379">      return cr;</a>
<a name="ln2380">      }</a>
<a name="ln2381"> </a>
<a name="ln2382">//---------------------------------------------------------</a>
<a name="ln2383">//   cmdDeleteSelection</a>
<a name="ln2384">//---------------------------------------------------------</a>
<a name="ln2385"> </a>
<a name="ln2386">void Score::cmdDeleteSelection()</a>
<a name="ln2387">      {</a>
<a name="ln2388">      ChordRest* cr = 0;            // select something after deleting notes</a>
<a name="ln2389"> </a>
<a name="ln2390">      if (selection().isRange()) {</a>
<a name="ln2391">            Segment* s1 = selection().startSegment();</a>
<a name="ln2392">            Segment* s2 = selection().endSegment();</a>
<a name="ln2393">            const Fraction stick1 = selection().tickStart();</a>
<a name="ln2394">            const Fraction stick2 = selection().tickEnd();</a>
<a name="ln2395">            cr = deleteRange(s1, s2, staff2track(selection().staffStart()), staff2track(selection().staffEnd()), selectionFilter());</a>
<a name="ln2396">            s1 = tick2segment(stick1);</a>
<a name="ln2397">            s2 = tick2segment(stick2, true);</a>
<a name="ln2398">            if (s1 == 0 || s2 == 0)</a>
<a name="ln2399">                  deselectAll();</a>
<a name="ln2400">            else {</a>
<a name="ln2401">                  _selection.setStartSegment(s1);</a>
<a name="ln2402">                  _selection.setEndSegment(s2);</a>
<a name="ln2403">                  _selection.updateSelectedElements();</a>
<a name="ln2404">                  }</a>
<a name="ln2405">            }</a>
<a name="ln2406">      else {</a>
<a name="ln2407">            // deleteItem modifies selection().elements() list,</a>
<a name="ln2408">            // so we need a local copy:</a>
<a name="ln2409">            QList&lt;Element*&gt; el = selection().elements();</a>
<a name="ln2410"> </a>
<a name="ln2411">            // keep track of linked elements that are deleted implicitly</a>
<a name="ln2412">            // so we don't try to delete them twice if they are also in selection</a>
<a name="ln2413">            QList&lt;ScoreElement*&gt; deletedElements;</a>
<a name="ln2414">            // Similarly, deleting one spanner segment, will delete all of them</a>
<a name="ln2415">            // so we don't try to delete them twice if they are also in selection</a>
<a name="ln2416">            QList&lt;Spanner*&gt; deletedSpanners;</a>
<a name="ln2417"> </a>
<a name="ln2418">            for (Element* e : el) {</a>
<a name="ln2419">                  // these are the linked elements we are about to delete</a>
<a name="ln2420">                  QList&lt;ScoreElement*&gt; links;</a>
<a name="ln2421">                  if (e-&gt;links())</a>
<a name="ln2422">                        links = *e-&gt;links();</a>
<a name="ln2423"> </a>
<a name="ln2424">                  // find location of element to select after deleting notes</a>
<a name="ln2425">                  // get tick of element itself if that is valid</a>
<a name="ln2426">                  // or of spanner or parent if that is more valid</a>
<a name="ln2427">                  Fraction tick  = { -1, 1 };</a>
<a name="ln2428">                  int track = -1;</a>
<a name="ln2429">                  if (!cr) {</a>
<a name="ln2430">                        if (e-&gt;isNote())</a>
<a name="ln2431">                              tick = toNote(e)-&gt;chord()-&gt;tick();</a>
<a name="ln2432">                        else if (e-&gt;isRest())</a>
<a name="ln2433">                              tick = toRest(e)-&gt;tick();</a>
<a name="ln2434">                        else if (e-&gt;isSpannerSegment())</a>
<a name="ln2435">                              tick = toSpannerSegment(e)-&gt;spanner()-&gt;tick();</a>
<a name="ln2436">                        else if (e-&gt;parent()</a>
<a name="ln2437">                           &amp;&amp; (e-&gt;parent()-&gt;isSegment() || e-&gt;parent()-&gt;isChord() || e-&gt;parent()-&gt;isNote() || e-&gt;parent()-&gt;isRest()))</a>
<a name="ln2438">                              tick = e-&gt;parent()-&gt;tick();</a>
<a name="ln2439">                        //else tick &lt; 0</a>
<a name="ln2440">                        track = e-&gt;track();</a>
<a name="ln2441">                        }</a>
<a name="ln2442"> </a>
<a name="ln2443">                  // delete element if we have not done so already</a>
<a name="ln2444">                  if (!deletedElements.contains(e)) {</a>
<a name="ln2445">                        // do not delete two spanner segments from the same spanner</a>
<a name="ln2446">                        if (e-&gt;isSpannerSegment()) {</a>
<a name="ln2447">                              Spanner* spanner = toSpannerSegment(e)-&gt;spanner();</a>
<a name="ln2448">                              if (deletedSpanners.contains(spanner))</a>
<a name="ln2449">                                    continue;</a>
<a name="ln2450">                              else {</a>
<a name="ln2451">                                    QList&lt;ScoreElement*&gt; linkedSpanners;</a>
<a name="ln2452">                                    if (spanner-&gt;links())</a>
<a name="ln2453">                                          linkedSpanners = *spanner-&gt;links();</a>
<a name="ln2454">                                    else</a>
<a name="ln2455">                                          linkedSpanners.append(spanner);</a>
<a name="ln2456">                                    for (ScoreElement* se : linkedSpanners)</a>
<a name="ln2457">                                          deletedSpanners.append(toSpanner(se));</a>
<a name="ln2458">                                    }</a>
<a name="ln2459">                              }</a>
<a name="ln2460">                        deleteItem(e);</a>
<a name="ln2461">                        }</a>
<a name="ln2462"> </a>
<a name="ln2463">                  // find element to select</a>
<a name="ln2464">                  if (!cr &amp;&amp; tick &gt;= Fraction(0,1) &amp;&amp; track &gt;= 0)</a>
<a name="ln2465">                        cr = findCR(tick, track);</a>
<a name="ln2466"> </a>
<a name="ln2467">                  // add these linked elements to list of already-deleted elements</a>
<a name="ln2468">                  for (ScoreElement* se : links)</a>
<a name="ln2469">                        deletedElements.append(se);</a>
<a name="ln2470">                  }</a>
<a name="ln2471"> </a>
<a name="ln2472">            }</a>
<a name="ln2473"> </a>
<a name="ln2474">      deselectAll();</a>
<a name="ln2475">      // make new selection if appropriate</a>
<a name="ln2476">      if (noteEntryMode())</a>
<a name="ln2477">            cr = _is.cr();</a>
<a name="ln2478">      if (cr) {</a>
<a name="ln2479">            if (cr-&gt;isChord())</a>
<a name="ln2480">                  select(toChord(cr)-&gt;upNote(), SelectType::SINGLE);</a>
<a name="ln2481">            else</a>
<a name="ln2482">                  select(cr, SelectType::SINGLE);</a>
<a name="ln2483">            }</a>
<a name="ln2484">      }</a>
<a name="ln2485"> </a>
<a name="ln2486">//---------------------------------------------------------</a>
<a name="ln2487">//   cmdFullMeasureRest</a>
<a name="ln2488">//---------------------------------------------------------</a>
<a name="ln2489"> </a>
<a name="ln2490">void Score::cmdFullMeasureRest()</a>
<a name="ln2491">      {</a>
<a name="ln2492">      Segment* s1     = nullptr;</a>
<a name="ln2493">      Segment* s2     = nullptr;</a>
<a name="ln2494">      Fraction stick1 = { -1, 1 };</a>
<a name="ln2495">      Fraction stick2 = { -1, 1 };</a>
<a name="ln2496">      int track1      = -1;</a>
<a name="ln2497">      int track2      = -1;</a>
<a name="ln2498">      Rest* r         = nullptr;</a>
<a name="ln2499"> </a>
<a name="ln2500">      if (noteEntryMode()) {</a>
<a name="ln2501">            s1 = inputState().segment();</a>
<a name="ln2502">            if (!s1 || s1-&gt;rtick().isNotZero())</a>
<a name="ln2503">                  return;</a>
<a name="ln2504">            Measure* m = s1-&gt;measure();</a>
<a name="ln2505">            s2 = m-&gt;last();</a>
<a name="ln2506">            stick1 = s1-&gt;tick();</a>
<a name="ln2507">            stick2 = s2-&gt;tick();</a>
<a name="ln2508">            track1 = inputState().track();</a>
<a name="ln2509">            track2 = track1 + 1;</a>
<a name="ln2510">            }</a>
<a name="ln2511">      else if (selection().isRange()) {</a>
<a name="ln2512">            s1 = selection().startSegment();</a>
<a name="ln2513">            s2 = selection().endSegment();</a>
<a name="ln2514">            if (styleB(Sid::createMultiMeasureRests)) {</a>
<a name="ln2515">                   // use underlying measures</a>
<a name="ln2516">                   if (s1 &amp;&amp; s1-&gt;measure()-&gt;isMMRest())</a>
<a name="ln2517">                         s1 = tick2segment(stick1);</a>
<a name="ln2518">                   if (s2 &amp;&amp; s2-&gt;measure()-&gt;isMMRest())</a>
<a name="ln2519">                         s2 = tick2segment(stick2, true);</a>
<a name="ln2520">                   }</a>
<a name="ln2521">            stick1 = selection().tickStart();</a>
<a name="ln2522">            stick2 = selection().tickEnd();</a>
<a name="ln2523">            Segment* ss1 = s1;</a>
<a name="ln2524">            if (ss1 &amp;&amp; ss1-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln2525">                  ss1 = ss1-&gt;next1(SegmentType::ChordRest);</a>
<a name="ln2526">            bool fullMeasure = ss1 &amp;&amp; (ss1-&gt;measure()-&gt;first(SegmentType::ChordRest) == ss1)</a>
<a name="ln2527">                  &amp;&amp; (s2 == 0 || (s2-&gt;segmentType() == SegmentType::EndBarLine)</a>
<a name="ln2528">                        || (s2-&gt;segmentType() == SegmentType::TimeSigAnnounce)</a>
<a name="ln2529">                        || (s2-&gt;segmentType() == SegmentType::KeySigAnnounce));</a>
<a name="ln2530">            if (!fullMeasure) {</a>
<a name="ln2531">                  return;</a>
<a name="ln2532">                  }</a>
<a name="ln2533">            track1 = selection().staffStart() * VOICES;</a>
<a name="ln2534">            track2 = selection().staffEnd() * VOICES;</a>
<a name="ln2535">            }</a>
<a name="ln2536">      else if (selection().cr()) {</a>
<a name="ln2537">            ChordRest* cr = selection().cr();</a>
<a name="ln2538">            if (!cr || cr-&gt;rtick().isNotZero())</a>
<a name="ln2539">                  return;</a>
<a name="ln2540">            Measure* m = cr-&gt;measure();</a>
<a name="ln2541">            s1 = m-&gt;first();</a>
<a name="ln2542">            s2 = m-&gt;last();</a>
<a name="ln2543">            stick1 = s1-&gt;tick();</a>
<a name="ln2544">            stick2 = s2-&gt;tick();</a>
<a name="ln2545">            track1 = selection().cr()-&gt;track();</a>
<a name="ln2546">            track2 = track1 + 1;</a>
<a name="ln2547">            }</a>
<a name="ln2548">      else {</a>
<a name="ln2549">            return;</a>
<a name="ln2550">            }</a>
<a name="ln2551"> </a>
<a name="ln2552">      for (int track = track1; track &lt; track2; ++track) {</a>
<a name="ln2553">            if (selection().isRange() &amp;&amp; !selectionFilter().canSelectVoice(track))</a>
<a name="ln2554">                  continue;</a>
<a name="ln2555">            // first pass - remove non-initial rests from empty measures/voices</a>
<a name="ln2556">            for (Segment* s = s1; s != s2; s = s-&gt;next1()) {</a>
<a name="ln2557">                  if (!(s-&gt;measure()-&gt;isOnlyRests(track))) // Don't remove anything from measures that contain notes</a>
<a name="ln2558">                        continue;</a>
<a name="ln2559">                  if (s-&gt;segmentType() != SegmentType::ChordRest || !s-&gt;element(track))</a>
<a name="ln2560">                        continue;</a>
<a name="ln2561">                  ChordRest* cr = toChordRest(s-&gt;element(track));</a>
<a name="ln2562">                  // keep first rest of measure as placeholder (replaced in second pass)</a>
<a name="ln2563">                  // but delete all others</a>
<a name="ln2564">                  if (s-&gt;rtick().isNotZero())</a>
<a name="ln2565">                        removeChordRest(cr, true);</a>
<a name="ln2566">                  }</a>
<a name="ln2567">            // second pass - replace placeholders with full measure rests</a>
<a name="ln2568">            for (Measure* m = s1-&gt;measure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln2569">                  if (m-&gt;isOnlyRests(track)) {</a>
<a name="ln2570">                        ChordRest* cr = m-&gt;findChordRest(m-&gt;tick(), track);</a>
<a name="ln2571">                        if (cr) {</a>
<a name="ln2572">                              removeChordRest(cr, true);</a>
<a name="ln2573">                              r = addRest(m-&gt;tick(), track, TDuration(TDuration::DurationType::V_MEASURE), 0);</a>
<a name="ln2574">                              }</a>
<a name="ln2575">                        else if (noteEntryMode()) {</a>
<a name="ln2576">                              // might be no cr at input position</a>
<a name="ln2577">                              r = addRest(m-&gt;tick(), track, TDuration(TDuration::DurationType::V_MEASURE), 0);</a>
<a name="ln2578">                              }</a>
<a name="ln2579">                        }</a>
<a name="ln2580">                  if (s2 &amp;&amp; (m == s2-&gt;measure()))</a>
<a name="ln2581">                        break;</a>
<a name="ln2582">                  }</a>
<a name="ln2583">            }</a>
<a name="ln2584"> </a>
<a name="ln2585">      // selected range is probably empty now and possibly subsumed by an mmrest</a>
<a name="ln2586">      // so updating selection requires forcing mmrests to be updated first</a>
<a name="ln2587">//TODO-ws      if (styleB(Sid::createMultiMeasureRests))</a>
<a name="ln2588">//            createMMRests();</a>
<a name="ln2589">      s1 = tick2segmentMM(stick1);</a>
<a name="ln2590">      s2 = tick2segmentMM(stick2, true);</a>
<a name="ln2591">      if (selection().isRange() &amp;&amp; s1 &amp;&amp; s2) {</a>
<a name="ln2592">            _selection.setStartSegment(s1);</a>
<a name="ln2593">            _selection.setEndSegment(s2);</a>
<a name="ln2594">            _selection.updateSelectedElements();</a>
<a name="ln2595">            }</a>
<a name="ln2596">      else if (r) {</a>
<a name="ln2597">            // note entry mode</a>
<a name="ln2598">            select(r, SelectType::SINGLE);</a>
<a name="ln2599">            }</a>
<a name="ln2600">      else {</a>
<a name="ln2601">            deselectAll();</a>
<a name="ln2602">            }</a>
<a name="ln2603">      }</a>
<a name="ln2604"> </a>
<a name="ln2605">//---------------------------------------------------------</a>
<a name="ln2606">//   addLyrics</a>
<a name="ln2607">//    called from Keyboard Accelerator &amp; menu</a>
<a name="ln2608">//---------------------------------------------------------</a>
<a name="ln2609"> </a>
<a name="ln2610">Lyrics* Score::addLyrics()</a>
<a name="ln2611">      {</a>
<a name="ln2612">      Element* el = selection().element();</a>
<a name="ln2613">      if (el == 0 || (!el-&gt;isNote() &amp;&amp; !el-&gt;isLyrics() &amp;&amp; !el-&gt;isRest())) {</a>
<a name="ln2614">            MScore::setError(NO_LYRICS_SELECTED);</a>
<a name="ln2615">            return 0;</a>
<a name="ln2616">            }</a>
<a name="ln2617">      ChordRest* cr;</a>
<a name="ln2618">      if (el-&gt;isNote()) {</a>
<a name="ln2619">            cr = toNote(el)-&gt;chord();</a>
<a name="ln2620">            if(cr-&gt;isGrace())</a>
<a name="ln2621">                  cr = toChordRest(cr-&gt;parent());</a>
<a name="ln2622">            }</a>
<a name="ln2623">      else if (el-&gt;isLyrics())</a>
<a name="ln2624">            cr = toLyrics(el)-&gt;chordRest();</a>
<a name="ln2625">      else if (el-&gt;isRest())</a>
<a name="ln2626">            cr = toChordRest(el);</a>
<a name="ln2627">      else</a>
<a name="ln2628">            return 0;</a>
<a name="ln2629"> </a>
<a name="ln2630">      int no = int(cr-&gt;lyrics().size());</a>
<a name="ln2631">      Lyrics* lyrics = new Lyrics(this);</a>
<a name="ln2632">      lyrics-&gt;setTrack(cr-&gt;track());</a>
<a name="ln2633">      lyrics-&gt;setParent(cr);</a>
<a name="ln2634">      lyrics-&gt;setNo(no);</a>
<a name="ln2635">      undoAddElement(lyrics);</a>
<a name="ln2636">      select(lyrics, SelectType::SINGLE, 0);</a>
<a name="ln2637">      return lyrics;</a>
<a name="ln2638">      }</a>
<a name="ln2639"> </a>
<a name="ln2640">//---------------------------------------------------------</a>
<a name="ln2641">//   addHairpin</a>
<a name="ln2642">//---------------------------------------------------------</a>
<a name="ln2643"> </a>
<a name="ln2644">Hairpin* Score::addHairpin(HairpinType t, const Fraction&amp; tickStart, const Fraction&amp; tickEnd, int track)</a>
<a name="ln2645">      {</a>
<a name="ln2646">      Hairpin* pin = new Hairpin(this);</a>
<a name="ln2647">      pin-&gt;setHairpinType(t);</a>
<a name="ln2648">      if (t == HairpinType::CRESC_LINE) {</a>
<a name="ln2649">            pin-&gt;setBeginText(&quot;cresc.&quot;);</a>
<a name="ln2650">            pin-&gt;setContinueText(&quot;(cresc.)&quot;);</a>
<a name="ln2651">            }</a>
<a name="ln2652">      else if (t == HairpinType::DECRESC_LINE) {</a>
<a name="ln2653">            pin-&gt;setBeginText(&quot;dim.&quot;);</a>
<a name="ln2654">            pin-&gt;setContinueText(&quot;(dim.)&quot;);</a>
<a name="ln2655">            }</a>
<a name="ln2656">      pin-&gt;setTrack(track);</a>
<a name="ln2657">      pin-&gt;setTrack2(track);</a>
<a name="ln2658">      pin-&gt;setTick(tickStart);</a>
<a name="ln2659">      pin-&gt;setTick2(tickEnd);</a>
<a name="ln2660">      undoAddElement(pin);</a>
<a name="ln2661">      return pin;</a>
<a name="ln2662">      }</a>
<a name="ln2663"> </a>
<a name="ln2664">//---------------------------------------------------------</a>
<a name="ln2665">//   Score::addHairpin</a>
<a name="ln2666">//---------------------------------------------------------</a>
<a name="ln2667"> </a>
<a name="ln2668">Hairpin* Score::addHairpin(HairpinType type, ChordRest* cr1, ChordRest* cr2, bool toCr2End)</a>
<a name="ln2669">      {</a>
<a name="ln2670">      if (!cr1)</a>
<a name="ln2671">            return nullptr;</a>
<a name="ln2672">      if (!cr2)</a>
<a name="ln2673">            cr2 = cr1;</a>
<a name="ln2674">      Q_ASSERT(cr1-&gt;staffIdx() == cr2-&gt;staffIdx());</a>
<a name="ln2675">      const Fraction end = toCr2End ? cr2-&gt;tick() + cr2-&gt;actualTicks() : cr2-&gt;tick();</a>
<a name="ln2676">      return addHairpin(type, cr1-&gt;tick(), end, cr1-&gt;track());</a>
<a name="ln2677">      }</a>
<a name="ln2678"> </a>
<a name="ln2679">//---------------------------------------------------------</a>
<a name="ln2680">//   cmdCreateTuplet</a>
<a name="ln2681">//    replace cr with tuplet</a>
<a name="ln2682">//---------------------------------------------------------</a>
<a name="ln2683"> </a>
<a name="ln2684">void Score::cmdCreateTuplet(ChordRest* ocr, Tuplet* tuplet)</a>
<a name="ln2685">      {</a>
<a name="ln2686">      int track        = ocr-&gt;track();</a>
<a name="ln2687">      Measure* measure = ocr-&gt;measure();</a>
<a name="ln2688">      Fraction tick     = ocr-&gt;tick();</a>
<a name="ln2689"> </a>
<a name="ln2690">      if (ocr-&gt;tuplet())</a>
<a name="ln2691">            tuplet-&gt;setTuplet(ocr-&gt;tuplet());</a>
<a name="ln2692">      undoRemoveElement(ocr);</a>
<a name="ln2693"> </a>
<a name="ln2694">      ChordRest* cr;</a>
<a name="ln2695">      if (ocr-&gt;isChord()) {</a>
<a name="ln2696">            cr = new Chord(this);</a>
<a name="ln2697">            foreach (Note* oldNote, toChord(ocr)-&gt;notes()) {</a>
<a name="ln2698">                  Note* note = new Note(this);</a>
<a name="ln2699">                  note-&gt;setPitch(oldNote-&gt;pitch());</a>
<a name="ln2700">                  note-&gt;setTpc1(oldNote-&gt;tpc1());</a>
<a name="ln2701">                  note-&gt;setTpc2(oldNote-&gt;tpc2());</a>
<a name="ln2702">                  cr-&gt;add(note);</a>
<a name="ln2703">                  }</a>
<a name="ln2704">            }</a>
<a name="ln2705">      else</a>
<a name="ln2706">            cr = new Rest(this);</a>
<a name="ln2707"> </a>
<a name="ln2708">      Fraction an     = (tuplet-&gt;ticks() * tuplet-&gt;ratio()) / tuplet-&gt;baseLen().fraction();</a>
<a name="ln2709">      int actualNotes = an.numerator() / an.denominator();</a>
<a name="ln2710"> </a>
<a name="ln2711">      tuplet-&gt;setTrack(track);</a>
<a name="ln2712">      cr-&gt;setTuplet(tuplet);</a>
<a name="ln2713">      cr-&gt;setTrack(track);</a>
<a name="ln2714">      cr-&gt;setDurationType(tuplet-&gt;baseLen());</a>
<a name="ln2715">      cr-&gt;setTicks(tuplet-&gt;baseLen().fraction());</a>
<a name="ln2716"> </a>
<a name="ln2717">      undoAddCR(cr, measure, tick);</a>
<a name="ln2718"> </a>
<a name="ln2719">      Fraction ticks = cr-&gt;actualTicks();</a>
<a name="ln2720"> </a>
<a name="ln2721">      for (int i = 0; i &lt; (actualNotes-1); ++i) {</a>
<a name="ln2722">            tick += ticks;</a>
<a name="ln2723">            Rest* rest = new Rest(this);</a>
<a name="ln2724">            rest-&gt;setTuplet(tuplet);</a>
<a name="ln2725">            rest-&gt;setTrack(track);</a>
<a name="ln2726">            rest-&gt;setDurationType(tuplet-&gt;baseLen());</a>
<a name="ln2727">            rest-&gt;setTicks(tuplet-&gt;baseLen().fraction());</a>
<a name="ln2728">            undoAddCR(rest, measure, tick);</a>
<a name="ln2729">            }</a>
<a name="ln2730">      }</a>
<a name="ln2731"> </a>
<a name="ln2732">//---------------------------------------------------------</a>
<a name="ln2733">//   colorItem</a>
<a name="ln2734">//---------------------------------------------------------</a>
<a name="ln2735"> </a>
<a name="ln2736">void Score::colorItem(Element* element)</a>
<a name="ln2737">      {</a>
<a name="ln2738">      QColor sc(element-&gt;color());</a>
<a name="ln2739">      QColor c = QColorDialog::getColor(sc);</a>
<a name="ln2740">      if (!c.isValid())</a>
<a name="ln2741">            return;</a>
<a name="ln2742"> </a>
<a name="ln2743">      foreach(Element* e, selection().elements()) {</a>
<a name="ln2744">            if (e-&gt;color() != c) {</a>
<a name="ln2745">                  e-&gt;undoChangeProperty(Pid::COLOR, c);</a>
<a name="ln2746">                  e-&gt;setGenerated(false);</a>
<a name="ln2747">                  addRefresh(e-&gt;abbox());</a>
<a name="ln2748">                  if (e-&gt;isBarLine()) {</a>
<a name="ln2749">//                        Element* ep = e-&gt;parent();</a>
<a name="ln2750">//                        if (ep-&gt;isSegment() &amp;&amp; toSegment(ep)-&gt;isEndBarLineType()) {</a>
<a name="ln2751">//                              Measure* m = toSegment(ep)-&gt;measure();</a>
<a name="ln2752">//                              BarLine* bl = toBarLine(e);</a>
<a name="ln2753">//                              m-&gt;setEndBarLineType(bl-&gt;barLineType(), false, e-&gt;visible(), e-&gt;color());</a>
<a name="ln2754">//                              }</a>
<a name="ln2755">                        }</a>
<a name="ln2756">                  }</a>
<a name="ln2757">            }</a>
<a name="ln2758">      deselectAll();</a>
<a name="ln2759">      }</a>
<a name="ln2760"> </a>
<a name="ln2761">//---------------------------------------------------------</a>
<a name="ln2762">//   cmdExchangeVoice</a>
<a name="ln2763">//---------------------------------------------------------</a>
<a name="ln2764"> </a>
<a name="ln2765">void Score::cmdExchangeVoice(int s, int d)</a>
<a name="ln2766">      {</a>
<a name="ln2767">      if (!selection().isRange()) {</a>
<a name="ln2768">            MScore::setError(NO_STAFF_SELECTED);</a>
<a name="ln2769">            return;</a>
<a name="ln2770">            }</a>
<a name="ln2771">      Fraction t1 = selection().tickStart();</a>
<a name="ln2772">      Fraction t2 = selection().tickEnd();</a>
<a name="ln2773"> </a>
<a name="ln2774">      Measure* m1 = tick2measure(t1);</a>
<a name="ln2775">      Measure* m2 = tick2measure(t2);</a>
<a name="ln2776"> </a>
<a name="ln2777">      if (selection().score()-&gt;excerpt())</a>
<a name="ln2778">            return;</a>
<a name="ln2779"> </a>
<a name="ln2780">      if (t2 &gt; m2-&gt;tick())</a>
<a name="ln2781">            m2 = m2-&gt;nextMeasure();</a>
<a name="ln2782"> </a>
<a name="ln2783">      for (;;) {</a>
<a name="ln2784">            undoExchangeVoice(m1, s, d, selection().staffStart(), selection().staffEnd());</a>
<a name="ln2785">            m1 = m1-&gt;nextMeasure();</a>
<a name="ln2786">            if ((m1 == 0) || (m2 &amp;&amp; (m1-&gt;tick() == m2-&gt;tick())))</a>
<a name="ln2787">                  break;</a>
<a name="ln2788">            }</a>
<a name="ln2789">      }</a>
<a name="ln2790"> </a>
<a name="ln2791">//---------------------------------------------------------</a>
<a name="ln2792">//   cmdEnterRest</a>
<a name="ln2793">//---------------------------------------------------------</a>
<a name="ln2794"> </a>
<a name="ln2795">void Score::cmdEnterRest(const TDuration&amp; d)</a>
<a name="ln2796">      {</a>
<a name="ln2797">      if (_is.track() == -1) {</a>
<a name="ln2798">            qDebug(&quot;cmdEnterRest: track -1&quot;);</a>
<a name="ln2799">            return;</a>
<a name="ln2800">            }</a>
<a name="ln2801">      startCmd();</a>
<a name="ln2802">      expandVoice();</a>
<a name="ln2803">      if (_is.cr() == 0) {</a>
<a name="ln2804">            qDebug(&quot;cannot enter rest here&quot;);</a>
<a name="ln2805">            return;</a>
<a name="ln2806">            }</a>
<a name="ln2807"> </a>
<a name="ln2808">      int track = _is.track();</a>
<a name="ln2809">      NoteVal nval;</a>
<a name="ln2810">      setNoteRest(_is.segment(), track, nval, d.fraction(), Direction::AUTO);</a>
<a name="ln2811">      _is.moveToNextInputPos();</a>
<a name="ln2812">      if (!noteEntryMode() || usingNoteEntryMethod(NoteEntryMethod::STEPTIME))</a>
<a name="ln2813">            _is.setRest(false);  // continue with normal note entry</a>
<a name="ln2814">      endCmd();</a>
<a name="ln2815">      }</a>
<a name="ln2816"> </a>
<a name="ln2817">//---------------------------------------------------------</a>
<a name="ln2818">//   removeChordRest</a>
<a name="ln2819">//    remove chord or rest</a>
<a name="ln2820">//    remove associated segment if empty</a>
<a name="ln2821">//    remove beam</a>
<a name="ln2822">//    remove slurs</a>
<a name="ln2823">//---------------------------------------------------------</a>
<a name="ln2824"> </a>
<a name="ln2825">void Score::removeChordRest(ChordRest* cr, bool clearSegment)</a>
<a name="ln2826">      {</a>
<a name="ln2827">      QList&lt;Segment*&gt; segments;</a>
<a name="ln2828">      for (ScoreElement* e : cr-&gt;linkList()) {</a>
<a name="ln2829">            undo(new RemoveElement(static_cast&lt;Element*&gt;(e)));</a>
<a name="ln2830">            if (clearSegment) {</a>
<a name="ln2831">                  Segment* s = cr-&gt;segment();</a>
<a name="ln2832">                  if (!segments.contains(s))</a>
<a name="ln2833">                        segments.append(s);</a>
<a name="ln2834">                  }</a>
<a name="ln2835">            }</a>
<a name="ln2836">      for (Segment* s : segments) {</a>
<a name="ln2837">            if (s-&gt;empty())</a>
<a name="ln2838">                  undo(new RemoveElement(s));</a>
<a name="ln2839">            }</a>
<a name="ln2840">      if (cr-&gt;beam()) {</a>
<a name="ln2841">            Beam* beam = cr-&gt;beam();</a>
<a name="ln2842">            if (beam-&gt;generated()) {</a>
<a name="ln2843">                  beam-&gt;parent()-&gt;remove(beam);</a>
<a name="ln2844">                  delete beam;</a>
<a name="ln2845">                  }</a>
<a name="ln2846">            else</a>
<a name="ln2847">                  undoRemoveElement(beam);</a>
<a name="ln2848">            }</a>
<a name="ln2849">      }</a>
<a name="ln2850"> </a>
<a name="ln2851">//---------------------------------------------------------</a>
<a name="ln2852">//   cmdDeleteTuplet</a>
<a name="ln2853">//    remove tuplet and replace with rest</a>
<a name="ln2854">//---------------------------------------------------------</a>
<a name="ln2855"> </a>
<a name="ln2856">void Score::cmdDeleteTuplet(Tuplet* tuplet, bool replaceWithRest)</a>
<a name="ln2857">      {</a>
<a name="ln2858">      foreach(DurationElement* de, tuplet-&gt;elements()) {</a>
<a name="ln2859">            if (de-&gt;isChordRest())</a>
<a name="ln2860">                  removeChordRest(toChordRest(de), true);</a>
<a name="ln2861">            else {</a>
<a name="ln2862">                  Q_ASSERT(de-&gt;isTuplet());</a>
<a name="ln2863">                  cmdDeleteTuplet(toTuplet(de), false);</a>
<a name="ln2864">                  }</a>
<a name="ln2865">            }</a>
<a name="ln2866">      if (replaceWithRest)</a>
<a name="ln2867">            setRest(tuplet-&gt;tick(), tuplet-&gt;track(), tuplet-&gt;ticks(), true, tuplet-&gt;tuplet());</a>
<a name="ln2868">      }</a>
<a name="ln2869"> </a>
<a name="ln2870">//---------------------------------------------------------</a>
<a name="ln2871">//   nextInputPos</a>
<a name="ln2872">//---------------------------------------------------------</a>
<a name="ln2873"> </a>
<a name="ln2874">void Score::nextInputPos(ChordRest* cr, bool doSelect)</a>
<a name="ln2875">      {</a>
<a name="ln2876">      ChordRest* ncr = nextChordRest(cr);</a>
<a name="ln2877">      if ((ncr == 0) &amp;&amp; (_is.track() % VOICES)) {</a>
<a name="ln2878">            Segment* s = tick2segment(cr-&gt;tick() + cr-&gt;actualTicks(), false, SegmentType::ChordRest);</a>
<a name="ln2879">            int track = (cr-&gt;track() / VOICES) * VOICES;</a>
<a name="ln2880">            ncr = s ? toChordRest(s-&gt;element(track)) : 0;</a>
<a name="ln2881">            }</a>
<a name="ln2882">      if (ncr) {</a>
<a name="ln2883">            _is.setSegment(ncr-&gt;segment());</a>
<a name="ln2884">            if (doSelect)</a>
<a name="ln2885">                  select(ncr, SelectType::SINGLE, 0);</a>
<a name="ln2886">            setPlayPos(ncr-&gt;tick());</a>
<a name="ln2887">            for (MuseScoreView* v : viewer)</a>
<a name="ln2888">                  v-&gt;moveCursor();</a>
<a name="ln2889">            }</a>
<a name="ln2890">      }</a>
<a name="ln2891"> </a>
<a name="ln2892">//---------------------------------------------------------</a>
<a name="ln2893">//   insertMeasure</a>
<a name="ln2894">//    Create a new MeasureBase of type type and insert</a>
<a name="ln2895">//    before measure.</a>
<a name="ln2896">//    If measure is zero, append new MeasureBase.</a>
<a name="ln2897">//---------------------------------------------------------</a>
<a name="ln2898"> </a>
<a name="ln2899">void Score::insertMeasure(ElementType type, MeasureBase* measure, bool createEmptyMeasures, bool moveSignaturesClef)</a>
<a name="ln2900">      {</a>
<a name="ln2901">      Fraction tick;</a>
<a name="ln2902">      if (measure) {</a>
<a name="ln2903">            if (measure-&gt;isMeasure() &amp;&amp; toMeasure(measure)-&gt;isMMRest()) {</a>
<a name="ln2904">                  measure = toMeasure(measure)-&gt;prev();</a>
<a name="ln2905">                  measure = measure ? measure-&gt;next() : firstMeasure();</a>
<a name="ln2906">                  deselectAll();</a>
<a name="ln2907">                  }</a>
<a name="ln2908">            tick = measure-&gt;tick();</a>
<a name="ln2909">            }</a>
<a name="ln2910">      else</a>
<a name="ln2911">            tick = last() ? last()-&gt;endTick() : Fraction(0,1);</a>
<a name="ln2912"> </a>
<a name="ln2913">      Fraction f       = sigmap()-&gt;timesig(tick.ticks()).nominal(); // use nominal time signature of current measure</a>
<a name="ln2914">      Measure* om      = 0;                                       // measure base in &quot;this&quot; score</a>
<a name="ln2915">      MeasureBase* rmb = 0;                                       // measure base in root score (for linking)</a>
<a name="ln2916">      Fraction ticks   = { 0, 1 };</a>
<a name="ln2917"> </a>
<a name="ln2918">      for (Score* score : scoreList()) {</a>
<a name="ln2919">            MeasureBase* im = 0;</a>
<a name="ln2920">            if (measure) {</a>
<a name="ln2921">                  if (measure-&gt;isMeasure())</a>
<a name="ln2922">                        im = score-&gt;tick2measure(tick);</a>
<a name="ln2923">                  else {</a>
<a name="ln2924">                        if (!measure-&gt;links()) {</a>
<a name="ln2925">                              if (measure-&gt;score() == score)</a>
<a name="ln2926">                                    im = measure;</a>
<a name="ln2927">                              else</a>
<a name="ln2928">                                    qDebug(&quot;no links&quot;);</a>
<a name="ln2929">                              }</a>
<a name="ln2930">                        else {</a>
<a name="ln2931">                              for (ScoreElement* m : *measure-&gt;links()) {</a>
<a name="ln2932">                                    if (measure-&gt;score() == score) {</a>
<a name="ln2933">                                          im = toMeasureBase(m);</a>
<a name="ln2934">                                          break;</a>
<a name="ln2935">                                          }</a>
<a name="ln2936">                                    }</a>
<a name="ln2937">                              }</a>
<a name="ln2938">                        }</a>
<a name="ln2939">                  if (!im)</a>
<a name="ln2940">                        qDebug(&quot;measure not found&quot;);</a>
<a name="ln2941">                  }</a>
<a name="ln2942">            MeasureBase* mb = toMeasureBase(Element::create(type, score));</a>
<a name="ln2943">            mb-&gt;setTick(tick);</a>
<a name="ln2944"> </a>
<a name="ln2945">            mb-&gt;setNext(im);</a>
<a name="ln2946">            mb-&gt;setPrev(im ? im-&gt;prev() : score-&gt;last());</a>
<a name="ln2947">            if (mb-&gt;isMeasure()) {</a>
<a name="ln2948">                  Measure* m = toMeasure(mb);</a>
<a name="ln2949">                  m-&gt;setTimesig(f);</a>
<a name="ln2950">                  m-&gt;setTicks(f);</a>
<a name="ln2951">                  }</a>
<a name="ln2952">            undo(new InsertMeasures(mb, mb));</a>
<a name="ln2953"> </a>
<a name="ln2954">            if (type == ElementType::MEASURE) {</a>
<a name="ln2955">                  Measure* m  = toMeasure(mb);  // new measure</a>
<a name="ln2956">                  ticks       = m-&gt;ticks();</a>
<a name="ln2957">                  Measure* mi = nullptr;        // insert before</a>
<a name="ln2958">                  if (im) {</a>
<a name="ln2959">                        if (im-&gt;isMeasure())</a>
<a name="ln2960">                              mi = toMeasure(im);</a>
<a name="ln2961">                        else</a>
<a name="ln2962">                              mi = score-&gt;tick2measure(im-&gt;tick());</a>
<a name="ln2963">                        }</a>
<a name="ln2964"> </a>
<a name="ln2965">                  if (score-&gt;isMaster())</a>
<a name="ln2966">                        om = m;</a>
<a name="ln2967"> </a>
<a name="ln2968">                  QList&lt;TimeSig*&gt; tsl;</a>
<a name="ln2969">                  QList&lt;KeySig*&gt;  ksl;</a>
<a name="ln2970">                  QList&lt;Clef*&gt;    cl;</a>
<a name="ln2971">                  QList&lt;Clef*&gt;    pcl;</a>
<a name="ln2972"> </a>
<a name="ln2973">                  //</a>
<a name="ln2974">                  // remove clef, time and key signatures</a>
<a name="ln2975">                  //</a>
<a name="ln2976">                  if (moveSignaturesClef &amp;&amp; mi) {</a>
<a name="ln2977">                        for (int staffIdx = 0; staffIdx &lt; score-&gt;nstaves(); ++staffIdx) {</a>
<a name="ln2978">                              Measure* pm = mi-&gt;prevMeasure();</a>
<a name="ln2979">                              if (pm) {</a>
<a name="ln2980">                                    Segment* ps = pm-&gt;findSegment(SegmentType::Clef, tick);</a>
<a name="ln2981">                                    if (ps &amp;&amp; ps-&gt;enabled()) {</a>
<a name="ln2982">                                          Element* pc = ps-&gt;element(staffIdx * VOICES);</a>
<a name="ln2983">                                          if (pc) {</a>
<a name="ln2984">                                                pcl.push_back(toClef(pc));</a>
<a name="ln2985">                                                undo(new RemoveElement(pc));</a>
<a name="ln2986">                                                if (ps-&gt;empty())</a>
<a name="ln2987">                                                      undoRemoveElement(ps);</a>
<a name="ln2988">                                                }</a>
<a name="ln2989">                                          }</a>
<a name="ln2990">                                    }</a>
<a name="ln2991">                              for (Segment* s = mi-&gt;first(); s &amp;&amp; s-&gt;rtick().isZero(); s = s-&gt;next()) {</a>
<a name="ln2992">                                    if (!s-&gt;enabled())</a>
<a name="ln2993">                                          continue;</a>
<a name="ln2994">                                    Element* e = s-&gt;element(staffIdx * VOICES);</a>
<a name="ln2995">                                    if (!e || e-&gt;generated())</a>
<a name="ln2996">                                          continue;</a>
<a name="ln2997">                                    Element* ee = 0;</a>
<a name="ln2998">                                    if (e-&gt;isKeySig()) {</a>
<a name="ln2999">                                          KeySig* ks = toKeySig(e);</a>
<a name="ln3000">                                          ksl.push_back(ks);</a>
<a name="ln3001">                                          ee = e;</a>
<a name="ln3002">                                          }</a>
<a name="ln3003">                                    else if (e-&gt;isTimeSig()) {</a>
<a name="ln3004">                                          TimeSig* ts = toTimeSig(e);</a>
<a name="ln3005">                                          tsl.push_back(ts);</a>
<a name="ln3006">                                          ee = e;</a>
<a name="ln3007">                                          }</a>
<a name="ln3008">                                    if (tick.isZero() &amp;&amp; e-&gt;isClef()) {</a>
<a name="ln3009">                                          Clef* clef = toClef(e);</a>
<a name="ln3010">                                          cl.push_back(clef);</a>
<a name="ln3011">                                          ee = e;</a>
<a name="ln3012">                                          }</a>
<a name="ln3013">                                    if (ee) {</a>
<a name="ln3014">                                          undo(new RemoveElement(ee));</a>
<a name="ln3015">                                          if (s-&gt;empty())</a>
<a name="ln3016">                                                undoRemoveElement(s);</a>
<a name="ln3017">                                          }</a>
<a name="ln3018">                                    }</a>
<a name="ln3019">                              }</a>
<a name="ln3020">                        }</a>
<a name="ln3021"> </a>
<a name="ln3022"> </a>
<a name="ln3023">                  //</a>
<a name="ln3024">                  // move clef, time, key signatrues</a>
<a name="ln3025">                  //</a>
<a name="ln3026">                  for (TimeSig* ts : tsl) {</a>
<a name="ln3027">                        TimeSig* nts = new TimeSig(*ts);</a>
<a name="ln3028">                        Segment* s   = m-&gt;undoGetSegmentR(SegmentType::TimeSig, Fraction(0,1));</a>
<a name="ln3029">                        nts-&gt;setParent(s);</a>
<a name="ln3030">                        undoAddElement(nts);</a>
<a name="ln3031">                        }</a>
<a name="ln3032">                  for (KeySig* ks : ksl) {</a>
<a name="ln3033">                        KeySig* nks = new KeySig(*ks);</a>
<a name="ln3034">                        Segment* s  = m-&gt;undoGetSegmentR(SegmentType::KeySig, Fraction(0,1));</a>
<a name="ln3035">                        nks-&gt;setParent(s);</a>
<a name="ln3036">                        undoAddElement(nks);</a>
<a name="ln3037">                        }</a>
<a name="ln3038">                  for (Clef* clef : cl) {</a>
<a name="ln3039">                        Clef* nClef = new Clef(*clef);</a>
<a name="ln3040">                        Segment* s  = m-&gt;undoGetSegmentR(SegmentType::HeaderClef, Fraction(0,1));</a>
<a name="ln3041">                        nClef-&gt;setParent(s);</a>
<a name="ln3042">                        undoAddElement(nClef);</a>
<a name="ln3043">                        }</a>
<a name="ln3044">                  Measure* pm = m-&gt;prevMeasure();</a>
<a name="ln3045">                  for (Clef* clef : pcl) {</a>
<a name="ln3046">                        Clef* nClef = new Clef(*clef);</a>
<a name="ln3047">                        Segment* s  = pm-&gt;undoGetSegment(SegmentType::Clef, tick);</a>
<a name="ln3048">                        nClef-&gt;setParent(s);</a>
<a name="ln3049">                        undoAddElement(nClef);</a>
<a name="ln3050">                        }</a>
<a name="ln3051">                  }</a>
<a name="ln3052">            else {</a>
<a name="ln3053">                  // a frame, not a measure</a>
<a name="ln3054">                  if (score-&gt;isMaster())</a>
<a name="ln3055">                        rmb = mb;</a>
<a name="ln3056">                  else if (rmb &amp;&amp; mb != rmb) {</a>
<a name="ln3057">                        mb-&gt;linkTo(rmb);</a>
<a name="ln3058">                        if (rmb-&gt;isTBox())</a>
<a name="ln3059">                              toTBox(mb)-&gt;text()-&gt;linkTo(toTBox(rmb)-&gt;text());</a>
<a name="ln3060">                        }</a>
<a name="ln3061">                  }</a>
<a name="ln3062">            }</a>
<a name="ln3063"> </a>
<a name="ln3064">      undoInsertTime(tick, ticks);</a>
<a name="ln3065"> </a>
<a name="ln3066">      if (om &amp;&amp; !createEmptyMeasures) {</a>
<a name="ln3067">            //</a>
<a name="ln3068">            // fill measure with rest</a>
<a name="ln3069">            //</a>
<a name="ln3070">            Score* score = om-&gt;score();</a>
<a name="ln3071"> </a>
<a name="ln3072">            // add rest to all staves and to all the staves linked to it</a>
<a name="ln3073">            for (int staffIdx = 0; staffIdx &lt; score-&gt;nstaves(); ++staffIdx) {</a>
<a name="ln3074">                  int track = staffIdx * VOICES;</a>
<a name="ln3075">                  Rest* rest = new Rest(score, TDuration(TDuration::DurationType::V_MEASURE));</a>
<a name="ln3076">                  Fraction timeStretch(score-&gt;staff(staffIdx)-&gt;timeStretch(om-&gt;tick()));</a>
<a name="ln3077">                  rest-&gt;setTicks(om-&gt;ticks() * timeStretch);</a>
<a name="ln3078">                  rest-&gt;setTrack(track);</a>
<a name="ln3079">                  score-&gt;undoAddCR(rest, om, tick);</a>
<a name="ln3080">                  }</a>
<a name="ln3081">            }</a>
<a name="ln3082">      deselectAll();</a>
<a name="ln3083">      }</a>
<a name="ln3084"> </a>
<a name="ln3085">//---------------------------------------------------------</a>
<a name="ln3086">//   checkSpanner</a>
<a name="ln3087">//    check if spanners are still valid as anchors may</a>
<a name="ln3088">//    have changed or be removed.</a>
<a name="ln3089">//    Spanners need to have a start anchor. Slurs need a</a>
<a name="ln3090">//    start and end anchor.</a>
<a name="ln3091">//---------------------------------------------------------</a>
<a name="ln3092"> </a>
<a name="ln3093">void Score::checkSpanner(const Fraction&amp; startTick, const Fraction&amp; endTick)</a>
<a name="ln3094">      {</a>
<a name="ln3095">      QList&lt;Spanner*&gt; sl;     // spanners to remove</a>
<a name="ln3096">      QList&lt;Spanner*&gt; sl2;    // spanners to shorten</a>
<a name="ln3097">      auto spanners = _spanner.findOverlapping(startTick.ticks(), endTick.ticks());</a>
<a name="ln3098"> </a>
<a name="ln3099">      // DEBUG: check all spanner</a>
<a name="ln3100">      //        there may be spanners outside of score bc. some measures were deleted</a>
<a name="ln3101"> </a>
<a name="ln3102">      Fraction lastTick = lastMeasure()-&gt;endTick();</a>
<a name="ln3103"> </a>
<a name="ln3104">      for (auto i : _spanner.map()) {</a>
<a name="ln3105">            Spanner* s = i.second;</a>
<a name="ln3106"> </a>
<a name="ln3107">            if (s-&gt;isSlur()) {</a>
<a name="ln3108">                  Segment* seg = tick2segmentMM(s-&gt;tick(), false, SegmentType::ChordRest);</a>
<a name="ln3109">                  if (!seg || !seg-&gt;element(s-&gt;track()))</a>
<a name="ln3110">                        sl.append(s);</a>
<a name="ln3111">                  else {</a>
<a name="ln3112">                        seg = tick2segmentMM(s-&gt;tick2(), false, SegmentType::ChordRest);</a>
<a name="ln3113">                        if (!seg || !seg-&gt;element(s-&gt;track2()))</a>
<a name="ln3114">                              sl.append(s);</a>
<a name="ln3115">                        }</a>
<a name="ln3116">                  }</a>
<a name="ln3117">            else {</a>
<a name="ln3118">                  // remove spanner if there is no start element</a>
<a name="ln3119">                  s-&gt;computeStartElement();</a>
<a name="ln3120">                  if (!s-&gt;startElement()) {</a>
<a name="ln3121">                        sl.append(s);</a>
<a name="ln3122">                        qDebug(&quot;checkSpanner::remove (3)&quot;);</a>
<a name="ln3123">                        }</a>
<a name="ln3124">                  else {</a>
<a name="ln3125">                        if (s-&gt;tick2() &gt; lastTick)</a>
<a name="ln3126">                              sl2.append(s);    //s-&gt;undoChangeProperty(Pid::SPANNER_TICKS, lastTick - s-&gt;tick());</a>
<a name="ln3127">                        else</a>
<a name="ln3128">                              s-&gt;computeEndElement();</a>
<a name="ln3129">                        }</a>
<a name="ln3130">                  }</a>
<a name="ln3131">            }</a>
<a name="ln3132">      for (auto s : sl)       // actually remove scheduled spanners</a>
<a name="ln3133">            undo(new RemoveElement(s));</a>
<a name="ln3134">      for (auto s : sl2) {    // shorten spanners that extended past end of score</a>
<a name="ln3135">            undo(new ChangeProperty(s, Pid::SPANNER_TICKS, lastTick - s-&gt;tick()));</a>
<a name="ln3136">            s-&gt;computeEndElement();</a>
<a name="ln3137">            }</a>
<a name="ln3138">      }</a>
<a name="ln3139"> </a>
<a name="ln3140">static constexpr SegmentType CR_TYPE = SegmentType::ChordRest;</a>
<a name="ln3141"> </a>
<a name="ln3142">//---------------------------------------------------------</a>
<a name="ln3143">//   checkTimeDelete</a>
<a name="ln3144">//---------------------------------------------------------</a>
<a name="ln3145"> </a>
<a name="ln3146">bool Score::checkTimeDelete(Segment* startSegment, Segment* endSegment)</a>
<a name="ln3147">      {</a>
<a name="ln3148">      Measure* m = startSegment-&gt;measure();</a>
<a name="ln3149">      Measure* endMeasure;</a>
<a name="ln3150"> </a>
<a name="ln3151">      if (endSegment)</a>
<a name="ln3152">            endMeasure = endSegment-&gt;prev() ? endSegment-&gt;measure() : endSegment-&gt;measure()-&gt;prevMeasure();</a>
<a name="ln3153">      else</a>
<a name="ln3154">            endMeasure = lastMeasure();</a>
<a name="ln3155"> </a>
<a name="ln3156">      Fraction endTick = endSegment ? endSegment-&gt;tick() : endMeasure-&gt;endTick();</a>
<a name="ln3157">      Fraction tick = startSegment-&gt;tick();</a>
<a name="ln3158">      Fraction etick = (m == endMeasure ? endTick : m-&gt;endTick());</a>
<a name="ln3159">      bool canDeleteTime = true;</a>
<a name="ln3160"> </a>
<a name="ln3161">      while (canDeleteTime) {</a>
<a name="ln3162">            for (int track = 0; canDeleteTime &amp;&amp; track &lt; _staves.size() * VOICES; ++track) {</a>
<a name="ln3163">                  if (m-&gt;hasVoice(track)) {</a>
<a name="ln3164">                        Segment* fs = m-&gt;first(CR_TYPE);</a>
<a name="ln3165">                        for (Segment* s = fs; s; s = s-&gt;next(CR_TYPE)) {</a>
<a name="ln3166">                              if (s-&gt;element(track)) {</a>
<a name="ln3167">                                    ChordRest* cr       = toChordRest(s-&gt;element(track));</a>
<a name="ln3168">                                    Tuplet* t           = cr-&gt;tuplet();</a>
<a name="ln3169">                                    DurationElement* de = t ? toDurationElement(t) : toDurationElement(cr);</a>
<a name="ln3170">                                    Fraction f          = de-&gt;tick() + de-&gt;actualTicks();</a>
<a name="ln3171">                                    Fraction cetick     = f;</a>
<a name="ln3172">                                    if (cetick &lt;= tick)</a>
<a name="ln3173">                                          continue;</a>
<a name="ln3174">                                    if (de-&gt;tick() &gt;= etick)</a>
<a name="ln3175">                                          break;</a>
<a name="ln3176">                                    if (t &amp;&amp; (t-&gt;tick() &lt; tick || cetick &gt; etick)) {</a>
<a name="ln3177">                                          canDeleteTime = false;</a>
<a name="ln3178">                                          break;</a>
<a name="ln3179">                                          }</a>
<a name="ln3180">                                    }</a>
<a name="ln3181">                              }</a>
<a name="ln3182">                        }</a>
<a name="ln3183">                  }</a>
<a name="ln3184">            if (m == endMeasure)</a>
<a name="ln3185">                  break;</a>
<a name="ln3186">            m     = endMeasure;</a>
<a name="ln3187">            tick  = m-&gt;tick();</a>
<a name="ln3188">            etick = endTick;</a>
<a name="ln3189">            }</a>
<a name="ln3190">      if (!canDeleteTime) {</a>
<a name="ln3191">            QMessageBox::information(0, &quot;MuseScore&quot;,</a>
<a name="ln3192">               tr(&quot;Please select the complete tuplet and retry the command&quot;),</a>
<a name="ln3193">               QMessageBox::Ok, QMessageBox::NoButton);</a>
<a name="ln3194">            return false;</a>
<a name="ln3195">            }</a>
<a name="ln3196">      return true;</a>
<a name="ln3197">      }</a>
<a name="ln3198"> </a>
<a name="ln3199">//---------------------------------------------------------</a>
<a name="ln3200">//   globalTimeDelete</a>
<a name="ln3201">//---------------------------------------------------------</a>
<a name="ln3202"> </a>
<a name="ln3203">void Score::globalTimeDelete()</a>
<a name="ln3204">      {</a>
<a name="ln3205">      qDebug(&quot;not implemented&quot;);</a>
<a name="ln3206">      }</a>
<a name="ln3207"> </a>
<a name="ln3208">//---------------------------------------------------------</a>
<a name="ln3209">//   localTimeDelete</a>
<a name="ln3210">//---------------------------------------------------------</a>
<a name="ln3211"> </a>
<a name="ln3212">void Score::localTimeDelete()</a>
<a name="ln3213">      {</a>
<a name="ln3214">      Segment* startSegment;</a>
<a name="ln3215">      Segment* endSegment;</a>
<a name="ln3216"> </a>
<a name="ln3217">      if (selection().state() != SelState::RANGE) {</a>
<a name="ln3218">            Element* el = selection().element();</a>
<a name="ln3219">            if (!el)</a>
<a name="ln3220">                  return;</a>
<a name="ln3221">            ChordRest* cr = 0;</a>
<a name="ln3222">            if (el-&gt;isNote())</a>
<a name="ln3223">                  cr = toNote(el)-&gt;chord();</a>
<a name="ln3224">            else if (el-&gt;isChordRest())</a>
<a name="ln3225">                  cr = toChordRest(el);</a>
<a name="ln3226">            else</a>
<a name="ln3227">                  return;</a>
<a name="ln3228">            startSegment     = cr-&gt;segment();</a>
<a name="ln3229">            Fraction endTick = startSegment-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln3230">            endSegment       = tick2measure(endTick)-&gt;findSegment(CR_TYPE, endTick);</a>
<a name="ln3231">            }</a>
<a name="ln3232">      else {</a>
<a name="ln3233">            startSegment = selection().startSegment();</a>
<a name="ln3234">            endSegment   = selection().endSegment();</a>
<a name="ln3235">            }</a>
<a name="ln3236"> </a>
<a name="ln3237">      if (!checkTimeDelete(startSegment, endSegment))</a>
<a name="ln3238">            return;</a>
<a name="ln3239"> </a>
<a name="ln3240">      MeasureBase* is = startSegment-&gt;measure();</a>
<a name="ln3241">      if (is-&gt;isMeasure() &amp;&amp; toMeasure(is)-&gt;isMMRest())</a>
<a name="ln3242">            is = toMeasure(is)-&gt;mmRestFirst();</a>
<a name="ln3243">      MeasureBase* ie;</a>
<a name="ln3244"> </a>
<a name="ln3245">      if (endSegment)</a>
<a name="ln3246">            ie = endSegment-&gt;prev() ? endSegment-&gt;measure() : endSegment-&gt;measure()-&gt;prev();</a>
<a name="ln3247">      else</a>
<a name="ln3248">            ie = lastMeasure();</a>
<a name="ln3249"> </a>
<a name="ln3250">      Fraction endTick = endSegment ? endSegment-&gt;tick() : ie-&gt;endTick();</a>
<a name="ln3251"> </a>
<a name="ln3252">      for (;;) {</a>
<a name="ln3253">            if (is-&gt;tick() != startSegment-&gt;tick()) {</a>
<a name="ln3254">                  Fraction tick = startSegment-&gt;tick();</a>
<a name="ln3255">                  Fraction len;</a>
<a name="ln3256">                  if (ie == is)</a>
<a name="ln3257">                        len = endTick - tick;</a>
<a name="ln3258">                  else</a>
<a name="ln3259">                        len = is-&gt;endTick() - tick;</a>
<a name="ln3260">                  timeDelete(toMeasure(is), startSegment, len);</a>
<a name="ln3261">                  if (is == ie)</a>
<a name="ln3262">                        break;</a>
<a name="ln3263">                  is = is-&gt;next();</a>
<a name="ln3264">                  }</a>
<a name="ln3265">            endTick = endSegment ? endSegment-&gt;tick() : ie-&gt;endTick();</a>
<a name="ln3266">            if (ie-&gt;endTick() != endTick) {</a>
<a name="ln3267">                  Fraction len = endTick - ie-&gt;tick();</a>
<a name="ln3268">                  timeDelete(toMeasure(ie), toMeasure(ie)-&gt;first(), len);</a>
<a name="ln3269">                  if (is == ie)</a>
<a name="ln3270">                        break;</a>
<a name="ln3271">                  ie = ie-&gt;prev();</a>
<a name="ln3272">                  }</a>
<a name="ln3273">            deleteMeasures(is, ie);</a>
<a name="ln3274">            break;</a>
<a name="ln3275">            };</a>
<a name="ln3276"> </a>
<a name="ln3277">      deselectAll();</a>
<a name="ln3278">      }</a>
<a name="ln3279"> </a>
<a name="ln3280">//---------------------------------------------------------</a>
<a name="ln3281">//   timeDelete</a>
<a name="ln3282">//---------------------------------------------------------</a>
<a name="ln3283"> </a>
<a name="ln3284">void Score::timeDelete(Measure* m, Segment* startSegment, const Fraction&amp; f)</a>
<a name="ln3285">      {</a>
<a name="ln3286">      const Fraction tick  = startSegment-&gt;rtick();</a>
<a name="ln3287">      const Fraction len   = f;</a>
<a name="ln3288">      const Fraction etick = tick + len;</a>
<a name="ln3289"> </a>
<a name="ln3290">      Segment* fs = m-&gt;first(CR_TYPE);</a>
<a name="ln3291"> </a>
<a name="ln3292">      for (int track = 0; track &lt; _staves.size() * VOICES; ++track) {</a>
<a name="ln3293">            if (m-&gt;hasVoice(track)) {</a>
<a name="ln3294">                  for (Segment* s = fs; s; s = s-&gt;next(CR_TYPE)) {</a>
<a name="ln3295">                        if (s-&gt;element(track)) {</a>
<a name="ln3296">                              ChordRest* cr   = toChordRest(s-&gt;element(track));</a>
<a name="ln3297">                              Fraction cetick = cr-&gt;rtick() + cr-&gt;actualTicks();</a>
<a name="ln3298"> </a>
<a name="ln3299">                              if (cetick &lt;= tick)</a>
<a name="ln3300">                                    continue;</a>
<a name="ln3301">                              if (s-&gt;rtick() &gt;= etick)</a>
<a name="ln3302">                                    break;</a>
<a name="ln3303"> </a>
<a name="ln3304">                              if (cr-&gt;isFullMeasureRest()) {</a>
<a name="ln3305">                                    if (cr-&gt;rtick() &gt;= tick) {</a>
<a name="ln3306">                                          // Move full-measure rest from the deleted area</a>
<a name="ln3307">                                          undoRemoveElement(cr);</a>
<a name="ln3308">                                          ChordRest* newCR = toChordRest(cr-&gt;clone());</a>
<a name="ln3309">                                          newCR-&gt;setTicks(cr-&gt;ticks() - f);</a>
<a name="ln3310">                                          undoAddCR(newCR, m, m-&gt;tick() + etick);</a>
<a name="ln3311">                                          }</a>
<a name="ln3312">                                    else</a>
<a name="ln3313">                                          cr-&gt;undoChangeProperty(Pid::DURATION, cr-&gt;ticks() - f);</a>
<a name="ln3314">                                    }</a>
<a name="ln3315">                              // inside deleted area</a>
<a name="ln3316">                              else if (s-&gt;rtick() &gt;= tick &amp;&amp; cetick &lt;= etick) {</a>
<a name="ln3317">                                    // inside</a>
<a name="ln3318">                                    undoRemoveElement(cr);</a>
<a name="ln3319">                                    }</a>
<a name="ln3320">                              else if (s-&gt;rtick() &gt;= tick) {</a>
<a name="ln3321">                                    // running out</a>
<a name="ln3322">                                    Fraction ff = cetick - etick;</a>
<a name="ln3323">                                    undoRemoveElement(cr);</a>
<a name="ln3324">                                    createCRSequence(ff, cr, tick + len);</a>
<a name="ln3325">                                    }</a>
<a name="ln3326">                              else if (s-&gt;rtick() &lt; tick &amp;&amp; cetick &lt;= etick) {</a>
<a name="ln3327">                                    // running in</a>
<a name="ln3328">                                    Fraction f1 = tick - s-&gt;rtick();</a>
<a name="ln3329">                                    changeCRlen(cr, f1, false);</a>
<a name="ln3330">                                    }</a>
<a name="ln3331">                              else {</a>
<a name="ln3332">                                    // running in/out</a>
<a name="ln3333">                                    Fraction f1 = cr-&gt;ticks() - f;</a>
<a name="ln3334">                                    changeCRlen(cr, f1, false);</a>
<a name="ln3335">                                    }</a>
<a name="ln3336">                              }</a>
<a name="ln3337">                        }</a>
<a name="ln3338">                  }</a>
<a name="ln3339">            }</a>
<a name="ln3340">      const Fraction abstick = startSegment-&gt;tick();</a>
<a name="ln3341">      undoInsertTime(abstick, -len);</a>
<a name="ln3342"> </a>
<a name="ln3343">      std::vector&lt;Segment*&gt; emptySegments;</a>
<a name="ln3344"> </a>
<a name="ln3345">      for (Score* score : masterScore()-&gt;scoreList()) {</a>
<a name="ln3346">            Measure* localMeasure = score-&gt;tick2measure(abstick);</a>
<a name="ln3347"> </a>
<a name="ln3348">            undo(new InsertTime(score, abstick, -len));</a>
<a name="ln3349"> </a>
<a name="ln3350">            Fraction updatedTick = tick;</a>
<a name="ln3351">            for (Segment* s = localMeasure-&gt;first(CR_TYPE); s; s = s-&gt;next()) {</a>
<a name="ln3352">                  if (s-&gt;rtick() &lt; etick || s-&gt;rtick() == updatedTick)</a>
<a name="ln3353">                        continue;</a>
<a name="ln3354"> </a>
<a name="ln3355">                  s-&gt;undoChangeProperty(Pid::TICK, updatedTick);</a>
<a name="ln3356">                  updatedTick += s-&gt;ticks();</a>
<a name="ln3357"> </a>
<a name="ln3358">                  if (score-&gt;isMaster()) {</a>
<a name="ln3359">                        if (s-&gt;isChordRestType() &amp;&amp; !s-&gt;hasElements())</a>
<a name="ln3360">                              emptySegments.push_back(s);</a>
<a name="ln3361">                        }</a>
<a name="ln3362">                  }</a>
<a name="ln3363"> </a>
<a name="ln3364">            undo(new ChangeMeasureLen(localMeasure, localMeasure-&gt;ticks() - f));</a>
<a name="ln3365">            }</a>
<a name="ln3366"> </a>
<a name="ln3367">      for (Segment* s : emptySegments) {</a>
<a name="ln3368">            if (Segment* ns = s-&gt;next(CR_TYPE)) {</a>
<a name="ln3369">                  // Move annotations from the empty segment.</a>
<a name="ln3370">                  // TODO: do we need to preserve annotations at all?</a>
<a name="ln3371">                  // Maybe only some types (Tempo etc.)?</a>
<a name="ln3372">                  for (Element* a : s-&gt;annotations()) {</a>
<a name="ln3373">                        Element* a1 = a-&gt;clone();</a>
<a name="ln3374">                        a1-&gt;setParent(ns);</a>
<a name="ln3375">                        undoRemoveElement(a);</a>
<a name="ln3376">                        undoAddElement(a1);</a>
<a name="ln3377">                        }</a>
<a name="ln3378">                  }</a>
<a name="ln3379">            }</a>
<a name="ln3380">      }</a>
<a name="ln3381"> </a>
<a name="ln3382">//---------------------------------------------------------</a>
<a name="ln3383">//   cloneVoice</a>
<a name="ln3384">//---------------------------------------------------------</a>
<a name="ln3385"> </a>
<a name="ln3386">void Score::cloneVoice(int strack, int dtrack, Segment* sf, const Fraction&amp; lTick, bool link, bool spanner)</a>
<a name="ln3387">      {</a>
<a name="ln3388">      Fraction start = sf-&gt;tick();</a>
<a name="ln3389">      TieMap  tieMap;</a>
<a name="ln3390">      TupletMap tupletMap;    // tuplets cannot cross measure boundaries</a>
<a name="ln3391">      Score* score = sf-&gt;score();</a>
<a name="ln3392">      Tremolo* tremolo = 0;</a>
<a name="ln3393"> </a>
<a name="ln3394">      for (Segment* oseg = sf; oseg &amp;&amp; oseg-&gt;tick() &lt; lTick; oseg = oseg-&gt;next1()) {</a>
<a name="ln3395">            Segment* ns = 0;        //create segment later, on demand</a>
<a name="ln3396">            Measure* dm = tick2measure(oseg-&gt;tick());</a>
<a name="ln3397"> </a>
<a name="ln3398">            Element* oe = oseg-&gt;element(strack);</a>
<a name="ln3399"> </a>
<a name="ln3400">            if (oe &amp;&amp; !oe-&gt;generated() &amp;&amp; oe-&gt;isChordRest()) {</a>
<a name="ln3401">                  Element* ne;</a>
<a name="ln3402">                  //does a linked clone to create just this element</a>
<a name="ln3403">                  //otherwise element will be add in every linked stave</a>
<a name="ln3404">                  if (link)</a>
<a name="ln3405">                        ne = oe-&gt;linkedClone();</a>
<a name="ln3406">                  else</a>
<a name="ln3407">                        ne = oe-&gt;clone();</a>
<a name="ln3408">                  ne-&gt;setTrack(dtrack);</a>
<a name="ln3409"> </a>
<a name="ln3410">                  //Don't clone gaps to a first voice</a>
<a name="ln3411">                  if (!(ne-&gt;track() % VOICES) &amp;&amp; ne-&gt;isRest())</a>
<a name="ln3412">                        toRest(ne)-&gt;setGap(false);</a>
<a name="ln3413"> </a>
<a name="ln3414">                  ne-&gt;setScore(this);</a>
<a name="ln3415">                  ChordRest* ocr = toChordRest(oe);</a>
<a name="ln3416">                  ChordRest* ncr = toChordRest(ne);</a>
<a name="ln3417"> </a>
<a name="ln3418">                  //Handle beams</a>
<a name="ln3419">                  if (ocr-&gt;beam() &amp;&amp; !ocr-&gt;beam()-&gt;empty() &amp;&amp; ocr-&gt;beam()-&gt;elements().front() == ocr) {</a>
<a name="ln3420">                        Beam* nb = ocr-&gt;beam()-&gt;clone();</a>
<a name="ln3421">                        nb-&gt;clear();</a>
<a name="ln3422">                        nb-&gt;setTrack(dtrack);</a>
<a name="ln3423">                        nb-&gt;setScore(this);</a>
<a name="ln3424">                        nb-&gt;add(ncr);</a>
<a name="ln3425">                        ncr-&gt;setBeam(nb);</a>
<a name="ln3426">                        }</a>
<a name="ln3427"> </a>
<a name="ln3428">                  // clone Tuplets</a>
<a name="ln3429">                  Tuplet* ot = ocr-&gt;tuplet();</a>
<a name="ln3430">                  if (ot) {</a>
<a name="ln3431">                        ot-&gt;setTrack(strack);</a>
<a name="ln3432">                        Tuplet* nt = tupletMap.findNew(ot);</a>
<a name="ln3433">                        if (nt == 0) {</a>
<a name="ln3434">                              if (link)</a>
<a name="ln3435">                                    nt = toTuplet(ot-&gt;linkedClone());</a>
<a name="ln3436">                              else</a>
<a name="ln3437">                                    nt = toTuplet(ot-&gt;clone());</a>
<a name="ln3438">                              nt-&gt;setTrack(dtrack);</a>
<a name="ln3439">                              nt-&gt;setParent(dm);</a>
<a name="ln3440">                              tupletMap.add(ot, nt);</a>
<a name="ln3441"> </a>
<a name="ln3442">                              Tuplet* nt1 = nt;</a>
<a name="ln3443">                              while (ot-&gt;tuplet()) {</a>
<a name="ln3444">                                    Tuplet* nt2 = tupletMap.findNew(ot-&gt;tuplet());</a>
<a name="ln3445">                                    if (nt2 == 0) {</a>
<a name="ln3446">                                          if (link)</a>
<a name="ln3447">                                                nt2 = toTuplet(ot-&gt;tuplet()-&gt;linkedClone());</a>
<a name="ln3448">                                          else</a>
<a name="ln3449">                                                nt2 = toTuplet(ot-&gt;tuplet()-&gt;clone());</a>
<a name="ln3450">                                          nt2-&gt;setTrack(dtrack);</a>
<a name="ln3451">                                          nt2-&gt;setParent(dm);</a>
<a name="ln3452">                                          tupletMap.add(ot-&gt;tuplet(), nt2);</a>
<a name="ln3453">                                          }</a>
<a name="ln3454">                                    nt2-&gt;add(nt1);</a>
<a name="ln3455">                                    nt1-&gt;setTuplet(nt2);</a>
<a name="ln3456">                                    ot = ot-&gt;tuplet();</a>
<a name="ln3457">                                    nt1 = nt2;</a>
<a name="ln3458">                                    }</a>
<a name="ln3459">                              }</a>
<a name="ln3460">                        nt-&gt;add(ncr);</a>
<a name="ln3461">                        ncr-&gt;setTuplet(nt);</a>
<a name="ln3462">                        }</a>
<a name="ln3463"> </a>
<a name="ln3464">                  // clone additional settings</a>
<a name="ln3465">                  if (oe-&gt;isChordRest()) {</a>
<a name="ln3466">                        if (oe-&gt;isRest()) {</a>
<a name="ln3467">                              Rest* ore = toRest(ocr);</a>
<a name="ln3468">                              // If we would clone a full measure rest just don't clone this rest</a>
<a name="ln3469">                              if (ore-&gt;isFullMeasureRest() &amp;&amp; (dtrack % VOICES)) {</a>
<a name="ln3470">                                    continue;</a>
<a name="ln3471">                                    }</a>
<a name="ln3472">                              }</a>
<a name="ln3473"> </a>
<a name="ln3474">                        if (oe-&gt;isChord()) {</a>
<a name="ln3475">                              Chord* och = toChord(ocr);</a>
<a name="ln3476">                              Chord* nch = toChord(ncr);</a>
<a name="ln3477"> </a>
<a name="ln3478">                              size_t n = och-&gt;notes().size();</a>
<a name="ln3479">                              for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln3480">                                    Note* on = och-&gt;notes().at(i);</a>
<a name="ln3481">                                    Note* nn = nch-&gt;notes().at(i);</a>
<a name="ln3482">                                    int idx = track2staff(dtrack);</a>
<a name="ln3483">                                    Fraction tick = oseg-&gt;tick();</a>
<a name="ln3484">                                    Interval v = staff(idx) ? staff(idx)-&gt;part()-&gt;instrument(tick)-&gt;transpose() : Interval();</a>
<a name="ln3485">                                    nn-&gt;setTpc1(on-&gt;tpc1());</a>
<a name="ln3486">                                    if (v.isZero())</a>
<a name="ln3487">                                          nn-&gt;setTpc2(on-&gt;tpc1());</a>
<a name="ln3488">                                    else {</a>
<a name="ln3489">                                          v.flip();</a>
<a name="ln3490">                                          nn-&gt;setTpc2(Ms::transposeTpc(nn-&gt;tpc1(), v, true));</a>
<a name="ln3491">                                          }</a>
<a name="ln3492"> </a>
<a name="ln3493">                                    if (on-&gt;tieFor()) {</a>
<a name="ln3494">                                          Tie* tie;</a>
<a name="ln3495">                                          if (link)</a>
<a name="ln3496">                                                tie = toTie(on-&gt;tieFor()-&gt;linkedClone());</a>
<a name="ln3497">                                          else</a>
<a name="ln3498">                                                tie = toTie(on-&gt;tieFor()-&gt;clone());</a>
<a name="ln3499">                                          tie-&gt;setScore(this);</a>
<a name="ln3500">                                          nn-&gt;setTieFor(tie);</a>
<a name="ln3501">                                          tie-&gt;setStartNote(nn);</a>
<a name="ln3502">                                          tie-&gt;setTrack(nn-&gt;track());</a>
<a name="ln3503">                                          tie-&gt;setEndNote(nn);</a>
<a name="ln3504">                                          tieMap.add(on-&gt;tieFor(), tie);</a>
<a name="ln3505">                                          }</a>
<a name="ln3506">                                    if (on-&gt;tieBack()) {</a>
<a name="ln3507">                                          Tie* tie = tieMap.findNew(on-&gt;tieBack());</a>
<a name="ln3508">                                          if (tie) {</a>
<a name="ln3509">                                                nn-&gt;setTieBack(tie);</a>
<a name="ln3510">                                                tie-&gt;setEndNote(nn);</a>
<a name="ln3511">                                                }</a>
<a name="ln3512">                                          else {</a>
<a name="ln3513">                                                qDebug(&quot;cloneVoices: cannot find tie&quot;);</a>
<a name="ln3514">                                                }</a>
<a name="ln3515">                                          }</a>
<a name="ln3516">                                    // add back spanners (going back from end to start spanner element</a>
<a name="ln3517">                                    // makes sure the 'other' spanner anchor element is already set up)</a>
<a name="ln3518">                                    // 'on' is the old spanner end note and 'nn' is the new spanner end note</a>
<a name="ln3519">                                    for (Spanner* oldSp : on-&gt;spannerBack()) {</a>
<a name="ln3520">                                          Note* newStart = Spanner::startElementFromSpanner(oldSp, nn);</a>
<a name="ln3521">                                          if (newStart) {</a>
<a name="ln3522">                                                Spanner* newSp;</a>
<a name="ln3523">                                                if (link)</a>
<a name="ln3524">                                                      newSp = toSpanner(oldSp-&gt;linkedClone());</a>
<a name="ln3525">                                                else</a>
<a name="ln3526">                                                      newSp = toSpanner(oldSp-&gt;clone());</a>
<a name="ln3527">                                                newSp-&gt;setNoteSpan(newStart, nn);</a>
<a name="ln3528">                                                addElement(newSp);</a>
<a name="ln3529">                                                }</a>
<a name="ln3530">                                          else {</a>
<a name="ln3531">                                                qDebug(&quot;cloneVoices: cannot find spanner start note&quot;);</a>
<a name="ln3532">                                                }</a>
<a name="ln3533">                                          }</a>
<a name="ln3534">                                    }</a>
<a name="ln3535">                              // two note tremolo</a>
<a name="ln3536">                              if (och-&gt;tremolo() &amp;&amp; och-&gt;tremolo()-&gt;twoNotes()) {</a>
<a name="ln3537">                                   if (och == och-&gt;tremolo()-&gt;chord1()) {</a>
<a name="ln3538">                                          if (tremolo)</a>
<a name="ln3539">                                                qDebug(&quot;unconnected two note tremolo&quot;);</a>
<a name="ln3540">                                          if (link)</a>
<a name="ln3541">                                                tremolo = toTremolo(och-&gt;tremolo()-&gt;linkedClone());</a>
<a name="ln3542">                                          else</a>
<a name="ln3543">                                                tremolo = toTremolo(och-&gt;tremolo()-&gt;clone());</a>
<a name="ln3544">                                          tremolo-&gt;setScore(nch-&gt;score());</a>
<a name="ln3545">                                          tremolo-&gt;setParent(nch);</a>
<a name="ln3546">                                          tremolo-&gt;setTrack(nch-&gt;track());</a>
<a name="ln3547">                                          tremolo-&gt;setChords(nch, 0);</a>
<a name="ln3548">                                          nch-&gt;setTremolo(tremolo);</a>
<a name="ln3549">                                          }</a>
<a name="ln3550">                                    else if (och == och-&gt;tremolo()-&gt;chord2()) {</a>
<a name="ln3551">                                          if (!tremolo)</a>
<a name="ln3552">                                                qDebug(&quot;first note for two note tremolo missing&quot;);</a>
<a name="ln3553">                                          else {</a>
<a name="ln3554">                                                tremolo-&gt;setChords(tremolo-&gt;chord1(), nch);</a>
<a name="ln3555">                                                nch-&gt;setTremolo(tremolo);</a>
<a name="ln3556">                                                }</a>
<a name="ln3557">                                          }</a>
<a name="ln3558">                                    else</a>
<a name="ln3559">                                          qDebug(&quot;inconsistent two note tremolo&quot;);</a>
<a name="ln3560">                                    }</a>
<a name="ln3561">                              }</a>
<a name="ln3562"> </a>
<a name="ln3563">                        // Add element (link -&gt; just in this measure)</a>
<a name="ln3564">                        if (link) {</a>
<a name="ln3565">                              if (!ns)</a>
<a name="ln3566">                                    ns = dm-&gt;getSegment(oseg-&gt;segmentType(), oseg-&gt;tick());</a>
<a name="ln3567">                              ns-&gt;add(ne);</a>
<a name="ln3568">                              }</a>
<a name="ln3569">                        else {</a>
<a name="ln3570">                              undoAddCR(toChordRest(ne), dm, oseg-&gt;tick());</a>
<a name="ln3571">                              }</a>
<a name="ln3572">                        }</a>
<a name="ln3573">                  }</a>
<a name="ln3574">            Segment* tst = dm-&gt;segments().firstCRSegment();</a>
<a name="ln3575">            if (strack % VOICES &amp;&amp; !(dtrack % VOICES) &amp;&amp; (!tst || (!tst-&gt;element(dtrack)))) {</a>
<a name="ln3576">                  Rest* rest = new Rest(this);</a>
<a name="ln3577">                  rest-&gt;setTicks(dm-&gt;ticks());</a>
<a name="ln3578">                  rest-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln3579">                  rest-&gt;setTrack(dtrack);</a>
<a name="ln3580">                  if (link) {</a>
<a name="ln3581">                        Segment* segment = dm-&gt;getSegment(SegmentType::ChordRest, dm-&gt;tick());</a>
<a name="ln3582">                        segment-&gt;add(rest);</a>
<a name="ln3583">                        }</a>
<a name="ln3584">                  else</a>
<a name="ln3585">                        undoAddCR(toChordRest(rest), dm, dm-&gt;tick());</a>
<a name="ln3586">                  }</a>
<a name="ln3587">            }</a>
<a name="ln3588"> </a>
<a name="ln3589">      if (spanner) {</a>
<a name="ln3590">            // Find and add corresponding slurs</a>
<a name="ln3591">            auto spanners = score-&gt;spannerMap().findOverlapping(start.ticks(), lTick.ticks());</a>
<a name="ln3592">            for (auto i = spanners.begin(); i &lt; spanners.end(); i++) {</a>
<a name="ln3593">                  Spanner* sp      = i-&gt;value;</a>
<a name="ln3594">                  Fraction spStart = sp-&gt;tick();</a>
<a name="ln3595">                  int track        = sp-&gt;track();</a>
<a name="ln3596">                  int track2       = sp-&gt;track2();</a>
<a name="ln3597">                  Fraction spEnd   = spStart + sp-&gt;ticks();</a>
<a name="ln3598"> </a>
<a name="ln3599">                  if (sp-&gt;isSlur() &amp;&amp; (spStart &gt;= start &amp;&amp; spEnd &lt; lTick)) {</a>
<a name="ln3600">                        if (track == strack &amp;&amp; track2 == strack){</a>
<a name="ln3601">                              Spanner* ns = toSpanner(link ? sp-&gt;linkedClone() : sp-&gt;clone());</a>
<a name="ln3602"> </a>
<a name="ln3603">                              ns-&gt;setScore(this);</a>
<a name="ln3604">                              ns-&gt;setParent(0);</a>
<a name="ln3605">                              ns-&gt;setTrack(dtrack);</a>
<a name="ln3606">                              ns-&gt;setTrack2(dtrack);</a>
<a name="ln3607"> </a>
<a name="ln3608">                              // set start/end element for slur</a>
<a name="ln3609">                              ChordRest* cr1 = sp-&gt;startCR();</a>
<a name="ln3610">                              ChordRest* cr2 = sp-&gt;endCR();</a>
<a name="ln3611"> </a>
<a name="ln3612">                              ns-&gt;setStartElement(0);</a>
<a name="ln3613">                              ns-&gt;setEndElement(0);</a>
<a name="ln3614">                              if (cr1 &amp;&amp; cr1-&gt;links()) {</a>
<a name="ln3615">                                    for (ScoreElement* e : *cr1-&gt;links()) {</a>
<a name="ln3616">                                          ChordRest* cr = toChordRest(e);</a>
<a name="ln3617">                                          if (cr == cr1)</a>
<a name="ln3618">                                                continue;</a>
<a name="ln3619">                                          if ((cr-&gt;score() == this) &amp;&amp; (cr-&gt;tick() == ns-&gt;tick()) &amp;&amp; cr-&gt;track() == dtrack) {</a>
<a name="ln3620">                                                ns-&gt;setStartElement(cr);</a>
<a name="ln3621">                                                break;</a>
<a name="ln3622">                                                }</a>
<a name="ln3623">                                          }</a>
<a name="ln3624">                                    }</a>
<a name="ln3625">                              if (cr2 &amp;&amp; cr2-&gt;links()) {</a>
<a name="ln3626">                                    for (ScoreElement* e : *cr2-&gt;links()) {</a>
<a name="ln3627">                                          ChordRest* cr = toChordRest(e);</a>
<a name="ln3628">                                          if (cr == cr2)</a>
<a name="ln3629">                                                continue;</a>
<a name="ln3630">                                          if ((cr-&gt;score() == this) &amp;&amp; (cr-&gt;tick() == ns-&gt;tick2()) &amp;&amp; cr-&gt;track() == dtrack) {</a>
<a name="ln3631">                                                ns-&gt;setEndElement(cr);</a>
<a name="ln3632">                                                break;</a>
<a name="ln3633">                                                }</a>
<a name="ln3634">                                          }</a>
<a name="ln3635">                                    }</a>
<a name="ln3636">                              undo(new AddElement(ns));</a>
<a name="ln3637">                              }</a>
<a name="ln3638">                        }</a>
<a name="ln3639">                  }</a>
<a name="ln3640">            }</a>
<a name="ln3641"> </a>
<a name="ln3642">      //Layout</a>
<a name="ln3643">//TODO ??      doLayoutRange(start, lTick);</a>
<a name="ln3644">      }</a>
<a name="ln3645"> </a>
<a name="ln3646">//---------------------------------------------------------</a>
<a name="ln3647">//   undoPropertyChanged</a>
<a name="ln3648">//    return true if an property was actually changed</a>
<a name="ln3649">//---------------------------------------------------------</a>
<a name="ln3650"> </a>
<a name="ln3651">bool Score::undoPropertyChanged(Element* e, Pid t, const QVariant&amp; st, PropertyFlags ps)</a>
<a name="ln3652">      {</a>
<a name="ln3653">      bool changed = false;</a>
<a name="ln3654"> </a>
<a name="ln3655">      if (propertyLink(t) &amp;&amp; e-&gt;links()) {</a>
<a name="ln3656">            for (ScoreElement* ee : *e-&gt;links()) {</a>
<a name="ln3657">                  if (ee == e) {</a>
<a name="ln3658">                        if (ee-&gt;getProperty(t) != st) {</a>
<a name="ln3659">                              undoStack()-&gt;push1(new ChangeProperty(ee, t, st, ps));</a>
<a name="ln3660">                              changed = true;</a>
<a name="ln3661">                              }</a>
<a name="ln3662">                        }</a>
<a name="ln3663">                  else {</a>
<a name="ln3664">                        // property in linked element has not changed yet</a>
<a name="ln3665">                        // push() calls redo() to change it</a>
<a name="ln3666">                        if (ee-&gt;getProperty(t) != e-&gt;getProperty(t)) {</a>
<a name="ln3667">                              undoStack()-&gt;push(new ChangeProperty(ee, t, e-&gt;getProperty(t), ps), 0);</a>
<a name="ln3668">                              changed = true;</a>
<a name="ln3669">                              }</a>
<a name="ln3670">                        }</a>
<a name="ln3671">                  }</a>
<a name="ln3672">            }</a>
<a name="ln3673">      else {</a>
<a name="ln3674">            PropertyFlags po = e-&gt;propertyFlags(t);</a>
<a name="ln3675">            if ((e-&gt;getProperty(t) != st) || (ps != po)) {</a>
<a name="ln3676">                  e-&gt;setPropertyFlags(t, ps);</a>
<a name="ln3677">                  undoStack()-&gt;push1(new ChangeProperty(e, t, st, po));</a>
<a name="ln3678">                  changed = true;</a>
<a name="ln3679">                  }</a>
<a name="ln3680">            }</a>
<a name="ln3681">      return changed;</a>
<a name="ln3682">      }</a>
<a name="ln3683"> </a>
<a name="ln3684">void Score::undoPropertyChanged(ScoreElement* e, Pid t, const QVariant&amp; st, PropertyFlags ps)</a>
<a name="ln3685">      {</a>
<a name="ln3686">      if (e-&gt;getProperty(t) != st)</a>
<a name="ln3687">            undoStack()-&gt;push1(new ChangeProperty(e, t, st, ps));</a>
<a name="ln3688">      }</a>
<a name="ln3689"> </a>
<a name="ln3690">//---------------------------------------------------------</a>
<a name="ln3691">//   undoChangeStyleVal</a>
<a name="ln3692">//---------------------------------------------------------</a>
<a name="ln3693"> </a>
<a name="ln3694">void Score::undoChangeStyleVal(Sid idx, const QVariant&amp; v)</a>
<a name="ln3695">      {</a>
<a name="ln3696">      undo(new ChangeStyleVal(this, idx, v));</a>
<a name="ln3697">      }</a>
<a name="ln3698"> </a>
<a name="ln3699">//---------------------------------------------------------</a>
<a name="ln3700">//   undoChangePageNumberOffset</a>
<a name="ln3701">//---------------------------------------------------------</a>
<a name="ln3702"> </a>
<a name="ln3703">void Score::undoChangePageNumberOffset(int po)</a>
<a name="ln3704">      {</a>
<a name="ln3705">      undo(new ChangePageNumberOffset(this, po));</a>
<a name="ln3706">      }</a>
<a name="ln3707"> </a>
<a name="ln3708">//---------------------------------------------------------</a>
<a name="ln3709">//   undoChangeElement</a>
<a name="ln3710">//---------------------------------------------------------</a>
<a name="ln3711"> </a>
<a name="ln3712">void Score::undoChangeElement(Element* oldElement, Element* newElement)</a>
<a name="ln3713">      {</a>
<a name="ln3714">      if (!oldElement)</a>
<a name="ln3715">            undoAddElement(newElement);</a>
<a name="ln3716">      else</a>
<a name="ln3717">            undo(new ChangeElement(oldElement, newElement));</a>
<a name="ln3718">      }</a>
<a name="ln3719"> </a>
<a name="ln3720">//---------------------------------------------------------</a>
<a name="ln3721">//   undoChangePitch</a>
<a name="ln3722">//---------------------------------------------------------</a>
<a name="ln3723"> </a>
<a name="ln3724">void Score::undoChangePitch(Note* note, int pitch, int tpc1, int tpc2)</a>
<a name="ln3725">      {</a>
<a name="ln3726">      for (ScoreElement* e : note-&gt;linkList()) {</a>
<a name="ln3727">            Note* n = toNote(e);</a>
<a name="ln3728">            undoStack()-&gt;push(new ChangePitch(n, pitch, tpc1, tpc2), 0);</a>
<a name="ln3729">            }</a>
<a name="ln3730">      }</a>
<a name="ln3731"> </a>
<a name="ln3732">//---------------------------------------------------------</a>
<a name="ln3733">//   undoChangeFretting</a>
<a name="ln3734">//</a>
<a name="ln3735">//    To use with tablatures to force a specific note fretting;</a>
<a name="ln3736">//    Pitch, string and fret must be changed all together; otherwise,</a>
<a name="ln3737">//    if they are not consistent among themselves, the refretting algorithm may re-assign</a>
<a name="ln3738">//    fret and string numbers for (potentially) all the notes of all the chords of a segment.</a>
<a name="ln3739">//---------------------------------------------------------</a>
<a name="ln3740"> </a>
<a name="ln3741">void Score::undoChangeFretting(Note* note, int pitch, int string, int fret, int tpc1, int tpc2)</a>
<a name="ln3742">      {</a>
<a name="ln3743">      const LinkedElements* l = note-&gt;links();</a>
<a name="ln3744">      if (l) {</a>
<a name="ln3745">            for (ScoreElement* e : *l) {</a>
<a name="ln3746">                  Note* n = toNote(e);</a>
<a name="ln3747">                  undo(new ChangeFretting(n, pitch, string, fret, tpc1, tpc2));</a>
<a name="ln3748">                  }</a>
<a name="ln3749">            }</a>
<a name="ln3750">      else</a>
<a name="ln3751">            undo(new ChangeFretting(note, pitch, string, fret, tpc1, tpc2));</a>
<a name="ln3752">      }</a>
<a name="ln3753"> </a>
<a name="ln3754">//---------------------------------------------------------</a>
<a name="ln3755">//   undoChangeKeySig</a>
<a name="ln3756">//---------------------------------------------------------</a>
<a name="ln3757"> </a>
<a name="ln3758">void Score::undoChangeKeySig(Staff* ostaff, const Fraction&amp; tick, KeySigEvent key)</a>
<a name="ln3759">      {</a>
<a name="ln3760">      KeySig* lks = 0;</a>
<a name="ln3761"> </a>
<a name="ln3762">      for (Staff* staff : ostaff-&gt;staffList()) {</a>
<a name="ln3763">            if (staff-&gt;isDrumStaff(tick))</a>
<a name="ln3764">                  continue;</a>
<a name="ln3765"> </a>
<a name="ln3766">            Score* score = staff-&gt;score();</a>
<a name="ln3767">            Measure* measure = score-&gt;tick2measure(tick);</a>
<a name="ln3768">            if (!measure) {</a>
<a name="ln3769">                  qWarning(&quot;measure for tick %d not found!&quot;, tick.ticks());</a>
<a name="ln3770">                  continue;</a>
<a name="ln3771">                  }</a>
<a name="ln3772">            Segment* s   = measure-&gt;undoGetSegment(SegmentType::KeySig, tick);</a>
<a name="ln3773"> </a>
<a name="ln3774">            int staffIdx = staff-&gt;idx();</a>
<a name="ln3775">            int track    = staffIdx * VOICES;</a>
<a name="ln3776">            KeySig* ks   = toKeySig(s-&gt;element(track));</a>
<a name="ln3777"> </a>
<a name="ln3778">            Interval interval = staff-&gt;part()-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln3779">            KeySigEvent nkey  = key;</a>
<a name="ln3780">            bool concertPitch = score-&gt;styleB(Sid::concertPitch);</a>
<a name="ln3781">            if (interval.chromatic &amp;&amp; !concertPitch &amp;&amp; !nkey.custom() &amp;&amp; !nkey.isAtonal()) {</a>
<a name="ln3782">                  interval.flip();</a>
<a name="ln3783">                  nkey.setKey(transposeKey(key.key(), interval, staff-&gt;part()-&gt;preferSharpFlat()));</a>
<a name="ln3784">                  }</a>
<a name="ln3785">            if (ks) {</a>
<a name="ln3786">                  ks-&gt;undoChangeProperty(Pid::GENERATED, false);</a>
<a name="ln3787">                  undo(new ChangeKeySig(ks, nkey, ks-&gt;showCourtesy()));</a>
<a name="ln3788">                  }</a>
<a name="ln3789">            else {</a>
<a name="ln3790">                  // do not create empty keysig unless custom or atonal</a>
<a name="ln3791">                  if (tick.isNotZero() || nkey.key() != Key::C || nkey.custom() || nkey.isAtonal()) {</a>
<a name="ln3792">                        KeySig* nks = new KeySig(score);</a>
<a name="ln3793">                        nks-&gt;setParent(s);</a>
<a name="ln3794">                        nks-&gt;setTrack(track);</a>
<a name="ln3795">                        nks-&gt;setKeySigEvent(nkey);</a>
<a name="ln3796">                        undo(new AddElement(nks));</a>
<a name="ln3797">                        if (lks)</a>
<a name="ln3798">                              undo(new Link(lks, nks));</a>
<a name="ln3799">                        else</a>
<a name="ln3800">                              lks = nks;</a>
<a name="ln3801">                        }</a>
<a name="ln3802">                  }</a>
<a name="ln3803">            }</a>
<a name="ln3804">      }</a>
<a name="ln3805"> </a>
<a name="ln3806">//---------------------------------------------------------</a>
<a name="ln3807">//   undoChangeClef</a>
<a name="ln3808">//    change clef if e is a clef</a>
<a name="ln3809">//    else</a>
<a name="ln3810">//    create a clef before element e</a>
<a name="ln3811">//---------------------------------------------------------</a>
<a name="ln3812"> </a>
<a name="ln3813">void Score::undoChangeClef(Staff* ostaff, Element* e, ClefType ct)</a>
<a name="ln3814">      {</a>
<a name="ln3815">      bool moveClef = false;</a>
<a name="ln3816">      SegmentType st = SegmentType::Clef;</a>
<a name="ln3817">      if (e-&gt;isMeasure()) {</a>
<a name="ln3818">            if (toMeasure(e)-&gt;prevMeasure())</a>
<a name="ln3819">                  moveClef = true;</a>
<a name="ln3820">            else</a>
<a name="ln3821">                  st = SegmentType::HeaderClef;</a>
<a name="ln3822">            }</a>
<a name="ln3823">      else if (e-&gt;isClef()) {</a>
<a name="ln3824">            Clef* clef = toClef(e);</a>
<a name="ln3825">            if (clef-&gt;segment()-&gt;isHeaderClefType()) {</a>
<a name="ln3826">                  if (clef-&gt;measure()-&gt;prevMeasure())</a>
<a name="ln3827">                        moveClef = true;</a>
<a name="ln3828">                  else</a>
<a name="ln3829">                        st = SegmentType::HeaderClef;</a>
<a name="ln3830">                  }</a>
<a name="ln3831">            else if (clef-&gt;rtick() == clef-&gt;measure()-&gt;ticks())</a>
<a name="ln3832">                  moveClef = true;</a>
<a name="ln3833">            }</a>
<a name="ln3834"> </a>
<a name="ln3835">      Clef* gclef = 0;</a>
<a name="ln3836">      Fraction tick = e-&gt;tick();</a>
<a name="ln3837">      Fraction rtick = e-&gt;rtick();</a>
<a name="ln3838">      bool small = (st == SegmentType::Clef);</a>
<a name="ln3839">      for (Staff* staff : ostaff-&gt;staffList()) {</a>
<a name="ln3840">            if (staff-&gt;staffType(tick)-&gt;group() != ClefInfo::staffGroup(ct))</a>
<a name="ln3841">                  continue;</a>
<a name="ln3842"> </a>
<a name="ln3843">            Score* score     = staff-&gt;score();</a>
<a name="ln3844">            Measure* measure = score-&gt;tick2measure(tick);</a>
<a name="ln3845"> </a>
<a name="ln3846">            if (!measure) {</a>
<a name="ln3847">                  qWarning(&quot;measure for tick %d not found!&quot;, tick.ticks());</a>
<a name="ln3848">                  continue;</a>
<a name="ln3849">                  }</a>
<a name="ln3850"> </a>
<a name="ln3851">            Segment* destSeg;</a>
<a name="ln3852">            Fraction rt;</a>
<a name="ln3853">            if (moveClef) {            // if at start of measure and there is a previous measure</a>
<a name="ln3854">                  measure = measure-&gt;prevMeasure();</a>
<a name="ln3855">                  rt      = measure-&gt;ticks();</a>
<a name="ln3856">                  }</a>
<a name="ln3857">            else</a>
<a name="ln3858">                  rt = rtick;</a>
<a name="ln3859">            destSeg = measure-&gt;undoGetSegmentR(st, rt);</a>
<a name="ln3860"> </a>
<a name="ln3861">            int staffIdx = staff-&gt;idx();</a>
<a name="ln3862">            int track    = staffIdx * VOICES;</a>
<a name="ln3863">            Clef* clef   = toClef(destSeg-&gt;element(track));</a>
<a name="ln3864"> </a>
<a name="ln3865">            if (clef) {</a>
<a name="ln3866">                  //</a>
<a name="ln3867">                  // for transposing instruments, differentiate</a>
<a name="ln3868">                  // clef type for concertPitch</a>
<a name="ln3869">                  //</a>
<a name="ln3870">                  Instrument* i = staff-&gt;part()-&gt;instrument(tick);</a>
<a name="ln3871">                  ClefType cp, tp;</a>
<a name="ln3872">                  if (i-&gt;transpose().isZero()) {</a>
<a name="ln3873">                        cp = ct;</a>
<a name="ln3874">                        tp = ct;</a>
<a name="ln3875">                        }</a>
<a name="ln3876">                  else {</a>
<a name="ln3877">                        bool concertPitch = clef-&gt;concertPitch();</a>
<a name="ln3878">                        if (concertPitch) {</a>
<a name="ln3879">                              cp = ct;</a>
<a name="ln3880">                              tp = clef-&gt;transposingClef();</a>
<a name="ln3881">                              }</a>
<a name="ln3882">                        else {</a>
<a name="ln3883">                              cp = clef-&gt;concertClef();</a>
<a name="ln3884">                              tp = ct;</a>
<a name="ln3885">                              }</a>
<a name="ln3886">                        }</a>
<a name="ln3887">                  clef-&gt;setGenerated(false);</a>
<a name="ln3888">                  score-&gt;undo(new ChangeClefType(clef, cp, tp));</a>
<a name="ln3889">                  // change the clef in the mmRest if any</a>
<a name="ln3890">                  if (measure-&gt;hasMMRest()) {</a>
<a name="ln3891">                        Measure* mmMeasure = measure-&gt;mmRest();</a>
<a name="ln3892">                        Segment* mmDestSeg = mmMeasure-&gt;findSegment(SegmentType::Clef, tick);</a>
<a name="ln3893">                        if (mmDestSeg) {</a>
<a name="ln3894">                              Clef* mmClef = toClef(mmDestSeg-&gt;element(clef-&gt;track()));</a>
<a name="ln3895">                              if (mmClef)</a>
<a name="ln3896">                                    score-&gt;undo(new ChangeClefType(mmClef, cp, tp));</a>
<a name="ln3897">                              }</a>
<a name="ln3898">                        }</a>
<a name="ln3899">                  }</a>
<a name="ln3900">            else {</a>
<a name="ln3901">                  if (gclef) {</a>
<a name="ln3902">                        clef = toClef(gclef-&gt;linkedClone());</a>
<a name="ln3903">                        clef-&gt;setScore(score);</a>
<a name="ln3904">                        }</a>
<a name="ln3905">                  else {</a>
<a name="ln3906">                        clef = new Clef(score);</a>
<a name="ln3907">                        gclef = clef;</a>
<a name="ln3908">                        }</a>
<a name="ln3909">                  clef-&gt;setTrack(track);</a>
<a name="ln3910">                  clef-&gt;setClefType(ct);</a>
<a name="ln3911">                  clef-&gt;setParent(destSeg);</a>
<a name="ln3912">                  score-&gt;undo(new AddElement(clef));</a>
<a name="ln3913">                  clef-&gt;layout();</a>
<a name="ln3914">                  }</a>
<a name="ln3915">            clef-&gt;setSmall(small);</a>
<a name="ln3916">            }</a>
<a name="ln3917">      }</a>
<a name="ln3918"> </a>
<a name="ln3919">//---------------------------------------------------------</a>
<a name="ln3920">//   findLinkedVoiceElement</a>
<a name="ln3921">//---------------------------------------------------------</a>
<a name="ln3922"> </a>
<a name="ln3923">static Element* findLinkedVoiceElement(Element* e, Staff* nstaff)</a>
<a name="ln3924">      {</a>
<a name="ln3925">      Excerpt* se = e-&gt;score()-&gt;excerpt();</a>
<a name="ln3926">      Excerpt* de = nstaff-&gt;score()-&gt;excerpt();</a>
<a name="ln3927">      int strack = e-&gt;track();</a>
<a name="ln3928">      int dtrack = nstaff-&gt;idx() * VOICES + e-&gt;voice();</a>
<a name="ln3929"> </a>
<a name="ln3930">      if (se)</a>
<a name="ln3931">            strack = se-&gt;tracks().key(strack);</a>
<a name="ln3932"> </a>
<a name="ln3933">      if (de) {</a>
<a name="ln3934">            QList&lt;int&gt; l = de-&gt;tracks().values(strack);</a>
<a name="ln3935">            if (l.isEmpty()) {</a>
<a name="ln3936">                  // simply return the first linked element whose staff is equal to nstaff</a>
<a name="ln3937">                  for (ScoreElement* ee : e-&gt;linkList()) {</a>
<a name="ln3938">                        Element* el = toElement(ee);</a>
<a name="ln3939">                        if (el-&gt;staff() == nstaff)</a>
<a name="ln3940">                              return el;</a>
<a name="ln3941">                        }</a>
<a name="ln3942">                  return 0;</a>
<a name="ln3943">                  }</a>
<a name="ln3944">            for (int i : l) {</a>
<a name="ln3945">                  if (nstaff-&gt;idx() * VOICES &lt;= i &amp;&amp; (nstaff-&gt;idx() + 1) * VOICES &gt; i) {</a>
<a name="ln3946">                        dtrack = i;</a>
<a name="ln3947">                        break;</a>
<a name="ln3948">                        }</a>
<a name="ln3949">                  }</a>
<a name="ln3950">            }</a>
<a name="ln3951"> </a>
<a name="ln3952">      Score* score     = nstaff-&gt;score();</a>
<a name="ln3953">      Segment* segment = toSegment(e-&gt;parent());</a>
<a name="ln3954">      Measure* measure = segment-&gt;measure();</a>
<a name="ln3955">      Measure* m       = score-&gt;tick2measure(measure-&gt;tick());</a>
<a name="ln3956">      Segment* s       = m-&gt;findSegment(segment-&gt;segmentType(), segment-&gt;tick());</a>
<a name="ln3957">      return s-&gt;element(dtrack);</a>
<a name="ln3958">      }</a>
<a name="ln3959"> </a>
<a name="ln3960">//---------------------------------------------------------</a>
<a name="ln3961">//   findLinkedChord</a>
<a name="ln3962">//---------------------------------------------------------</a>
<a name="ln3963"> </a>
<a name="ln3964">static Chord* findLinkedChord(Chord* c, Staff* nstaff)</a>
<a name="ln3965">      {</a>
<a name="ln3966">      Excerpt* se = c-&gt;score()-&gt;excerpt();</a>
<a name="ln3967">      Excerpt* de = nstaff-&gt;score()-&gt;excerpt();</a>
<a name="ln3968">      int strack = c-&gt;track();</a>
<a name="ln3969">      int dtrack = nstaff-&gt;idx() * VOICES + c-&gt;voice();</a>
<a name="ln3970"> </a>
<a name="ln3971">      if (se)</a>
<a name="ln3972">            strack = se-&gt;tracks().key(strack);</a>
<a name="ln3973"> </a>
<a name="ln3974">      if (de) {</a>
<a name="ln3975">            QList&lt;int&gt; l = de-&gt;tracks().values(strack);</a>
<a name="ln3976">            if (l.isEmpty()) {</a>
<a name="ln3977">                  // simply return the first linked chord whose staff is equal to nstaff</a>
<a name="ln3978">                  for (ScoreElement* ee : c-&gt;linkList()) {</a>
<a name="ln3979">                        Chord* ch = toChord(ee);</a>
<a name="ln3980">                        if (ch-&gt;staff() == nstaff)</a>
<a name="ln3981">                              return ch;</a>
<a name="ln3982">                        }</a>
<a name="ln3983">                  return 0;</a>
<a name="ln3984">                  }</a>
<a name="ln3985">            for (int i : l) {</a>
<a name="ln3986">                  if (nstaff-&gt;idx() * VOICES &lt;= i &amp;&amp; (nstaff-&gt;idx() + 1) * VOICES &gt; i) {</a>
<a name="ln3987">                        dtrack = i;</a>
<a name="ln3988">                        break;</a>
<a name="ln3989">                        }</a>
<a name="ln3990">                  }</a>
<a name="ln3991">            }</a>
<a name="ln3992"> </a>
<a name="ln3993">      Segment* s  = c-&gt;segment();</a>
<a name="ln3994">      Measure* nm = nstaff-&gt;score()-&gt;tick2measure(s-&gt;tick());</a>
<a name="ln3995">      Segment* ns = nm-&gt;findSegment(s-&gt;segmentType(), s-&gt;tick());</a>
<a name="ln3996">      Element* ne = ns-&gt;element(dtrack);</a>
<a name="ln3997">      if (!ne-&gt;isChord())</a>
<a name="ln3998">            return 0;</a>
<a name="ln3999">      Chord* nc = toChord(ne);</a>
<a name="ln4000">      if (c-&gt;isGrace()) {</a>
<a name="ln4001">            Chord* pc = toChord(c-&gt;parent());</a>
<a name="ln4002">            int index = 0;</a>
<a name="ln4003">            for (Chord* gc : pc-&gt;graceNotes()) {</a>
<a name="ln4004">                  if (c == gc)</a>
<a name="ln4005">                        break;</a>
<a name="ln4006">                  index++;</a>
<a name="ln4007">                  }</a>
<a name="ln4008">            if (index &lt; nc-&gt;graceNotes().length())</a>
<a name="ln4009">                  nc = nc-&gt;graceNotes().at(index);</a>
<a name="ln4010">            }</a>
<a name="ln4011">      return nc;</a>
<a name="ln4012">      }</a>
<a name="ln4013"> </a>
<a name="ln4014">//---------------------------------------------------------</a>
<a name="ln4015">//   undoChangeChordRestLen</a>
<a name="ln4016">//---------------------------------------------------------</a>
<a name="ln4017"> </a>
<a name="ln4018">void Score::undoChangeChordRestLen(ChordRest* cr, const TDuration&amp; d)</a>
<a name="ln4019">      {</a>
<a name="ln4020">      auto sl = cr-&gt;staff()-&gt;staffList();</a>
<a name="ln4021">      for (Staff* staff : sl) {</a>
<a name="ln4022">            ChordRest *ncr;</a>
<a name="ln4023">            if (cr-&gt;isGrace())</a>
<a name="ln4024">                  ncr = findLinkedChord(toChord(cr), staff);</a>
<a name="ln4025">            else</a>
<a name="ln4026">                  ncr = toChordRest(findLinkedVoiceElement(cr, staff));</a>
<a name="ln4027">            if (!ncr)</a>
<a name="ln4028">                  continue;</a>
<a name="ln4029">            ncr-&gt;undoChangeProperty(Pid::DURATION_TYPE, QVariant::fromValue(d));</a>
<a name="ln4030">            ncr-&gt;undoChangeProperty(Pid::DURATION, QVariant::fromValue(d.fraction()));</a>
<a name="ln4031">            }</a>
<a name="ln4032">      }</a>
<a name="ln4033"> </a>
<a name="ln4034">//---------------------------------------------------------</a>
<a name="ln4035">//   undoTransposeHarmony</a>
<a name="ln4036">//---------------------------------------------------------</a>
<a name="ln4037"> </a>
<a name="ln4038">void Score::undoTransposeHarmony(Harmony* h, int rootTpc, int baseTpc)</a>
<a name="ln4039">      {</a>
<a name="ln4040">      undo(new TransposeHarmony(h, rootTpc, baseTpc));</a>
<a name="ln4041">      }</a>
<a name="ln4042"> </a>
<a name="ln4043">//---------------------------------------------------------</a>
<a name="ln4044">//   undoExchangeVoice</a>
<a name="ln4045">//---------------------------------------------------------</a>
<a name="ln4046"> </a>
<a name="ln4047">void Score::undoExchangeVoice(Measure* measure, int srcVoice, int dstVoice, int srcStaff, int dstStaff)</a>
<a name="ln4048">      {</a>
<a name="ln4049">      Fraction tick = measure-&gt;tick();</a>
<a name="ln4050"> </a>
<a name="ln4051">      for (int staffIdx = srcStaff; staffIdx &lt; dstStaff; ++staffIdx) {</a>
<a name="ln4052">            QSet&lt;Staff*&gt; staffList;</a>
<a name="ln4053">            for (Staff* s : staff(staffIdx)-&gt;staffList())</a>
<a name="ln4054">                  staffList.insert(s);</a>
<a name="ln4055"> </a>
<a name="ln4056">            int srcStaffTrack = staffIdx * VOICES;</a>
<a name="ln4057">            int srcTrack = srcStaffTrack + srcVoice;</a>
<a name="ln4058">            int dstTrack = srcStaffTrack + dstVoice;</a>
<a name="ln4059">            int trackDiff = dstVoice - srcVoice;</a>
<a name="ln4060"> </a>
<a name="ln4061">            //handle score and complete measures first</a>
<a name="ln4062">            undo(new ExchangeVoice(measure, srcTrack, dstTrack, staffIdx));</a>
<a name="ln4063"> </a>
<a name="ln4064">            for (Staff* st : staffList) {</a>
<a name="ln4065">                  int staffTrack = st-&gt;idx() * VOICES;</a>
<a name="ln4066">                  Measure* measure2 = st-&gt;score()-&gt;tick2measure(tick);</a>
<a name="ln4067">                  Excerpt* ex = st-&gt;score()-&gt;excerpt();</a>
<a name="ln4068"> </a>
<a name="ln4069">                  if (ex) {</a>
<a name="ln4070">                        QMultiMap&lt;int, int&gt; tracks = ex-&gt;tracks();</a>
<a name="ln4071">                        QList&lt;int&gt; srcTrackList = tracks.values(srcTrack);</a>
<a name="ln4072">                        QList&lt;int&gt; dstTrackList = tracks.values(dstTrack);</a>
<a name="ln4073"> </a>
<a name="ln4074">                        for (int srcTrack2 : srcTrackList) {</a>
<a name="ln4075">                              // don't care about other linked staves</a>
<a name="ln4076">                              if (!(staffTrack &lt;= srcTrack2) || !(srcTrack2 &lt; staffTrack + VOICES))</a>
<a name="ln4077">                                    continue;</a>
<a name="ln4078"> </a>
<a name="ln4079">                              int tempTrack = tracks.key(srcTrack2);</a>
<a name="ln4080">                              QList&lt;int&gt; testTracks = tracks.values(tempTrack + trackDiff);</a>
<a name="ln4081">                              bool hasVoice = false;</a>
<a name="ln4082">                              for (int testTrack : testTracks) {</a>
<a name="ln4083">                                    if (staffTrack &lt;= testTrack &amp;&amp; testTrack &lt; staffTrack + VOICES &amp;&amp; dstTrackList.contains(testTrack)) {</a>
<a name="ln4084">                                          hasVoice = true;</a>
<a name="ln4085">                                          // voice is simply exchangeable now (deal directly)</a>
<a name="ln4086">                                          undo(new ExchangeVoice(measure2, srcTrack2, testTrack, staffTrack / 4));</a>
<a name="ln4087">                                          }</a>
<a name="ln4088">                                    }</a>
<a name="ln4089"> </a>
<a name="ln4090">                              // only source voice is in this staff</a>
<a name="ln4091">                              if (!hasVoice) {</a>
<a name="ln4092">                                    undo(new CloneVoice(measure-&gt;first(), measure2-&gt;endTick(), measure2-&gt;first(), tempTrack, srcTrack2, tempTrack + trackDiff));</a>
<a name="ln4093">                                    srcTrackList.removeOne(srcTrack2);</a>
<a name="ln4094">                                    }</a>
<a name="ln4095">                              }</a>
<a name="ln4096"> </a>
<a name="ln4097">                        for (int dstTrack2 : dstTrackList) {</a>
<a name="ln4098">                              // don't care about other linked staves</a>
<a name="ln4099">                              if (!(staffTrack &lt;= dstTrack2) || !(dstTrack2 &lt; staffTrack + VOICES))</a>
<a name="ln4100">                                    continue;</a>
<a name="ln4101"> </a>
<a name="ln4102">                              int tempTrack = tracks.key(dstTrack2);</a>
<a name="ln4103">                              QList&lt;int&gt; testTracks = tracks.values(tempTrack - trackDiff);</a>
<a name="ln4104">                              bool hasVoice = false;</a>
<a name="ln4105">                              for (int testTrack : testTracks) {</a>
<a name="ln4106">                                    if (staffTrack &lt;= testTrack &amp;&amp; testTrack &lt; staffTrack + VOICES &amp;&amp;</a>
<a name="ln4107">                                        srcTrackList.contains(testTrack))</a>
<a name="ln4108">                                          hasVoice = true;</a>
<a name="ln4109">                                    }</a>
<a name="ln4110"> </a>
<a name="ln4111">                              // only destination voice is in this staff</a>
<a name="ln4112">                              if (!hasVoice) {</a>
<a name="ln4113">                                    undo(new CloneVoice(measure-&gt;first(), measure2-&gt;endTick(), measure2-&gt;first(), tempTrack, dstTrack2, tempTrack - trackDiff));</a>
<a name="ln4114">                                    dstTrackList.removeOne(dstTrack2);</a>
<a name="ln4115">                                    }</a>
<a name="ln4116">                              }</a>
<a name="ln4117">                        }</a>
<a name="ln4118">                  else if (srcStaffTrack != staffTrack) {</a>
<a name="ln4119">                        // linked staff in same score (all voices present can be assumed)</a>
<a name="ln4120">                        undo(new ExchangeVoice(measure2, staffTrack + srcVoice, staffTrack + dstVoice, st-&gt;idx()));</a>
<a name="ln4121">                        }</a>
<a name="ln4122">                  }</a>
<a name="ln4123">            }</a>
<a name="ln4124"> </a>
<a name="ln4125">      // make sure voice 0 is complete</a>
<a name="ln4126"> </a>
<a name="ln4127">      if (srcVoice == 0 || dstVoice == 0) {</a>
<a name="ln4128">            for (int staffIdx = srcStaff; staffIdx &lt; dstStaff; ++staffIdx) {</a>
<a name="ln4129">                  // check for complete timeline of voice 0</a>
<a name="ln4130">                  Fraction ctick  = measure-&gt;tick();</a>
<a name="ln4131">                  int track = staffIdx * VOICES;</a>
<a name="ln4132">                  for (Segment* s = measure-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln4133">                        ChordRest* cr = toChordRest(s-&gt;element(track));</a>
<a name="ln4134">                        if (cr == 0)</a>
<a name="ln4135">                              continue;</a>
<a name="ln4136">                        if (cr-&gt;isRest()) {</a>
<a name="ln4137">                              Rest* r = toRest(cr);</a>
<a name="ln4138">                              if (r-&gt;isGap())</a>
<a name="ln4139">                                    r-&gt;undoChangeProperty(Pid::GAP, false);</a>
<a name="ln4140">                              }</a>
<a name="ln4141">                        if (ctick &lt; s-&gt;tick())</a>
<a name="ln4142">                              setRest(ctick, track, s-&gt;tick() - ctick, false, 0);   // fill gap</a>
<a name="ln4143">                        ctick = s-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln4144">                        }</a>
<a name="ln4145">                  Fraction etick = measure-&gt;endTick();</a>
<a name="ln4146">                  if (ctick &lt; etick)</a>
<a name="ln4147">                        setRest(ctick, track, etick - ctick, false, 0);       // fill gap</a>
<a name="ln4148">                  }</a>
<a name="ln4149">            }</a>
<a name="ln4150">      }</a>
<a name="ln4151"> </a>
<a name="ln4152">//---------------------------------------------------------</a>
<a name="ln4153">//   undoRemovePart</a>
<a name="ln4154">//---------------------------------------------------------</a>
<a name="ln4155"> </a>
<a name="ln4156">void Score::undoRemovePart(Part* part, int idx)</a>
<a name="ln4157">      {</a>
<a name="ln4158">      undo(new RemovePart(part, idx));</a>
<a name="ln4159">      }</a>
<a name="ln4160"> </a>
<a name="ln4161">//---------------------------------------------------------</a>
<a name="ln4162">//   undoInsertPart</a>
<a name="ln4163">//---------------------------------------------------------</a>
<a name="ln4164"> </a>
<a name="ln4165">void Score::undoInsertPart(Part* part, int idx)</a>
<a name="ln4166">      {</a>
<a name="ln4167">      undo(new InsertPart(part, idx));</a>
<a name="ln4168">      }</a>
<a name="ln4169"> </a>
<a name="ln4170">//---------------------------------------------------------</a>
<a name="ln4171">//   undoRemoveStaff</a>
<a name="ln4172">//    idx - index of staff in part</a>
<a name="ln4173">//---------------------------------------------------------</a>
<a name="ln4174"> </a>
<a name="ln4175">void Score::undoRemoveStaff(Staff* staff)</a>
<a name="ln4176">      {</a>
<a name="ln4177">      const int idx = staff-&gt;idx();</a>
<a name="ln4178">      Q_ASSERT(idx &gt;= 0);</a>
<a name="ln4179"> </a>
<a name="ln4180">      std::vector&lt;Spanner*&gt; toRemove;</a>
<a name="ln4181">      for (auto i = _spanner.cbegin(); i != _spanner.cend(); ++i) {</a>
<a name="ln4182">            Spanner* s = i-&gt;second;</a>
<a name="ln4183">            if (s-&gt;staffIdx() == idx &amp;&amp; (idx != 0 || !s-&gt;systemFlag()))</a>
<a name="ln4184">                  toRemove.push_back(s);</a>
<a name="ln4185">            }</a>
<a name="ln4186">      for (Spanner* s : _unmanagedSpanner) {</a>
<a name="ln4187">            if (s-&gt;staffIdx() == idx &amp;&amp; (idx != 0 || !s-&gt;systemFlag()))</a>
<a name="ln4188">                  toRemove.push_back(s);</a>
<a name="ln4189">            }</a>
<a name="ln4190">      for (Spanner* s : toRemove) {</a>
<a name="ln4191">            s-&gt;undoUnlink();</a>
<a name="ln4192">            undo(new RemoveElement(s));</a>
<a name="ln4193">            }</a>
<a name="ln4194"> </a>
<a name="ln4195">      //</a>
<a name="ln4196">      //    adjust measures</a>
<a name="ln4197">      //</a>
<a name="ln4198">      for (Measure* m = staff-&gt;score()-&gt;firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln4199">            m-&gt;cmdRemoveStaves(idx, idx+1);</a>
<a name="ln4200">            if (m-&gt;hasMMRest())</a>
<a name="ln4201">                  m-&gt;mmRest()-&gt;cmdRemoveStaves(idx, idx+1);</a>
<a name="ln4202">            }</a>
<a name="ln4203"> </a>
<a name="ln4204">      undo(new RemoveStaff(staff));</a>
<a name="ln4205">      }</a>
<a name="ln4206"> </a>
<a name="ln4207">//---------------------------------------------------------</a>
<a name="ln4208">//   undoInsertStaff</a>
<a name="ln4209">//    idx - index of staff in part</a>
<a name="ln4210">//---------------------------------------------------------</a>
<a name="ln4211"> </a>
<a name="ln4212">void Score::undoInsertStaff(Staff* staff, int ridx, bool createRests)</a>
<a name="ln4213">      {</a>
<a name="ln4214">      undo(new InsertStaff(staff, ridx));</a>
<a name="ln4215">      int idx = staffIdx(staff-&gt;part()) + ridx;</a>
<a name="ln4216">      for (Measure* m = firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln4217">            m-&gt;cmdAddStaves(idx, idx+1, createRests);</a>
<a name="ln4218">            if (m-&gt;hasMMRest())</a>
<a name="ln4219">                  m-&gt;mmRest()-&gt;cmdAddStaves(idx, idx+1, false);</a>
<a name="ln4220">            }</a>
<a name="ln4221">      // when newly adding an instrument,</a>
<a name="ln4222">      // this was already set when we created the staff</a>
<a name="ln4223">      // we don't have any better info at this point</a>
<a name="ln4224">      // and it dooesn't work to adjust bracket &amp; barlines until all staves are added</a>
<a name="ln4225">      // TODO: adjust brackets only when appropriate</a>
<a name="ln4226">      //adjustBracketsIns(idx, idx+1);</a>
<a name="ln4227">      }</a>
<a name="ln4228"> </a>
<a name="ln4229">//---------------------------------------------------------</a>
<a name="ln4230">//   undoChangeInvisible</a>
<a name="ln4231">//---------------------------------------------------------</a>
<a name="ln4232"> </a>
<a name="ln4233">void Score::undoChangeInvisible(Element* e, bool v)</a>
<a name="ln4234">      {</a>
<a name="ln4235">      e-&gt;undoChangeProperty(Pid::VISIBLE, v);</a>
<a name="ln4236">      e-&gt;setGenerated(false);</a>
<a name="ln4237">      }</a>
<a name="ln4238"> </a>
<a name="ln4239">//---------------------------------------------------------</a>
<a name="ln4240">//   undoAddElement</a>
<a name="ln4241">//---------------------------------------------------------</a>
<a name="ln4242"> </a>
<a name="ln4243">void Score::undoAddElement(Element* element)</a>
<a name="ln4244">      {</a>
<a name="ln4245">      QList&lt;Staff* &gt; staffList;</a>
<a name="ln4246">      Staff* ostaff = element-&gt;staff();</a>
<a name="ln4247">      int strack = -1;</a>
<a name="ln4248">      if (ostaff) {</a>
<a name="ln4249">            strack = ostaff-&gt;idx() * VOICES + element-&gt;track() % VOICES;</a>
<a name="ln4250">            if (ostaff-&gt;score()-&gt;excerpt() &amp;&amp; !ostaff-&gt;score()-&gt;excerpt()-&gt;tracks().isEmpty() &amp;&amp; strack &gt; -1)</a>
<a name="ln4251">                  strack = ostaff-&gt;score()-&gt;excerpt()-&gt;tracks().key(strack, -1);</a>
<a name="ln4252">            }</a>
<a name="ln4253"> </a>
<a name="ln4254">      ElementType et = element-&gt;type();</a>
<a name="ln4255"> </a>
<a name="ln4256">      //</a>
<a name="ln4257">      // some elements are replicated for all parts regardless of</a>
<a name="ln4258">      // linking:</a>
<a name="ln4259">      //</a>
<a name="ln4260"> </a>
<a name="ln4261">      if ((et == ElementType::REHEARSAL_MARK)</a>
<a name="ln4262">         || (et == ElementType::SYSTEM_TEXT)</a>
<a name="ln4263">         || (et == ElementType::JUMP)</a>
<a name="ln4264">         || (et == ElementType::MARKER)</a>
<a name="ln4265">         || (et == ElementType::TEMPO_TEXT)</a>
<a name="ln4266">         || (et == ElementType::VOLTA)</a>
<a name="ln4267">         ) {</a>
<a name="ln4268">            for (Score* s : scoreList())</a>
<a name="ln4269">                  staffList.append(s-&gt;staff(0));</a>
<a name="ln4270"> </a>
<a name="ln4271">            for (Staff* staff : staffList) {</a>
<a name="ln4272">                  Score* score  = staff-&gt;score();</a>
<a name="ln4273">                  int staffIdx  = staff-&gt;idx();</a>
<a name="ln4274">                  int ntrack    = staffIdx * VOICES;</a>
<a name="ln4275">                  Element* ne;</a>
<a name="ln4276"> </a>
<a name="ln4277">                  if (staff-&gt;score() == ostaff-&gt;score())</a>
<a name="ln4278">                        ne = element;</a>
<a name="ln4279">                  else {</a>
<a name="ln4280">                        // only create linked volta for first staff</a>
<a name="ln4281">                        if (et == ElementType::VOLTA &amp;&amp; element-&gt;track() != 0)</a>
<a name="ln4282">                              continue;</a>
<a name="ln4283">                        ne = element-&gt;linkedClone();</a>
<a name="ln4284">                        ne-&gt;setScore(score);</a>
<a name="ln4285">                        ne-&gt;setSelected(false);</a>
<a name="ln4286">                        ne-&gt;setTrack(staffIdx * VOICES + element-&gt;voice());</a>
<a name="ln4287">                        }</a>
<a name="ln4288"> </a>
<a name="ln4289">                  if (et == ElementType::VOLTA) {</a>
<a name="ln4290">                        Spanner* nsp = toSpanner(ne);</a>
<a name="ln4291">                        Spanner* sp = toSpanner(element);</a>
<a name="ln4292">                        int staffIdx1 = sp-&gt;track() / VOICES;</a>
<a name="ln4293">                        int staffIdx2 = sp-&gt;track2() / VOICES;</a>
<a name="ln4294">                        int diff = staffIdx2 - staffIdx1;</a>
<a name="ln4295">                        nsp-&gt;setTrack2((staffIdx + diff) * VOICES + (sp-&gt;track2() % VOICES));</a>
<a name="ln4296">                        undo(new AddElement(nsp));</a>
<a name="ln4297">                        }</a>
<a name="ln4298">                  else if (et == ElementType::MARKER || et == ElementType::JUMP) {</a>
<a name="ln4299">                        Measure* om = toMeasure(element-&gt;parent());</a>
<a name="ln4300">                        Measure* m  = score-&gt;tick2measure(om-&gt;tick());</a>
<a name="ln4301">                        ne-&gt;setTrack(element-&gt;track());</a>
<a name="ln4302">                        ne-&gt;setParent(m);</a>
<a name="ln4303">                        undo(new AddElement(ne));</a>
<a name="ln4304">                        }</a>
<a name="ln4305">                  else {</a>
<a name="ln4306">                        Segment* segment  = toSegment(element-&gt;parent());</a>
<a name="ln4307">                        Fraction tick     = segment-&gt;tick();</a>
<a name="ln4308">                        Measure* m        = score-&gt;tick2measure(tick);</a>
<a name="ln4309">                        Segment* seg      = m-&gt;undoGetSegment(SegmentType::ChordRest, tick);</a>
<a name="ln4310">                        ne-&gt;setTrack(ntrack);</a>
<a name="ln4311">                        ne-&gt;setParent(seg);</a>
<a name="ln4312">                        undo(new AddElement(ne));</a>
<a name="ln4313">                        }</a>
<a name="ln4314">                  }</a>
<a name="ln4315">            return;</a>
<a name="ln4316">            }</a>
<a name="ln4317"> </a>
<a name="ln4318">      if (et == ElementType::FINGERING</a>
<a name="ln4319">         || (et == ElementType::IMAGE  &amp;&amp; !element-&gt;parent()-&gt;isSegment())</a>
<a name="ln4320">         || (et == ElementType::SYMBOL &amp;&amp; !element-&gt;parent()-&gt;isSegment())</a>
<a name="ln4321">         || et == ElementType::NOTE</a>
<a name="ln4322">         || et == ElementType::TEXT</a>
<a name="ln4323">         || et == ElementType::GLISSANDO</a>
<a name="ln4324">         || et == ElementType::BEND</a>
<a name="ln4325">         || (et == ElementType::CHORD &amp;&amp; toChord(element)-&gt;isGrace())</a>
<a name="ln4326">            ) {</a>
<a name="ln4327">            Element* parent = element-&gt;parent();</a>
<a name="ln4328">            const LinkedElements* links = parent-&gt;links();</a>
<a name="ln4329">            // don't link part name</a>
<a name="ln4330">            if (et == ElementType::TEXT) {</a>
<a name="ln4331">                  Text* t = toText(element);</a>
<a name="ln4332">                  if (t-&gt;tid() == Tid::INSTRUMENT_EXCERPT)</a>
<a name="ln4333">                        links = 0;</a>
<a name="ln4334">                  }</a>
<a name="ln4335">            if (links == 0) {</a>
<a name="ln4336">                  undo(new AddElement(element));</a>
<a name="ln4337">                  return;</a>
<a name="ln4338">                  }</a>
<a name="ln4339">            for (ScoreElement* ee : *links) {</a>
<a name="ln4340">                  Element* e = static_cast&lt;Element*&gt;(ee);</a>
<a name="ln4341">                  Element* ne;</a>
<a name="ln4342">                  if (e == parent)</a>
<a name="ln4343">                        ne = element;</a>
<a name="ln4344">                  else {</a>
<a name="ln4345">                        if (element-&gt;isGlissando()) {    // and other spanners with Anchor::NOTE</a>
<a name="ln4346">                              Note* newEnd = Spanner::endElementFromSpanner(toGlissando(element), e);</a>
<a name="ln4347">                              if (newEnd) {</a>
<a name="ln4348">                                    ne = element-&gt;linkedClone();</a>
<a name="ln4349">                                    toSpanner(ne)-&gt;setNoteSpan(toNote(e), newEnd);</a>
<a name="ln4350">                                    }</a>
<a name="ln4351">                              else              //couldn't find suitable start note</a>
<a name="ln4352">                                    continue;</a>
<a name="ln4353">                              }</a>
<a name="ln4354">                        else if (element-&gt;isFingering()) {</a>
<a name="ln4355">                              bool tabFingering = e-&gt;staff()-&gt;staffType(e-&gt;tick())-&gt;showTabFingering();</a>
<a name="ln4356">                              if (e-&gt;staff()-&gt;isTabStaff(e-&gt;tick()) &amp;&amp; !tabFingering)</a>
<a name="ln4357">                                    continue;</a>
<a name="ln4358">                              ne = element-&gt;linkedClone();</a>
<a name="ln4359">                              }</a>
<a name="ln4360">                        else</a>
<a name="ln4361">                              ne = element-&gt;linkedClone();</a>
<a name="ln4362">                        }</a>
<a name="ln4363">                  ne-&gt;setScore(e-&gt;score());</a>
<a name="ln4364">                  ne-&gt;setSelected(false);</a>
<a name="ln4365">                  ne-&gt;setParent(e);</a>
<a name="ln4366">                  undo(new AddElement(ne));</a>
<a name="ln4367">                  }</a>
<a name="ln4368">            return;</a>
<a name="ln4369">            }</a>
<a name="ln4370"> </a>
<a name="ln4371">      if (et == ElementType::LAYOUT_BREAK) {</a>
<a name="ln4372">            LayoutBreak* lb = toLayoutBreak(element);</a>
<a name="ln4373">            if (lb-&gt;layoutBreakType() == LayoutBreak::Type::SECTION) {</a>
<a name="ln4374">                  Measure* m = lb-&gt;measure();</a>
<a name="ln4375">                  for (Score* s : scoreList()) {</a>
<a name="ln4376">                        if (s == lb-&gt;score())</a>
<a name="ln4377">                              undo(new AddElement(lb));</a>
<a name="ln4378">                        else {</a>
<a name="ln4379">                              Element* e = lb-&gt;linkedClone();</a>
<a name="ln4380">                              e-&gt;setScore(s);</a>
<a name="ln4381">                              Measure* nm = s-&gt;tick2measure(m-&gt;tick());</a>
<a name="ln4382">                              e-&gt;setParent(nm);</a>
<a name="ln4383">                              undo(new AddElement(e));</a>
<a name="ln4384">                              }</a>
<a name="ln4385">                        }</a>
<a name="ln4386">                  return;</a>
<a name="ln4387">                  }</a>
<a name="ln4388">            }</a>
<a name="ln4389"> </a>
<a name="ln4390">      if (ostaff == 0 || (</a>
<a name="ln4391">         et    != ElementType::ARTICULATION</a>
<a name="ln4392">         &amp;&amp; et != ElementType::CHORDLINE</a>
<a name="ln4393">         &amp;&amp; et != ElementType::LYRICS</a>
<a name="ln4394">         &amp;&amp; et != ElementType::SLUR</a>
<a name="ln4395">         &amp;&amp; et != ElementType::TIE</a>
<a name="ln4396">         &amp;&amp; et != ElementType::NOTE</a>
<a name="ln4397">         &amp;&amp; et != ElementType::INSTRUMENT_CHANGE</a>
<a name="ln4398">         &amp;&amp; et != ElementType::HAIRPIN</a>
<a name="ln4399">         &amp;&amp; et != ElementType::OTTAVA</a>
<a name="ln4400">         &amp;&amp; et != ElementType::TRILL</a>
<a name="ln4401">         &amp;&amp; et != ElementType::VIBRATO</a>
<a name="ln4402">         &amp;&amp; et != ElementType::TEXTLINE</a>
<a name="ln4403">         &amp;&amp; et != ElementType::PEDAL</a>
<a name="ln4404">         &amp;&amp; et != ElementType::BREATH</a>
<a name="ln4405">         &amp;&amp; et != ElementType::DYNAMIC</a>
<a name="ln4406">         &amp;&amp; et != ElementType::STAFF_TEXT</a>
<a name="ln4407">         &amp;&amp; et != ElementType::SYSTEM_TEXT</a>
<a name="ln4408">         &amp;&amp; et != ElementType::STICKING</a>
<a name="ln4409">         &amp;&amp; et != ElementType::TREMOLO</a>
<a name="ln4410">         &amp;&amp; et != ElementType::ARPEGGIO</a>
<a name="ln4411">         &amp;&amp; et != ElementType::SYMBOL</a>
<a name="ln4412">         &amp;&amp; et != ElementType::TREMOLOBAR</a>
<a name="ln4413">         &amp;&amp; et != ElementType::FRET_DIAGRAM</a>
<a name="ln4414">         &amp;&amp; et != ElementType::FERMATA</a>
<a name="ln4415">         &amp;&amp; et != ElementType::HARMONY)</a>
<a name="ln4416">            ) {</a>
<a name="ln4417">            undo(new AddElement(element));</a>
<a name="ln4418">            return;</a>
<a name="ln4419">            }</a>
<a name="ln4420"> </a>
<a name="ln4421">      foreach (Staff* staff, ostaff-&gt;staffList()) {</a>
<a name="ln4422">            Score* score = staff-&gt;score();</a>
<a name="ln4423">            int staffIdx = staff-&gt;idx();</a>
<a name="ln4424"> </a>
<a name="ln4425">            QList&lt;int&gt; tr;</a>
<a name="ln4426">            if ((strack &amp; ~3) != staffIdx) // linked staff ?</a>
<a name="ln4427">                  tr.append(staffIdx * VOICES + (strack % VOICES));</a>
<a name="ln4428">            else if (staff-&gt;score()-&gt;excerpt() &amp;&amp; strack &gt; -1)</a>
<a name="ln4429">                  tr = staff-&gt;score()-&gt;excerpt()-&gt;tracks().values(strack);</a>
<a name="ln4430">            else</a>
<a name="ln4431">                  tr.append(strack);</a>
<a name="ln4432"> </a>
<a name="ln4433">            // Some elements in voice 1 of a staff should be copied to every track which has a linked voice in this staff</a>
<a name="ln4434"> </a>
<a name="ln4435">            if (tr.isEmpty() &amp;&amp; (element-&gt;isSymbol()</a>
<a name="ln4436">                || element-&gt;isImage()</a>
<a name="ln4437">                || element-&gt;isTremoloBar()</a>
<a name="ln4438">                || element-&gt;isDynamic()</a>
<a name="ln4439">                || element-&gt;isStaffText()</a>
<a name="ln4440">                || element-&gt;isSticking()</a>
<a name="ln4441">                || element-&gt;isFretDiagram()</a>
<a name="ln4442">                || element-&gt;isHarmony()</a>
<a name="ln4443">                || element-&gt;isHairpin()</a>
<a name="ln4444">                || element-&gt;isOttava()</a>
<a name="ln4445">                || element-&gt;isTrill()</a>
<a name="ln4446">                || element-&gt;isSlur()</a>
<a name="ln4447">                || element-&gt;isVibrato()</a>
<a name="ln4448">                || element-&gt;isTextLine()</a>
<a name="ln4449">                || element-&gt;isPedal()</a>
<a name="ln4450">                || element-&gt;isLyrics())) {</a>
<a name="ln4451">                  tr.append(staffIdx * VOICES);</a>
<a name="ln4452">                  }</a>
<a name="ln4453"> </a>
<a name="ln4454">            int it = 0;</a>
<a name="ln4455">            for (int ntrack : tr) {</a>
<a name="ln4456">                  if ((ntrack &amp; ~3) != staffIdx * VOICES) {</a>
<a name="ln4457">                        it++;</a>
<a name="ln4458">                        continue;</a>
<a name="ln4459">                        }</a>
<a name="ln4460"> </a>
<a name="ln4461">                  Element* ne;</a>
<a name="ln4462">                  if (staff == ostaff)</a>
<a name="ln4463">                        ne = element;</a>
<a name="ln4464">                  else {</a>
<a name="ln4465">                        if (staff-&gt;rstaff() != ostaff-&gt;rstaff()) {</a>
<a name="ln4466">                              switch (element-&gt;type()) {</a>
<a name="ln4467">                                    // exclude certain element types except on corresponding staff in part</a>
<a name="ln4468">                                    // this should be same list excluded in cloneStaff()</a>
<a name="ln4469">                                    case ElementType::STAFF_TEXT:</a>
<a name="ln4470">                                    case ElementType::SYSTEM_TEXT:</a>
<a name="ln4471">                                    case ElementType::FRET_DIAGRAM:</a>
<a name="ln4472">                                    case ElementType::HARMONY:</a>
<a name="ln4473">                                    case ElementType::FIGURED_BASS:</a>
<a name="ln4474">                                    case ElementType::DYNAMIC:</a>
<a name="ln4475">                                    case ElementType::LYRICS:   // not normally segment-attached</a>
<a name="ln4476">                                          continue;</a>
<a name="ln4477">                                    default:</a>
<a name="ln4478">                                          break;</a>
<a name="ln4479">                                    }</a>
<a name="ln4480">                              }</a>
<a name="ln4481">                        ne = element-&gt;linkedClone();</a>
<a name="ln4482">                        ne-&gt;setScore(score);</a>
<a name="ln4483">                        ne-&gt;setSelected(false);</a>
<a name="ln4484">                        ne-&gt;setTrack(staffIdx * VOICES + element-&gt;voice());</a>
<a name="ln4485">                        }</a>
<a name="ln4486"> </a>
<a name="ln4487">                  if (element-&gt;isArticulation()) {</a>
<a name="ln4488">                        Articulation* a  = toArticulation(element);</a>
<a name="ln4489">                        Segment* segment;</a>
<a name="ln4490">                        SegmentType st;</a>
<a name="ln4491">                        Measure* m;</a>
<a name="ln4492">                        Fraction tick;</a>
<a name="ln4493">                        if (a-&gt;parent()-&gt;isChordRest()) {</a>
<a name="ln4494">                              ChordRest* cr = a-&gt;chordRest();</a>
<a name="ln4495">                              segment       = cr-&gt;segment();</a>
<a name="ln4496">                              st            = SegmentType::ChordRest;</a>
<a name="ln4497">                              tick          = segment-&gt;tick();</a>
<a name="ln4498">                              m             = score-&gt;tick2measure(tick);</a>
<a name="ln4499">                              }</a>
<a name="ln4500">                        else {</a>
<a name="ln4501">                              segment  = toSegment(a-&gt;parent()-&gt;parent());</a>
<a name="ln4502">                              st       = SegmentType::EndBarLine;</a>
<a name="ln4503">                              tick     = segment-&gt;tick();</a>
<a name="ln4504">                              m        = score-&gt;tick2measure(tick);</a>
<a name="ln4505">                              if (m-&gt;tick() == tick)</a>
<a name="ln4506">                                    m = m-&gt;prevMeasure();</a>
<a name="ln4507">                              }</a>
<a name="ln4508">                        Segment* seg = m-&gt;findSegment(st, tick);</a>
<a name="ln4509">                        if (seg == 0) {</a>
<a name="ln4510">                              qWarning(&quot;undoAddSegment: segment not found&quot;);</a>
<a name="ln4511">                              break;</a>
<a name="ln4512">                              }</a>
<a name="ln4513">                        Articulation* na = toArticulation(ne);</a>
<a name="ln4514">                        na-&gt;setTrack(ntrack);</a>
<a name="ln4515">                        if (a-&gt;parent()-&gt;isChordRest()) {</a>
<a name="ln4516">                              ChordRest* cr = a-&gt;chordRest();</a>
<a name="ln4517">                              ChordRest* ncr;</a>
<a name="ln4518">                              if (cr-&gt;isGrace())</a>
<a name="ln4519">                                    ncr = findLinkedChord(toChord(cr), score-&gt;staff(staffIdx));</a>
<a name="ln4520">                              else</a>
<a name="ln4521">                                    ncr = toChordRest(seg-&gt;element(ntrack));</a>
<a name="ln4522">                              na-&gt;setParent(ncr);</a>
<a name="ln4523">                              }</a>
<a name="ln4524">                        else {</a>
<a name="ln4525">                              BarLine* bl = toBarLine(seg-&gt;element(ntrack));</a>
<a name="ln4526">                              na-&gt;setParent(bl);</a>
<a name="ln4527">                              }</a>
<a name="ln4528">                        undo(new AddElement(na));</a>
<a name="ln4529">                        }</a>
<a name="ln4530">                  else if (element-&gt;isChordLine() || element-&gt;isLyrics()) {</a>
<a name="ln4531">                        ChordRest* cr    = toChordRest(element-&gt;parent());</a>
<a name="ln4532">                        Segment* segment = cr-&gt;segment();</a>
<a name="ln4533">                        Fraction tick    = segment-&gt;tick();</a>
<a name="ln4534">                        Measure* m       = score-&gt;tick2measure(tick);</a>
<a name="ln4535">                        Segment* seg     = m-&gt;findSegment(SegmentType::ChordRest, tick);</a>
<a name="ln4536">                        if (seg == 0) {</a>
<a name="ln4537">                              qWarning(&quot;undoAddSegment: segment not found&quot;);</a>
<a name="ln4538">                              break;</a>
<a name="ln4539">                              }</a>
<a name="ln4540">                        ne-&gt;setTrack(ntrack);</a>
<a name="ln4541">                        ChordRest* ncr = toChordRest(seg-&gt;element(ntrack));</a>
<a name="ln4542">                        ne-&gt;setParent(ncr);</a>
<a name="ln4543">                        undo(new AddElement(ne));</a>
<a name="ln4544">                        }</a>
<a name="ln4545">                  //</a>
<a name="ln4546">                  // elements with Segment as parent</a>
<a name="ln4547">                  //</a>
<a name="ln4548">                  else if (element-&gt;isSymbol()</a>
<a name="ln4549">                     || element-&gt;isImage()</a>
<a name="ln4550">                     || element-&gt;isTremoloBar()</a>
<a name="ln4551">                     || element-&gt;isDynamic()</a>
<a name="ln4552">                     || element-&gt;isStaffText()</a>
<a name="ln4553">                     || element-&gt;isSticking()</a>
<a name="ln4554">                     || element-&gt;isFretDiagram()</a>
<a name="ln4555">                     || element-&gt;isFermata()</a>
<a name="ln4556">                     || element-&gt;isHarmony()) {</a>
<a name="ln4557">                        Segment* segment = element-&gt;parent()-&gt;isFretDiagram() ? toSegment(element-&gt;parent()-&gt;parent()) : toSegment(element-&gt;parent());</a>
<a name="ln4558">                        Fraction tick    = segment-&gt;tick();</a>
<a name="ln4559">                        Measure* m       = score-&gt;tick2measure(tick);</a>
<a name="ln4560">                        if ((segment-&gt;segmentType() == SegmentType::EndBarLine) &amp;&amp; (m-&gt;tick() == tick))</a>
<a name="ln4561">                              m = m-&gt;prevMeasure();</a>
<a name="ln4562">                        Segment* seg     = m-&gt;undoGetSegment(segment-&gt;segmentType(), tick);</a>
<a name="ln4563">                        ne-&gt;setTrack(ntrack);</a>
<a name="ln4564">                        ne-&gt;setParent(seg);</a>
<a name="ln4565"> </a>
<a name="ln4566">                        // make harmony child of fret diagram if possible</a>
<a name="ln4567">                        if (ne-&gt;isHarmony()) {</a>
<a name="ln4568">                              for (Element* segel : segment-&gt;annotations()) {</a>
<a name="ln4569">                                    if (segel &amp;&amp; segel-&gt;isFretDiagram() &amp;&amp; segel-&gt;track() == ntrack) {</a>
<a name="ln4570">                                          ne-&gt;setTrack(segel-&gt;track());</a>
<a name="ln4571">                                          ne-&gt;setParent(segel);</a>
<a name="ln4572">                                          break;</a>
<a name="ln4573">                                          }</a>
<a name="ln4574">                                    }</a>
<a name="ln4575">                              }</a>
<a name="ln4576">                        else if (ne-&gt;isFretDiagram()) {</a>
<a name="ln4577">                              // update track of child harmony</a>
<a name="ln4578">                              FretDiagram* fd = toFretDiagram(ne);</a>
<a name="ln4579">                              if (fd-&gt;harmony())</a>
<a name="ln4580">                                    fd-&gt;harmony()-&gt;setTrack(ntrack);</a>
<a name="ln4581">                              }</a>
<a name="ln4582"> </a>
<a name="ln4583">                        undo(new AddElement(ne));</a>
<a name="ln4584">                        // transpose harmony if necessary</a>
<a name="ln4585">                        if (element-&gt;isHarmony() &amp;&amp; ne != element) {</a>
<a name="ln4586">                              Harmony* h = toHarmony(ne);</a>
<a name="ln4587">                              if (score-&gt;styleB(Sid::concertPitch) != element-&gt;score()-&gt;styleB(Sid::concertPitch)) {</a>
<a name="ln4588">                                    Part* partDest = h-&gt;part();</a>
<a name="ln4589">                                    Interval interval = partDest-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln4590">                                    if (!interval.isZero()) {</a>
<a name="ln4591">                                          if (!score-&gt;styleB(Sid::concertPitch))</a>
<a name="ln4592">                                                interval.flip();</a>
<a name="ln4593">                                          int rootTpc = transposeTpc(h-&gt;rootTpc(), interval, true);</a>
<a name="ln4594">                                          int baseTpc = transposeTpc(h-&gt;baseTpc(), interval, true);</a>
<a name="ln4595">                                          score-&gt;undoTransposeHarmony(h, rootTpc, baseTpc);</a>
<a name="ln4596">                                          }</a>
<a name="ln4597">                                    }</a>
<a name="ln4598">                              }</a>
<a name="ln4599">                        }</a>
<a name="ln4600">                  else if (element-&gt;isSlur()</a>
<a name="ln4601">                     || element-&gt;isHairpin()</a>
<a name="ln4602">                     || element-&gt;isOttava()</a>
<a name="ln4603">                     || element-&gt;isTrill()</a>
<a name="ln4604">                     || element-&gt;isVibrato()</a>
<a name="ln4605">                     || element-&gt;isTextLine()</a>
<a name="ln4606">                     || element-&gt;isPedal()) {</a>
<a name="ln4607">                        Spanner* sp   = toSpanner(element);</a>
<a name="ln4608">                        Spanner* nsp  = toSpanner(ne);</a>
<a name="ln4609">                        int staffIdx1 = sp-&gt;track() / VOICES;</a>
<a name="ln4610">                        int tr2 = sp-&gt;effectiveTrack2();</a>
<a name="ln4611">                        int staffIdx2 = tr2 / VOICES;</a>
<a name="ln4612">                        int diff      = staffIdx2 - staffIdx1;</a>
<a name="ln4613">                        nsp-&gt;setTrack2((staffIdx + diff) * VOICES + (tr2 % VOICES));</a>
<a name="ln4614">                        nsp-&gt;setTrack(ntrack);</a>
<a name="ln4615"> </a>
<a name="ln4616">#if 0 //whatdoesitdo?</a>
<a name="ln4617">                        QList&lt;int&gt; tl2;</a>
<a name="ln4618">                        if (staff-&gt;score()-&gt;excerpt() &amp;&amp; element-&gt;isSlur()) {</a>
<a name="ln4619">                              nsp-&gt;setTrack(ntrack);</a>
<a name="ln4620">                                    tl2 = staff-&gt;score()-&gt;excerpt()-&gt;tracks().values(sp-&gt;track2());</a>
<a name="ln4621">                                    if (tl2.isEmpty()) {</a>
<a name="ln4622">                                          it++;</a>
<a name="ln4623">                                          continue;</a>
<a name="ln4624">                                          }</a>
<a name="ln4625">                                   nsp-&gt;setTrack2(tl2.at(it));</a>
<a name="ln4626">                              }</a>
<a name="ln4627">                        else if (!element-&gt;isSlur())</a>
<a name="ln4628">                              nsp-&gt;setTrack(ntrack &amp; ~3);</a>
<a name="ln4629">#endif</a>
<a name="ln4630"> </a>
<a name="ln4631">                        // determine start/end element for slurs</a>
<a name="ln4632">                        // this is only necessary if start/end element is</a>
<a name="ln4633">                        //   a grace note, otherwise the element can be set to zero</a>
<a name="ln4634">                        //   and will later be calculated from tick/track values</a>
<a name="ln4635">                        //</a>
<a name="ln4636">                        if (element-&gt;isSlur() &amp;&amp; sp != nsp) {</a>
<a name="ln4637">                              if (sp-&gt;startElement()) {</a>
<a name="ln4638">                                    QList&lt;ScoreElement*&gt; sel = sp-&gt;startElement()-&gt;linkList();</a>
<a name="ln4639">                                    for (ScoreElement* ee : sel) {</a>
<a name="ln4640">                                          Element* e = static_cast&lt;Element*&gt;(ee);</a>
<a name="ln4641">                                          if (e-&gt;score() == nsp-&gt;score() &amp;&amp; e-&gt;track() == nsp-&gt;track()) {</a>
<a name="ln4642">                                                nsp-&gt;setStartElement(e);</a>
<a name="ln4643">                                                break;</a>
<a name="ln4644">                                                }</a>
<a name="ln4645">                                          }</a>
<a name="ln4646">                                    }</a>
<a name="ln4647">                              if (sp-&gt;endElement()) {</a>
<a name="ln4648">                                    QList&lt;ScoreElement*&gt; eel = sp-&gt;endElement()-&gt;linkList();</a>
<a name="ln4649">                                    for (ScoreElement* ee : eel) {</a>
<a name="ln4650">                                          Element* e = static_cast&lt;Element*&gt;(ee);</a>
<a name="ln4651">                                          if (e-&gt;score() == nsp-&gt;score() &amp;&amp; e-&gt;track() == nsp-&gt;track2()) {</a>
<a name="ln4652">                                                nsp-&gt;setEndElement(e);</a>
<a name="ln4653">                                                break;</a>
<a name="ln4654">                                                }</a>
<a name="ln4655">                                          }</a>
<a name="ln4656">                                    }</a>
<a name="ln4657">                              }</a>
<a name="ln4658">                        undo(new AddElement(nsp));</a>
<a name="ln4659">                        }</a>
<a name="ln4660">                  else if (et == ElementType::GLISSANDO)</a>
<a name="ln4661">                        undo(new AddElement(toSpanner(ne)));</a>
<a name="ln4662">                  else if (element-&gt;isTremolo() &amp;&amp; toTremolo(element)-&gt;twoNotes()) {</a>
<a name="ln4663">                        Tremolo* tremolo = toTremolo(element);</a>
<a name="ln4664">                        ChordRest* cr1 = toChordRest(tremolo-&gt;chord1());</a>
<a name="ln4665">                        ChordRest* cr2 = toChordRest(tremolo-&gt;chord2());</a>
<a name="ln4666">                        Segment* s1    = cr1-&gt;segment();</a>
<a name="ln4667">                        Segment* s2    = cr2-&gt;segment();</a>
<a name="ln4668">                        Measure* m1    = s1-&gt;measure();</a>
<a name="ln4669">                        Measure* m2    = s2-&gt;measure();</a>
<a name="ln4670">                        Measure* nm1   = score-&gt;tick2measure(m1-&gt;tick());</a>
<a name="ln4671">                        Measure* nm2   = score-&gt;tick2measure(m2-&gt;tick());</a>
<a name="ln4672">                        Segment* ns1   = nm1-&gt;findSegment(s1-&gt;segmentType(), s1-&gt;tick());</a>
<a name="ln4673">                        Segment* ns2   = nm2-&gt;findSegment(s2-&gt;segmentType(), s2-&gt;tick());</a>
<a name="ln4674">                        Chord* c1      = toChord(ns1-&gt;element(staffIdx * VOICES + cr1-&gt;voice()));</a>
<a name="ln4675">                        Chord* c2      = toChord(ns2-&gt;element(staffIdx * VOICES + cr2-&gt;voice()));</a>
<a name="ln4676">                        Tremolo* ntremolo = toTremolo(ne);</a>
<a name="ln4677">                        ntremolo-&gt;setChords(c1, c2);</a>
<a name="ln4678">                        ntremolo-&gt;setParent(c1);</a>
<a name="ln4679">                        undo(new AddElement(ntremolo));</a>
<a name="ln4680">                        }</a>
<a name="ln4681">                  else if (element-&gt;isTremolo() &amp;&amp; !toTremolo(element)-&gt;twoNotes()) {</a>
<a name="ln4682">                        Chord* cr = toChord(element-&gt;parent());</a>
<a name="ln4683">                        Chord* c1 = findLinkedChord(cr, score-&gt;staff(staffIdx));</a>
<a name="ln4684">                        ne-&gt;setParent(c1);</a>
<a name="ln4685">                        undo(new AddElement(ne));</a>
<a name="ln4686">                        }</a>
<a name="ln4687">                  else if (element-&gt;isArpeggio()) {</a>
<a name="ln4688">                        ChordRest* cr = toChordRest(element-&gt;parent());</a>
<a name="ln4689">                        Segment* s    = cr-&gt;segment();</a>
<a name="ln4690">                        Measure* m    = s-&gt;measure();</a>
<a name="ln4691">                        Measure* nm   = score-&gt;tick2measure(m-&gt;tick());</a>
<a name="ln4692">                        Segment* ns   = nm-&gt;findSegment(s-&gt;segmentType(), s-&gt;tick());</a>
<a name="ln4693">                        Chord* c1     = toChord(ns-&gt;element(staffIdx * VOICES + cr-&gt;voice()));</a>
<a name="ln4694">                        ne-&gt;setParent(c1);</a>
<a name="ln4695">                        undo(new AddElement(ne));</a>
<a name="ln4696">                        }</a>
<a name="ln4697">                  else if (element-&gt;isTie()) {</a>
<a name="ln4698">                        Tie* tie       = toTie(element);</a>
<a name="ln4699">                        Note* n1       = tie-&gt;startNote();</a>
<a name="ln4700">                        Note* n2       = tie-&gt;endNote();</a>
<a name="ln4701">                        Chord* cr1     = n1-&gt;chord();</a>
<a name="ln4702">                        Chord* cr2     = n2 ? n2-&gt;chord() : 0;</a>
<a name="ln4703"> </a>
<a name="ln4704">                        // find corresponding notes in linked staff</a>
<a name="ln4705">                        // accounting for grace notes and cross-staff notation</a>
<a name="ln4706">                        int sm = 0;</a>
<a name="ln4707">                        if (cr1-&gt;staffIdx() != cr2-&gt;staffIdx())</a>
<a name="ln4708">                              sm = cr2-&gt;staffIdx() - cr1-&gt;staffIdx();</a>
<a name="ln4709">                        Chord* c1 = findLinkedChord(cr1, score-&gt;staff(staffIdx));</a>
<a name="ln4710">                        Chord* c2 = findLinkedChord(cr2, score-&gt;staff(staffIdx + sm));</a>
<a name="ln4711">                        Note* nn1 = c1-&gt;findNote(n1-&gt;pitch(), n1-&gt;unisonIndex());</a>
<a name="ln4712">                        Note* nn2 = c2 ? c2-&gt;findNote(n2-&gt;pitch(), n2-&gt;unisonIndex()) : 0;</a>
<a name="ln4713"> </a>
<a name="ln4714">                        // create tie</a>
<a name="ln4715">                        Tie* ntie = toTie(ne);</a>
<a name="ln4716">                        ntie-&gt;eraseSpannerSegments();</a>
<a name="ln4717">                        ntie-&gt;setTrack(c1-&gt;track());</a>
<a name="ln4718">                        ntie-&gt;setStartNote(nn1);</a>
<a name="ln4719">                        ntie-&gt;setEndNote(nn2);</a>
<a name="ln4720">                        undo(new AddElement(ntie));</a>
<a name="ln4721">                        }</a>
<a name="ln4722">                  else if (element-&gt;isInstrumentChange()) {</a>
<a name="ln4723">                        InstrumentChange* is = toInstrumentChange(element);</a>
<a name="ln4724">                        Segment* s1    = is-&gt;segment();</a>
<a name="ln4725">                        Measure* m1    = s1-&gt;measure();</a>
<a name="ln4726">                        Measure* nm1   = score-&gt;tick2measure(m1-&gt;tick());</a>
<a name="ln4727">                        Segment* ns1   = nm1-&gt;findSegment(s1-&gt;segmentType(), s1-&gt;tick());</a>
<a name="ln4728">                        InstrumentChange* nis = toInstrumentChange(ne);</a>
<a name="ln4729">                        nis-&gt;setParent(ns1);</a>
<a name="ln4730">                        Fraction tickStart = nis-&gt;segment()-&gt;tick();</a>
<a name="ln4731">                        Part* part = nis-&gt;part();</a>
<a name="ln4732">                        Interval oldV = nis-&gt;part()-&gt;instrument(tickStart)-&gt;transpose();</a>
<a name="ln4733">                        // ws: instrument should not be changed here</a>
<a name="ln4734">                        if (is-&gt;instrument()-&gt;channel().empty() || is-&gt;instrument()-&gt;channel(0)-&gt;program() == -1)</a>
<a name="ln4735">                              nis-&gt;setInstrument(*staff-&gt;part()-&gt;instrument(s1-&gt;tick()));</a>
<a name="ln4736">                        else if (nis != is)</a>
<a name="ln4737">                              nis-&gt;setInstrument(*is-&gt;instrument());</a>
<a name="ln4738">                        undo(new AddElement(nis));</a>
<a name="ln4739">                        // transpose root score; parts will follow</a>
<a name="ln4740">                        if (score-&gt;isMaster() &amp;&amp; part-&gt;instrument(tickStart)-&gt;transpose() != oldV) {</a>
<a name="ln4741">                              auto i = part-&gt;instruments()-&gt;upper_bound(tickStart.ticks());</a>
<a name="ln4742">                              Fraction tickEnd = i == part-&gt;instruments()-&gt;end() ? Fraction(-1, 1) : Fraction::fromTicks(i-&gt;first);</a>
<a name="ln4743">                              transpositionChanged(part, oldV, tickStart, tickEnd);</a>
<a name="ln4744">                              }</a>
<a name="ln4745">                        }</a>
<a name="ln4746">                  else if (element-&gt;isBreath()) {</a>
<a name="ln4747">                        Breath* breath   = toBreath(element);</a>
<a name="ln4748">                        Fraction tick    = breath-&gt;segment()-&gt;tick();</a>
<a name="ln4749">                        Measure* m       = score-&gt;tick2measure(tick);</a>
<a name="ln4750">                        // breath appears before barline</a>
<a name="ln4751">                        if (m-&gt;tick() == tick)</a>
<a name="ln4752">                              m = m-&gt;prevMeasure();</a>
<a name="ln4753">                        Segment* seg     = m-&gt;undoGetSegment(SegmentType::Breath, tick);</a>
<a name="ln4754">                        Breath* nbreath  = toBreath(ne);</a>
<a name="ln4755">                        nbreath-&gt;setScore(score);</a>
<a name="ln4756">                        nbreath-&gt;setTrack(ntrack);</a>
<a name="ln4757">                        nbreath-&gt;setParent(seg);</a>
<a name="ln4758">                        undo(new AddElement(nbreath));</a>
<a name="ln4759">                        }</a>
<a name="ln4760">                  else</a>
<a name="ln4761">                        qWarning(&quot;undoAddElement: unhandled: &lt;%s&gt;&quot;, element-&gt;name());</a>
<a name="ln4762">                  it++;</a>
<a name="ln4763">                  }</a>
<a name="ln4764">            }</a>
<a name="ln4765">      }</a>
<a name="ln4766"> </a>
<a name="ln4767">//---------------------------------------------------------</a>
<a name="ln4768">//   undoAddCR</a>
<a name="ln4769">//---------------------------------------------------------</a>
<a name="ln4770"> </a>
<a name="ln4771">void Score::undoAddCR(ChordRest* cr, Measure* measure, const Fraction&amp; tick)</a>
<a name="ln4772">      {</a>
<a name="ln4773">      Q_ASSERT(!cr-&gt;isChord() || !(toChord(cr)-&gt;notes()).empty());</a>
<a name="ln4774">      if (!cr-&gt;lyrics().empty()) {</a>
<a name="ln4775">            // Add chordrest and lyrics separately for correct</a>
<a name="ln4776">            // handling of adding lyrics to linked staves.</a>
<a name="ln4777">            std::vector&lt;Lyrics*&gt; lyrics;</a>
<a name="ln4778">            std::swap(lyrics, cr-&gt;lyrics());</a>
<a name="ln4779">            undoAddCR(cr, measure, tick);</a>
<a name="ln4780">            for (Lyrics* l : lyrics)</a>
<a name="ln4781">                  undoAddElement(l);</a>
<a name="ln4782">            return;</a>
<a name="ln4783">            }</a>
<a name="ln4784"> </a>
<a name="ln4785">      Staff* ostaff = cr-&gt;staff();</a>
<a name="ln4786">      int strack    = ostaff-&gt;idx() * VOICES + cr-&gt;voice();</a>
<a name="ln4787"> </a>
<a name="ln4788">      if (ostaff-&gt;score()-&gt;excerpt() &amp;&amp; !ostaff-&gt;score()-&gt;excerpt()-&gt;tracks().isEmpty())</a>
<a name="ln4789">            strack = ostaff-&gt;score()-&gt;excerpt()-&gt;tracks().key(strack, -1);</a>
<a name="ln4790"> </a>
<a name="ln4791">      SegmentType segmentType = SegmentType::ChordRest;</a>
<a name="ln4792"> </a>
<a name="ln4793">      Tuplet* t = cr-&gt;tuplet();</a>
<a name="ln4794"> </a>
<a name="ln4795">      for (const Staff* staff : ostaff-&gt;staffList()) {</a>
<a name="ln4796">            QList&lt;int&gt; tracks;</a>
<a name="ln4797">            int staffIdx = staff-&gt;idx();</a>
<a name="ln4798">            if ((strack &amp; ~3) != staffIdx) // linked staff ?</a>
<a name="ln4799">                  tracks.append(staffIdx * VOICES + (strack % VOICES));</a>
<a name="ln4800">            else if (staff-&gt;score()-&gt;excerpt() &amp;&amp; !staff-&gt;score()-&gt;excerpt()-&gt;tracks().isEmpty())</a>
<a name="ln4801">                  tracks = staff-&gt;score()-&gt;excerpt()-&gt;tracks().values(strack);</a>
<a name="ln4802">            else if (!staff-&gt;score()-&gt;excerpt())</a>
<a name="ln4803">                  tracks.append(staffIdx * VOICES + (strack % VOICES));</a>
<a name="ln4804">            else</a>
<a name="ln4805">                  tracks.append(staffIdx * VOICES + cr-&gt;voice());</a>
<a name="ln4806"> </a>
<a name="ln4807">            for (int ntrack : tracks) {</a>
<a name="ln4808">                  if (ntrack &lt; staff-&gt;part()-&gt;startTrack() || ntrack &gt;= staff-&gt;part()-&gt;endTrack())</a>
<a name="ln4809">                        continue;</a>
<a name="ln4810"> </a>
<a name="ln4811">                  Score* score = staff-&gt;score();</a>
<a name="ln4812">                  Measure* m   = (score == this) ? measure : score-&gt;tick2measure(tick);</a>
<a name="ln4813">                  if (!m)  {</a>
<a name="ln4814">                        qDebug(&quot;measure not found&quot;);</a>
<a name="ln4815">                        break;</a>
<a name="ln4816">                        }</a>
<a name="ln4817">                  Segment* seg = m-&gt;undoGetSegment(segmentType, tick);</a>
<a name="ln4818"> </a>
<a name="ln4819">                  Q_ASSERT(seg-&gt;segmentType() == segmentType);</a>
<a name="ln4820"> </a>
<a name="ln4821">                  ChordRest* newcr = (staff == ostaff) ? cr : toChordRest(cr-&gt;linkedClone());</a>
<a name="ln4822">                  newcr-&gt;setScore(score);</a>
<a name="ln4823"> </a>
<a name="ln4824">                  newcr-&gt;setTrack(ntrack);</a>
<a name="ln4825">                  newcr-&gt;setParent(seg);</a>
<a name="ln4826"> </a>
<a name="ln4827">#ifndef QT_NO_DEBUG</a>
<a name="ln4828">                  if (newcr-&gt;isChord()) {</a>
<a name="ln4829">                        Chord* chord = toChord(newcr);</a>
<a name="ln4830">                        // setTpcFromPitch needs to know the note tick position</a>
<a name="ln4831">                        for (Note* note : chord-&gt;notes()) {</a>
<a name="ln4832">                              // if (note-&gt;tpc() == Tpc::TPC_INVALID)</a>
<a name="ln4833">                              //      note-&gt;setTpcFromPitch();</a>
<a name="ln4834">                              Q_ASSERT(note-&gt;tpc() != Tpc::TPC_INVALID);</a>
<a name="ln4835">                              }</a>
<a name="ln4836">                        }</a>
<a name="ln4837">#endif</a>
<a name="ln4838">                  if (t) {</a>
<a name="ln4839">                        if (staff != ostaff) {</a>
<a name="ln4840">                              Tuplet* nt = 0;</a>
<a name="ln4841">                              if (t-&gt;elements().empty() || t-&gt;elements().front() == cr) {</a>
<a name="ln4842">                                    for (ScoreElement* e : t-&gt;linkList()) {</a>
<a name="ln4843">                                          Tuplet* nt1 = toTuplet(e);</a>
<a name="ln4844">                                          if (nt1 == t)</a>
<a name="ln4845">                                                continue;</a>
<a name="ln4846">                                          if (nt1-&gt;score() == score &amp;&amp; nt1-&gt;track() == newcr-&gt;track()) {</a>
<a name="ln4847">                                                nt = nt1;</a>
<a name="ln4848">                                                break;</a>
<a name="ln4849">                                                }</a>
<a name="ln4850">                                          }</a>
<a name="ln4851">                                    if (!nt) {</a>
<a name="ln4852">                                          nt = toTuplet(t-&gt;linkedClone());</a>
<a name="ln4853">                                          nt-&gt;setTuplet(0);</a>
<a name="ln4854">                                          nt-&gt;setScore(score);</a>
<a name="ln4855">                                          nt-&gt;setTrack(newcr-&gt;track());</a>
<a name="ln4856">                                          }</a>
<a name="ln4857"> </a>
<a name="ln4858">                                    Tuplet* t2  = t;</a>
<a name="ln4859">                                    Tuplet* nt2 = nt;</a>
<a name="ln4860">                                    while (t2-&gt;tuplet()) {</a>
<a name="ln4861">                                          Tuplet* t3  = t2-&gt;tuplet();</a>
<a name="ln4862">                                          Tuplet* nt3 = 0;</a>
<a name="ln4863"> </a>
<a name="ln4864">                                          for (auto i : t3-&gt;linkList()) {</a>
<a name="ln4865">                                                Tuplet* tt = toTuplet(i);</a>
<a name="ln4866">                                                if (tt != t3 &amp;&amp; tt-&gt;score() == score &amp;&amp; tt-&gt;track() == t2-&gt;track()) {</a>
<a name="ln4867">                                                      nt3 = tt;</a>
<a name="ln4868">                                                      break;</a>
<a name="ln4869">                                                      }</a>
<a name="ln4870">                                                }</a>
<a name="ln4871">                                          if (nt3 == 0) {</a>
<a name="ln4872">                                                nt3 = toTuplet(t3-&gt;linkedClone());</a>
<a name="ln4873">                                                nt3-&gt;setScore(score);</a>
<a name="ln4874">                                                nt3-&gt;setTrack(nt2-&gt;track());</a>
<a name="ln4875">                                                }</a>
<a name="ln4876">                                          nt3-&gt;add(nt2);</a>
<a name="ln4877">                                          nt2-&gt;setTuplet(nt3);</a>
<a name="ln4878"> </a>
<a name="ln4879">                                          t2 = t3;</a>
<a name="ln4880">                                          nt2 = nt3;</a>
<a name="ln4881">                                          }</a>
<a name="ln4882"> </a>
<a name="ln4883">                                    }</a>
<a name="ln4884">                              else {</a>
<a name="ln4885">                                    const LinkedElements* le = t-&gt;links();</a>
<a name="ln4886">                                    // search the linked tuplet</a>
<a name="ln4887">                                    if (le) {</a>
<a name="ln4888">                                          for (ScoreElement* ee : *le) {</a>
<a name="ln4889">                                                Element* e = static_cast&lt;Element*&gt;(ee);</a>
<a name="ln4890">                                                if (e-&gt;score() == score &amp;&amp; e-&gt;track() == ntrack) {</a>
<a name="ln4891">                                                      nt = toTuplet(e);</a>
<a name="ln4892">                                                      break;</a>
<a name="ln4893">                                                      }</a>
<a name="ln4894">                                                }</a>
<a name="ln4895">                                          }</a>
<a name="ln4896">                                    if (nt == 0)</a>
<a name="ln4897">                                          qWarning(&quot;linked tuplet not found&quot;);</a>
<a name="ln4898">                                    }</a>
<a name="ln4899"> </a>
<a name="ln4900">                              if (nt) {</a>
<a name="ln4901">                                    newcr-&gt;setTuplet(nt);</a>
<a name="ln4902">                                    nt-&gt;setParent(newcr-&gt;measure());</a>
<a name="ln4903">                                    }</a>
<a name="ln4904">                              }</a>
<a name="ln4905">                        }</a>
<a name="ln4906"> </a>
<a name="ln4907">                  if (newcr-&gt;isRest() &amp;&amp; (toRest(newcr)-&gt;isGap()) &amp;&amp; !(toRest(newcr)-&gt;track() % VOICES))</a>
<a name="ln4908">                        toRest(newcr)-&gt;setGap(false);</a>
<a name="ln4909"> </a>
<a name="ln4910">                  undo(new AddElement(newcr));</a>
<a name="ln4911">                  }</a>
<a name="ln4912">            }</a>
<a name="ln4913">      }</a>
<a name="ln4914"> </a>
<a name="ln4915">//---------------------------------------------------------</a>
<a name="ln4916">//   undoRemoveElement</a>
<a name="ln4917">//---------------------------------------------------------</a>
<a name="ln4918"> </a>
<a name="ln4919">void Score::undoRemoveElement(Element* element)</a>
<a name="ln4920">      {</a>
<a name="ln4921">      QList&lt;Segment*&gt; segments;</a>
<a name="ln4922">      for (ScoreElement* ee : element-&gt;linkList()) {</a>
<a name="ln4923">            Element* e = static_cast&lt;Element*&gt;(ee);</a>
<a name="ln4924">            undo(new RemoveElement(e));</a>
<a name="ln4925">            if (e-&gt;parent() &amp;&amp; (e-&gt;parent()-&gt;isSegment())) {</a>
<a name="ln4926">                  Segment* s = toSegment(e-&gt;parent());</a>
<a name="ln4927">                  if (!segments.contains(s))</a>
<a name="ln4928">                        segments.append(s);</a>
<a name="ln4929">                  }</a>
<a name="ln4930">            if (e-&gt;parent() &amp;&amp; e-&gt;parent()-&gt;isSystem()) {</a>
<a name="ln4931">                  e-&gt;setParent(0); // systems will be regenerated upon redo, so detach</a>
<a name="ln4932">                  }</a>
<a name="ln4933">            }</a>
<a name="ln4934">      for (Segment* s : segments) {</a>
<a name="ln4935">            if (s-&gt;empty()) {</a>
<a name="ln4936">                  if (s-&gt;header() || s-&gt;trailer())    // probably more segment types (system header)</a>
<a name="ln4937">                        s-&gt;setEnabled(false);</a>
<a name="ln4938">                  else</a>
<a name="ln4939">                        undo(new RemoveElement(s));</a>
<a name="ln4940">                  }</a>
<a name="ln4941">            }</a>
<a name="ln4942">      }</a>
<a name="ln4943"> </a>
<a name="ln4944">//---------------------------------------------------------</a>
<a name="ln4945">//   undoChangeSpannerElements</a>
<a name="ln4946">//---------------------------------------------------------</a>
<a name="ln4947"> </a>
<a name="ln4948">void Score::undoChangeSpannerElements(Spanner* spanner, Element* startElement, Element* endElement)</a>
<a name="ln4949">      {</a>
<a name="ln4950">      Element* oldStartElement = spanner-&gt;startElement();</a>
<a name="ln4951">      Element* oldEndElement = spanner-&gt;endElement();</a>
<a name="ln4952">      int startDeltaTrack = startElement &amp;&amp; oldStartElement ? startElement-&gt;track() - oldStartElement-&gt;track() : 0;</a>
<a name="ln4953">      int endDeltaTrack = endElement &amp;&amp; oldEndElement ? endElement-&gt;track() - oldEndElement-&gt;track() : 0;</a>
<a name="ln4954">      // scan all spanners linked to this one</a>
<a name="ln4955">      for (ScoreElement* el : spanner-&gt;linkList()) {</a>
<a name="ln4956">            Spanner* sp = toSpanner(el);</a>
<a name="ln4957">            Element* newStartElement = nullptr;</a>
<a name="ln4958">            Element* newEndElement = nullptr;</a>
<a name="ln4959">            // if not the current spanner, but one linked to it, determine its new start and end elements</a>
<a name="ln4960">            // as modifications 'parallel' to the modifications of the current spanner's start and end elements</a>
<a name="ln4961">            if (sp != spanner) {</a>
<a name="ln4962">                  if (startElement) {</a>
<a name="ln4963">                        // determine the track where to expect the 'parallel' start element</a>
<a name="ln4964">                        int newTrack = sp-&gt;startElement() ? sp-&gt;startElement()-&gt;track() + startDeltaTrack : 0;</a>
<a name="ln4965">                        // look in elements linked to new start element for an element with</a>
<a name="ln4966">                        // same score as linked spanner and appropriate track</a>
<a name="ln4967">                        for (ScoreElement* ee : startElement-&gt;linkList()) {</a>
<a name="ln4968">                              Element* e = toElement(ee);</a>
<a name="ln4969">                              if (e-&gt;score() == sp-&gt;score() &amp;&amp; e-&gt;track() == newTrack) {</a>
<a name="ln4970">                                    newStartElement = e;</a>
<a name="ln4971">                                    break;</a>
<a name="ln4972">                                    }</a>
<a name="ln4973">                              }</a>
<a name="ln4974">                        }</a>
<a name="ln4975">                  // similarly to determine the 'parallel' end element</a>
<a name="ln4976">                  if (endElement) {</a>
<a name="ln4977">                        int newTrack = sp-&gt;endElement() ? sp-&gt;endElement()-&gt;track() + endDeltaTrack : 0;</a>
<a name="ln4978">                        for (ScoreElement* ee : endElement-&gt;linkList()) {</a>
<a name="ln4979">                              Element* e = toElement(ee);</a>
<a name="ln4980">                              if (e-&gt;score() == sp-&gt;score() &amp;&amp; e-&gt;track() == newTrack) {</a>
<a name="ln4981">                                    newEndElement = e;</a>
<a name="ln4982">                                    break;</a>
<a name="ln4983">                                    }</a>
<a name="ln4984">                              }</a>
<a name="ln4985">                        }</a>
<a name="ln4986">                  }</a>
<a name="ln4987">            // if current spanner, just use stored start and end elements</a>
<a name="ln4988">            else {</a>
<a name="ln4989">                  newStartElement = startElement;</a>
<a name="ln4990">                  newEndElement = endElement;</a>
<a name="ln4991">                  }</a>
<a name="ln4992">            sp-&gt;score()-&gt;undo(new ChangeSpannerElements(sp, newStartElement, newEndElement));</a>
<a name="ln4993">            }</a>
<a name="ln4994">      }</a>
<a name="ln4995"> </a>
<a name="ln4996">//---------------------------------------------------------</a>
<a name="ln4997">//   undoChangeTuning</a>
<a name="ln4998">//---------------------------------------------------------</a>
<a name="ln4999"> </a>
<a name="ln5000">void Score::undoChangeTuning(Note* n, qreal v)</a>
<a name="ln5001">      {</a>
<a name="ln5002">      n-&gt;undoChangeProperty(Pid::TUNING, v);</a>
<a name="ln5003">      }</a>
<a name="ln5004"> </a>
<a name="ln5005">void Score::undoChangeUserMirror(Note* n, MScore::DirectionH d)</a>
<a name="ln5006">      {</a>
<a name="ln5007">      n-&gt;undoChangeProperty(Pid::MIRROR_HEAD, int(d));</a>
<a name="ln5008">      }</a>
<a name="ln5009"> </a>
<a name="ln5010">//---------------------------------------------------------</a>
<a name="ln5011">//   undoChangeTpc</a>
<a name="ln5012">//    TODO-TPC: check</a>
<a name="ln5013">//---------------------------------------------------------</a>
<a name="ln5014"> </a>
<a name="ln5015">void Score::undoChangeTpc(Note* note, int v)</a>
<a name="ln5016">      {</a>
<a name="ln5017">      note-&gt;undoChangeProperty(Pid::TPC1, v);</a>
<a name="ln5018">      }</a>
<a name="ln5019"> </a>
<a name="ln5020">//---------------------------------------------------------</a>
<a name="ln5021">//   undoAddBracket</a>
<a name="ln5022">//---------------------------------------------------------</a>
<a name="ln5023"> </a>
<a name="ln5024">void Score::undoAddBracket(Staff* staff, int level, BracketType type, int span)</a>
<a name="ln5025">      {</a>
<a name="ln5026">      undo(new AddBracket(staff, level, type, span));</a>
<a name="ln5027">      }</a>
<a name="ln5028"> </a>
<a name="ln5029">//---------------------------------------------------------</a>
<a name="ln5030">//   undoRemoveBracket</a>
<a name="ln5031">//---------------------------------------------------------</a>
<a name="ln5032"> </a>
<a name="ln5033">void Score::undoRemoveBracket(Bracket* b)</a>
<a name="ln5034">      {</a>
<a name="ln5035">      undo(new RemoveBracket(b-&gt;staff(), b-&gt;column(), b-&gt;bracketType(), b-&gt;span()));</a>
<a name="ln5036">      }</a>
<a name="ln5037"> </a>
<a name="ln5038">//---------------------------------------------------------</a>
<a name="ln5039">//   undoInsertTime</a>
<a name="ln5040">//   acts on the linked scores as well</a>
<a name="ln5041">//---------------------------------------------------------</a>
<a name="ln5042"> </a>
<a name="ln5043">void Score::undoInsertTime(const Fraction&amp; tick, const Fraction&amp; len)</a>
<a name="ln5044">      {</a>
<a name="ln5045">      if (len.isZero())</a>
<a name="ln5046">            return;</a>
<a name="ln5047"> </a>
<a name="ln5048">      QList&lt;Spanner*&gt; sl;</a>
<a name="ln5049">      for (auto i : _spanner.map()) {</a>
<a name="ln5050">            Spanner* s = i.second;</a>
<a name="ln5051">            if (s-&gt;tick2() &lt; tick)</a>
<a name="ln5052">                  continue;</a>
<a name="ln5053">            bool append = false;</a>
<a name="ln5054">            if (len &gt; Fraction(0, 1)) {</a>
<a name="ln5055">                  if (tick &gt; s-&gt;tick() &amp;&amp; tick &lt; s-&gt;tick2())</a>
<a name="ln5056">                        append = true;</a>
<a name="ln5057">                  else if (tick &lt;= s-&gt;tick())</a>
<a name="ln5058">                        append = true;</a>
<a name="ln5059">                  }</a>
<a name="ln5060">            else {</a>
<a name="ln5061">                  Fraction tick2 = tick - len;</a>
<a name="ln5062">                  if (s-&gt;tick() &gt;= tick2)</a>
<a name="ln5063">                        append = true;</a>
<a name="ln5064">                  else if (s-&gt;tick() &gt;= tick &amp;&amp; s-&gt;tick2() &lt;= tick2)</a>
<a name="ln5065">                        append = true;</a>
<a name="ln5066">                  else if ((s-&gt;tick() &lt;= tick) &amp;&amp; (s-&gt;tick2() &gt;= tick2)) {</a>
<a name="ln5067">                        Fraction t2 = s-&gt;tick2() + len;</a>
<a name="ln5068">                        if (t2 &gt; s-&gt;tick())</a>
<a name="ln5069">                              append = true;</a>
<a name="ln5070">                        }</a>
<a name="ln5071">                  else if (s-&gt;tick() &gt; tick &amp;&amp; s-&gt;tick2() &gt; tick2)</a>
<a name="ln5072">                        append = true;</a>
<a name="ln5073">                  else if (s-&gt;tick() &lt; tick &amp;&amp; s-&gt;tick2() &lt; tick2)</a>
<a name="ln5074">                        append = true;</a>
<a name="ln5075">                  }</a>
<a name="ln5076">            for (Spanner* ss : sl) {</a>
<a name="ln5077">                  if (ss-&gt;linkList().contains(s)) {</a>
<a name="ln5078">                        append = false;</a>
<a name="ln5079">                        break;</a>
<a name="ln5080">                        }</a>
<a name="ln5081">                  }</a>
<a name="ln5082">            if (append)</a>
<a name="ln5083">                  sl.append(s);</a>
<a name="ln5084">            }</a>
<a name="ln5085">      for (Spanner* s : sl) {</a>
<a name="ln5086">            if (len &gt; Fraction(0, 1)) {</a>
<a name="ln5087">                  if (tick &gt; s-&gt;tick() &amp;&amp; tick &lt; s-&gt;tick2()) {</a>
<a name="ln5088">                        //</a>
<a name="ln5089">                        //  case a:</a>
<a name="ln5090">                        //  +----spanner--------+</a>
<a name="ln5091">                        //    +---add---</a>
<a name="ln5092">                        //</a>
<a name="ln5093">                        s-&gt;undoChangeProperty(Pid::SPANNER_TICKS, s-&gt;ticks() + len);</a>
<a name="ln5094">                        }</a>
<a name="ln5095">                  else if (tick &lt;= s-&gt;tick()) {</a>
<a name="ln5096">                        //</a>
<a name="ln5097">                        //  case b:</a>
<a name="ln5098">                        //       +----spanner--------</a>
<a name="ln5099">                        //  +---add---</a>
<a name="ln5100">                        // and</a>
<a name="ln5101">                        //            +----spanner--------</a>
<a name="ln5102">                        //  +---add---+</a>
<a name="ln5103">                        Element* startElement = s-&gt;startElement();</a>
<a name="ln5104">                        Element* endElement = s-&gt;endElement();</a>
<a name="ln5105">                        undoChangeSpannerElements(s, nullptr, nullptr);</a>
<a name="ln5106">                        s-&gt;undoChangeProperty(Pid::SPANNER_TICK, s-&gt;tick() + len);</a>
<a name="ln5107">                        undoChangeSpannerElements(s, startElement, endElement);</a>
<a name="ln5108">                        }</a>
<a name="ln5109">                  }</a>
<a name="ln5110">            else {</a>
<a name="ln5111">                  Fraction tick2 = tick - len;</a>
<a name="ln5112">                  if (s-&gt;tick() &gt;= tick2) {</a>
<a name="ln5113">                        //</a>
<a name="ln5114">                        //  case A:</a>
<a name="ln5115">                        //  +----remove---+ +---spanner---+</a>
<a name="ln5116">                        //</a>
<a name="ln5117">                        Fraction t = s-&gt;tick() + len;</a>
<a name="ln5118">                        if (t &lt; Fraction(0,1))</a>
<a name="ln5119">                              t = Fraction(0,1);</a>
<a name="ln5120">                        Element* startElement = s-&gt;startElement();</a>
<a name="ln5121">                        Element* endElement = s-&gt;endElement();</a>
<a name="ln5122">                        undoChangeSpannerElements(s, nullptr, nullptr);</a>
<a name="ln5123">                        s-&gt;undoChangeProperty(Pid::SPANNER_TICK, t);</a>
<a name="ln5124">                        undoChangeSpannerElements(s, startElement, endElement);</a>
<a name="ln5125">                        }</a>
<a name="ln5126">                  else if (s-&gt;tick() &gt;= tick &amp;&amp; s-&gt;tick2() &lt;= tick2) {</a>
<a name="ln5127">                        //</a>
<a name="ln5128">                        //  case B:</a>
<a name="ln5129">                        //    +---spanner---+</a>
<a name="ln5130">                        //  +----remove--------+</a>
<a name="ln5131">                        //</a>
<a name="ln5132">                        undoRemoveElement(s);</a>
<a name="ln5133">                        }</a>
<a name="ln5134">                  else if ((s-&gt;tick() &lt;= tick) &amp;&amp; (s-&gt;tick2() &gt;= tick2)) {</a>
<a name="ln5135">                        //</a>
<a name="ln5136">                        //  case C:</a>
<a name="ln5137">                        //  +----spanner--------+</a>
<a name="ln5138">                        //    +---remove---+</a>
<a name="ln5139">                        //</a>
<a name="ln5140">                        Fraction t2 = s-&gt;tick2() + len;</a>
<a name="ln5141">                        if (t2 &gt; s-&gt;tick())</a>
<a name="ln5142">                              s-&gt;undoChangeProperty(Pid::SPANNER_TICKS, s-&gt;ticks() + len);</a>
<a name="ln5143">                        }</a>
<a name="ln5144">                  else if (s-&gt;tick() &gt; tick &amp;&amp; s-&gt;tick2() &gt; tick2) {</a>
<a name="ln5145">                        //</a>
<a name="ln5146">                        //  case D:</a>
<a name="ln5147">                        //       +----spanner--------+</a>
<a name="ln5148">                        //  +---remove---+</a>
<a name="ln5149">                        //</a>
<a name="ln5150">                        Fraction d1 = s-&gt;tick() - tick;</a>
<a name="ln5151">                        Fraction d2 = tick2 - s-&gt;tick();</a>
<a name="ln5152">                        Fraction le = s-&gt;ticks() - d2;</a>
<a name="ln5153">                        if (le.isZero())</a>
<a name="ln5154">                              undoRemoveElement(s);</a>
<a name="ln5155">                        else {</a>
<a name="ln5156">                              s-&gt;undoChangeProperty(Pid::SPANNER_TICK, s-&gt;tick() - d1);</a>
<a name="ln5157">                              s-&gt;undoChangeProperty(Pid::SPANNER_TICKS, le);</a>
<a name="ln5158">                              }</a>
<a name="ln5159">                        }</a>
<a name="ln5160">                  else if (s-&gt;tick() &lt; tick &amp;&amp; s-&gt;tick2() &lt; tick2) {</a>
<a name="ln5161">                        //</a>
<a name="ln5162">                        //  case E:</a>
<a name="ln5163">                        //       +----spanner--------+</a>
<a name="ln5164">                        //                     +---remove---+</a>
<a name="ln5165">                        //</a>
<a name="ln5166">                        Fraction d  = s-&gt;tick2() - tick;</a>
<a name="ln5167">                        Fraction le = s-&gt;ticks() - d;</a>
<a name="ln5168">                        if (le.isZero())</a>
<a name="ln5169">                              undoRemoveElement(s);</a>
<a name="ln5170">                        else</a>
<a name="ln5171">                              s-&gt;undoChangeProperty(Pid::SPANNER_TICKS, le);</a>
<a name="ln5172">                        }</a>
<a name="ln5173">                  }</a>
<a name="ln5174">            }</a>
<a name="ln5175"> </a>
<a name="ln5176">      undo(new InsertTimeUnmanagedSpanner(this, tick, len));</a>
<a name="ln5177">      }</a>
<a name="ln5178"> </a>
<a name="ln5179">//---------------------------------------------------------</a>
<a name="ln5180">//   undoRemoveMeasures</a>
<a name="ln5181">//---------------------------------------------------------</a>
<a name="ln5182"> </a>
<a name="ln5183">void Score::undoRemoveMeasures(Measure* m1, Measure* m2)</a>
<a name="ln5184">      {</a>
<a name="ln5185">      Q_ASSERT(m1 &amp;&amp; m2);</a>
<a name="ln5186"> </a>
<a name="ln5187">      const Fraction startTick = m1-&gt;tick();</a>
<a name="ln5188">      const Fraction endTick = m2-&gt;endTick();</a>
<a name="ln5189">      std::set&lt;Spanner*&gt; spannersToRemove;</a>
<a name="ln5190"> </a>
<a name="ln5191">      //</a>
<a name="ln5192">      //  handle ties which start before m1 and end in (m1-m2)</a>
<a name="ln5193">      //</a>
<a name="ln5194">      for (Segment* s = m1-&gt;first(); s != m2-&gt;last(); s = s-&gt;next1()) {</a>
<a name="ln5195">            if (!s-&gt;isChordRestType())</a>
<a name="ln5196">                  continue;</a>
<a name="ln5197">            for (int track = 0; track &lt; ntracks(); ++track) {</a>
<a name="ln5198">                  Element* e = s-&gt;element(track);</a>
<a name="ln5199">                  if (!e || !e-&gt;isChord())</a>
<a name="ln5200">                        continue;</a>
<a name="ln5201">                  Chord* c = toChord(e);</a>
<a name="ln5202">                  for (Note* n : c-&gt;notes()) {</a>
<a name="ln5203">                        // Remove ties crossing measure range boundaries</a>
<a name="ln5204">                        Tie* t = n-&gt;tieBack();</a>
<a name="ln5205">                        if (t &amp;&amp; (t-&gt;startNote()-&gt;chord()-&gt;tick() &lt; startTick))</a>
<a name="ln5206">                              undoRemoveElement(t);</a>
<a name="ln5207">                        t = n-&gt;tieFor();</a>
<a name="ln5208">                        if (t &amp;&amp; (t-&gt;endNote()-&gt;chord()-&gt;tick() &gt;= endTick))</a>
<a name="ln5209">                              undoRemoveElement(t);</a>
<a name="ln5210"> </a>
<a name="ln5211">                        // Do the same for other note-anchored spanners (e.g. glissandi).</a>
<a name="ln5212">                        // Delay actual removing to avoid modifying lists inside loops over them.</a>
<a name="ln5213">                        for (Spanner* sb : n-&gt;spannerBack()) {</a>
<a name="ln5214">                              if (sb-&gt;tick() &lt; startTick)</a>
<a name="ln5215">                                    spannersToRemove.insert(sb);</a>
<a name="ln5216">                              }</a>
<a name="ln5217">                        for (Spanner* sf : n-&gt;spannerFor()) {</a>
<a name="ln5218">                              if (sf-&gt;tick2() &gt;= endTick)</a>
<a name="ln5219">                                    spannersToRemove.insert(sf);</a>
<a name="ln5220">                              }</a>
<a name="ln5221">                        }</a>
<a name="ln5222">                  }</a>
<a name="ln5223">            }</a>
<a name="ln5224"> </a>
<a name="ln5225">      for (Spanner* s : spannersToRemove)</a>
<a name="ln5226">            undoRemoveElement(s);</a>
<a name="ln5227"> </a>
<a name="ln5228">      undo(new RemoveMeasures(m1, m2));</a>
<a name="ln5229">      }</a>
<a name="ln5230"> </a>
<a name="ln5231">}</a>

</code></pre>
<div class="balloon" rel="439"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'staffIdx < 0' is always true.</p></div>
<div class="balloon" rel="1971"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="2138"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'createEndBar' is always false.</p></div>
<div class="balloon" rel="2263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: s1.</p></div>
<div class="balloon" rel="2263"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v571/" target="_blank">V571</a> Recurring check. The 's1' condition was already verified in line 2261.</p></div>
<div class="balloon" rel="3565"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!ns' is always true.</p></div>
<div class="balloon" rel="4396"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: et != ElementType::NOTE.</p></div>
<div class="balloon" rel="4407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: et != ElementType::SYSTEM_TEXT.</p></div>
<div class="balloon" rel="4761"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'warning' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
