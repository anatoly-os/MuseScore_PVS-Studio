
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>durationtype.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;durationtype.h&quot;</a>
<a name="ln14">#include &quot;mscore.h&quot;</a>
<a name="ln15">#include &quot;note.h&quot;</a>
<a name="ln16">#include &quot;sig.h&quot;</a>
<a name="ln17">#include &quot;measure.h&quot;</a>
<a name="ln18"> </a>
<a name="ln19">namespace Ms {</a>
<a name="ln20"> </a>
<a name="ln21">//---------------------------------------------------------</a>
<a name="ln22">//   dots</a>
<a name="ln23">//---------------------------------------------------------</a>
<a name="ln24"> </a>
<a name="ln25">static int getDots(int base, int rest, char* dots)</a>
<a name="ln26">      {</a>
<a name="ln27">      if (base &lt; 16)</a>
<a name="ln28">           return rest;</a>
<a name="ln29">      *dots = 0;</a>
<a name="ln30">      if (rest &gt;= base / 2) {</a>
<a name="ln31">            *dots = *dots + 1;</a>
<a name="ln32">            rest -= base / 2;</a>
<a name="ln33">            }</a>
<a name="ln34">      if (rest &gt;= base / 4) {</a>
<a name="ln35">            *dots = *dots + 1;</a>
<a name="ln36">            rest -= base / 4;</a>
<a name="ln37">            }</a>
<a name="ln38">      if (rest &gt;= base / 8) {</a>
<a name="ln39">            *dots = *dots + 1;</a>
<a name="ln40">            rest -= base / 8;</a>
<a name="ln41">            }</a>
<a name="ln42">      if (rest &gt;= base / 16) {</a>
<a name="ln43">            *dots = *dots + 1;</a>
<a name="ln44">            rest -= base / 16;</a>
<a name="ln45">            }</a>
<a name="ln46">      if (*dots &gt; MAX_DOTS)</a>
<a name="ln47">            *dots = MAX_DOTS;</a>
<a name="ln48">      return rest;</a>
<a name="ln49">      }</a>
<a name="ln50"> </a>
<a name="ln51">//---------------------------------------------------------</a>
<a name="ln52">//   setDots</a>
<a name="ln53">//---------------------------------------------------------</a>
<a name="ln54"> </a>
<a name="ln55">void TDuration::setDots(int v)</a>
<a name="ln56">      {</a>
<a name="ln57">      if (v &gt; MAX_DOTS)</a>
<a name="ln58">            v = MAX_DOTS;</a>
<a name="ln59">      if (v &lt; 0)</a>
<a name="ln60">            v = 0;</a>
<a name="ln61">      _dots = v;</a>
<a name="ln62">      }</a>
<a name="ln63"> </a>
<a name="ln64">//---------------------------------------------------------</a>
<a name="ln65">//   setVal</a>
<a name="ln66">//---------------------------------------------------------</a>
<a name="ln67"> </a>
<a name="ln68">void TDuration::setVal(int ticks)</a>
<a name="ln69">      {</a>
<a name="ln70">      if (ticks == 0)</a>
<a name="ln71">            _val = DurationType::V_MEASURE;</a>
<a name="ln72">      else {</a>
<a name="ln73">            TDuration dt;</a>
<a name="ln74">            for (int i = 0; i &lt; int(TDuration::DurationType::V_ZERO); ++i) {</a>
<a name="ln75">                  dt.setType(TDuration::DurationType(i));</a>
<a name="ln76">                  int t = dt.ticks().ticks();</a>
<a name="ln77">                  if (ticks / t) {</a>
<a name="ln78">                        int remain = ticks % t;</a>
<a name="ln79">                        if ((t - remain) &lt; (t/4)) {</a>
<a name="ln80">                              _val = DurationType(i - 1);</a>
<a name="ln81">                              return;</a>
<a name="ln82">                              }</a>
<a name="ln83">                        _val = DurationType(i);</a>
<a name="ln84">                        getDots(t, remain, &amp;_dots);</a>
<a name="ln85">                        return;</a>
<a name="ln86">                        }</a>
<a name="ln87">                  }</a>
<a name="ln88">            qDebug(&quot;2: no duration type for ticks %d&quot;, ticks);</a>
<a name="ln89">            _val = DurationType::V_QUARTER;       // fallback default value</a>
<a name="ln90">            }</a>
<a name="ln91">      }</a>
<a name="ln92"> </a>
<a name="ln93">//---------------------------------------------------------</a>
<a name="ln94">//   ticks</a>
<a name="ln95">//---------------------------------------------------------</a>
<a name="ln96"> </a>
<a name="ln97">Fraction TDuration::ticks() const</a>
<a name="ln98">      {</a>
<a name="ln99">      Fraction t;</a>
<a name="ln100">      switch(_val) {</a>
<a name="ln101">            case DurationType::V_QUARTER: t = Fraction(1, 4);    break;</a>
<a name="ln102">            case DurationType::V_1024TH:  t = Fraction(1, 1024); break;</a>
<a name="ln103">            case DurationType::V_512TH:   t = Fraction(1, 512);  break;</a>
<a name="ln104">            case DurationType::V_256TH:   t = Fraction(1, 256);  break;</a>
<a name="ln105">            case DurationType::V_128TH:   t = Fraction(1, 128);  break;</a>
<a name="ln106">            case DurationType::V_64TH:    t = Fraction(1, 64);   break;</a>
<a name="ln107">            case DurationType::V_32ND:    t = Fraction(1, 32);   break;</a>
<a name="ln108">            case DurationType::V_16TH:    t = Fraction(1, 16);   break;</a>
<a name="ln109">            case DurationType::V_EIGHTH:  t = Fraction(1, 8);    break;</a>
<a name="ln110">            case DurationType::V_HALF:    t = Fraction(1, 2);    break;</a>
<a name="ln111">            case DurationType::V_WHOLE:   t = Fraction(1, 1);    break;</a>
<a name="ln112">            case DurationType::V_BREVE:   t = Fraction(2, 1);    break;</a>
<a name="ln113">            case DurationType::V_LONG:    t = Fraction(4, 1);    break;</a>
<a name="ln114">            case DurationType::V_ZERO:</a>
<a name="ln115">            case DurationType::V_MEASURE:</a>
<a name="ln116">                  return Fraction(0,1);</a>
<a name="ln117">            default:</a>
<a name="ln118">            case DurationType::V_INVALID:</a>
<a name="ln119">                  return Fraction(-1,1);</a>
<a name="ln120">            }</a>
<a name="ln121">      Fraction tmp = t;</a>
<a name="ln122">      for (int i = 0; i &lt; _dots; ++i) {</a>
<a name="ln123">            tmp *= Fraction(1,2);</a>
<a name="ln124">            t += tmp;</a>
<a name="ln125">            }</a>
<a name="ln126">      return t;</a>
<a name="ln127">      }</a>
<a name="ln128"> </a>
<a name="ln129">//---------------------------------------------------------</a>
<a name="ln130">//   name</a>
<a name="ln131">//---------------------------------------------------------</a>
<a name="ln132"> </a>
<a name="ln133">QString TDuration::name() const</a>
<a name="ln134">      {</a>
<a name="ln135">      switch(_val) {</a>
<a name="ln136">            case DurationType::V_QUARTER:   return &quot;quarter&quot;;</a>
<a name="ln137">            case DurationType::V_EIGHTH:    return &quot;eighth&quot;;</a>
<a name="ln138">            case DurationType::V_1024TH:    return &quot;1024th&quot;;</a>
<a name="ln139">            case DurationType::V_512TH:     return &quot;512th&quot;;</a>
<a name="ln140">            case DurationType::V_256TH:     return &quot;256th&quot;;</a>
<a name="ln141">            case DurationType::V_128TH:     return &quot;128th&quot;;</a>
<a name="ln142">            case DurationType::V_64TH:      return &quot;64th&quot;;</a>
<a name="ln143">            case DurationType::V_32ND:      return &quot;32nd&quot;;</a>
<a name="ln144">            case DurationType::V_16TH:      return &quot;16th&quot;;</a>
<a name="ln145">            case DurationType::V_HALF:      return &quot;half&quot;;</a>
<a name="ln146">            case DurationType::V_WHOLE:     return &quot;whole&quot;;</a>
<a name="ln147">            case DurationType::V_MEASURE:   return &quot;measure&quot;;</a>
<a name="ln148">            case DurationType::V_BREVE:     return &quot;breve&quot;;</a>
<a name="ln149">            case DurationType::V_LONG:      return &quot;long&quot;;</a>
<a name="ln150">            default:</a>
<a name="ln151">qDebug(&quot;TDuration::name(): invalid duration type %d&quot;, static_cast&lt;int&gt;(_val));</a>
<a name="ln152">                 // fall through</a>
<a name="ln153">            case DurationType::V_ZERO:</a>
<a name="ln154">            case DurationType::V_INVALID:   return &quot;&quot;;</a>
<a name="ln155">            }</a>
<a name="ln156">      }</a>
<a name="ln157"> </a>
<a name="ln158">//---------------------------------------------------------</a>
<a name="ln159">//   headType</a>
<a name="ln160">//---------------------------------------------------------</a>
<a name="ln161"> </a>
<a name="ln162">NoteHead::Type TDuration::headType() const</a>
<a name="ln163">      {</a>
<a name="ln164">      NoteHead::Type headType = NoteHead::Type::HEAD_WHOLE;</a>
<a name="ln165">      switch(_val) {</a>
<a name="ln166">            case DurationType::V_1024TH:</a>
<a name="ln167">            case DurationType::V_512TH:</a>
<a name="ln168">            case DurationType::V_256TH:</a>
<a name="ln169">            case DurationType::V_128TH:</a>
<a name="ln170">            case DurationType::V_64TH:</a>
<a name="ln171">            case DurationType::V_32ND:</a>
<a name="ln172">            case DurationType::V_16TH:</a>
<a name="ln173">            case DurationType::V_EIGHTH:</a>
<a name="ln174">            case DurationType::V_QUARTER:</a>
<a name="ln175">                  headType = NoteHead::Type::HEAD_QUARTER;</a>
<a name="ln176">                  break;</a>
<a name="ln177">            case DurationType::V_HALF:</a>
<a name="ln178">                  headType = NoteHead::Type::HEAD_HALF;</a>
<a name="ln179">                  break;</a>
<a name="ln180">            case DurationType::V_MEASURE:</a>
<a name="ln181">            case DurationType::V_WHOLE:</a>
<a name="ln182">                  headType = NoteHead::Type::HEAD_WHOLE;</a>
<a name="ln183">                  break;</a>
<a name="ln184">            case DurationType::V_BREVE:</a>
<a name="ln185">                  headType = NoteHead::Type::HEAD_BREVIS;</a>
<a name="ln186">                  break;</a>
<a name="ln187">            case DurationType::V_LONG:</a>
<a name="ln188">                  headType = NoteHead::Type::HEAD_BREVIS;</a>
<a name="ln189">                  break;</a>
<a name="ln190">            default:</a>
<a name="ln191">            case DurationType::V_INVALID:</a>
<a name="ln192">            case DurationType::V_ZERO:</a>
<a name="ln193">                  headType = NoteHead::Type::HEAD_QUARTER;</a>
<a name="ln194">                  break;</a>
<a name="ln195">            }</a>
<a name="ln196">      return headType;</a>
<a name="ln197">      }</a>
<a name="ln198"> </a>
<a name="ln199">//---------------------------------------------------------</a>
<a name="ln200">//   hooks</a>
<a name="ln201">//---------------------------------------------------------</a>
<a name="ln202"> </a>
<a name="ln203">int TDuration::hooks() const</a>
<a name="ln204">      {</a>
<a name="ln205">      static const int table[] = {</a>
<a name="ln206">         // V_LONG, V_BREVE, V_WHOLE, V_HALF, V_QUARTER, V_EIGHTH, V_16TH,</a>
<a name="ln207">            0,      0,       0,       0,      0,         1,        2,</a>
<a name="ln208">         // V_32ND, V_64TH, V_128TH, V_256TH, V_512TH, V_1024TH,</a>
<a name="ln209">            3,      4,       5,       6,      7,       8,</a>
<a name="ln210">         // V_ZERO, V_MEASURE, V_INVALID</a>
<a name="ln211">            0,      0,       0</a>
<a name="ln212">            };</a>
<a name="ln213">      return table[int(_val)];</a>
<a name="ln214">      }</a>
<a name="ln215"> </a>
<a name="ln216">//---------------------------------------------------------</a>
<a name="ln217">//   hasStem</a>
<a name="ln218">//---------------------------------------------------------</a>
<a name="ln219"> </a>
<a name="ln220">bool TDuration::hasStem() const</a>
<a name="ln221">      {</a>
<a name="ln222">      switch(_val) {</a>
<a name="ln223">            case DurationType::V_1024TH:</a>
<a name="ln224">            case DurationType::V_512TH:</a>
<a name="ln225">            case DurationType::V_256TH:</a>
<a name="ln226">            case DurationType::V_128TH:</a>
<a name="ln227">            case DurationType::V_64TH:</a>
<a name="ln228">            case DurationType::V_32ND:</a>
<a name="ln229">            case DurationType::V_16TH:</a>
<a name="ln230">            case DurationType::V_EIGHTH:</a>
<a name="ln231">            case DurationType::V_QUARTER:</a>
<a name="ln232">            case DurationType::V_HALF:</a>
<a name="ln233">            case DurationType::V_LONG:</a>
<a name="ln234">                  return true;</a>
<a name="ln235">            default:</a>
<a name="ln236">                  return false;</a>
<a name="ln237">            }</a>
<a name="ln238">      }</a>
<a name="ln239"> </a>
<a name="ln240">//---------------------------------------------------------</a>
<a name="ln241">//   setVal</a>
<a name="ln242">//---------------------------------------------------------</a>
<a name="ln243"> </a>
<a name="ln244">TDuration::TDuration(const QString&amp; s)</a>
<a name="ln245">      {</a>
<a name="ln246">      setType(s);</a>
<a name="ln247">      _dots = 0;</a>
<a name="ln248">      }</a>
<a name="ln249"> </a>
<a name="ln250">//---------------------------------------------------------</a>
<a name="ln251">//   setType</a>
<a name="ln252">//---------------------------------------------------------</a>
<a name="ln253"> </a>
<a name="ln254">void TDuration::setType(const QString&amp; s)</a>
<a name="ln255">      {</a>
<a name="ln256">      if (s == &quot;quarter&quot;)</a>
<a name="ln257">            _val = DurationType::V_QUARTER;</a>
<a name="ln258">      else if (s == &quot;eighth&quot;)</a>
<a name="ln259">            _val = DurationType::V_EIGHTH;</a>
<a name="ln260">      else if (s == &quot;1024th&quot;)</a>
<a name="ln261">            _val = DurationType::V_1024TH;</a>
<a name="ln262">      else if (s == &quot;512th&quot;)</a>
<a name="ln263">            _val = DurationType::V_512TH;</a>
<a name="ln264">      else if (s == &quot;256th&quot;)</a>
<a name="ln265">            _val = DurationType::V_256TH;</a>
<a name="ln266">      else if (s == &quot;128th&quot;)</a>
<a name="ln267">            _val = DurationType::V_128TH;</a>
<a name="ln268">      else if (s == &quot;64th&quot;)</a>
<a name="ln269">            _val = DurationType::V_64TH;</a>
<a name="ln270">      else if (s == &quot;32nd&quot;)</a>
<a name="ln271">            _val = DurationType::V_32ND;</a>
<a name="ln272">      else if (s == &quot;16th&quot;)</a>
<a name="ln273">            _val = DurationType::V_16TH;</a>
<a name="ln274">      else if (s == &quot;half&quot;)</a>
<a name="ln275">            _val = DurationType::V_HALF;</a>
<a name="ln276">      else if (s == &quot;whole&quot;)</a>
<a name="ln277">            _val = DurationType::V_WHOLE;</a>
<a name="ln278">      else if (s == &quot;breve&quot;)</a>
<a name="ln279">            _val = DurationType::V_BREVE;</a>
<a name="ln280">      else if (s == &quot;long&quot;)</a>
<a name="ln281">            _val = DurationType::V_LONG;</a>
<a name="ln282">      else if (s == &quot;measure&quot;)</a>
<a name="ln283">            _val = DurationType::V_MEASURE;</a>
<a name="ln284">      else {</a>
<a name="ln285">            // _val = V_INVALID;</a>
<a name="ln286">            _val = DurationType::V_QUARTER;</a>
<a name="ln287">            qDebug(&quot;TDuration::setType(%s): unknown, assume \&quot;quarter\&quot;&quot;, qPrintable(s));</a>
<a name="ln288">            }</a>
<a name="ln289">      }</a>
<a name="ln290"> </a>
<a name="ln291">//---------------------------------------------------------</a>
<a name="ln292">//   shiftType</a>
<a name="ln293">//    If stepDotted = false, duration type will inc/dec by</a>
<a name="ln294">//    nSteps with _dots remaining same.</a>
<a name="ln295">//</a>
<a name="ln296">//    If stepDotted = true, duration will round toward zero</a>
<a name="ln297">//    to next single-dotted or undotted duration and then</a>
<a name="ln298">//    will included dotted durations when stepping</a>
<a name="ln299">//---------------------------------------------------------</a>
<a name="ln300"> </a>
<a name="ln301">void TDuration::shiftType(int nSteps, bool stepDotted)</a>
<a name="ln302">      {</a>
<a name="ln303">      if (_val == DurationType::V_MEASURE || _val == DurationType::V_INVALID || _val == DurationType::V_ZERO)</a>
<a name="ln304">            setType(DurationType::V_INVALID);</a>
<a name="ln305">      else {</a>
<a name="ln306">            int newValue;</a>
<a name="ln307">            int newDots;</a>
<a name="ln308">            if (stepDotted) {</a>
<a name="ln309">                  // figure out the new duration in terms of the number of single dotted or undotted steps from DurationType::V_LONG</a>
<a name="ln310">                  int roundDownSingleDots = (_dots &gt; 0) ? -1 : 0;</a>
<a name="ln311">                  int newValAsNumSingleDotSteps = int(_val) * 2 + roundDownSingleDots + nSteps;</a>
<a name="ln312"> </a>
<a name="ln313">                  // convert that new duration back into terms of DurationType integer value and number of dots</a>
<a name="ln314">                  newDots  = newValAsNumSingleDotSteps % 2; // odd means there is a dot</a>
<a name="ln315">                  newValue = newValAsNumSingleDotSteps / 2 + newDots; // if new duration has a dot, then that</a>
<a name="ln316">                  }</a>
<a name="ln317">            else {</a>
<a name="ln318">                  newDots = _dots;</a>
<a name="ln319">                  newValue = int(_val) + nSteps;</a>
<a name="ln320">                  }</a>
<a name="ln321"> </a>
<a name="ln322">            if ((newValue &lt; int(DurationType::V_LONG)) || (newValue &gt; int(DurationType::V_1024TH)) ||</a>
<a name="ln323">                 ((newValue &gt;= int(DurationType::V_1024TH)) &amp;&amp; (newDots &gt;= 1)) ||</a>
<a name="ln324">                 ((newValue &gt;= int(DurationType::V_512TH))  &amp;&amp; (newDots &gt;= 2)) ||</a>
<a name="ln325">                 ((newValue &gt;= int(DurationType::V_256TH))  &amp;&amp; (newDots &gt;= 3)) ||</a>
<a name="ln326">                 ((newValue &gt;= int(DurationType::V_128TH))  &amp;&amp; (newDots &gt;= 4)))</a>
<a name="ln327">                  setType(DurationType::V_INVALID);</a>
<a name="ln328">            else {</a>
<a name="ln329">                  setType(DurationType(newValue));</a>
<a name="ln330">                  setDots(newDots);</a>
<a name="ln331">                  }</a>
<a name="ln332">            }</a>
<a name="ln333">      }</a>
<a name="ln334"> </a>
<a name="ln335">//---------------------------------------------------------</a>
<a name="ln336">//   operator&lt;</a>
<a name="ln337">//---------------------------------------------------------</a>
<a name="ln338"> </a>
<a name="ln339">bool TDuration::operator&lt;(const TDuration&amp; t) const</a>
<a name="ln340">      {</a>
<a name="ln341">      if (t._val &lt; _val)</a>
<a name="ln342">            return true;</a>
<a name="ln343">      if (t._val == _val) {</a>
<a name="ln344">            if (_dots &lt; t._dots)</a>
<a name="ln345">                  return true;</a>
<a name="ln346">            }</a>
<a name="ln347">      return false;</a>
<a name="ln348">      }</a>
<a name="ln349"> </a>
<a name="ln350">//---------------------------------------------------------</a>
<a name="ln351">//   operator&gt;=</a>
<a name="ln352">//---------------------------------------------------------</a>
<a name="ln353"> </a>
<a name="ln354">bool TDuration::operator&gt;=(const TDuration&amp; t) const</a>
<a name="ln355">      {</a>
<a name="ln356">      if (t._val &gt; _val)</a>
<a name="ln357">            return true;</a>
<a name="ln358">      if (t._val == _val) {</a>
<a name="ln359">            if (_dots &gt;= t._dots)</a>
<a name="ln360">                  return true;</a>
<a name="ln361">            }</a>
<a name="ln362">      return false;</a>
<a name="ln363">      }</a>
<a name="ln364"> </a>
<a name="ln365">//---------------------------------------------------------</a>
<a name="ln366">//   operator&lt;=</a>
<a name="ln367">//---------------------------------------------------------</a>
<a name="ln368"> </a>
<a name="ln369">bool TDuration::operator&lt;=(const TDuration&amp; t) const</a>
<a name="ln370">      {</a>
<a name="ln371">      if (t._val &lt; _val)</a>
<a name="ln372">            return true;</a>
<a name="ln373">      if (t._val == _val) {</a>
<a name="ln374">            if (_dots &lt;= t._dots)</a>
<a name="ln375">                  return true;</a>
<a name="ln376">            }</a>
<a name="ln377">      return false;</a>
<a name="ln378">      }</a>
<a name="ln379"> </a>
<a name="ln380">//---------------------------------------------------------</a>
<a name="ln381">//   operator&gt;</a>
<a name="ln382">//---------------------------------------------------------</a>
<a name="ln383"> </a>
<a name="ln384">bool TDuration::operator&gt;(const TDuration&amp; t) const</a>
<a name="ln385">      {</a>
<a name="ln386">      if (t._val &gt; _val)</a>
<a name="ln387">            return true;</a>
<a name="ln388">      if (t._val == _val) {</a>
<a name="ln389">            if (_dots &gt; t._dots)</a>
<a name="ln390">                  return true;</a>
<a name="ln391">            }</a>
<a name="ln392">      return false;</a>
<a name="ln393">      }</a>
<a name="ln394"> </a>
<a name="ln395">//---------------------------------------------------------</a>
<a name="ln396">//   fraction</a>
<a name="ln397">//---------------------------------------------------------</a>
<a name="ln398"> </a>
<a name="ln399">Fraction TDuration::fraction() const</a>
<a name="ln400">      {</a>
<a name="ln401">      int z = 1;</a>
<a name="ln402">      unsigned n;</a>
<a name="ln403">      switch(_val) {</a>
<a name="ln404">            case DurationType::V_1024TH:    n = 1024;     break;</a>
<a name="ln405">            case DurationType::V_512TH:     n = 512;      break;</a>
<a name="ln406">            case DurationType::V_256TH:     n = 256;      break;</a>
<a name="ln407">            case DurationType::V_128TH:     n = 128;      break;</a>
<a name="ln408">            case DurationType::V_64TH:      n = 64;       break;</a>
<a name="ln409">            case DurationType::V_32ND:      n = 32;       break;</a>
<a name="ln410">            case DurationType::V_16TH:      n = 16;       break;</a>
<a name="ln411">            case DurationType::V_EIGHTH:    n = 8;        break;</a>
<a name="ln412">            case DurationType::V_QUARTER:   n = 4;        break;</a>
<a name="ln413">            case DurationType::V_HALF:      n = 2;        break;</a>
<a name="ln414">            case DurationType::V_WHOLE:     n = 1;        break;</a>
<a name="ln415">            case DurationType::V_BREVE:     z = 2; n = 1; break;</a>
<a name="ln416">            case DurationType::V_LONG:      z = 4; n = 1; break;</a>
<a name="ln417">            case DurationType::V_ZERO:      z = 0; n = 1; break;</a>
<a name="ln418">            default:          z = 0; n = 0; break;    // zero+invalid fraction</a>
<a name="ln419">            }</a>
<a name="ln420">      Fraction a(z, n);</a>
<a name="ln421">      if (a.isValid()) {</a>
<a name="ln422">            for (int i = 0; i &lt; _dots; ++i) {</a>
<a name="ln423">                  n *= 2;</a>
<a name="ln424">                  a += Fraction(z, n);</a>
<a name="ln425">                  }</a>
<a name="ln426">            }</a>
<a name="ln427">      return a;</a>
<a name="ln428">      }</a>
<a name="ln429"> </a>
<a name="ln430">// Longest TDuration that fits into Fraction. Must fit exactly if truncate = false.</a>
<a name="ln431">TDuration::TDuration(const Fraction&amp; l, bool truncate, int maxDots, DurationType maxType)</a>
<a name="ln432">      {</a>
<a name="ln433">#ifdef NDEBUG</a>
<a name="ln434">      Q_UNUSED(truncate);</a>
<a name="ln435">#endif</a>
<a name="ln436">      setType(maxType); // use maxType to avoid testing all types if you know that l is smaller than a certain DurationType</a>
<a name="ln437">      setDots(maxDots);</a>
<a name="ln438">      truncateToFraction(l, maxDots);</a>
<a name="ln439">      Q_ASSERT(truncate || (fraction() - l).numerator() == 0); // check for exact fit</a>
<a name="ln440">      }</a>
<a name="ln441"> </a>
<a name="ln442">//---------------------------------------------------------</a>
<a name="ln443">//   truncateToFraction</a>
<a name="ln444">//---------------------------------------------------------</a>
<a name="ln445"> </a>
<a name="ln446">void TDuration::truncateToFraction(const Fraction&amp; l, int maxDots)</a>
<a name="ln447">      {</a>
<a name="ln448">      // try to fit in l by reducing number of duration dots</a>
<a name="ln449">      if (setDotsToFitFraction(l, _dots))</a>
<a name="ln450">            return;</a>
<a name="ln451"> </a>
<a name="ln452">      // that wasn't enough so now change type too</a>
<a name="ln453">      for (shiftType(1); isValid(); shiftType(1)) {</a>
<a name="ln454">            if (setDotsToFitFraction(l, maxDots))</a>
<a name="ln455">                  return; // duration fits fits in l</a>
<a name="ln456">            }</a>
<a name="ln457"> </a>
<a name="ln458">      }</a>
<a name="ln459"> </a>
<a name="ln460">//---------------------------------------------------------</a>
<a name="ln461">//   setDotsToFitFraction</a>
<a name="ln462">//---------------------------------------------------------</a>
<a name="ln463"> </a>
<a name="ln464">bool TDuration::setDotsToFitFraction(const Fraction&amp; l, int maxDots)</a>
<a name="ln465">      {</a>
<a name="ln466">      for ( ; maxDots &gt;= 0; maxDots--) {</a>
<a name="ln467">            _dots = maxDots; // ensures _dots &gt;= 0 if function returns false.</a>
<a name="ln468">            if ((fraction() - l).numerator() &lt;= 0)</a>
<a name="ln469">                  return true; // duration fits in l</a>
<a name="ln470">            }</a>
<a name="ln471"> </a>
<a name="ln472">      return false; // doesn't fit by changing dots alone (type needs to be changed too)</a>
<a name="ln473">      }</a>
<a name="ln474"> </a>
<a name="ln475">//---------------------------------------------------------</a>
<a name="ln476">//   operator -=</a>
<a name="ln477">//---------------------------------------------------------</a>
<a name="ln478"> </a>
<a name="ln479">TDuration&amp; TDuration::operator-=(const TDuration&amp; t)</a>
<a name="ln480">      {</a>
<a name="ln481">      Fraction f1 = fraction() - t.fraction();</a>
<a name="ln482">      TDuration d(f1);</a>
<a name="ln483">      _val  = d._val;</a>
<a name="ln484">      _dots = d._dots;</a>
<a name="ln485">      return *this;</a>
<a name="ln486">      }</a>
<a name="ln487"> </a>
<a name="ln488">//---------------------------------------------------------</a>
<a name="ln489">//   operator +=</a>
<a name="ln490">//---------------------------------------------------------</a>
<a name="ln491"> </a>
<a name="ln492">TDuration&amp; TDuration::operator+=(const TDuration&amp; t)</a>
<a name="ln493">      {</a>
<a name="ln494">      Fraction f1 = fraction() + t.fraction();</a>
<a name="ln495">      TDuration d(f1);</a>
<a name="ln496">      _val  = d._val;</a>
<a name="ln497">      _dots = d._dots;</a>
<a name="ln498">      return *this;</a>
<a name="ln499">      }</a>
<a name="ln500"> </a>
<a name="ln501">//---------------------------------------------------------</a>
<a name="ln502">//   toDurationList</a>
<a name="ln503">//---------------------------------------------------------</a>
<a name="ln504"> </a>
<a name="ln505">std::vector&lt;TDuration&gt; toDurationList(Fraction l, bool useDots, int maxDots, bool printRestRemains)</a>
<a name="ln506">      {</a>
<a name="ln507">      std::vector&lt;TDuration&gt; dList;</a>
<a name="ln508">      dList.reserve(8);</a>
<a name="ln509"> </a>
<a name="ln510">      if (!useDots)</a>
<a name="ln511">            maxDots = 0;</a>
<a name="ln512"> </a>
<a name="ln513">      for (TDuration dd(l, true, maxDots); dd.isValid() &amp;&amp; l.numerator() &gt; 0; dd = TDuration(l, true, maxDots, dd.type())) {</a>
<a name="ln514">            dList.push_back(dd);</a>
<a name="ln515">            l -= dd.fraction();</a>
<a name="ln516">            }</a>
<a name="ln517"> </a>
<a name="ln518">      if (printRestRemains &amp;&amp; l.numerator() != 0)</a>
<a name="ln519">            qDebug(&quot;toDurationList:: rest remains %d/%d&quot;, l.numerator(), l.denominator());</a>
<a name="ln520"> </a>
<a name="ln521">      return dList;</a>
<a name="ln522">      }</a>
<a name="ln523"> </a>
<a name="ln524">//---------------------------------------------------------</a>
<a name="ln525">//   toRhythmicDurationList</a>
<a name="ln526">//---------------------------------------------------------</a>
<a name="ln527"> </a>
<a name="ln528">std::vector&lt;TDuration&gt; toRhythmicDurationList(const Fraction&amp; l, bool isRest, Fraction rtickStart, const TimeSigFrac&amp; nominal, Measure* msr, int maxDots)</a>
<a name="ln529">      {</a>
<a name="ln530">      std::vector&lt;TDuration&gt; dList;</a>
<a name="ln531">      dList.reserve(8);</a>
<a name="ln532"> </a>
<a name="ln533">      if (msr-&gt;isAnacrusis())</a>
<a name="ln534">            rtickStart = Fraction::fromTicks(nominal.ticksPerMeasure()) - rtickStart;</a>
<a name="ln535">      else if (isRest &amp;&amp; l == msr-&gt;ticks()) {</a>
<a name="ln536">            TDuration d = TDuration(TDuration::DurationType::V_MEASURE);</a>
<a name="ln537">            dList.push_back(d);</a>
<a name="ln538">            return dList;</a>
<a name="ln539">            }</a>
<a name="ln540"> </a>
<a name="ln541">      if (nominal.isCompound())</a>
<a name="ln542">            splitCompoundBeatsForList(&amp;dList, l, isRest, rtickStart, nominal, maxDots);</a>
<a name="ln543">      else</a>
<a name="ln544">            populateRhythmicList(&amp;dList, l, isRest, rtickStart, nominal, maxDots);</a>
<a name="ln545"> </a>
<a name="ln546">      return dList;</a>
<a name="ln547">      }</a>
<a name="ln548"> </a>
<a name="ln549">//---------------------------------------------------------</a>
<a name="ln550">//   populateRhythmicList</a>
<a name="ln551">//---------------------------------------------------------</a>
<a name="ln552"> </a>
<a name="ln553">void populateRhythmicList(std::vector&lt;TDuration&gt;* dList, const Fraction&amp; l, bool isRest, const Fraction&amp; rtickStart, const TimeSigFrac&amp; nominal, int maxDots)</a>
<a name="ln554">      {</a>
<a name="ln555">      Fraction rtickEnd = rtickStart + l;</a>
<a name="ln556"> </a>
<a name="ln557">      bool needToSplit = false; // do we need to split?</a>
<a name="ln558">      int rtickSplit = 0; // tick to split on if we need to</a>
<a name="ln559"> </a>
<a name="ln560">      // CHECK AT SUBBEAT LEVEL</a>
<a name="ln561"> </a>
<a name="ln562">      int startLevel            = nominal.rtick2subbeatLevel(rtickStart.ticks());</a>
<a name="ln563">      int endLevel              = nominal.rtick2subbeatLevel(rtickEnd.ticks());</a>
<a name="ln564">      int strongestLevelCrossed = nominal.strongestSubbeatLevelInRange(rtickStart.ticks(), rtickEnd.ticks(), &amp;rtickSplit); // sets rtickSplit</a>
<a name="ln565"> </a>
<a name="ln566">      if ((startLevel &lt; 0) || (endLevel &lt; 0) || (strongestLevelCrossed &lt; 0)) {</a>
<a name="ln567">            // Beyond maximum subbeat level so just split into largest possible durations.</a>
<a name="ln568">            std::vector&lt;TDuration&gt; dList2 = toDurationList(l, maxDots &gt; 0, maxDots, false);</a>
<a name="ln569">            dList-&gt;insert(dList-&gt;end(), dList2.begin(), dList2.end());</a>
<a name="ln570">            return;</a>
<a name="ln571">            }</a>
<a name="ln572"> </a>
<a name="ln573">      // split if we cross something stronger than where we start and end</a>
<a name="ln574">      if ((strongestLevelCrossed &lt; startLevel) &amp;&amp; (strongestLevelCrossed &lt; endLevel))</a>
<a name="ln575">            needToSplit = true;</a>
<a name="ln576">      // but don't split for level 1 syncopation (allow eight-note, quarter, quarter... to cross unstressed beats)</a>
<a name="ln577">      if (startLevel == endLevel &amp;&amp; strongestLevelCrossed == startLevel - 1)</a>
<a name="ln578">            needToSplit = false;</a>
<a name="ln579">      // nor for the next simplest case of level 2 syncopation (allow sixteenth-note, eighth, eighth... to cross unstressed beats)</a>
<a name="ln580">      if (startLevel == endLevel &amp;&amp; strongestLevelCrossed == startLevel - 2) {</a>
<a name="ln581">            // but disallow sixteenth-note, quarter, quarter...</a>
<a name="ln582">            int ticksToNext = nominal.ticksToNextSubbeat(rtickStart.ticks(), startLevel - 1);</a>
<a name="ln583">            int ticksPastPrev = nominal.ticksPastSubbeat(rtickStart.ticks(), startLevel - 1);</a>
<a name="ln584">            needToSplit = ticksToNext != ticksPastPrev;</a>
<a name="ln585">            }</a>
<a name="ln586"> </a>
<a name="ln587">      if (!needToSplit &amp;&amp; strongestLevelCrossed == 0) {</a>
<a name="ln588">            // NOW CHECK AT DENOMINATOR UNIT LEVEL AND BEAT LEVEL</a>
<a name="ln589">            BeatType startBeat = nominal.rtick2beatType(rtickStart.ticks());</a>
<a name="ln590">            BeatType endBeat   = nominal.rtick2beatType(rtickEnd.ticks());</a>
<a name="ln591"> </a>
<a name="ln592">            int dUnitsCrossed = 0; // number of timeSig denominator units the note/rest crosses</a>
<a name="ln593">            // if there is a choice of which beat to split on, should we use the first or last?</a>
<a name="ln594">            bool useLast = startBeat &lt;= BeatType::SIMPLE_UNSTRESSED; // split on the later beat if starting on a beat</a>
<a name="ln595"> </a>
<a name="ln596">            BeatType strongestBeatCrossed = nominal.strongestBeatInRange(rtickStart.ticks(), rtickEnd.ticks(), &amp;dUnitsCrossed, &amp;rtickSplit, useLast);</a>
<a name="ln597"> </a>
<a name="ln598">            needToSplit = forceRhythmicSplit(isRest, startBeat, endBeat, dUnitsCrossed, strongestBeatCrossed, nominal);</a>
<a name="ln599">            }</a>
<a name="ln600"> </a>
<a name="ln601">      if (!needToSplit) {</a>
<a name="ln602">            // CHECK THERE IS A DURATION THAT FITS</a>
<a name="ln603">            // crossed beats/subbeats were not important so try to avoid splitting</a>
<a name="ln604">            TDuration d = TDuration(l, true, maxDots);</a>
<a name="ln605">            if (d.fraction() == l) {</a>
<a name="ln606">                  // we can use a single duration - no need to split!</a>
<a name="ln607">                  dList-&gt;push_back(l);</a>
<a name="ln608">                  return;</a>
<a name="ln609">                  }</a>
<a name="ln610">            // no single TDuration fits so must split anyway</a>
<a name="ln611">            }</a>
<a name="ln612"> </a>
<a name="ln613">      // Split on the strongest beat or subbeat crossed</a>
<a name="ln614">      Fraction leftSplit   = Fraction::fromTicks(rtickSplit) - rtickStart;</a>
<a name="ln615">      Fraction rightSplit = l - leftSplit;</a>
<a name="ln616"> </a>
<a name="ln617">      // Recurse to see if we need to split further before adding to list</a>
<a name="ln618">      populateRhythmicList(dList, leftSplit, isRest, rtickStart, nominal, maxDots);</a>
<a name="ln619">      populateRhythmicList(dList, rightSplit, isRest, Fraction::fromTicks(rtickSplit) , nominal, maxDots);</a>
<a name="ln620">      }</a>
<a name="ln621"> </a>
<a name="ln622">//---------------------------------------------------------</a>
<a name="ln623">//   splitCompoundBeatsForList</a>
<a name="ln624">//    Split compound notes/rests where they enter a compound beat.</a>
<a name="ln625">//---------------------------------------------------------</a>
<a name="ln626"> </a>
<a name="ln627">void splitCompoundBeatsForList(std::vector&lt;TDuration&gt;* dList, const Fraction&amp; l, bool isRest,</a>
<a name="ln628">   const Fraction&amp; rtickStart, const TimeSigFrac&amp; nominal, int maxDots)</a>
<a name="ln629">      {</a>
<a name="ln630">      Fraction rtickEnd = rtickStart + l;</a>
<a name="ln631"> </a>
<a name="ln632">      BeatType startBeat = nominal.rtick2beatType(rtickStart.ticks());</a>
<a name="ln633">      BeatType endBeat = nominal.rtick2beatType(rtickEnd.ticks());</a>
<a name="ln634"> </a>
<a name="ln635">      if (startBeat &gt; BeatType::COMPOUND_UNSTRESSED) {</a>
<a name="ln636">            // Not starting on a compound beat so mustn't extend into next compound beat</a>
<a name="ln637">            int splitTicks = nominal.ticksToNextBeat(rtickStart.ticks());</a>
<a name="ln638"> </a>
<a name="ln639">            if ((rtickEnd - rtickStart).ticks() &gt; splitTicks) {</a>
<a name="ln640">                  // Duration extends into next beat so must split</a>
<a name="ln641">                  Fraction leftSplit = Fraction::fromTicks(splitTicks);</a>
<a name="ln642">                  Fraction rightSplit = l - leftSplit;</a>
<a name="ln643">                  populateRhythmicList(dList, leftSplit, isRest, rtickStart, nominal, maxDots); // this side is ok to proceed</a>
<a name="ln644">                  splitCompoundBeatsForList(dList, rightSplit, isRest, rtickStart + Fraction::fromTicks(splitTicks), nominal, maxDots); // not checked yet</a>
<a name="ln645">                  return;</a>
<a name="ln646">                  }</a>
<a name="ln647">            }</a>
<a name="ln648"> </a>
<a name="ln649">      if (endBeat &gt; BeatType::COMPOUND_UNSTRESSED) {</a>
<a name="ln650">            // Not ending on a compound beat so mustn't extend into previous compound beat</a>
<a name="ln651">            int splitTicks = nominal.ticksPastBeat(rtickEnd.ticks());</a>
<a name="ln652"> </a>
<a name="ln653">            if ((rtickEnd - rtickStart).ticks() &gt; splitTicks) {</a>
<a name="ln654">                  // Duration extends into previous beat so must split</a>
<a name="ln655">                  Fraction rightSplit = Fraction::fromTicks(splitTicks);</a>
<a name="ln656">                  Fraction leftSplit = l - rightSplit;</a>
<a name="ln657">                  populateRhythmicList(dList, leftSplit, isRest, rtickStart, nominal, maxDots); // must add leftSplit to list first</a>
<a name="ln658">                  populateRhythmicList(dList, rightSplit, isRest, rtickEnd - Fraction::fromTicks(splitTicks), nominal, maxDots);</a>
<a name="ln659">                  return;</a>
<a name="ln660">                  }</a>
<a name="ln661">            }</a>
<a name="ln662"> </a>
<a name="ln663">      // Duration either starts and ends on compound beats, or it remains within a single compound beat</a>
<a name="ln664">      populateRhythmicList(dList, l, isRest, rtickStart, nominal, maxDots);</a>
<a name="ln665">      }</a>
<a name="ln666"> </a>
<a name="ln667">//---------------------------------------------------------</a>
<a name="ln668">//   forceRhythmicSplit</a>
<a name="ln669">//    Where to split notes and force a tie to indicate rhythm.</a>
<a name="ln670">//</a>
<a name="ln671">//    The function assumes the following:</a>
<a name="ln672">//      * Note/rest has already been split at measure boundaries.</a>
<a name="ln673">//      * Full measure rest was used if possible</a>
<a name="ln674">//      * Note/rest already split where it enters a compound beat.</a>
<a name="ln675">//</a>
<a name="ln676">//    Usage: Set crossedBeat to the strongest BeatType crossed by</a>
<a name="ln677">//    the note. Split note if function returns true. Repeat with</a>
<a name="ln678">//    the two new notes, and so on, until function returns false.</a>
<a name="ln679">//</a>
<a name="ln680">//    Note: If no single TDuration can fill the gap then the note</a>
<a name="ln681">//    *has* to be split, regardless of what this function returns.</a>
<a name="ln682">//    Non-rhythmic splits should still occur on the strongest beat.</a>
<a name="ln683">//</a>
<a name="ln684">//    Implementation: When comparing BeatTypes use &lt;, &lt;=, &gt;, &gt;=</a>
<a name="ln685">//    instead of == and != as appropriate (see sig.h). E.g. to match</a>
<a name="ln686">//    all full beats: &quot;&lt;= SIMPLE_UNSTRESSED&quot;. This will match for</a>
<a name="ln687">//    all compound and simple full beats, and not any subbeats.</a>
<a name="ln688">//---------------------------------------------------------</a>
<a name="ln689"> </a>
<a name="ln690">bool forceRhythmicSplit(bool isRest, BeatType startBeat, BeatType endBeat,</a>
<a name="ln691">   int dUnitsCrossed, BeatType strongestBeatCrossed, const TimeSigFrac&amp; nominal) {</a>
<a name="ln692"> </a>
<a name="ln693">      // Assumption: Notes were split at measure boundary before this function was</a>
<a name="ln694">      // called. (Necessary because timeSig might be different in next measure.)</a>
<a name="ln695">      Q_ASSERT(strongestBeatCrossed != BeatType::DOWNBEAT);</a>
<a name="ln696">      // Assumption: compound notes have already been split where they enter a compound beat.</a>
<a name="ln697">      // (Necessary because the split beat is not always the strongest beat in this case.)</a>
<a name="ln698">      Q_ASSERT(!nominal.isCompound() || strongestBeatCrossed &gt;= BeatType::COMPOUND_SUBBEAT</a>
<a name="ln699">            || (startBeat &lt;= BeatType::COMPOUND_UNSTRESSED &amp;&amp; endBeat &lt;= BeatType::COMPOUND_UNSTRESSED));</a>
<a name="ln700"> </a>
<a name="ln701">      // SPECIAL CASES</a>
<a name="ln702"> </a>
<a name="ln703">      // nothing can cross a stressed beat in an irregular time signature</a>
<a name="ln704">      if (strongestBeatCrossed &lt;= BeatType::SIMPLE_STRESSED &amp;&amp; !nominal.isTriple() &amp;&amp; !nominal.isDuple())</a>
<a name="ln705">            return true;</a>
<a name="ln706">      if (isRest) {</a>
<a name="ln707">            // rests must not cross the middle of a bar with numerator == 2 (e.g. 2/4 bar) even though the beat is unstressed</a>
<a name="ln708">            if (strongestBeatCrossed &lt;= BeatType::SIMPLE_UNSTRESSED &amp;&amp; nominal.numerator() == 2)</a>
<a name="ln709">                  return true;</a>
<a name="ln710">            // rests must not cross a beat in a triple meter - simple (e.g. 3/4) or compound (e.g. 9/8)</a>
<a name="ln711">            if (strongestBeatCrossed &lt;= BeatType::SIMPLE_UNSTRESSED &amp;&amp; nominal.isTriple())</a>
<a name="ln712">                  return true;</a>
<a name="ln713">            }</a>
<a name="ln714"> </a>
<a name="ln715">      // GENERAL RULES</a>
<a name="ln716"> </a>
<a name="ln717">      if (nominal.isCompound())</a>
<a name="ln718">            return forceRhythmicSplitCompound(isRest, startBeat, endBeat, dUnitsCrossed, strongestBeatCrossed);</a>
<a name="ln719">      else</a>
<a name="ln720">            return forceRhythmicSplitSimple(isRest, startBeat, endBeat, dUnitsCrossed, strongestBeatCrossed);</a>
<a name="ln721">      }</a>
<a name="ln722"> </a>
<a name="ln723">//---------------------------------------------------------</a>
<a name="ln724">//   forceRhythmicSplitCompound</a>
<a name="ln725">//---------------------------------------------------------</a>
<a name="ln726"> </a>
<a name="ln727">bool forceRhythmicSplitCompound(bool isRest, BeatType startBeat, BeatType endBeat, int dUnitsCrossed, BeatType strongestBeatCrossed)</a>
<a name="ln728">      {</a>
<a name="ln729">      switch (strongestBeatCrossed) {</a>
<a name="ln730">            case BeatType::COMPOUND_STRESSED:</a>
<a name="ln731">                  // Assumption: compound notes have already been split where they enter a compound beat.</a>
<a name="ln732">                  Q_ASSERT(startBeat &lt;= BeatType::COMPOUND_UNSTRESSED &amp;&amp; endBeat &lt;= BeatType::COMPOUND_UNSTRESSED);</a>
<a name="ln733">                  // Notes are guaranteed to and start on a compound beat so we can pretend we have a simple measure.</a>
<a name="ln734">                  return forceRhythmicSplitSimple(isRest, startBeat, endBeat, dUnitsCrossed / 3, BeatType::SIMPLE_STRESSED);</a>
<a name="ln735">            case BeatType::COMPOUND_UNSTRESSED:</a>
<a name="ln736">                  // Same assumption as before</a>
<a name="ln737">                  Q_ASSERT(startBeat &lt;= BeatType::COMPOUND_UNSTRESSED &amp;&amp; endBeat &lt;= BeatType::COMPOUND_UNSTRESSED);</a>
<a name="ln738">                  // No further conditions since note are guaranteed to start and end on a compound beat.</a>
<a name="ln739">                  return false;</a>
<a name="ln740">            case BeatType::COMPOUND_SUBBEAT:</a>
<a name="ln741">                  // don't split anything that takes up a full compound beat</a>
<a name="ln742">                  if (startBeat &lt;= BeatType::COMPOUND_UNSTRESSED &amp;&amp; endBeat &lt;= BeatType::COMPOUND_UNSTRESSED)</a>
<a name="ln743">                        return false;</a>
<a name="ln744">                  // split rests that don't start on a compound beat</a>
<a name="ln745">                  if (isRest &amp;&amp; startBeat &gt; BeatType::COMPOUND_UNSTRESSED)</a>
<a name="ln746">                        return true;</a>
<a name="ln747">                  // Remaining groupings within compound triplets are the same as for simple triple (3/4, 3/8, etc.)</a>
<a name="ln748">                  return forceRhythmicSplitSimple(isRest, startBeat, endBeat, dUnitsCrossed, BeatType::SIMPLE_UNSTRESSED);</a>
<a name="ln749">            default: // BeatType::SUBBEAT</a>
<a name="ln750">                  return forceRhythmicSplitSimple(isRest, startBeat, endBeat, dUnitsCrossed, strongestBeatCrossed);</a>
<a name="ln751">            }</a>
<a name="ln752">      }</a>
<a name="ln753"> </a>
<a name="ln754">//---------------------------------------------------------</a>
<a name="ln755">//   forceRhythmicSplitSimple</a>
<a name="ln756">//    Implementation: This function is also called for compound</a>
<a name="ln757">//    measures so be careful when comparing BeatTypes. Use &lt;, &lt;=,</a>
<a name="ln758">//    &gt;, &gt;= instead of == and != when appropriate. (See sig.h)</a>
<a name="ln759">//---------------------------------------------------------</a>
<a name="ln760"> </a>
<a name="ln761">bool forceRhythmicSplitSimple(bool isRest, BeatType startBeat, BeatType endBeat, int beatsCrossed, BeatType strongestBeatCrossed)</a>
<a name="ln762">      {</a>
<a name="ln763">      switch (strongestBeatCrossed) {</a>
<a name="ln764">            case BeatType::SIMPLE_STRESSED:</a>
<a name="ln765">                  // Must split rests on a stressed beat.</a>
<a name="ln766">                  if (isRest)</a>
<a name="ln767">                        return true;</a>
<a name="ln768">                  // Don't split notes that start or end on a stressed beat. Enables double-dotting in 4/4.</a>
<a name="ln769">                  // (Don't remove this to disable double-dotting, instead set maxDots = 1 elsewhere.)</a>
<a name="ln770">                  if (startBeat &lt;= BeatType::SIMPLE_STRESSED || endBeat &lt;= BeatType::SIMPLE_STRESSED)</a>
<a name="ln771">                        return false;</a>
<a name="ln772">                  // Don't split notes that both start and end on unstressed beats or stronger.</a>
<a name="ln773">                  if (startBeat &lt;= BeatType::SIMPLE_UNSTRESSED &amp;&amp; endBeat &lt;= BeatType::SIMPLE_UNSTRESSED)</a>
<a name="ln774">                        return false;</a>
<a name="ln775">                  // anything else must split on stressed beat.</a>
<a name="ln776">                  return true;</a>
<a name="ln777">            case BeatType::SIMPLE_UNSTRESSED:</a>
<a name="ln778">                  // Don't split notes or rests if starting and ending on stressed beat.</a>
<a name="ln779">                  if (startBeat &lt;= BeatType::SIMPLE_STRESSED &amp;&amp; endBeat &lt;= BeatType::SIMPLE_STRESSED)</a>
<a name="ln780">                        return false;</a>
<a name="ln781">                  // Split rests that don't start or end on a beat. Notes may cross 1 unstressed beat.</a>
<a name="ln782">                  if (startBeat == BeatType::SUBBEAT || endBeat == BeatType::SUBBEAT)</a>
<a name="ln783">                        return isRest || (beatsCrossed &gt; 1);</a>
<a name="ln784">                  return false;</a>
<a name="ln785">            default: // BeatType::SUBBEAT</a>
<a name="ln786">                  return false;</a>
<a name="ln787">            }</a>
<a name="ln788">      }</a>
<a name="ln789"> </a>
<a name="ln790">//---------------------------------------------------------</a>
<a name="ln791">//   print</a>
<a name="ln792">//---------------------------------------------------------</a>
<a name="ln793"> </a>
<a name="ln794">QString TDuration::durationTypeUserName() const</a>
<a name="ln795">      {</a>
<a name="ln796">      QString s = QObject::tr(&quot;Custom&quot;);</a>
<a name="ln797">      switch(_val) {</a>
<a name="ln798">            case DurationType::V_LONG:      s = QObject::tr(&quot;Longa&quot;  ); break;</a>
<a name="ln799">            case DurationType::V_BREVE:     s = QObject::tr(&quot;Breve&quot;  ); break;</a>
<a name="ln800">            case DurationType::V_WHOLE:     s = QObject::tr(&quot;Whole&quot;  ); break;</a>
<a name="ln801">            case DurationType::V_HALF:      s = QObject::tr(&quot;Half&quot;   ); break;</a>
<a name="ln802">            case DurationType::V_QUARTER:   s = QObject::tr(&quot;Quarter&quot;); break;</a>
<a name="ln803">            case DurationType::V_EIGHTH:    s = QObject::tr(&quot;Eighth&quot; ); break;</a>
<a name="ln804">            case DurationType::V_16TH:      s = QObject::tr(&quot;16th&quot;   ); break;</a>
<a name="ln805">            case DurationType::V_32ND:      s = QObject::tr(&quot;32nd&quot;   ); break;</a>
<a name="ln806">            case DurationType::V_64TH:      s = QObject::tr(&quot;64th&quot;   ); break;</a>
<a name="ln807">            case DurationType::V_128TH:     s = QObject::tr(&quot;128th&quot;  ); break;</a>
<a name="ln808">            case DurationType::V_256TH:     s = QObject::tr(&quot;256th&quot;  ); break;</a>
<a name="ln809">            case DurationType::V_512TH:     s = QObject::tr(&quot;512th&quot;  ); break;</a>
<a name="ln810">            case DurationType::V_1024TH:    s = QObject::tr(&quot;1024th&quot; ); break;</a>
<a name="ln811">            case DurationType::V_ZERO:      s = QObject::tr(&quot;Zero&quot;   ); break;</a>
<a name="ln812">            case DurationType::V_MEASURE:   s = QObject::tr(&quot;Measure&quot;); break;</a>
<a name="ln813">            case DurationType::V_INVALID:   s = QObject::tr(&quot;Invalid&quot;); break;</a>
<a name="ln814">            };</a>
<a name="ln815">      return s;</a>
<a name="ln816">      }</a>
<a name="ln817"> </a>
<a name="ln818">//---------------------------------------------------------</a>
<a name="ln819">//   setType</a>
<a name="ln820">//---------------------------------------------------------</a>
<a name="ln821"> </a>
<a name="ln822">void TDuration::setType(DurationType t)</a>
<a name="ln823">      {</a>
<a name="ln824">      _val = t;</a>
<a name="ln825">      if (_val == DurationType::V_MEASURE)</a>
<a name="ln826">            _dots = 0;</a>
<a name="ln827">      }</a>
<a name="ln828"> </a>
<a name="ln829">//---------------------------------------------------------</a>
<a name="ln830">//   isValid</a>
<a name="ln831">//---------------------------------------------------------</a>
<a name="ln832"> </a>
<a name="ln833">bool TDuration::isValid(Fraction f)</a>
<a name="ln834">     {</a>
<a name="ln835">     TDuration t;</a>
<a name="ln836">     t.setType(DurationType::V_LONG);</a>
<a name="ln837">     t.setDots(4);</a>
<a name="ln838">     t.truncateToFraction(f, 4);</a>
<a name="ln839">     return (t.isValid() &amp;&amp; (t.fraction() - f).numerator() == 0);</a>
<a name="ln840">     }</a>
<a name="ln841">}</a>
<a name="ln842"> </a>

</code></pre>
<div class="balloon" rel="77"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'ticks / t' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="175"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 175, 193</p></div>
<div class="balloon" rel="185"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 185, 188</p></div>
<div class="balloon" rel="287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
