
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>select.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">/**</a>
<a name="ln14"> \file</a>
<a name="ln15"> Implementation of class Selection plus other selection related functions.</a>
<a name="ln16">*/</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;mscore.h&quot;</a>
<a name="ln19">#include &quot;arpeggio.h&quot;</a>
<a name="ln20">#include &quot;barline.h&quot;</a>
<a name="ln21">#include &quot;beam.h&quot;</a>
<a name="ln22">#include &quot;chord.h&quot;</a>
<a name="ln23">#include &quot;dynamic.h&quot;</a>
<a name="ln24">#include &quot;element.h&quot;</a>
<a name="ln25">#include &quot;figuredbass.h&quot;</a>
<a name="ln26">#include &quot;glissando.h&quot;</a>
<a name="ln27">#include &quot;hairpin.h&quot;</a>
<a name="ln28">#include &quot;harmony.h&quot;</a>
<a name="ln29">#include &quot;fret.h&quot;</a>
<a name="ln30">#include &quot;hook.h&quot;</a>
<a name="ln31">#include &quot;input.h&quot;</a>
<a name="ln32">#include &quot;limits.h&quot;</a>
<a name="ln33">#include &quot;lyrics.h&quot;</a>
<a name="ln34">#include &quot;measure.h&quot;</a>
<a name="ln35">#include &quot;note.h&quot;</a>
<a name="ln36">#include &quot;notedot.h&quot;</a>
<a name="ln37">#include &quot;page.h&quot;</a>
<a name="ln38">#include &quot;rest.h&quot;</a>
<a name="ln39">#include &quot;score.h&quot;</a>
<a name="ln40">#include &quot;segment.h&quot;</a>
<a name="ln41">#include &quot;select.h&quot;</a>
<a name="ln42">#include &quot;sig.h&quot;</a>
<a name="ln43">#include &quot;slur.h&quot;</a>
<a name="ln44">#include &quot;stem.h&quot;</a>
<a name="ln45">#include &quot;stemslash.h&quot;</a>
<a name="ln46">#include &quot;tie.h&quot;</a>
<a name="ln47">#include &quot;system.h&quot;</a>
<a name="ln48">#include &quot;text.h&quot;</a>
<a name="ln49">#include &quot;tremolo.h&quot;</a>
<a name="ln50">#include &quot;tuplet.h&quot;</a>
<a name="ln51">#include &quot;utils.h&quot;</a>
<a name="ln52">#include &quot;xml.h&quot;</a>
<a name="ln53">#include &quot;staff.h&quot;</a>
<a name="ln54">#include &quot;part.h&quot;</a>
<a name="ln55">#include &quot;accidental.h&quot;</a>
<a name="ln56">#include &quot;articulation.h&quot;</a>
<a name="ln57"> </a>
<a name="ln58">namespace Ms {</a>
<a name="ln59"> </a>
<a name="ln60">//---------------------------------------------------------</a>
<a name="ln61">//   Selection</a>
<a name="ln62">//---------------------------------------------------------</a>
<a name="ln63"> </a>
<a name="ln64">Selection::Selection(Score* s)</a>
<a name="ln65">      {</a>
<a name="ln66">      _score         = s;</a>
<a name="ln67">      _state         = SelState::NONE;</a>
<a name="ln68">      _startSegment  = 0;</a>
<a name="ln69">      _endSegment    = 0;</a>
<a name="ln70">      _activeSegment = 0;</a>
<a name="ln71">      _staffStart    = 0;</a>
<a name="ln72">      _staffEnd      = 0;</a>
<a name="ln73">      _activeTrack   = 0;</a>
<a name="ln74">      _currentTick   = Fraction(-1, 1);</a>
<a name="ln75">      _currentTrack  = 0;</a>
<a name="ln76">      }</a>
<a name="ln77"> </a>
<a name="ln78">//---------------------------------------------------------</a>
<a name="ln79">//   tickStart</a>
<a name="ln80">//---------------------------------------------------------</a>
<a name="ln81"> </a>
<a name="ln82">Fraction Selection::tickStart() const</a>
<a name="ln83">      {</a>
<a name="ln84">      switch (_state) {</a>
<a name="ln85">            case SelState::RANGE:</a>
<a name="ln86">                  return _startSegment ? _startSegment-&gt;tick() : Fraction(-1,1);</a>
<a name="ln87">            case SelState::LIST: {</a>
<a name="ln88">                  ChordRest* cr = firstChordRest();</a>
<a name="ln89">                  return (cr) ? cr-&gt;tick() : Fraction(-1,1);</a>
<a name="ln90">                  }</a>
<a name="ln91">            default:</a>
<a name="ln92">                  return Fraction(-1,1);</a>
<a name="ln93">            }</a>
<a name="ln94">      }</a>
<a name="ln95"> </a>
<a name="ln96">//---------------------------------------------------------</a>
<a name="ln97">//   tickEnd</a>
<a name="ln98">//---------------------------------------------------------</a>
<a name="ln99"> </a>
<a name="ln100">Fraction Selection::tickEnd() const</a>
<a name="ln101">      {</a>
<a name="ln102">      switch (_state) {</a>
<a name="ln103">            case SelState::RANGE: {</a>
<a name="ln104">                  if (_endSegment)</a>
<a name="ln105">                        return _endSegment-&gt;tick();</a>
<a name="ln106">                  else { // endsegment == 0 if end of score</a>
<a name="ln107">                      Measure* m = _score-&gt;lastMeasure();</a>
<a name="ln108">                      return m-&gt;endTick();</a>
<a name="ln109">                      }</a>
<a name="ln110">                  break;</a>
<a name="ln111">                  }</a>
<a name="ln112">            case SelState::LIST: {</a>
<a name="ln113">                  ChordRest* cr = lastChordRest();</a>
<a name="ln114">                  return (cr) ? cr-&gt;segment()-&gt;tick() : Fraction(-1,1);</a>
<a name="ln115">                  break;</a>
<a name="ln116">                  }</a>
<a name="ln117">            default:</a>
<a name="ln118">                  return Fraction(-1,1);</a>
<a name="ln119">            }</a>
<a name="ln120">      }</a>
<a name="ln121"> </a>
<a name="ln122">//---------------------------------------------------------</a>
<a name="ln123">//   isStartActive</a>
<a name="ln124">//---------------------------------------------------------</a>
<a name="ln125"> </a>
<a name="ln126">bool Selection::isStartActive() const</a>
<a name="ln127">      {</a>
<a name="ln128">      return activeSegment() &amp;&amp; activeSegment()-&gt;tick() == tickStart();</a>
<a name="ln129">      }</a>
<a name="ln130"> </a>
<a name="ln131">//---------------------------------------------------------</a>
<a name="ln132">//   isEndActive</a>
<a name="ln133">//---------------------------------------------------------</a>
<a name="ln134"> </a>
<a name="ln135">bool Selection::isEndActive() const</a>
<a name="ln136">      {</a>
<a name="ln137">      return activeSegment() &amp;&amp; activeSegment()-&gt;tick() == tickEnd();</a>
<a name="ln138">      }</a>
<a name="ln139"> </a>
<a name="ln140">//---------------------------------------------------------</a>
<a name="ln141">//   element</a>
<a name="ln142">//---------------------------------------------------------</a>
<a name="ln143"> </a>
<a name="ln144">Element* Selection::element() const</a>
<a name="ln145">      {</a>
<a name="ln146">      return ((state() != SelState::RANGE) &amp;&amp; (_el.size() == 1)) ? _el[0] : 0;</a>
<a name="ln147">      }</a>
<a name="ln148"> </a>
<a name="ln149">//---------------------------------------------------------</a>
<a name="ln150">//   cr</a>
<a name="ln151">//---------------------------------------------------------</a>
<a name="ln152"> </a>
<a name="ln153">ChordRest* Selection::cr() const</a>
<a name="ln154">      {</a>
<a name="ln155">      Element* e = element();</a>
<a name="ln156">      if (!e)</a>
<a name="ln157">            return 0;</a>
<a name="ln158">      if (e-&gt;isNote())</a>
<a name="ln159">            e = e-&gt;parent();</a>
<a name="ln160">      if (e-&gt;isChordRest())</a>
<a name="ln161">            return toChordRest(e);</a>
<a name="ln162">      return 0;</a>
<a name="ln163">      }</a>
<a name="ln164"> </a>
<a name="ln165">//---------------------------------------------------------</a>
<a name="ln166">//   currentCR</a>
<a name="ln167">//---------------------------------------------------------</a>
<a name="ln168"> </a>
<a name="ln169">ChordRest* Selection::currentCR() const</a>
<a name="ln170">      {</a>
<a name="ln171">      // no selection yet - start at very beginning, not first cr</a>
<a name="ln172">      if (_currentTick == Fraction(-1, 1))</a>
<a name="ln173">            return nullptr;</a>
<a name="ln174">      Segment* s = score()-&gt;tick2rightSegment(_currentTick, true);</a>
<a name="ln175">      if (!s)</a>
<a name="ln176">            return nullptr;</a>
<a name="ln177">      int track = _currentTrack;</a>
<a name="ln178">      // staff may have been removed - start at top</a>
<a name="ln179">      if (track &lt; 0 || track &gt;= score()-&gt;ntracks())</a>
<a name="ln180">            track = 0;</a>
<a name="ln181">      Element* e = s-&gt;element(track);</a>
<a name="ln182">      if (e &amp;&amp; e-&gt;isChordRest())</a>
<a name="ln183">            return toChordRest(e);</a>
<a name="ln184">      else</a>
<a name="ln185">            return nullptr;</a>
<a name="ln186">      }</a>
<a name="ln187"> </a>
<a name="ln188">//---------------------------------------------------------</a>
<a name="ln189">//   activeCR</a>
<a name="ln190">//---------------------------------------------------------</a>
<a name="ln191"> </a>
<a name="ln192">ChordRest* Selection::activeCR() const</a>
<a name="ln193">      {</a>
<a name="ln194">      if ((_state != SelState::RANGE) || !_activeSegment)</a>
<a name="ln195">            return 0;</a>
<a name="ln196">      if (_activeSegment == _startSegment)</a>
<a name="ln197">            return firstChordRest(_activeTrack);</a>
<a name="ln198">      else</a>
<a name="ln199">            return lastChordRest(_activeTrack);</a>
<a name="ln200">      }</a>
<a name="ln201"> </a>
<a name="ln202">Segment* Selection::firstChordRestSegment() const</a>
<a name="ln203">      {</a>
<a name="ln204">      if (!isRange())</a>
<a name="ln205">            return 0;</a>
<a name="ln206"> </a>
<a name="ln207">      for (Segment* s = _startSegment; s &amp;&amp; (s != _endSegment); s = s-&gt;next1MM()) {</a>
<a name="ln208">            if (!s-&gt;enabled())</a>
<a name="ln209">                  continue;</a>
<a name="ln210">            if (s-&gt;isChordRestType())</a>
<a name="ln211">                  return s;</a>
<a name="ln212">            }</a>
<a name="ln213">      return 0;</a>
<a name="ln214">      }</a>
<a name="ln215"> </a>
<a name="ln216">//---------------------------------------------------------</a>
<a name="ln217">//   firstChordRest</a>
<a name="ln218">//---------------------------------------------------------</a>
<a name="ln219"> </a>
<a name="ln220">ChordRest* Selection::firstChordRest(int track) const</a>
<a name="ln221">      {</a>
<a name="ln222">      if (_el.size() == 1) {</a>
<a name="ln223">            Element* el = _el[0];</a>
<a name="ln224">            if (el-&gt;isNote())</a>
<a name="ln225">                  return toChordRest(el-&gt;parent());</a>
<a name="ln226">            else if (el-&gt;isRest())</a>
<a name="ln227">                  return toChordRest(el);</a>
<a name="ln228">            return 0;</a>
<a name="ln229">            }</a>
<a name="ln230">      ChordRest* cr = 0;</a>
<a name="ln231">      for (Element* el : _el) {</a>
<a name="ln232">            if (el-&gt;isNote())</a>
<a name="ln233">                  el = el-&gt;parent();</a>
<a name="ln234">            if (el-&gt;isChordRest()) {</a>
<a name="ln235">                  if (track != -1 &amp;&amp; el-&gt;track() != track)</a>
<a name="ln236">                        continue;</a>
<a name="ln237">                  if (cr) {</a>
<a name="ln238">                        if (toChordRest(el)-&gt;tick() &lt; cr-&gt;tick())</a>
<a name="ln239">                              cr = toChordRest(el);</a>
<a name="ln240">                        }</a>
<a name="ln241">                  else</a>
<a name="ln242">                        cr = toChordRest(el);</a>
<a name="ln243">                  }</a>
<a name="ln244">            }</a>
<a name="ln245">      return cr;</a>
<a name="ln246">      }</a>
<a name="ln247"> </a>
<a name="ln248">//---------------------------------------------------------</a>
<a name="ln249">//   lastChordRest</a>
<a name="ln250">//---------------------------------------------------------</a>
<a name="ln251"> </a>
<a name="ln252">ChordRest* Selection::lastChordRest(int track) const</a>
<a name="ln253">      {</a>
<a name="ln254">      if (_el.size() == 1) {</a>
<a name="ln255">            Element* el = _el[0];</a>
<a name="ln256">            if (el &amp;&amp; el-&gt;isNote())</a>
<a name="ln257">                  return toChordRest(el-&gt;parent());</a>
<a name="ln258">            else if (el-&gt;isChord() || el-&gt;isRest() || el-&gt;isRepeatMeasure())</a>
<a name="ln259">                  return toChordRest(el);</a>
<a name="ln260">            return 0;</a>
<a name="ln261">            }</a>
<a name="ln262">      ChordRest* cr = 0;</a>
<a name="ln263">      for (auto el : _el) {</a>
<a name="ln264">            if (el-&gt;isNote())</a>
<a name="ln265">                  el = toNote(el)-&gt;chord();</a>
<a name="ln266">            if (el-&gt;isChordRest() &amp;&amp; toChordRest(el)-&gt;segment()-&gt;isChordRestType()) {</a>
<a name="ln267">                  if (track != -1 &amp;&amp; el-&gt;track() != track)</a>
<a name="ln268">                        continue;</a>
<a name="ln269">                  if (cr) {</a>
<a name="ln270">                        if (toChordRest(el)-&gt;tick() &gt;= cr-&gt;tick())</a>
<a name="ln271">                              cr = toChordRest(el);</a>
<a name="ln272">                        }</a>
<a name="ln273">                  else</a>
<a name="ln274">                        cr = toChordRest(el);</a>
<a name="ln275">                  }</a>
<a name="ln276">            }</a>
<a name="ln277">      return cr;</a>
<a name="ln278">      }</a>
<a name="ln279"> </a>
<a name="ln280">//---------------------------------------------------------</a>
<a name="ln281">//   findMeasure</a>
<a name="ln282">//---------------------------------------------------------</a>
<a name="ln283"> </a>
<a name="ln284">Measure* Selection::findMeasure() const</a>
<a name="ln285">      {</a>
<a name="ln286">      Measure *m = 0;</a>
<a name="ln287">      if (_el.size() &gt; 0) {</a>
<a name="ln288">            Element* el = _el[0];</a>
<a name="ln289">            m = toMeasure(el-&gt;findMeasure());</a>
<a name="ln290">            }</a>
<a name="ln291">      return m;</a>
<a name="ln292">      }</a>
<a name="ln293"> </a>
<a name="ln294">//---------------------------------------------------------</a>
<a name="ln295">//   deselectAll</a>
<a name="ln296">//---------------------------------------------------------</a>
<a name="ln297"> </a>
<a name="ln298">void Selection::deselectAll()</a>
<a name="ln299">      {</a>
<a name="ln300">      if (_state == SelState::RANGE)</a>
<a name="ln301">            _score-&gt;setUpdateAll();</a>
<a name="ln302">      clear();</a>
<a name="ln303">      updateState();</a>
<a name="ln304">      }</a>
<a name="ln305"> </a>
<a name="ln306">//---------------------------------------------------------</a>
<a name="ln307">//   changeSelection</a>
<a name="ln308">//---------------------------------------------------------</a>
<a name="ln309"> </a>
<a name="ln310">static QRectF changeSelection(Element* e, bool b)</a>
<a name="ln311">      {</a>
<a name="ln312">      QRectF r = e-&gt;canvasBoundingRect();</a>
<a name="ln313">      e-&gt;setSelected(b);</a>
<a name="ln314">      r |= e-&gt;canvasBoundingRect();</a>
<a name="ln315">      return r;</a>
<a name="ln316">      }</a>
<a name="ln317"> </a>
<a name="ln318">//---------------------------------------------------------</a>
<a name="ln319">//   clear</a>
<a name="ln320">//---------------------------------------------------------</a>
<a name="ln321"> </a>
<a name="ln322">void Selection::clear()</a>
<a name="ln323">      {</a>
<a name="ln324">      for (Element* e : _el) {</a>
<a name="ln325">            if (e-&gt;isSpanner()) {   // TODO: only visible elements should be selectable?</a>
<a name="ln326">                  Spanner* sp = toSpanner(e);</a>
<a name="ln327">                  for (auto s : sp-&gt;spannerSegments())</a>
<a name="ln328">                        e-&gt;score()-&gt;addRefresh(changeSelection(s, false));</a>
<a name="ln329">                  }</a>
<a name="ln330">            else</a>
<a name="ln331">                  e-&gt;score()-&gt;addRefresh(changeSelection(e, false));</a>
<a name="ln332">            }</a>
<a name="ln333">      _el.clear();</a>
<a name="ln334">      _startSegment  = 0;</a>
<a name="ln335">      _endSegment    = 0;</a>
<a name="ln336">      _activeSegment = 0;</a>
<a name="ln337">      _staffStart    = 0;</a>
<a name="ln338">      _staffEnd      = 0;</a>
<a name="ln339">      _activeTrack   = 0;</a>
<a name="ln340">      setState(SelState::NONE);</a>
<a name="ln341">      }</a>
<a name="ln342"> </a>
<a name="ln343">//---------------------------------------------------------</a>
<a name="ln344">//   remove</a>
<a name="ln345">//---------------------------------------------------------</a>
<a name="ln346"> </a>
<a name="ln347">void Selection::remove(Element* el)</a>
<a name="ln348">      {</a>
<a name="ln349">      const bool removed = _el.removeOne(el);</a>
<a name="ln350">      el-&gt;setSelected(false);</a>
<a name="ln351">      if (removed)</a>
<a name="ln352">            updateState();</a>
<a name="ln353">      }</a>
<a name="ln354"> </a>
<a name="ln355">//---------------------------------------------------------</a>
<a name="ln356">//   add</a>
<a name="ln357">//---------------------------------------------------------</a>
<a name="ln358"> </a>
<a name="ln359">void Selection::add(Element* el)</a>
<a name="ln360">      {</a>
<a name="ln361">      _el.append(el);</a>
<a name="ln362">      update();</a>
<a name="ln363">      }</a>
<a name="ln364"> </a>
<a name="ln365">//---------------------------------------------------------</a>
<a name="ln366">//   canSelect</a>
<a name="ln367">//   see also `static const char* labels[]` in selectionwindow.cpp</a>
<a name="ln368">//---------------------------------------------------------</a>
<a name="ln369"> </a>
<a name="ln370">bool SelectionFilter::canSelect(const Element* e) const</a>
<a name="ln371">      {</a>
<a name="ln372">      if (e-&gt;isDynamic() || e-&gt;isHairpin())</a>
<a name="ln373">          return isFiltered(SelectionFilterType::DYNAMIC);</a>
<a name="ln374">      if (e-&gt;isArticulation() || e-&gt;isTrill() || e-&gt;isVibrato() || e-&gt;isFermata())</a>
<a name="ln375">          return isFiltered(SelectionFilterType::ARTICULATION);</a>
<a name="ln376">      if (e-&gt;type() == ElementType::LYRICS)</a>
<a name="ln377">          return isFiltered(SelectionFilterType::LYRICS);</a>
<a name="ln378">      if (e-&gt;type() == ElementType::FINGERING)</a>
<a name="ln379">          return isFiltered(SelectionFilterType::FINGERING);</a>
<a name="ln380">      if (e-&gt;type() == ElementType::HARMONY)</a>
<a name="ln381">          return isFiltered(SelectionFilterType::CHORD_SYMBOL);</a>
<a name="ln382">      if (e-&gt;type() == ElementType::SLUR)</a>
<a name="ln383">          return isFiltered(SelectionFilterType::SLUR);</a>
<a name="ln384">      if (e-&gt;type() == ElementType::FIGURED_BASS)</a>
<a name="ln385">          return isFiltered(SelectionFilterType::FIGURED_BASS);</a>
<a name="ln386">      if (e-&gt;type() == ElementType::OTTAVA)</a>
<a name="ln387">          return isFiltered(SelectionFilterType::OTTAVA);</a>
<a name="ln388">      if (e-&gt;type() == ElementType::PEDAL)</a>
<a name="ln389">          return isFiltered(SelectionFilterType::PEDAL_LINE);</a>
<a name="ln390">      if (e-&gt;type() == ElementType::ARPEGGIO)</a>
<a name="ln391">          return isFiltered(SelectionFilterType::ARPEGGIO);</a>
<a name="ln392">      if (e-&gt;type() == ElementType::GLISSANDO)</a>
<a name="ln393">          return isFiltered(SelectionFilterType::GLISSANDO);</a>
<a name="ln394">      if (e-&gt;type() == ElementType::FRET_DIAGRAM)</a>
<a name="ln395">          return isFiltered(SelectionFilterType::FRET_DIAGRAM);</a>
<a name="ln396">      if (e-&gt;type() == ElementType::BREATH)</a>
<a name="ln397">          return isFiltered(SelectionFilterType::BREATH);</a>
<a name="ln398">      if (e-&gt;isTextBase()) // only TEXT, INSTRCHANGE and STAFFTEXT are caught here, rest are system thus not in selection</a>
<a name="ln399">          return isFiltered(SelectionFilterType::OTHER_TEXT);</a>
<a name="ln400">      if (e-&gt;isSLine()) // NoteLine, Volta</a>
<a name="ln401">          return isFiltered(SelectionFilterType::OTHER_LINE);</a>
<a name="ln402">      if (e-&gt;isTremolo())</a>
<a name="ln403">          return isFiltered(SelectionFilterType::TREMOLO);</a>
<a name="ln404">      if (e-&gt;isChord() &amp;&amp; toChord(e)-&gt;isGrace())</a>
<a name="ln405">          return isFiltered(SelectionFilterType::GRACE_NOTE);</a>
<a name="ln406">      return true;</a>
<a name="ln407">      }</a>
<a name="ln408"> </a>
<a name="ln409">//---------------------------------------------------------</a>
<a name="ln410">//   canSelectVoice</a>
<a name="ln411">//---------------------------------------------------------</a>
<a name="ln412"> </a>
<a name="ln413">bool SelectionFilter::canSelectVoice(int track) const</a>
<a name="ln414">      {</a>
<a name="ln415">      int voice = track % VOICES;</a>
<a name="ln416">      switch (voice) {</a>
<a name="ln417">            case 0:</a>
<a name="ln418">                  return isFiltered(SelectionFilterType::FIRST_VOICE);</a>
<a name="ln419">            case 1:</a>
<a name="ln420">                  return isFiltered(SelectionFilterType::SECOND_VOICE);</a>
<a name="ln421">            case 2:</a>
<a name="ln422">                  return isFiltered(SelectionFilterType::THIRD_VOICE);</a>
<a name="ln423">            case 3:</a>
<a name="ln424">                  return isFiltered(SelectionFilterType::FOURTH_VOICE);</a>
<a name="ln425">            }</a>
<a name="ln426">      return true;</a>
<a name="ln427">      }</a>
<a name="ln428"> </a>
<a name="ln429">//---------------------------------------------------------</a>
<a name="ln430">//   appendFiltered</a>
<a name="ln431">//---------------------------------------------------------</a>
<a name="ln432"> </a>
<a name="ln433">void Selection::appendFiltered(Element* e)</a>
<a name="ln434">      {</a>
<a name="ln435">      if (selectionFilter().canSelect(e))</a>
<a name="ln436">            _el.append(e);</a>
<a name="ln437">      }</a>
<a name="ln438"> </a>
<a name="ln439">//---------------------------------------------------------</a>
<a name="ln440">//   appendChord</a>
<a name="ln441">//---------------------------------------------------------</a>
<a name="ln442"> </a>
<a name="ln443">void Selection::appendChord(Chord* chord)</a>
<a name="ln444">      {</a>
<a name="ln445">      if (chord-&gt;beam() &amp;&amp; !_el.contains(chord-&gt;beam()))</a>
<a name="ln446">            _el.append(chord-&gt;beam());</a>
<a name="ln447">      if (chord-&gt;stem())</a>
<a name="ln448">            _el.append(chord-&gt;stem());</a>
<a name="ln449">      if (chord-&gt;hook())</a>
<a name="ln450">            _el.append(chord-&gt;hook());</a>
<a name="ln451">      if (chord-&gt;arpeggio())</a>
<a name="ln452">            appendFiltered(chord-&gt;arpeggio());</a>
<a name="ln453">      if (chord-&gt;stemSlash())</a>
<a name="ln454">            _el.append(chord-&gt;stemSlash());</a>
<a name="ln455">      if (chord-&gt;tremolo())</a>
<a name="ln456">            appendFiltered(chord-&gt;tremolo());</a>
<a name="ln457">      for (Note* note : chord-&gt;notes()) {</a>
<a name="ln458">            _el.append(note);</a>
<a name="ln459">            if (note-&gt;accidental()) _el.append(note-&gt;accidental());</a>
<a name="ln460">            foreach(Element* el, note-&gt;el())</a>
<a name="ln461">                  appendFiltered(el);</a>
<a name="ln462">            for (NoteDot* dot : note-&gt;dots())</a>
<a name="ln463">                  _el.append(dot);</a>
<a name="ln464"> </a>
<a name="ln465">            if (note-&gt;tieFor() &amp;&amp; (note-&gt;tieFor()-&gt;endElement() != 0)) {</a>
<a name="ln466">                  if (note-&gt;tieFor()-&gt;endElement()-&gt;isNote()) {</a>
<a name="ln467">                        Note* endNote = toNote(note-&gt;tieFor()-&gt;endElement());</a>
<a name="ln468">                        Segment* s = endNote-&gt;chord()-&gt;segment();</a>
<a name="ln469">                        if (s-&gt;tick() &lt; tickEnd())</a>
<a name="ln470">                              _el.append(note-&gt;tieFor());</a>
<a name="ln471">                        }</a>
<a name="ln472">                  }</a>
<a name="ln473">            for (Spanner* sp : note-&gt;spannerFor()) {</a>
<a name="ln474">                  if (sp-&gt;endElement()-&gt;isNote()) {</a>
<a name="ln475">                        Note* endNote = toNote(sp-&gt;endElement());</a>
<a name="ln476">                        Segment* s = endNote-&gt;chord()-&gt;segment();</a>
<a name="ln477">                        if (s-&gt;tick() &lt; tickEnd())</a>
<a name="ln478">                              _el.append(sp);</a>
<a name="ln479">                        }</a>
<a name="ln480">                  }</a>
<a name="ln481">            }</a>
<a name="ln482">      }</a>
<a name="ln483"> </a>
<a name="ln484">//---------------------------------------------------------</a>
<a name="ln485">//   updateSelectedElements</a>
<a name="ln486">//---------------------------------------------------------</a>
<a name="ln487"> </a>
<a name="ln488">void Selection::updateSelectedElements()</a>
<a name="ln489">      {</a>
<a name="ln490">      if (_state != SelState::RANGE) {</a>
<a name="ln491">            update();</a>
<a name="ln492">            return;</a>
<a name="ln493">            }</a>
<a name="ln494">      if (_state == SelState::RANGE &amp;&amp; _plannedTick1 != Fraction(-1,1) &amp;&amp; _plannedTick2 != Fraction(-1,1)) {</a>
<a name="ln495">            const int staffStart = _staffStart;</a>
<a name="ln496">            const int staffEnd = _staffEnd;</a>
<a name="ln497">            deselectAll();</a>
<a name="ln498">            Segment* s1 = _score-&gt;tick2segmentMM(_plannedTick1);</a>
<a name="ln499">            Segment* s2 = _score-&gt;tick2segmentMM(_plannedTick2, /* first */ true);</a>
<a name="ln500">            if (s2 &amp;&amp; s2-&gt;measure()-&gt;isMMRest())</a>
<a name="ln501">                  s2 = s2-&gt;prev1MM(); // HACK both this and the previous &quot;true&quot;</a>
<a name="ln502">                                      // are needed to prevent bug #173381.</a>
<a name="ln503">                                      // This should exclude any segments belonging</a>
<a name="ln504">                                      // to MM-rest range from the selection.</a>
<a name="ln505">            if (s1 &amp;&amp; s2 &amp;&amp; s1-&gt;tick() + s1-&gt;ticks() &gt; s2-&gt;tick()) {</a>
<a name="ln506">                  // can happen with MM rests as tick2measure returns only</a>
<a name="ln507">                  // the first segment for them.</a>
<a name="ln508">                  return;</a>
<a name="ln509">                  }</a>
<a name="ln510">            if (s2 &amp;&amp; s2 == s2-&gt;measure()-&gt;first())</a>
<a name="ln511">                  s2 = s2-&gt;prev1();   // we want the last segment of the previous measure</a>
<a name="ln512">            setRange(s1, s2, staffStart, staffEnd);</a>
<a name="ln513">            _plannedTick1 = Fraction(-1,1);</a>
<a name="ln514">            _plannedTick2 = Fraction(-1,1);</a>
<a name="ln515">            }</a>
<a name="ln516"> </a>
<a name="ln517">      for (Element* e : _el)</a>
<a name="ln518">            e-&gt;setSelected(false);</a>
<a name="ln519">      _el.clear();</a>
<a name="ln520"> </a>
<a name="ln521">      // assert:</a>
<a name="ln522">      int staves = _score-&gt;nstaves();</a>
<a name="ln523">      if (_staffStart &lt; 0 || _staffStart &gt;= staves || _staffEnd &lt; 0 || _staffEnd &gt; staves</a>
<a name="ln524">         || _staffStart &gt;= _staffEnd) {</a>
<a name="ln525">            qDebug(&quot;updateSelectedElements: bad staff selection %d - %d, staves %d&quot;, _staffStart, _staffEnd, staves);</a>
<a name="ln526">            _staffStart = 0;</a>
<a name="ln527">            _staffEnd   = 0;</a>
<a name="ln528">            }</a>
<a name="ln529">      int startTrack = _staffStart * VOICES;</a>
<a name="ln530">      int endTrack   = _staffEnd * VOICES;</a>
<a name="ln531"> </a>
<a name="ln532">      for (int st = startTrack; st &lt; endTrack; ++st) {</a>
<a name="ln533">            if (!canSelectVoice(st))</a>
<a name="ln534">                  continue;</a>
<a name="ln535">            for (Segment* s = _startSegment; s &amp;&amp; (s != _endSegment); s = s-&gt;next1MM()) {</a>
<a name="ln536">                  if (!s-&gt;enabled() || s-&gt;isEndBarLineType())  // do not select end bar line</a>
<a name="ln537">                        continue;</a>
<a name="ln538">                  for (Element* e : s-&gt;annotations()) {</a>
<a name="ln539">                        if (e-&gt;track() != st)</a>
<a name="ln540">                              continue;</a>
<a name="ln541">                        appendFiltered(e);</a>
<a name="ln542">                        }</a>
<a name="ln543">                  Element* e = s-&gt;element(st);</a>
<a name="ln544">                  if (!e || e-&gt;generated() || e-&gt;isTimeSig() || e-&gt;isKeySig())</a>
<a name="ln545">                        continue;</a>
<a name="ln546">                  if (e-&gt;isChordRest()) {</a>
<a name="ln547">                        ChordRest* cr = toChordRest(e);</a>
<a name="ln548">                        for (Element* el : cr-&gt;lyrics()) {</a>
<a name="ln549">                              if (el)</a>
<a name="ln550">                                    appendFiltered(el);</a>
<a name="ln551">                              }</a>
<a name="ln552">                        }</a>
<a name="ln553">                  if (e-&gt;isChord()) {</a>
<a name="ln554">                        Chord* chord = toChord(e);</a>
<a name="ln555">                        for (Chord* graceNote : chord-&gt;graceNotes())</a>
<a name="ln556">                              if (canSelect(graceNote)) appendChord(graceNote);</a>
<a name="ln557">                        appendChord(chord);</a>
<a name="ln558">                        for (Articulation* art : chord-&gt;articulations())</a>
<a name="ln559">                              appendFiltered(art);</a>
<a name="ln560">                        }</a>
<a name="ln561">                  else {</a>
<a name="ln562">                        appendFiltered(e);</a>
<a name="ln563">                        if (e-&gt;isRest()) {</a>
<a name="ln564">                              Rest* r = toRest(e);</a>
<a name="ln565">                              for (int i = 0; i &lt; r-&gt;dots(); ++i)</a>
<a name="ln566">                                    appendFiltered(r-&gt;dot(i));</a>
<a name="ln567">                              }</a>
<a name="ln568">                        }</a>
<a name="ln569">                  }</a>
<a name="ln570">            }</a>
<a name="ln571">      Fraction stick = startSegment()-&gt;tick();</a>
<a name="ln572">      Fraction etick = tickEnd();</a>
<a name="ln573"> </a>
<a name="ln574">      for (auto i = _score-&gt;spanner().begin(); i != _score-&gt;spanner().end(); ++i) {</a>
<a name="ln575">            Spanner* sp = (*i).second;</a>
<a name="ln576">            // ignore spanners belonging to other tracks</a>
<a name="ln577">            if (sp-&gt;track() &lt; startTrack || sp-&gt;track() &gt;= endTrack)</a>
<a name="ln578">                  continue;</a>
<a name="ln579">            if (!canSelectVoice(sp-&gt;track()))</a>
<a name="ln580">                  continue;</a>
<a name="ln581">            // ignore voltas</a>
<a name="ln582">            if (sp-&gt;isVolta())</a>
<a name="ln583">                  continue;</a>
<a name="ln584">            if (sp-&gt;isSlur()) {</a>
<a name="ln585">                  // ignore if start &amp; end elements not calculated yet</a>
<a name="ln586">                  if (!sp-&gt;startElement() || !sp-&gt;endElement())</a>
<a name="ln587">                        continue;</a>
<a name="ln588">                  if ((sp-&gt;tick() &gt;= stick &amp;&amp; sp-&gt;tick() &lt; etick) || (sp-&gt;tick2() &gt;= stick &amp;&amp; sp-&gt;tick2() &lt; etick))</a>
<a name="ln589">                        if (canSelect(sp-&gt;startCR()) &amp;&amp; canSelect(sp-&gt;endCR()))</a>
<a name="ln590">                              appendFiltered(sp);     // slur with start or end in range selection</a>
<a name="ln591">            }</a>
<a name="ln592">            else if ((sp-&gt;tick() &gt;= stick &amp;&amp; sp-&gt;tick() &lt; etick) &amp;&amp; (sp-&gt;tick2() &gt;= stick &amp;&amp; sp-&gt;tick2() &lt;= etick))</a>
<a name="ln593">                  appendFiltered(sp); // spanner with start and end in range selection</a>
<a name="ln594">            }</a>
<a name="ln595">      update();</a>
<a name="ln596">      }</a>
<a name="ln597"> </a>
<a name="ln598">//---------------------------------------------------------</a>
<a name="ln599">//   setRange</a>
<a name="ln600">//---------------------------------------------------------</a>
<a name="ln601"> </a>
<a name="ln602">void Selection::setRange(Segment* startSegment, Segment* endSegment, int staffStart, int staffEnd)</a>
<a name="ln603">      {</a>
<a name="ln604">      Q_ASSERT(staffEnd &gt; staffStart &amp;&amp; staffStart &gt;= 0 &amp;&amp; staffEnd &gt;= 0 &amp;&amp; staffEnd &lt;= _score-&gt;nstaves());</a>
<a name="ln605">      Q_ASSERT(!(endSegment &amp;&amp; !startSegment));</a>
<a name="ln606"> </a>
<a name="ln607">      _startSegment  = startSegment;</a>
<a name="ln608">      _endSegment    = endSegment;</a>
<a name="ln609">      _activeSegment = endSegment;</a>
<a name="ln610">      _staffStart    = staffStart;</a>
<a name="ln611">      _staffEnd      = staffEnd;</a>
<a name="ln612">      setState(SelState::RANGE);</a>
<a name="ln613">      }</a>
<a name="ln614"> </a>
<a name="ln615">//---------------------------------------------------------</a>
<a name="ln616">//   setRangeTicks</a>
<a name="ln617">//    sets the range to be selected on next</a>
<a name="ln618">//    updateSelectedElements() call. Can be used if some</a>
<a name="ln619">//    segment structure changes are expected (e.g. if</a>
<a name="ln620">//    creating MM rests is pending).</a>
<a name="ln621">//---------------------------------------------------------</a>
<a name="ln622"> </a>
<a name="ln623">void Selection::setRangeTicks(const Fraction&amp; tick1, const Fraction&amp; tick2, int staffStart, int staffEnd)</a>
<a name="ln624">      {</a>
<a name="ln625">      Q_ASSERT(staffEnd &gt; staffStart &amp;&amp; staffStart &gt;= 0 &amp;&amp; staffEnd &gt;= 0 &amp;&amp; staffEnd &lt;= _score-&gt;nstaves());</a>
<a name="ln626"> </a>
<a name="ln627">      deselectAll();</a>
<a name="ln628">      _plannedTick1 = tick1;</a>
<a name="ln629">      _plannedTick2 = tick2;</a>
<a name="ln630">      _startSegment = _endSegment = _activeSegment = nullptr;</a>
<a name="ln631">      _staffStart    = staffStart;</a>
<a name="ln632">      _staffEnd      = staffEnd;</a>
<a name="ln633">      setState(SelState::RANGE);</a>
<a name="ln634">      }</a>
<a name="ln635"> </a>
<a name="ln636">//---------------------------------------------------------</a>
<a name="ln637">//   update</a>
<a name="ln638">///   Set select flag for all Elements in select list.</a>
<a name="ln639">//---------------------------------------------------------</a>
<a name="ln640"> </a>
<a name="ln641">void Selection::update()</a>
<a name="ln642">      {</a>
<a name="ln643">      for (Element* e : _el)</a>
<a name="ln644">            e-&gt;setSelected(true);</a>
<a name="ln645">      updateState();</a>
<a name="ln646">      }</a>
<a name="ln647"> </a>
<a name="ln648">//---------------------------------------------------------</a>
<a name="ln649">//   dump</a>
<a name="ln650">//---------------------------------------------------------</a>
<a name="ln651"> </a>
<a name="ln652">void Selection::dump()</a>
<a name="ln653">      {</a>
<a name="ln654">      qDebug(&quot;Selection dump: &quot;);</a>
<a name="ln655">      switch(_state) {</a>
<a name="ln656">            case SelState::NONE:   qDebug(&quot;NONE&quot;); return;</a>
<a name="ln657">            case SelState::RANGE:  qDebug(&quot;RANGE&quot;); break;</a>
<a name="ln658">            case SelState::LIST:   qDebug(&quot;LIST&quot;); break;</a>
<a name="ln659">            }</a>
<a name="ln660">      foreach(const Element* e, _el)</a>
<a name="ln661">            qDebug(&quot;  %p %s&quot;, e, e-&gt;name());</a>
<a name="ln662">      }</a>
<a name="ln663"> </a>
<a name="ln664">//---------------------------------------------------------</a>
<a name="ln665">//   updateState</a>
<a name="ln666">///   update selection and input state</a>
<a name="ln667">//---------------------------------------------------------</a>
<a name="ln668"> </a>
<a name="ln669">void Selection::updateState()</a>
<a name="ln670">      {</a>
<a name="ln671">      int n = _el.size();</a>
<a name="ln672">      Element* e = element();</a>
<a name="ln673">      if (n == 0)</a>
<a name="ln674">            setState(SelState::NONE);</a>
<a name="ln675">      else if (_state == SelState::NONE)</a>
<a name="ln676">            setState(SelState::LIST);</a>
<a name="ln677">      if (e) {</a>
<a name="ln678">            if (e-&gt;isSpannerSegment())</a>
<a name="ln679">                  _currentTick = toSpannerSegment(e)-&gt;spanner()-&gt;tick();</a>
<a name="ln680">            else</a>
<a name="ln681">                  _currentTick = e-&gt;tick();</a>
<a name="ln682">            // ignore system elements (e.g., frames)</a>
<a name="ln683">            if (e-&gt;track() &gt;= 0)</a>
<a name="ln684">                  _currentTrack = e-&gt;track();</a>
<a name="ln685">            }</a>
<a name="ln686">      }</a>
<a name="ln687"> </a>
<a name="ln688">//---------------------------------------------------------</a>
<a name="ln689">//   setState</a>
<a name="ln690">//---------------------------------------------------------</a>
<a name="ln691"> </a>
<a name="ln692">void Selection::setState(SelState s)</a>
<a name="ln693">      {</a>
<a name="ln694">      _state = s;</a>
<a name="ln695">      _score-&gt;setSelectionChanged(true);</a>
<a name="ln696">      }</a>
<a name="ln697"> </a>
<a name="ln698">//---------------------------------------------------------</a>
<a name="ln699">//   mimeType</a>
<a name="ln700">//---------------------------------------------------------</a>
<a name="ln701"> </a>
<a name="ln702">QString Selection::mimeType() const</a>
<a name="ln703">      {</a>
<a name="ln704">      switch (_state) {</a>
<a name="ln705">            default:</a>
<a name="ln706">            case SelState::NONE:</a>
<a name="ln707">                  return QString();</a>
<a name="ln708">            case SelState::LIST:</a>
<a name="ln709">                  return isSingle() ? mimeSymbolFormat : mimeSymbolListFormat;</a>
<a name="ln710">            case SelState::RANGE:</a>
<a name="ln711">                  return mimeStaffListFormat;</a>
<a name="ln712">            }</a>
<a name="ln713">      }</a>
<a name="ln714"> </a>
<a name="ln715">//---------------------------------------------------------</a>
<a name="ln716">//   mimeData</a>
<a name="ln717">//---------------------------------------------------------</a>
<a name="ln718"> </a>
<a name="ln719">QByteArray Selection::mimeData() const</a>
<a name="ln720">      {</a>
<a name="ln721">      QByteArray a;</a>
<a name="ln722">      switch (_state) {</a>
<a name="ln723">            case SelState::LIST:</a>
<a name="ln724">                  if (isSingle())</a>
<a name="ln725">                        a = element()-&gt;mimeData(QPointF());</a>
<a name="ln726">                  else</a>
<a name="ln727">                        a = symbolListMimeData();</a>
<a name="ln728">                  break;</a>
<a name="ln729">            case SelState::NONE:</a>
<a name="ln730">                  break;</a>
<a name="ln731">            case SelState::RANGE:</a>
<a name="ln732">                  a = staffMimeData();</a>
<a name="ln733">                  break;</a>
<a name="ln734">            }</a>
<a name="ln735">      return a;</a>
<a name="ln736">      }</a>
<a name="ln737"> </a>
<a name="ln738">//---------------------------------------------------------</a>
<a name="ln739">//   hasElementInTrack</a>
<a name="ln740">//---------------------------------------------------------</a>
<a name="ln741"> </a>
<a name="ln742">bool hasElementInTrack(Segment* startSeg, Segment* endSeg, int track)</a>
<a name="ln743">      {</a>
<a name="ln744">      for (Segment* seg = startSeg; seg != endSeg; seg = seg-&gt;next1MM()) {</a>
<a name="ln745">            if (!seg-&gt;enabled())</a>
<a name="ln746">                  continue;</a>
<a name="ln747">            if (seg-&gt;element(track))</a>
<a name="ln748">                  return true;</a>
<a name="ln749">            }</a>
<a name="ln750">      return false;</a>
<a name="ln751">      }</a>
<a name="ln752"> </a>
<a name="ln753">//---------------------------------------------------------</a>
<a name="ln754">//   firstElementInTrack</a>
<a name="ln755">//---------------------------------------------------------</a>
<a name="ln756"> </a>
<a name="ln757">static Fraction firstElementInTrack(Segment* startSeg, Segment* endSeg, int track)</a>
<a name="ln758">      {</a>
<a name="ln759">      for (Segment* seg = startSeg; seg != endSeg; seg = seg-&gt;next1MM()) {</a>
<a name="ln760">            if (!seg-&gt;enabled())</a>
<a name="ln761">                  continue;</a>
<a name="ln762">            if (seg-&gt;element(track))</a>
<a name="ln763">                  return seg-&gt;tick();</a>
<a name="ln764">            }</a>
<a name="ln765">      return Fraction(-1,1);</a>
<a name="ln766">      }</a>
<a name="ln767"> </a>
<a name="ln768">//---------------------------------------------------------</a>
<a name="ln769">//   staffMimeData</a>
<a name="ln770">//---------------------------------------------------------</a>
<a name="ln771"> </a>
<a name="ln772">QByteArray Selection::staffMimeData() const</a>
<a name="ln773">      {</a>
<a name="ln774">      QBuffer buffer;</a>
<a name="ln775">      buffer.open(QIODevice::WriteOnly);</a>
<a name="ln776">      XmlWriter xml(score(), &amp;buffer);</a>
<a name="ln777">      xml.header();</a>
<a name="ln778">      xml.setClipboardmode(true);</a>
<a name="ln779">      xml.setFilter(selectionFilter());</a>
<a name="ln780"> </a>
<a name="ln781">      Fraction ticks  = tickEnd() - tickStart();</a>
<a name="ln782">      int staves = staffEnd() - staffStart();</a>
<a name="ln783">      if (!MScore::testMode) {</a>
<a name="ln784">            xml.stag(QString(&quot;StaffList version=\&quot;&quot; MSC_VERSION &quot;\&quot; tick=\&quot;%1\&quot; len=\&quot;%2\&quot; staff=\&quot;%3\&quot; staves=\&quot;%4\&quot;&quot;).arg(tickStart().ticks()).arg(ticks.ticks()).arg(staffStart()).arg(staves));</a>
<a name="ln785">            }</a>
<a name="ln786">      else {</a>
<a name="ln787">            xml.stag(QString(&quot;StaffList version=\&quot;2.00\&quot; tick=\&quot;%1\&quot; len=\&quot;%2\&quot; staff=\&quot;%3\&quot; staves=\&quot;%4\&quot;&quot;).arg(tickStart().ticks()).arg(ticks.ticks()).arg(staffStart()).arg(staves));</a>
<a name="ln788">            }</a>
<a name="ln789">      Segment* seg1 = _startSegment;</a>
<a name="ln790">      Segment* seg2 = _endSegment;</a>
<a name="ln791"> </a>
<a name="ln792">      for (int staffIdx = staffStart(); staffIdx &lt; staffEnd(); ++staffIdx) {</a>
<a name="ln793">            int startTrack = staffIdx * VOICES;</a>
<a name="ln794">            int endTrack   = startTrack + VOICES;</a>
<a name="ln795"> </a>
<a name="ln796">            xml.stag(QString(&quot;Staff id=\&quot;%1\&quot;&quot;).arg(staffIdx));</a>
<a name="ln797"> </a>
<a name="ln798">            Staff* staff = _score-&gt;staff(staffIdx);</a>
<a name="ln799">            Part* part = staff-&gt;part();</a>
<a name="ln800">            Interval interval = part-&gt;instrument(seg1-&gt;tick())-&gt;transpose();</a>
<a name="ln801">            if (interval.chromatic)</a>
<a name="ln802">                  xml.tag(&quot;transposeChromatic&quot;, interval.chromatic);</a>
<a name="ln803">            if (interval.diatonic)</a>
<a name="ln804">                  xml.tag(&quot;transposeDiatonic&quot;, interval.diatonic);</a>
<a name="ln805">            xml.stag(&quot;voiceOffset&quot;);</a>
<a name="ln806">            for (int voice = 0; voice &lt; VOICES; voice++) {</a>
<a name="ln807">                  if (hasElementInTrack(seg1, seg2, startTrack + voice)</a>
<a name="ln808">                     &amp;&amp; xml.canWriteVoice(voice)) {</a>
<a name="ln809">                        Fraction offset = firstElementInTrack(seg1, seg2, startTrack+voice) - tickStart();</a>
<a name="ln810">                        xml.tag(QString(&quot;voice id=\&quot;%1\&quot;&quot;).arg(voice), offset.ticks());</a>
<a name="ln811">                        }</a>
<a name="ln812">                  }</a>
<a name="ln813">            xml.etag(); // &lt;/voiceOffset&gt;</a>
<a name="ln814">            xml.setCurTrack(startTrack);</a>
<a name="ln815">            _score-&gt;writeSegments(xml, startTrack, endTrack, seg1, seg2, false, false);</a>
<a name="ln816">            xml.etag();</a>
<a name="ln817">            }</a>
<a name="ln818"> </a>
<a name="ln819">      xml.etag();</a>
<a name="ln820">      buffer.close();</a>
<a name="ln821">      return buffer.buffer();</a>
<a name="ln822">      }</a>
<a name="ln823"> </a>
<a name="ln824">//---------------------------------------------------------</a>
<a name="ln825">//   symbolListMimeData</a>
<a name="ln826">//---------------------------------------------------------</a>
<a name="ln827"> </a>
<a name="ln828">QByteArray Selection::symbolListMimeData() const</a>
<a name="ln829">      {</a>
<a name="ln830">      struct MapData {</a>
<a name="ln831">            Element* e;</a>
<a name="ln832">            Segment* s;</a>
<a name="ln833">            };</a>
<a name="ln834"> </a>
<a name="ln835">      QBuffer buffer;</a>
<a name="ln836">      buffer.open(QIODevice::WriteOnly);</a>
<a name="ln837">      XmlWriter xml(score(), &amp;buffer);</a>
<a name="ln838">      xml.header();</a>
<a name="ln839">      xml.setClipboardmode(true);</a>
<a name="ln840"> </a>
<a name="ln841">      int         topTrack    = 1000000;</a>
<a name="ln842">      int         bottomTrack = 0;</a>
<a name="ln843">      Segment*    firstSeg    = 0;</a>
<a name="ln844">      Fraction    firstTick   = Fraction(0x7FFFFFFF,1);</a>
<a name="ln845">      MapData     mapData;</a>
<a name="ln846">      Segment*    seg         = 0;</a>
<a name="ln847">      std::multimap&lt;qint64, MapData&gt; map;</a>
<a name="ln848"> </a>
<a name="ln849">      // scan selection element list, inserting relevant elements in a tick-sorted map</a>
<a name="ln850">      foreach (Element* e, _el) {</a>
<a name="ln851">            switch (e-&gt;type()) {</a>
<a name="ln852">/* All these element types are ignored:</a>
<a name="ln853"> </a>
<a name="ln854">Enabling copying of more element types requires enabling pasting in Score::pasteSymbols() in libmscore/paste.cpp</a>
<a name="ln855"> </a>
<a name="ln856">                  case ElementType::SYMBOL:</a>
<a name="ln857">                  case ElementType::TEXT:</a>
<a name="ln858">                  case ElementType::INSTRUMENT_NAME:</a>
<a name="ln859">                  case ElementType::SLUR_SEGMENT:</a>
<a name="ln860">                  case ElementType::TIE_SEGMENT:</a>
<a name="ln861">                  case ElementType::STAFF_LINES:</a>
<a name="ln862">                  case ElementType::BAR_LINE:</a>
<a name="ln863">                  case ElementType::STEM_SLASH:</a>
<a name="ln864">                  case ElementType::LINE:</a>
<a name="ln865">                  case ElementType::BRACKET:</a>
<a name="ln866">                  case ElementType::ARPEGGIO:</a>
<a name="ln867">                  case ElementType::ACCIDENTAL:</a>
<a name="ln868">                  case ElementType::STEM:</a>
<a name="ln869">                  case ElementType::NOTE:</a>
<a name="ln870">                  case ElementType::CLEF:</a>
<a name="ln871">                  case ElementType::KEYSIG:</a>
<a name="ln872">                  case ElementType::TIMESIG:</a>
<a name="ln873">                  case ElementType::REST:</a>
<a name="ln874">                  case ElementType::BREATH:</a>
<a name="ln875">                  case ElementType::GLISSANDO:</a>
<a name="ln876">                  case ElementType::REPEAT_MEASURE:</a>
<a name="ln877">                  case ElementType::IMAGE:</a>
<a name="ln878">                  case ElementType::TIE:</a>
<a name="ln879">                  case ElementType::CHORDLINE:</a>
<a name="ln880">                  case ElementType::BEAM:</a>
<a name="ln881">                  case ElementType::HOOK:</a>
<a name="ln882">                  case ElementType::MARKER:</a>
<a name="ln883">                  case ElementType::JUMP:</a>
<a name="ln884">                  case ElementType::FINGERING:</a>
<a name="ln885">                  case ElementType::TUPLET:</a>
<a name="ln886">                  case ElementType::TEMPO_TEXT:</a>
<a name="ln887">                  case ElementType::STAFF_TEXT:</a>
<a name="ln888">                  case ElementType::SYSTEM_TEXT:</a>
<a name="ln889">                  case ElementType::REHEARSAL_MARK:</a>
<a name="ln890">                  case ElementType::INSTRUMENT_CHANGE:</a>
<a name="ln891">                  case ElementType::BEND:</a>
<a name="ln892">                  case ElementType::TREMOLOBAR:</a>
<a name="ln893">                  case ElementType::VOLTA:</a>
<a name="ln894">                  case ElementType::OTTAVA_SEGMENT:</a>
<a name="ln895">                  case ElementType::TRILL_SEGMENT:</a>
<a name="ln896">                  case ElementType::VIBRATO_SEGMENT:</a>
<a name="ln897">                  case ElementType::TEXTLINE_SEGMENT:</a>
<a name="ln898">                  case ElementType::VOLTA_SEGMENT:</a>
<a name="ln899">                  case ElementType::PEDAL_SEGMENT:</a>
<a name="ln900">                  case ElementType::LAYOUT_BREAK:</a>
<a name="ln901">                  case ElementType::SPACER:</a>
<a name="ln902">                  case ElementType::STAFF_STATE:</a>
<a name="ln903">                  case ElementType::LEDGER_LINE:</a>
<a name="ln904">                  case ElementType::NOTEHEAD:</a>
<a name="ln905">                  case ElementType::NOTEDOT:</a>
<a name="ln906">                  case ElementType::TREMOLO:</a>
<a name="ln907">                  case ElementType::MEASURE:</a>
<a name="ln908">                  case ElementType::SELECTION:</a>
<a name="ln909">                  case ElementType::LASSO:</a>
<a name="ln910">                  case ElementType::SHADOW_NOTE:</a>
<a name="ln911">                  case ElementType::RUBBERBAND:</a>
<a name="ln912">                  case ElementType::TAB_DURATION_SYMBOL:</a>
<a name="ln913">                  case ElementType::FSYMBOL:</a>
<a name="ln914">                  case ElementType::PAGE:</a>
<a name="ln915">                  case ElementType::OTTAVA:</a>
<a name="ln916">                  case ElementType::PEDAL:</a>
<a name="ln917">                  case ElementType::TRILL:</a>
<a name="ln918">                  case ElementType::TEXTLINE:</a>
<a name="ln919">                  case ElementType::NOTELINE:</a>
<a name="ln920">                  case ElementType::SEGMENT:</a>
<a name="ln921">                  case ElementType::SYSTEM:</a>
<a name="ln922">                  case ElementType::COMPOUND:</a>
<a name="ln923">                  case ElementType::CHORD:</a>
<a name="ln924">                  case ElementType::SLUR:</a>
<a name="ln925">                  case ElementType::ELEMENT:</a>
<a name="ln926">                  case ElementType::ELEMENT_LIST:</a>
<a name="ln927">                  case ElementType::STAFF_LIST:</a>
<a name="ln928">                  case ElementType::MEASURE_LIST:</a>
<a name="ln929">                  case ElementType::LAYOUT:</a>
<a name="ln930">                  case ElementType::HBOX:</a>
<a name="ln931">                  case ElementType::VBOX:</a>
<a name="ln932">                  case ElementType::TBOX:</a>
<a name="ln933">                  case ElementType::FBOX:</a>
<a name="ln934">                  case ElementType::ICON:</a>
<a name="ln935">                  case ElementType::OSSIA:</a>
<a name="ln936">                  case ElementType::BAGPIPE_EMBELLISHMENT:</a>
<a name="ln937">                        continue;</a>
<a name="ln938">*/</a>
<a name="ln939">                  case ElementType::ARTICULATION:</a>
<a name="ln940">                        // ignore articulations not attached to chords/rest</a>
<a name="ln941">                        if (e-&gt;parent()-&gt;isChord()) {</a>
<a name="ln942">                              Chord* par = toChord(e-&gt;parent());</a>
<a name="ln943">                              seg = par-&gt;segment();</a>
<a name="ln944">                              break;</a>
<a name="ln945">                              }</a>
<a name="ln946">                        else if (e-&gt;parent()-&gt;isRest()) {</a>
<a name="ln947">                              Rest* par = toRest(e-&gt;parent());</a>
<a name="ln948">                              seg = par-&gt;segment();</a>
<a name="ln949">                              break;</a>
<a name="ln950">                              }</a>
<a name="ln951">                        continue;</a>
<a name="ln952">                  case ElementType::FIGURED_BASS:</a>
<a name="ln953">                        seg = toFiguredBass(e)-&gt;segment();</a>
<a name="ln954">                        break;</a>
<a name="ln955">                  case ElementType::HARMONY:</a>
<a name="ln956">                  case ElementType::FRET_DIAGRAM:</a>
<a name="ln957">                        // ignore chord symbols or fret diagrams not attached to segment</a>
<a name="ln958">                        if (e-&gt;parent()-&gt;isSegment()) {</a>
<a name="ln959">                              seg = toSegment(e-&gt;parent());</a>
<a name="ln960">                              break;</a>
<a name="ln961">                              }</a>
<a name="ln962">                        continue;</a>
<a name="ln963">                  case ElementType::LYRICS:</a>
<a name="ln964">                        seg = toLyrics(e)-&gt;segment();</a>
<a name="ln965">                        break;</a>
<a name="ln966">                  case ElementType::DYNAMIC:</a>
<a name="ln967">                        seg = toDynamic(e)-&gt;segment();</a>
<a name="ln968">                        break;</a>
<a name="ln969">                  case ElementType::HAIRPIN_SEGMENT:</a>
<a name="ln970">                        e = toHairpinSegment(e)-&gt;hairpin();</a>
<a name="ln971">                        // fall through</a>
<a name="ln972">                  case ElementType::HAIRPIN:</a>
<a name="ln973">                        seg = toHairpin(e)-&gt;startSegment();</a>
<a name="ln974">                        break;</a>
<a name="ln975">                  default:</a>
<a name="ln976">                        continue;</a>
<a name="ln977">                  }</a>
<a name="ln978">            int track = e-&gt;track();</a>
<a name="ln979">            if (track &lt; topTrack)</a>
<a name="ln980">                  topTrack = track;</a>
<a name="ln981">            if (track &gt; bottomTrack)</a>
<a name="ln982">                  bottomTrack = track;</a>
<a name="ln983">            if (seg-&gt;tick() &lt; firstTick) {</a>
<a name="ln984">                  firstSeg  = seg;</a>
<a name="ln985">                  firstTick = seg-&gt;tick();</a>
<a name="ln986">                  }</a>
<a name="ln987">            mapData.e = e;</a>
<a name="ln988">            mapData.s = seg;</a>
<a name="ln989">            map.insert(std::pair&lt;qint64,MapData&gt;( ((qint64)track &lt;&lt; 32) + seg-&gt;tick().ticks(), mapData));</a>
<a name="ln990">            }</a>
<a name="ln991"> </a>
<a name="ln992">      xml.stag(QString(&quot;SymbolList version=\&quot;&quot; MSC_VERSION &quot;\&quot; fromtrack=\&quot;%1\&quot; totrack=\&quot;%2\&quot;&quot;)</a>
<a name="ln993">                  .arg(topTrack).arg(bottomTrack));</a>
<a name="ln994">      // scan the map, outputting elements each with a relative &lt;track&gt; tag on track change,</a>
<a name="ln995">      // a relative tick and the number of CR segments to skip</a>
<a name="ln996">      int   currTrack = -1;</a>
<a name="ln997">      for (auto iter = map.cbegin(); iter != map.cend(); ++iter) {</a>
<a name="ln998">            int   numSegs;</a>
<a name="ln999">            int   track = static_cast&lt;int&gt;(iter-&gt;first &gt;&gt; 32);</a>
<a name="ln1000">            if (currTrack != track) {</a>
<a name="ln1001">                  xml.tag(&quot;trackOffset&quot;, track - topTrack);</a>
<a name="ln1002">                  currTrack = track;</a>
<a name="ln1003">                  seg       = firstSeg;</a>
<a name="ln1004">                  }</a>
<a name="ln1005">            xml.tag(&quot;tickOffset&quot;, static_cast&lt;int&gt;(iter-&gt;first &amp; 0xFFFFFFFF) - firstTick.ticks());</a>
<a name="ln1006">            numSegs = 0;</a>
<a name="ln1007">            // with figured bass, we need to look for the proper segment</a>
<a name="ln1008">            // not only according to ChordRest elements, but also annotations</a>
<a name="ln1009">            if (iter-&gt;second.e-&gt;type() == ElementType::FIGURED_BASS) {</a>
<a name="ln1010">                  bool done = false;</a>
<a name="ln1011">                  for ( ; seg; seg = seg-&gt;next1()) {</a>
<a name="ln1012">                        if (seg-&gt;isChordRestType()) {</a>
<a name="ln1013">                              // if no ChordRest in right track, look in anotations</a>
<a name="ln1014">                              if (seg-&gt;element(currTrack) == nullptr) {</a>
<a name="ln1015">                                    foreach (Element* el, seg-&gt;annotations()) {</a>
<a name="ln1016">                                          // do annotations include our element?</a>
<a name="ln1017">                                          if (el == iter-&gt;second.e) {</a>
<a name="ln1018">                                                done = true;</a>
<a name="ln1019">                                                break;</a>
<a name="ln1020">                                                }</a>
<a name="ln1021">                                          // do annotations include any f.b.?</a>
<a name="ln1022">                                          if (el-&gt;type() == ElementType::FIGURED_BASS &amp;&amp; el-&gt;track() == track) {</a>
<a name="ln1023">                                                numSegs++;  //yes: it counts as a step</a>
<a name="ln1024">                                                break;</a>
<a name="ln1025">                                                }</a>
<a name="ln1026">                                          }</a>
<a name="ln1027">                                    if (done)</a>
<a name="ln1028">                                          break;</a>
<a name="ln1029">                                    continue;               // segment is not relevant: no ChordRest nor f.b.</a>
<a name="ln1030">                                    }</a>
<a name="ln1031">                              else {</a>
<a name="ln1032">                                    if (iter-&gt;second.s == seg)</a>
<a name="ln1033">                                          break;</a>
<a name="ln1034">                                    }</a>
<a name="ln1035">                              numSegs++;</a>
<a name="ln1036">                              }</a>
<a name="ln1037">                        }</a>
<a name="ln1038">                  }</a>
<a name="ln1039">            else {</a>
<a name="ln1040">                  while (seg &amp;&amp; iter-&gt;second.s != seg) {</a>
<a name="ln1041">                        seg = seg-&gt;nextCR(currTrack);</a>
<a name="ln1042">                        numSegs++;</a>
<a name="ln1043">                        }</a>
<a name="ln1044">                  }</a>
<a name="ln1045">            xml.tag(&quot;segDelta&quot;, numSegs);</a>
<a name="ln1046">            iter-&gt;second.e-&gt;write(xml);</a>
<a name="ln1047">            }</a>
<a name="ln1048"> </a>
<a name="ln1049">      xml.etag();</a>
<a name="ln1050">      buffer.close();</a>
<a name="ln1051">      return buffer.buffer();</a>
<a name="ln1052">      }</a>
<a name="ln1053"> </a>
<a name="ln1054">//---------------------------------------------------------</a>
<a name="ln1055">//   noteList</a>
<a name="ln1056">//---------------------------------------------------------</a>
<a name="ln1057"> </a>
<a name="ln1058">std::vector&lt;Note*&gt; Selection::noteList(int selTrack) const</a>
<a name="ln1059">      {</a>
<a name="ln1060">      std::vector&lt;Note*&gt;nl;</a>
<a name="ln1061"> </a>
<a name="ln1062">      if (_state == SelState::LIST) {</a>
<a name="ln1063">            foreach(Element* e, _el) {</a>
<a name="ln1064">                  if (e-&gt;isNote())</a>
<a name="ln1065">                        nl.push_back(toNote(e));</a>
<a name="ln1066">                  }</a>
<a name="ln1067">            }</a>
<a name="ln1068">      else if (_state == SelState::RANGE) {</a>
<a name="ln1069">            for (int staffIdx = staffStart(); staffIdx &lt; staffEnd(); ++staffIdx) {</a>
<a name="ln1070">                  int startTrack = staffIdx * VOICES;</a>
<a name="ln1071">                  int endTrack   = startTrack + VOICES;</a>
<a name="ln1072">                  for (Segment* seg = _startSegment; seg &amp;&amp; seg != _endSegment; seg = seg-&gt;next1()) {</a>
<a name="ln1073">                        if (!(seg-&gt;segmentType() &amp; (SegmentType::ChordRest)))</a>
<a name="ln1074">                              continue;</a>
<a name="ln1075">                        for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln1076">                              if (!canSelectVoice(track))</a>
<a name="ln1077">                                  continue;</a>
<a name="ln1078">                              Element* e = seg-&gt;element(track);</a>
<a name="ln1079">                              if (e == 0 || e-&gt;type() != ElementType::CHORD</a>
<a name="ln1080">                                 || (selTrack != -1 &amp;&amp; selTrack != track))</a>
<a name="ln1081">                                    continue;</a>
<a name="ln1082">                              Chord* c = toChord(e);</a>
<a name="ln1083">                              nl.insert(nl.end(), c-&gt;notes().begin(), c-&gt;notes().end());</a>
<a name="ln1084">                              for (Chord* g : c-&gt;graceNotes()) {</a>
<a name="ln1085">                                    nl.insert(nl.end(), g-&gt;notes().begin(), g-&gt;notes().end());</a>
<a name="ln1086">                                    }</a>
<a name="ln1087">                              }</a>
<a name="ln1088">                        }</a>
<a name="ln1089">                  }</a>
<a name="ln1090">            }</a>
<a name="ln1091">      return nl;</a>
<a name="ln1092">      }</a>
<a name="ln1093"> </a>
<a name="ln1094">//---------------------------------------------------------</a>
<a name="ln1095">//   checkStart</a>
<a name="ln1096">//     return false if element is NOT a tuplet or is start of a tuplet/tremolo</a>
<a name="ln1097">//     return true  if element is part of a tuplet/tremolo, but not the start</a>
<a name="ln1098">//---------------------------------------------------------</a>
<a name="ln1099"> </a>
<a name="ln1100">static bool checkStart(Element* e)</a>
<a name="ln1101">      {</a>
<a name="ln1102">      if (e == 0 || !e-&gt;isChordRest())</a>
<a name="ln1103">            return false;</a>
<a name="ln1104">      ChordRest* cr = toChordRest(e);</a>
<a name="ln1105">      bool rv = false;</a>
<a name="ln1106">      if (cr-&gt;tuplet()) {</a>
<a name="ln1107">            // check that complete tuplet is selected, all the way up to top level</a>
<a name="ln1108">            Tuplet* tuplet = cr-&gt;tuplet();</a>
<a name="ln1109">            while (tuplet) {</a>
<a name="ln1110">                  if (tuplet-&gt;elements().front() != e)</a>
<a name="ln1111">                        return true;</a>
<a name="ln1112">                  e = tuplet;</a>
<a name="ln1113">                  tuplet = tuplet-&gt;tuplet();</a>
<a name="ln1114">                  }</a>
<a name="ln1115">            }</a>
<a name="ln1116">      else if (cr-&gt;type() == ElementType::CHORD) {</a>
<a name="ln1117">            rv = false;</a>
<a name="ln1118">            Chord* chord = toChord(cr);</a>
<a name="ln1119">            if (chord-&gt;tremolo() &amp;&amp; chord-&gt;tremolo()-&gt;twoNotes())</a>
<a name="ln1120">                  rv = chord-&gt;tremolo()-&gt;chord2() == chord;</a>
<a name="ln1121">            }</a>
<a name="ln1122">      return rv;</a>
<a name="ln1123">      }</a>
<a name="ln1124"> </a>
<a name="ln1125">//---------------------------------------------------------</a>
<a name="ln1126">//   checkEnd</a>
<a name="ln1127">//     return false if element is NOT a tuplet or is end of a tuplet</a>
<a name="ln1128">//     return true  if element is part of a tuplet, but not the end</a>
<a name="ln1129">//---------------------------------------------------------</a>
<a name="ln1130"> </a>
<a name="ln1131">static bool checkEnd(Element* e, const Fraction&amp; endTick)</a>
<a name="ln1132">      {</a>
<a name="ln1133">      if (e == 0 || !e-&gt;isChordRest())</a>
<a name="ln1134">            return false;</a>
<a name="ln1135">      ChordRest* cr = toChordRest(e);</a>
<a name="ln1136">      bool rv = false;</a>
<a name="ln1137">      if (cr-&gt;tuplet()) {</a>
<a name="ln1138">            // check that complete tuplet is selected, all the way up to top level</a>
<a name="ln1139">            Tuplet* tuplet = cr-&gt;tuplet();</a>
<a name="ln1140">            while (tuplet) {</a>
<a name="ln1141">                  if (tuplet-&gt;elements().back() != e)</a>
<a name="ln1142">                        return true;</a>
<a name="ln1143">                  e = tuplet;</a>
<a name="ln1144">                  tuplet = tuplet-&gt;tuplet();</a>
<a name="ln1145">                  }</a>
<a name="ln1146">            // also check that the selection extends to the end of the top-level tuplet</a>
<a name="ln1147">            tuplet = toTuplet(e);</a>
<a name="ln1148">            if (tuplet-&gt;elements().front()-&gt;tick() + tuplet-&gt;actualTicks() &gt; endTick)</a>
<a name="ln1149">                  return true;</a>
<a name="ln1150">            }</a>
<a name="ln1151">      else if (cr-&gt;type() == ElementType::CHORD) {</a>
<a name="ln1152">            rv = false;</a>
<a name="ln1153">            Chord* chord = toChord(cr);</a>
<a name="ln1154">            if (chord-&gt;tremolo() &amp;&amp; chord-&gt;tremolo()-&gt;twoNotes())</a>
<a name="ln1155">                  rv = chord-&gt;tremolo()-&gt;chord1() == chord;</a>
<a name="ln1156">            }</a>
<a name="ln1157">      return rv;</a>
<a name="ln1158">      }</a>
<a name="ln1159"> </a>
<a name="ln1160">//---------------------------------------------------------</a>
<a name="ln1161">//   canCopy</a>
<a name="ln1162">//    return false if range selection intersects a tuplet</a>
<a name="ln1163">//    or a tremolo, or a local time signature</a>
<a name="ln1164">//---------------------------------------------------------</a>
<a name="ln1165"> </a>
<a name="ln1166">bool Selection::canCopy() const</a>
<a name="ln1167">      {</a>
<a name="ln1168">      if (_state != SelState::RANGE)</a>
<a name="ln1169">            return true;</a>
<a name="ln1170"> </a>
<a name="ln1171">      Fraction endTick = _endSegment ? _endSegment-&gt;tick() : _score-&gt;lastSegment()-&gt;tick();</a>
<a name="ln1172"> </a>
<a name="ln1173">      for (int staffIdx = _staffStart; staffIdx != _staffEnd; ++staffIdx) {</a>
<a name="ln1174"> </a>
<a name="ln1175">            for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln1176">                  int track = staffIdx * VOICES + voice;</a>
<a name="ln1177">                  if (!canSelectVoice(track))</a>
<a name="ln1178">                        continue;</a>
<a name="ln1179"> </a>
<a name="ln1180">                  // check first cr in track within selection</a>
<a name="ln1181">                  ChordRest* check = _startSegment-&gt;nextChordRest(track);</a>
<a name="ln1182">                  if (check &amp;&amp; check-&gt;tick() &lt; endTick &amp;&amp; checkStart(check))</a>
<a name="ln1183">                        return false;</a>
<a name="ln1184"> </a>
<a name="ln1185">                  if (! _endSegment)</a>
<a name="ln1186">                        continue;</a>
<a name="ln1187"> </a>
<a name="ln1188">                  // find last segment in the selection.</a>
<a name="ln1189">                  // Note that _endSegment is the first segment after the selection</a>
<a name="ln1190"> </a>
<a name="ln1191">                  Segment *endSegmentSelection = _startSegment;</a>
<a name="ln1192">                  while (endSegmentSelection-&gt;nextCR(track) &amp;&amp;</a>
<a name="ln1193">                        (endSegmentSelection-&gt;nextCR(track)-&gt;tick() &lt; _endSegment-&gt;tick()))</a>
<a name="ln1194">                        endSegmentSelection = endSegmentSelection-&gt;nextCR(track);</a>
<a name="ln1195"> </a>
<a name="ln1196">                  if (checkEnd(endSegmentSelection-&gt;element(track), endTick))</a>
<a name="ln1197">                        return false;</a>
<a name="ln1198">                  }</a>
<a name="ln1199"> </a>
<a name="ln1200">            // loop through measures on this staff checking for local time signatures</a>
<a name="ln1201">            for (Measure* m = _startSegment-&gt;measure(); m &amp;&amp; m-&gt;tick() &lt; endTick; m = m-&gt;nextMeasure()) {</a>
<a name="ln1202">                  if (_score-&gt;staff(staffIdx)-&gt;isLocalTimeSignature(m-&gt;tick()))</a>
<a name="ln1203">                        return false;</a>
<a name="ln1204">                  }</a>
<a name="ln1205"> </a>
<a name="ln1206">            }</a>
<a name="ln1207">      return true;</a>
<a name="ln1208">      }</a>
<a name="ln1209"> </a>
<a name="ln1210">//---------------------------------------------------------</a>
<a name="ln1211">//   measureRange</a>
<a name="ln1212">//    return false if no measure range selected</a>
<a name="ln1213">//---------------------------------------------------------</a>
<a name="ln1214"> </a>
<a name="ln1215">bool Selection::measureRange(Measure** m1, Measure** m2) const</a>
<a name="ln1216">      {</a>
<a name="ln1217">      if (!isRange())</a>
<a name="ln1218">            return false;</a>
<a name="ln1219">      *m1 = startSegment()-&gt;measure();</a>
<a name="ln1220">      Segment* s2 = endSegment();</a>
<a name="ln1221">      *m2 = s2 ? s2-&gt;measure() : _score-&gt;lastMeasure();</a>
<a name="ln1222">      if (*m1 == *m2)</a>
<a name="ln1223">            return true;</a>
<a name="ln1224">      // if selection extends to last segment of a measure,</a>
<a name="ln1225">      // then endSegment() will point to next measure</a>
<a name="ln1226">      // this won't normally happen because end barlines are excluded from range selection</a>
<a name="ln1227">      // but just in case, detect this and back up one measure</a>
<a name="ln1228">      if (*m2 &amp;&amp; s2 &amp;&amp; (*m2)-&gt;tick() == s2-&gt;tick())</a>
<a name="ln1229">            *m2 = (*m2)-&gt;prevMeasure();</a>
<a name="ln1230">      return true;</a>
<a name="ln1231">      }</a>
<a name="ln1232"> </a>
<a name="ln1233">//---------------------------------------------------------</a>
<a name="ln1234">//   uniqueElements</a>
<a name="ln1235">//    Return list of selected elements.</a>
<a name="ln1236">//    If some elements are linked, only one of the linked</a>
<a name="ln1237">//    elements show up in the list.</a>
<a name="ln1238">//---------------------------------------------------------</a>
<a name="ln1239"> </a>
<a name="ln1240">const QList&lt;Element*&gt; Selection::uniqueElements() const</a>
<a name="ln1241">      {</a>
<a name="ln1242">      QList&lt;Element*&gt; l;</a>
<a name="ln1243"> </a>
<a name="ln1244">      for (Element* e : elements()) {</a>
<a name="ln1245">            bool alreadyThere = false;</a>
<a name="ln1246">            for (Element* ee : l) {</a>
<a name="ln1247">                  if ((ee-&gt;links() &amp;&amp; ee-&gt;links()-&gt;contains(e)) || e == ee) {</a>
<a name="ln1248">                        alreadyThere = true;</a>
<a name="ln1249">                        break;</a>
<a name="ln1250">                        }</a>
<a name="ln1251">                  }</a>
<a name="ln1252">            if (!alreadyThere)</a>
<a name="ln1253">                  l.append(e);</a>
<a name="ln1254">            }</a>
<a name="ln1255">      return l;</a>
<a name="ln1256">      }</a>
<a name="ln1257"> </a>
<a name="ln1258">//---------------------------------------------------------</a>
<a name="ln1259">//   uniqueNotes</a>
<a name="ln1260">//    Return list of selected notes.</a>
<a name="ln1261">//    If some notes are linked, only one of the linked</a>
<a name="ln1262">//    elements show up in the list.</a>
<a name="ln1263">//---------------------------------------------------------</a>
<a name="ln1264"> </a>
<a name="ln1265">QList&lt;Note*&gt; Selection::uniqueNotes(int track) const</a>
<a name="ln1266">      {</a>
<a name="ln1267">      QList&lt;Note*&gt; l;</a>
<a name="ln1268"> </a>
<a name="ln1269">      for (Note* nn : noteList(track)) {</a>
<a name="ln1270">            for (Note* note : nn-&gt;tiedNotes()) {</a>
<a name="ln1271">                  bool alreadyThere = false;</a>
<a name="ln1272">                  for (Note* n : l) {</a>
<a name="ln1273">                        if ((n-&gt;links() &amp;&amp; n-&gt;links()-&gt;contains(note)) || n == note) {</a>
<a name="ln1274">                              alreadyThere = true;</a>
<a name="ln1275">                              break;</a>
<a name="ln1276">                              }</a>
<a name="ln1277">                        }</a>
<a name="ln1278">                  if (!alreadyThere)</a>
<a name="ln1279">                        l.append(note);</a>
<a name="ln1280">                  }</a>
<a name="ln1281">            }</a>
<a name="ln1282">      return l;</a>
<a name="ln1283">      }</a>
<a name="ln1284"> </a>
<a name="ln1285">//---------------------------------------------------------</a>
<a name="ln1286">//   extendRangeSelection</a>
<a name="ln1287">//    Extends the range selection to contain the given</a>
<a name="ln1288">//    chord rest.</a>
<a name="ln1289">//---------------------------------------------------------</a>
<a name="ln1290"> </a>
<a name="ln1291">void Selection::extendRangeSelection(ChordRest* cr)</a>
<a name="ln1292">      {</a>
<a name="ln1293">      extendRangeSelection(cr-&gt;segment(),</a>
<a name="ln1294">         cr-&gt;nextSegmentAfterCR(SegmentType::ChordRest</a>
<a name="ln1295">            | SegmentType::EndBarLine</a>
<a name="ln1296">            | SegmentType::Clef),</a>
<a name="ln1297">            cr-&gt;staffIdx(),</a>
<a name="ln1298">            cr-&gt;tick(),</a>
<a name="ln1299">            cr-&gt;tick());</a>
<a name="ln1300">      }</a>
<a name="ln1301"> </a>
<a name="ln1302">//---------------------------------------------------------</a>
<a name="ln1303">//   extendRangeSelection</a>
<a name="ln1304">//    Extends the range selection to contain the given</a>
<a name="ln1305">//    segment. SegAfter should represent the segment</a>
<a name="ln1306">//    that is after seg. Tick and etick represent</a>
<a name="ln1307">//    the start and end tick of an element. Useful when</a>
<a name="ln1308">//    extending by a chord rest.</a>
<a name="ln1309">//---------------------------------------------------------</a>
<a name="ln1310"> </a>
<a name="ln1311">void Selection::extendRangeSelection(Segment* seg, Segment* segAfter, int staffIdx, const Fraction&amp; tick, const Fraction&amp; etick)</a>
<a name="ln1312">      {</a>
<a name="ln1313">      bool activeIsFirst = false;</a>
<a name="ln1314">      int activeStaff = _activeTrack / VOICES;</a>
<a name="ln1315"> </a>
<a name="ln1316">      if (staffIdx &lt; _staffStart)</a>
<a name="ln1317">            _staffStart = staffIdx;</a>
<a name="ln1318">      else if (staffIdx &gt;= _staffEnd)</a>
<a name="ln1319">            _staffEnd = staffIdx + 1;</a>
<a name="ln1320">      else if (_staffEnd - _staffStart &gt; 1) { // at least 2 staff selected</a>
<a name="ln1321">            if (staffIdx == _staffStart + 1 &amp;&amp; activeStaff == _staffStart) // going down</a>
<a name="ln1322">                  _staffStart = staffIdx;</a>
<a name="ln1323">            else if (staffIdx == _staffEnd - 2 &amp;&amp; activeStaff == _staffEnd - 1) // going up</a>
<a name="ln1324">                  _staffEnd = staffIdx + 1;</a>
<a name="ln1325">            }</a>
<a name="ln1326"> </a>
<a name="ln1327">      if (tick &lt; tickStart()) {</a>
<a name="ln1328">            _startSegment = seg;</a>
<a name="ln1329">            activeIsFirst = true;</a>
<a name="ln1330">            }</a>
<a name="ln1331">      else if (etick &gt;= tickEnd()) {</a>
<a name="ln1332">            _endSegment = segAfter;</a>
<a name="ln1333">            }</a>
<a name="ln1334">      else {</a>
<a name="ln1335">            if (_activeSegment == _startSegment) {</a>
<a name="ln1336">                  _startSegment = seg;</a>
<a name="ln1337">                  activeIsFirst = true;</a>
<a name="ln1338">                  }</a>
<a name="ln1339">            else {</a>
<a name="ln1340">                  _endSegment = segAfter;</a>
<a name="ln1341">                  }</a>
<a name="ln1342">            }</a>
<a name="ln1343">      activeIsFirst ? _activeSegment = _startSegment : _activeSegment = _endSegment;</a>
<a name="ln1344">      _score-&gt;setSelectionChanged(true);</a>
<a name="ln1345">      Q_ASSERT(!(_endSegment &amp;&amp; !_startSegment));</a>
<a name="ln1346">      }</a>
<a name="ln1347"> </a>
<a name="ln1348">//---------------------------------------------------------</a>
<a name="ln1349">//   selectionFilter</a>
<a name="ln1350">//---------------------------------------------------------</a>
<a name="ln1351"> </a>
<a name="ln1352">SelectionFilter Selection::selectionFilter() const</a>
<a name="ln1353">      {</a>
<a name="ln1354">      return _score-&gt;selectionFilter();</a>
<a name="ln1355">      }</a>
<a name="ln1356"> </a>
<a name="ln1357">//---------------------------------------------------------</a>
<a name="ln1358">//   setFiltered</a>
<a name="ln1359">//---------------------------------------------------------</a>
<a name="ln1360"> </a>
<a name="ln1361">void SelectionFilter::setFiltered(SelectionFilterType type, bool set)</a>
<a name="ln1362">      {</a>
<a name="ln1363">      if (set)</a>
<a name="ln1364">            _filtered = _filtered | (int)type;</a>
<a name="ln1365">      else</a>
<a name="ln1366">            _filtered = _filtered &amp; ~(int)type;</a>
<a name="ln1367">      }</a>
<a name="ln1368">}</a>
<a name="ln1369"> </a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
