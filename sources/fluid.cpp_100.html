
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>fluid.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/* FluidSynth - A Software Synthesizer</a>
<a name="ln2"> *</a>
<a name="ln3"> * Copyright (C) 2003  Peter Hanappe and others.</a>
<a name="ln4"> *</a>
<a name="ln5"> * This library is free software; you can redistribute it and/or</a>
<a name="ln6"> * modify it under the terms of the GNU Library General Public License</a>
<a name="ln7"> * as published by the Free Software Foundation; either version 2 of</a>
<a name="ln8"> * the License, or (at your option) any later version.</a>
<a name="ln9"> *</a>
<a name="ln10"> * This library is distributed in the hope that it will be useful, but</a>
<a name="ln11"> * WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12"> * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</a>
<a name="ln13"> * Library General Public License for more details.</a>
<a name="ln14"> *</a>
<a name="ln15"> * You should have received a copy of the GNU Library General Public</a>
<a name="ln16"> * License along with this library; if not, write to the Free</a>
<a name="ln17"> * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA</a>
<a name="ln18"> * 02111-1307, USA</a>
<a name="ln19"> */</a>
<a name="ln20"> </a>
<a name="ln21">#include &quot;synthesizer/event.h&quot;</a>
<a name="ln22">#include &quot;synthesizer/msynthesizer.h&quot;</a>
<a name="ln23">#include &quot;mscore/preferences.h&quot;</a>
<a name="ln24">#include &quot;mscore/extension.h&quot;</a>
<a name="ln25"> </a>
<a name="ln26">#include &quot;fluid.h&quot;</a>
<a name="ln27">#include &quot;sfont.h&quot;</a>
<a name="ln28">#include &quot;conv.h&quot;</a>
<a name="ln29">#include &quot;gen.h&quot;</a>
<a name="ln30">#include &quot;voice.h&quot;</a>
<a name="ln31"> </a>
<a name="ln32">namespace FluidS {</a>
<a name="ln33"> </a>
<a name="ln34">/***************************************************************</a>
<a name="ln35"> *</a>
<a name="ln36"> *                         GLOBAL</a>
<a name="ln37"> */</a>
<a name="ln38"> </a>
<a name="ln39">bool Fluid::initialized = false;</a>
<a name="ln40"> </a>
<a name="ln41">/* default modulators</a>
<a name="ln42"> * SF2.01 page 52 ff:</a>
<a name="ln43"> *</a>
<a name="ln44"> * There is a set of predefined default modulators. They have to be</a>
<a name="ln45"> * explicitly overridden by the sound font in order to turn them off.</a>
<a name="ln46"> */</a>
<a name="ln47"> </a>
<a name="ln48">static const Mod defaultMod[] = {</a>
<a name="ln49">      { GEN_ATTENUATION, FLUID_MOD_VELOCITY, FLUID_MOD_GC | FLUID_MOD_CONCAVE | FLUID_MOD_UNIPOLAR | FLUID_MOD_NEGATIVE, 0, 0, 960.0 },</a>
<a name="ln50">      { GEN_FILTERFC,</a>
<a name="ln51">         FLUID_MOD_VELOCITY, FLUID_MOD_GC | FLUID_MOD_LINEAR | FLUID_MOD_UNIPOLAR | FLUID_MOD_NEGATIVE,</a>
<a name="ln52">         FLUID_MOD_VELOCITY, FLUID_MOD_GC | FLUID_MOD_SWITCH | FLUID_MOD_UNIPOLAR | FLUID_MOD_POSITIVE,</a>
<a name="ln53">         -2400 },</a>
<a name="ln54">      { GEN_VIBLFOTOPITCH, FLUID_MOD_CHANNELPRESSURE, FLUID_MOD_GC | FLUID_MOD_LINEAR | FLUID_MOD_UNIPOLAR | FLUID_MOD_POSITIVE, 0, 0, 50 },</a>
<a name="ln55">      { GEN_VIBLFOTOPITCH, 1, FLUID_MOD_CC | FLUID_MOD_LINEAR | FLUID_MOD_UNIPOLAR | FLUID_MOD_POSITIVE, 0, 0, 50 },</a>
<a name="ln56">      { GEN_ATTENUATION, 7, FLUID_MOD_CC | FLUID_MOD_CONCAVE | FLUID_MOD_UNIPOLAR | FLUID_MOD_NEGATIVE, 0, 0, 960.0 },</a>
<a name="ln57">      { GEN_PAN, 10, FLUID_MOD_CC | FLUID_MOD_LINEAR | FLUID_MOD_BIPOLAR | FLUID_MOD_POSITIVE, 0, 0, 500.0 },</a>
<a name="ln58">      { GEN_ATTENUATION, 11, FLUID_MOD_CC | FLUID_MOD_CONCAVE | FLUID_MOD_UNIPOLAR | FLUID_MOD_NEGATIVE, 0, 0, 960.0 },</a>
<a name="ln59">      { GEN_REVERBSEND, 91, FLUID_MOD_CC | FLUID_MOD_LINEAR | FLUID_MOD_UNIPOLAR | FLUID_MOD_POSITIVE, 0, 0, 200 },</a>
<a name="ln60">      { GEN_CHORUSSEND, 93, FLUID_MOD_CC | FLUID_MOD_LINEAR | FLUID_MOD_UNIPOLAR | FLUID_MOD_POSITIVE, 0, 0, 200 },</a>
<a name="ln61">      { GEN_PITCH,</a>
<a name="ln62">           FLUID_MOD_PITCHWHEEL,     FLUID_MOD_GC | FLUID_MOD_LINEAR | FLUID_MOD_BIPOLAR  | FLUID_MOD_POSITIVE,</a>
<a name="ln63">           FLUID_MOD_PITCHWHEELSENS, FLUID_MOD_GC | FLUID_MOD_LINEAR | FLUID_MOD_UNIPOLAR | FLUID_MOD_POSITIVE,</a>
<a name="ln64">        12700.0 },</a>
<a name="ln65">      };</a>
<a name="ln66"> </a>
<a name="ln67">static const Mod forcePanMod = { GEN_PAN, 10, FLUID_MOD_CC | FLUID_MOD_LINEAR | FLUID_MOD_BIPOLAR | FLUID_MOD_POSITIVE, 0, 0, 1000.0 };</a>
<a name="ln68"> </a>
<a name="ln69">//---------------------------------------------------------</a>
<a name="ln70">//   Fluid</a>
<a name="ln71">//---------------------------------------------------------</a>
<a name="ln72"> </a>
<a name="ln73">Fluid::Fluid()</a>
<a name="ln74">   : Synthesizer()</a>
<a name="ln75">      {</a>
<a name="ln76">      }</a>
<a name="ln77"> </a>
<a name="ln78">//---------------------------------------------------------</a>
<a name="ln79">//   init</a>
<a name="ln80">//    instance initialization</a>
<a name="ln81">//---------------------------------------------------------</a>
<a name="ln82"> </a>
<a name="ln83">void Fluid::init(float sampleRate)</a>
<a name="ln84">      {</a>
<a name="ln85">      if (!initialized) {     // initialize all the conversion tables and other stuff</a>
<a name="ln86">            initialized = true;</a>
<a name="ln87">            fluid_conversion_config();</a>
<a name="ln88">            Voice::dsp_float_config();</a>
<a name="ln89">            }</a>
<a name="ln90">      Synthesizer::init(sampleRate);</a>
<a name="ln91">      sample_rate        = sampleRate;</a>
<a name="ln92">      sfont_id           = 0;</a>
<a name="ln93"> </a>
<a name="ln94">      _state       = FLUID_SYNTH_PLAYING; // as soon as the synth is created it starts playing.</a>
<a name="ln95">      noteid      = 0;</a>
<a name="ln96">      for (int i = 0; i &lt; 128; ++i)</a>
<a name="ln97">            _tuning[i] = i * 100.0;</a>
<a name="ln98">      _masterTuning = 440.0;</a>
<a name="ln99"> </a>
<a name="ln100">      for (int i = 0; i &lt; 512; i++)</a>
<a name="ln101">            freeVoices.append(new Voice(this));</a>
<a name="ln102">      }</a>
<a name="ln103"> </a>
<a name="ln104">//---------------------------------------------------------</a>
<a name="ln105">//   ~Fluid</a>
<a name="ln106">//---------------------------------------------------------</a>
<a name="ln107"> </a>
<a name="ln108">Fluid::~Fluid()</a>
<a name="ln109">      {</a>
<a name="ln110">      _state = FLUID_SYNTH_STOPPED;</a>
<a name="ln111">      _globalTerminate = true;</a>
<a name="ln112">      while (!mutex.tryLock()) {}</a>
<a name="ln113">      qDeleteAll(activeVoices);</a>
<a name="ln114">      qDeleteAll(freeVoices);</a>
<a name="ln115">      qDeleteAll(sfonts);</a>
<a name="ln116">      qDeleteAll(channel);</a>
<a name="ln117">      qDeleteAll(patches);</a>
<a name="ln118">      }</a>
<a name="ln119"> </a>
<a name="ln120">//---------------------------------------------------------</a>
<a name="ln121">//   freeVoice</a>
<a name="ln122">//---------------------------------------------------------</a>
<a name="ln123"> </a>
<a name="ln124">void Fluid::freeVoice(Voice* v)</a>
<a name="ln125">      {</a>
<a name="ln126">      if (activeVoices.removeOne(v))</a>
<a name="ln127">            freeVoices.append(v);</a>
<a name="ln128">      }</a>
<a name="ln129"> </a>
<a name="ln130">//---------------------------------------------------------</a>
<a name="ln131">//   play</a>
<a name="ln132">//---------------------------------------------------------</a>
<a name="ln133"> </a>
<a name="ln134">void Fluid::play(const PlayEvent&amp; event)</a>
<a name="ln135">      {</a>
<a name="ln136">      bool err = false;</a>
<a name="ln137">      int ch   = event.channel();</a>
<a name="ln138"> </a>
<a name="ln139">      if (ch &gt;= channel.size()) {</a>
<a name="ln140">            for (int i = channel.size(); i &lt; ch+1; i++)</a>
<a name="ln141">                  channel.append(new Channel(this, i));</a>
<a name="ln142">            }</a>
<a name="ln143"> </a>
<a name="ln144">      int type    = event.type();</a>
<a name="ln145">      Channel* cp = channel[ch];</a>
<a name="ln146"> </a>
<a name="ln147">      if (type == ME_NOTEON) {</a>
<a name="ln148">            int key = event.dataA();</a>
<a name="ln149">            int vel = event.dataB();</a>
<a name="ln150">            if (vel == 0) {</a>
<a name="ln151">                  //</a>
<a name="ln152">                  // process note off</a>
<a name="ln153">                  //</a>
<a name="ln154">                  for (Voice* v : activeVoices) {</a>
<a name="ln155">                        if (v-&gt;ON() &amp;&amp; (v-&gt;chan == ch) &amp;&amp; (v-&gt;key == key))</a>
<a name="ln156">                              v-&gt;noteoff();</a>
<a name="ln157">                        }</a>
<a name="ln158">                  return;</a>
<a name="ln159">                  }</a>
<a name="ln160">            if (cp-&gt;preset() == 0) {</a>
<a name="ln161">                  qDebug(&quot;channel has no preset&quot;);</a>
<a name="ln162">                  err = true;</a>
<a name="ln163">                  }</a>
<a name="ln164">            else {</a>
<a name="ln165">                  /*</a>
<a name="ln166">                   * If the same note is hit twice on the same channel, then the older</a>
<a name="ln167">                   * voice process is advanced to the release stage.  Using a mechanical</a>
<a name="ln168">                   * MIDI controller, the only way this can happen is when the sustain</a>
<a name="ln169">                   * pedal is held.  In this case the behaviour implemented here is</a>
<a name="ln170">                   * natural for many instruments.  Note: One noteon event can trigger</a>
<a name="ln171">                   * several voice processes, for example a stereo sample.  Don't</a>
<a name="ln172">                   * release those...</a>
<a name="ln173">                   */</a>
<a name="ln174">                  for(Voice* v : activeVoices) {</a>
<a name="ln175">                        if (v-&gt;isPlaying() &amp;&amp; (v-&gt;chan == ch) &amp;&amp; (v-&gt;key == key) &amp;&amp; (v-&gt;get_id() != noteid))</a>
<a name="ln176">                              v-&gt;noteoff();</a>
<a name="ln177">                        }</a>
<a name="ln178">                  err = !cp-&gt;preset()-&gt;noteon(this, noteid++, ch, key, vel, event.tuning());</a>
<a name="ln179">                  }</a>
<a name="ln180">            }</a>
<a name="ln181">      else if (type == ME_CONTROLLER) {</a>
<a name="ln182">            switch(event.dataA()) {</a>
<a name="ln183">                  case CTRL_PROGRAM:</a>
<a name="ln184">                        program_change(ch, event.dataB());</a>
<a name="ln185">                        break;</a>
<a name="ln186">                  case CTRL_PRESS:</a>
<a name="ln187">                        break;</a>
<a name="ln188">                  default:</a>
<a name="ln189">                        cp-&gt;setcc(event.dataA(), event.dataB());</a>
<a name="ln190">                        break;</a>
<a name="ln191">                  }</a>
<a name="ln192">            }</a>
<a name="ln193">      else if (type == ME_PITCHBEND){</a>
<a name="ln194">            int midiPitch = event.dataB() * 128 + event.dataA();  // msb * 128 + lsb</a>
<a name="ln195">            cp-&gt;pitchBend(midiPitch);</a>
<a name="ln196">            }</a>
<a name="ln197">      /*</a>
<a name="ln198">       *    MIDI spec.: One data byte follows the Status. It is the pressure amount, a value</a>
<a name="ln199">       *    from 0 to 127 (where 127 is the most pressure).</a>
<a name="ln200">       */</a>
<a name="ln201">      else if (type == ME_AFTERTOUCH){</a>
<a name="ln202">            cp-&gt;setChannelPressure(event.dataA());</a>
<a name="ln203">            }</a>
<a name="ln204">      /*</a>
<a name="ln205">       *    MIDI spec.: Two data bytes follow the Status. The first data is the note number.</a>
<a name="ln206">       *    This indicates to which note the pressure is being applied. The second data byte is the</a>
<a name="ln207">       *    pressure amount, a value from 0 to 127 (where 127 is the most pressure).</a>
<a name="ln208">       */</a>
<a name="ln209">      else if (type == ME_POLYAFTER){</a>
<a name="ln210">            cp-&gt;setKeyPressure(event.dataA(), event.dataB());</a>
<a name="ln211">            }</a>
<a name="ln212"> </a>
<a name="ln213">      if (err) {</a>
<a name="ln214">            // TODO: distinguish between types of error code.</a>
<a name="ln215">            // Lack of a soundfont should not produce qDebug messages, because user could deliberately be using MIDI out only.</a>
<a name="ln216">            //qWarning(&quot;FluidSynth error: event 0x%2x channel %d: %s&quot;, type, ch, qPrintable(error()));</a>
<a name="ln217">            }</a>
<a name="ln218">      }</a>
<a name="ln219"> </a>
<a name="ln220">//---------------------------------------------------------</a>
<a name="ln221">//   damp_voices</a>
<a name="ln222">//---------------------------------------------------------</a>
<a name="ln223"> </a>
<a name="ln224">void Fluid::damp_voices(int chan)</a>
<a name="ln225">      {</a>
<a name="ln226">      for(Voice* v : activeVoices) {</a>
<a name="ln227">            if ((v-&gt;chan == chan) &amp;&amp; v-&gt;SUSTAINED())</a>
<a name="ln228">                  v-&gt;noteoff();</a>
<a name="ln229">            }</a>
<a name="ln230">      }</a>
<a name="ln231"> </a>
<a name="ln232">//---------------------------------------------------------</a>
<a name="ln233">//   allNotesOff</a>
<a name="ln234">//---------------------------------------------------------</a>
<a name="ln235"> </a>
<a name="ln236">void Fluid::allNotesOff(int chan)</a>
<a name="ln237">      {</a>
<a name="ln238">      for(Voice* v : activeVoices) {</a>
<a name="ln239">            if (chan == -1 || v-&gt;chan == chan)</a>
<a name="ln240">                  v-&gt;noteoff();</a>
<a name="ln241">            }</a>
<a name="ln242">      }</a>
<a name="ln243"> </a>
<a name="ln244">//---------------------------------------------------------</a>
<a name="ln245">//   allSoundsOff</a>
<a name="ln246">//    immediately stop all notes on this channel.</a>
<a name="ln247">//    stop all channel if chan==-1</a>
<a name="ln248">//---------------------------------------------------------</a>
<a name="ln249"> </a>
<a name="ln250">void Fluid::allSoundsOff(int chan)</a>
<a name="ln251">      {</a>
<a name="ln252">      for(Voice* v : activeVoices) {</a>
<a name="ln253">            if (chan == -1 || v-&gt;chan == chan)</a>
<a name="ln254">                  v-&gt;off();</a>
<a name="ln255">            }</a>
<a name="ln256">      }</a>
<a name="ln257"> </a>
<a name="ln258">//---------------------------------------------------------</a>
<a name="ln259">//   system_reset</a>
<a name="ln260">//</a>
<a name="ln261">//    Purpose:</a>
<a name="ln262">//    Respond to the MIDI command 'system reset' (0xFF, big red 'panic' button)</a>
<a name="ln263">//---------------------------------------------------------</a>
<a name="ln264"> </a>
<a name="ln265">void Fluid::system_reset()</a>
<a name="ln266">      {</a>
<a name="ln267">      for(Voice* v : activeVoices)</a>
<a name="ln268">            v-&gt;off();</a>
<a name="ln269">      for(Channel* c : channel)</a>
<a name="ln270">            c-&gt;reset();</a>
<a name="ln271">      }</a>
<a name="ln272"> </a>
<a name="ln273">/*</a>
<a name="ln274"> * fluid_synth_modulate_voices</a>
<a name="ln275"> *</a>
<a name="ln276"> * tell all synthesis processes on this channel to update their</a>
<a name="ln277"> * synthesis parameters after a control change.</a>
<a name="ln278"> */</a>
<a name="ln279">void Fluid::modulate_voices(int chan, bool is_cc, int ctrl)</a>
<a name="ln280">      {</a>
<a name="ln281">      for(Voice* v : activeVoices) {</a>
<a name="ln282">            if (v-&gt;chan == chan)</a>
<a name="ln283">                  v-&gt;modulate(is_cc, ctrl);</a>
<a name="ln284">            }</a>
<a name="ln285">      }</a>
<a name="ln286"> </a>
<a name="ln287">/*</a>
<a name="ln288"> * fluid_synth_modulate_voices_all</a>
<a name="ln289"> *</a>
<a name="ln290"> * Tell all synthesis processes on this channel to update their</a>
<a name="ln291"> * synthesis parameters after an all control off message (i.e. all</a>
<a name="ln292"> * controller have been reset to their default value).</a>
<a name="ln293"> */</a>
<a name="ln294">void Fluid::modulate_voices_all(int chan)</a>
<a name="ln295">      {</a>
<a name="ln296">      for(Voice* v : activeVoices) {</a>
<a name="ln297">            if (v-&gt;chan == chan)</a>
<a name="ln298">                  v-&gt;modulate_all();</a>
<a name="ln299">            }</a>
<a name="ln300">      }</a>
<a name="ln301"> </a>
<a name="ln302">/*</a>
<a name="ln303"> * fluid_synth_get_pitch_bend</a>
<a name="ln304"> */</a>
<a name="ln305">void Fluid::get_pitch_bend(int chan, int* ppitch_bend)</a>
<a name="ln306">      {</a>
<a name="ln307">      *ppitch_bend = channel[chan]-&gt;getPitchBend();</a>
<a name="ln308">      }</a>
<a name="ln309"> </a>
<a name="ln310">/*</a>
<a name="ln311"> * Fluid_synth_pitch_wheel_sens</a>
<a name="ln312"> */</a>
<a name="ln313">void Fluid::pitch_wheel_sens(int chan, int val)</a>
<a name="ln314">      {</a>
<a name="ln315">      /* set the pitch-bend value in the channel */</a>
<a name="ln316">      channel[chan]-&gt;pitchWheelSens(val);</a>
<a name="ln317">      }</a>
<a name="ln318"> </a>
<a name="ln319">/*</a>
<a name="ln320"> * fluid_synth_get_preset</a>
<a name="ln321"> */</a>
<a name="ln322">Preset* Fluid::get_preset(unsigned int sfontnum, unsigned banknum, unsigned prognum)</a>
<a name="ln323">      {</a>
<a name="ln324">      SFont* sf = get_sfont_by_id(sfontnum);</a>
<a name="ln325">      if (sf) {</a>
<a name="ln326">            Preset* preset = sf-&gt;get_preset(banknum, prognum);</a>
<a name="ln327">            if (preset != 0)</a>
<a name="ln328">                  return preset;</a>
<a name="ln329">            }</a>
<a name="ln330">      return 0;</a>
<a name="ln331">      }</a>
<a name="ln332"> </a>
<a name="ln333">//---------------------------------------------------------</a>
<a name="ln334">//   find_preset</a>
<a name="ln335">//---------------------------------------------------------</a>
<a name="ln336"> </a>
<a name="ln337">Preset* Fluid::find_preset(unsigned banknum, unsigned prognum)</a>
<a name="ln338">      {</a>
<a name="ln339">      for (SFont* sf : sfonts) {</a>
<a name="ln340">            Preset* preset = sf-&gt;get_preset(banknum, prognum);</a>
<a name="ln341">            if (preset)</a>
<a name="ln342">                  return preset;</a>
<a name="ln343">            }</a>
<a name="ln344">      return 0;</a>
<a name="ln345">      }</a>
<a name="ln346"> </a>
<a name="ln347">//---------------------------------------------------------</a>
<a name="ln348">//   program_change</a>
<a name="ln349">//---------------------------------------------------------</a>
<a name="ln350"> </a>
<a name="ln351">void Fluid::program_change(int chan, int prognum)</a>
<a name="ln352">      {</a>
<a name="ln353">      Channel* c       = channel[chan];</a>
<a name="ln354">      unsigned banknum = c-&gt;getBanknum();</a>
<a name="ln355">      c-&gt;setPrognum(prognum);</a>
<a name="ln356"> </a>
<a name="ln357">      Preset* preset = find_preset(banknum, prognum);</a>
<a name="ln358">      if (!preset) {</a>
<a name="ln359">            //Suppressing qDebug because might not have soundfont if using MIDI out only.</a>
<a name="ln360">            //qDebug(&quot;Fluid::program_change: preset %d %d not found&quot;, banknum, prognum);</a>
<a name="ln361">            preset = find_preset(0, prognum);</a>
<a name="ln362">            if (!preset)</a>
<a name="ln363">                  preset = find_preset(0, 0);</a>
<a name="ln364">            }</a>
<a name="ln365"> </a>
<a name="ln366">      unsigned sfont_idl = preset? preset-&gt;sfont-&gt;id() : 0;</a>
<a name="ln367">      c-&gt;setSfontnum(sfont_idl);</a>
<a name="ln368">      c-&gt;setPreset(preset);</a>
<a name="ln369">      }</a>
<a name="ln370"> </a>
<a name="ln371">/*</a>
<a name="ln372"> * fluid_synth_get_program</a>
<a name="ln373"> */</a>
<a name="ln374">void Fluid::get_program(int chan, unsigned* sfont_idl, unsigned* bank_num, unsigned* preset_num)</a>
<a name="ln375">      {</a>
<a name="ln376">      Channel* c       = channel[chan];</a>
<a name="ln377">      *sfont_idl       = c-&gt;getSfontnum();</a>
<a name="ln378">      *bank_num        = c-&gt;getBanknum();</a>
<a name="ln379">      *preset_num      = c-&gt;getPrognum();</a>
<a name="ln380">      }</a>
<a name="ln381"> </a>
<a name="ln382">//---------------------------------------------------------</a>
<a name="ln383">//   program_select</a>
<a name="ln384">//---------------------------------------------------------</a>
<a name="ln385"> </a>
<a name="ln386">bool Fluid::program_select(int chan, unsigned sfont_idl, unsigned bank_num, unsigned preset_num)</a>
<a name="ln387">      {</a>
<a name="ln388">      Channel* c     = channel[chan];</a>
<a name="ln389">      Preset* preset = get_preset(sfont_idl, bank_num, preset_num);</a>
<a name="ln390">      if (preset == 0) {</a>
<a name="ln391">            qDebug(&quot;There is no preset with bank number %d and preset number %d in SoundFont %d&quot;, bank_num, preset_num, sfont_idl);</a>
<a name="ln392">            return false;</a>
<a name="ln393">            }</a>
<a name="ln394"> </a>
<a name="ln395">      /* inform the channel of the new bank and program number */</a>
<a name="ln396">      c-&gt;setSfontnum(sfont_idl);</a>
<a name="ln397">      c-&gt;setBanknum(bank_num);</a>
<a name="ln398">      c-&gt;setPrognum(preset_num);</a>
<a name="ln399">      c-&gt;setPreset(preset);</a>
<a name="ln400">      return true;</a>
<a name="ln401">      }</a>
<a name="ln402"> </a>
<a name="ln403">//---------------------------------------------------------</a>
<a name="ln404">//   update_presets</a>
<a name="ln405">//---------------------------------------------------------</a>
<a name="ln406"> </a>
<a name="ln407">void Fluid::update_presets()</a>
<a name="ln408">      {</a>
<a name="ln409">      for (Channel* c : channel)</a>
<a name="ln410">            c-&gt;setPreset(get_preset(c-&gt;getSfontnum(), c-&gt;getBanknum(), c-&gt;getPrognum()));</a>
<a name="ln411">      }</a>
<a name="ln412"> </a>
<a name="ln413">//---------------------------------------------------------</a>
<a name="ln414">//   process</a>
<a name="ln415">//---------------------------------------------------------</a>
<a name="ln416"> </a>
<a name="ln417">void Fluid::process(unsigned len, float* out, float* effect1, float* effect2)</a>
<a name="ln418">      {</a>
<a name="ln419">      if (mutex.tryLock()) {</a>
<a name="ln420">            //we have to copy voices array for proper output sound processing in for loop</a>
<a name="ln421">            auto tempVoices = activeVoices;</a>
<a name="ln422">            for (Voice* v : tempVoices)</a>
<a name="ln423">                  v-&gt;write(len, out, effect1, effect2);</a>
<a name="ln424">            mutex.unlock();</a>
<a name="ln425">            }</a>
<a name="ln426">      }</a>
<a name="ln427"> </a>
<a name="ln428">/*</a>
<a name="ln429"> * fluid_synth_free_voice_by_kill</a>
<a name="ln430"> *</a>
<a name="ln431"> * selects a voice for killing. the selection algorithm is a refinement</a>
<a name="ln432"> * of the algorithm previously in fluid_synth_alloc_voice.</a>
<a name="ln433"> */</a>
<a name="ln434"> </a>
<a name="ln435">void Fluid::free_voice_by_kill()</a>
<a name="ln436">      {</a>
<a name="ln437">      float best_prio = 999999.;</a>
<a name="ln438">      float this_voice_prio;</a>
<a name="ln439">      Voice* best_voice = 0;</a>
<a name="ln440"> </a>
<a name="ln441">      for(Voice* v : activeVoices) {</a>
<a name="ln442">            /* Determine, how 'important' a voice is.</a>
<a name="ln443">             * Start with an arbitrary number */</a>
<a name="ln444">            this_voice_prio = 10000.;</a>
<a name="ln445"> </a>
<a name="ln446">            /* Is this voice on the drum channel?</a>
<a name="ln447">             * Then it is very important.</a>
<a name="ln448">             * Also, forget about the released-note condition:</a>
<a name="ln449">             * Typically, drum notes are triggered only very briefly, they run most</a>
<a name="ln450">             * of the time in release phase.</a>
<a name="ln451">             */</a>
<a name="ln452">            if (v-&gt;chan == 9) {</a>
<a name="ln453">                  this_voice_prio += 4000;</a>
<a name="ln454"> </a>
<a name="ln455">                  }</a>
<a name="ln456">            else if (v-&gt;RELEASED()) {</a>
<a name="ln457">                  /* The key for this voice has been released. Consider it much less important</a>
<a name="ln458">                  * than a voice, which is still held.</a>
<a name="ln459">                  */</a>
<a name="ln460">                  this_voice_prio -= 2000.;</a>
<a name="ln461">                  }</a>
<a name="ln462"> </a>
<a name="ln463">            if (v-&gt;SUSTAINED()) {</a>
<a name="ln464">              /* The sustain pedal is held down on this channel.</a>
<a name="ln465">               * Consider it less important than non-sustained channels.</a>
<a name="ln466">               * This decision is somehow subjective. But usually the sustain pedal</a>
<a name="ln467">               * is used to play 'more-voices-than-fingers', so it shouldn't hurt</a>
<a name="ln468">               * if we kill one voice.</a>
<a name="ln469">               */</a>
<a name="ln470">                  this_voice_prio -= 1000;</a>
<a name="ln471">                  }</a>
<a name="ln472"> </a>
<a name="ln473">            /* We are not enthusiastic about releasing voices, which have just been started.</a>
<a name="ln474">             * Otherwise hitting a chord may result in killing notes belonging to that very same</a>
<a name="ln475">             * chord.</a>
<a name="ln476">             * So subtract the age of the voice from the priority - an older voice is just a little</a>
<a name="ln477">             * bit less important than a younger voice.</a>
<a name="ln478">             * This is a number between roughly 0 and 100.*/</a>
<a name="ln479"> </a>
<a name="ln480">            this_voice_prio -= (noteid - v-&gt;get_id());</a>
<a name="ln481"> </a>
<a name="ln482">            /* take a rough estimate of loudness into account. Louder voices are more important. */</a>
<a name="ln483">            if (v-&gt;volenv_section != FLUID_VOICE_ENVATTACK) {</a>
<a name="ln484">                  this_voice_prio += v-&gt;volenv_val * 1000.;</a>
<a name="ln485">                  }</a>
<a name="ln486"> </a>
<a name="ln487">            /* check if this voice has less priority than the previous candidate. */</a>
<a name="ln488">            if (this_voice_prio &lt; best_prio) {</a>
<a name="ln489">                  best_voice = v;</a>
<a name="ln490">                  best_prio = this_voice_prio;</a>
<a name="ln491">                  }</a>
<a name="ln492">            }</a>
<a name="ln493">      if (best_voice)</a>
<a name="ln494">            best_voice-&gt;off();</a>
<a name="ln495">      }</a>
<a name="ln496"> </a>
<a name="ln497">//---------------------------------------------------------</a>
<a name="ln498">//   alloc_voice</a>
<a name="ln499">//---------------------------------------------------------</a>
<a name="ln500"> </a>
<a name="ln501">Voice* Fluid::alloc_voice(unsigned id, Sample* sample, int chan, int key, int vel, double vt)</a>
<a name="ln502">      {</a>
<a name="ln503">      Channel* c = 0;</a>
<a name="ln504"> </a>
<a name="ln505">      /* check if there's an available synthesis process */</a>
<a name="ln506">      if (freeVoices.isEmpty())</a>
<a name="ln507">            free_voice_by_kill();</a>
<a name="ln508"> </a>
<a name="ln509">      if (freeVoices.isEmpty()) {</a>
<a name="ln510">            qDebug(&quot;Failed to allocate a synthesis process. (chan=%d,key=%d)&quot;, chan, key);</a>
<a name="ln511">            return 0;</a>
<a name="ln512">            }</a>
<a name="ln513"> </a>
<a name="ln514">      Voice* v = freeVoices.takeLast();</a>
<a name="ln515">      activeVoices.append(v);</a>
<a name="ln516"> </a>
<a name="ln517">      if (chan &gt;= 0)</a>
<a name="ln518">            c = channel[chan];</a>
<a name="ln519"> </a>
<a name="ln520">      v-&gt;init(sample, c, key, vel, id, vt);</a>
<a name="ln521"> </a>
<a name="ln522">      /* add the default modulators to the synthesis process. */</a>
<a name="ln523">      for (unsigned i = 0; i &lt; sizeof(defaultMod)/sizeof(*defaultMod); ++i)</a>
<a name="ln524">            v-&gt;add_mod(&amp;defaultMod[i],  FLUID_VOICE_DEFAULT);</a>
<a name="ln525">      v-&gt;add_mod(&amp;forcePanMod, FLUID_VOICE_OVERWRITE);</a>
<a name="ln526">      return v;</a>
<a name="ln527">      }</a>
<a name="ln528"> </a>
<a name="ln529">//---------------------------------------------------------</a>
<a name="ln530">//   start_voice</a>
<a name="ln531">//---------------------------------------------------------</a>
<a name="ln532"> </a>
<a name="ln533">void Fluid::start_voice(Voice* voice)</a>
<a name="ln534">      {</a>
<a name="ln535">      /* Find the exclusive class of this voice. If set, kill all voices</a>
<a name="ln536">      * that match the exclusive class and are younger than the first</a>
<a name="ln537">      * voice process created by this noteon event. */</a>
<a name="ln538"> </a>
<a name="ln539">      /** Kill all voices on a given channel, which belong into</a>
<a name="ln540">          excl_class.  This function is called by a SoundFont's preset in</a>
<a name="ln541">          response to a noteon event.  If one noteon event results in</a>
<a name="ln542">          several voice processes (stereo samples), ignore_ID must name</a>
<a name="ln543">          the voice ID of the first generated voice (so that it is not</a>
<a name="ln544">          stopped). The first voice uses ignore_ID=-1, which will</a>
<a name="ln545">          terminate all voices on a channel belonging into the exclusive</a>
<a name="ln546">          class excl_class.</a>
<a name="ln547">      */</a>
<a name="ln548"> </a>
<a name="ln549">      /* Check if the voice belongs to an exclusive class. In that case,</a>
<a name="ln550">         previous notes from the same class are released. */</a>
<a name="ln551"> </a>
<a name="ln552">      int excl_class = voice-&gt;GEN(GEN_EXCLUSIVECLASS);</a>
<a name="ln553">      if (excl_class) {</a>
<a name="ln554"> </a>
<a name="ln555">            /* Kill all notes on the same channel with the same exclusive class */</a>
<a name="ln556"> </a>
<a name="ln557">            for(Voice* existing_voice : activeVoices) {</a>
<a name="ln558">                  /* Existing voice does not play? Leave it alone. */</a>
<a name="ln559">                  if (!existing_voice-&gt;isPlaying())</a>
<a name="ln560">                        continue;</a>
<a name="ln561"> </a>
<a name="ln562">                  /* An exclusive class is valid for a whole channel (or preset).</a>
<a name="ln563">                   * Is the voice on a different channel? Leave it alone. */</a>
<a name="ln564">                  if (existing_voice-&gt;chan != voice-&gt;chan)</a>
<a name="ln565">                        continue;</a>
<a name="ln566"> </a>
<a name="ln567">                  /* Existing voice has a different (or no) exclusive class? Leave it alone. */</a>
<a name="ln568">                  if ((int)existing_voice-&gt;GEN(GEN_EXCLUSIVECLASS) != excl_class)</a>
<a name="ln569">                        continue;</a>
<a name="ln570"> </a>
<a name="ln571">                  /* Existing voice is a voice process belonging to this noteon</a>
<a name="ln572">                   * event (for example: stereo sample)?  Leave it alone. */</a>
<a name="ln573">                  if (existing_voice-&gt;get_id() == voice-&gt;get_id())</a>
<a name="ln574">                        continue;</a>
<a name="ln575">                  existing_voice-&gt;kill_excl();</a>
<a name="ln576">                  }</a>
<a name="ln577">            }</a>
<a name="ln578">      voice-&gt;voice_start();</a>
<a name="ln579">      }</a>
<a name="ln580"> </a>
<a name="ln581">//---------------------------------------------------------</a>
<a name="ln582">//   updatePatchList</a>
<a name="ln583">//---------------------------------------------------------</a>
<a name="ln584"> </a>
<a name="ln585">void Fluid::updatePatchList()</a>
<a name="ln586">      {</a>
<a name="ln587">      qDeleteAll(patches);</a>
<a name="ln588">      patches.clear();</a>
<a name="ln589"> </a>
<a name="ln590">      int bankOffset = 0;</a>
<a name="ln591">      int sfid = 0;</a>
<a name="ln592">      for (SFont* sf : sfonts) {</a>
<a name="ln593">            sf-&gt;setBankOffset(bankOffset);</a>
<a name="ln594">            int banks = 0;</a>
<a name="ln595">            for (Preset* p : sf-&gt;getPresets()) {</a>
<a name="ln596">                  MidiPatch* patch = new MidiPatch;</a>
<a name="ln597">                  patch-&gt;drum = (p-&gt;get_banknum() == 128);</a>
<a name="ln598">                  patch-&gt;synti = name();</a>
<a name="ln599">                  if (p-&gt;get_banknum() &gt; banks)</a>
<a name="ln600">                        banks = p-&gt;get_banknum();</a>
<a name="ln601">                  patch-&gt;bank = p-&gt;get_banknum() + bankOffset;</a>
<a name="ln602">                  patch-&gt;prog = p-&gt;get_num();</a>
<a name="ln603">                  patch-&gt;name = p-&gt;get_name();</a>
<a name="ln604">                  patch-&gt;sfid = sfid;</a>
<a name="ln605">                  patches.append(patch);</a>
<a name="ln606">                  }</a>
<a name="ln607">            sfid++;</a>
<a name="ln608">            bankOffset += (banks + 1);</a>
<a name="ln609">            }</a>
<a name="ln610"> </a>
<a name="ln611">      /* try to set the correct presets */</a>
<a name="ln612">      int n = channel.size();</a>
<a name="ln613">      for (int i = 0; i &lt; n; i++)</a>
<a name="ln614">            program_change(i, channel[i]-&gt;getPrognum());</a>
<a name="ln615">      }</a>
<a name="ln616"> </a>
<a name="ln617">//---------------------------------------------------------</a>
<a name="ln618">//   soundFonts</a>
<a name="ln619">//---------------------------------------------------------</a>
<a name="ln620"> </a>
<a name="ln621">QStringList Fluid::soundFonts() const</a>
<a name="ln622">      {</a>
<a name="ln623">      QStringList sf;</a>
<a name="ln624">      for (SFont* f : sfonts)</a>
<a name="ln625">            sf.append(QFileInfo(f-&gt;get_name()).fileName());</a>
<a name="ln626">      return sf;</a>
<a name="ln627">      }</a>
<a name="ln628"> </a>
<a name="ln629">//---------------------------------------------------------</a>
<a name="ln630">//   soundFontsInfo</a>
<a name="ln631">//---------------------------------------------------------</a>
<a name="ln632"> </a>
<a name="ln633">std::vector&lt;SoundFontInfo&gt; Fluid::soundFontsInfo() const</a>
<a name="ln634">      {</a>
<a name="ln635">      std::vector&lt;SoundFontInfo&gt; sl;</a>
<a name="ln636">      sl.reserve(sfonts.size());</a>
<a name="ln637">      for (SFont* f : sfonts)</a>
<a name="ln638">            sl.emplace_back(QFileInfo(f-&gt;get_name()).fileName(), f-&gt;fontName());</a>
<a name="ln639">      return sl;</a>
<a name="ln640">      }</a>
<a name="ln641"> </a>
<a name="ln642">//---------------------------------------------------------</a>
<a name="ln643">//   loadSoundFont</a>
<a name="ln644">//    return false on error</a>
<a name="ln645">//---------------------------------------------------------</a>
<a name="ln646"> </a>
<a name="ln647">bool Fluid::loadSoundFonts(const QStringList&amp; sl)</a>
<a name="ln648">      {</a>
<a name="ln649">      QStringList ol = soundFonts();</a>
<a name="ln650">      if (ol == sl) {</a>
<a name="ln651">            qDebug(&quot;Fluid:loadSoundFonts: already loaded&quot;);</a>
<a name="ln652">            return true;</a>
<a name="ln653">            }</a>
<a name="ln654">      QMutexLocker locker(&amp;mutex);</a>
<a name="ln655">      for(Voice* v : activeVoices)</a>
<a name="ln656">            v-&gt;off();</a>
<a name="ln657">      for(Channel* c : channel)</a>
<a name="ln658">            c-&gt;reset();</a>
<a name="ln659">      for (SFont* sf : sfonts)</a>
<a name="ln660">            sfunload(sf-&gt;id());</a>
<a name="ln661">      locker.unlock();</a>
<a name="ln662">      bool ok = true;</a>
<a name="ln663"> </a>
<a name="ln664">      QFileInfoList l = sfFiles();</a>
<a name="ln665">      for (int i = sl.size() - 1; i &gt;= 0; --i) {</a>
<a name="ln666">            QString s = sl[i];</a>
<a name="ln667">            if (s.isEmpty())</a>
<a name="ln668">                  continue;</a>
<a name="ln669">            QString path;</a>
<a name="ln670">            QFileInfo fis(s);</a>
<a name="ln671">            QString fileName = fis.fileName();</a>
<a name="ln672">            for (const QFileInfo&amp; fi : l) {</a>
<a name="ln673">                  if (fi.fileName() == fileName) {</a>
<a name="ln674">                        path = fi.absoluteFilePath();</a>
<a name="ln675">                        break;</a>
<a name="ln676">                        }</a>
<a name="ln677">                  }</a>
<a name="ln678">            if (path.isEmpty()) {</a>
<a name="ln679">                  qDebug(&quot;Fluid: sf &lt;%s&gt; not found&quot;, qPrintable(s));</a>
<a name="ln680">                  ok = false;</a>
<a name="ln681">                  }</a>
<a name="ln682">            else {</a>
<a name="ln683">                  locker.relock();</a>
<a name="ln684">                  if (sfload(path) == -1) {</a>
<a name="ln685">                        qDebug(&quot;loading sf failed: &lt;%s&gt;&quot;, qPrintable(path));</a>
<a name="ln686">                        ok = false;</a>
<a name="ln687">                        }</a>
<a name="ln688">                  locker.unlock();</a>
<a name="ln689">                  }</a>
<a name="ln690">            }</a>
<a name="ln691">      return ok;</a>
<a name="ln692">      }</a>
<a name="ln693"> </a>
<a name="ln694">//---------------------------------------------------------</a>
<a name="ln695">//   addSoundFont</a>
<a name="ln696">//    return false on error</a>
<a name="ln697">//---------------------------------------------------------</a>
<a name="ln698"> </a>
<a name="ln699">bool Fluid::addSoundFont(const QString&amp; s)</a>
<a name="ln700">      {</a>
<a name="ln701">      QMutexLocker locker(&amp;mutex);</a>
<a name="ln702">      bool rv = (sfload(s) == -1) ? false : true;</a>
<a name="ln703">      return rv;</a>
<a name="ln704">      }</a>
<a name="ln705"> </a>
<a name="ln706">//---------------------------------------------------------</a>
<a name="ln707">//   removeSoundFont</a>
<a name="ln708">//    return false on error</a>
<a name="ln709">//---------------------------------------------------------</a>
<a name="ln710"> </a>
<a name="ln711">bool Fluid::removeSoundFont(const QString&amp; s)</a>
<a name="ln712">      {</a>
<a name="ln713">      QMutexLocker locker(&amp;mutex);</a>
<a name="ln714">      for(Voice* v : activeVoices)</a>
<a name="ln715">            v-&gt;off();</a>
<a name="ln716">      SFont* sf = get_sfont_by_name(s);</a>
<a name="ln717">      if (!sf)</a>
<a name="ln718">            return false;</a>
<a name="ln719">      </a>
<a name="ln720">      sfunload(sf-&gt;id());</a>
<a name="ln721">      return true;</a>
<a name="ln722">      }</a>
<a name="ln723"> </a>
<a name="ln724">//---------------------------------------------------------</a>
<a name="ln725">//   sfload</a>
<a name="ln726">//---------------------------------------------------------</a>
<a name="ln727"> </a>
<a name="ln728">int Fluid::sfload(const QString&amp; filename)</a>
<a name="ln729">      {</a>
<a name="ln730">      if (filename.isEmpty())</a>
<a name="ln731">            return -1;</a>
<a name="ln732"> </a>
<a name="ln733">      SFont* sf = new SFont(this);</a>
<a name="ln734">      try {</a>
<a name="ln735">            if (!sf-&gt;read(filename)) {</a>
<a name="ln736">                  delete sf;</a>
<a name="ln737">                  sf = 0;</a>
<a name="ln738">                  return -1;</a>
<a name="ln739">                  }</a>
<a name="ln740">            }</a>
<a name="ln741">      catch(...) {</a>
<a name="ln742">            delete sf;</a>
<a name="ln743">            sf = 0;</a>
<a name="ln744">            return -1;</a>
<a name="ln745">            }</a>
<a name="ln746"> </a>
<a name="ln747">      sf-&gt;setId(++sfont_id);</a>
<a name="ln748"> </a>
<a name="ln749">      /* insert the sfont as the first one on the list */</a>
<a name="ln750">      sfonts.prepend(sf);</a>
<a name="ln751"> </a>
<a name="ln752">      /* reset the presets for all channels */</a>
<a name="ln753"> </a>
<a name="ln754">      updatePatchList();</a>
<a name="ln755">      return sf-&gt;id();</a>
<a name="ln756">      }</a>
<a name="ln757"> </a>
<a name="ln758">//---------------------------------------------------------</a>
<a name="ln759">//   sfunload</a>
<a name="ln760">//---------------------------------------------------------</a>
<a name="ln761"> </a>
<a name="ln762">bool Fluid::sfunload(int id)</a>
<a name="ln763">      {</a>
<a name="ln764">      SFont* sf = get_sfont_by_id(id);</a>
<a name="ln765"> </a>
<a name="ln766">      if (!sf) {</a>
<a name="ln767">            qDebug(&quot;No SoundFont with id = %d&quot;, id);</a>
<a name="ln768">            return false;</a>
<a name="ln769">            }</a>
<a name="ln770"> </a>
<a name="ln771">      sfonts.removeAll(sf);   // remove the SoundFont from the list</a>
<a name="ln772">      updatePatchList();</a>
<a name="ln773"> </a>
<a name="ln774">      delete sf;</a>
<a name="ln775">      return true;</a>
<a name="ln776">      }</a>
<a name="ln777"> </a>
<a name="ln778">//---------------------------------------------------------</a>
<a name="ln779">//   get_sfont_by_id</a>
<a name="ln780">//---------------------------------------------------------</a>
<a name="ln781"> </a>
<a name="ln782">SFont* Fluid::get_sfont_by_id(int id)</a>
<a name="ln783">      {</a>
<a name="ln784">      for(SFont* sf : sfonts) {</a>
<a name="ln785">            if (sf-&gt;id() == id)</a>
<a name="ln786">                  return sf;</a>
<a name="ln787">            }</a>
<a name="ln788">      return 0;</a>
<a name="ln789">      }</a>
<a name="ln790"> </a>
<a name="ln791">//---------------------------------------------------------</a>
<a name="ln792">//   get_sfont_by_name</a>
<a name="ln793">//---------------------------------------------------------</a>
<a name="ln794"> </a>
<a name="ln795">SFont* Fluid::get_sfont_by_name(const QString&amp; name)</a>
<a name="ln796">      {</a>
<a name="ln797">      for(SFont* sf : sfonts) {</a>
<a name="ln798">            if (QFileInfo(sf-&gt;get_name()).fileName() == name)</a>
<a name="ln799">                  return sf;</a>
<a name="ln800">            }</a>
<a name="ln801">      return 0;</a>
<a name="ln802">      }</a>
<a name="ln803"> </a>
<a name="ln804">//---------------------------------------------------------</a>
<a name="ln805">//   set_interp_method</a>
<a name="ln806">//    Sets the interpolation method to use on channel chan.</a>
<a name="ln807">//    If chan is &lt; 0, then set the interpolation method on all channels.</a>
<a name="ln808">//---------------------------------------------------------</a>
<a name="ln809"> </a>
<a name="ln810">void Fluid::set_interp_method(int chan, int interp_method)</a>
<a name="ln811">      {</a>
<a name="ln812">      for(Channel* c : channel) {</a>
<a name="ln813">            if (chan &lt; 0 || c-&gt;getNum() == chan)</a>
<a name="ln814">                  c-&gt;setInterpMethod(interp_method);</a>
<a name="ln815">            }</a>
<a name="ln816">      }</a>
<a name="ln817"> </a>
<a name="ln818">//---------------------------------------------------------</a>
<a name="ln819">//   set_gen</a>
<a name="ln820">//---------------------------------------------------------</a>
<a name="ln821"> </a>
<a name="ln822">void Fluid::set_gen(int chan, int param, float value)</a>
<a name="ln823">      {</a>
<a name="ln824">      channel[chan]-&gt;setGen(param, value, 0);</a>
<a name="ln825">      for(Voice* v : activeVoices) {</a>
<a name="ln826">            if (v-&gt;chan == chan)</a>
<a name="ln827">                  v-&gt;set_param(param, value, 0);</a>
<a name="ln828">            }</a>
<a name="ln829">      }</a>
<a name="ln830"> </a>
<a name="ln831">/** Change the value of a generator. This function allows to control</a>
<a name="ln832">    all synthesis parameters in real-time. The changes are additive,</a>
<a name="ln833">    i.e. they add up to the existing parameter value. This function is</a>
<a name="ln834">    similar to sending an NRPN message to the synthesizer. The</a>
<a name="ln835">    function accepts a float as the value of the parameter. The</a>
<a name="ln836">    parameter numbers and ranges are described in the SoundFont 2.01</a>
<a name="ln837">    specification, paragraph 8.1.3, page 48. See also</a>
<a name="ln838">    'fluid_gen_type'.</a>
<a name="ln839"> </a>
<a name="ln840">    Using the fluid_synth_set_gen2() function, it is possible to set</a>
<a name="ln841">    the absolute value of a generator. This is an extension to the</a>
<a name="ln842">    SoundFont standard. If 'absolute' is non-zero, the value of the</a>
<a name="ln843">    generator specified in the SoundFont is completely ignored and the</a>
<a name="ln844">    generator is fixed to the value passed as argument. To undo this</a>
<a name="ln845">    behavior, you must call fluid_synth_set_gen2 again, with</a>
<a name="ln846">    'absolute' set to 0 (and possibly 'value' set to zero).</a>
<a name="ln847"> </a>
<a name="ln848">    If 'normalized' is non-zero, the value is supposed to be</a>
<a name="ln849">    normalized between 0 and 1. Before applying the value, it will be</a>
<a name="ln850">    scaled and shifted to the range defined in the SoundFont</a>
<a name="ln851">    specifications.</a>
<a name="ln852"> </a>
<a name="ln853"> */</a>
<a name="ln854">void Fluid::set_gen2(int chan, int param, float value, int absolute, int normalized)</a>
<a name="ln855">      {</a>
<a name="ln856">      float v = (normalized)? fluid_gen_scale(param, value) : value;</a>
<a name="ln857">      channel[chan]-&gt;setGen(param, v, absolute);</a>
<a name="ln858"> </a>
<a name="ln859">      for(Voice* vo : activeVoices) {</a>
<a name="ln860">            if (vo-&gt;chan == chan)</a>
<a name="ln861">                  vo-&gt;set_param(param, v, absolute);</a>
<a name="ln862">            }</a>
<a name="ln863">      }</a>
<a name="ln864"> </a>
<a name="ln865">float Fluid::get_gen(int chan, int param)</a>
<a name="ln866">      {</a>
<a name="ln867">      if ((param &lt; 0) || (param &gt;= GEN_LAST)) {</a>
<a name="ln868">            qDebug(&quot;Parameter number out of range&quot;);</a>
<a name="ln869">            return 0.0;</a>
<a name="ln870">            }</a>
<a name="ln871">      return channel[chan]-&gt;getGen(param);</a>
<a name="ln872">      }</a>
<a name="ln873"> </a>
<a name="ln874">//---------------------------------------------------------</a>
<a name="ln875">//   state</a>
<a name="ln876">//---------------------------------------------------------</a>
<a name="ln877"> </a>
<a name="ln878">SynthesizerGroup Fluid::state() const</a>
<a name="ln879">      {</a>
<a name="ln880">      SynthesizerGroup g;</a>
<a name="ln881">      g.setName(name());</a>
<a name="ln882"> </a>
<a name="ln883">      QStringList sfl = soundFonts();</a>
<a name="ln884">      for (QString sf : sfl)</a>
<a name="ln885">            g.push_back(IdValue(0, sf));</a>
<a name="ln886"> </a>
<a name="ln887">      return g;</a>
<a name="ln888">      }</a>
<a name="ln889"> </a>
<a name="ln890">//---------------------------------------------------------</a>
<a name="ln891">//   setState</a>
<a name="ln892">//---------------------------------------------------------</a>
<a name="ln893"> </a>
<a name="ln894">bool Fluid::setState(const SynthesizerGroup&amp; sp)</a>
<a name="ln895">      {</a>
<a name="ln896">      QStringList sfl;</a>
<a name="ln897">      for (const IdValue&amp; v : sp) {</a>
<a name="ln898">            if (v.id == 0)</a>
<a name="ln899">                  sfl.append(v.data);</a>
<a name="ln900">            else</a>
<a name="ln901">                  qDebug(&quot;Fluid::setState: unknown id %d&quot;, v.id);</a>
<a name="ln902">            }</a>
<a name="ln903">      return loadSoundFonts(sfl);</a>
<a name="ln904">      }</a>
<a name="ln905"> </a>
<a name="ln906">//---------------------------------------------------------</a>
<a name="ln907">//   collectFiles</a>
<a name="ln908">//---------------------------------------------------------</a>
<a name="ln909"> </a>
<a name="ln910">static void collectFiles(QFileInfoList* l, const QString&amp; path)</a>
<a name="ln911">      {</a>
<a name="ln912">      QDir dir(path);</a>
<a name="ln913">      for (const QFileInfo&amp; s : dir.entryInfoList(QDir::Files | QDir::Dirs | QDir::NoDotAndDotDot)) {</a>
<a name="ln914">            if (path == s.absoluteFilePath())</a>
<a name="ln915">                  return;</a>
<a name="ln916"> </a>
<a name="ln917">            if (s.isDir() &amp;&amp; !s.isHidden())</a>
<a name="ln918">                  collectFiles(l, s.absoluteFilePath());</a>
<a name="ln919">            else {</a>
<a name="ln920">                  QString suffix = s.suffix().toLower();</a>
<a name="ln921">                  if (suffix == &quot;sf&quot; || suffix == &quot;sf2&quot; || suffix == &quot;sf3&quot;)</a>
<a name="ln922">                        l-&gt;append(s);</a>
<a name="ln923">                  }</a>
<a name="ln924">            }</a>
<a name="ln925">      }</a>
<a name="ln926"> </a>
<a name="ln927">//---------------------------------------------------------</a>
<a name="ln928">//   sfFiles</a>
<a name="ln929">//---------------------------------------------------------</a>
<a name="ln930"> </a>
<a name="ln931">QFileInfoList Fluid::sfFiles()</a>
<a name="ln932">      {</a>
<a name="ln933">      QFileInfoList l;</a>
<a name="ln934"> </a>
<a name="ln935">      QStringList pl = preferences.getString(PREF_APP_PATHS_MYSOUNDFONTS).split(&quot;;&quot;);</a>
<a name="ln936">      pl.prepend(QFileInfo(QString(&quot;%1%2&quot;).arg(mscoreGlobalShare).arg(&quot;sound&quot;)).absoluteFilePath());</a>
<a name="ln937"> </a>
<a name="ln938">      // append extensions directory</a>
<a name="ln939">      QStringList extensionsDir = Ms::Extension::getDirectoriesByType(Ms::Extension::soundfontsDir);</a>
<a name="ln940">      pl.append(extensionsDir);</a>
<a name="ln941"> </a>
<a name="ln942">      foreach (const QString&amp; s, pl) {</a>
<a name="ln943">            QString ss(s);</a>
<a name="ln944">            if (!s.isEmpty() &amp;&amp; s[0] == '~')</a>
<a name="ln945">                  ss = QDir::homePath() + s.mid(1);</a>
<a name="ln946">            collectFiles(&amp;l, ss);</a>
<a name="ln947">            }</a>
<a name="ln948">      return l;</a>
<a name="ln949">      }</a>
<a name="ln950">}</a>

</code></pre>
<div class="balloon" rel="679"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="685"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="73"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: sample_rate, _masterTuning, _tuning, _state, sfont_id, noteid.</p></div>
<div class="balloon" rel="6"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
