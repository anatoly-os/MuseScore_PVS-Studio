
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>importgtp-gp5.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;importgtp.h&quot;</a>
<a name="ln14">#include &quot;globals.h&quot;</a>
<a name="ln15">#include &lt;libmscore/score.h&gt;</a>
<a name="ln16">#include &lt;libmscore/measurebase.h&gt;</a>
<a name="ln17">#include &lt;libmscore/text.h&gt;</a>
<a name="ln18">#include &lt;libmscore/box.h&gt;</a>
<a name="ln19">#include &lt;libmscore/staff.h&gt;</a>
<a name="ln20">#include &lt;libmscore/part.h&gt;</a>
<a name="ln21">#include &lt;libmscore/measure.h&gt;</a>
<a name="ln22">#include &lt;libmscore/timesig.h&gt;</a>
<a name="ln23">#include &lt;libmscore/tremolo.h&gt;</a>
<a name="ln24">#include &lt;libmscore/rest.h&gt;</a>
<a name="ln25">#include &lt;libmscore/chord.h&gt;</a>
<a name="ln26">#include &lt;libmscore/note.h&gt;</a>
<a name="ln27">#include &lt;libmscore/stringdata.h&gt;</a>
<a name="ln28">#include &lt;libmscore/clef.h&gt;</a>
<a name="ln29">#include &lt;libmscore/lyrics.h&gt;</a>
<a name="ln30">#include &lt;libmscore/tempotext.h&gt;</a>
<a name="ln31">#include &lt;libmscore/glissando.h&gt;</a>
<a name="ln32">#include &lt;libmscore/slur.h&gt;</a>
<a name="ln33">#include &lt;libmscore/tie.h&gt;</a>
<a name="ln34">#include &lt;libmscore/tuplet.h&gt;</a>
<a name="ln35">#include &lt;libmscore/barline.h&gt;</a>
<a name="ln36">#include &lt;libmscore/excerpt.h&gt;</a>
<a name="ln37">#include &lt;libmscore/stafftype.h&gt;</a>
<a name="ln38">#include &lt;libmscore/bracket.h&gt;</a>
<a name="ln39">#include &lt;libmscore/articulation.h&gt;</a>
<a name="ln40">#include &lt;libmscore/keysig.h&gt;</a>
<a name="ln41">#include &lt;libmscore/harmony.h&gt;</a>
<a name="ln42">#include &lt;libmscore/bend.h&gt;</a>
<a name="ln43">#include &lt;libmscore/tremolobar.h&gt;</a>
<a name="ln44">#include &lt;libmscore/segment.h&gt;</a>
<a name="ln45">#include &lt;libmscore/rehearsalmark.h&gt;</a>
<a name="ln46">#include &lt;libmscore/dynamic.h&gt;</a>
<a name="ln47">#include &lt;libmscore/arpeggio.h&gt;</a>
<a name="ln48">#include &lt;libmscore/volta.h&gt;</a>
<a name="ln49">#include &lt;libmscore/instrtemplate.h&gt;</a>
<a name="ln50">#include &lt;libmscore/fingering.h&gt;</a>
<a name="ln51">#include &lt;libmscore/notedot.h&gt;</a>
<a name="ln52">#include &lt;libmscore/stafftext.h&gt;</a>
<a name="ln53">#include &lt;libmscore/sym.h&gt;</a>
<a name="ln54">#include &lt;libmscore/chordline.h&gt;</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">namespace Ms {</a>
<a name="ln58"> </a>
<a name="ln59">//---------------------------------------------------------</a>
<a name="ln60">//   readInfo</a>
<a name="ln61">//---------------------------------------------------------</a>
<a name="ln62"> </a>
<a name="ln63">void GuitarPro5::readInfo()</a>
<a name="ln64">      {</a>
<a name="ln65">      title        = readDelphiString();</a>
<a name="ln66">      subtitle     = readDelphiString();</a>
<a name="ln67">      artist       = readDelphiString();</a>
<a name="ln68">      album        = readDelphiString();</a>
<a name="ln69">      composer     = readDelphiString();</a>
<a name="ln70">      readDelphiString();</a>
<a name="ln71">      QString copyright = readDelphiString();</a>
<a name="ln72">      if (!copyright.isEmpty())</a>
<a name="ln73">            score-&gt;setMetaTag(&quot;copyright&quot;, QString(&quot;%1&quot;).arg(copyright));</a>
<a name="ln74"> </a>
<a name="ln75">      transcriber  = readDelphiString();</a>
<a name="ln76">      instructions = readDelphiString();</a>
<a name="ln77">      int n = readInt();</a>
<a name="ln78">      for (int i = 0; i &lt; n; ++i)</a>
<a name="ln79">            comments.append(readDelphiString());</a>
<a name="ln80">      }</a>
<a name="ln81"> </a>
<a name="ln82">//---------------------------------------------------------</a>
<a name="ln83">//   readBeatEffects</a>
<a name="ln84">//---------------------------------------------------------</a>
<a name="ln85"> </a>
<a name="ln86">int GuitarPro5::readBeatEffects(int track, Segment* segment)</a>
<a name="ln87">      {</a>
<a name="ln88">      int effects = 0;</a>
<a name="ln89"> </a>
<a name="ln90">      uchar fxBits1 = readUChar();</a>
<a name="ln91">      uchar fxBits2 = readUChar();</a>
<a name="ln92">      if (fxBits1 &amp; BEAT_FADE)</a>
<a name="ln93">             effects = 4; // fade in</a>
<a name="ln94">      if (fxBits1 &amp; BEAT_EFFECT) {</a>
<a name="ln95">            int k = readUChar();</a>
<a name="ln96">		effects = k + effects * 100;// &amp;effects;</a>
<a name="ln97">	      }</a>
<a name="ln98">      if (fxBits1 &amp; BEAT_VIBRATO_TREMOLO) {</a>
<a name="ln99">            effects = 7 + effects * 100;</a>
<a name="ln100">            }</a>
<a name="ln101">      if (fxBits2 &amp; BEAT_TREMOLO)</a>
<a name="ln102">            readTremoloBar(track, segment);       // readBend();</a>
<a name="ln103">      if (fxBits2 &amp; 0x01) { // Rasgueado effect</a>
<a name="ln104">            StaffText* st = new StaffText(score);</a>
<a name="ln105">		st-&gt;setXmlText(&quot;rasg.&quot;);</a>
<a name="ln106">		st-&gt;setParent(segment);</a>
<a name="ln107">		st-&gt;setTrack(track);</a>
<a name="ln108">		score-&gt;addElement(st);</a>
<a name="ln109">	      }</a>
<a name="ln110">      if (fxBits1 &amp; BEAT_ARPEGGIO) {</a>
<a name="ln111">            int strokeup = readUChar();            // up stroke length</a>
<a name="ln112">            int strokedown = readUChar();            // down stroke length</a>
<a name="ln113"> </a>
<a name="ln114">            Arpeggio* a = new Arpeggio(score);</a>
<a name="ln115">            // representation is different in guitar pro 5 - the up/down order below is correct</a>
<a name="ln116">            if (strokeup &gt; 0) {</a>
<a name="ln117">                  a-&gt;setArpeggioType(ArpeggioType::UP_STRAIGHT);</a>
<a name="ln118">                  }</a>
<a name="ln119">            else if (strokedown &gt; 0) {</a>
<a name="ln120">                  a-&gt;setArpeggioType(ArpeggioType::DOWN_STRAIGHT);</a>
<a name="ln121">                  }</a>
<a name="ln122">            else {</a>
<a name="ln123">                  delete a;</a>
<a name="ln124">                  a = 0;</a>
<a name="ln125">                  }</a>
<a name="ln126">            if (a) {</a>
<a name="ln127">                  ChordRest* cr = new Chord(score);</a>
<a name="ln128">                  cr-&gt;setTrack(track);</a>
<a name="ln129">                  cr-&gt;add(a);</a>
<a name="ln130">                  segment-&gt;add(cr);</a>
<a name="ln131">                  }</a>
<a name="ln132">            }</a>
<a name="ln133">      if (fxBits2 &amp; BEAT_STROKE_DIR) {</a>
<a name="ln134">            effects = readChar();            // stroke pick direction</a>
<a name="ln135">            effects += 4; //1 or 2 for effects becomes 4 or 5</a>
<a name="ln136">            }</a>
<a name="ln137">      return effects;</a>
<a name="ln138">      }</a>
<a name="ln139"> </a>
<a name="ln140">//---------------------------------------------------------</a>
<a name="ln141">//   readPageSetup</a>
<a name="ln142">//---------------------------------------------------------</a>
<a name="ln143"> </a>
<a name="ln144">void GuitarPro5::readPageSetup()</a>
<a name="ln145">      {</a>
<a name="ln146">      skip(version &gt; 500 ? 49 : 30);</a>
<a name="ln147">      for (int i = 0; i &lt; 11; ++i) {</a>
<a name="ln148">            skip(4);</a>
<a name="ln149">            readBytePascalString();</a>
<a name="ln150">            }</a>
<a name="ln151">      }</a>
<a name="ln152"> </a>
<a name="ln153">//---------------------------------------------------------</a>
<a name="ln154">//   readBeat</a>
<a name="ln155">//---------------------------------------------------------</a>
<a name="ln156"> </a>
<a name="ln157">Fraction GuitarPro5::readBeat(const Fraction&amp; tick, int voice, Measure* measure, int staffIdx, Tuplet** tuplets,</a>
<a name="ln158">   bool /*mixChange*/)</a>
<a name="ln159">      {</a>
<a name="ln160">      uchar beatBits = readUChar();</a>
<a name="ln161">      bool dotted    = beatBits &amp; BEAT_DOTTED;</a>
<a name="ln162"> </a>
<a name="ln163">      slide = -1;</a>
<a name="ln164">      int track = staffIdx * VOICES + voice;</a>
<a name="ln165">      if (slides.contains(track))</a>
<a name="ln166">            slide = slides.take(track);</a>
<a name="ln167"> </a>
<a name="ln168">      int pause = -1;</a>
<a name="ln169">      if (beatBits &amp; BEAT_PAUSE)</a>
<a name="ln170">            pause = readUChar();</a>
<a name="ln171"> </a>
<a name="ln172">      // readDuration</a>
<a name="ln173">      int len   = readChar();</a>
<a name="ln174">      int tuple = 0;</a>
<a name="ln175">      if (beatBits &amp; BEAT_TUPLET)</a>
<a name="ln176">            tuple = readInt();</a>
<a name="ln177"> </a>
<a name="ln178">      Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, tick);</a>
<a name="ln179">      if (beatBits &amp; BEAT_CHORD) {</a>
<a name="ln180">            int numStrings = score-&gt;staff(staffIdx)-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln181">            skip(17);</a>
<a name="ln182">#if 0</a>
<a name="ln183">            uchar header = readUChar(); //1</a>
<a name="ln184">		uchar sharp = readUChar(); //2</a>
<a name="ln185">		skip(3); //5</a>
<a name="ln186">		char root = readChar(); //6</a>
<a name="ln187">		uchar chordtype = readUChar();//7</a>
<a name="ln188">		uchar nines = readUChar();//8</a>
<a name="ln189">		int bass = readInt();//12</a>
<a name="ln190">		int aug = readInt(); //16</a>
<a name="ln191">		char add = readChar(); //17</a>
<a name="ln192">#endif</a>
<a name="ln193">            QString name;</a>
<a name="ln194">            {</a>
<a name="ln195">		      /*auto len =*/ readUChar();</a>
<a name="ln196">			char c[21];</a>
<a name="ln197">			f-&gt;read(c, 21);</a>
<a name="ln198">			// if (len &gt; 20)</a>
<a name="ln199">			//      skip(len - 20);</a>
<a name="ln200">                  //skip(len - 20);</a>
<a name="ln201">			c[20] = 0;</a>
<a name="ln202">			name = c;</a>
<a name="ln203">			}</a>
<a name="ln204">            //QString name = readPascalString(21);</a>
<a name="ln205">            skip(4);</a>
<a name="ln206">            // no header to be read in the GP5 format - default to true.</a>
<a name="ln207">            readChord(segment, staffIdx * VOICES, numStrings, name, true);</a>
<a name="ln208">            skip(32);</a>
<a name="ln209">            }</a>
<a name="ln210">      Lyrics* lyrics = 0;</a>
<a name="ln211">      QString free_text;</a>
<a name="ln212">      if (beatBits &amp; BEAT_LYRICS) {</a>
<a name="ln213">            //free_text = readDelphiString();</a>
<a name="ln214">		QString qs = readDelphiString();</a>
<a name="ln215">            std::string txt = qs.toUtf8().constData();</a>
<a name="ln216">     	      txt.erase(std::remove_if(txt.begin(), txt.end(), [](char c) {return c == '_'; }), txt.end());</a>
<a name="ln217">//		auto pos = txt.find('-');</a>
<a name="ln218">		auto buffer = txt;</a>
<a name="ln219">		txt.resize(0);</a>
<a name="ln220">		const char* c = buffer.c_str();</a>
<a name="ln221">            while (*c) {</a>
<a name="ln222">                  if (*c == ' ') {</a>
<a name="ln223">                        while (*c == ' ')</a>
<a name="ln224">                              ++c;</a>
<a name="ln225">                        if (*c == '-') {</a>
<a name="ln226">				      txt += '-';</a>
<a name="ln227">                              ++c;</a>
<a name="ln228">					while (*c == ' ')</a>
<a name="ln229">                                    ++c;</a>
<a name="ln230">				      }</a>
<a name="ln231">                        else if (*c)</a>
<a name="ln232">                              txt += '-';</a>
<a name="ln233">			      }</a>
<a name="ln234">                  else</a>
<a name="ln235">                        txt += *(c++);</a>
<a name="ln236">		      }</a>
<a name="ln237">            if (gpLyrics.lyrics.size() == 0 || (gpLyrics.lyrics.size() == 1 &amp;&amp; gpLyrics.lyrics[0].isEmpty())) {</a>
<a name="ln238">//			gpLyrics.lyrics.resize(0);</a>
<a name="ln239">                  gpLyrics.lyrics.clear();</a>
<a name="ln240">			gpLyrics.fromBeat = _beat_counter;</a>
<a name="ln241">			gpLyrics.lyricTrack = track;</a>
<a name="ln242">		      }</a>
<a name="ln243">            while (txt.size() &amp;&amp; txt[txt.size() - 1] == '-')</a>
<a name="ln244">                  txt.resize(txt.size() - 1);</a>
<a name="ln245">//		  gpLyrics.lyrics.append(txt);</a>
<a name="ln246">            gpLyrics.lyrics.append(QString::fromUtf8(txt.data(), int(txt.size())));</a>
<a name="ln247">		gpLyrics.segments.push_back(segment);</a>
<a name="ln248">            }</a>
<a name="ln249">#if 0</a>
<a name="ln250">      gpLyrics.beatCounter++;</a>
<a name="ln251">      if (false &amp;&amp; gpLyrics.beatCounter &gt;= gpLyrics.fromBeat &amp;&amp; gpLyrics.lyricTrack == staffIdx+1) {</a>
<a name="ln252">            int index = gpLyrics.beatCounter - gpLyrics.fromBeat;</a>
<a name="ln253">            if (index &lt; gpLyrics.lyrics.size()) {</a>
<a name="ln254">		      lyrics = new Lyrics(score);</a>
<a name="ln255">			lyrics-&gt;setPlainText(gpLyrics.lyrics[index]);</a>
<a name="ln256">                  }</a>
<a name="ln257">            }</a>
<a name="ln258">#endif</a>
<a name="ln259">      int beatEffects = 0;</a>
<a name="ln260">      if (beatBits &amp; BEAT_EFFECTS)</a>
<a name="ln261">            beatEffects = readBeatEffects(track, segment);</a>
<a name="ln262">      last_segment = segment;</a>
<a name="ln263">      if (beatBits &amp; BEAT_MIX_CHANGE)</a>
<a name="ln264">            readMixChange(measure);</a>
<a name="ln265"> </a>
<a name="ln266">      int strings = readUChar();   // used strings mask</a>
<a name="ln267"> </a>
<a name="ln268">      Fraction l  = len2fraction(len);</a>
<a name="ln269"> </a>
<a name="ln270">      // Some beat effects could add a Chord before this</a>
<a name="ln271">      ChordRest* cr = segment-&gt;cr(track);</a>
<a name="ln272">      if (voice != 0 &amp;&amp; pause == 0 &amp;&amp; strings == 0)</a>
<a name="ln273">            cr = 0;</a>
<a name="ln274">      else {</a>
<a name="ln275">            if (strings == 0) {</a>
<a name="ln276">                  if (cr) {</a>
<a name="ln277">                        segment-&gt;remove(cr);</a>
<a name="ln278">                        delete cr;</a>
<a name="ln279">                        cr = 0;</a>
<a name="ln280">                        }</a>
<a name="ln281">                  cr = new Rest(score);</a>
<a name="ln282">                  }</a>
<a name="ln283">            else  {</a>
<a name="ln284">                  if (!cr)</a>
<a name="ln285">                        cr = new Chord(score);</a>
<a name="ln286">                  }</a>
<a name="ln287">            cr-&gt;setParent(segment);</a>
<a name="ln288">            cr-&gt;setTrack(track);</a>
<a name="ln289"> </a>
<a name="ln290">            TDuration d(l);</a>
<a name="ln291">            d.setDots(dotted ? 1 : 0);</a>
<a name="ln292"> </a>
<a name="ln293">            if (dotted)</a>
<a name="ln294">                  l = l + (l * Fraction(1,2));</a>
<a name="ln295"> </a>
<a name="ln296">            if (tuple) {</a>
<a name="ln297">                  Tuplet* tuplet = tuplets[staffIdx * 2 + voice];</a>
<a name="ln298">                  if ((tuplet == 0) || (tuplet-&gt;elementsDuration() == tuplet-&gt;baseLen().fraction() * tuplet-&gt;ratio().numerator())) {</a>
<a name="ln299">                        tuplet = new Tuplet(score);</a>
<a name="ln300">                        tuplet-&gt;setTick(tick);</a>
<a name="ln301">                        // int track = staffIdx * 2 + voice;</a>
<a name="ln302">                        tuplets[staffIdx * 2 + voice] = tuplet;</a>
<a name="ln303">                        tuplet-&gt;setTrack(cr-&gt;track());</a>
<a name="ln304">                        setTuplet(tuplet, tuple);</a>
<a name="ln305">                        tuplet-&gt;setParent(measure);</a>
<a name="ln306">                        }</a>
<a name="ln307">                  tuplet-&gt;setTrack(cr-&gt;track());</a>
<a name="ln308">                  tuplet-&gt;setBaseLen(l);</a>
<a name="ln309">                  tuplet-&gt;setTicks(l * tuplet-&gt;ratio().denominator());</a>
<a name="ln310">                  cr-&gt;setTuplet(tuplet);</a>
<a name="ln311">                  tuplet-&gt;add(cr);</a>
<a name="ln312">                  }</a>
<a name="ln313"> </a>
<a name="ln314">            cr-&gt;setTicks(l);</a>
<a name="ln315">            if (cr-&gt;isRest() &amp;&amp; (pause == 0 || l &gt;= measure-&gt;ticks())) {</a>
<a name="ln316">                  cr-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln317">                  cr-&gt;setTicks(measure-&gt;ticks());</a>
<a name="ln318">                  }</a>
<a name="ln319">            else</a>
<a name="ln320">                  cr-&gt;setDurationType(d);</a>
<a name="ln321"> </a>
<a name="ln322">            if (!segment-&gt;cr(track))</a>
<a name="ln323">                  segment-&gt;add(cr);</a>
<a name="ln324"> </a>
<a name="ln325">            Staff* staff = cr-&gt;staff();</a>
<a name="ln326">            int numStrings = staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings();</a>
<a name="ln327">            bool hasSlur = false;</a>
<a name="ln328">		Note* _note{ nullptr };</a>
<a name="ln329">		std::vector&lt;Note*&gt; delnote;</a>
<a name="ln330">            for (int i = 6; i &gt;= 0; --i) {</a>
<a name="ln331">                  if (strings &amp; (1 &lt;&lt; i) &amp;&amp; ((6-i) &lt; numStrings)) {</a>
<a name="ln332">                        Note* note = new Note(score);</a>
<a name="ln333">				_note = note;</a>
<a name="ln334">                        if (dotted) {</a>
<a name="ln335">                              // there is at most one dotted note in this guitar pro version</a>
<a name="ln336">                              NoteDot* dot = new NoteDot(score);</a>
<a name="ln337">                              dot-&gt;setParent(note);</a>
<a name="ln338">                              dot-&gt;setTrack(track);  // needed to know the staff it belongs to (and detect tablature)</a>
<a name="ln339">                              dot-&gt;setVisible(true);</a>
<a name="ln340">                              note-&gt;add(dot);</a>
<a name="ln341">                              }</a>
<a name="ln342">                        toChord(cr)-&gt;add(note);</a>
<a name="ln343"> </a>
<a name="ln344">                        hasSlur = (readNote(6-i, note) || hasSlur);</a>
<a name="ln345">                        if (slideList.size() &amp;&amp; slideList.back() == nullptr) {</a>
<a name="ln346">                              slideList.back() = note;</a>
<a name="ln347">					hasSlur = true;</a>
<a name="ln348">					}</a>
<a name="ln349">                        if (note-&gt;fret() == -20) {</a>
<a name="ln350">                              delnote.push_back(note);</a>
<a name="ln351">#if 0</a>
<a name="ln352">					Chord* chord = toChord(cr);</a>
<a name="ln353">					chord-&gt;remove(note);</a>
<a name="ln354">                              delete note;</a>
<a name="ln355">					if (chord-&gt;notes().empty()) {</a>
<a name="ln356">                                    chord-&gt;segment()-&gt;remove(chord);</a>
<a name="ln357">						delete chord;</a>
<a name="ln358">						cr = nullptr;</a>
<a name="ln359">						}</a>
<a name="ln360">#endif</a>
<a name="ln361">				      }</a>
<a name="ln362">			      else</a>
<a name="ln363">				      note-&gt;setTpcFromPitch();</a>
<a name="ln364">                        }</a>
<a name="ln365">                  }</a>
<a name="ln366">            if (delnote.size()) {</a>
<a name="ln367">                  Chord* chord = toChord(cr);</a>
<a name="ln368">                  for (auto n : delnote) {</a>
<a name="ln369">                        chord-&gt;remove(n);</a>
<a name="ln370">                        delete n;</a>
<a name="ln371">                        }</a>
<a name="ln372">                  if (chord-&gt;notes().empty()) {</a>
<a name="ln373">                        if (chord-&gt;tuplet())</a>
<a name="ln374">                              chord-&gt;tuplet()-&gt;remove(chord);</a>
<a name="ln375">                        chord-&gt;segment()-&gt;remove(chord);</a>
<a name="ln376">                        delete chord;</a>
<a name="ln377">				cr = nullptr;</a>
<a name="ln378">				}</a>
<a name="ln379">                  delnote.clear();</a>
<a name="ln380">			}</a>
<a name="ln381">            createSlur(hasSlur, staffIdx, cr);</a>
<a name="ln382">            if (lyrics)</a>
<a name="ln383">                  cr-&gt;add(lyrics);</a>
<a name="ln384">			if (free_text.length() &amp;&amp; _note) {</a>
<a name="ln385">				addTextToNote(free_text, Align::CENTER, _note);</a>
<a name="ln386">			      }</a>
<a name="ln387"> </a>
<a name="ln388">            }</a>
<a name="ln389">      int rr = readChar();</a>
<a name="ln390">      if (cr &amp;&amp; cr-&gt;isChord()) {</a>
<a name="ln391">            Chord* chord = toChord(cr);</a>
<a name="ln392">            do {</a>
<a name="ln393">                  applyBeatEffects(chord, beatEffects % 100);</a>
<a name="ln394">            } while (beatEffects /= 100);</a>
<a name="ln395">            if (rr == ARPEGGIO_DOWN)</a>
<a name="ln396">                  chord-&gt;setStemDirection(Direction::DOWN);</a>
<a name="ln397">            else if (rr == ARPEGGIO_UP)</a>
<a name="ln398">                  chord-&gt;setStemDirection(Direction::UP);</a>
<a name="ln399">            }</a>
<a name="ln400">      int r = readChar();</a>
<a name="ln401">      if (r &amp; 0x8) {</a>
<a name="ln402">            int rrr = readChar();</a>
<a name="ln403">qDebug(&quot;  3beat read 0x%02x&quot;, rrr);</a>
<a name="ln404">           }</a>
<a name="ln405">      if (cr &amp;&amp; cr-&gt;isChord()) {</a>
<a name="ln406">	      if (toChord(cr)-&gt;notes().size() == 0) {</a>
<a name="ln407">                  segment-&gt;remove(cr);</a>
<a name="ln408">                  delete cr;</a>
<a name="ln409">			cr = 0;</a>
<a name="ln410">		      }</a>
<a name="ln411">            else if (slide &gt; 0)</a>
<a name="ln412">                  createSlide(slide, cr, staffIdx);</a>
<a name="ln413">	      }</a>
<a name="ln414">      restsForEmptyBeats(segment, measure, cr, l, track, tick);</a>
<a name="ln415">      return cr ? cr-&gt;actualTicks() : measure-&gt;ticks();</a>
<a name="ln416">      }</a>
<a name="ln417"> </a>
<a name="ln418">//---------------------------------------------------------</a>
<a name="ln419">//   readMeasure</a>
<a name="ln420">//---------------------------------------------------------</a>
<a name="ln421"> </a>
<a name="ln422">void GuitarPro5::readMeasure(Measure* measure, int staffIdx, Tuplet** tuplets, bool mixChange)</a>
<a name="ln423">      {</a>
<a name="ln424">      for (int voice = 0; voice &lt; 2; ++voice) {</a>
<a name="ln425">            Fraction measureLen = { 0,1 };</a>
<a name="ln426">            Fraction tick       = measure-&gt;tick();</a>
<a name="ln427">            int beats           = readInt();</a>
<a name="ln428">            if (beats &gt; 100)</a>
<a name="ln429">                  return;</a>
<a name="ln430">            for (int beat = 0; beat &lt; beats; ++beat) {</a>
<a name="ln431">                  Fraction ticks = readBeat(tick, voice, measure, staffIdx, tuplets, mixChange);</a>
<a name="ln432">			++_beat_counter;</a>
<a name="ln433">                  tick += ticks;</a>
<a name="ln434">                  measureLen += ticks;</a>
<a name="ln435">                  }</a>
<a name="ln436">            if (measureLen &lt; measure-&gt;ticks()) {</a>
<a name="ln437">                  score-&gt;setRest(tick, staffIdx * VOICES + voice, measure-&gt;ticks() - measureLen, false, nullptr, false);</a>
<a name="ln438">                  }</a>
<a name="ln439">            }</a>
<a name="ln440">      }</a>
<a name="ln441"> </a>
<a name="ln442">//---------------------------------------------------------</a>
<a name="ln443">//   readMixChange</a>
<a name="ln444">//---------------------------------------------------------</a>
<a name="ln445"> </a>
<a name="ln446">bool GuitarPro5::readMixChange(Measure* measure)</a>
<a name="ln447">      {</a>
<a name="ln448">      /*char patch   =*/ readChar();</a>
<a name="ln449">      skip(16);</a>
<a name="ln450">      signed char volume  = readChar();</a>
<a name="ln451">      signed char pan     = readChar();</a>
<a name="ln452">      signed char chorus  = readChar();</a>
<a name="ln453">      signed char reverb  = readChar();</a>
<a name="ln454">      signed char phase   = readChar();</a>
<a name="ln455">      signed char tremolo = readChar();</a>
<a name="ln456">      readDelphiString();                 // tempo name</a>
<a name="ln457"> </a>
<a name="ln458">      int temp = readInt();</a>
<a name="ln459">      bool editedTempo = false;</a>
<a name="ln460">      if (volume &gt;= 0)</a>
<a name="ln461">            readChar();</a>
<a name="ln462">      if (pan &gt;= 0)</a>
<a name="ln463">            readChar();</a>
<a name="ln464">      if (chorus &gt;= 0)</a>
<a name="ln465">            readChar();</a>
<a name="ln466">      if (reverb &gt;= 0)</a>
<a name="ln467">            readChar();</a>
<a name="ln468">      //qDebug(&quot;read reverb: %d&quot;, reverb);</a>
<a name="ln469">      if (phase &gt;= 0)</a>
<a name="ln470">            readChar();</a>
<a name="ln471">      if (tremolo &gt;= 0)</a>
<a name="ln472">            readChar();</a>
<a name="ln473">      if (temp &gt;= 0) {</a>
<a name="ln474">            if (last_segment) {</a>
<a name="ln475">                  score-&gt;setTempo(last_segment-&gt;tick(), double(temp) / 60.0);</a>
<a name="ln476">			last_segment = nullptr;</a>
<a name="ln477">		      }</a>
<a name="ln478">            if (temp != previousTempo) {</a>
<a name="ln479">                  previousTempo = temp;</a>
<a name="ln480">                  setTempo(temp, measure);</a>
<a name="ln481">                  editedTempo = true;</a>
<a name="ln482">                  }</a>
<a name="ln483">            readChar();</a>
<a name="ln484">            if (version &gt; 500)</a>
<a name="ln485">                 readChar();</a>
<a name="ln486">            }</a>
<a name="ln487">      readChar();</a>
<a name="ln488">      readChar();</a>
<a name="ln489">      if (version &gt; 500) {</a>
<a name="ln490">            readDelphiString();</a>
<a name="ln491">            readDelphiString();</a>
<a name="ln492">            }</a>
<a name="ln493">      return editedTempo;</a>
<a name="ln494">      }</a>
<a name="ln495"> </a>
<a name="ln496">//---------------------------------------------------------</a>
<a name="ln497">//   readTracks</a>
<a name="ln498">//---------------------------------------------------------</a>
<a name="ln499"> </a>
<a name="ln500">bool GuitarPro5::readTracks()</a>
<a name="ln501">      {</a>
<a name="ln502">      for (int i = 0; i &lt; staves; ++i) {</a>
<a name="ln503">            int tuning[GP_MAX_STRING_NUMBER];</a>
<a name="ln504">            Staff* staff = score-&gt;staff(i);</a>
<a name="ln505">            Part* part = staff-&gt;part();</a>
<a name="ln506"> </a>
<a name="ln507">            uchar c = readUChar();   // simulations bitmask</a>
<a name="ln508">            if (c &amp; 0x2) {           // 12 stringed guitar</a>
<a name="ln509">                  }</a>
<a name="ln510">            if (c &amp; 0x4) {           // banjo track</a>
<a name="ln511">                  }</a>
<a name="ln512">            if (i == 0 || version == 500)</a>
<a name="ln513">                  skip(1);</a>
<a name="ln514">            QString name = readPascalString(40);</a>
<a name="ln515"> </a>
<a name="ln516">            int strings  = readInt();</a>
<a name="ln517">            if (strings &lt;= 0 || strings &gt; GP_MAX_STRING_NUMBER)</a>
<a name="ln518">                return false;</a>
<a name="ln519">            for (int j = 0; j &lt; strings; ++j) {</a>
<a name="ln520">                  tuning[j] = readInt();</a>
<a name="ln521">                  }</a>
<a name="ln522">            for (int j = strings; j &lt; GP_MAX_STRING_NUMBER; ++j)</a>
<a name="ln523">                  readInt();</a>
<a name="ln524">            int midiPort     = readInt() -1;</a>
<a name="ln525">            int midiChannel  = readInt() - 1;</a>
<a name="ln526">            /*int midiChannel2 =*/ readInt();   // -1</a>
<a name="ln527"> </a>
<a name="ln528">            int frets        = readInt();</a>
<a name="ln529">            int capo         = readInt();</a>
<a name="ln530">            /*int color        =*/ readInt();</a>
<a name="ln531"> </a>
<a name="ln532">            skip(version &gt; 500 ? 49 : 44);</a>
<a name="ln533">            if (version &gt; 500) {</a>
<a name="ln534">                  //  british stack clean / amp tone</a>
<a name="ln535">                  readDelphiString();</a>
<a name="ln536">                  readDelphiString();</a>
<a name="ln537">                  }</a>
<a name="ln538">			std::vector&lt;int&gt; tuning2(strings);</a>
<a name="ln539">            //int tuning2[strings];</a>
<a name="ln540">            for (int k = 0; k &lt; strings; ++k)</a>
<a name="ln541">                  tuning2[strings-k-1] = tuning[k];</a>
<a name="ln542">            StringData stringData(frets, strings, &amp;tuning2[0]);</a>
<a name="ln543">			createTuningString(strings, &amp;tuning2[0]);</a>
<a name="ln544">            Instrument* instr = part-&gt;instrument();</a>
<a name="ln545">            instr-&gt;setStringData(stringData);</a>
<a name="ln546">            instr-&gt;setSingleNoteDynamics(false);</a>
<a name="ln547">            part-&gt;setPartName(name);</a>
<a name="ln548">            part-&gt;setPlainLongName(name);</a>
<a name="ln549"> </a>
<a name="ln550">            //</a>
<a name="ln551">            // determine clef</a>
<a name="ln552">            //</a>
<a name="ln553">            int patch = channelDefaults[midiChannel].patch;</a>
<a name="ln554">            ClefType clefId = ClefType::G;</a>
<a name="ln555">            if (midiChannel == GP_DEFAULT_PERCUSSION_CHANNEL) {</a>
<a name="ln556">                  clefId = ClefType::PERC;</a>
<a name="ln557">                  // instr-&gt;setUseDrumset(DrumsetKind::GUITAR_PRO);</a>
<a name="ln558">                  instr-&gt;setDrumset(gpDrumset);</a>
<a name="ln559">                  staff-&gt;setStaffType(Fraction(0,1), *StaffType::preset(StaffTypes::PERC_DEFAULT));</a>
<a name="ln560">                  }</a>
<a name="ln561">            else</a>
<a name="ln562">                  clefId = defaultClef(patch);</a>
<a name="ln563">            Measure* measure = score-&gt;firstMeasure();</a>
<a name="ln564">            Clef* clef = new Clef(score);</a>
<a name="ln565">            clef-&gt;setClefType(clefId);</a>
<a name="ln566">            clef-&gt;setTrack(i * VOICES);</a>
<a name="ln567">            Segment* segment = measure-&gt;getSegment(SegmentType::HeaderClef, Fraction(0,1));</a>
<a name="ln568">            segment-&gt;add(clef);</a>
<a name="ln569"> </a>
<a name="ln570">            if (capo &gt; 0) {</a>
<a name="ln571">                  Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln572">                  StaffText* st = new StaffText(score);</a>
<a name="ln573">                  st-&gt;setPlainText(QString(&quot;Capo. fret &quot;) + QString::number(capo));</a>
<a name="ln574">                  st-&gt;setTrack(i * VOICES);</a>
<a name="ln575">                  s-&gt;add(st);</a>
<a name="ln576">                  }</a>
<a name="ln577"> </a>
<a name="ln578">            Channel* ch = instr-&gt;channel(0);</a>
<a name="ln579">            if (midiChannel == GP_DEFAULT_PERCUSSION_CHANNEL) {</a>
<a name="ln580">                  ch-&gt;setProgram(0);</a>
<a name="ln581">                  ch-&gt;setBank(128);</a>
<a name="ln582">                  }</a>
<a name="ln583">            else {</a>
<a name="ln584">                  ch-&gt;setProgram(patch);</a>
<a name="ln585">                  ch-&gt;setBank(0);</a>
<a name="ln586">                  }</a>
<a name="ln587">            ch-&gt;setVolume(channelDefaults[midiChannel].volume);</a>
<a name="ln588">            ch-&gt;setPan(channelDefaults[midiChannel].pan);</a>
<a name="ln589">            ch-&gt;setChorus(channelDefaults[midiChannel].chorus);</a>
<a name="ln590">            ch-&gt;setReverb(channelDefaults[midiChannel].reverb);</a>
<a name="ln591">            staff-&gt;part()-&gt;setMidiChannel(midiChannel, midiPort);</a>
<a name="ln592"> </a>
<a name="ln593">            //qDebug(&quot;default2: %d&quot;, channelDefaults[i].reverb);</a>
<a name="ln594">            // missing: phase, tremolo</a>
<a name="ln595">            }</a>
<a name="ln596">      skip(version == 500 ? 2 : 1);</a>
<a name="ln597"> </a>
<a name="ln598">      return true;</a>
<a name="ln599">      }</a>
<a name="ln600"> </a>
<a name="ln601">//---------------------------------------------------------</a>
<a name="ln602">//   readMeasures</a>
<a name="ln603">//---------------------------------------------------------</a>
<a name="ln604"> </a>
<a name="ln605">void GuitarPro5::readMeasures(int /*startingTempo*/)</a>
<a name="ln606">      {</a>
<a name="ln607">      Measure* measure = score-&gt;firstMeasure();</a>
<a name="ln608">      bool mixChange = false;</a>
<a name="ln609">      for (int bar = 0; bar &lt; measures; ++bar, measure = measure-&gt;nextMeasure()) {</a>
<a name="ln610">            const GpBar&amp; gpbar = bars[bar];</a>
<a name="ln611"> </a>
<a name="ln612">            if (!gpbar.marker.isEmpty()) {</a>
<a name="ln613">                  RehearsalMark* s = new RehearsalMark(score);</a>
<a name="ln614">                  s-&gt;setPlainText(gpbar.marker.trimmed());</a>
<a name="ln615">                  s-&gt;setTrack(0);</a>
<a name="ln616">                  Segment* segment = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln617">                  segment-&gt;add(s);</a>
<a name="ln618">                  }</a>
<a name="ln619"> </a>
<a name="ln620">			std::vector&lt;Tuplet*&gt; tuplets(staves * 2);</a>
<a name="ln621">            //Tuplet* tuplets[staves * 2];     // two voices</a>
<a name="ln622">            for (int track = 0; track &lt; staves*2; ++track)</a>
<a name="ln623">                  tuplets[track] = 0;</a>
<a name="ln624"> </a>
<a name="ln625">            for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln626">                  _beat_counter = 0;</a>
<a name="ln627">                  readMeasure(measure, staffIdx, &amp;tuplets[0], mixChange);</a>
<a name="ln628">                  if (!(((bar == (measures-1)) &amp;&amp; (staffIdx == (staves-1))))) {</a>
<a name="ln629">                        /*int a = */  readChar();</a>
<a name="ln630">                        // qDebug(&quot;    ======skip %02x&quot;, a);</a>
<a name="ln631">                        }</a>
<a name="ln632">                  }</a>
<a name="ln633">            if (bar == 1 &amp;&amp; !mixChange)</a>
<a name="ln634">                  setTempo(tempo, score-&gt;firstMeasure());</a>
<a name="ln635">            }</a>
<a name="ln636"> </a>
<a name="ln637">      if (gpLyrics.segments.size()) {</a>
<a name="ln638">            auto size = std::min(int(gpLyrics.segments.size()), int(gpLyrics.lyrics.size()));</a>
<a name="ln639">		for (int i = 0; i &lt; size; ++i) {</a>
<a name="ln640">                  std::string str = gpLyrics.lyrics[i].toUtf8().constData();</a>
<a name="ln641">			auto seg = gpLyrics.segments[i];</a>
<a name="ln642">			auto mes = seg-&gt;measure();</a>
<a name="ln643">			while (str.size() &amp;&amp; seg &amp;&amp; seg-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln644">                        auto cr = seg-&gt;cr(gpLyrics.lyricTrack);</a>
<a name="ln645">				if (cr) {</a>
<a name="ln646">                              if (str[0] != '-') {</a>
<a name="ln647">                                    auto lyr = new Lyrics(score);</a>
<a name="ln648"> </a>
<a name="ln649">						std::string text;</a>
<a name="ln650">						auto pos = str.find('-');</a>
<a name="ln651">						auto pos2 = str.find('\n');</a>
<a name="ln652">						if (pos2 &lt; pos)</a>
<a name="ln653">                                          pos = pos2;</a>
<a name="ln654">					      if (pos != std::string::npos) {</a>
<a name="ln655">                                          const char* c = &amp;str.c_str()[pos + 1];</a>
<a name="ln656">							if (*c == 0) {</a>
<a name="ln657">                                                pos = std::string::npos;</a>
<a name="ln658">								text = str;</a>
<a name="ln659">                                                }</a>
<a name="ln660">                                          else {</a>
<a name="ln661">                                                text = str.substr(0, pos);</a>
<a name="ln662">                                                str = str.substr(pos + 1);</a>
<a name="ln663">                                                }</a>
<a name="ln664">                                          }</a>
<a name="ln665">                                    else</a>
<a name="ln666">                                          text = str;</a>
<a name="ln667">                                    if (pos == std::string::npos)</a>
<a name="ln668">                                          str.resize(0);</a>
<a name="ln669">                                    lyr-&gt;setPlainText(QString::fromUtf8(text.data(), int(text.size())));</a>
<a name="ln670">                                    cr-&gt;add(lyr);</a>
<a name="ln671">                                    }</a>
<a name="ln672">                              else {</a>
<a name="ln673">                                    str = str.substr(1);</a>
<a name="ln674">                                    }</a>
<a name="ln675">                              }</a>
<a name="ln676">                        seg = seg-&gt;next();</a>
<a name="ln677">                        if (!seg) {</a>
<a name="ln678">                              mes = mes-&gt;nextMeasure();</a>
<a name="ln679">                              if (!mes)</a>
<a name="ln680">                                    break;</a>
<a name="ln681">                              seg = mes-&gt;first();</a>
<a name="ln682">                              }</a>
<a name="ln683">                        }</a>
<a name="ln684">                  }</a>
<a name="ln685">            }</a>
<a name="ln686">      else {</a>
<a name="ln687">            int counter = 0;</a>
<a name="ln688">//            int index = 0;</a>
<a name="ln689">//TODO-ws ???		gpLyrics.lyricTrack -= 1;</a>
<a name="ln690">		auto mes = score-&gt;firstMeasure();</a>
<a name="ln691">		auto beg = mes-&gt;first();</a>
<a name="ln692"> </a>
<a name="ln693">		do {</a>
<a name="ln694">		      if (beg-&gt;isChordRestType() &amp;&amp; beg-&gt;cr(gpLyrics.lyricTrack)) {</a>
<a name="ln695">                        ChordRest* cr = beg-&gt;cr(gpLyrics.lyricTrack);</a>
<a name="ln696">				++counter;</a>
<a name="ln697">				if (!cr-&gt;isChord())</a>
<a name="ln698">                              continue;</a>
<a name="ln699">                        bool is_tied = false;</a>
<a name="ln700">				Chord* chord = toChord(cr);</a>
<a name="ln701">				for (auto n : chord-&gt;notes()) {</a>
<a name="ln702">				      if (n-&gt;tiedNotes().size() &gt; 1 &amp;&amp; n-&gt;tiedNotes()[0] != n) {</a>
<a name="ln703">                                    is_tied = true;</a>
<a name="ln704">						break;</a>
<a name="ln705">					      }</a>
<a name="ln706">                              }</a>
<a name="ln707">                        if (is_tied)</a>
<a name="ln708">                              continue;</a>
<a name="ln709">#if 0 // TODO-ws</a>
<a name="ln710">                        if (counter &gt;= gpLyrics.fromBeat) {</a>
<a name="ln711">                              if (gpLyrics.lyrics[index][0] != '-') {</a>
<a name="ln712">                                    auto lyr = new Lyrics(score);</a>
<a name="ln713"> </a>
<a name="ln714">                                    std::string text;</a>
<a name="ln715">						auto pos  = gpLyrics.lyrics[index].find('-');</a>
<a name="ln716">						auto pos2 = gpLyrics.lyrics[index].find('\n');</a>
<a name="ln717">						if (pos2 &lt; pos)</a>
<a name="ln718">                                          pos = pos2;</a>
<a name="ln719">						if (pos != std::string::npos) {</a>
<a name="ln720">                                          const char* c = &amp;gpLyrics.lyrics[index].c_str()[pos + 1];</a>
<a name="ln721">							if (*c == 0) {</a>
<a name="ln722">                                                pos = std::string::npos;</a>
<a name="ln723">								text = gpLyrics.lyrics[index];</a>
<a name="ln724">							      }</a>
<a name="ln725">                                          else {</a>
<a name="ln726">                                                text = gpLyrics.lyrics[index].substr(0, pos);</a>
<a name="ln727">								auto str = gpLyrics.lyrics[index].substr(pos + 1);</a>
<a name="ln728">								gpLyrics.lyrics[index] = str;</a>
<a name="ln729">								if (str.length())</a>
<a name="ln730">								      gpLyrics.lyrics[index][0] = str[0];</a>
<a name="ln731">							      }</a>
<a name="ln732">						      }</a>
<a name="ln733">						else</a>
<a name="ln734">                                          text = gpLyrics.lyrics[index];</a>
<a name="ln735">                                    if (pos == std::string::npos)</a>
<a name="ln736">                                          ++index;</a>
<a name="ln737">                                    lyr-&gt;setPlainText(text);</a>
<a name="ln738">						cr-&gt;add(lyr);</a>
<a name="ln739">						if (index &gt;= gpLyrics.lyrics.size())</a>
<a name="ln740">							  break;</a>
<a name="ln741">					      }</a>
<a name="ln742">                              else {</a>
<a name="ln743">                                    //TODO: Need studio new release, bug here</a>
<a name="ln744">						std::string s = &amp;gpLyrics.lyrics[index].c_str()[1];</a>
<a name="ln745">						gpLyrics.lyrics[index] = s;</a>
<a name="ln746">						if (s.length())</a>
<a name="ln747">                                          gpLyrics.lyrics[index][0] = s[0];</a>
<a name="ln748">					      }</a>
<a name="ln749">				      }</a>
<a name="ln750">#endif</a>
<a name="ln751">			      }</a>
<a name="ln752">		      } while ((beg = beg-&gt;next()) || ((mes = toMeasure(mes-&gt;next())) &amp;&amp; (beg = mes-&gt;first())));</a>
<a name="ln753">            }</a>
<a name="ln754">      }</a>
<a name="ln755"> </a>
<a name="ln756">//---------------------------------------------------------</a>
<a name="ln757">//   read</a>
<a name="ln758">//---------------------------------------------------------</a>
<a name="ln759"> </a>
<a name="ln760">bool GuitarPro5::read(QFile* fp)</a>
<a name="ln761">      {</a>
<a name="ln762">      f = fp;</a>
<a name="ln763"> </a>
<a name="ln764">      readInfo();</a>
<a name="ln765">      readLyrics();</a>
<a name="ln766">      readPageSetup();</a>
<a name="ln767"> </a>
<a name="ln768">      previousDynamic = -1;</a>
<a name="ln769">      previousTempo = -1;</a>
<a name="ln770">      //previousDynamic = new int [staves * VOICES];</a>
<a name="ln771">      // initialise the dynamics to 0</a>
<a name="ln772">      //for (int i = 0; i &lt; staves * VOICES; i++)</a>
<a name="ln773">      //      previousDynamic[i] = 0;</a>
<a name="ln774"> </a>
<a name="ln775">      tempo = readInt();</a>
<a name="ln776">      if (version &gt; 500)</a>
<a name="ln777">            skip(1);</a>
<a name="ln778"> </a>
<a name="ln779">      key    = readInt();</a>
<a name="ln780">      /* int octave =*/ readChar();    // octave</a>
<a name="ln781"> </a>
<a name="ln782">      readChannels();</a>
<a name="ln783"> </a>
<a name="ln784">      std::vector&lt;unsigned int&gt; articulations;</a>
<a name="ln785">	articulations.resize(19);</a>
<a name="ln786">	{</a>
<a name="ln787">            unsigned int r; unsigned char x;</a>
<a name="ln788">		for (int i = 0; i &lt; 19; ++i) {</a>
<a name="ln789">                  x = readUChar();</a>
<a name="ln790">			r = x;</a>
<a name="ln791">			x = readUChar();</a>
<a name="ln792">			r += x &lt;&lt; 8;</a>
<a name="ln793"> </a>
<a name="ln794">			articulations[i] = r;</a>
<a name="ln795">		      }</a>
<a name="ln796">	      }</a>
<a name="ln797"> </a>
<a name="ln798">      //skip(42);</a>
<a name="ln799">      skip(4);</a>
<a name="ln800"> </a>
<a name="ln801">      measures = readInt();</a>
<a name="ln802">      staves  = readInt();</a>
<a name="ln803"> </a>
<a name="ln804">	for (int str = 0; str &lt; 7; ++str) {</a>
<a name="ln805">	      for (int staff = 0; staff &lt; staves; ++staff)</a>
<a name="ln806">		      dead_end[{staff, str}] = true;</a>
<a name="ln807">            }</a>
<a name="ln808"> </a>
<a name="ln809">      slurs = new Slur*[staves];</a>
<a name="ln810">      for (int i = 0; i &lt; staves; ++i)</a>
<a name="ln811">            slurs[i] = 0;</a>
<a name="ln812"> </a>
<a name="ln813">      int tnumerator   = 4;</a>
<a name="ln814">      int tdenominator = 4;</a>
<a name="ln815">      for (int i = 0; i &lt; measures; ++i) {</a>
<a name="ln816">            if (i &gt; 0)</a>
<a name="ln817">                  skip(1);</a>
<a name="ln818">            GpBar bar;</a>
<a name="ln819">            uchar barBits = readUChar();</a>
<a name="ln820">            if (barBits &amp; SCORE_TIMESIG_NUMERATOR)</a>
<a name="ln821">                  tnumerator = readUChar();</a>
<a name="ln822">            if (barBits &amp; SCORE_TIMESIG_DENOMINATOR)</a>
<a name="ln823">                  tdenominator = readUChar();</a>
<a name="ln824">            if (barBits &amp; SCORE_REPEAT_START)</a>
<a name="ln825">                  bar.repeatFlags = bar.repeatFlags | Repeat::START;</a>
<a name="ln826">            if (barBits &amp; SCORE_REPEAT_END) {                // number of repeats</a>
<a name="ln827">                  bar.repeatFlags = bar.repeatFlags |Repeat::END;</a>
<a name="ln828">                  bar.repeats = readUChar();</a>
<a name="ln829">                  }</a>
<a name="ln830">            if (barBits &amp; SCORE_MARKER) {</a>
<a name="ln831">                  bar.marker = readDelphiString();     // new section?</a>
<a name="ln832">                  /*int color =*/ readInt();    // color?</a>
<a name="ln833">                  }</a>
<a name="ln834">            if (barBits &amp; SCORE_VOLTA) {                      // a volta</a>
<a name="ln835">                  uchar voltaNumber = readUChar();</a>
<a name="ln836">                  while (voltaNumber &gt; 0) {</a>
<a name="ln837">                        // voltas are represented as flags</a>
<a name="ln838">                        bar.volta.voltaType = GP_VOLTA_FLAGS;</a>
<a name="ln839">                        bar.volta.voltaInfo.append(voltaNumber &amp; 1);</a>
<a name="ln840">                        voltaNumber &gt;&gt;= 1;</a>
<a name="ln841">                        }</a>
<a name="ln842">                  }</a>
<a name="ln843">            if (barBits &amp; SCORE_KEYSIG) {</a>
<a name="ln844">                  int currentKey = readUChar();</a>
<a name="ln845">                  /* key signatures are specified as</a>
<a name="ln846">                   * 1# = 1, 2# = 2, ..., 7# = 7</a>
<a name="ln847">                   * 1b = 255, 2b = 254, ... 7b = 249 */</a>
<a name="ln848">                  bar.keysig = currentKey &lt;= 7 ? currentKey : -256+currentKey;</a>
<a name="ln849">                  readUChar();        // specified major/minor mode</a>
<a name="ln850">                  }</a>
<a name="ln851">            if (barBits &amp; SCORE_DOUBLE_BAR)</a>
<a name="ln852">                  bar.barLine = BarLineType::DOUBLE;</a>
<a name="ln853">            if (barBits &amp; 0x3) {</a>
<a name="ln854">                  skip(4);</a>
<a name="ln855">                  }</a>
<a name="ln856">            if ((barBits &amp; 0x10) == 0) {</a>
<a name="ln857">                  skip(1);</a>
<a name="ln858">			}</a>
<a name="ln859"> </a>
<a name="ln860">            readChar();             // triple feel  (none, 8, 16)</a>
<a name="ln861">            bar.timesig = Fraction(tnumerator, tdenominator);</a>
<a name="ln862">            bars.append(bar);</a>
<a name="ln863">            }</a>
<a name="ln864"> </a>
<a name="ln865">      //</a>
<a name="ln866">      // create a part for every staff</a>
<a name="ln867">      //</a>
<a name="ln868">      for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln869">            Part* part = new Part(score);</a>
<a name="ln870">            Staff* s = new Staff(score);</a>
<a name="ln871">            s-&gt;setPart(part);</a>
<a name="ln872">            part-&gt;insertStaff(s, -1);</a>
<a name="ln873">            score-&gt;staves().push_back(s);</a>
<a name="ln874">            score-&gt;appendPart(part);</a>
<a name="ln875">            }</a>
<a name="ln876"> </a>
<a name="ln877">      createMeasures();</a>
<a name="ln878">      if (!readTracks()) {</a>
<a name="ln879">            return false;</a>
<a name="ln880">            }</a>
<a name="ln881">      readMeasures(tempo);</a>
<a name="ln882">      for (auto n : slideList) {</a>
<a name="ln883">//		Note* next = nullptr;</a>
<a name="ln884">            auto segment = n-&gt;chord()-&gt;segment();</a>
<a name="ln885">		auto measure = segment-&gt;measure();</a>
<a name="ln886">		while ((segment = segment-&gt;next1(SegmentType::ChordRest)) || ((measure = measure-&gt;nextMeasure() ) &amp;&amp; (segment = measure-&gt;first()))) {</a>
<a name="ln887">                  if (segment-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln888">			      continue;</a>
<a name="ln889">                  bool br = false;</a>
<a name="ln890">			ChordRest* cr = toChordRest(segment-&gt;cr(n-&gt;track()));</a>
<a name="ln891">			if (cr &amp;&amp; cr-&gt;isChord()) {</a>
<a name="ln892">                        Chord* c = toChord(cr);</a>
<a name="ln893">			      for (auto nt : c-&gt;notes()) {</a>
<a name="ln894">				      if (nt-&gt;string() == n-&gt;string()) {</a>
<a name="ln895">                                    for (auto e : nt-&gt;el())</a>
<a name="ln896">						      if (e-&gt;isChordLine()) {</a>
<a name="ln897">                                                ChordLine* cl = toChordLine(e);</a>
<a name="ln898">								if (cl-&gt;chordLineType() == ChordLineType::PLOP || cl-&gt;chordLineType() == ChordLineType::SCOOP) {</a>
<a name="ln899">                                                      br = true;</a>
<a name="ln900">									break;</a>
<a name="ln901">								      }</a>
<a name="ln902">							      }</a>
<a name="ln903">				            if (br)</a>
<a name="ln904">                                          break;</a>
<a name="ln905">                                    Glissando* s = new Glissando(score);</a>
<a name="ln906">						s-&gt;setAnchor(Spanner::Anchor::NOTE);</a>
<a name="ln907">						s-&gt;setStartElement(n);</a>
<a name="ln908">						s-&gt;setTick(n-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln909">						s-&gt;setTrack(n-&gt;track());</a>
<a name="ln910">						s-&gt;setParent(n);</a>
<a name="ln911">						s-&gt;setGlissandoType(GlissandoType::STRAIGHT);</a>
<a name="ln912">						s-&gt;setEndElement(nt);</a>
<a name="ln913">						s-&gt;setTick2(nt-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln914">						s-&gt;setTrack2(n-&gt;track());</a>
<a name="ln915">						score-&gt;addElement(s);</a>
<a name="ln916">						br = true;</a>
<a name="ln917">						break;</a>
<a name="ln918">                                    }</a>
<a name="ln919">                              }</a>
<a name="ln920">                        }</a>
<a name="ln921">			if (br)</a>
<a name="ln922">                        break;</a>
<a name="ln923">		      }</a>
<a name="ln924">            }</a>
<a name="ln925"> </a>
<a name="ln926">	  std::map&lt;int, int&gt; counter;</a>
<a name="ln927">	  for (int i = 0; i &lt; 19; ++i) {</a>
<a name="ln928">		  if (articulations[i] != 0xFFFF) {</a>
<a name="ln929">                  Measure* measure = toMeasure(score-&gt;measure(articulations[i] - 1));</a>
<a name="ln930">			if (i &lt; 4) {</a>
<a name="ln931">                        Segment* segment = measure-&gt;getSegment(SegmentType::BarLine, measure-&gt;tick());</a>
<a name="ln932">                        Symbol* sym = new Symbol(score);</a>
<a name="ln933">				if (i == 0)</a>
<a name="ln934">                              sym-&gt;setSym(SymId::coda);</a>
<a name="ln935">                        else if (i == 1) {</a>
<a name="ln936">#if 0</a>
<a name="ln937">				      sym-&gt;setSym(SymId::coda);</a>
<a name="ln938">					Symbol* s2 = new Symbol(score);</a>
<a name="ln939">					s2-&gt;setSym(SymId::coda);</a>
<a name="ln940">					s2-&gt;setXoffset(5.5f);</a>
<a name="ln941">					auto iter = counter.find(articulations[i]);</a>
<a name="ln942">					if (iter != counter.end())</a>
<a name="ln943">					      s2-&gt;setElYOffset(-7.0f * iter-&gt;second);</a>
<a name="ln944">                              s2-&gt;setParent(measure);</a>
<a name="ln945">				      s2-&gt;setTrack(0);</a>
<a name="ln946">					segment-&gt;add(s2);</a>
<a name="ln947">#endif</a>
<a name="ln948">					sym-&gt;setSym(SymId::codaSquare);</a>
<a name="ln949">				      }</a>
<a name="ln950">				else if (i == 2)</a>
<a name="ln951">                              sym-&gt;setSym(SymId::segno);</a>
<a name="ln952">				else {</a>
<a name="ln953">#if 0</a>
<a name="ln954">					sym-&gt;setSym(SymId::segno);</a>
<a name="ln955">                              Symbol* s2 = new Symbol(score);</a>
<a name="ln956">					s2-&gt;setSym(SymId::segno);</a>
<a name="ln957">					s2-&gt;setXoffset(5.5f);</a>
<a name="ln958">					auto iter = counter.find(articulations[i]);</a>
<a name="ln959">					if (iter != counter.end())</a>
<a name="ln960">						  s2-&gt;setElYOffset(-7.0f * iter-&gt;second);</a>
<a name="ln961">					s2-&gt;setParent(measure);</a>
<a name="ln962">					s2-&gt;setTrack(0);</a>
<a name="ln963">					segment-&gt;add(s2);</a>
<a name="ln964">#endif</a>
<a name="ln965">					sym-&gt;setSym(SymId::segnoSerpent2);</a>
<a name="ln966">				      }</a>
<a name="ln967"> </a>
<a name="ln968"> </a>
<a name="ln969">                        sym-&gt;setParent(measure);</a>
<a name="ln970">				sym-&gt;setTrack(0);</a>
<a name="ln971">				segment-&gt;add(sym);</a>
<a name="ln972">				auto iter = counter.find(articulations[i]);</a>
<a name="ln973">				if (iter == counter.end())</a>
<a name="ln974">				      counter[articulations[i]] = 1;</a>
<a name="ln975">                        else {</a>
<a name="ln976">//TODO-ws		            sym-&gt;setElYOffset(-7.0f * counter[articulations[i]]);</a>
<a name="ln977">					counter[articulations[i]] += 1;</a>
<a name="ln978">				      }</a>
<a name="ln979">                        }</a>
<a name="ln980">                  else {</a>
<a name="ln981">                        Segment* s = measure-&gt;getSegment(SegmentType::KeySig, measure-&gt;tick());</a>
<a name="ln982">				StaffText* st = new StaffText(score);</a>
<a name="ln983">				static constexpr char text[][22] = {</a>
<a name="ln984">					&quot;fine&quot;, &quot;Da Capo&quot;, &quot;D.C. al Coda&quot;, &quot;D.C. al Double Coda&quot;,</a>
<a name="ln985">					&quot;D.C. al Fine&quot;, &quot;Da Segno&quot;, &quot;D.S. al Coda&quot;, &quot;D.S. al Double Coda&quot;,</a>
<a name="ln986">					&quot;D.S. al Fine&quot;, &quot;Da Segno Segno&quot;, &quot;D.S.S. al Coda&quot;, &quot;D.S.S. al Double Coda&quot;,</a>
<a name="ln987">					&quot;D.S.S. al Fine&quot;, &quot;Da Coda&quot;, &quot;Da Double Coda&quot;</a>
<a name="ln988">				      };</a>
<a name="ln989">			      st-&gt;setPlainText(text[i - 4]);</a>
<a name="ln990">				st-&gt;setParent(s);</a>
<a name="ln991">				st-&gt;setTrack(0);</a>
<a name="ln992">//TODO-ws			st-&gt;_measureEnd = true;</a>
<a name="ln993">				auto iter = counter.find(articulations[i]);</a>
<a name="ln994">				if (iter == counter.end())</a>
<a name="ln995">				      counter[articulations[i]] = 1;</a>
<a name="ln996">                        else {</a>
<a name="ln997">//TODO-ws                     st-&gt;setElYOffset(-7.0f * counter[articulations[i]]);</a>
<a name="ln998">					counter[articulations[i]] += 1;</a>
<a name="ln999">				      }</a>
<a name="ln1000">                        score-&gt;addElement(st);</a>
<a name="ln1001">			      }</a>
<a name="ln1002">		      }</a>
<a name="ln1003">	      }</a>
<a name="ln1004">      return true;</a>
<a name="ln1005">      }</a>
<a name="ln1006"> </a>
<a name="ln1007">//---------------------------------------------------------</a>
<a name="ln1008">//   readNoteEffects</a>
<a name="ln1009">//---------------------------------------------------------</a>
<a name="ln1010"> </a>
<a name="ln1011">bool GuitarPro5::readNoteEffects(Note* note)</a>
<a name="ln1012">      {</a>
<a name="ln1013">      uchar modMask1 = readUChar();</a>
<a name="ln1014">      uchar modMask2 = readUChar();</a>
<a name="ln1015">      bool slur = false;</a>
<a name="ln1016"> </a>
<a name="ln1017">      if (modMask1 &amp; EFFECT_BEND) {</a>
<a name="ln1018">            readBend(note);</a>
<a name="ln1019">            }</a>
<a name="ln1020">      if (modMask1 &amp; EFFECT_HAMMER) {</a>
<a name="ln1021">            slur = true;</a>
<a name="ln1022">#if 0</a>
<a name="ln1023">		Symbol* s = new Symbol(score);</a>
<a name="ln1024">		s-&gt;setSym(SymId::articLaissezVibrerBelow);</a>
<a name="ln1025">		s-&gt;setParent(note);</a>
<a name="ln1026">		note-&gt;add(s);</a>
<a name="ln1027">#endif</a>
<a name="ln1028">	      }</a>
<a name="ln1029">      if (modMask1 &amp; EFFECT_LET_RING)</a>
<a name="ln1030">	      addLetRing(note);</a>
<a name="ln1031">		//note-&gt;setLetRing(true);</a>
<a name="ln1032"> </a>
<a name="ln1033">      if (modMask1 &amp; EFFECT_GRACE) {</a>
<a name="ln1034">            int fret = readUChar();            // grace fret</a>
<a name="ln1035">            /*int dynamic =*/ readUChar();            // grace dynamic</a>
<a name="ln1036">            int transition = readUChar();            // grace transition</a>
<a name="ln1037">            /*int duration =*/ readUChar();            // grace duration</a>
<a name="ln1038">            int gflags = readUChar();</a>
<a name="ln1039"> </a>
<a name="ln1040">		NoteType note_type = NoteType::ACCIACCATURA;</a>
<a name="ln1041"> </a>
<a name="ln1042">            if (gflags &amp; NOTE_APPOGIATURA) //on beat</a>
<a name="ln1043">                  note_type = NoteType::APPOGGIATURA;</a>
<a name="ln1044"> </a>
<a name="ln1045">#if 0</a>
<a name="ln1046">            int grace_len = MScore::division/8;</a>
<a name="ln1047">            if (duration == 1)</a>
<a name="ln1048">                  grace_len = MScore::division/8; //32th</a>
<a name="ln1049">            else if (duration == 2)</a>
<a name="ln1050">                  grace_len = MScore::division/6; //24th</a>
<a name="ln1051">            else if (duration == 3)</a>
<a name="ln1052">                  grace_len = MScore::division/4; //16th</a>
<a name="ln1053">            Note* gn = new Note(score);</a>
<a name="ln1054"> </a>
<a name="ln1055">            if (gflags &amp; EFFECT_GHOST) {</a>
<a name="ln1056">                  gn-&gt;setHeadGroup(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1057">                  gn-&gt;setGhost(true);</a>
<a name="ln1058">                  }</a>
<a name="ln1059">            gn-&gt;setFret(fret);</a>
<a name="ln1060">            gn-&gt;setString(note-&gt;string());</a>
<a name="ln1061">#endif</a>
<a name="ln1062">            int grace_pitch = note-&gt;staff()-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;getPitch(note-&gt;string(), fret, nullptr, Fraction(0,1));</a>
<a name="ln1063">#if 0</a>
<a name="ln1064">            gn-&gt;setPitch(grace_pitch);</a>
<a name="ln1065">            gn-&gt;setTpcFromPitch();</a>
<a name="ln1066"> </a>
<a name="ln1067">            Chord* gc = new Chord(score);</a>
<a name="ln1068">            gc-&gt;setTrack(note-&gt;chord()-&gt;track());</a>
<a name="ln1069">            gc-&gt;add(gn);</a>
<a name="ln1070">            gc-&gt;setParent(note-&gt;chord());</a>
<a name="ln1071"> </a>
<a name="ln1072">            TDuration d;</a>
<a name="ln1073">            d.setVal(grace_len);</a>
<a name="ln1074">            if (grace_len == MScore::division/6)</a>
<a name="ln1075">                  d.setDots(1);</a>
<a name="ln1076">            gc-&gt;setDurationType(d);</a>
<a name="ln1077">            gc-&gt;setTicks(d.fraction());</a>
<a name="ln1078">            gc-&gt;setNoteType(note_type);</a>
<a name="ln1079">            gc-&gt;setMag(note-&gt;chord()-&gt;staff()-&gt;mag(0) * score-&gt;styleD(Sid::graceNoteMag));</a>
<a name="ln1080">            note-&gt;chord()-&gt;add(gc);</a>
<a name="ln1081">            addDynamic(gn, dynamic);</a>
<a name="ln1082">#endif</a>
<a name="ln1083">		auto gnote = score-&gt;setGraceNote(note-&gt;chord(), grace_pitch, note_type, MScore::division / 2);</a>
<a name="ln1084">		gnote-&gt;setString(note-&gt;string());</a>
<a name="ln1085">		auto sd = note-&gt;part()-&gt;instrument()-&gt;stringData();</a>
<a name="ln1086">		gnote-&gt;setFret(grace_pitch - sd-&gt;stringList().at(sd-&gt;stringList().size() - note-&gt;string() - 1).pitch);</a>
<a name="ln1087">            if (transition == 0) {</a>
<a name="ln1088">                  // no transition</a>
<a name="ln1089">                  }</a>
<a name="ln1090">            else if (transition == 1) {</a>
<a name="ln1091">			}</a>
<a name="ln1092">	      else if (transition == 3) {</a>
<a name="ln1093">		      Slur* slur1 = new Slur(score);</a>
<a name="ln1094">			slur1-&gt;setAnchor(Spanner::Anchor::CHORD);</a>
<a name="ln1095">			slur1-&gt;setStartElement(gnote-&gt;chord());</a>
<a name="ln1096">			slur1-&gt;setEndElement(note-&gt;chord());</a>
<a name="ln1097">			slur1-&gt;setParent(0);</a>
<a name="ln1098">			slur1-&gt;setTrack(note-&gt;staffIdx());</a>
<a name="ln1099">			slur1-&gt;setTrack2(note-&gt;staffIdx());</a>
<a name="ln1100">			slur1-&gt;setTick(gnote-&gt;chord()-&gt;tick());</a>
<a name="ln1101">			slur1-&gt;setTick2(note-&gt;chord()-&gt;tick());</a>
<a name="ln1102">//TODO-ws		note-&gt;chord()-&gt;has_slur = true;</a>
<a name="ln1103">			score-&gt;addElement(slur1);</a>
<a name="ln1104">                  //TODO: Add a 'slide' guitar effect when implemented</a>
<a name="ln1105">			//note-&gt;setSlideNote(gn);</a>
<a name="ln1106">                  }</a>
<a name="ln1107">#if 0</a>
<a name="ln1108">            else if (transition == 2 &amp;&amp; note-&gt;fret()&gt;=0 &amp;&amp; note-&gt;fret()&lt;=255 &amp;&amp; note-&gt;fret()!=gn-&gt;fret()) {</a>
<a name="ln1109">                  QList&lt;PitchValue&gt; points;</a>
<a name="ln1110">                  points.append(PitchValue(0,0, false));</a>
<a name="ln1111">                  points.append(PitchValue(60,(note-&gt;fret()-gn-&gt;fret())*100, false));</a>
<a name="ln1112"> </a>
<a name="ln1113">                  Bend* b = new Bend(note-&gt;score());</a>
<a name="ln1114">                  b-&gt;setPoints(points);</a>
<a name="ln1115">                  b-&gt;setTrack(gn-&gt;track());</a>
<a name="ln1116">                  gn-&gt;add(b);</a>
<a name="ln1117">                  }</a>
<a name="ln1118">             else if (transition == 3) {</a>
<a name="ln1119">                   // TODO:</a>
<a name="ln1120">                   //     major: replace with a 'hammer-on' guitar effect when implemented</a>
<a name="ln1121">                   //     minor: make slurs for parts</a>
<a name="ln1122"> </a>
<a name="ln1123">                   ChordRest* cr1 = toChord(gc);</a>
<a name="ln1124">                   ChordRest* cr2 = toChord(note-&gt;chord());</a>
<a name="ln1125"> </a>
<a name="ln1126">                   Slur* slur = new Slur(score);</a>
<a name="ln1127">                   slur-&gt;setAnchor(Spanner::Anchor::CHORD);</a>
<a name="ln1128">                   slur-&gt;setStartElement(cr1);</a>
<a name="ln1129">                   slur-&gt;setEndElement(cr2);</a>
<a name="ln1130">                   slur-&gt;setTick(cr1-&gt;tick());</a>
<a name="ln1131">                   slur-&gt;setTick2(cr2-&gt;tick());</a>
<a name="ln1132">                   slur-&gt;setTrack(cr1-&gt;track());</a>
<a name="ln1133">                   slur-&gt;setTrack2(cr2-&gt;track());</a>
<a name="ln1134">                   // this case specifies only two-note slurs, don't set a parent</a>
<a name="ln1135">                   score-&gt;undoAddElement(slur);</a>
<a name="ln1136">                   }</a>
<a name="ln1137">#endif</a>
<a name="ln1138">            }</a>
<a name="ln1139">      if (modMask2 &amp; EFFECT_STACATTO) {</a>
<a name="ln1140">            Chord* chord = note-&gt;chord();</a>
<a name="ln1141">            Articulation* a = new Articulation(chord-&gt;score());</a>
<a name="ln1142">            a-&gt;setSymId(SymId::articStaccatoAbove);</a>
<a name="ln1143">		bool add = true;</a>
<a name="ln1144">		for (auto a1 : chord-&gt;articulations()) {</a>
<a name="ln1145">		      if (a1-&gt;symId() == SymId::articStaccatoAbove) {</a>
<a name="ln1146">			      add = false;</a>
<a name="ln1147">				break;</a>
<a name="ln1148">				}</a>
<a name="ln1149">                  }</a>
<a name="ln1150">            if (add)</a>
<a name="ln1151">                  chord-&gt;add(a);</a>
<a name="ln1152">            }</a>
<a name="ln1153">      if (modMask2 &amp; EFFECT_PALM_MUTE)</a>
<a name="ln1154">	      addPalmMute(note);</a>
<a name="ln1155">		//note-&gt;setPalmMute(true);</a>
<a name="ln1156"> </a>
<a name="ln1157">      if (modMask2 &amp; EFFECT_TREMOLO) {    // tremolo picking length</a>
<a name="ln1158">            int tremoloDivision = readUChar();</a>
<a name="ln1159">            Chord* chord = note-&gt;chord();</a>
<a name="ln1160">            Tremolo* t = new Tremolo(score);</a>
<a name="ln1161">            if (tremoloDivision == 1) {</a>
<a name="ln1162">                  t-&gt;setTremoloType(TremoloType::R8);</a>
<a name="ln1163">                  chord-&gt;add(t);</a>
<a name="ln1164">                  }</a>
<a name="ln1165">            else if (tremoloDivision == 2) {</a>
<a name="ln1166">                  t-&gt;setTremoloType(TremoloType::R16);</a>
<a name="ln1167">                  chord-&gt;add(t);</a>
<a name="ln1168">                  }</a>
<a name="ln1169">            else if (tremoloDivision == 3) {</a>
<a name="ln1170">                  t-&gt;setTremoloType(TremoloType::R32);</a>
<a name="ln1171">                  chord-&gt;add(t);</a>
<a name="ln1172">                  }</a>
<a name="ln1173">            else</a>
<a name="ln1174">                  qDebug(&quot;Unknown tremolo value&quot;);</a>
<a name="ln1175">            }</a>
<a name="ln1176">//      bool skip = false;</a>
<a name="ln1177">      if (modMask2 &amp; EFFECT_SLIDE) {</a>
<a name="ln1178">            int slideKind = readUChar();</a>
<a name="ln1179">		if (slideKind &amp; SLIDE_OUT_DOWN) {</a>
<a name="ln1180">		      slideKind &amp;= ~SLIDE_OUT_DOWN;</a>
<a name="ln1181">			ChordLine* cl = new ChordLine(score);</a>
<a name="ln1182">			cl-&gt;setChordLineType(ChordLineType::FALL);</a>
<a name="ln1183">			cl-&gt;setStraight(true);</a>
<a name="ln1184">			note-&gt;add(cl);</a>
<a name="ln1185">//			skip = true;</a>
<a name="ln1186">			}</a>
<a name="ln1187">	      // slide out upwards (doit)</a>
<a name="ln1188">		if (slideKind &amp; SLIDE_OUT_UP) {</a>
<a name="ln1189">		      slideKind &amp;= ~SLIDE_OUT_UP;</a>
<a name="ln1190">			ChordLine* cl = new ChordLine(score);</a>
<a name="ln1191">			cl-&gt;setChordLineType(ChordLineType::DOIT);</a>
<a name="ln1192">			cl-&gt;setStraight(true);</a>
<a name="ln1193">			note-&gt;add(cl);</a>
<a name="ln1194">//			skip = true;</a>
<a name="ln1195">			}</a>
<a name="ln1196">            // slide in from below (plop)</a>
<a name="ln1197">		if (slideKind &amp; SLIDE_IN_BELOW) {</a>
<a name="ln1198">		      slideKind &amp;= ~SLIDE_IN_BELOW;</a>
<a name="ln1199">			ChordLine* cl = new ChordLine(score);</a>
<a name="ln1200">			cl-&gt;setChordLineType(ChordLineType::PLOP);</a>
<a name="ln1201">			cl-&gt;setStraight(true);</a>
<a name="ln1202">			note-&gt;add(cl);</a>
<a name="ln1203">//			skip = true;</a>
<a name="ln1204">			}</a>
<a name="ln1205">	      // slide in from above (scoop)</a>
<a name="ln1206">		if (slideKind &amp; SLIDE_IN_ABOVE) {</a>
<a name="ln1207">		      slideKind &amp;= ~SLIDE_IN_ABOVE;</a>
<a name="ln1208">			ChordLine* cl = new ChordLine(score);</a>
<a name="ln1209">			cl-&gt;setChordLineType(ChordLineType::SCOOP);</a>
<a name="ln1210">			cl-&gt;setStraight(true);</a>
<a name="ln1211">			note-&gt;add(cl);</a>
<a name="ln1212">//			skip = true;</a>
<a name="ln1213">			}</a>
<a name="ln1214"> </a>
<a name="ln1215">	      if (false &amp;&amp; !slideList.empty() &amp;&amp; slideList.back()-&gt;chord()-&gt;segment() != note-&gt;chord()-&gt;segment()) {</a>
<a name="ln1216">                  Note* start = slideList.front();</a>
<a name="ln1217">			slideList.pop_front();</a>
<a name="ln1218">			bool skip = false;</a>
<a name="ln1219">			for (auto e : start-&gt;el()) {</a>
<a name="ln1220">			      if (e-&gt;isChordLine())</a>
<a name="ln1221">                              skip = true;</a>
<a name="ln1222">                        }</a>
<a name="ln1223">                  if (!skip) {</a>
<a name="ln1224">			      Glissando* s = new Glissando(score);</a>
<a name="ln1225">				s-&gt;setAnchor(Spanner::Anchor::NOTE);</a>
<a name="ln1226">				s-&gt;setStartElement(start);</a>
<a name="ln1227">				s-&gt;setTick(start-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln1228">				s-&gt;setTrack(start-&gt;staffIdx());</a>
<a name="ln1229">				s-&gt;setParent(start);</a>
<a name="ln1230">				s-&gt;setGlissandoType(GlissandoType::STRAIGHT);</a>
<a name="ln1231">				s-&gt;setEndElement(note);</a>
<a name="ln1232">				s-&gt;setTick2(note-&gt;chord()-&gt;segment()-&gt;tick());</a>
<a name="ln1233">				s-&gt;setTrack2(note-&gt;staffIdx());</a>
<a name="ln1234">				score-&gt;addElement(s);</a>
<a name="ln1235">				}</a>
<a name="ln1236">			}</a>
<a name="ln1237">            if (slideKind &amp; LEGATO_SLIDE) {</a>
<a name="ln1238">                  slideKind &amp;= ~LEGATO_SLIDE;</a>
<a name="ln1239">			slideList.push_back(nullptr);</a>
<a name="ln1240">			createSlur(true, note-&gt;staffIdx(), note-&gt;chord());</a>
<a name="ln1241">			}</a>
<a name="ln1242">	      if (slideKind &amp; SHIFT_SLIDE) {</a>
<a name="ln1243">                  slideKind &amp;= ~SHIFT_SLIDE;</a>
<a name="ln1244">			slideList.push_back(note);</a>
<a name="ln1245">			}</a>
<a name="ln1246">#if 0</a>
<a name="ln1247">            if (slideKind)</a>
<a name="ln1248">		      int k = 1;</a>
<a name="ln1249">            if (slideKind &gt; 4)</a>
<a name="ln1250">                  int k = 1;</a>
<a name="ln1251">            // if slide &gt;= 4 then we are not dealing with legato slide nor shift slide</a>
<a name="ln1252">            if (slideKind &gt;= 4)</a>
<a name="ln1253">                  slide = slideKind;</a>
<a name="ln1254">            else</a>
<a name="ln1255">                  slides[note-&gt;chord()-&gt;track()] = slideKind;</a>
<a name="ln1256">#endif</a>
<a name="ln1257">            }</a>
<a name="ln1258"> </a>
<a name="ln1259">      if (modMask2 &amp; EFFECT_ARTIFICIAL_HARMONIC) {</a>
<a name="ln1260">            int type = readArtificialHarmonic();</a>
<a name="ln1261">		if (type == 2) {</a>
<a name="ln1262">                  auto harmNote = readUChar();</a>
<a name="ln1263">			/*auto sharp =*/ readChar();</a>
<a name="ln1264">			auto octave = readUChar();</a>
<a name="ln1265"> </a>
<a name="ln1266">			auto harmonicNote = new Note(score);</a>
<a name="ln1267">//TODO-ws		harmonicNote-&gt;setHarmonic(true);</a>
<a name="ln1268">			note-&gt;chord()-&gt;add(harmonicNote);</a>
<a name="ln1269">			auto staff = note-&gt;staff();</a>
<a name="ln1270">//			int string = staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;strings() - 1 - note-&gt;string();</a>
<a name="ln1271">			int fret = note-&gt;fret();</a>
<a name="ln1272">			switch (harmNote) {</a>
<a name="ln1273">                        case 0: fret += 24; break;</a>
<a name="ln1274">			      case 2: fret += 34; break;</a>
<a name="ln1275">			      case 4: fret += 38; break;</a>
<a name="ln1276">			      case 5: fret += 12; break;</a>
<a name="ln1277">			      case 7: fret += 32; break;</a>
<a name="ln1278">			      case 9: fret += 28; break;</a>
<a name="ln1279">			      default: fret += octave * 12;</a>
<a name="ln1280">			      }</a>
<a name="ln1281">		      harmonicNote-&gt;setString(note-&gt;string());</a>
<a name="ln1282">			harmonicNote-&gt;setFret(fret);</a>
<a name="ln1283">			harmonicNote-&gt;setPitch(staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;getPitch(note-&gt;string(), fret, nullptr, Fraction(0,1)));</a>
<a name="ln1284">			harmonicNote-&gt;setTpcFromPitch();</a>
<a name="ln1285">			addTextToNote(&quot;A.H.&quot;, Align::CENTER, harmonicNote);</a>
<a name="ln1286">		      }</a>
<a name="ln1287">            if (type == 1 || type == 4 || type == 5) {</a>
<a name="ln1288">                  //TextStyle textStyle;</a>
<a name="ln1289">			//textStyle.setAlign(Align::CENTER);</a>
<a name="ln1290">			//addTextToNote(&quot;N.H.&quot;, textStyle, note);</a>
<a name="ln1291">//TODO-ws		note-&gt;setHarmonic(true);</a>
<a name="ln1292">		      }</a>
<a name="ln1293">	      }</a>
<a name="ln1294"> </a>
<a name="ln1295">            if (modMask2 &amp; 0x40)</a>
<a name="ln1296">                  addVibrato(note);</a>
<a name="ln1297"> </a>
<a name="ln1298">      if (modMask2 &amp; EFFECT_TRILL) {</a>
<a name="ln1299">//TODO-ws            note-&gt;setTrillFret(readUChar());      // trill fret</a>
<a name="ln1300">            readUChar();      // trill fret</a>
<a name="ln1301"> </a>
<a name="ln1302">            int period = readUChar();      // trill length</a>
<a name="ln1303"> </a>
<a name="ln1304">            // add the trill articulation to the note</a>
<a name="ln1305">            Articulation* art = new Articulation(note-&gt;score());</a>
<a name="ln1306">            art-&gt;setSymId(SymId::ornamentTrill);</a>
<a name="ln1307">            if (!note-&gt;score()-&gt;addArticulation(note, art))</a>
<a name="ln1308">                  delete art;</a>
<a name="ln1309"> </a>
<a name="ln1310">            switch(period) {</a>
<a name="ln1311">                  case 1:           // 16</a>
<a name="ln1312">                        break;</a>
<a name="ln1313">                  case 2:           // 32</a>
<a name="ln1314">                        break;</a>
<a name="ln1315">                  case 3:           // 64</a>
<a name="ln1316">                        break;</a>
<a name="ln1317">                  default:</a>
<a name="ln1318">                        qDebug(&quot;unknown trill period %d&quot;, period);</a>
<a name="ln1319">                        break;</a>
<a name="ln1320">                  }</a>
<a name="ln1321">            }</a>
<a name="ln1322">      return slur;</a>
<a name="ln1323">      }</a>
<a name="ln1324"> </a>
<a name="ln1325">//---------------------------------------------------------</a>
<a name="ln1326">//   readNote</a>
<a name="ln1327">//---------------------------------------------------------</a>
<a name="ln1328"> </a>
<a name="ln1329">bool GuitarPro5::readNote(int string, Note* note)</a>
<a name="ln1330">      {</a>
<a name="ln1331">      uchar noteBits = readUChar();</a>
<a name="ln1332">      //</a>
<a name="ln1333">      // noteBits:</a>
<a name="ln1334">      //    7 - Right hand or left hand fingering;</a>
<a name="ln1335">      //    6 - Accentuated note</a>
<a name="ln1336">      //    5 - Note type (rest, empty note, normal note);</a>
<a name="ln1337">      //    4 - note dynamic;</a>
<a name="ln1338">      //    3 - Presence of effects linked to the note;</a>
<a name="ln1339">      //    2 - Ghost note;</a>
<a name="ln1340">      //    1 - Dotted note;  ?</a>
<a name="ln1341">      //    0 - Time-independent duration</a>
<a name="ln1342"> </a>
<a name="ln1343">      if (noteBits &amp; NOTE_GHOST) {</a>
<a name="ln1344">            note-&gt;setHeadGroup(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1345">            note-&gt;setGhost(true);</a>
<a name="ln1346">            }</a>
<a name="ln1347"> </a>
<a name="ln1348">      bool tieNote = false;</a>
<a name="ln1349"> </a>
<a name="ln1350">      if (noteBits &amp; NOTE_DEAD) {</a>
<a name="ln1351">            uchar noteType = readUChar();</a>
<a name="ln1352">            if (noteType == 1) {} //standard note</a>
<a name="ln1353">            else if (noteType == 2) {</a>
<a name="ln1354">                  tieNote = true;</a>
<a name="ln1355">                  }</a>
<a name="ln1356">            else if (noteType == 3) {                 // dead notes</a>
<a name="ln1357">                  note-&gt;setHeadGroup(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1358">                  note-&gt;setGhost(true);</a>
<a name="ln1359">                  }</a>
<a name="ln1360">            else</a>
<a name="ln1361">                  qDebug(&quot;unknown note type: %d&quot;, noteType);</a>
<a name="ln1362">            }</a>
<a name="ln1363"> </a>
<a name="ln1364">      if (noteBits &amp; NOTE_DYNAMIC) {          // velocity</a>
<a name="ln1365">            int d = readChar();</a>
<a name="ln1366">            if (previousDynamic != d) {</a>
<a name="ln1367">                  previousDynamic = d;</a>
<a name="ln1368">                  addDynamic(note, d);</a>
<a name="ln1369">                  }</a>
<a name="ln1370">            }</a>
<a name="ln1371"> </a>
<a name="ln1372">      int fretNumber = 0;</a>
<a name="ln1373">      if (noteBits &amp; NOTE_FRET) {</a>
<a name="ln1374">	      fretNumber = readChar();</a>
<a name="ln1375">            }</a>
<a name="ln1376"> </a>
<a name="ln1377">      if (noteBits &amp; NOTE_FINGERING) {</a>
<a name="ln1378">            int leftFinger = readUChar();</a>
<a name="ln1379">            int rightFinger = readUChar();</a>
<a name="ln1380">            Fingering* fi = new Fingering(score);</a>
<a name="ln1381">            QString finger;</a>
<a name="ln1382">            // if there is a valid left hand fingering</a>
<a name="ln1383">            if (leftFinger &lt; 5) {</a>
<a name="ln1384">                  if (leftFinger == 0)</a>
<a name="ln1385">                        finger = &quot;T&quot;;</a>
<a name="ln1386">                  else if (leftFinger == 1)</a>
<a name="ln1387">                        finger = &quot;1&quot;;</a>
<a name="ln1388">                  else if (leftFinger == 2)</a>
<a name="ln1389">                        finger = &quot;2&quot;;</a>
<a name="ln1390">                  else if (leftFinger == 3)</a>
<a name="ln1391">                        finger = &quot;3&quot;;</a>
<a name="ln1392">                  else if (leftFinger == 4)</a>
<a name="ln1393">                        finger = &quot;4&quot;;</a>
<a name="ln1394">                  }</a>
<a name="ln1395">            else  {</a>
<a name="ln1396">                  if (rightFinger == 0)</a>
<a name="ln1397">                        finger = &quot;T&quot;;</a>
<a name="ln1398">                  else if (rightFinger == 1)</a>
<a name="ln1399">                        finger = &quot;I&quot;;</a>
<a name="ln1400">                  else if (rightFinger == 2)</a>
<a name="ln1401">                        finger = &quot;M&quot;;</a>
<a name="ln1402">                  else if (rightFinger == 3)</a>
<a name="ln1403">                        finger = &quot;A&quot;;</a>
<a name="ln1404">                  else if (rightFinger == 4)</a>
<a name="ln1405">                        finger = &quot;O&quot;;</a>
<a name="ln1406">                  }</a>
<a name="ln1407">            fi-&gt;setPlainText(finger);</a>
<a name="ln1408">            note-&gt;add(fi);</a>
<a name="ln1409">            fi-&gt;reset();</a>
<a name="ln1410">            }</a>
<a name="ln1411"> </a>
<a name="ln1412">      if (noteBits &amp; 0x1)     // Time independent duration</a>
<a name="ln1413">            skip(8);</a>
<a name="ln1414"> </a>
<a name="ln1415">      // check if a note is supposed to be accented, and give it the marcato type</a>
<a name="ln1416">      if (noteBits &amp; NOTE_MARCATO) {</a>
<a name="ln1417">            Articulation* art = new Articulation(note-&gt;score());</a>
<a name="ln1418">            art-&gt;setSymId(SymId::articMarcatoAbove);</a>
<a name="ln1419">            if (!note-&gt;score()-&gt;addArticulation(note, art))</a>
<a name="ln1420">                  delete art;</a>
<a name="ln1421">            }</a>
<a name="ln1422"> </a>
<a name="ln1423">      // check if a note is supposed to be accented, and give it the sforzato type</a>
<a name="ln1424">      if (noteBits &amp; NOTE_SFORZATO) {</a>
<a name="ln1425">            Articulation* art = new Articulation(note-&gt;score());</a>
<a name="ln1426">            art-&gt;setSymId(SymId::articAccentAbove);</a>
<a name="ln1427">			note-&gt;add(art);</a>
<a name="ln1428">            // if (!note-&gt;score()-&gt;addArticulation(note, art))</a>
<a name="ln1429">            //      delete art;</a>
<a name="ln1430">            }</a>
<a name="ln1431"> </a>
<a name="ln1432">      readUChar(); //skip</a>
<a name="ln1433"> </a>
<a name="ln1434">      Staff* staff = note-&gt;staff();</a>
<a name="ln1435">      if (fretNumber == 255 || fretNumber &lt; 0) {</a>
<a name="ln1436">            fretNumber = 0;</a>
<a name="ln1437">            note-&gt;setHeadGroup(NoteHead::Group::HEAD_CROSS);</a>
<a name="ln1438">            note-&gt;setGhost(true);</a>
<a name="ln1439">            }</a>
<a name="ln1440">      int pitch = staff-&gt;part()-&gt;instrument()-&gt;stringData()-&gt;getPitch(string, fretNumber, nullptr, Fraction(0,1));</a>
<a name="ln1441">      note-&gt;setFret(fretNumber);</a>
<a name="ln1442">      note-&gt;setString(string);</a>
<a name="ln1443">      note-&gt;setPitch(pitch);</a>
<a name="ln1444"> </a>
<a name="ln1445">      // This function uses string and fret number, so it should be set before this</a>
<a name="ln1446">      bool slur = false;</a>
<a name="ln1447">      if (noteBits &amp; NOTE_SLUR) {</a>
<a name="ln1448">            slur = readNoteEffects(note);</a>
<a name="ln1449">	      }</a>
<a name="ln1450"> </a>
<a name="ln1451">      if (tieNote) {</a>
<a name="ln1452">            auto staffIdx = note-&gt;staffIdx();</a>
<a name="ln1453">		if (dead_end[{staffIdx, string}]) {</a>
<a name="ln1454">		      note-&gt;setFret(-20);</a>
<a name="ln1455">			return false;</a>
<a name="ln1456">		      }</a>
<a name="ln1457">            if (slurs[staffIdx]) {</a>
<a name="ln1458">                  score-&gt;removeSpanner(slurs[staffIdx]);</a>
<a name="ln1459">			delete slurs[staffIdx];</a>
<a name="ln1460">			slurs[staffIdx] = 0;</a>
<a name="ln1461">		      }</a>
<a name="ln1462">            bool found = false;</a>
<a name="ln1463">            Chord* chord     = note-&gt;chord();</a>
<a name="ln1464">            Segment* segment = chord-&gt;segment()-&gt;prev1(SegmentType::ChordRest);</a>
<a name="ln1465">            int track        = note-&gt;track();</a>
<a name="ln1466">		std::vector&lt;ChordRest*&gt; chords;</a>
<a name="ln1467">		Note* true_note = nullptr;</a>
<a name="ln1468">            while (segment) {</a>
<a name="ln1469">                  Element* e = segment-&gt;element(track);</a>
<a name="ln1470">                  if (e) {</a>
<a name="ln1471">                        if (e-&gt;isChord()) {</a>
<a name="ln1472">                              Chord* chord2 = toChord(e);</a>
<a name="ln1473">                              foreach (Note* note2, chord2-&gt;notes()) {</a>
<a name="ln1474">                                    if (note2-&gt;string() == string) {</a>
<a name="ln1475">					            if (chords.empty()) {</a>
<a name="ln1476">                                                Tie* tie = new Tie(score);</a>
<a name="ln1477">	      						tie-&gt;setEndNote(note);</a>
<a name="ln1478">		      					note2-&gt;add(tie);</a>
<a name="ln1479">			      				}</a>
<a name="ln1480">                                          note-&gt;setFret(note2-&gt;fret());</a>
<a name="ln1481">                                          note-&gt;setPitch(note2-&gt;pitch());</a>
<a name="ln1482">						      true_note = note2;</a>
<a name="ln1483">                                          found = true;</a>
<a name="ln1484">                                          break;</a>
<a name="ln1485">                                          }</a>
<a name="ln1486">                                    }</a>
<a name="ln1487">                              }</a>
<a name="ln1488">                        if (found)</a>
<a name="ln1489">                              break;</a>
<a name="ln1490">                        else {</a>
<a name="ln1491">				      if (e)</a>
<a name="ln1492">                                    chords.push_back(toChordRest(e));</a>
<a name="ln1493">                              }</a>
<a name="ln1494">                        }</a>
<a name="ln1495">                  segment = segment-&gt;prev1(SegmentType::ChordRest);</a>
<a name="ln1496">                  }</a>
<a name="ln1497">            if (true_note &amp;&amp; chords.size()) {</a>
<a name="ln1498">                  Note* end_note = note;</a>
<a name="ln1499">			for (unsigned int i = 0; i &lt; chords.size(); ++i) {</a>
<a name="ln1500">                        Chord* chord1 = nullptr;</a>
<a name="ln1501">				auto cr = chords.at(i);</a>
<a name="ln1502">				if (cr-&gt;isChord())</a>
<a name="ln1503">                              chord1 = toChord(cr);</a>
<a name="ln1504">                        else {</a>
<a name="ln1505">				      auto rest = toRest(cr);</a>
<a name="ln1506">					auto dur = rest-&gt;ticks();</a>
<a name="ln1507">					auto dut = rest-&gt;durationType();</a>
<a name="ln1508">					auto seg = rest-&gt;segment();</a>
<a name="ln1509">					seg-&gt;remove(rest);</a>
<a name="ln1510">					auto tuplet = rest-&gt;tuplet();</a>
<a name="ln1511">					if (tuplet)</a>
<a name="ln1512">                                    tuplet-&gt;remove(rest);</a>
<a name="ln1513">					delete rest;</a>
<a name="ln1514">					chord1 = new Chord(score);</a>
<a name="ln1515">					chord1-&gt;setTrack(note-&gt;track());</a>
<a name="ln1516">					chord1-&gt;setTicks(dur);</a>
<a name="ln1517">					chord1-&gt;setDurationType(dut);</a>
<a name="ln1518">					seg-&gt;add(chord1);</a>
<a name="ln1519">					if (tuplet)</a>
<a name="ln1520">                                    tuplet-&gt;add(chord1);</a>
<a name="ln1521">					}</a>
<a name="ln1522"> </a>
<a name="ln1523">			      Note* note2 = new Note(score);</a>
<a name="ln1524">				note2-&gt;setString(true_note-&gt;string());</a>
<a name="ln1525">				note2-&gt;setFret(true_note-&gt;fret());</a>
<a name="ln1526">				note2-&gt;setPitch(true_note-&gt;pitch());</a>
<a name="ln1527">				note2-&gt;setTpcFromPitch();</a>
<a name="ln1528">				chord1-&gt;setNoteType(true_note-&gt;noteType());</a>
<a name="ln1529">				chord1-&gt;add(note2);</a>
<a name="ln1530">				Tie* tie = new Tie(score);</a>
<a name="ln1531">				tie-&gt;setEndNote(end_note);</a>
<a name="ln1532">//TODO-ws			end_note-&gt;setHarmonic(true_note-&gt;harmonic());</a>
<a name="ln1533">				end_note = note2;</a>
<a name="ln1534">				note2-&gt;add(tie);</a>
<a name="ln1535">				}</a>
<a name="ln1536">		      Tie* tie = new Tie(score);</a>
<a name="ln1537">			tie-&gt;setEndNote(end_note);</a>
<a name="ln1538">//TODO-ws		end_note-&gt;setHarmonic(true_note-&gt;harmonic());</a>
<a name="ln1539">			true_note-&gt;add(tie);</a>
<a name="ln1540">			}</a>
<a name="ln1541">            if (!found) {</a>
<a name="ln1542">		      note-&gt;setFret(-20);</a>
<a name="ln1543">			dead_end[{staffIdx, string}] = true;</a>
<a name="ln1544">			qDebug(&quot;tied note not found, pitch %d fret %d string %d&quot;, note-&gt;pitch(), note-&gt;fret(), note-&gt;string());</a>
<a name="ln1545">			return false;</a>
<a name="ln1546">			}</a>
<a name="ln1547">            }</a>
<a name="ln1548">      dead_end[{note-&gt;staffIdx(), string}] = false;</a>
<a name="ln1549">      return slur;</a>
<a name="ln1550">      }</a>
<a name="ln1551"> </a>
<a name="ln1552">//---------------------------------------------------------</a>
<a name="ln1553">//   readArtificialHarmonic</a>
<a name="ln1554">//---------------------------------------------------------</a>
<a name="ln1555"> </a>
<a name="ln1556">int GuitarPro5::readArtificialHarmonic()</a>
<a name="ln1557">      {</a>
<a name="ln1558">      int type = readChar();</a>
<a name="ln1559">      switch(type) {</a>
<a name="ln1560">            case 1:           // natural</a>
<a name="ln1561">                  break;</a>
<a name="ln1562">            case 2:           // artificial</a>
<a name="ln1563">                  //skip(3);</a>
<a name="ln1564">                  break;</a>
<a name="ln1565">            case 3:           // tapped</a>
<a name="ln1566">                  skip(1);</a>
<a name="ln1567">                  break;</a>
<a name="ln1568">            case 4:           // pinch</a>
<a name="ln1569">                  break;</a>
<a name="ln1570">            case 5:           // semi</a>
<a name="ln1571">                  break;</a>
<a name="ln1572">            }</a>
<a name="ln1573">	  return type;</a>
<a name="ln1574">      }</a>
<a name="ln1575"> </a>
<a name="ln1576">}</a>

</code></pre>
<div class="balloon" rel="382"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'lyrics' is always false.</p></div>
<div class="balloon" rel="633"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: !mixChange.</p></div>
<div class="balloon" rel="1491"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'e' is always true.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
