
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>layout.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2016 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;accidental.h&quot;</a>
<a name="ln14">#include &quot;barline.h&quot;</a>
<a name="ln15">#include &quot;beam.h&quot;</a>
<a name="ln16">#include &quot;box.h&quot;</a>
<a name="ln17">#include &quot;chord.h&quot;</a>
<a name="ln18">#include &quot;clef.h&quot;</a>
<a name="ln19">#include &quot;element.h&quot;</a>
<a name="ln20">#include &quot;fingering.h&quot;</a>
<a name="ln21">#include &quot;glissando.h&quot;</a>
<a name="ln22">#include &quot;harmony.h&quot;</a>
<a name="ln23">#include &quot;key.h&quot;</a>
<a name="ln24">#include &quot;keysig.h&quot;</a>
<a name="ln25">#include &quot;layoutbreak.h&quot;</a>
<a name="ln26">#include &quot;layout.h&quot;</a>
<a name="ln27">#include &quot;lyrics.h&quot;</a>
<a name="ln28">#include &quot;marker.h&quot;</a>
<a name="ln29">#include &quot;measure.h&quot;</a>
<a name="ln30">#include &quot;mscore.h&quot;</a>
<a name="ln31">#include &quot;notedot.h&quot;</a>
<a name="ln32">#include &quot;note.h&quot;</a>
<a name="ln33">#include &quot;ottava.h&quot;</a>
<a name="ln34">#include &quot;page.h&quot;</a>
<a name="ln35">#include &quot;part.h&quot;</a>
<a name="ln36">#include &quot;repeat.h&quot;</a>
<a name="ln37">#include &quot;score.h&quot;</a>
<a name="ln38">#include &quot;segment.h&quot;</a>
<a name="ln39">#include &quot;sig.h&quot;</a>
<a name="ln40">#include &quot;slur.h&quot;</a>
<a name="ln41">#include &quot;staff.h&quot;</a>
<a name="ln42">#include &quot;stem.h&quot;</a>
<a name="ln43">#include &quot;stemslash.h&quot;</a>
<a name="ln44">#include &quot;sticking.h&quot;</a>
<a name="ln45">#include &quot;style.h&quot;</a>
<a name="ln46">#include &quot;sym.h&quot;</a>
<a name="ln47">#include &quot;system.h&quot;</a>
<a name="ln48">#include &quot;text.h&quot;</a>
<a name="ln49">#include &quot;tie.h&quot;</a>
<a name="ln50">#include &quot;timesig.h&quot;</a>
<a name="ln51">#include &quot;tremolo.h&quot;</a>
<a name="ln52">#include &quot;tuplet.h&quot;</a>
<a name="ln53">#include &quot;undo.h&quot;</a>
<a name="ln54">#include &quot;utils.h&quot;</a>
<a name="ln55">#include &quot;volta.h&quot;</a>
<a name="ln56">#include &quot;breath.h&quot;</a>
<a name="ln57">#include &quot;tempotext.h&quot;</a>
<a name="ln58">#include &quot;systemdivider.h&quot;</a>
<a name="ln59">#include &quot;hook.h&quot;</a>
<a name="ln60">#include &quot;ambitus.h&quot;</a>
<a name="ln61">#include &quot;hairpin.h&quot;</a>
<a name="ln62">#include &quot;stafflines.h&quot;</a>
<a name="ln63">#include &quot;articulation.h&quot;</a>
<a name="ln64">#include &quot;bracket.h&quot;</a>
<a name="ln65">#include &quot;spacer.h&quot;</a>
<a name="ln66">#include &quot;fermata.h&quot;</a>
<a name="ln67">#include &quot;measurenumber.h&quot;</a>
<a name="ln68"> </a>
<a name="ln69">namespace Ms {</a>
<a name="ln70"> </a>
<a name="ln71">// #define PAGE_DEBUG</a>
<a name="ln72"> </a>
<a name="ln73">#ifdef PAGE_DEBUG</a>
<a name="ln74">#define PAGEDBG(...)  qDebug(__VA_ARGS__)</a>
<a name="ln75">#else</a>
<a name="ln76">#define PAGEDBG(...)  ;</a>
<a name="ln77">#endif</a>
<a name="ln78"> </a>
<a name="ln79">//---------------------------------------------------------</a>
<a name="ln80">//   rebuildBspTree</a>
<a name="ln81">//---------------------------------------------------------</a>
<a name="ln82"> </a>
<a name="ln83">void Score::rebuildBspTree()</a>
<a name="ln84">      {</a>
<a name="ln85">      for (Page* page : pages())</a>
<a name="ln86">            page-&gt;rebuildBspTree();</a>
<a name="ln87">      }</a>
<a name="ln88"> </a>
<a name="ln89">//---------------------------------------------------------</a>
<a name="ln90">//   layoutSegmentElements</a>
<a name="ln91">//---------------------------------------------------------</a>
<a name="ln92"> </a>
<a name="ln93">static void layoutSegmentElements(Segment* segment, int startTrack, int endTrack)</a>
<a name="ln94">      {</a>
<a name="ln95">      for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln96">            if (Element* e = segment-&gt;element(track))</a>
<a name="ln97">                  e-&gt;layout();</a>
<a name="ln98">            }</a>
<a name="ln99">      }</a>
<a name="ln100"> </a>
<a name="ln101">#if 0</a>
<a name="ln102">//---------------------------------------------------------</a>
<a name="ln103">//   vUp</a>
<a name="ln104">//    reurns true if chord should be treated as up</a>
<a name="ln105">//    for purpose of setting horizontal position</a>
<a name="ln106">//    for most chords, this is just chord-&gt;up()</a>
<a name="ln107">//    but for notes on cross-staff beams, we take care to produce more consistent results</a>
<a name="ln108">//    since the initial guess for up() may change during layout</a>
<a name="ln109">//---------------------------------------------------------</a>
<a name="ln110">static bool vUp(Chord* chord)</a>
<a name="ln111">      {</a>
<a name="ln112">      if (!chord)</a>
<a name="ln113">            return true;</a>
<a name="ln114">      else if (!chord-&gt;beam() || !chord-&gt;beam()-&gt;cross()) {</a>
<a name="ln115">            return chord-&gt;up();</a>
<a name="ln116">            }</a>
<a name="ln117">      else {</a>
<a name="ln118">            // cross-staff beam: we cannot know the actual direction of this chord until the beam layout,</a>
<a name="ln119">            // but that's too late - it won't work to lay out as if the chord is up on pass one but then down on pass two</a>
<a name="ln120">            // so just assign a logical direction based on attributes that won't change</a>
<a name="ln121">            // so chords can be laid out consistently on both passes</a>
<a name="ln122">            bool up;</a>
<a name="ln123">            if (chord-&gt;stemDirection() != Direction::AUTO)</a>
<a name="ln124">                  up = chord-&gt;stemDirection() == Direction::UP;</a>
<a name="ln125">            else if (chord-&gt;staffMove())</a>
<a name="ln126">                  up = chord-&gt;staffMove() &gt; 0;</a>
<a name="ln127">            else if (chord-&gt;track() &lt; chord-&gt;beam()-&gt;track())</a>
<a name="ln128">                  up = false;</a>
<a name="ln129">            else if (chord-&gt;track() &gt; chord-&gt;beam()-&gt;track())</a>
<a name="ln130">                  up = true;</a>
<a name="ln131">            else if (chord-&gt;measure()-&gt;hasVoices(chord-&gt;staffIdx()))</a>
<a name="ln132">                  up = !(chord-&gt;track() % 2);</a>
<a name="ln133">            else</a>
<a name="ln134">                  up = !chord-&gt;staff()-&gt;isTop();</a>
<a name="ln135">            return up;</a>
<a name="ln136">            }</a>
<a name="ln137">      }</a>
<a name="ln138">#endif</a>
<a name="ln139"> </a>
<a name="ln140">//---------------------------------------------------------</a>
<a name="ln141">//   layoutChords1</a>
<a name="ln142">//    - layout upstem and downstem chords</a>
<a name="ln143">//    - offset as necessary to avoid conflict</a>
<a name="ln144">//---------------------------------------------------------</a>
<a name="ln145"> </a>
<a name="ln146">void Score::layoutChords1(Segment* segment, int staffIdx)</a>
<a name="ln147">      {</a>
<a name="ln148">      const Staff* staff = Score::staff(staffIdx);</a>
<a name="ln149">      const int startTrack = staffIdx * VOICES;</a>
<a name="ln150">      const int endTrack   = startTrack + VOICES;</a>
<a name="ln151"> </a>
<a name="ln152">      if (staff-&gt;isTabStaff(segment-&gt;tick())) {</a>
<a name="ln153">            layoutSegmentElements(segment, startTrack, endTrack);</a>
<a name="ln154">            return;</a>
<a name="ln155">            }</a>
<a name="ln156"> </a>
<a name="ln157">      bool crossBeamFound = false;</a>
<a name="ln158">      std::vector&lt;Note*&gt; upStemNotes;</a>
<a name="ln159">      std::vector&lt;Note*&gt; downStemNotes;</a>
<a name="ln160">      int upVoices       = 0;</a>
<a name="ln161">      int downVoices     = 0;</a>
<a name="ln162">      qreal nominalWidth = noteHeadWidth() * staff-&gt;mag(segment-&gt;tick());</a>
<a name="ln163">      qreal maxUpWidth   = 0.0;</a>
<a name="ln164">      qreal maxDownWidth = 0.0;</a>
<a name="ln165">      qreal maxUpMag     = 0.0;</a>
<a name="ln166">      qreal maxDownMag   = 0.0;</a>
<a name="ln167"> </a>
<a name="ln168">      // dots and hooks can affect layout of notes as well as vice versa</a>
<a name="ln169">      int upDots         = 0;</a>
<a name="ln170">      int downDots       = 0;</a>
<a name="ln171">      bool upHooks       = false;</a>
<a name="ln172">      bool downHooks     = false;</a>
<a name="ln173"> </a>
<a name="ln174">      // also check for grace notes</a>
<a name="ln175">      bool upGrace       = false;</a>
<a name="ln176">      bool downGrace     = false;</a>
<a name="ln177"> </a>
<a name="ln178">      for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln179">            Element* e = segment-&gt;element(track);</a>
<a name="ln180">            if (e &amp;&amp; e-&gt;isChord()) {</a>
<a name="ln181">                  Chord* chord = toChord(e);</a>
<a name="ln182">                  if (chord-&gt;beam() &amp;&amp; chord-&gt;beam()-&gt;cross())</a>
<a name="ln183">                        crossBeamFound = true;</a>
<a name="ln184">                  bool hasGraceBefore = false;</a>
<a name="ln185">                  for (Chord* c : chord-&gt;graceNotes()) {</a>
<a name="ln186">                        if (c-&gt;isGraceBefore())</a>
<a name="ln187">                              hasGraceBefore = true;</a>
<a name="ln188">                        layoutChords2(c-&gt;notes(), c-&gt;up());       // layout grace note noteheads</a>
<a name="ln189">                        layoutChords3(c-&gt;notes(), staff, 0);      // layout grace note chords</a>
<a name="ln190">                        }</a>
<a name="ln191">                  if (chord-&gt;up()) {</a>
<a name="ln192">                        ++upVoices;</a>
<a name="ln193">                        upStemNotes.insert(upStemNotes.end(), chord-&gt;notes().begin(), chord-&gt;notes().end());</a>
<a name="ln194">                        upDots   = qMax(upDots, chord-&gt;dots());</a>
<a name="ln195">                        maxUpMag = qMax(maxUpMag, chord-&gt;mag());</a>
<a name="ln196">                        if (!upHooks)</a>
<a name="ln197">                              upHooks = chord-&gt;hook();</a>
<a name="ln198">                        if (hasGraceBefore)</a>
<a name="ln199">                              upGrace = true;</a>
<a name="ln200">                        }</a>
<a name="ln201">                  else {</a>
<a name="ln202">                        ++downVoices;</a>
<a name="ln203">                        downStemNotes.insert(downStemNotes.end(), chord-&gt;notes().begin(), chord-&gt;notes().end());</a>
<a name="ln204">                        downDots = qMax(downDots, chord-&gt;dots());</a>
<a name="ln205">                        maxDownMag = qMax(maxDownMag, chord-&gt;mag());</a>
<a name="ln206">                        if (!downHooks)</a>
<a name="ln207">                              downHooks = chord-&gt;hook();</a>
<a name="ln208">                        if (hasGraceBefore)</a>
<a name="ln209">                              downGrace = true;</a>
<a name="ln210">                        }</a>
<a name="ln211">                  }</a>
<a name="ln212">            }</a>
<a name="ln213"> </a>
<a name="ln214">      if (upVoices + downVoices) {</a>
<a name="ln215">            // TODO: use track as secondary sort criteria?</a>
<a name="ln216">            // otherwise there might be issues with unisons between voices</a>
<a name="ln217">            // in some corner cases</a>
<a name="ln218"> </a>
<a name="ln219">            maxUpWidth   = nominalWidth * maxUpMag;</a>
<a name="ln220">            maxDownWidth = nominalWidth * maxDownMag;</a>
<a name="ln221"> </a>
<a name="ln222">            // layout upstem noteheads</a>
<a name="ln223">            if (upVoices &gt; 1) {</a>
<a name="ln224">                  qSort(upStemNotes.begin(), upStemNotes.end(),</a>
<a name="ln225">                     [](Note* n1, const Note* n2) -&gt;bool {return n1-&gt;line() &gt; n2-&gt;line(); } );</a>
<a name="ln226">                  }</a>
<a name="ln227">            if (upVoices) {</a>
<a name="ln228">                  qreal hw = layoutChords2(upStemNotes, true);</a>
<a name="ln229">                  maxUpWidth = qMax(maxUpWidth, hw);</a>
<a name="ln230">                  }</a>
<a name="ln231"> </a>
<a name="ln232">            // layout downstem noteheads</a>
<a name="ln233">            if (downVoices &gt; 1) {</a>
<a name="ln234">                  qSort(downStemNotes.begin(), downStemNotes.end(),</a>
<a name="ln235">                     [](Note* n1, const Note* n2) -&gt;bool {return n1-&gt;line() &gt; n2-&gt;line(); } );</a>
<a name="ln236">                  }</a>
<a name="ln237">            if (downVoices) {</a>
<a name="ln238">                  qreal hw = layoutChords2(downStemNotes, false);</a>
<a name="ln239">                  maxDownWidth = qMax(maxDownWidth, hw);</a>
<a name="ln240">                  }</a>
<a name="ln241"> </a>
<a name="ln242">            qreal sp                 = staff-&gt;spatium(segment-&gt;tick());</a>
<a name="ln243">            qreal upOffset           = 0.0;      // offset to apply to upstem chords</a>
<a name="ln244">            qreal downOffset         = 0.0;      // offset to apply to downstem chords</a>
<a name="ln245">            qreal dotAdjust          = 0.0;      // additional chord offset to account for dots</a>
<a name="ln246">            qreal dotAdjustThreshold = 0.0;      // if it exceeds this amount</a>
<a name="ln247"> </a>
<a name="ln248">            // centering adjustments for whole note, breve, and small chords</a>
<a name="ln249">            qreal centerUp          = 0.0;      // offset to apply in order to center upstem chords</a>
<a name="ln250">            qreal oversizeUp        = 0.0;      // adjustment to oversized upstem chord needed if laid out to the right</a>
<a name="ln251">            qreal centerDown        = 0.0;      // offset to apply in order to center downstem chords</a>
<a name="ln252">            qreal centerAdjustUp    = 0.0;      // adjustment to upstem chord needed after centering donwstem chord</a>
<a name="ln253">            qreal centerAdjustDown  = 0.0;      // adjustment to downstem chord needed after centering upstem chord</a>
<a name="ln254"> </a>
<a name="ln255">            // only center chords if they differ from nominal by at least this amount</a>
<a name="ln256">            // this avoids unnecessary centering on differences due only to floating point roundoff</a>
<a name="ln257">            // it also allows for the possibility of disabling centering</a>
<a name="ln258">            // for notes only &quot;slightly&quot; larger than nominal, like half notes</a>
<a name="ln259">            // but this will result in them not being aligned with each other between voices</a>
<a name="ln260">            // unless you change to left alignment as described in the comments below</a>
<a name="ln261">            qreal centerThreshold   = 0.01 * sp;</a>
<a name="ln262"> </a>
<a name="ln263">            // amount by which actual width exceeds nominal, adjusted for staff mag() only</a>
<a name="ln264">            qreal headDiff = maxUpWidth - nominalWidth;</a>
<a name="ln265">            // amount by which actual width exceeds nominal, adjusted for staff &amp; chord/note mag()</a>
<a name="ln266">            qreal headDiff2 = maxUpWidth - nominalWidth * (maxUpMag / staff-&gt;mag(segment-&gt;tick()));</a>
<a name="ln267">            if (headDiff &gt; centerThreshold) {</a>
<a name="ln268">                  // larger than nominal</a>
<a name="ln269">                  centerUp = headDiff * -0.5;</a>
<a name="ln270">                  // maxUpWidth is true width, but we no longer will care about that</a>
<a name="ln271">                  // instead, we care only about portion to right of origin</a>
<a name="ln272">                  maxUpWidth += centerUp;</a>
<a name="ln273">                  // to left align rather than center, delete both of the above</a>
<a name="ln274">                  if (headDiff2 &gt; centerThreshold) {</a>
<a name="ln275">                        // if max notehead is wider than nominal with chord/note mag() applied</a>
<a name="ln276">                        // then noteheads extend to left of origin</a>
<a name="ln277">                        // because stemPosX() is based on nominal width</a>
<a name="ln278">                        // so we need to correct for that too</a>
<a name="ln279">                        centerUp += headDiff2;</a>
<a name="ln280">                        oversizeUp = headDiff2;</a>
<a name="ln281">                        }</a>
<a name="ln282">                  }</a>
<a name="ln283">            else if (-headDiff &gt; centerThreshold) {</a>
<a name="ln284">                  // smaller than nominal</a>
<a name="ln285">                  centerUp = -headDiff * 0.5;</a>
<a name="ln286">                  if (headDiff2 &gt; centerThreshold) {</a>
<a name="ln287">                        // max notehead is wider than nominal with chord/note mag() applied</a>
<a name="ln288">                        // perform same adjustment as above</a>
<a name="ln289">                        centerUp += headDiff2;</a>
<a name="ln290">                        oversizeUp = headDiff2;</a>
<a name="ln291">                        }</a>
<a name="ln292">                  centerAdjustDown = centerUp;</a>
<a name="ln293">                  }</a>
<a name="ln294"> </a>
<a name="ln295">            headDiff = maxDownWidth - nominalWidth;</a>
<a name="ln296">            if (headDiff &gt; centerThreshold) {</a>
<a name="ln297">                  // larger than nominal</a>
<a name="ln298">                  centerDown = headDiff * -0.5;</a>
<a name="ln299">                  // to left align rather than center, change the above to</a>
<a name="ln300">                  //centerAdjustUp = headDiff;</a>
<a name="ln301">                  maxDownWidth = nominalWidth - centerDown;</a>
<a name="ln302">                  }</a>
<a name="ln303">            else if (-headDiff &gt; centerThreshold) {</a>
<a name="ln304">                  // smaller than nominal</a>
<a name="ln305">                  centerDown = -headDiff * 0.5;</a>
<a name="ln306">                  centerAdjustUp = centerDown;</a>
<a name="ln307">                  }</a>
<a name="ln308"> </a>
<a name="ln309">            // handle conflict between upstem and downstem chords</a>
<a name="ln310"> </a>
<a name="ln311">            if (upVoices &amp;&amp; downVoices) {</a>
<a name="ln312">                  Note* bottomUpNote = upStemNotes.front();</a>
<a name="ln313">                  Note* topDownNote  = downStemNotes.back();</a>
<a name="ln314">                  int separation;</a>
<a name="ln315">                  // TODO: handle conflicts for cross-staff notes and notes on cross-staff beams</a>
<a name="ln316">                  // for now we simply treat these as though there is no conflict</a>
<a name="ln317">                  if (bottomUpNote-&gt;chord()-&gt;staffMove() == topDownNote-&gt;chord()-&gt;staffMove() &amp;&amp; !crossBeamFound)</a>
<a name="ln318">                        separation = topDownNote-&gt;line() - bottomUpNote-&gt;line();</a>
<a name="ln319">                  else</a>
<a name="ln320">                        separation = 2;   // no conflict</a>
<a name="ln321">                  QVector&lt;Note*&gt; overlapNotes;</a>
<a name="ln322">                  overlapNotes.reserve(8);</a>
<a name="ln323"> </a>
<a name="ln324">                  if (separation == 1) {</a>
<a name="ln325">                        // second</a>
<a name="ln326">                        downOffset = maxUpWidth;</a>
<a name="ln327">                        // align stems if present, leave extra room if not</a>
<a name="ln328">                        if (topDownNote-&gt;chord()-&gt;stem() &amp;&amp; bottomUpNote-&gt;chord()-&gt;stem())</a>
<a name="ln329">                              downOffset -= topDownNote-&gt;chord()-&gt;stem()-&gt;lineWidth();</a>
<a name="ln330">                        else</a>
<a name="ln331">                              downOffset += 0.1 * sp;</a>
<a name="ln332">                        }</a>
<a name="ln333"> </a>
<a name="ln334">                  else if (separation &lt; 1) {</a>
<a name="ln335"> </a>
<a name="ln336">                        // overlap (possibly unison)</a>
<a name="ln337"> </a>
<a name="ln338">                        // build list of overlapping notes</a>
<a name="ln339">                        for (size_t i = 0, n = upStemNotes.size(); i &lt; n; ++i) {</a>
<a name="ln340">                              if (upStemNotes[i]-&gt;line() &gt;= topDownNote-&gt;line() - 1)</a>
<a name="ln341">                                    overlapNotes.append(upStemNotes[i]);</a>
<a name="ln342">                              else</a>
<a name="ln343">                                    break;</a>
<a name="ln344">                              }</a>
<a name="ln345">                        for (size_t i = downStemNotes.size(); i &gt; 0; --i) { // loop most probably needs to be in this reverse order</a>
<a name="ln346">                              if (downStemNotes[i-1]-&gt;line() &lt;= bottomUpNote-&gt;line() + 1)</a>
<a name="ln347">                                    overlapNotes.append(downStemNotes[i-1]);</a>
<a name="ln348">                              else</a>
<a name="ln349">                                    break;</a>
<a name="ln350">                              }</a>
<a name="ln351">                        qSort(overlapNotes.begin(), overlapNotes.end(),</a>
<a name="ln352">                           [](Note* n1, const Note* n2) -&gt;bool {return n1-&gt;line() &gt; n2-&gt;line(); } );</a>
<a name="ln353"> </a>
<a name="ln354">                        // determine nature of overlap</a>
<a name="ln355">                        bool shareHeads = true;       // can all overlapping notes share heads?</a>
<a name="ln356">                        bool matchPending = false;    // looking for a unison match</a>
<a name="ln357">                        bool conflictUnison = false;  // unison found</a>
<a name="ln358">                        bool conflictSecondUpHigher = false;      // second found</a>
<a name="ln359">                        bool conflictSecondDownHigher = false;    // second found</a>
<a name="ln360">                        int lastLine = 1000;</a>
<a name="ln361">                        Note* p = overlapNotes[0];</a>
<a name="ln362">                        for (int i = 0, count = overlapNotes.size(); i &lt; count; ++i) {</a>
<a name="ln363">                              Note* n = overlapNotes[i];</a>
<a name="ln364">                              NoteHead::Type nHeadType;</a>
<a name="ln365">                              NoteHead::Type pHeadType;</a>
<a name="ln366">                              Chord* nchord = n-&gt;chord();</a>
<a name="ln367">                              Chord* pchord = p-&gt;chord();</a>
<a name="ln368">                              if (n-&gt;mirror()) {</a>
<a name="ln369">                                    if (separation &lt; 0) {</a>
<a name="ln370">                                          // don't try to share heads if there is any mirroring</a>
<a name="ln371">                                          shareHeads = false;</a>
<a name="ln372">                                          // don't worry about conflicts involving mirrored notes</a>
<a name="ln373">                                          continue;</a>
<a name="ln374">                                          }</a>
<a name="ln375">                                    }</a>
<a name="ln376">                              int line = n-&gt;line();</a>
<a name="ln377">                              int d = lastLine - line;</a>
<a name="ln378">                              switch (d) {</a>
<a name="ln379">                                    case 0:</a>
<a name="ln380">                                          // unison</a>
<a name="ln381">                                          conflictUnison = true;</a>
<a name="ln382">                                          matchPending = false;</a>
<a name="ln383">                                          nHeadType = (n-&gt;headType() == NoteHead::Type::HEAD_AUTO) ? n-&gt;chord()-&gt;durationType().headType() : n-&gt;headType();</a>
<a name="ln384">                                          pHeadType = (p-&gt;headType() == NoteHead::Type::HEAD_AUTO) ? p-&gt;chord()-&gt;durationType().headType() : p-&gt;headType();</a>
<a name="ln385">                                          // the most important rules for sharing noteheads on unisons between voices are</a>
<a name="ln386">                                          // that notes must be one same line with same tpc</a>
<a name="ln387">                                          // noteheads must be unmirrored and of same group</a>
<a name="ln388">                                          // and chords must be same size (or else sharing code won't work)</a>
<a name="ln389">                                          if (n-&gt;headGroup() != p-&gt;headGroup() || n-&gt;tpc() != p-&gt;tpc() || n-&gt;mirror() || p-&gt;mirror() || nchord-&gt;small() != pchord-&gt;small()) {</a>
<a name="ln390">                                                shareHeads = false;</a>
<a name="ln391">                                                }</a>
<a name="ln392">                                          else {</a>
<a name="ln393">                                                // noteheads are potentially shareable</a>
<a name="ln394">                                                // it is more subjective at this point</a>
<a name="ln395">                                                // current default is to require *either* of the following:</a>
<a name="ln396">                                                //    1) both chords have same number of dots, both have stems, and both noteheads are same type and are full size (automatic match)</a>
<a name="ln397">                                                // or 2) one or more of the noteheads is not of type AUTO, but is explicitly set to match the other (user-forced match)</a>
<a name="ln398">                                                // or 3) exactly one of the noteheads is invisible (user-forced match)</a>
<a name="ln399">                                                // thus user can force notes to be shared despite differing number of dots or either being stemless</a>
<a name="ln400">                                                // by setting one of the notehead types to match the other or by making one notehead invisible</a>
<a name="ln401">                                                // TODO: consider adding a style option, staff properties, or note property to control sharing</a>
<a name="ln402">                                                if ((nchord-&gt;dots() != pchord-&gt;dots() || !nchord-&gt;stem() || !pchord-&gt;stem() || nHeadType != pHeadType || n-&gt;small() || p-&gt;small()) &amp;&amp;</a>
<a name="ln403">                                                    ((n-&gt;headType() == NoteHead::Type::HEAD_AUTO &amp;&amp; p-&gt;headType() == NoteHead::Type::HEAD_AUTO) || nHeadType != pHeadType) &amp;&amp;</a>
<a name="ln404">                                                    (n-&gt;visible() == p-&gt;visible())) {</a>
<a name="ln405">                                                      shareHeads = false;</a>
<a name="ln406">                                                      }</a>
<a name="ln407">                                                }</a>
<a name="ln408">                                          break;</a>
<a name="ln409">                                    case 1:</a>
<a name="ln410">                                          // second</a>
<a name="ln411">                                          // trust that this won't be a problem for single unison</a>
<a name="ln412">                                          if (separation &lt; 0) {</a>
<a name="ln413">                                                if (n-&gt;chord()-&gt;up())</a>
<a name="ln414">                                                      conflictSecondUpHigher = true;</a>
<a name="ln415">                                                else</a>
<a name="ln416">                                                      conflictSecondDownHigher = true;</a>
<a name="ln417">                                                shareHeads = false;</a>
<a name="ln418">                                                }</a>
<a name="ln419">                                          break;</a>
<a name="ln420">                                    default:</a>
<a name="ln421">                                          // no conflict</a>
<a name="ln422">                                          if (matchPending)</a>
<a name="ln423">                                                shareHeads = false;</a>
<a name="ln424">                                          matchPending = true;</a>
<a name="ln425">                                    }</a>
<a name="ln426">                              p = n;</a>
<a name="ln427">                              lastLine = line;</a>
<a name="ln428">                              }</a>
<a name="ln429">                        if (matchPending)</a>
<a name="ln430">                              shareHeads = false;</a>
<a name="ln431"> </a>
<a name="ln432">                        // calculate offsets</a>
<a name="ln433">                        if (shareHeads) {</a>
<a name="ln434">                              for (int i = overlapNotes.size() - 1; i &gt;= 1; i -= 2) {</a>
<a name="ln435">                                    Note* previousNote = overlapNotes[i-1];</a>
<a name="ln436">                                    Note* n = overlapNotes[i];</a>
<a name="ln437">                                    if (!(previousNote-&gt;chord()-&gt;isNudged() || n-&gt;chord()-&gt;isNudged())) {</a>
<a name="ln438">                                          if (previousNote-&gt;chord()-&gt;dots() == n-&gt;chord()-&gt;dots()) {</a>
<a name="ln439">                                                // hide one set dots</a>
<a name="ln440">                                                bool onLine = !(previousNote-&gt;line() &amp; 1);</a>
<a name="ln441">                                                if (onLine) {</a>
<a name="ln442">                                                      // hide dots for lower voice</a>
<a name="ln443">                                                      if (previousNote-&gt;voice() &amp; 1)</a>
<a name="ln444">                                                            previousNote-&gt;setDotsHidden(true);</a>
<a name="ln445">                                                      else</a>
<a name="ln446">                                                            n-&gt;setDotsHidden(true);</a>
<a name="ln447">                                                      }</a>
<a name="ln448">                                                else {</a>
<a name="ln449">                                                      // hide dots for upper voice</a>
<a name="ln450">                                                      if (!(previousNote-&gt;voice() &amp; 1))</a>
<a name="ln451">                                                            previousNote-&gt;setDotsHidden(true);</a>
<a name="ln452">                                                      else</a>
<a name="ln453">                                                            n-&gt;setDotsHidden(true);</a>
<a name="ln454">                                                      }</a>
<a name="ln455">                                                }</a>
<a name="ln456">                                          // formerly we hid noteheads in an effort to fix playback</a>
<a name="ln457">                                          // but this doesn't work for cases where noteheads cannot be shared</a>
<a name="ln458">                                          // so better to solve the problem elsewhere</a>
<a name="ln459">                                          }</a>
<a name="ln460">                                    }</a>
<a name="ln461">                              }</a>
<a name="ln462">                        else if (conflictUnison &amp;&amp; separation == 0 &amp;&amp; (!downGrace || upGrace))</a>
<a name="ln463">                              downOffset = maxUpWidth + 0.3 * sp;</a>
<a name="ln464">                        else if (conflictUnison)</a>
<a name="ln465">                              upOffset = maxDownWidth + 0.3 * sp;</a>
<a name="ln466">                        else if (conflictSecondUpHigher)</a>
<a name="ln467">                              upOffset = maxDownWidth + 0.2 * sp;</a>
<a name="ln468">                        else if ((downHooks &amp;&amp; !upHooks) &amp;&amp; !(upDots &amp;&amp; !downDots))</a>
<a name="ln469">                              downOffset = maxUpWidth + 0.3 * sp;</a>
<a name="ln470">                        else if (conflictSecondDownHigher) {</a>
<a name="ln471">                              if (downDots &amp;&amp; !upDots)</a>
<a name="ln472">                                    downOffset = maxUpWidth + 0.3 * sp;</a>
<a name="ln473">                              else {</a>
<a name="ln474">                                    upOffset = maxDownWidth - 0.2 * sp;</a>
<a name="ln475">                                    if (downHooks)</a>
<a name="ln476">                                          upOffset += 0.3 * sp;</a>
<a name="ln477">                                    }</a>
<a name="ln478">                              }</a>
<a name="ln479">                        else {</a>
<a name="ln480">                              // no direct conflict, so parts can overlap (downstem on left)</a>
<a name="ln481">                              // just be sure that stems clear opposing noteheads</a>
<a name="ln482">                              qreal clearLeft = 0.0, clearRight = 0.0;</a>
<a name="ln483">                              if (topDownNote-&gt;chord()-&gt;stem())</a>
<a name="ln484">                                    clearLeft = topDownNote-&gt;chord()-&gt;stem()-&gt;lineWidth() + 0.3 * sp;</a>
<a name="ln485">                              if (bottomUpNote-&gt;chord()-&gt;stem())</a>
<a name="ln486">                                    clearRight = bottomUpNote-&gt;chord()-&gt;stem()-&gt;lineWidth() + qMax(maxDownWidth - maxUpWidth, 0.0) + 0.3 * sp;</a>
<a name="ln487">                              else</a>
<a name="ln488">                                    downDots = 0; // no need to adjust for dots in this case</a>
<a name="ln489">                              upOffset = qMax(clearLeft, clearRight);</a>
<a name="ln490">                              if (downHooks) {</a>
<a name="ln491">                                    // we will need more space to avoid collision with hook</a>
<a name="ln492">                                    // but we won't need as much dot adjustment</a>
<a name="ln493">                                    upOffset = qMax(upOffset, maxDownWidth + 0.1 * sp);</a>
<a name="ln494">                                    dotAdjustThreshold = maxUpWidth - 0.3 * sp;</a>
<a name="ln495">                                    }</a>
<a name="ln496">                              // if downstem chord is small, don't center</a>
<a name="ln497">                              // and we might not need as much dot adjustment either</a>
<a name="ln498">                              if (centerDown &gt; 0.0) {</a>
<a name="ln499">                                    centerDown = 0.0;</a>
<a name="ln500">                                    centerAdjustUp = 0.0;</a>
<a name="ln501">                                    dotAdjustThreshold = (upOffset - maxDownWidth) + maxUpWidth - 0.3 * sp;</a>
<a name="ln502">                                    }</a>
<a name="ln503">                              }</a>
<a name="ln504"> </a>
<a name="ln505">                        }</a>
<a name="ln506"> </a>
<a name="ln507">                  // adjust for dots</a>
<a name="ln508">                  if ((upDots &amp;&amp; !downDots) || (downDots &amp;&amp; !upDots)) {</a>
<a name="ln509">                        // only one sets of dots</a>
<a name="ln510">                        // place between chords</a>
<a name="ln511">                        int dots;</a>
<a name="ln512">                        qreal mag;</a>
<a name="ln513">                        if (upDots) {</a>
<a name="ln514">                              dots = upDots;</a>
<a name="ln515">                              mag = maxUpMag;</a>
<a name="ln516">                              }</a>
<a name="ln517">                        else {</a>
<a name="ln518">                              dots = downDots;</a>
<a name="ln519">                              mag = maxDownMag;</a>
<a name="ln520">                              }</a>
<a name="ln521">                        qreal dotWidth = segment-&gt;symWidth(SymId::augmentationDot);</a>
<a name="ln522">                        // first dot</a>
<a name="ln523">                        dotAdjust = styleP(Sid::dotNoteDistance) + dotWidth;</a>
<a name="ln524">                        // additional dots</a>
<a name="ln525">                        if (dots &gt; 1)</a>
<a name="ln526">                              dotAdjust += styleP(Sid::dotDotDistance) * (dots - 1);</a>
<a name="ln527">                        dotAdjust *= mag;</a>
<a name="ln528">                        // only by amount over threshold</a>
<a name="ln529">                        dotAdjust = qMax(dotAdjust - dotAdjustThreshold, 0.0);</a>
<a name="ln530">                        }</a>
<a name="ln531">                  if (separation == 1)</a>
<a name="ln532">                        dotAdjust += 0.1 * sp;</a>
<a name="ln533"> </a>
<a name="ln534">                  }</a>
<a name="ln535"> </a>
<a name="ln536">            // apply chord offsets</a>
<a name="ln537">            for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln538">                  Element* e = segment-&gt;element(track);</a>
<a name="ln539">                  if (e &amp;&amp; e-&gt;isChord()) {</a>
<a name="ln540">                        Chord* chord = toChord(e);</a>
<a name="ln541">                        if (chord-&gt;up()) {</a>
<a name="ln542">                              if (upOffset != 0.0) {</a>
<a name="ln543">                                    chord-&gt;rxpos() += upOffset + centerAdjustUp + oversizeUp;</a>
<a name="ln544">                                    if (downDots &amp;&amp; !upDots)</a>
<a name="ln545">                                          chord-&gt;rxpos() += dotAdjust;</a>
<a name="ln546">                                    }</a>
<a name="ln547">                              else</a>
<a name="ln548">                                    chord-&gt;rxpos() += centerUp;</a>
<a name="ln549">                              }</a>
<a name="ln550">                        else {</a>
<a name="ln551">                              if (downOffset != 0.0) {</a>
<a name="ln552">                                    chord-&gt;rxpos() += downOffset + centerAdjustDown;</a>
<a name="ln553">                                    if (upDots &amp;&amp; !downDots)</a>
<a name="ln554">                                          chord-&gt;rxpos() += dotAdjust;</a>
<a name="ln555">                                    }</a>
<a name="ln556">                              else</a>
<a name="ln557">                                    chord-&gt;rxpos() += centerDown;</a>
<a name="ln558">                              }</a>
<a name="ln559">                        }</a>
<a name="ln560">                  }</a>
<a name="ln561"> </a>
<a name="ln562">            // layout chords</a>
<a name="ln563">            std::vector&lt;Note*&gt; notes;</a>
<a name="ln564">            if (upVoices)</a>
<a name="ln565">                  notes.insert(notes.end(), upStemNotes.begin(), upStemNotes.end());</a>
<a name="ln566">            if (downVoices)</a>
<a name="ln567">                  notes.insert(notes.end(), downStemNotes.begin(), downStemNotes.end());</a>
<a name="ln568">            if (upVoices + downVoices &gt; 1)</a>
<a name="ln569">                  qSort(notes.begin(), notes.end(),</a>
<a name="ln570">                     [](Note* n1, const Note* n2) -&gt;bool {return n1-&gt;line() &gt; n2-&gt;line(); } );</a>
<a name="ln571">            layoutChords3(notes, staff, segment);</a>
<a name="ln572">            }</a>
<a name="ln573"> </a>
<a name="ln574">      layoutSegmentElements(segment, startTrack, endTrack);</a>
<a name="ln575">      }</a>
<a name="ln576"> </a>
<a name="ln577">//---------------------------------------------------------</a>
<a name="ln578">//   layoutChords2</a>
<a name="ln579">//    - determine which notes need mirroring</a>
<a name="ln580">//    - this is called once for each stem direction</a>
<a name="ln581">//      eg, once for voices 1&amp;3, once for 2&amp;4</a>
<a name="ln582">//      with all notes combined and sorted to resemble one chord</a>
<a name="ln583">//    - return maximum non-mirrored notehead width</a>
<a name="ln584">//---------------------------------------------------------</a>
<a name="ln585"> </a>
<a name="ln586">qreal Score::layoutChords2(std::vector&lt;Note*&gt;&amp; notes, bool up)</a>
<a name="ln587">      {</a>
<a name="ln588">      int startIdx, endIdx, incIdx;</a>
<a name="ln589">      qreal maxWidth = 0.0;</a>
<a name="ln590"> </a>
<a name="ln591">      // loop in correct direction so that first encountered notehead wins conflict</a>
<a name="ln592">      if (up) {</a>
<a name="ln593">            // loop bottom up</a>
<a name="ln594">            startIdx = 0;</a>
<a name="ln595">            endIdx = int(notes.size());</a>
<a name="ln596">            incIdx = 1;</a>
<a name="ln597">            }</a>
<a name="ln598">      else {</a>
<a name="ln599">            // loop top down</a>
<a name="ln600">            startIdx = int(notes.size()) - 1;</a>
<a name="ln601">            endIdx = -1;</a>
<a name="ln602">            incIdx = -1;</a>
<a name="ln603">            }</a>
<a name="ln604"> </a>
<a name="ln605">      int ll        = 1000;         // line of previous notehead</a>
<a name="ln606">                                    // hack: start high so first note won't show as conflict</a>
<a name="ln607">      bool lvisible = false;        // was last note visible?</a>
<a name="ln608">      bool mirror   = false;        // should current notehead be mirrored?</a>
<a name="ln609">                                    // value is retained and may be used on next iteration</a>
<a name="ln610">                                    // to track mirror status of previous note</a>
<a name="ln611">      bool isLeft   = notes[startIdx]-&gt;chord()-&gt;up();             // is notehead on left?</a>
<a name="ln612">      int lmove     = notes[startIdx]-&gt;chord()-&gt;staffMove();      // staff offset of last note (for cross-staff beaming)</a>
<a name="ln613"> </a>
<a name="ln614">      for (int idx = startIdx; idx != endIdx; idx += incIdx) {</a>
<a name="ln615">            Note* note    = notes[idx];                     // current note</a>
<a name="ln616">            int line      = note-&gt;line();                   // line of current note</a>
<a name="ln617">            Chord* chord  = note-&gt;chord();</a>
<a name="ln618">            int move      = chord-&gt;staffMove();             // staff offset of current note</a>
<a name="ln619"> </a>
<a name="ln620">            // there is a conflict</a>
<a name="ln621">            // if this is same or adjacent line as previous note (and chords are on same staff!)</a>
<a name="ln622">            // but no need to do anything about it if either note is invisible</a>
<a name="ln623">            bool conflict = (qAbs(ll - line) &lt; 2) &amp;&amp; (lmove == move) &amp;&amp; note-&gt;visible() &amp;&amp; lvisible;</a>
<a name="ln624"> </a>
<a name="ln625">            // this note is on opposite side of stem as previous note</a>
<a name="ln626">            // if there is a conflict</a>
<a name="ln627">            // or if this the first note *after* a conflict</a>
<a name="ln628">            if (conflict || (chord-&gt;up() != isLeft))</a>
<a name="ln629">                  isLeft = !isLeft;</a>
<a name="ln630"> </a>
<a name="ln631">            // determine if we would need to mirror current note</a>
<a name="ln632">            // to get it to the correct side</a>
<a name="ln633">            // this would be needed to get a note to left or downstem or right of upstem</a>
<a name="ln634">            // whether or not we actually do this is determined later (based on user mirror property)</a>
<a name="ln635">            bool nmirror = (chord-&gt;up() != isLeft);</a>
<a name="ln636"> </a>
<a name="ln637">            // by default, notes and dots are not hidden</a>
<a name="ln638">            // this may be changed later to allow unisons to share noteheads</a>
<a name="ln639">            note-&gt;setHidden(false);</a>
<a name="ln640">            note-&gt;setDotsHidden(false);</a>
<a name="ln641"> </a>
<a name="ln642">            // be sure chord position is initialized</a>
<a name="ln643">            // chord may be moved to the right later</a>
<a name="ln644">            // if there are conflicts between voices</a>
<a name="ln645">            chord-&gt;rxpos() = 0.0;</a>
<a name="ln646"> </a>
<a name="ln647">            // let user mirror property override the default we calculated</a>
<a name="ln648">            if (note-&gt;userMirror() == MScore::DirectionH::AUTO) {</a>
<a name="ln649">                  mirror = nmirror;</a>
<a name="ln650">                  }</a>
<a name="ln651">            else {</a>
<a name="ln652">                  mirror = note-&gt;chord()-&gt;up();</a>
<a name="ln653">                  if (note-&gt;userMirror() == MScore::DirectionH::LEFT)</a>
<a name="ln654">                        mirror = !mirror;</a>
<a name="ln655">                  }</a>
<a name="ln656">            note-&gt;setMirror(mirror);</a>
<a name="ln657"> </a>
<a name="ln658">            // accumulate return value</a>
<a name="ln659">            if (!mirror)</a>
<a name="ln660">                  maxWidth = qMax(maxWidth, note-&gt;bboxRightPos());</a>
<a name="ln661"> </a>
<a name="ln662">            // prepare for next iteration</a>
<a name="ln663">            lvisible = note-&gt;visible();</a>
<a name="ln664">            lmove    = move;</a>
<a name="ln665">            ll       = line;</a>
<a name="ln666">            }</a>
<a name="ln667"> </a>
<a name="ln668">      return maxWidth;</a>
<a name="ln669">      }</a>
<a name="ln670"> </a>
<a name="ln671">//---------------------------------------------------------</a>
<a name="ln672">//   AcEl</a>
<a name="ln673">//---------------------------------------------------------</a>
<a name="ln674"> </a>
<a name="ln675">struct AcEl {</a>
<a name="ln676">      Note* note;</a>
<a name="ln677">      qreal x;          // actual x position of this accidental relative to origin</a>
<a name="ln678">      qreal top;        // top of accidental bbox relative to staff</a>
<a name="ln679">      qreal bottom;     // bottom of accidental bbox relative to staff</a>
<a name="ln680">      int line;         // line of note</a>
<a name="ln681">      int next;         // index of next accidental of same pitch class (ascending list)</a>
<a name="ln682">      qreal width;      // width of accidental</a>
<a name="ln683">      qreal ascent;     // amount (in sp) vertical strokes extend above body</a>
<a name="ln684">      qreal descent;    // amount (in sp) vertical strokes extend below body</a>
<a name="ln685">      qreal rightClear; // amount (in sp) to right of last vertical stroke above body</a>
<a name="ln686">      qreal leftClear;  // amount (in sp) to left of last vertical stroke below body</a>
<a name="ln687">      };</a>
<a name="ln688"> </a>
<a name="ln689">//---------------------------------------------------------</a>
<a name="ln690">//   resolveAccidentals</a>
<a name="ln691">//    lx = calculated position of rightmost edge of left accidental relative to origin</a>
<a name="ln692">//---------------------------------------------------------</a>
<a name="ln693"> </a>
<a name="ln694">static bool resolveAccidentals(AcEl* left, AcEl* right, qreal&amp; lx, qreal pd, qreal sp)</a>
<a name="ln695">      {</a>
<a name="ln696">      AcEl* upper;</a>
<a name="ln697">      AcEl* lower;</a>
<a name="ln698">      if (left-&gt;line &gt;= right-&gt;line) {</a>
<a name="ln699">            upper = right;</a>
<a name="ln700">            lower = left;</a>
<a name="ln701">            }</a>
<a name="ln702">      else {</a>
<a name="ln703">            upper = left;</a>
<a name="ln704">            lower = right;</a>
<a name="ln705">            }</a>
<a name="ln706"> </a>
<a name="ln707">      qreal gap = lower-&gt;top - upper-&gt;bottom;</a>
<a name="ln708"> </a>
<a name="ln709">      // no conflict at all if there is sufficient vertical gap between accidentals</a>
<a name="ln710">      // the arrangement of accidentals into columns assumes accidentals an octave apart *do* clear</a>
<a name="ln711">      if (gap &gt;= pd || lower-&gt;line - upper-&gt;line &gt;= 7)</a>
<a name="ln712">            return false;</a>
<a name="ln713"> </a>
<a name="ln714">      qreal allowableOverlap = qMax(upper-&gt;descent, lower-&gt;ascent) - pd;</a>
<a name="ln715"> </a>
<a name="ln716">      // accidentals that are &quot;close&quot; (small gap or even slight overlap)</a>
<a name="ln717">      if (qAbs(gap) &lt;= 0.33 * sp) {</a>
<a name="ln718">            // acceptable with slight offset</a>
<a name="ln719">            // if one of the accidentals can subsume the overlap</a>
<a name="ln720">            // and both accidentals allow it</a>
<a name="ln721">            if (-gap &lt;= allowableOverlap &amp;&amp; qMin(upper-&gt;descent, lower-&gt;ascent) &gt; 0.0) {</a>
<a name="ln722">                  qreal align = qMin(left-&gt;width, right-&gt;width);</a>
<a name="ln723">                  lx = qMin(lx, right-&gt;x + align - pd);</a>
<a name="ln724">                  return true;</a>
<a name="ln725">                  }</a>
<a name="ln726">            }</a>
<a name="ln727"> </a>
<a name="ln728">      // amount by which overlapping accidentals will be separated</a>
<a name="ln729">      // for example, the vertical stems of two flat signs</a>
<a name="ln730">      // these need more space than we would need between non-overlapping accidentals</a>
<a name="ln731">      qreal overlapShift = pd * 1.41;</a>
<a name="ln732"> </a>
<a name="ln733">      // accidentals with more significant overlap</a>
<a name="ln734">      // acceptable if one accidental can subsume overlap</a>
<a name="ln735">      if (left == lower &amp;&amp; -gap &lt;= allowableOverlap) {</a>
<a name="ln736">            qreal offset = qMax(left-&gt;rightClear, right-&gt;leftClear);</a>
<a name="ln737">            offset = qMin(offset, left-&gt;width) - overlapShift;</a>
<a name="ln738">            lx = qMin(lx, right-&gt;x + offset);</a>
<a name="ln739">            return true;</a>
<a name="ln740">            }</a>
<a name="ln741"> </a>
<a name="ln742">      // accidentals with even more overlap</a>
<a name="ln743">      // can work if both accidentals can subsume overlap</a>
<a name="ln744">      if (left == lower &amp;&amp; -gap &lt;= upper-&gt;descent + lower-&gt;ascent - pd) {</a>
<a name="ln745">            qreal offset = qMin(left-&gt;rightClear, right-&gt;leftClear) - overlapShift;</a>
<a name="ln746">            if (offset &gt; 0.0) {</a>
<a name="ln747">                  lx = qMin(lx, right-&gt;x + offset);</a>
<a name="ln748">                  return true;</a>
<a name="ln749">                  }</a>
<a name="ln750">            }</a>
<a name="ln751"> </a>
<a name="ln752">      // otherwise, there is real conflict</a>
<a name="ln753">      lx = qMin(lx, right-&gt;x - pd);</a>
<a name="ln754">      return true;</a>
<a name="ln755">      }</a>
<a name="ln756"> </a>
<a name="ln757">//---------------------------------------------------------</a>
<a name="ln758">//   layoutAccidental</a>
<a name="ln759">//---------------------------------------------------------</a>
<a name="ln760"> </a>
<a name="ln761">static qreal layoutAccidental(AcEl* me, AcEl* above, AcEl* below, qreal colOffset, QVector&lt;Note*&gt;&amp; leftNotes, qreal pnd, qreal pd, qreal sp)</a>
<a name="ln762">      {</a>
<a name="ln763">      qreal lx = colOffset;</a>
<a name="ln764">      Accidental* acc = me-&gt;note-&gt;accidental();</a>
<a name="ln765">      qreal mag = acc-&gt;mag();</a>
<a name="ln766">      pnd *= mag;</a>
<a name="ln767">      pd *= mag;</a>
<a name="ln768"> </a>
<a name="ln769">      // extra space for ledger lines</a>
<a name="ln770">      if (me-&gt;line &lt;= -2 || me-&gt;line &gt;= me-&gt;note-&gt;staff()-&gt;lines(me-&gt;note-&gt;chord()-&gt;tick()) * 2)</a>
<a name="ln771">            lx = qMin(lx, -0.2 * sp);</a>
<a name="ln772"> </a>
<a name="ln773">      // clear left notes</a>
<a name="ln774">      int lns = leftNotes.size();</a>
<a name="ln775">      for (int i = 0; i &lt; lns; ++i) {</a>
<a name="ln776">            Note* ln = leftNotes[i];</a>
<a name="ln777">            int lnLine = ln-&gt;line();</a>
<a name="ln778">            qreal lnTop = (lnLine - 1) * 0.5 * sp;</a>
<a name="ln779">            qreal lnBottom = lnTop + sp;</a>
<a name="ln780">            if (me-&gt;top - lnBottom &lt;= pnd &amp;&amp; lnTop - me-&gt;bottom &lt;= pnd) {</a>
<a name="ln781">                  // undercut note above if possible</a>
<a name="ln782">                  if (lnBottom - me-&gt;top &lt;= me-&gt;ascent - pnd)</a>
<a name="ln783">                        lx = qMin(lx, ln-&gt;x() + ln-&gt;chord()-&gt;x() + me-&gt;rightClear);</a>
<a name="ln784">                  else</a>
<a name="ln785">                        lx = qMin(lx, ln-&gt;x() + ln-&gt;chord()-&gt;x());</a>
<a name="ln786">                  }</a>
<a name="ln787">            else if (lnTop &gt; me-&gt;bottom)</a>
<a name="ln788">                  break;</a>
<a name="ln789">            }</a>
<a name="ln790"> </a>
<a name="ln791">      // clear other accidentals</a>
<a name="ln792">      bool conflictAbove = false;</a>
<a name="ln793">      bool conflictBelow = false;</a>
<a name="ln794"> </a>
<a name="ln795">      if (above)</a>
<a name="ln796">            conflictAbove = resolveAccidentals(me, above, lx, pd, sp);</a>
<a name="ln797">      if (below)</a>
<a name="ln798">            conflictBelow = resolveAccidentals(me, below, lx, pd, sp);</a>
<a name="ln799">      if (conflictAbove || conflictBelow)</a>
<a name="ln800">            me-&gt;x = lx - acc-&gt;width() - acc-&gt;bbox().x();</a>
<a name="ln801">      else if (colOffset != 0.0)</a>
<a name="ln802">            me-&gt;x = lx - pd - acc-&gt;width() - acc-&gt;bbox().x();</a>
<a name="ln803">      else</a>
<a name="ln804">            me-&gt;x = lx - pnd - acc-&gt;width() - acc-&gt;bbox().x();</a>
<a name="ln805"> </a>
<a name="ln806">      return me-&gt;x;</a>
<a name="ln807">      }</a>
<a name="ln808"> </a>
<a name="ln809">//---------------------------------------------------------</a>
<a name="ln810">//   layoutChords3</a>
<a name="ln811">//    - calculate positions of notes, accidentals, dots</a>
<a name="ln812">//---------------------------------------------------------</a>
<a name="ln813"> </a>
<a name="ln814">void Score::layoutChords3(std::vector&lt;Note*&gt;&amp; notes, const Staff* staff, Segment* segment)</a>
<a name="ln815">      {</a>
<a name="ln816">      //---------------------------------------------------</a>
<a name="ln817">      //    layout accidentals</a>
<a name="ln818">      //    find column for dots</a>
<a name="ln819">      //---------------------------------------------------</a>
<a name="ln820"> </a>
<a name="ln821">      QVector&lt;Note*&gt; leftNotes; // notes to left of origin</a>
<a name="ln822">      leftNotes.reserve(8);</a>
<a name="ln823">      QVector&lt;AcEl&gt; aclist;       // accidentals</a>
<a name="ln824">      aclist.reserve(8);</a>
<a name="ln825"> </a>
<a name="ln826">      // track columns of octave-separated accidentals</a>
<a name="ln827">      int columnBottom[7] = { -1, -1, -1, -1, -1, -1, -1 };</a>
<a name="ln828"> </a>
<a name="ln829">      Fraction tick      =  notes.front()-&gt;chord()-&gt;segment()-&gt;tick();</a>
<a name="ln830">      qreal sp           = staff-&gt;spatium(tick);</a>
<a name="ln831">      qreal stepDistance = sp * staff-&gt;lineDistance(tick) * .5;</a>
<a name="ln832">      int stepOffset     = staff-&gt;staffType(tick)-&gt;stepOffset();</a>
<a name="ln833"> </a>
<a name="ln834">      qreal lx           = 10000.0;  // leftmost notehead position</a>
<a name="ln835">      qreal upDotPosX    = 0.0;</a>
<a name="ln836">      qreal downDotPosX  = 0.0;</a>
<a name="ln837"> </a>
<a name="ln838">      int nNotes = int(notes.size());</a>
<a name="ln839">      int nAcc = 0;</a>
<a name="ln840">      for (int i = nNotes-1; i &gt;= 0; --i) {</a>
<a name="ln841">            Note* note     = notes[i];</a>
<a name="ln842">            Accidental* ac = note-&gt;accidental();</a>
<a name="ln843">            if (ac &amp;&amp; !note-&gt;fixed()) {</a>
<a name="ln844">                  ac-&gt;layout();</a>
<a name="ln845">                  AcEl acel;</a>
<a name="ln846">                  acel.note   = note;</a>
<a name="ln847">                  int line    = note-&gt;line();</a>
<a name="ln848">                  acel.line   = line;</a>
<a name="ln849">                  acel.x      = 0.0;</a>
<a name="ln850">                  acel.top    = line * 0.5 * sp + ac-&gt;bbox().top();</a>
<a name="ln851">                  acel.bottom = line * 0.5 * sp + ac-&gt;bbox().bottom();</a>
<a name="ln852">                  acel.width  = ac-&gt;width();</a>
<a name="ln853">                  QPointF bboxNE = ac-&gt;symBbox(ac-&gt;symbol()).topRight();</a>
<a name="ln854">                  QPointF bboxSW = ac-&gt;symBbox(ac-&gt;symbol()).bottomLeft();</a>
<a name="ln855">                  QPointF cutOutNE = ac-&gt;symCutOutNE(ac-&gt;symbol());</a>
<a name="ln856">                  QPointF cutOutSW = ac-&gt;symCutOutSW(ac-&gt;symbol());</a>
<a name="ln857">                  if (!cutOutNE.isNull()) {</a>
<a name="ln858">                        acel.ascent     = cutOutNE.y() - bboxNE.y();</a>
<a name="ln859">                        acel.rightClear = bboxNE.x() - cutOutNE.x();</a>
<a name="ln860">                        }</a>
<a name="ln861">                  else {</a>
<a name="ln862">                        acel.ascent     = 0.0;</a>
<a name="ln863">                        acel.rightClear = 0.0;</a>
<a name="ln864">                        }</a>
<a name="ln865">                  if (!cutOutSW.isNull()) {</a>
<a name="ln866">                        acel.descent   = bboxSW.y() - cutOutSW.y();</a>
<a name="ln867">                        acel.leftClear = cutOutSW.x() - bboxSW.x();</a>
<a name="ln868">                        }</a>
<a name="ln869">                  else {</a>
<a name="ln870">                        acel.descent   = 0.0;</a>
<a name="ln871">                        acel.leftClear = 0.0;</a>
<a name="ln872">                        }</a>
<a name="ln873">                  int pitchClass = (line + 700) % 7;</a>
<a name="ln874">                  acel.next = columnBottom[pitchClass];</a>
<a name="ln875">                  columnBottom[pitchClass] = nAcc;</a>
<a name="ln876">                  aclist.append(acel);</a>
<a name="ln877">                  ++nAcc;</a>
<a name="ln878">                  }</a>
<a name="ln879"> </a>
<a name="ln880">            Chord* chord = note-&gt;chord();</a>
<a name="ln881">            bool _up     = chord-&gt;up();</a>
<a name="ln882"> </a>
<a name="ln883">            if (chord-&gt;stemSlash())</a>
<a name="ln884">                  chord-&gt;stemSlash()-&gt;layout();</a>
<a name="ln885"> </a>
<a name="ln886">            qreal overlapMirror;</a>
<a name="ln887">            Stem* stem = chord-&gt;stem();</a>
<a name="ln888">            if (stem)</a>
<a name="ln889">                  overlapMirror = stem-&gt;lineWidth();</a>
<a name="ln890">            else if (chord-&gt;durationType().headType() == NoteHead::Type::HEAD_WHOLE)</a>
<a name="ln891">                  overlapMirror = styleP(Sid::stemWidth) * chord-&gt;mag();</a>
<a name="ln892">            else</a>
<a name="ln893">                  overlapMirror = 0.0;</a>
<a name="ln894"> </a>
<a name="ln895">            qreal x = 0.0;</a>
<a name="ln896">            if (note-&gt;mirror())</a>
<a name="ln897">                  if (_up)</a>
<a name="ln898">                        x = chord-&gt;stemPosX() - overlapMirror;</a>
<a name="ln899">                  else</a>
<a name="ln900">                        x = -note-&gt;headBodyWidth() + overlapMirror;</a>
<a name="ln901">            else if (_up)</a>
<a name="ln902">                  x = chord-&gt;stemPosX() - note-&gt;headBodyWidth();</a>
<a name="ln903"> </a>
<a name="ln904">            qreal ny = (note-&gt;line() + stepOffset) * stepDistance;</a>
<a name="ln905">            if (note-&gt;rypos() != ny) {</a>
<a name="ln906">                  note-&gt;rypos() = ny;</a>
<a name="ln907">                  if (chord-&gt;stem()) {</a>
<a name="ln908">                        chord-&gt;stem()-&gt;layout();</a>
<a name="ln909">                        if (chord-&gt;hook())</a>
<a name="ln910">                              chord-&gt;hook()-&gt;rypos() = chord-&gt;stem()-&gt;hookPos().y();</a>
<a name="ln911">                        }</a>
<a name="ln912">                  }</a>
<a name="ln913">            note-&gt;rxpos()  = x;</a>
<a name="ln914"> </a>
<a name="ln915">            // find leftmost non-mirrored note to set as X origin for accidental layout</a>
<a name="ln916">            // a mirrored note that extends to left of segment X origin</a>
<a name="ln917">            // will displace accidentals only if there is conflict</a>
<a name="ln918">            qreal sx = x + chord-&gt;x(); // segment-relative X position of note</a>
<a name="ln919">            if (note-&gt;mirror() &amp;&amp; !chord-&gt;up() &amp;&amp; sx &lt; 0.0)</a>
<a name="ln920">                  leftNotes.append(note);</a>
<a name="ln921">            else if (sx &lt; lx)</a>
<a name="ln922">                  lx = sx;</a>
<a name="ln923"> </a>
<a name="ln924">            qreal xx = x + note-&gt;headBodyWidth() + chord-&gt;pos().x();</a>
<a name="ln925"> </a>
<a name="ln926">            Direction dotPosition = note-&gt;userDotPosition();</a>
<a name="ln927">            if (chord-&gt;dots()) {</a>
<a name="ln928">                  if (chord-&gt;up())</a>
<a name="ln929">                        upDotPosX = qMax(upDotPosX, xx);</a>
<a name="ln930">                  else {</a>
<a name="ln931">                        downDotPosX = qMax(downDotPosX, xx);</a>
<a name="ln932">                        }</a>
<a name="ln933"> </a>
<a name="ln934">                  if (dotPosition == Direction::AUTO &amp;&amp; nNotes &gt; 1 &amp;&amp; note-&gt;visible() &amp;&amp; !note-&gt;dotsHidden()) {</a>
<a name="ln935">                        // resolve dot conflicts</a>
<a name="ln936">                        int line = note-&gt;line();</a>
<a name="ln937">                        Note* above = (i &lt; nNotes - 1) ? notes[i+1] : 0;</a>
<a name="ln938">                        if (above &amp;&amp; (!above-&gt;visible() || above-&gt;dotsHidden()))</a>
<a name="ln939">                              above = 0;</a>
<a name="ln940">                        int intervalAbove = above ? line - above-&gt;line() : 1000;</a>
<a name="ln941">                        Note* below = (i &gt; 0) ? notes[i-1] : 0;</a>
<a name="ln942">                        if (below &amp;&amp; (!below-&gt;visible() || below-&gt;dotsHidden()))</a>
<a name="ln943">                              below = 0;</a>
<a name="ln944">                        int intervalBelow = below ? below-&gt;line() - line : 1000;</a>
<a name="ln945">                        if ((line &amp; 1) == 0) {</a>
<a name="ln946">                              // line</a>
<a name="ln947">                              if (intervalAbove == 1 &amp;&amp; intervalBelow != 1)</a>
<a name="ln948">                                    dotPosition = Direction::DOWN;</a>
<a name="ln949">                              else if (intervalBelow == 1 &amp;&amp; intervalAbove != 1)</a>
<a name="ln950">                                    dotPosition = Direction::UP;</a>
<a name="ln951">                              else if (intervalAbove == 0 &amp;&amp; above-&gt;chord()-&gt;dots()) {</a>
<a name="ln952">                                    // unison</a>
<a name="ln953">                                    if (((above-&gt;voice() &amp; 1) == (note-&gt;voice() &amp; 1))) {</a>
<a name="ln954">                                          above-&gt;setDotY(Direction::UP);</a>
<a name="ln955">                                          dotPosition = Direction::DOWN;</a>
<a name="ln956">                                          }</a>
<a name="ln957">                                    }</a>
<a name="ln958">                              }</a>
<a name="ln959">                        else {</a>
<a name="ln960">                              // space</a>
<a name="ln961">                              if (intervalAbove == 0 &amp;&amp; above-&gt;chord()-&gt;dots()) {</a>
<a name="ln962">                                    // unison</a>
<a name="ln963">                                    if (!(note-&gt;voice() &amp; 1))</a>
<a name="ln964">                                          dotPosition = Direction::UP;</a>
<a name="ln965">                                    else {</a>
<a name="ln966">                                          if (!(above-&gt;voice() &amp; 1))</a>
<a name="ln967">                                                above-&gt;setDotY(Direction::UP);</a>
<a name="ln968">                                          else</a>
<a name="ln969">                                                dotPosition = Direction::DOWN;</a>
<a name="ln970">                                          }</a>
<a name="ln971">                                    }</a>
<a name="ln972">                              }</a>
<a name="ln973">                        }</a>
<a name="ln974">                  }</a>
<a name="ln975">            note-&gt;setDotY(dotPosition);  // also removes invalid dots</a>
<a name="ln976">            }</a>
<a name="ln977"> </a>
<a name="ln978">      // if there are no non-mirrored notes in a downstem chord,</a>
<a name="ln979">      // then use the stem X position as X origin for accidental layout</a>
<a name="ln980">      if (nNotes &amp;&amp; leftNotes.size() == nNotes)</a>
<a name="ln981">            lx = notes.front()-&gt;chord()-&gt;stemPosX();</a>
<a name="ln982"> </a>
<a name="ln983">      if (segment) {</a>
<a name="ln984">            // align all dots for segment/staff</a>
<a name="ln985">            // it would be possible to dots for up &amp; down chords separately</a>
<a name="ln986">            // this would require space to have been allocated previously</a>
<a name="ln987">            // when calculating chord offsets</a>
<a name="ln988">            segment-&gt;setDotPosX(staff-&gt;idx(), qMax(upDotPosX, downDotPosX));</a>
<a name="ln989">            }</a>
<a name="ln990"> </a>
<a name="ln991">      if (nAcc == 0)</a>
<a name="ln992">            return;</a>
<a name="ln993"> </a>
<a name="ln994">      QVector&lt;int&gt; umi;</a>
<a name="ln995">      qreal pd  = styleP(Sid::accidentalDistance);</a>
<a name="ln996">      qreal pnd = styleP(Sid::accidentalNoteDistance);</a>
<a name="ln997">      qreal colOffset = 0.0;</a>
<a name="ln998"> </a>
<a name="ln999">      if (nAcc &gt;= 2 &amp;&amp; aclist[nAcc-1].line - aclist[0].line &gt;= 7) {</a>
<a name="ln1000"> </a>
<a name="ln1001">            // accidentals spread over an octave or more</a>
<a name="ln1002">            // set up columns for accidentals with octave matches</a>
<a name="ln1003">            // these will start at right and work to the left</a>
<a name="ln1004">            // unmatched accidentals will use zig zag approach (see below)</a>
<a name="ln1005">            // starting to the left of the octave columns</a>
<a name="ln1006"> </a>
<a name="ln1007">            qreal minX = 0.0;</a>
<a name="ln1008">            int columnTop[7] = { -1, -1, -1, -1, -1, -1, -1 };</a>
<a name="ln1009"> </a>
<a name="ln1010">            // find columns of octaves</a>
<a name="ln1011">            for (int pc = 0; pc &lt; 7; ++pc) {</a>
<a name="ln1012">                  if (columnBottom[pc] == -1)</a>
<a name="ln1013">                        continue;</a>
<a name="ln1014">                  // calculate column height</a>
<a name="ln1015">                  for (int j = columnBottom[pc]; j != -1; j = aclist[j].next)</a>
<a name="ln1016">                        columnTop[pc] = j;</a>
<a name="ln1017">                  }</a>
<a name="ln1018"> </a>
<a name="ln1019">            // compute reasonable column order</a>
<a name="ln1020">            // use zig zag</a>
<a name="ln1021">            QVector&lt;int&gt; column;</a>
<a name="ln1022">            QVector&lt;int&gt; unmatched;</a>
<a name="ln1023">            int n = nAcc - 1;</a>
<a name="ln1024">            for (int i = 0; i &lt;= n; ++i, --n) {</a>
<a name="ln1025">                  int pc = (aclist[i].line + 700) % 7;</a>
<a name="ln1026">                  if (aclist[columnTop[pc]].line != aclist[columnBottom[pc]].line) {</a>
<a name="ln1027">                        if (!column.contains(pc))</a>
<a name="ln1028">                              column.append(pc);</a>
<a name="ln1029">                        }</a>
<a name="ln1030">                  else</a>
<a name="ln1031">                        unmatched.append(i);</a>
<a name="ln1032">                  if (i == n)</a>
<a name="ln1033">                        break;</a>
<a name="ln1034">                  pc = (aclist[n].line + 700) % 7;</a>
<a name="ln1035">                  if (aclist[columnTop[pc]].line != aclist[columnBottom[pc]].line) {</a>
<a name="ln1036">                        if (!column.contains(pc))</a>
<a name="ln1037">                              column.append(pc);</a>
<a name="ln1038">                        }</a>
<a name="ln1039">                  else</a>
<a name="ln1040">                        unmatched.append(n);</a>
<a name="ln1041">                  }</a>
<a name="ln1042">            int nColumns = column.size();</a>
<a name="ln1043">            int nUnmatched = unmatched.size();</a>
<a name="ln1044"> </a>
<a name="ln1045">            // handle unmatched accidentals</a>
<a name="ln1046">            for (int i = 0; i &lt; nUnmatched; ++i) {</a>
<a name="ln1047">                  // first try to slot it into an existing column</a>
<a name="ln1048">                  AcEl* me = &amp;aclist[unmatched[i]];</a>
<a name="ln1049">                  // find column</a>
<a name="ln1050">                  bool found = false;</a>
<a name="ln1051">                  for (int j = 0; j &lt; nColumns; ++j) {</a>
<a name="ln1052">                        int pc = column[j];</a>
<a name="ln1053">                        int above = -1;</a>
<a name="ln1054">                        int below = -1;</a>
<a name="ln1055">                        // find slot within column</a>
<a name="ln1056">                        for (int k = columnBottom[pc]; k != -1; k = aclist[k].next) {</a>
<a name="ln1057">                              if (aclist[k].line &lt; me-&gt;line) {</a>
<a name="ln1058">                                    above = k;</a>
<a name="ln1059">                                    break;</a>
<a name="ln1060">                                    }</a>
<a name="ln1061">                              below = k;</a>
<a name="ln1062">                              }</a>
<a name="ln1063">                        // check to see if accidental can fit in slot</a>
<a name="ln1064">                        qreal myPd = pd * me-&gt;note-&gt;accidental()-&gt;mag();</a>
<a name="ln1065">                        bool conflict = false;</a>
<a name="ln1066">                        if (above != -1 &amp;&amp; me-&gt;top - aclist[above].bottom &lt; myPd)</a>
<a name="ln1067">                              conflict = true;</a>
<a name="ln1068">                        else if (below != -1 &amp;&amp; aclist[below].top - me-&gt;bottom &lt; myPd)</a>
<a name="ln1069">                              conflict = true;</a>
<a name="ln1070">                        if (!conflict) {</a>
<a name="ln1071">                              // insert into column</a>
<a name="ln1072">                              found = true;</a>
<a name="ln1073">                              me-&gt;next = above;</a>
<a name="ln1074">                              if (above == -1)</a>
<a name="ln1075">                                    columnTop[pc] = unmatched[i];</a>
<a name="ln1076">                              if (below != -1)</a>
<a name="ln1077">                                    aclist[below].next = unmatched[i];</a>
<a name="ln1078">                              else</a>
<a name="ln1079">                                    columnBottom[pc] = unmatched[i];</a>
<a name="ln1080">                              break;</a>
<a name="ln1081">                              }</a>
<a name="ln1082">                        }</a>
<a name="ln1083">                  // if no slot found, then add to list of unmatched accidental indices</a>
<a name="ln1084">                  if (!found)</a>
<a name="ln1085">                        umi.push_back(unmatched[i]);</a>
<a name="ln1086">                  }</a>
<a name="ln1087">            nAcc = umi.size();</a>
<a name="ln1088">            if (nAcc &gt; 1)</a>
<a name="ln1089">                  qSort(umi);</a>
<a name="ln1090"> </a>
<a name="ln1091">            // lay out columns</a>
<a name="ln1092">            for (int i = 0; i &lt; nColumns; ++i) {</a>
<a name="ln1093">                  int pc = column[i];</a>
<a name="ln1094">                  AcEl* below = 0;</a>
<a name="ln1095">                  // lay out accidentals</a>
<a name="ln1096">                  for (int j = columnBottom[pc]; j != -1; j = aclist[j].next) {</a>
<a name="ln1097">                        qreal x = layoutAccidental(&amp;aclist[j], 0, below, colOffset, leftNotes, pnd, pd, sp);</a>
<a name="ln1098">                        minX = qMin(minX, x);</a>
<a name="ln1099">                        below = &amp;aclist[j];</a>
<a name="ln1100">                        }</a>
<a name="ln1101">                  // align within column</a>
<a name="ln1102">                  int next = -1;</a>
<a name="ln1103">                  for (int j = columnBottom[pc]; j != -1; j = next) {</a>
<a name="ln1104">                        next = aclist[j].next;</a>
<a name="ln1105">                        if (next != -1 &amp;&amp; aclist[j].line == aclist[next].line)</a>
<a name="ln1106">                              continue;</a>
<a name="ln1107">                        aclist[j].x = minX;</a>
<a name="ln1108">                        }</a>
<a name="ln1109">                  // move to next column</a>
<a name="ln1110">                  colOffset = minX;</a>
<a name="ln1111">                  }</a>
<a name="ln1112"> </a>
<a name="ln1113">            }</a>
<a name="ln1114"> </a>
<a name="ln1115">      else {</a>
<a name="ln1116">            for (int i = 0; i &lt; nAcc; ++i)</a>
<a name="ln1117">                  umi.push_back(i);</a>
<a name="ln1118">            }</a>
<a name="ln1119"> </a>
<a name="ln1120">      if (nAcc) {</a>
<a name="ln1121"> </a>
<a name="ln1122">            // for accidentals with no octave matches, use zig zag approach</a>
<a name="ln1123">            // layout right to left in pairs, (next) highest then lowest</a>
<a name="ln1124"> </a>
<a name="ln1125">            AcEl* me = &amp;aclist[umi[0]];</a>
<a name="ln1126">            AcEl* above = 0;</a>
<a name="ln1127">            AcEl* below = 0;</a>
<a name="ln1128"> </a>
<a name="ln1129">            // layout top accidental</a>
<a name="ln1130">            layoutAccidental(me, above, below, colOffset, leftNotes, pnd, pd, sp);</a>
<a name="ln1131"> </a>
<a name="ln1132">            // layout bottom accidental</a>
<a name="ln1133">            int n = nAcc - 1;</a>
<a name="ln1134">            if (n &gt; 0) {</a>
<a name="ln1135">                  above = me;</a>
<a name="ln1136">                  me = &amp;aclist[umi[n]];</a>
<a name="ln1137">                  layoutAccidental(me, above, below, colOffset, leftNotes, pnd, pd, sp);</a>
<a name="ln1138">                  }</a>
<a name="ln1139"> </a>
<a name="ln1140">            // layout middle accidentals</a>
<a name="ln1141">            if (n &gt; 1) {</a>
<a name="ln1142">                  for (int i = 1; i &lt; n; ++i, --n) {</a>
<a name="ln1143">                        // next highest</a>
<a name="ln1144">                        below = me;</a>
<a name="ln1145">                        me = &amp;aclist[umi[i]];</a>
<a name="ln1146">                        layoutAccidental(me, above, below, colOffset, leftNotes, pnd, pd, sp);</a>
<a name="ln1147">                        if (i == n - 1)</a>
<a name="ln1148">                              break;</a>
<a name="ln1149">                        // next lowest</a>
<a name="ln1150">                        above = me;</a>
<a name="ln1151">                        me = &amp;aclist[umi[n-1]];</a>
<a name="ln1152">                        layoutAccidental(me, above, below, colOffset, leftNotes, pnd, pd, sp);</a>
<a name="ln1153">                        }</a>
<a name="ln1154">                  }</a>
<a name="ln1155"> </a>
<a name="ln1156">            }</a>
<a name="ln1157"> </a>
<a name="ln1158">      for (const AcEl&amp; e : aclist) {</a>
<a name="ln1159">            // even though we initially calculate accidental position relative to segment</a>
<a name="ln1160">            // we must record pos for accidental relative to note,</a>
<a name="ln1161">            // since pos is always interpreted relative to parent</a>
<a name="ln1162">            Note* note = e.note;</a>
<a name="ln1163">            qreal x    = e.x + lx - (note-&gt;x() + note-&gt;chord()-&gt;x());</a>
<a name="ln1164">            note-&gt;accidental()-&gt;setPos(x, 0);</a>
<a name="ln1165">            }</a>
<a name="ln1166">      }</a>
<a name="ln1167"> </a>
<a name="ln1168">#define beamModeMid(a) (a == Beam::Mode::MID || a == Beam::Mode::BEGIN32 || a == Beam::Mode::BEGIN64)</a>
<a name="ln1169"> </a>
<a name="ln1170">bool beamNoContinue(Beam::Mode mode)</a>
<a name="ln1171">      {</a>
<a name="ln1172">      return mode == Beam::Mode::END || mode == Beam::Mode::NONE || mode == Beam::Mode::INVALID;</a>
<a name="ln1173">      }</a>
<a name="ln1174"> </a>
<a name="ln1175">//---------------------------------------------------------</a>
<a name="ln1176">//   beamGraceNotes</a>
<a name="ln1177">//---------------------------------------------------------</a>
<a name="ln1178"> </a>
<a name="ln1179">void Score::beamGraceNotes(Chord* mainNote, bool after)</a>
<a name="ln1180">      {</a>
<a name="ln1181">      ChordRest* a1    = 0;      // start of (potential) beam</a>
<a name="ln1182">      Beam* beam       = 0;      // current beam</a>
<a name="ln1183">      Beam::Mode bm = Beam::Mode::AUTO;</a>
<a name="ln1184">      QVector&lt;Chord*&gt; graceNotes = after ? mainNote-&gt;graceNotesAfter() : mainNote-&gt;graceNotesBefore();</a>
<a name="ln1185"> </a>
<a name="ln1186">      for (ChordRest* cr : graceNotes) {</a>
<a name="ln1187">            bm = Groups::endBeam(cr);</a>
<a name="ln1188">            if ((cr-&gt;durationType().type() &lt;= TDuration::DurationType::V_QUARTER) || (bm == Beam::Mode::NONE)) {</a>
<a name="ln1189">                  if (beam) {</a>
<a name="ln1190">                        beam-&gt;layoutGraceNotes();</a>
<a name="ln1191">                        beam = 0;</a>
<a name="ln1192">                        }</a>
<a name="ln1193">                  if (a1) {</a>
<a name="ln1194">                        a1-&gt;removeDeleteBeam(false);</a>
<a name="ln1195">                        a1 = 0;</a>
<a name="ln1196">                        }</a>
<a name="ln1197">                  cr-&gt;removeDeleteBeam(false);</a>
<a name="ln1198">                  continue;</a>
<a name="ln1199">                  }</a>
<a name="ln1200">            if (beam) {</a>
<a name="ln1201">                  bool beamEnd = bm == Beam::Mode::BEGIN;</a>
<a name="ln1202">                  if (!beamEnd) {</a>
<a name="ln1203">                        cr-&gt;replaceBeam(beam);</a>
<a name="ln1204">                        cr = 0;</a>
<a name="ln1205">                        beamEnd = (bm == Beam::Mode::END);</a>
<a name="ln1206">                        }</a>
<a name="ln1207">                  if (beamEnd) {</a>
<a name="ln1208">                        beam-&gt;layoutGraceNotes();</a>
<a name="ln1209">                        beam = 0;</a>
<a name="ln1210">                        }</a>
<a name="ln1211">                  }</a>
<a name="ln1212">            if (!cr)</a>
<a name="ln1213">                  continue;</a>
<a name="ln1214">            if (a1 == 0)</a>
<a name="ln1215">                  a1 = cr;</a>
<a name="ln1216">            else {</a>
<a name="ln1217">                  if (!beamModeMid(bm) &amp;&amp; (bm == Beam::Mode::BEGIN)) {</a>
<a name="ln1218">                        a1-&gt;removeDeleteBeam(false);</a>
<a name="ln1219">                        a1 = cr;</a>
<a name="ln1220">                        }</a>
<a name="ln1221">                  else {</a>
<a name="ln1222">                        beam = a1-&gt;beam();</a>
<a name="ln1223">                        if (beam == 0 || beam-&gt;elements().front() != a1) {</a>
<a name="ln1224">                              beam = new Beam(this);</a>
<a name="ln1225">                              beam-&gt;setGenerated(true);</a>
<a name="ln1226">                              beam-&gt;setTrack(mainNote-&gt;track());</a>
<a name="ln1227">                              a1-&gt;replaceBeam(beam);</a>
<a name="ln1228">                              }</a>
<a name="ln1229">                        cr-&gt;replaceBeam(beam);</a>
<a name="ln1230">                        a1 = 0;</a>
<a name="ln1231">                        }</a>
<a name="ln1232">                  }</a>
<a name="ln1233">            }</a>
<a name="ln1234">      if (beam)</a>
<a name="ln1235">            beam-&gt;layoutGraceNotes();</a>
<a name="ln1236">      else if (a1)</a>
<a name="ln1237">            a1-&gt;removeDeleteBeam(false);</a>
<a name="ln1238">      }</a>
<a name="ln1239"> </a>
<a name="ln1240">#if 0 // unused</a>
<a name="ln1241">//---------------------------------------------------------</a>
<a name="ln1242">//   layoutSpanner</a>
<a name="ln1243">//    called after dragging a staff</a>
<a name="ln1244">//---------------------------------------------------------</a>
<a name="ln1245"> </a>
<a name="ln1246">void Score::layoutSpanner()</a>
<a name="ln1247">      {</a>
<a name="ln1248">      int tracks = ntracks();</a>
<a name="ln1249">      for (int track = 0; track &lt; tracks; ++track) {</a>
<a name="ln1250">            for (Segment* segment = firstSegment(SegmentType::All); segment; segment = segment-&gt;next1()) {</a>
<a name="ln1251">                  if (track == tracks-1) {</a>
<a name="ln1252">                        size_t n = segment-&gt;annotations().size();</a>
<a name="ln1253">                        for (size_t i = 0; i &lt; n; ++i)</a>
<a name="ln1254">                              segment-&gt;annotations().at(i)-&gt;layout();</a>
<a name="ln1255">                        }</a>
<a name="ln1256">                  Element* e = segment-&gt;element(track);</a>
<a name="ln1257">                  if (e &amp;&amp; e-&gt;isChord()) {</a>
<a name="ln1258">                        Chord* c = toChord(segment-&gt;element(track));</a>
<a name="ln1259">                        c-&gt;layoutStem();</a>
<a name="ln1260">                        for (Note* n : c-&gt;notes()) {</a>
<a name="ln1261">                              Tie* tie = n-&gt;tieFor();</a>
<a name="ln1262">                              if (tie)</a>
<a name="ln1263">                                    tie-&gt;layout();</a>
<a name="ln1264">                              for (Spanner* sp : n-&gt;spannerFor())</a>
<a name="ln1265">                                    sp-&gt;layout();</a>
<a name="ln1266">                              }</a>
<a name="ln1267">                        }</a>
<a name="ln1268">                  }</a>
<a name="ln1269">            }</a>
<a name="ln1270">      rebuildBspTree();</a>
<a name="ln1271">      }</a>
<a name="ln1272">#endif</a>
<a name="ln1273"> </a>
<a name="ln1274">//---------------------------------------------------------</a>
<a name="ln1275">//   hideEmptyStaves</a>
<a name="ln1276">//---------------------------------------------------------</a>
<a name="ln1277"> </a>
<a name="ln1278">void Score::hideEmptyStaves(System* system, bool isFirstSystem)</a>
<a name="ln1279">      {</a>
<a name="ln1280">      int staves   = _staves.size();</a>
<a name="ln1281">      int staffIdx = 0;</a>
<a name="ln1282">      bool systemIsEmpty = true;</a>
<a name="ln1283"> </a>
<a name="ln1284">      for (Staff* staff : _staves) {</a>
<a name="ln1285">            SysStaff* ss  = system-&gt;staff(staffIdx);</a>
<a name="ln1286"> </a>
<a name="ln1287">            Staff::HideMode hideMode = staff-&gt;hideWhenEmpty();</a>
<a name="ln1288"> </a>
<a name="ln1289">            if (hideMode == Staff::HideMode::ALWAYS</a>
<a name="ln1290">                || (styleB(Sid::hideEmptyStaves)</a>
<a name="ln1291">                    &amp;&amp; (staves &gt; 1)</a>
<a name="ln1292">                    &amp;&amp; !(isFirstSystem &amp;&amp; styleB(Sid::dontHideStavesInFirstSystem))</a>
<a name="ln1293">                    &amp;&amp; hideMode != Staff::HideMode::NEVER)) {</a>
<a name="ln1294">                  bool hideStaff = true;</a>
<a name="ln1295">                  for (MeasureBase* m : system-&gt;measures()) {</a>
<a name="ln1296">                        if (!m-&gt;isMeasure())</a>
<a name="ln1297">                              continue;</a>
<a name="ln1298">                        Measure* measure = toMeasure(m);</a>
<a name="ln1299">                        if (!measure-&gt;isEmpty(staffIdx)) {</a>
<a name="ln1300">                              hideStaff = false;</a>
<a name="ln1301">                              break;</a>
<a name="ln1302">                              }</a>
<a name="ln1303">                        }</a>
<a name="ln1304">                  // check if notes moved into this staff</a>
<a name="ln1305">                  Part* part = staff-&gt;part();</a>
<a name="ln1306">                  int n = part-&gt;nstaves();</a>
<a name="ln1307">                  if (hideStaff &amp;&amp; (n &gt; 1)) {</a>
<a name="ln1308">                        int idx = part-&gt;staves()-&gt;front()-&gt;idx();</a>
<a name="ln1309">                        for (int i = 0; i &lt; part-&gt;nstaves(); ++i) {</a>
<a name="ln1310">                              int st = idx + i;</a>
<a name="ln1311"> </a>
<a name="ln1312">                              for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln1313">                                    if (!mb-&gt;isMeasure())</a>
<a name="ln1314">                                          continue;</a>
<a name="ln1315">                                    Measure* m = toMeasure(mb);</a>
<a name="ln1316">                                    if (staff-&gt;hideWhenEmpty() == Staff::HideMode::INSTRUMENT &amp;&amp; !m-&gt;isEmpty(st)) {</a>
<a name="ln1317">                                          hideStaff = false;</a>
<a name="ln1318">                                          break;</a>
<a name="ln1319">                                          }</a>
<a name="ln1320">                                    for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln1321">                                          for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln1322">                                                ChordRest* cr = s-&gt;cr(st * VOICES + voice);</a>
<a name="ln1323">                                                if (cr == 0 || cr-&gt;isRest())</a>
<a name="ln1324">                                                      continue;</a>
<a name="ln1325">                                                int staffMove = cr-&gt;staffMove();</a>
<a name="ln1326">                                                if (staffIdx == st + staffMove) {</a>
<a name="ln1327">                                                      hideStaff = false;</a>
<a name="ln1328">                                                      break;</a>
<a name="ln1329">                                                      }</a>
<a name="ln1330">                                                }</a>
<a name="ln1331">                                          }</a>
<a name="ln1332">                                    if (!hideStaff)</a>
<a name="ln1333">                                          break;</a>
<a name="ln1334">                                    }</a>
<a name="ln1335">                              if (!hideStaff)</a>
<a name="ln1336">                                    break;</a>
<a name="ln1337">                              }</a>
<a name="ln1338">                        }</a>
<a name="ln1339">                  ss-&gt;setShow(hideStaff ? false : staff-&gt;show());</a>
<a name="ln1340">                  if (ss-&gt;show())</a>
<a name="ln1341">                        systemIsEmpty = false;</a>
<a name="ln1342">                  }</a>
<a name="ln1343">            else if (!staff-&gt;show()) {</a>
<a name="ln1344">                  // TODO: OK to check this first and not bother with checking if empty?</a>
<a name="ln1345">                  ss-&gt;setShow(false);</a>
<a name="ln1346">                  }</a>
<a name="ln1347">            else {</a>
<a name="ln1348">                  systemIsEmpty = false;</a>
<a name="ln1349">                  ss-&gt;setShow(true);</a>
<a name="ln1350">                  }</a>
<a name="ln1351"> </a>
<a name="ln1352">            ++staffIdx;</a>
<a name="ln1353">            }</a>
<a name="ln1354">      Staff* firstVisible = nullptr;</a>
<a name="ln1355">      if (systemIsEmpty) {</a>
<a name="ln1356">            for (Staff* staff : _staves) {</a>
<a name="ln1357">                  SysStaff* ss  = system-&gt;staff(staff-&gt;idx());</a>
<a name="ln1358">                  if (staff-&gt;showIfEmpty() &amp;&amp; !ss-&gt;show()) {</a>
<a name="ln1359">                        ss-&gt;setShow(true);</a>
<a name="ln1360">                        systemIsEmpty = false;</a>
<a name="ln1361">                        }</a>
<a name="ln1362">                  else if (!firstVisible &amp;&amp; staff-&gt;show()) {</a>
<a name="ln1363">                        firstVisible = staff;</a>
<a name="ln1364">                        }</a>
<a name="ln1365">                  }</a>
<a name="ln1366">            }</a>
<a name="ln1367">      // dont allow a complete empty system</a>
<a name="ln1368">      if (systemIsEmpty) {</a>
<a name="ln1369">            Staff* staff = firstVisible ? firstVisible : _staves.front();</a>
<a name="ln1370">            SysStaff* ss = system-&gt;staff(staff-&gt;idx());</a>
<a name="ln1371">            ss-&gt;setShow(true);</a>
<a name="ln1372">            }</a>
<a name="ln1373">      }</a>
<a name="ln1374"> </a>
<a name="ln1375">//---------------------------------------------------------</a>
<a name="ln1376">//   connectTies</a>
<a name="ln1377">///   Rebuild tie connections.</a>
<a name="ln1378">//---------------------------------------------------------</a>
<a name="ln1379"> </a>
<a name="ln1380">void Score::connectTies(bool silent)</a>
<a name="ln1381">      {</a>
<a name="ln1382">      int tracks = nstaves() * VOICES;</a>
<a name="ln1383">      Measure* m = firstMeasure();</a>
<a name="ln1384">      if (!m)</a>
<a name="ln1385">            return;</a>
<a name="ln1386"> </a>
<a name="ln1387">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln1388">      for (Segment* s = m-&gt;first(st); s; s = s-&gt;next1(st)) {</a>
<a name="ln1389">            for (int i = 0; i &lt; tracks; ++i) {</a>
<a name="ln1390">                  Element* e = s-&gt;element(i);</a>
<a name="ln1391">                  if (e == 0 || !e-&gt;isChord())</a>
<a name="ln1392">                        continue;</a>
<a name="ln1393">                  Chord* c = toChord(e);</a>
<a name="ln1394">                  for (Note* n : c-&gt;notes()) {</a>
<a name="ln1395">                        // connect a tie without end note</a>
<a name="ln1396">                        Tie* tie = n-&gt;tieFor();</a>
<a name="ln1397">                        if (tie &amp;&amp; !tie-&gt;endNote()) {</a>
<a name="ln1398">                              Note* nnote;</a>
<a name="ln1399">                              if (_mscVersion &lt;= 114)</a>
<a name="ln1400">                                    nnote = searchTieNote114(n);</a>
<a name="ln1401">                              else</a>
<a name="ln1402">                                    nnote = searchTieNote(n);</a>
<a name="ln1403">                              if (nnote == 0) {</a>
<a name="ln1404">                                    if (!silent) {</a>
<a name="ln1405">                                          qDebug(&quot;next note at %d track %d for tie not found (version %d)&quot;, s-&gt;tick().ticks(), i, _mscVersion);</a>
<a name="ln1406">                                          delete tie;</a>
<a name="ln1407">                                          n-&gt;setTieFor(0);</a>
<a name="ln1408">                                          }</a>
<a name="ln1409">                                    }</a>
<a name="ln1410">                              else {</a>
<a name="ln1411">                                    tie-&gt;setEndNote(nnote);</a>
<a name="ln1412">                                    nnote-&gt;setTieBack(tie);</a>
<a name="ln1413">                                    }</a>
<a name="ln1414">                              }</a>
<a name="ln1415">                        // connect a glissando without initial note (old glissando format)</a>
<a name="ln1416">                        for (Spanner* spanner : n-&gt;spannerBack()) {</a>
<a name="ln1417">                              if (spanner-&gt;isGlissando() &amp;&amp; !spanner-&gt;startElement()) {</a>
<a name="ln1418">                                    Note* initialNote = Glissando::guessInitialNote(n-&gt;chord());</a>
<a name="ln1419">                                    n-&gt;removeSpannerBack(spanner);</a>
<a name="ln1420">                                    if (initialNote) {</a>
<a name="ln1421">                                          spanner-&gt;setStartElement(initialNote);</a>
<a name="ln1422">                                          spanner-&gt;setEndElement(n);</a>
<a name="ln1423">                                          spanner-&gt;setTick(initialNote-&gt;chord()-&gt;tick());</a>
<a name="ln1424">                                          spanner-&gt;setTick2(n-&gt;chord()-&gt;tick());</a>
<a name="ln1425">                                          spanner-&gt;setTrack(n-&gt;track());</a>
<a name="ln1426">                                          spanner-&gt;setTrack2(n-&gt;track());</a>
<a name="ln1427">                                          spanner-&gt;setParent(initialNote);</a>
<a name="ln1428">                                          initialNote-&gt;add(spanner);</a>
<a name="ln1429">                                          }</a>
<a name="ln1430">                                    else {</a>
<a name="ln1431">                                          delete spanner;</a>
<a name="ln1432">                                          }</a>
<a name="ln1433">                                    }</a>
<a name="ln1434">                              }</a>
<a name="ln1435">                        // spanner with no end element can happen during copy/paste</a>
<a name="ln1436">                        for (Spanner* spanner : n-&gt;spannerFor()) {</a>
<a name="ln1437">                              if (spanner-&gt;endElement() == nullptr) {</a>
<a name="ln1438">                                    n-&gt;removeSpannerFor(spanner);</a>
<a name="ln1439">                                    delete spanner;</a>
<a name="ln1440">                                    }</a>
<a name="ln1441">                              }</a>
<a name="ln1442">                        }</a>
<a name="ln1443">#if 0    // chords are set in tremolo-&gt;layout()</a>
<a name="ln1444">                  // connect two note tremolos</a>
<a name="ln1445">                  Tremolo* tremolo = c-&gt;tremolo();</a>
<a name="ln1446">                  if (tremolo &amp;&amp; tremolo-&gt;twoNotes() &amp;&amp; !tremolo-&gt;chord2()) {</a>
<a name="ln1447">                        for (Segment* ls = s-&gt;next1(st); ls; ls = ls-&gt;next1(st)) {</a>
<a name="ln1448">                              Element* element = ls-&gt;element(i);</a>
<a name="ln1449">                              if (!element)</a>
<a name="ln1450">                                    continue;</a>
<a name="ln1451">                              if (!element-&gt;isChord())</a>
<a name="ln1452">                                    qDebug(&quot;cannot connect tremolo&quot;);</a>
<a name="ln1453">                              else {</a>
<a name="ln1454">                                    Chord* nc = toChord(element);</a>
<a name="ln1455">                                    nc-&gt;setTremolo(tremolo);</a>
<a name="ln1456">                                    tremolo-&gt;setChords(c, nc);</a>
<a name="ln1457">                                    // cross-measure tremolos are not supported</a>
<a name="ln1458">                                    // but can accidentally result from copy &amp; paste</a>
<a name="ln1459">                                    // remove them now</a>
<a name="ln1460">                                    if (c-&gt;measure() != nc-&gt;measure())</a>
<a name="ln1461">                                          c-&gt;remove(tremolo);</a>
<a name="ln1462">                                    }</a>
<a name="ln1463">                              break;</a>
<a name="ln1464">                              }</a>
<a name="ln1465">                        }</a>
<a name="ln1466">#endif</a>
<a name="ln1467">                  }</a>
<a name="ln1468">            }</a>
<a name="ln1469">      }</a>
<a name="ln1470"> </a>
<a name="ln1471">//---------------------------------------------------------</a>
<a name="ln1472">//   checkDivider</a>
<a name="ln1473">//---------------------------------------------------------</a>
<a name="ln1474"> </a>
<a name="ln1475">static void checkDivider(bool left, System* s, qreal yOffset, bool remove = false)</a>
<a name="ln1476">      {</a>
<a name="ln1477">      SystemDivider* divider = left ? s-&gt;systemDividerLeft() : s-&gt;systemDividerRight();</a>
<a name="ln1478">      if ((s-&gt;score()-&gt;styleB(left ? Sid::dividerLeft : Sid::dividerRight)) &amp;&amp; !remove) {</a>
<a name="ln1479">            if (!divider) {</a>
<a name="ln1480">                  divider = new SystemDivider(s-&gt;score());</a>
<a name="ln1481">                  divider-&gt;setDividerType(left ? SystemDivider::Type::LEFT : SystemDivider::Type::RIGHT);</a>
<a name="ln1482">                  divider-&gt;setGenerated(true);</a>
<a name="ln1483">                  s-&gt;add(divider);</a>
<a name="ln1484">                  }</a>
<a name="ln1485">            divider-&gt;layout();</a>
<a name="ln1486">            divider-&gt;rypos() = divider-&gt;height() * .5 + yOffset;</a>
<a name="ln1487">            if (left) {</a>
<a name="ln1488">                  divider-&gt;rypos() += s-&gt;score()-&gt;styleD(Sid::dividerLeftY) * SPATIUM20;</a>
<a name="ln1489">                  divider-&gt;rxpos() =  s-&gt;score()-&gt;styleD(Sid::dividerLeftX) * SPATIUM20;</a>
<a name="ln1490">                  }</a>
<a name="ln1491">            else {</a>
<a name="ln1492">                  divider-&gt;rypos() += s-&gt;score()-&gt;styleD(Sid::dividerRightY) * SPATIUM20;</a>
<a name="ln1493">                  divider-&gt;rxpos() =  s-&gt;score()-&gt;styleD(Sid::pagePrintableWidth) * DPI - divider-&gt;width();</a>
<a name="ln1494">                  divider-&gt;rxpos() += s-&gt;score()-&gt;styleD(Sid::dividerRightX) * SPATIUM20;</a>
<a name="ln1495">                  }</a>
<a name="ln1496">            }</a>
<a name="ln1497">      else if (divider) {</a>
<a name="ln1498">            if (divider-&gt;generated()) {</a>
<a name="ln1499">                  s-&gt;remove(divider);</a>
<a name="ln1500">                  delete divider;</a>
<a name="ln1501">                  }</a>
<a name="ln1502">            else</a>
<a name="ln1503">                  s-&gt;score()-&gt;undoRemoveElement(divider);</a>
<a name="ln1504">            }</a>
<a name="ln1505">      }</a>
<a name="ln1506"> </a>
<a name="ln1507">//---------------------------------------------------------</a>
<a name="ln1508">//   layoutPage</a>
<a name="ln1509">//    restHeight - vertical space which has to be distributed</a>
<a name="ln1510">//                 between systems</a>
<a name="ln1511">//    The algorithm tries to produce most equally spaced</a>
<a name="ln1512">//    systems.</a>
<a name="ln1513">//---------------------------------------------------------</a>
<a name="ln1514"> </a>
<a name="ln1515">static void layoutPage(Page* page, qreal restHeight)</a>
<a name="ln1516">      {</a>
<a name="ln1517">      if (restHeight &lt; 0.0) {</a>
<a name="ln1518">            qDebug(&quot;restHeight &lt; 0.0: %f\n&quot;, restHeight);</a>
<a name="ln1519">            restHeight = 0;</a>
<a name="ln1520">            }</a>
<a name="ln1521"> </a>
<a name="ln1522">      Score* score = page-&gt;score();</a>
<a name="ln1523">      int gaps     = page-&gt;systems().size() - 1;</a>
<a name="ln1524"> </a>
<a name="ln1525">      QList&lt;System*&gt; sList;</a>
<a name="ln1526"> </a>
<a name="ln1527">      // build list of systems (excluding last)</a>
<a name="ln1528">      // set initial distance for each to the unstretched minimum distance to next</a>
<a name="ln1529">      for (int i = 0; i &lt; gaps; ++i) {</a>
<a name="ln1530">            System* s1 = page-&gt;systems().at(i);</a>
<a name="ln1531">            System* s2 = page-&gt;systems().at(i+1);</a>
<a name="ln1532">            s1-&gt;setDistance(s2-&gt;y() - s1-&gt;y());</a>
<a name="ln1533">            if (s1-&gt;vbox() || s2-&gt;vbox() || s1-&gt;hasFixedDownDistance())</a>
<a name="ln1534">                  continue;</a>
<a name="ln1535">            sList.push_back(s1);</a>
<a name="ln1536">            }</a>
<a name="ln1537"> </a>
<a name="ln1538">      // last systenm needs no divider</a>
<a name="ln1539">      System* lastSystem = page-&gt;systems().back();</a>
<a name="ln1540">      checkDivider(true, lastSystem, 0.0, true);      // remove</a>
<a name="ln1541">      checkDivider(false, lastSystem, 0.0, true);     // remove</a>
<a name="ln1542"> </a>
<a name="ln1543">      if (sList.empty() || MScore::noVerticalStretch || score-&gt;layoutMode() == LayoutMode::SYSTEM) {</a>
<a name="ln1544">            if (score-&gt;layoutMode() == LayoutMode::FLOAT) {</a>
<a name="ln1545">                  qreal y = restHeight * .5;</a>
<a name="ln1546">                  for (System* system : page-&gt;systems())</a>
<a name="ln1547">                        system-&gt;move(QPointF(0.0, y));</a>
<a name="ln1548">                  }</a>
<a name="ln1549">            // system dividers</a>
<a name="ln1550">            for (int i = 0; i &lt; gaps; ++i) {</a>
<a name="ln1551">                  System* s1 = page-&gt;systems().at(i);</a>
<a name="ln1552">                  System* s2 = page-&gt;systems().at(i+1);</a>
<a name="ln1553">                  if (!(s1-&gt;vbox() || s2-&gt;vbox())) {</a>
<a name="ln1554">                        qreal yOffset = s1-&gt;height() + (s1-&gt;distance()-s1-&gt;height()) * .5;</a>
<a name="ln1555">                        checkDivider(true,  s1, yOffset);</a>
<a name="ln1556">                        checkDivider(false, s1, yOffset);</a>
<a name="ln1557">                        }</a>
<a name="ln1558">                  }</a>
<a name="ln1559">            return;</a>
<a name="ln1560">            }</a>
<a name="ln1561"> </a>
<a name="ln1562">      qreal maxDist = score-&gt;styleP(Sid::maxSystemDistance);</a>
<a name="ln1563"> </a>
<a name="ln1564">      // allocate space as needed to normalize system distance (bottom of one system to top of next)</a>
<a name="ln1565">      std::sort(sList.begin(), sList.end(), [](System* a, System* b) { return a-&gt;distance() - a-&gt;height() &lt; b-&gt;distance() - b-&gt;height(); });</a>
<a name="ln1566">      System* s0 = sList[0];</a>
<a name="ln1567">      qreal dist = s0-&gt;distance() - s0-&gt;height();           // distance for shortest system</a>
<a name="ln1568">      for (int i = 1; i &lt; sList.size(); ++i) {</a>
<a name="ln1569">            System* si = sList[i];</a>
<a name="ln1570">            qreal ndist = si-&gt;distance() - si-&gt;height();    // next taller system</a>
<a name="ln1571">            qreal fill  = ndist - dist;                     // amount by which this system distance exceeds next shorter</a>
<a name="ln1572">            if (fill &gt; 0.0) {</a>
<a name="ln1573">                  qreal totalFill = fill * i;               // space required to add this amount to all shorter systems</a>
<a name="ln1574">                  if (totalFill &gt; restHeight) {</a>
<a name="ln1575">                        totalFill = restHeight;             // too much; adjust amount</a>
<a name="ln1576">                        fill = restHeight / i;</a>
<a name="ln1577">                        }</a>
<a name="ln1578">                  for (int k = 0; k &lt; i; ++k) {             // add amount to all shorter systems</a>
<a name="ln1579">                        System* s = sList[k];</a>
<a name="ln1580">                        qreal d = s-&gt;distance() + fill;</a>
<a name="ln1581">                        if ((d - s-&gt;height()) &gt; maxDist)    // but don't exceed max system distance</a>
<a name="ln1582">                              d = qMax(maxDist + s-&gt;height(), s-&gt;distance());</a>
<a name="ln1583">                        s-&gt;setDistance(d);</a>
<a name="ln1584">                        }</a>
<a name="ln1585">                  restHeight -= totalFill;                  // reduce available space for next iteration</a>
<a name="ln1586">                  if (restHeight &lt;= 0)</a>
<a name="ln1587">                        break;                              // no space left</a>
<a name="ln1588">                  }</a>
<a name="ln1589">            dist = ndist;                                   // set up for next iteration</a>
<a name="ln1590">            }</a>
<a name="ln1591"> </a>
<a name="ln1592">      if (restHeight &gt; 0.0) {                               // space left?</a>
<a name="ln1593">            qreal fill = restHeight / sList.size();</a>
<a name="ln1594">            for (System* s : sList) {                       // allocate it to systems equally</a>
<a name="ln1595">                  qreal d = s-&gt;distance() + fill;</a>
<a name="ln1596">                  if ((d - s-&gt;height()) &gt; maxDist)          // but don't exceed max system distance</a>
<a name="ln1597">                        d = qMax(maxDist + s-&gt;height(), s-&gt;distance());</a>
<a name="ln1598">                  s-&gt;setDistance(d);</a>
<a name="ln1599">                  }</a>
<a name="ln1600">            }</a>
<a name="ln1601"> </a>
<a name="ln1602">      qreal y = page-&gt;systems().at(0)-&gt;y();</a>
<a name="ln1603">      for (int i = 0; i &lt; gaps; ++i) {</a>
<a name="ln1604">            System* s1  = page-&gt;systems().at(i);</a>
<a name="ln1605">            System* s2  = page-&gt;systems().at(i+1);</a>
<a name="ln1606">            s1-&gt;rypos() = y;</a>
<a name="ln1607">            y          += s1-&gt;distance();</a>
<a name="ln1608"> </a>
<a name="ln1609">            if (!(s1-&gt;vbox() || s2-&gt;vbox())) {</a>
<a name="ln1610">                  qreal yOffset = s1-&gt;height() + (s1-&gt;distance()-s1-&gt;height()) * .5;</a>
<a name="ln1611">                  checkDivider(true,  s1, yOffset);</a>
<a name="ln1612">                  checkDivider(false, s1, yOffset);</a>
<a name="ln1613">                  }</a>
<a name="ln1614">            }</a>
<a name="ln1615">      page-&gt;systems().back()-&gt;rypos() = y;</a>
<a name="ln1616">      }</a>
<a name="ln1617"> </a>
<a name="ln1618">//---------------------------------------------------------</a>
<a name="ln1619">//   Spring</a>
<a name="ln1620">//---------------------------------------------------------</a>
<a name="ln1621"> </a>
<a name="ln1622">struct Spring {</a>
<a name="ln1623">      int seg;</a>
<a name="ln1624">      qreal stretch;</a>
<a name="ln1625">      qreal fix;</a>
<a name="ln1626">      Spring(int i, qreal s, qreal f) : seg(i), stretch(s), fix(f) {}</a>
<a name="ln1627">      };</a>
<a name="ln1628"> </a>
<a name="ln1629">typedef std::multimap&lt;qreal, Spring, std::less&lt;qreal&gt; &gt; SpringMap;</a>
<a name="ln1630"> </a>
<a name="ln1631">//---------------------------------------------------------</a>
<a name="ln1632">//   sff2</a>
<a name="ln1633">//    compute 1/Force for a given Extend</a>
<a name="ln1634">//---------------------------------------------------------</a>
<a name="ln1635"> </a>
<a name="ln1636">static qreal sff2(qreal width, qreal xMin, const SpringMap&amp; springs)</a>
<a name="ln1637">      {</a>
<a name="ln1638">      if (width &lt;= xMin)</a>
<a name="ln1639">            return 0.0;</a>
<a name="ln1640">      auto i = springs.begin();</a>
<a name="ln1641">      qreal c  = i-&gt;second.stretch;</a>
<a name="ln1642">      if (c == 0.0)           //DEBUG</a>
<a name="ln1643">            c = 1.1;</a>
<a name="ln1644">      qreal f = 0.0;</a>
<a name="ln1645">      for (; i != springs.end();) {</a>
<a name="ln1646">            xMin -= i-&gt;second.fix;</a>
<a name="ln1647">            f = (width - xMin) / c;</a>
<a name="ln1648">            ++i;</a>
<a name="ln1649">            if (i == springs.end() || f &lt;= i-&gt;first)</a>
<a name="ln1650">                  break;</a>
<a name="ln1651">            c += i-&gt;second.stretch;</a>
<a name="ln1652">            }</a>
<a name="ln1653">      return f;</a>
<a name="ln1654">      }</a>
<a name="ln1655"> </a>
<a name="ln1656">//---------------------------------------------------------</a>
<a name="ln1657">//   respace</a>
<a name="ln1658">//---------------------------------------------------------</a>
<a name="ln1659"> </a>
<a name="ln1660">void Score::respace(std::vector&lt;ChordRest*&gt;* elements)</a>
<a name="ln1661">      {</a>
<a name="ln1662">      ChordRest* cr1 = elements-&gt;front();</a>
<a name="ln1663">      ChordRest* cr2 = elements-&gt;back();</a>
<a name="ln1664">      int n          = int(elements-&gt;size());</a>
<a name="ln1665">      qreal x1       = cr1-&gt;segment()-&gt;pos().x();</a>
<a name="ln1666">      qreal x2       = cr2-&gt;segment()-&gt;pos().x();</a>
<a name="ln1667"> </a>
<a name="ln1668">#if (!defined (_MSCVER) &amp;&amp; !defined (_MSC_VER))</a>
<a name="ln1669">      qreal width[n-1];</a>
<a name="ln1670">      int ticksList[n-1];</a>
<a name="ln1671">#else</a>
<a name="ln1672">      // MSVC does not support VLA. Replace with std::vector. If profiling determines that the</a>
<a name="ln1673">      //    heap allocation is slow, an optimization might be used.</a>
<a name="ln1674">      std::vector&lt;qreal&gt; width(n-1);</a>
<a name="ln1675">      std::vector&lt;int&gt; ticksList(n-1);</a>
<a name="ln1676">#endif</a>
<a name="ln1677">      int minTick = 100000;</a>
<a name="ln1678"> </a>
<a name="ln1679">      for (int i = 0; i &lt; n-1; ++i) {</a>
<a name="ln1680">            ChordRest* cr  = (*elements)[i];</a>
<a name="ln1681">            ChordRest* ncr  = (*elements)[i+1];</a>
<a name="ln1682">            width[i]       = cr-&gt;shape().minHorizontalDistance(ncr-&gt;shape());</a>
<a name="ln1683">            ticksList[i]   = cr-&gt;ticks().ticks();</a>
<a name="ln1684">            minTick = qMin(ticksList[i], minTick);</a>
<a name="ln1685">            }</a>
<a name="ln1686"> </a>
<a name="ln1687">      //---------------------------------------------------</a>
<a name="ln1688">      // compute stretches</a>
<a name="ln1689">      //---------------------------------------------------</a>
<a name="ln1690"> </a>
<a name="ln1691">      SpringMap springs;</a>
<a name="ln1692">      qreal minimum = 0.0;</a>
<a name="ln1693">      for (int i = 0; i &lt; n-1; ++i) {</a>
<a name="ln1694">            qreal w   = width[i];</a>
<a name="ln1695">            int t     = ticksList[i];</a>
<a name="ln1696">            qreal str = 1.0 + 0.865617 * log(qreal(t) / qreal(minTick));</a>
<a name="ln1697">            qreal d   = w / str;</a>
<a name="ln1698"> </a>
<a name="ln1699">            springs.insert(std::pair&lt;qreal, Spring&gt;(d, Spring(i, str, w)));</a>
<a name="ln1700">            minimum += w;</a>
<a name="ln1701">            }</a>
<a name="ln1702"> </a>
<a name="ln1703">      //---------------------------------------------------</a>
<a name="ln1704">      //    distribute stretch to elements</a>
<a name="ln1705">      //---------------------------------------------------</a>
<a name="ln1706"> </a>
<a name="ln1707">      qreal force = sff2(x2 - x1, minimum, springs);</a>
<a name="ln1708">      for (auto i = springs.begin(); i != springs.end(); ++i) {</a>
<a name="ln1709">            qreal stretch = force * i-&gt;second.stretch;</a>
<a name="ln1710">            if (stretch &lt; i-&gt;second.fix)</a>
<a name="ln1711">                  stretch = i-&gt;second.fix;</a>
<a name="ln1712">            width[i-&gt;second.seg] = stretch;</a>
<a name="ln1713">            }</a>
<a name="ln1714">      qreal x = x1;</a>
<a name="ln1715">      for (int i = 1; i &lt; n-1; ++i) {</a>
<a name="ln1716">            x += width[i-1];</a>
<a name="ln1717">            ChordRest* cr = (*elements)[i];</a>
<a name="ln1718">            qreal dx = x - cr-&gt;segment()-&gt;pos().x();</a>
<a name="ln1719">            cr-&gt;rxpos() += dx;</a>
<a name="ln1720">            }</a>
<a name="ln1721">      }</a>
<a name="ln1722"> </a>
<a name="ln1723">//---------------------------------------------------------</a>
<a name="ln1724">//   getNextPage</a>
<a name="ln1725">//---------------------------------------------------------</a>
<a name="ln1726"> </a>
<a name="ln1727">void LayoutContext::getNextPage()</a>
<a name="ln1728">      {</a>
<a name="ln1729">      if (!page || curPage &gt;= score-&gt;npages()) {</a>
<a name="ln1730">            page = new Page(score);</a>
<a name="ln1731">            score-&gt;pages().push_back(page);</a>
<a name="ln1732">            prevSystem = nullptr;</a>
<a name="ln1733">            pageOldMeasure = nullptr;</a>
<a name="ln1734">            }</a>
<a name="ln1735">      else {</a>
<a name="ln1736">            page = score-&gt;pages()[curPage];</a>
<a name="ln1737">            QList&lt;System*&gt;&amp; systems = page-&gt;systems();</a>
<a name="ln1738">            pageOldMeasure = systems.isEmpty() ? nullptr : systems.back()-&gt;measures().back();</a>
<a name="ln1739">            const int i = systems.indexOf(curSystem);</a>
<a name="ln1740">            if (i &gt; 0 &amp;&amp; systems[i-1]-&gt;page() == page) {</a>
<a name="ln1741">                  // Current and previous systems are on the current page.</a>
<a name="ln1742">                  // Erase only the current and the following systems</a>
<a name="ln1743">                  // as the previous one will not participate in layout.</a>
<a name="ln1744">                  systems.erase(systems.begin() + i, systems.end());</a>
<a name="ln1745">                  }</a>
<a name="ln1746">            else // system is not on the current page (or will be the first one)</a>
<a name="ln1747">                  systems.clear();</a>
<a name="ln1748">            prevSystem = systems.empty() ? nullptr : systems.back();</a>
<a name="ln1749">            }</a>
<a name="ln1750">      page-&gt;bbox().setRect(0.0, 0.0, score-&gt;loWidth(), score-&gt;loHeight());</a>
<a name="ln1751">      page-&gt;setNo(curPage);</a>
<a name="ln1752">      qreal x = 0.0;</a>
<a name="ln1753">      qreal y = 0.0;</a>
<a name="ln1754">      if (curPage) {</a>
<a name="ln1755">            Page* prevPage = score-&gt;pages()[curPage - 1];</a>
<a name="ln1756">            if (MScore::verticalOrientation())</a>
<a name="ln1757">                  y = prevPage-&gt;pos().y() + page-&gt;height() + MScore::verticalPageGap;</a>
<a name="ln1758">            else {</a>
<a name="ln1759">                  qreal gap = (curPage + score-&gt;pageNumberOffset()) &amp; 1 ? MScore::horizontalPageGapOdd : MScore::horizontalPageGapEven;</a>
<a name="ln1760">                  x = prevPage-&gt;pos().x() + page-&gt;width() + gap;</a>
<a name="ln1761">                  }</a>
<a name="ln1762">            }</a>
<a name="ln1763">      ++curPage;</a>
<a name="ln1764">      page-&gt;setPos(x, y);</a>
<a name="ln1765">      }</a>
<a name="ln1766"> </a>
<a name="ln1767">//---------------------------------------------------------</a>
<a name="ln1768">//   getNextSystem</a>
<a name="ln1769">//---------------------------------------------------------</a>
<a name="ln1770"> </a>
<a name="ln1771">System* Score::getNextSystem(LayoutContext&amp; lc)</a>
<a name="ln1772">      {</a>
<a name="ln1773">      bool isVBox = lc.curMeasure-&gt;isVBox();</a>
<a name="ln1774">      System* system;</a>
<a name="ln1775">      if (lc.systemList.empty()) {</a>
<a name="ln1776">            system = new System(this);</a>
<a name="ln1777">            lc.systemOldMeasure = 0;</a>
<a name="ln1778">            }</a>
<a name="ln1779">      else {</a>
<a name="ln1780">            system = lc.systemList.takeFirst();</a>
<a name="ln1781">            lc.systemOldMeasure = system-&gt;measures().empty() ? 0 : system-&gt;measures().back();</a>
<a name="ln1782">            system-&gt;clear();   // remove measures from system</a>
<a name="ln1783">            }</a>
<a name="ln1784">      _systems.append(system);</a>
<a name="ln1785">      if (!isVBox) {</a>
<a name="ln1786">            int nstaves = Score::nstaves();</a>
<a name="ln1787">            system-&gt;adjustStavesNumber(nstaves);</a>
<a name="ln1788">            }</a>
<a name="ln1789">      return system;</a>
<a name="ln1790">      }</a>
<a name="ln1791"> </a>
<a name="ln1792">//---------------------------------------------------------</a>
<a name="ln1793">//   createMMRest</a>
<a name="ln1794">//    create a multi measure rest from m to lm (inclusive)</a>
<a name="ln1795">//---------------------------------------------------------</a>
<a name="ln1796"> </a>
<a name="ln1797">void Score::createMMRest(Measure* m, Measure* lm, const Fraction&amp; len)</a>
<a name="ln1798">      {</a>
<a name="ln1799">      int n = 1;</a>
<a name="ln1800">      if (m != lm) {</a>
<a name="ln1801">            for (Measure* mm = m-&gt;nextMeasure(); mm; mm = mm-&gt;nextMeasure()) {</a>
<a name="ln1802">                  ++n;</a>
<a name="ln1803">                  mm-&gt;setMMRestCount(-1);</a>
<a name="ln1804">                  if (mm-&gt;mmRest())</a>
<a name="ln1805">                        undo(new ChangeMMRest(mm, 0));</a>
<a name="ln1806">                  if (mm == lm)</a>
<a name="ln1807">                        break;</a>
<a name="ln1808">                  }</a>
<a name="ln1809">            }</a>
<a name="ln1810"> </a>
<a name="ln1811">      Measure* mmr = m-&gt;mmRest();</a>
<a name="ln1812">      if (mmr) {</a>
<a name="ln1813">            // reuse existing mmrest</a>
<a name="ln1814">            if (mmr-&gt;ticks() != len) {</a>
<a name="ln1815">                  Segment* s = mmr-&gt;findSegmentR(SegmentType::EndBarLine, mmr-&gt;ticks());</a>
<a name="ln1816">                  // adjust length</a>
<a name="ln1817">                  mmr-&gt;setTicks(len);</a>
<a name="ln1818">                  // move existing end barline</a>
<a name="ln1819">                  if (s)</a>
<a name="ln1820">                        s-&gt;setRtick(len);</a>
<a name="ln1821">                  }</a>
<a name="ln1822">            mmr-&gt;removeSystemTrailer();</a>
<a name="ln1823">            }</a>
<a name="ln1824">      else {</a>
<a name="ln1825">            mmr = new Measure(this);</a>
<a name="ln1826">            mmr-&gt;setTicks(len);</a>
<a name="ln1827">            mmr-&gt;setTick(m-&gt;tick());</a>
<a name="ln1828">            undo(new ChangeMMRest(m, mmr));</a>
<a name="ln1829">            }</a>
<a name="ln1830">      mmr-&gt;setTimesig(m-&gt;timesig());</a>
<a name="ln1831">      mmr-&gt;setPageBreak(lm-&gt;pageBreak());</a>
<a name="ln1832">      mmr-&gt;setLineBreak(lm-&gt;lineBreak());</a>
<a name="ln1833">      mmr-&gt;setMMRestCount(n);</a>
<a name="ln1834">      mmr-&gt;setNo(m-&gt;no());</a>
<a name="ln1835"> </a>
<a name="ln1836">      Segment* ss = lm-&gt;findSegmentR(SegmentType::EndBarLine, lm-&gt;ticks());</a>
<a name="ln1837">      if (ss) {</a>
<a name="ln1838">            Segment* ds = mmr-&gt;undoGetSegmentR(SegmentType::EndBarLine, mmr-&gt;ticks());</a>
<a name="ln1839">            for (int staffIdx = 0; staffIdx &lt; nstaves(); ++staffIdx) {</a>
<a name="ln1840">                  Element* e = ss-&gt;element(staffIdx * VOICES);</a>
<a name="ln1841">                  if (e) {</a>
<a name="ln1842">                        bool generated = e-&gt;generated();</a>
<a name="ln1843">                        if (!ds-&gt;element(staffIdx * VOICES)) {</a>
<a name="ln1844">                              Element* ee = generated ? e-&gt;clone() : e-&gt;linkedClone();</a>
<a name="ln1845">                              ee-&gt;setGenerated(generated);</a>
<a name="ln1846">                              ee-&gt;setParent(ds);</a>
<a name="ln1847">                              undoAddElement(ee);</a>
<a name="ln1848">                              }</a>
<a name="ln1849">                        else {</a>
<a name="ln1850">                              BarLine* bd = toBarLine(ds-&gt;element(staffIdx * VOICES));</a>
<a name="ln1851">                              BarLine* bs = toBarLine(e);</a>
<a name="ln1852">                              if (!generated &amp;&amp; !bd-&gt;links())</a>
<a name="ln1853">                                    undo(new Link(bd, bs));</a>
<a name="ln1854">                              if (bd-&gt;barLineType() != bs-&gt;barLineType()) {</a>
<a name="ln1855">                                    // change directly when generating mmrests, do not change underlying measures or follow links</a>
<a name="ln1856">                                    undo(new ChangeProperty(bd, Pid::BARLINE_TYPE, QVariant::fromValue(bs-&gt;barLineType()), PropertyFlags::NOSTYLE));</a>
<a name="ln1857">                                    undo(new ChangeProperty(bd, Pid::GENERATED, generated, PropertyFlags::NOSTYLE));</a>
<a name="ln1858">                                    }</a>
<a name="ln1859">                              }</a>
<a name="ln1860">                        }</a>
<a name="ln1861">                  }</a>
<a name="ln1862">            }</a>
<a name="ln1863"> </a>
<a name="ln1864">      Segment* clefSeg = lm-&gt;findSegmentR(SegmentType::Clef | SegmentType::HeaderClef, lm-&gt;ticks());</a>
<a name="ln1865">      if (clefSeg) {</a>
<a name="ln1866">            Segment* mmrClefSeg = mmr-&gt;undoGetSegment(clefSeg-&gt;segmentType(), lm-&gt;endTick());</a>
<a name="ln1867">            for (int staffIdx = 0; staffIdx &lt; nstaves(); ++staffIdx) {</a>
<a name="ln1868">                  const int track = staff2track(staffIdx);</a>
<a name="ln1869">                  Element* e = clefSeg-&gt;element(track);</a>
<a name="ln1870">                  if (e &amp;&amp; e-&gt;isClef()) {</a>
<a name="ln1871">                        Clef* clef = toClef(e);</a>
<a name="ln1872">                        if (!mmrClefSeg-&gt;element(track)) {</a>
<a name="ln1873">                              Clef* mmrClef = clef-&gt;generated() ? clef-&gt;clone() : toClef(clef-&gt;linkedClone());</a>
<a name="ln1874">                              mmrClef-&gt;setParent(mmrClefSeg);</a>
<a name="ln1875">                              undoAddElement(mmrClef);</a>
<a name="ln1876">                              }</a>
<a name="ln1877">                        else {</a>
<a name="ln1878">                              Clef* mmrClef = toClef(mmrClefSeg-&gt;element(track));</a>
<a name="ln1879">                              mmrClef-&gt;setClefType(clef-&gt;clefType());</a>
<a name="ln1880">                              mmrClef-&gt;setShowCourtesy(clef-&gt;showCourtesy());</a>
<a name="ln1881">                              }</a>
<a name="ln1882">                        }</a>
<a name="ln1883">                  }</a>
<a name="ln1884">            }</a>
<a name="ln1885"> </a>
<a name="ln1886">      mmr-&gt;setRepeatStart(m-&gt;repeatStart() || lm-&gt;repeatStart());</a>
<a name="ln1887">      mmr-&gt;setRepeatEnd(m-&gt;repeatEnd() || lm-&gt;repeatEnd());</a>
<a name="ln1888">      mmr-&gt;setSectionBreak(lm-&gt;sectionBreak());</a>
<a name="ln1889"> </a>
<a name="ln1890">      ElementList oldList = mmr-&gt;takeElements();</a>
<a name="ln1891">      ElementList newList = lm-&gt;el();</a>
<a name="ln1892"> </a>
<a name="ln1893">      for (Element* e : m-&gt;el()) {</a>
<a name="ln1894">            if (e-&gt;isMarker())</a>
<a name="ln1895">                  newList.push_back(e);</a>
<a name="ln1896">            }</a>
<a name="ln1897">      for (Element* e : newList) {</a>
<a name="ln1898">            bool found = false;</a>
<a name="ln1899">            for (Element* ee : oldList) {</a>
<a name="ln1900">                  if (ee-&gt;type() == e-&gt;type() &amp;&amp; ee-&gt;subtype() == e-&gt;subtype()) {</a>
<a name="ln1901">                        mmr-&gt;add(ee);</a>
<a name="ln1902">                        auto i = std::find(oldList.begin(), oldList.end(), ee);</a>
<a name="ln1903">                        if (i != oldList.end())</a>
<a name="ln1904">                              oldList.erase(i);</a>
<a name="ln1905">                        found = true;</a>
<a name="ln1906">                        break;</a>
<a name="ln1907">                        }</a>
<a name="ln1908">                  }</a>
<a name="ln1909">            if (!found)</a>
<a name="ln1910">                  mmr-&gt;add(e-&gt;clone());</a>
<a name="ln1911">            }</a>
<a name="ln1912">      for (Element* e : oldList)</a>
<a name="ln1913">            delete e;</a>
<a name="ln1914">      Segment* s = mmr-&gt;undoGetSegmentR(SegmentType::ChordRest, Fraction(0,1));</a>
<a name="ln1915">      for (int staffIdx = 0; staffIdx &lt; _staves.size(); ++staffIdx) {</a>
<a name="ln1916">            int track = staffIdx * VOICES;</a>
<a name="ln1917">            if (s-&gt;element(track) == 0) {</a>
<a name="ln1918">                  Rest* r = new Rest(this);</a>
<a name="ln1919">                  r-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln1920">                  r-&gt;setTicks(mmr-&gt;ticks());</a>
<a name="ln1921">                  r-&gt;setTrack(track);</a>
<a name="ln1922">                  r-&gt;setParent(s);</a>
<a name="ln1923">                  undo(new AddElement(r));</a>
<a name="ln1924">                  }</a>
<a name="ln1925">            }</a>
<a name="ln1926"> </a>
<a name="ln1927">      //</a>
<a name="ln1928">      // check for clefs</a>
<a name="ln1929">      //</a>
<a name="ln1930">      Segment* cs = lm-&gt;findSegmentR(SegmentType::Clef, lm-&gt;ticks());</a>
<a name="ln1931">      Segment* ns = mmr-&gt;findSegment(SegmentType::Clef, lm-&gt;endTick());</a>
<a name="ln1932">      if (cs) {</a>
<a name="ln1933">            if (ns == 0)</a>
<a name="ln1934">                  ns = mmr-&gt;undoGetSegmentR(SegmentType::Clef, lm-&gt;ticks());</a>
<a name="ln1935">            ns-&gt;setEnabled(cs-&gt;enabled());</a>
<a name="ln1936">            ns-&gt;setTrailer(cs-&gt;trailer());</a>
<a name="ln1937">            for (int staffIdx = 0; staffIdx &lt; _staves.size(); ++staffIdx) {</a>
<a name="ln1938">                  int track = staffIdx * VOICES;</a>
<a name="ln1939">                  Clef* clef = toClef(cs-&gt;element(track));</a>
<a name="ln1940">                  if (clef) {</a>
<a name="ln1941">                        if (ns-&gt;element(track) == 0)</a>
<a name="ln1942">                              ns-&gt;add(clef-&gt;clone());</a>
<a name="ln1943">                        else {</a>
<a name="ln1944">                              //TODO: check if same clef</a>
<a name="ln1945">                              }</a>
<a name="ln1946">                        }</a>
<a name="ln1947">                  }</a>
<a name="ln1948">            }</a>
<a name="ln1949">      else if (ns) {</a>
<a name="ln1950">            // TODO: remove elements from ns?</a>
<a name="ln1951">            undo(new RemoveElement(ns));</a>
<a name="ln1952">            }</a>
<a name="ln1953"> </a>
<a name="ln1954">      //</a>
<a name="ln1955">      // check for time signature</a>
<a name="ln1956">      //</a>
<a name="ln1957">      cs = m-&gt;findSegmentR(SegmentType::TimeSig, Fraction(0,1));</a>
<a name="ln1958">      ns = mmr-&gt;findSegment(SegmentType::TimeSig, m-&gt;tick());</a>
<a name="ln1959">      if (cs) {</a>
<a name="ln1960">            if (ns == 0)</a>
<a name="ln1961">                  ns = mmr-&gt;undoGetSegmentR(SegmentType::TimeSig, Fraction(0,1));</a>
<a name="ln1962">            ns-&gt;setEnabled(cs-&gt;enabled());</a>
<a name="ln1963">            ns-&gt;setHeader(cs-&gt;header());</a>
<a name="ln1964">            for (int staffIdx = 0; staffIdx &lt; _staves.size(); ++staffIdx) {</a>
<a name="ln1965">                  int track = staffIdx * VOICES;</a>
<a name="ln1966">                  TimeSig* ts = toTimeSig(cs-&gt;element(track));</a>
<a name="ln1967">                  if (ts) {</a>
<a name="ln1968">                        TimeSig* nts = toTimeSig(ns-&gt;element(track));</a>
<a name="ln1969">                        if (!nts) {</a>
<a name="ln1970">                              nts = ts-&gt;generated() ? ts-&gt;clone() : toTimeSig(ts-&gt;linkedClone());</a>
<a name="ln1971">                              nts-&gt;setParent(ns);</a>
<a name="ln1972">                              undo(new AddElement(nts));</a>
<a name="ln1973">                              }</a>
<a name="ln1974">                        else {</a>
<a name="ln1975">                              nts-&gt;setSig(ts-&gt;sig(), ts-&gt;timeSigType());</a>
<a name="ln1976">                              nts-&gt;layout();</a>
<a name="ln1977">                              }</a>
<a name="ln1978">                        }</a>
<a name="ln1979">                  }</a>
<a name="ln1980">            }</a>
<a name="ln1981">      else if (ns) {</a>
<a name="ln1982">            // TODO: remove elements from ns?</a>
<a name="ln1983">            undo(new RemoveElement(ns));</a>
<a name="ln1984">            }</a>
<a name="ln1985"> </a>
<a name="ln1986">      //</a>
<a name="ln1987">      // check for ambitus</a>
<a name="ln1988">      //</a>
<a name="ln1989">      cs = m-&gt;findSegmentR(SegmentType::Ambitus, Fraction(0,1));</a>
<a name="ln1990">      ns = mmr-&gt;findSegment(SegmentType::Ambitus, m-&gt;tick());</a>
<a name="ln1991">      if (cs) {</a>
<a name="ln1992">            if (ns == 0)</a>
<a name="ln1993">                  ns = mmr-&gt;undoGetSegmentR(SegmentType::Ambitus, Fraction(0,1));</a>
<a name="ln1994">            for (int staffIdx = 0; staffIdx &lt; _staves.size(); ++staffIdx) {</a>
<a name="ln1995">                  int track = staffIdx * VOICES;</a>
<a name="ln1996">                  Ambitus* a = toAmbitus(cs-&gt;element(track));</a>
<a name="ln1997">                  if (a) {</a>
<a name="ln1998">                        Ambitus* na = toAmbitus(ns-&gt;element(track));</a>
<a name="ln1999">                        if (!na) {</a>
<a name="ln2000">                              na = a-&gt;clone();</a>
<a name="ln2001">                              na-&gt;setParent(ns);</a>
<a name="ln2002">                              undo(new AddElement(na));</a>
<a name="ln2003">                              }</a>
<a name="ln2004">                        else {</a>
<a name="ln2005">                              na-&gt;initFrom(a);</a>
<a name="ln2006">                              na-&gt;layout();</a>
<a name="ln2007">                              }</a>
<a name="ln2008">                        }</a>
<a name="ln2009">                  }</a>
<a name="ln2010">            }</a>
<a name="ln2011">      else if (ns) {</a>
<a name="ln2012">            // TODO: remove elements from ns?</a>
<a name="ln2013">            undo(new RemoveElement(ns));</a>
<a name="ln2014">            }</a>
<a name="ln2015"> </a>
<a name="ln2016">      //</a>
<a name="ln2017">      // check for key signature</a>
<a name="ln2018">      //</a>
<a name="ln2019">      cs = m-&gt;findSegmentR(SegmentType::KeySig, Fraction(0,1));</a>
<a name="ln2020">      ns = mmr-&gt;findSegmentR(SegmentType::KeySig, Fraction(0,1));</a>
<a name="ln2021">      if (cs) {</a>
<a name="ln2022">            if (ns == 0)</a>
<a name="ln2023">                  ns = mmr-&gt;undoGetSegmentR(SegmentType::KeySig, Fraction(0,1));</a>
<a name="ln2024">            ns-&gt;setEnabled(cs-&gt;enabled());</a>
<a name="ln2025">            ns-&gt;setHeader(cs-&gt;header());</a>
<a name="ln2026">            for (int staffIdx = 0; staffIdx &lt; _staves.size(); ++staffIdx) {</a>
<a name="ln2027">                  int track = staffIdx * VOICES;</a>
<a name="ln2028">                  KeySig* ks  = toKeySig(cs-&gt;element(track));</a>
<a name="ln2029">                  if (ks) {</a>
<a name="ln2030">                        KeySig* nks = toKeySig(ns-&gt;element(track));</a>
<a name="ln2031">                        if (!nks) {</a>
<a name="ln2032">                              nks = ks-&gt;generated() ? ks-&gt;clone() : toKeySig(ks-&gt;linkedClone());</a>
<a name="ln2033">                              nks-&gt;setParent(ns);</a>
<a name="ln2034">                              nks-&gt;setGenerated(true);</a>
<a name="ln2035">                              undo(new AddElement(nks));</a>
<a name="ln2036">                              }</a>
<a name="ln2037">                        else {</a>
<a name="ln2038">                              if (!(nks-&gt;keySigEvent() == ks-&gt;keySigEvent())) {</a>
<a name="ln2039">                                    bool addKey = ks-&gt;isChange();</a>
<a name="ln2040">                                    undo(new ChangeKeySig(nks, ks-&gt;keySigEvent(), nks-&gt;showCourtesy(), addKey));</a>
<a name="ln2041">                                    }</a>
<a name="ln2042">                              }</a>
<a name="ln2043">                        }</a>
<a name="ln2044">                  }</a>
<a name="ln2045">            }</a>
<a name="ln2046">      else if (ns) {</a>
<a name="ln2047">            ns-&gt;setEnabled(false);</a>
<a name="ln2048">            // TODO: remove elements from ns, then delete ns</a>
<a name="ln2049">            // previously we removed the segment if not empty,</a>
<a name="ln2050">            // but this resulted in &quot;stale&quot; keysig in mmrest after removed from underlying measure</a>
<a name="ln2051">            //undo(new RemoveElement(ns));</a>
<a name="ln2052">            }</a>
<a name="ln2053"> </a>
<a name="ln2054">      mmr-&gt;checkHeader();</a>
<a name="ln2055">      mmr-&gt;checkTrailer();</a>
<a name="ln2056"> </a>
<a name="ln2057">      //</a>
<a name="ln2058">      // check for rehearsal mark etc.</a>
<a name="ln2059">      //</a>
<a name="ln2060">      cs = m-&gt;findSegmentR(SegmentType::ChordRest, Fraction(0,1));</a>
<a name="ln2061">      if (cs) {</a>
<a name="ln2062">            // clone elements from underlying measure to mmr</a>
<a name="ln2063">            for (Element* e : cs-&gt;annotations()) {</a>
<a name="ln2064">                  // look at elements in underlying measure</a>
<a name="ln2065">                  if (!(e-&gt;isRehearsalMark() || e-&gt;isTempoText() || e-&gt;isHarmony() || e-&gt;isStaffText() || e-&gt;isSystemText() || e-&gt;isInstrumentChange()))</a>
<a name="ln2066">                        continue;</a>
<a name="ln2067">                  // try to find a match in mmr</a>
<a name="ln2068">                  bool found = false;</a>
<a name="ln2069">                  for (Element* ee : s-&gt;annotations()) {</a>
<a name="ln2070">                        if (e-&gt;linkList().contains(ee)) {</a>
<a name="ln2071">                              found = true;</a>
<a name="ln2072">                              break;</a>
<a name="ln2073">                              }</a>
<a name="ln2074">                        }</a>
<a name="ln2075">                  // add to mmr if no match found</a>
<a name="ln2076">                  if (!found) {</a>
<a name="ln2077">                        Element* ne = e-&gt;linkedClone();</a>
<a name="ln2078">                        ne-&gt;setParent(s);</a>
<a name="ln2079">                        undo(new AddElement(ne));</a>
<a name="ln2080">                        }</a>
<a name="ln2081">                  }</a>
<a name="ln2082"> </a>
<a name="ln2083">            // remove stray elements (possibly leftover from a previous layout of this mmr)</a>
<a name="ln2084">            // this should not happen since the elements are linked?</a>
<a name="ln2085">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln2086">                  // look at elements in mmr</a>
<a name="ln2087">                  if (!(e-&gt;isRehearsalMark() || e-&gt;isTempoText() || e-&gt;isHarmony() || e-&gt;isStaffText() || e-&gt;isSystemText() || e-&gt;isInstrumentChange()))</a>
<a name="ln2088">                        continue;</a>
<a name="ln2089">                  // try to find a match in underlying measure</a>
<a name="ln2090">                  bool found = false;</a>
<a name="ln2091">                  for (Element* ee : cs-&gt;annotations()) {</a>
<a name="ln2092">                        if (e-&gt;linkList().contains(ee)) {</a>
<a name="ln2093">                              found = true;</a>
<a name="ln2094">                              break;</a>
<a name="ln2095">                              }</a>
<a name="ln2096">                        }</a>
<a name="ln2097">                  // remove from mmr if no match found</a>
<a name="ln2098">                  if (!found)</a>
<a name="ln2099">                        undo(new RemoveElement(e));</a>
<a name="ln2100">                  }</a>
<a name="ln2101">            }</a>
<a name="ln2102">      MeasureBase* nm = _showVBox ? lm-&gt;next() : lm-&gt;nextMeasure();</a>
<a name="ln2103">      mmr-&gt;setNext(nm);</a>
<a name="ln2104">      mmr-&gt;setPrev(m-&gt;prev());</a>
<a name="ln2105">      }</a>
<a name="ln2106"> </a>
<a name="ln2107">//---------------------------------------------------------</a>
<a name="ln2108">// validMMRestMeasure</a>
<a name="ln2109">//    return true if this might be a measure in a</a>
<a name="ln2110">//    multi measure rest</a>
<a name="ln2111">//---------------------------------------------------------</a>
<a name="ln2112"> </a>
<a name="ln2113">static bool validMMRestMeasure(Measure* m)</a>
<a name="ln2114">      {</a>
<a name="ln2115">      if (m-&gt;irregular())</a>
<a name="ln2116">            return false;</a>
<a name="ln2117"> </a>
<a name="ln2118">      int n = 0;</a>
<a name="ln2119">      for (Segment* s = m-&gt;first(); s; s = s-&gt;next()) {</a>
<a name="ln2120">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln2121">                  if (!(e-&gt;isRehearsalMark() || e-&gt;isTempoText() || e-&gt;isHarmony() || e-&gt;isStaffText() || e-&gt;isSystemText() || e-&gt;isInstrumentChange()))</a>
<a name="ln2122">                        return false;</a>
<a name="ln2123">                  }</a>
<a name="ln2124">            if (s-&gt;isChordRestType()) {</a>
<a name="ln2125">                  bool restFound = false;</a>
<a name="ln2126">                  int tracks = m-&gt;score()-&gt;ntracks();</a>
<a name="ln2127">                  for (int track = 0; track &lt; tracks; ++track) {</a>
<a name="ln2128">                        if ((track % VOICES) == 0 &amp;&amp; !m-&gt;score()-&gt;staff(track/VOICES)-&gt;show()) {</a>
<a name="ln2129">                              track += VOICES-1;</a>
<a name="ln2130">                              continue;</a>
<a name="ln2131">                              }</a>
<a name="ln2132">                        if (s-&gt;element(track))  {</a>
<a name="ln2133">                              if (!s-&gt;element(track)-&gt;isRest())</a>
<a name="ln2134">                                    return false;</a>
<a name="ln2135">                              restFound = true;</a>
<a name="ln2136">                              }</a>
<a name="ln2137">                        }</a>
<a name="ln2138">                  for (Element* e : s-&gt;annotations()) {</a>
<a name="ln2139">                        if (e-&gt;isFermata())</a>
<a name="ln2140">                              return false;</a>
<a name="ln2141">                        }</a>
<a name="ln2142">                  if (restFound)</a>
<a name="ln2143">                        ++n;</a>
<a name="ln2144">                  // measure is not empty if there is more than one rest</a>
<a name="ln2145">                  if (n &gt; 1)</a>
<a name="ln2146">                        return false;</a>
<a name="ln2147">                  }</a>
<a name="ln2148">            }</a>
<a name="ln2149">      return true;</a>
<a name="ln2150">      }</a>
<a name="ln2151"> </a>
<a name="ln2152">//---------------------------------------------------------</a>
<a name="ln2153">//  breakMultiMeasureRest</a>
<a name="ln2154">//    return true if this measure should start a new</a>
<a name="ln2155">//    multi measure rest</a>
<a name="ln2156">//---------------------------------------------------------</a>
<a name="ln2157"> </a>
<a name="ln2158">static bool breakMultiMeasureRest(Measure* m)</a>
<a name="ln2159">      {</a>
<a name="ln2160">      if (m-&gt;breakMultiMeasureRest())</a>
<a name="ln2161">            return true;</a>
<a name="ln2162"> </a>
<a name="ln2163">      if (m-&gt;repeatStart()</a>
<a name="ln2164">         || (m-&gt;prevMeasure() &amp;&amp; m-&gt;prevMeasure()-&gt;repeatEnd())</a>
<a name="ln2165">         || (m-&gt;isIrregular())</a>
<a name="ln2166">         || (m-&gt;prevMeasure() &amp;&amp; m-&gt;prevMeasure()-&gt;isIrregular())</a>
<a name="ln2167">         || (m-&gt;prevMeasure() &amp;&amp; (m-&gt;prevMeasure()-&gt;sectionBreak())))</a>
<a name="ln2168">            return true;</a>
<a name="ln2169"> </a>
<a name="ln2170">      auto sl = m-&gt;score()-&gt;spannerMap().findOverlapping(m-&gt;tick().ticks(), m-&gt;endTick().ticks());</a>
<a name="ln2171">      for (auto i : sl) {</a>
<a name="ln2172">            Spanner* s = i.value;</a>
<a name="ln2173">            // break for first measure of volta and first measure *after* volta</a>
<a name="ln2174">            if (s-&gt;isVolta() &amp;&amp; (s-&gt;tick() == m-&gt;tick() || s-&gt;tick2() == m-&gt;tick()))</a>
<a name="ln2175">                  return true;</a>
<a name="ln2176">            }</a>
<a name="ln2177"> </a>
<a name="ln2178">      // break for marker in this measure</a>
<a name="ln2179">      for (Element* e : m-&gt;el()) {</a>
<a name="ln2180">            if (e-&gt;isMarker()) {</a>
<a name="ln2181">                  Marker* mark = toMarker(e);</a>
<a name="ln2182">                  if (!(mark-&gt;align() &amp; Align::RIGHT))</a>
<a name="ln2183">                        return true;</a>
<a name="ln2184">                  }</a>
<a name="ln2185">            }</a>
<a name="ln2186"> </a>
<a name="ln2187">      // break for marker &amp; jump in previous measure</a>
<a name="ln2188">      Measure* pm = m-&gt;prevMeasure();</a>
<a name="ln2189">      if (pm) {</a>
<a name="ln2190">            for (Element* e : pm-&gt;el()) {</a>
<a name="ln2191">                  if (e-&gt;isJump())</a>
<a name="ln2192">                        return true;</a>
<a name="ln2193">                  else if (e-&gt;isMarker()) {</a>
<a name="ln2194">                        Marker* mark = toMarker(e);</a>
<a name="ln2195">                        if (mark-&gt;align() &amp; Align::RIGHT)</a>
<a name="ln2196">                              return true;</a>
<a name="ln2197">                        }</a>
<a name="ln2198">                  }</a>
<a name="ln2199">            }</a>
<a name="ln2200"> </a>
<a name="ln2201">      for (Segment* s = m-&gt;first(); s; s = s-&gt;next()) {</a>
<a name="ln2202">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln2203">                  if (!e-&gt;visible())</a>
<a name="ln2204">                        continue;</a>
<a name="ln2205">                  if (e-&gt;isRehearsalMark() ||</a>
<a name="ln2206">                      e-&gt;isTempoText() ||</a>
<a name="ln2207">                      ((e-&gt;isHarmony() || e-&gt;isStaffText() || e-&gt;isSystemText() || e-&gt;isInstrumentChange()) &amp;&amp; (e-&gt;systemFlag() || m-&gt;score()-&gt;staff(e-&gt;staffIdx())-&gt;show())))</a>
<a name="ln2208">                        return true;</a>
<a name="ln2209">                  }</a>
<a name="ln2210">            for (int staffIdx = 0; staffIdx &lt; m-&gt;score()-&gt;nstaves(); ++staffIdx) {</a>
<a name="ln2211">                  if (!m-&gt;score()-&gt;staff(staffIdx)-&gt;show())</a>
<a name="ln2212">                        continue;</a>
<a name="ln2213">                  Element* e = s-&gt;element(staffIdx * VOICES);</a>
<a name="ln2214">                  if (!e || e-&gt;generated())</a>
<a name="ln2215">                        continue;</a>
<a name="ln2216">                  if (s-&gt;isStartRepeatBarLineType())</a>
<a name="ln2217">                        return true;</a>
<a name="ln2218">                  if (s-&gt;isType(SegmentType::KeySig | SegmentType::TimeSig) &amp;&amp; m-&gt;tick().isNotZero())</a>
<a name="ln2219">                        return true;</a>
<a name="ln2220">                  if (s-&gt;isClefType()) {</a>
<a name="ln2221">                        if (s-&gt;tick() != m-&gt;endTick() &amp;&amp; m-&gt;tick().isNotZero())</a>
<a name="ln2222">                              return true;</a>
<a name="ln2223">                        }</a>
<a name="ln2224">                  }</a>
<a name="ln2225">            }</a>
<a name="ln2226">      if (pm) {</a>
<a name="ln2227">            Segment* s = pm-&gt;findSegmentR(SegmentType::EndBarLine, pm-&gt;ticks());</a>
<a name="ln2228">            if (s) {</a>
<a name="ln2229">                  for (int staffIdx = 0; staffIdx &lt; s-&gt;score()-&gt;nstaves(); ++staffIdx) {</a>
<a name="ln2230">                        BarLine* bl = toBarLine(s-&gt;element(staffIdx * VOICES));</a>
<a name="ln2231">                        if (bl) {</a>
<a name="ln2232">                              BarLineType t = bl-&gt;barLineType();</a>
<a name="ln2233">                              if (t != BarLineType::NORMAL &amp;&amp; t != BarLineType::BROKEN &amp;&amp; t != BarLineType::DOTTED &amp;&amp; !bl-&gt;generated())</a>
<a name="ln2234">                                    return true;</a>
<a name="ln2235">                              else</a>
<a name="ln2236">                                    break;</a>
<a name="ln2237">                              }</a>
<a name="ln2238">                        }</a>
<a name="ln2239">                  }</a>
<a name="ln2240">            if (pm-&gt;findSegment(SegmentType::Clef, m-&gt;tick()))</a>
<a name="ln2241">                  return true;</a>
<a name="ln2242">            }</a>
<a name="ln2243">      return false;</a>
<a name="ln2244">      }</a>
<a name="ln2245"> </a>
<a name="ln2246">//---------------------------------------------------------</a>
<a name="ln2247">//   adjustMeasureNo</a>
<a name="ln2248">//---------------------------------------------------------</a>
<a name="ln2249"> </a>
<a name="ln2250">int LayoutContext::adjustMeasureNo(MeasureBase* m)</a>
<a name="ln2251">      {</a>
<a name="ln2252">      measureNo += m-&gt;noOffset();</a>
<a name="ln2253">      m-&gt;setNo(measureNo);</a>
<a name="ln2254">      if (!m-&gt;irregular())          // dont count measure</a>
<a name="ln2255">            ++measureNo;</a>
<a name="ln2256">      if (m-&gt;sectionBreakElement() &amp;&amp; m-&gt;sectionBreakElement()-&gt;startWithMeasureOne())</a>
<a name="ln2257">            measureNo = 0;</a>
<a name="ln2258">      return measureNo;</a>
<a name="ln2259">      }</a>
<a name="ln2260"> </a>
<a name="ln2261">//---------------------------------------------------------</a>
<a name="ln2262">//   createBeams</a>
<a name="ln2263">//    helper function</a>
<a name="ln2264">//---------------------------------------------------------</a>
<a name="ln2265"> </a>
<a name="ln2266">void Score::createBeams(Measure* measure)</a>
<a name="ln2267">      {</a>
<a name="ln2268">      bool crossMeasure = styleB(Sid::crossMeasureValues);</a>
<a name="ln2269"> </a>
<a name="ln2270">      for (int track = 0; track &lt; ntracks(); ++track) {</a>
<a name="ln2271">            Staff* stf = staff(track2staff(track));</a>
<a name="ln2272"> </a>
<a name="ln2273">            // dont compute beams for invisible staffs and tablature without stems</a>
<a name="ln2274">            if (!stf-&gt;show() || (stf-&gt;isTabStaff(measure-&gt;tick()) &amp;&amp; stf-&gt;staffType(measure-&gt;tick())-&gt;stemless()))</a>
<a name="ln2275">                  continue;</a>
<a name="ln2276"> </a>
<a name="ln2277">            ChordRest* a1    = 0;      // start of (potential) beam</a>
<a name="ln2278">            bool firstCR     = true;</a>
<a name="ln2279">            Beam* beam       = 0;      // current beam</a>
<a name="ln2280">            Beam::Mode bm    = Beam::Mode::AUTO;</a>
<a name="ln2281">            ChordRest* prev  = 0;</a>
<a name="ln2282">            bool checkBeats  = false;</a>
<a name="ln2283">            Fraction stretch = Fraction(1,1);</a>
<a name="ln2284">            QHash&lt;int, TDuration&gt; beatSubdivision;</a>
<a name="ln2285"> </a>
<a name="ln2286">            // if this measure is simple meter (actually X/4),</a>
<a name="ln2287">            // then perform a prepass to determine the subdivision of each beat</a>
<a name="ln2288"> </a>
<a name="ln2289">            beatSubdivision.clear();</a>
<a name="ln2290">            TimeSig* ts = stf-&gt;timeSig(measure-&gt;tick());</a>
<a name="ln2291">            checkBeats  = false;</a>
<a name="ln2292">            stretch     = ts ? ts-&gt;stretch() : Fraction(1,1);</a>
<a name="ln2293"> </a>
<a name="ln2294">            const SegmentType st = SegmentType::ChordRest;</a>
<a name="ln2295">            if (ts &amp;&amp; ts-&gt;denominator() == 4) {</a>
<a name="ln2296">                  checkBeats = true;</a>
<a name="ln2297">                  for (Segment* s = measure-&gt;first(st); s; s = s-&gt;next(st)) {</a>
<a name="ln2298">                        ChordRest* mcr = toChordRest(s-&gt;element(track));</a>
<a name="ln2299">                        if (mcr == 0)</a>
<a name="ln2300">                              continue;</a>
<a name="ln2301">                        int beat = (mcr-&gt;rtick() * stretch).ticks() / MScore::division;</a>
<a name="ln2302">                        if (beatSubdivision.contains(beat))</a>
<a name="ln2303">                              beatSubdivision[beat] = qMin(beatSubdivision[beat], mcr-&gt;durationType());</a>
<a name="ln2304">                        else</a>
<a name="ln2305">                              beatSubdivision[beat] = mcr-&gt;durationType();</a>
<a name="ln2306">                        }</a>
<a name="ln2307">                  }</a>
<a name="ln2308"> </a>
<a name="ln2309">            for (Segment* segment = measure-&gt;first(st); segment; segment = segment-&gt;next(st)) {</a>
<a name="ln2310">                  ChordRest* cr = segment-&gt;cr(track);</a>
<a name="ln2311">                  if (cr == 0)</a>
<a name="ln2312">                        continue;</a>
<a name="ln2313"> </a>
<a name="ln2314">                  if (firstCR) {</a>
<a name="ln2315">                        firstCR = false;</a>
<a name="ln2316">                        // Handle cross-measure beams</a>
<a name="ln2317">                        Beam::Mode mode = cr-&gt;beamMode();</a>
<a name="ln2318">                        if (mode == Beam::Mode::MID || mode == Beam::Mode::END) {</a>
<a name="ln2319">                              ChordRest* prevCR = findCR(measure-&gt;tick() - Fraction::fromTicks(1), track);</a>
<a name="ln2320">                              if (prevCR) {</a>
<a name="ln2321">                                    const Measure* pm = prevCR-&gt;measure();</a>
<a name="ln2322">                                    if (!beamNoContinue(prevCR-&gt;beamMode())</a>
<a name="ln2323">                                        &amp;&amp; !pm-&gt;lineBreak() &amp;&amp; !pm-&gt;pageBreak() &amp;&amp; !pm-&gt;sectionBreak()</a>
<a name="ln2324">                                        &amp;&amp; prevCR-&gt;durationType().type() &gt;= TDuration::DurationType::V_EIGHTH</a>
<a name="ln2325">                                        &amp;&amp; prevCR-&gt;durationType().type() &lt;= TDuration::DurationType::V_1024TH) {</a>
<a name="ln2326">                                          beam = prevCR-&gt;beam();</a>
<a name="ln2327">                                          //a1 = beam ? beam-&gt;elements().front() : prevCR;</a>
<a name="ln2328">                                          a1 = beam ? nullptr : prevCR; // when beam is found, a1 is no longer required.</a>
<a name="ln2329">                                          }</a>
<a name="ln2330">                                    }</a>
<a name="ln2331">                              }</a>
<a name="ln2332">                        }</a>
<a name="ln2333">#if 0</a>
<a name="ln2334">                  for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln2335">                        if (l)</a>
<a name="ln2336">                              l-&gt;layout();</a>
<a name="ln2337">                        }</a>
<a name="ln2338">#endif</a>
<a name="ln2339">                  // handle grace notes and cross-measure beaming</a>
<a name="ln2340">                  // (tied chords?)</a>
<a name="ln2341">                  if (cr-&gt;isChord()) {</a>
<a name="ln2342">                        Chord* chord = toChord(cr);</a>
<a name="ln2343">                        beamGraceNotes(chord, false); // grace before</a>
<a name="ln2344">                        beamGraceNotes(chord, true);  // grace after</a>
<a name="ln2345">                        // set up for cross-measure values as soon as possible</a>
<a name="ln2346">                        // to have all computations (stems, hooks, ...) consistent with it</a>
<a name="ln2347">                        if (!chord-&gt;isGrace())</a>
<a name="ln2348">                              chord-&gt;crossMeasureSetup(crossMeasure);</a>
<a name="ln2349">                        }</a>
<a name="ln2350"> </a>
<a name="ln2351">                  if (cr-&gt;isRest() &amp;&amp; cr-&gt;beamMode() == Beam::Mode::AUTO)</a>
<a name="ln2352">                        bm = Beam::Mode::NONE;           // do not beam rests set to Beam::Mode::AUTO</a>
<a name="ln2353">                  else</a>
<a name="ln2354">                        bm = Groups::endBeam(cr, prev);  // get defaults from time signature properties</a>
<a name="ln2355"> </a>
<a name="ln2356">                  // perform additional context-dependent checks</a>
<a name="ln2357">                  if (bm == Beam::Mode::AUTO) {</a>
<a name="ln2358">                        // check if we need to break beams according to minimum duration in current / previous beat</a>
<a name="ln2359">                        if (checkBeats &amp;&amp; cr-&gt;rtick().isNotZero()) {</a>
<a name="ln2360">                              Fraction tick = cr-&gt;rtick() * stretch;</a>
<a name="ln2361">                              // check if on the beat</a>
<a name="ln2362">                              if ((tick.ticks() % MScore::division) == 0) {</a>
<a name="ln2363">                                    int beat = tick.ticks() / MScore::division;</a>
<a name="ln2364">                                    // get minimum duration for this &amp; previous beat</a>
<a name="ln2365">                                    TDuration minDuration = qMin(beatSubdivision[beat], beatSubdivision[beat - 1]);</a>
<a name="ln2366">                                    // re-calculate beam as if this were the duration of current chordrest</a>
<a name="ln2367">                                    TDuration saveDuration        = cr-&gt;actualDurationType();</a>
<a name="ln2368">                                    TDuration saveCMDuration      = cr-&gt;crossMeasureDurationType();</a>
<a name="ln2369">                                    CrossMeasure saveCrossMeasVal = cr-&gt;crossMeasure();</a>
<a name="ln2370">                                    cr-&gt;setDurationType(minDuration);</a>
<a name="ln2371">                                    bm = Groups::endBeam(cr, prev);</a>
<a name="ln2372">                                    cr-&gt;setDurationType(saveDuration);</a>
<a name="ln2373">                                    cr-&gt;setCrossMeasure(saveCrossMeasVal);</a>
<a name="ln2374">                                    cr-&gt;setCrossMeasureDurationType(saveCMDuration);</a>
<a name="ln2375">                                    }</a>
<a name="ln2376">                              }</a>
<a name="ln2377">                        }</a>
<a name="ln2378"> </a>
<a name="ln2379">                  prev = cr;</a>
<a name="ln2380"> </a>
<a name="ln2381">                  // if chord has hooks and is 2nd element of a cross-measure value</a>
<a name="ln2382">                  // set beam mode to NONE (do not combine with following chord beam/hook, if any)</a>
<a name="ln2383"> </a>
<a name="ln2384">                  if (cr-&gt;durationType().hooks() &gt; 0 &amp;&amp; cr-&gt;crossMeasure() == CrossMeasure::SECOND)</a>
<a name="ln2385">                        bm = Beam::Mode::NONE;</a>
<a name="ln2386"> </a>
<a name="ln2387">                  if ((cr-&gt;durationType().type() &lt;= TDuration::DurationType::V_QUARTER) || (bm == Beam::Mode::NONE)) {</a>
<a name="ln2388">                        bool removeBeam = true;</a>
<a name="ln2389">                        if (beam) {</a>
<a name="ln2390">                              beam-&gt;layout1();</a>
<a name="ln2391">                              removeBeam = (beam-&gt;elements().size() &lt;= 1);</a>
<a name="ln2392">                              beam = 0;</a>
<a name="ln2393">                              }</a>
<a name="ln2394">                        if (a1) {</a>
<a name="ln2395">                              if (removeBeam)</a>
<a name="ln2396">                                    a1-&gt;removeDeleteBeam(false);</a>
<a name="ln2397">                              a1 = 0;</a>
<a name="ln2398">                              }</a>
<a name="ln2399">                        cr-&gt;removeDeleteBeam(false);</a>
<a name="ln2400">                        continue;</a>
<a name="ln2401">                        }</a>
<a name="ln2402"> </a>
<a name="ln2403">                  if (beam) {</a>
<a name="ln2404">                        bool beamEnd = (bm == Beam::Mode::BEGIN);</a>
<a name="ln2405">                        if (!beamEnd) {</a>
<a name="ln2406">                              cr-&gt;replaceBeam(beam);</a>
<a name="ln2407">                              cr = 0;</a>
<a name="ln2408">                              beamEnd = (bm == Beam::Mode::END);</a>
<a name="ln2409">                              }</a>
<a name="ln2410">                        if (beamEnd) {</a>
<a name="ln2411">                              beam-&gt;layout1();</a>
<a name="ln2412">                              beam = 0;</a>
<a name="ln2413">                              }</a>
<a name="ln2414">                        }</a>
<a name="ln2415">                  if (!cr)</a>
<a name="ln2416">                        continue;</a>
<a name="ln2417"> </a>
<a name="ln2418">                  if (a1 == 0)</a>
<a name="ln2419">                        a1 = cr;</a>
<a name="ln2420">                  else {</a>
<a name="ln2421">                        if (!beamModeMid(bm)</a>
<a name="ln2422">                           &amp;&amp;</a>
<a name="ln2423">                           (bm == Beam::Mode::BEGIN</a>
<a name="ln2424">                              || (a1-&gt;segment()-&gt;segmentType() != cr-&gt;segment()-&gt;segmentType())</a>
<a name="ln2425">                              || (a1-&gt;tick() + a1-&gt;actualTicks() &lt; cr-&gt;tick())</a>
<a name="ln2426">                              )</a>
<a name="ln2427">                           )</a>
<a name="ln2428">                              {</a>
<a name="ln2429">                              a1-&gt;removeDeleteBeam(false);</a>
<a name="ln2430">                              a1 = cr;</a>
<a name="ln2431">                              }</a>
<a name="ln2432">                        else {</a>
<a name="ln2433">                              beam = a1-&gt;beam();</a>
<a name="ln2434">                              if (beam == 0 || beam-&gt;elements().front() != a1) {</a>
<a name="ln2435">                                    beam = new Beam(this);</a>
<a name="ln2436">                                    beam-&gt;setGenerated(true);</a>
<a name="ln2437">                                    beam-&gt;setTrack(track);</a>
<a name="ln2438">                                    a1-&gt;replaceBeam(beam);</a>
<a name="ln2439">                                    }</a>
<a name="ln2440">                              cr-&gt;replaceBeam(beam);</a>
<a name="ln2441">                              a1 = 0;</a>
<a name="ln2442">                              }</a>
<a name="ln2443">                        }</a>
<a name="ln2444">                  }</a>
<a name="ln2445">            if (beam)</a>
<a name="ln2446">                  beam-&gt;layout1();</a>
<a name="ln2447">            else if (a1) {</a>
<a name="ln2448">                  Fraction nextTick = a1-&gt;tick() + a1-&gt;actualTicks();</a>
<a name="ln2449">                  Measure* m = (nextTick &gt;= measure-&gt;endTick() ? measure-&gt;nextMeasure() : measure);</a>
<a name="ln2450">                  ChordRest* nextCR = (m ? m-&gt;findChordRest(nextTick, track) : nullptr);</a>
<a name="ln2451">                  Beam* b = a1-&gt;beam();</a>
<a name="ln2452">                  if (!(b &amp;&amp; b-&gt;elements().startsWith(a1) &amp;&amp; nextCR &amp;&amp; beamModeMid(nextCR-&gt;beamMode())))</a>
<a name="ln2453">                        a1-&gt;removeDeleteBeam(false);</a>
<a name="ln2454">                  }</a>
<a name="ln2455">            }</a>
<a name="ln2456">      }</a>
<a name="ln2457"> </a>
<a name="ln2458">//---------------------------------------------------------</a>
<a name="ln2459">//   breakCrossMeasureBeams</a>
<a name="ln2460">//---------------------------------------------------------</a>
<a name="ln2461"> </a>
<a name="ln2462">static void breakCrossMeasureBeams(Measure* measure)</a>
<a name="ln2463">      {</a>
<a name="ln2464">      MeasureBase* mbNext = measure-&gt;next();</a>
<a name="ln2465">      if (!mbNext || !mbNext-&gt;isMeasure())</a>
<a name="ln2466">            return;</a>
<a name="ln2467"> </a>
<a name="ln2468">      Measure* next = toMeasure(mbNext);</a>
<a name="ln2469">      Score* score = measure-&gt;score();</a>
<a name="ln2470">      const int ntracks = score-&gt;ntracks();</a>
<a name="ln2471">      Segment* fstSeg = next-&gt;first(SegmentType::ChordRest);</a>
<a name="ln2472">      if (!fstSeg)</a>
<a name="ln2473">            return;</a>
<a name="ln2474"> </a>
<a name="ln2475">      for (int track = 0; track &lt; ntracks; ++track) {</a>
<a name="ln2476">            Staff* stf = score-&gt;staff(track2staff(track));</a>
<a name="ln2477"> </a>
<a name="ln2478">            // dont compute beams for invisible staffs and tablature without stems</a>
<a name="ln2479">            if (!stf-&gt;show() || (stf-&gt;isTabStaff(measure-&gt;tick()) &amp;&amp; stf-&gt;staffType(measure-&gt;tick())-&gt;stemless()))</a>
<a name="ln2480">                  continue;</a>
<a name="ln2481"> </a>
<a name="ln2482">            Element* e = fstSeg-&gt;element(track);</a>
<a name="ln2483">            if (!e || !e-&gt;isChordRest())</a>
<a name="ln2484">                  continue;</a>
<a name="ln2485"> </a>
<a name="ln2486">            ChordRest* cr = toChordRest(e);</a>
<a name="ln2487">            Beam* beam = cr-&gt;beam();</a>
<a name="ln2488">            if (!beam || beam-&gt;elements().front()-&gt;measure() == next) // no beam or not cross-measure beam</a>
<a name="ln2489">                  continue;</a>
<a name="ln2490"> </a>
<a name="ln2491">            std::vector&lt;ChordRest*&gt; mElements;</a>
<a name="ln2492">            std::vector&lt;ChordRest*&gt; nextElements;</a>
<a name="ln2493"> </a>
<a name="ln2494">            for (ChordRest* beamCR : beam-&gt;elements()) {</a>
<a name="ln2495">                  if (beamCR-&gt;measure() == measure)</a>
<a name="ln2496">                        mElements.push_back(beamCR);</a>
<a name="ln2497">                  else</a>
<a name="ln2498">                        nextElements.push_back(beamCR);</a>
<a name="ln2499">                  }</a>
<a name="ln2500"> </a>
<a name="ln2501">            if (mElements.size() == 1)</a>
<a name="ln2502">                  mElements[0]-&gt;removeDeleteBeam(false);</a>
<a name="ln2503"> </a>
<a name="ln2504">            Beam* newBeam = nullptr;</a>
<a name="ln2505">            if (nextElements.size() &gt; 1) {</a>
<a name="ln2506">                  newBeam = new Beam(score);</a>
<a name="ln2507">                  newBeam-&gt;setGenerated(true);</a>
<a name="ln2508">                  newBeam-&gt;setTrack(track);</a>
<a name="ln2509">                  }</a>
<a name="ln2510"> </a>
<a name="ln2511">            const bool nextBeamed = bool(newBeam);</a>
<a name="ln2512">            for (ChordRest* nextCR : nextElements) {</a>
<a name="ln2513">                  nextCR-&gt;removeDeleteBeam(nextBeamed);</a>
<a name="ln2514">                  if (newBeam)</a>
<a name="ln2515">                        newBeam-&gt;add(nextCR);</a>
<a name="ln2516">                  }</a>
<a name="ln2517"> </a>
<a name="ln2518">            if (newBeam)</a>
<a name="ln2519">                  newBeam-&gt;layout1();</a>
<a name="ln2520">            }</a>
<a name="ln2521">      }</a>
<a name="ln2522"> </a>
<a name="ln2523">//---------------------------------------------------------</a>
<a name="ln2524">//   layoutDrumsetChord</a>
<a name="ln2525">//---------------------------------------------------------</a>
<a name="ln2526"> </a>
<a name="ln2527">void layoutDrumsetChord(Chord* c, const Drumset* drumset, const StaffType* st, qreal spatium)</a>
<a name="ln2528">      {</a>
<a name="ln2529">      for (Note* note : c-&gt;notes()) {</a>
<a name="ln2530">            int pitch = note-&gt;pitch();</a>
<a name="ln2531">            if (!drumset-&gt;isValid(pitch)) {</a>
<a name="ln2532">                  // qDebug(&quot;unmapped drum note %d&quot;, pitch);</a>
<a name="ln2533">                  }</a>
<a name="ln2534">            else if (!note-&gt;fixed()) {</a>
<a name="ln2535">                  note-&gt;undoChangeProperty(Pid::HEAD_GROUP, int(drumset-&gt;noteHead(pitch)));</a>
<a name="ln2536">                  int line = drumset-&gt;line(pitch);</a>
<a name="ln2537">                  note-&gt;setLine(line);</a>
<a name="ln2538"> </a>
<a name="ln2539">                  int off  = st-&gt;stepOffset();</a>
<a name="ln2540">                  qreal ld = st-&gt;lineDistance().val();</a>
<a name="ln2541">                  note-&gt;rypos()  = (line + off * 2.0) * spatium * .5 * ld;</a>
<a name="ln2542">                  }</a>
<a name="ln2543">            }</a>
<a name="ln2544">      }</a>
<a name="ln2545"> </a>
<a name="ln2546">//---------------------------------------------------------</a>
<a name="ln2547">//   getNextMeasure</a>
<a name="ln2548">//---------------------------------------------------------</a>
<a name="ln2549"> </a>
<a name="ln2550">void Score::getNextMeasure(LayoutContext&amp; lc)</a>
<a name="ln2551">      {</a>
<a name="ln2552">      lc.prevMeasure = lc.curMeasure;</a>
<a name="ln2553">      lc.curMeasure  = lc.nextMeasure;</a>
<a name="ln2554">      if (!lc.curMeasure)</a>
<a name="ln2555">            lc.nextMeasure = _showVBox ? first() : firstMeasure();</a>
<a name="ln2556">      else</a>
<a name="ln2557">            lc.nextMeasure = _showVBox ? lc.curMeasure-&gt;next() : lc.curMeasure-&gt;nextMeasure();</a>
<a name="ln2558">      if (!lc.curMeasure)</a>
<a name="ln2559">            return;</a>
<a name="ln2560"> </a>
<a name="ln2561">      int mno = lc.adjustMeasureNo(lc.curMeasure);</a>
<a name="ln2562"> </a>
<a name="ln2563">      if (lc.curMeasure-&gt;isMeasure()) {</a>
<a name="ln2564">            if (score()-&gt;styleB(Sid::createMultiMeasureRests)) {</a>
<a name="ln2565">                  Measure* m = toMeasure(lc.curMeasure);</a>
<a name="ln2566">                  Measure* nm = m;</a>
<a name="ln2567">                  Measure* lm = nm;</a>
<a name="ln2568">                  int n       = 0;</a>
<a name="ln2569">                  Fraction len;</a>
<a name="ln2570"> </a>
<a name="ln2571">                  while (validMMRestMeasure(nm)) {</a>
<a name="ln2572">                        MeasureBase* mb = _showVBox ? nm-&gt;next() : nm-&gt;nextMeasure();</a>
<a name="ln2573">                        if (breakMultiMeasureRest(nm) &amp;&amp; n)</a>
<a name="ln2574">                              break;</a>
<a name="ln2575">                        if (nm != m)</a>
<a name="ln2576">                              lc.adjustMeasureNo(nm);</a>
<a name="ln2577">                        ++n;</a>
<a name="ln2578">                        len += nm-&gt;ticks();</a>
<a name="ln2579">                        lm = nm;</a>
<a name="ln2580">                        if (!(mb &amp;&amp; mb-&gt;isMeasure()))</a>
<a name="ln2581">                              break;</a>
<a name="ln2582">                        nm = toMeasure(mb);</a>
<a name="ln2583">                        }</a>
<a name="ln2584">                  if (n &gt;= styleI(Sid::minEmptyMeasures)) {</a>
<a name="ln2585">                        createMMRest(m, lm, len);</a>
<a name="ln2586">                        lc.curMeasure  = m-&gt;mmRest();</a>
<a name="ln2587">                        lc.nextMeasure = _showVBox ?  lm-&gt;next() : lm-&gt;nextMeasure();</a>
<a name="ln2588">                        }</a>
<a name="ln2589">                  else {</a>
<a name="ln2590">                        if (m-&gt;mmRest())</a>
<a name="ln2591">                              undo(new ChangeMMRest(m, 0));</a>
<a name="ln2592">                        m-&gt;setMMRestCount(0);</a>
<a name="ln2593">                        lc.measureNo = mno;</a>
<a name="ln2594">                        }</a>
<a name="ln2595">                  }</a>
<a name="ln2596">            else if (toMeasure(lc.curMeasure)-&gt;isMMRest()) {</a>
<a name="ln2597">                  qDebug(&quot;mmrest: no %d += %d&quot;, lc.measureNo, toMeasure(lc.curMeasure)-&gt;mmRestCount());</a>
<a name="ln2598">                  lc.measureNo += toMeasure(lc.curMeasure)-&gt;mmRestCount() - 1;</a>
<a name="ln2599">                  }</a>
<a name="ln2600">            }</a>
<a name="ln2601">      if (!lc.curMeasure-&gt;isMeasure()) {</a>
<a name="ln2602">            lc.curMeasure-&gt;setTick(lc.tick);</a>
<a name="ln2603">            return;</a>
<a name="ln2604">            }</a>
<a name="ln2605"> </a>
<a name="ln2606">      //-----------------------------------------</a>
<a name="ln2607">      //    process one measure</a>
<a name="ln2608">      //-----------------------------------------</a>
<a name="ln2609"> </a>
<a name="ln2610">      Measure* measure = toMeasure(lc.curMeasure);</a>
<a name="ln2611">      measure-&gt;moveTicks(lc.tick - measure-&gt;tick());</a>
<a name="ln2612"> </a>
<a name="ln2613">      if (lineMode() &amp;&amp; (measure-&gt;tick() &lt; lc.startTick || measure-&gt;tick() &gt; lc.endTick)) {</a>
<a name="ln2614">            // needed to reset segment widths if they can change after measure width is computed</a>
<a name="ln2615">            //for (Segment&amp; s : measure-&gt;segments())</a>
<a name="ln2616">            //      s.createShapes();</a>
<a name="ln2617">            lc.tick += measure-&gt;ticks();</a>
<a name="ln2618">            return;</a>
<a name="ln2619">            }</a>
<a name="ln2620"> </a>
<a name="ln2621">      measure-&gt;connectTremolo();</a>
<a name="ln2622"> </a>
<a name="ln2623">      //</a>
<a name="ln2624">      // calculate accidentals and note lines,</a>
<a name="ln2625">      // create stem and set stem direction</a>
<a name="ln2626">      //</a>
<a name="ln2627">      for (int staffIdx = 0; staffIdx &lt; score()-&gt;nstaves(); ++staffIdx) {</a>
<a name="ln2628">            const Staff* staff     = Score::staff(staffIdx);</a>
<a name="ln2629">            const Drumset* drumset = staff-&gt;part()-&gt;instrument()-&gt;useDrumset() ? staff-&gt;part()-&gt;instrument()-&gt;drumset() : 0;</a>
<a name="ln2630">            AccidentalState as;      // list of already set accidentals for this measure</a>
<a name="ln2631">            as.init(staff-&gt;keySigEvent(measure-&gt;tick()), staff-&gt;clef(measure-&gt;tick()));</a>
<a name="ln2632"> </a>
<a name="ln2633">            for (Segment&amp; segment : measure-&gt;segments()) {</a>
<a name="ln2634">                  // TODO? maybe we do need to process it here to make it possible to enable later</a>
<a name="ln2635">                  //if (!segment.enabled())</a>
<a name="ln2636">                  //      continue;</a>
<a name="ln2637">                  if (segment.isKeySigType()) {</a>
<a name="ln2638">                        KeySig* ks = toKeySig(segment.element(staffIdx * VOICES));</a>
<a name="ln2639">                        if (!ks)</a>
<a name="ln2640">                              continue;</a>
<a name="ln2641">                        Fraction tick = segment.tick();</a>
<a name="ln2642">                        as.init(staff-&gt;keySigEvent(tick), staff-&gt;clef(tick));</a>
<a name="ln2643">                        ks-&gt;layout();</a>
<a name="ln2644">                        }</a>
<a name="ln2645">                  else if (segment.isChordRestType()) {</a>
<a name="ln2646">                        const StaffType* st = staff-&gt;staffType(segment.tick());</a>
<a name="ln2647">                        int track     = staffIdx * VOICES;</a>
<a name="ln2648">                        int endTrack  = track + VOICES;</a>
<a name="ln2649"> </a>
<a name="ln2650">                        for (int t = track; t &lt; endTrack; ++t) {</a>
<a name="ln2651">                              ChordRest* cr = segment.cr(t);</a>
<a name="ln2652">                              if (!cr)</a>
<a name="ln2653">                                    continue;</a>
<a name="ln2654">                              qreal m = staff-&gt;mag(segment.tick());</a>
<a name="ln2655">                              if (cr-&gt;small())</a>
<a name="ln2656">                                    m *= score()-&gt;styleD(Sid::smallNoteMag);</a>
<a name="ln2657"> </a>
<a name="ln2658">                              if (cr-&gt;isChord()) {</a>
<a name="ln2659">                                    Chord* chord = toChord(cr);</a>
<a name="ln2660">                                    chord-&gt;cmdUpdateNotes(&amp;as);</a>
<a name="ln2661">                                    for (Chord* c : chord-&gt;graceNotes()) {</a>
<a name="ln2662">                                          c-&gt;setMag(m * score()-&gt;styleD(Sid::graceNoteMag));</a>
<a name="ln2663">                                          c-&gt;computeUp();</a>
<a name="ln2664">                                          if (c-&gt;stemDirection() != Direction::AUTO)</a>
<a name="ln2665">                                                c-&gt;setUp(c-&gt;stemDirection() == Direction::UP);</a>
<a name="ln2666">                                          else</a>
<a name="ln2667">                                                c-&gt;setUp(!(t % 2));</a>
<a name="ln2668">                                          if (drumset)</a>
<a name="ln2669">                                                layoutDrumsetChord(c, drumset, st, spatium());</a>
<a name="ln2670">                                          c-&gt;layoutStem1();</a>
<a name="ln2671">                                          }</a>
<a name="ln2672">                                    if (drumset)</a>
<a name="ln2673">                                          layoutDrumsetChord(chord, drumset, st, spatium());</a>
<a name="ln2674">                                    chord-&gt;computeUp();</a>
<a name="ln2675">                                    chord-&gt;layoutStem1();   // create stems needed to calculate spacing</a>
<a name="ln2676">                                                            // stem direction can change later during beam processing</a>
<a name="ln2677">                                    }</a>
<a name="ln2678">                              cr-&gt;setMag(m);</a>
<a name="ln2679">                              }</a>
<a name="ln2680">                        }</a>
<a name="ln2681">                  else if (segment.isClefType()) {</a>
<a name="ln2682">                        Element* e = segment.element(staffIdx * VOICES);</a>
<a name="ln2683">                        if (e) {</a>
<a name="ln2684">                              toClef(e)-&gt;setSmall(true);</a>
<a name="ln2685">                              e-&gt;layout();</a>
<a name="ln2686">                              }</a>
<a name="ln2687">                        }</a>
<a name="ln2688">                  else if (segment.isType(SegmentType::TimeSig | SegmentType::Ambitus | SegmentType::HeaderClef)) {</a>
<a name="ln2689">                        Element* e = segment.element(staffIdx * VOICES);</a>
<a name="ln2690">                        if (e)</a>
<a name="ln2691">                              e-&gt;layout();</a>
<a name="ln2692">                        }</a>
<a name="ln2693">                  }</a>
<a name="ln2694">            }</a>
<a name="ln2695"> </a>
<a name="ln2696">      createBeams(measure);</a>
<a name="ln2697"> </a>
<a name="ln2698">      for (int staffIdx = 0; staffIdx &lt; score()-&gt;nstaves(); ++staffIdx) {</a>
<a name="ln2699">            for (Segment&amp; segment : measure-&gt;segments()) {</a>
<a name="ln2700">                  if (segment.isChordRestType()) {</a>
<a name="ln2701">                        layoutChords1(&amp;segment, staffIdx);</a>
<a name="ln2702">                        for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln2703">                              ChordRest* cr = segment.cr(staffIdx * VOICES + voice);</a>
<a name="ln2704">                              if (cr) {</a>
<a name="ln2705">                                    for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln2706">                                          if (l)</a>
<a name="ln2707">                                                l-&gt;layout();</a>
<a name="ln2708">                                          }</a>
<a name="ln2709">                                    }</a>
<a name="ln2710">                              }</a>
<a name="ln2711">                        }</a>
<a name="ln2712">                  }</a>
<a name="ln2713">            }</a>
<a name="ln2714"> </a>
<a name="ln2715">      measure-&gt;computeTicks();</a>
<a name="ln2716"> </a>
<a name="ln2717">      for (Segment&amp; segment : measure-&gt;segments()) {</a>
<a name="ln2718">            if (segment.isBreathType()) {</a>
<a name="ln2719">                  for (Element* e : segment.elist()) {</a>
<a name="ln2720">                        if (e &amp;&amp; e-&gt;isBreath())</a>
<a name="ln2721">                              e-&gt;layout();</a>
<a name="ln2722">                        }</a>
<a name="ln2723">                  }</a>
<a name="ln2724">            else if (segment.isChordRestType()) {</a>
<a name="ln2725">                  for (Element* e : segment.annotations()) {</a>
<a name="ln2726">                        if (e-&gt;isSymbol())</a>
<a name="ln2727">                              e-&gt;layout();</a>
<a name="ln2728">                        }</a>
<a name="ln2729">                  }</a>
<a name="ln2730">            }</a>
<a name="ln2731"> </a>
<a name="ln2732">      rebuildTempoAndTimeSigMaps(measure);</a>
<a name="ln2733"> </a>
<a name="ln2734">      Segment* seg = measure-&gt;findSegmentR(SegmentType::StartRepeatBarLine, Fraction(0,1));</a>
<a name="ln2735">      if (measure-&gt;repeatStart()) {</a>
<a name="ln2736">            if (!seg)</a>
<a name="ln2737">                  seg = measure-&gt;getSegmentR(SegmentType::StartRepeatBarLine, Fraction(0,1));</a>
<a name="ln2738">            measure-&gt;barLinesSetSpan(seg);      // this also creates necessary barlines</a>
<a name="ln2739">            for (int staffIdx = 0; staffIdx &lt; nstaves(); ++staffIdx) {</a>
<a name="ln2740">                  BarLine* b = toBarLine(seg-&gt;element(staffIdx * VOICES));</a>
<a name="ln2741">                  if (b) {</a>
<a name="ln2742">                        b-&gt;setBarLineType(BarLineType::START_REPEAT);</a>
<a name="ln2743">                        b-&gt;layout();</a>
<a name="ln2744">                        }</a>
<a name="ln2745">                  }</a>
<a name="ln2746">            }</a>
<a name="ln2747">      else if (seg)</a>
<a name="ln2748">            score()-&gt;undoRemoveElement(seg);</a>
<a name="ln2749"> </a>
<a name="ln2750">      for (Segment&amp; s : measure-&gt;segments()) {</a>
<a name="ln2751">            // TODO? maybe we do need to process it here to make it possible to enable later</a>
<a name="ln2752">            //if (!s.enabled())</a>
<a name="ln2753">            //      continue;</a>
<a name="ln2754">            // DEBUG: relayout grace notes as beaming/flags may have changed</a>
<a name="ln2755">            if (s.isChordRestType()) {</a>
<a name="ln2756">                  for (Element* e : s.elist()) {</a>
<a name="ln2757">                        if (e &amp;&amp; e-&gt;isChord()) {</a>
<a name="ln2758">                              Chord* chord = toChord(e);</a>
<a name="ln2759">                              chord-&gt;layout();</a>
<a name="ln2760">//                              if (chord-&gt;tremolo())            // debug</a>
<a name="ln2761">//                                    chord-&gt;tremolo()-&gt;layout();</a>
<a name="ln2762">                              }</a>
<a name="ln2763">                        }</a>
<a name="ln2764">                  }</a>
<a name="ln2765">            else if (s.isEndBarLineType())</a>
<a name="ln2766">                  continue;</a>
<a name="ln2767">            s.createShapes();</a>
<a name="ln2768">            }</a>
<a name="ln2769"> </a>
<a name="ln2770">      lc.tick += measure-&gt;ticks();</a>
<a name="ln2771">      }</a>
<a name="ln2772"> </a>
<a name="ln2773">//---------------------------------------------------------</a>
<a name="ln2774">//   isTopBeam</a>
<a name="ln2775">//    returns true for the first CR of a beam that is not cross-staff</a>
<a name="ln2776">//---------------------------------------------------------</a>
<a name="ln2777"> </a>
<a name="ln2778">bool isTopBeam(ChordRest* cr)</a>
<a name="ln2779">      {</a>
<a name="ln2780">      Beam* b = cr-&gt;beam();</a>
<a name="ln2781">      if (b &amp;&amp; b-&gt;elements().front() == cr) {</a>
<a name="ln2782">            // beam already considered cross?</a>
<a name="ln2783">            if (b-&gt;cross())</a>
<a name="ln2784">                  return false;</a>
<a name="ln2785"> </a>
<a name="ln2786">            // for beams not already considered cross,</a>
<a name="ln2787">            // consider them so here if any elements were moved up</a>
<a name="ln2788">            for (ChordRest* cr1 : b-&gt;elements()) {</a>
<a name="ln2789">                  // some element moved up?</a>
<a name="ln2790">                  if (cr1-&gt;staffMove() &lt; 0)</a>
<a name="ln2791">                        return false;</a>
<a name="ln2792">                  }</a>
<a name="ln2793"> </a>
<a name="ln2794">            // not cross</a>
<a name="ln2795">            return true;</a>
<a name="ln2796">            }</a>
<a name="ln2797"> </a>
<a name="ln2798">      // no beam or not first element</a>
<a name="ln2799">      return false;</a>
<a name="ln2800">      }</a>
<a name="ln2801"> </a>
<a name="ln2802">//---------------------------------------------------------</a>
<a name="ln2803">//   notTopBeam</a>
<a name="ln2804">//    returns true for the first CR of a beam that is cross-staff</a>
<a name="ln2805">//---------------------------------------------------------</a>
<a name="ln2806"> </a>
<a name="ln2807">bool notTopBeam(ChordRest* cr)</a>
<a name="ln2808">      {</a>
<a name="ln2809">      Beam* b = cr-&gt;beam();</a>
<a name="ln2810">      if (b &amp;&amp; b-&gt;elements().front() == cr) {</a>
<a name="ln2811">            // beam already considered cross?</a>
<a name="ln2812">            if (b-&gt;cross())</a>
<a name="ln2813">                  return true;</a>
<a name="ln2814"> </a>
<a name="ln2815">            // for beams not already considered cross,</a>
<a name="ln2816">            // consider them so here if any elements were moved up</a>
<a name="ln2817">            for (ChordRest* cr1 : b-&gt;elements()) {</a>
<a name="ln2818">                  // some element moved up?</a>
<a name="ln2819">                  if (cr1-&gt;staffMove() &lt; 0)</a>
<a name="ln2820">                        return true;</a>
<a name="ln2821">                  }</a>
<a name="ln2822"> </a>
<a name="ln2823">            // not cross</a>
<a name="ln2824">            return false;</a>
<a name="ln2825">            }</a>
<a name="ln2826"> </a>
<a name="ln2827">      // no beam or not first element</a>
<a name="ln2828">      return false;</a>
<a name="ln2829">      }</a>
<a name="ln2830"> </a>
<a name="ln2831">//---------------------------------------------------------</a>
<a name="ln2832">//   isTopTuplet</a>
<a name="ln2833">//    returns true for the first CR of a tuplet that is not cross-staff</a>
<a name="ln2834">//---------------------------------------------------------</a>
<a name="ln2835"> </a>
<a name="ln2836">bool isTopTuplet(ChordRest* cr)</a>
<a name="ln2837">      {</a>
<a name="ln2838">      Tuplet* t = cr-&gt;tuplet();</a>
<a name="ln2839">      if (t &amp;&amp; t-&gt;elements().front() == cr) {</a>
<a name="ln2840">            // find top level tuplet</a>
<a name="ln2841">            while (t-&gt;tuplet())</a>
<a name="ln2842">                  t = t-&gt;tuplet();</a>
<a name="ln2843">            // consider tuplet cross if anything moved within it</a>
<a name="ln2844">            if (t-&gt;cross())</a>
<a name="ln2845">                  return false;</a>
<a name="ln2846">            else</a>
<a name="ln2847">                  return true;</a>
<a name="ln2848">            }</a>
<a name="ln2849"> </a>
<a name="ln2850">      // no tuplet or not first element</a>
<a name="ln2851">      return false;</a>
<a name="ln2852">      }</a>
<a name="ln2853"> </a>
<a name="ln2854">//---------------------------------------------------------</a>
<a name="ln2855">//   notTopTuplet</a>
<a name="ln2856">//    returns true for the first CR of a tuplet that is cross-staff</a>
<a name="ln2857">//---------------------------------------------------------</a>
<a name="ln2858"> </a>
<a name="ln2859">bool notTopTuplet(ChordRest* cr)</a>
<a name="ln2860">      {</a>
<a name="ln2861">      Tuplet* t = cr-&gt;tuplet();</a>
<a name="ln2862">      if (t &amp;&amp; t-&gt;elements().front() == cr) {</a>
<a name="ln2863">            // find top level tuplet</a>
<a name="ln2864">            while (t-&gt;tuplet())</a>
<a name="ln2865">                  t = t-&gt;tuplet();</a>
<a name="ln2866">            // consider tuplet cross if anything moved within it</a>
<a name="ln2867">            if (t-&gt;cross())</a>
<a name="ln2868">                  return true;</a>
<a name="ln2869">            else</a>
<a name="ln2870">                  return false;</a>
<a name="ln2871">            }</a>
<a name="ln2872"> </a>
<a name="ln2873">      // no tuplet or not first element</a>
<a name="ln2874">      return false;</a>
<a name="ln2875">      }</a>
<a name="ln2876"> </a>
<a name="ln2877"> </a>
<a name="ln2878">//---------------------------------------------------------</a>
<a name="ln2879">//   findLyricsMaxY</a>
<a name="ln2880">//---------------------------------------------------------</a>
<a name="ln2881"> </a>
<a name="ln2882">static qreal findLyricsMaxY(Segment&amp; s, int staffIdx)</a>
<a name="ln2883">      {</a>
<a name="ln2884">      qreal yMax = 0.0;</a>
<a name="ln2885">      if (!s.isChordRestType())</a>
<a name="ln2886">            return yMax;</a>
<a name="ln2887"> </a>
<a name="ln2888">      qreal lyricsMinTopDistance = s.score()-&gt;styleP(Sid::lyricsMinTopDistance);</a>
<a name="ln2889"> </a>
<a name="ln2890">      for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln2891">            ChordRest* cr = s.cr(staffIdx * VOICES + voice);</a>
<a name="ln2892">            if (cr &amp;&amp; !cr-&gt;lyrics().empty()) {</a>
<a name="ln2893">                  SkylineLine sk(true);</a>
<a name="ln2894"> </a>
<a name="ln2895">                  for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln2896">                        if (l-&gt;autoplace() &amp;&amp; l-&gt;placeBelow()) {</a>
<a name="ln2897">                              qreal yOff = l-&gt;offset().y();</a>
<a name="ln2898">                              QPointF offset = l-&gt;pos() + cr-&gt;pos() + s.pos() + s.measure()-&gt;pos();</a>
<a name="ln2899">                              QRectF r = l-&gt;bbox().translated(offset);</a>
<a name="ln2900">                              r.translate(0.0, -yOff);</a>
<a name="ln2901">                              sk.add(r.x(), r.top(), r.width());</a>
<a name="ln2902">                              }</a>
<a name="ln2903">                        }</a>
<a name="ln2904">                  SysStaff* ss = s.measure()-&gt;system()-&gt;staff(staffIdx);</a>
<a name="ln2905">                  for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln2906">                        if (l-&gt;autoplace() &amp;&amp; l-&gt;placeBelow()) {</a>
<a name="ln2907">                              qreal y = ss-&gt;skyline().south().minDistance(sk);</a>
<a name="ln2908">                              if (y &gt; -lyricsMinTopDistance)</a>
<a name="ln2909">                                    yMax = qMax(yMax, y + lyricsMinTopDistance);</a>
<a name="ln2910">                              }</a>
<a name="ln2911">                        }</a>
<a name="ln2912">                  }</a>
<a name="ln2913">            }</a>
<a name="ln2914">      return yMax;</a>
<a name="ln2915">      }</a>
<a name="ln2916"> </a>
<a name="ln2917">//---------------------------------------------------------</a>
<a name="ln2918">//   findLyricsMinY</a>
<a name="ln2919">//---------------------------------------------------------</a>
<a name="ln2920"> </a>
<a name="ln2921">static qreal findLyricsMinY(Segment&amp; s, int staffIdx)</a>
<a name="ln2922">      {</a>
<a name="ln2923">      qreal yMin = 0.0;</a>
<a name="ln2924">      if (!s.isChordRestType())</a>
<a name="ln2925">            return yMin;</a>
<a name="ln2926">      qreal lyricsMinTopDistance = s.score()-&gt;styleP(Sid::lyricsMinTopDistance);</a>
<a name="ln2927">      for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln2928">            ChordRest* cr = s.cr(staffIdx * VOICES + voice);</a>
<a name="ln2929">            if (cr &amp;&amp; !cr-&gt;lyrics().empty()) {</a>
<a name="ln2930">                  SkylineLine sk(false);</a>
<a name="ln2931"> </a>
<a name="ln2932">                  for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln2933">                        if (l-&gt;autoplace() &amp;&amp; l-&gt;placeAbove()) {</a>
<a name="ln2934">                              qreal yOff = l-&gt;offset().y();</a>
<a name="ln2935">                              QRectF r = l-&gt;bbox().translated(l-&gt;pos() + cr-&gt;pos() + s.pos() + s.measure()-&gt;pos());</a>
<a name="ln2936">                              r.translate(0.0, -yOff);</a>
<a name="ln2937">                              sk.add(r.x(), r.bottom(), r.width());</a>
<a name="ln2938">                              }</a>
<a name="ln2939">                        }</a>
<a name="ln2940">                  SysStaff* ss = s.measure()-&gt;system()-&gt;staff(staffIdx);</a>
<a name="ln2941">                  for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln2942">                        if (l-&gt;autoplace() &amp;&amp; l-&gt;placeAbove()) {</a>
<a name="ln2943">                              qreal y = sk.minDistance(ss-&gt;skyline().north());</a>
<a name="ln2944">                              if (y &gt; -lyricsMinTopDistance)</a>
<a name="ln2945">                                    yMin = qMin(yMin, -y - lyricsMinTopDistance);</a>
<a name="ln2946">                              }</a>
<a name="ln2947">                        }</a>
<a name="ln2948">                  }</a>
<a name="ln2949">            }</a>
<a name="ln2950">      return yMin;</a>
<a name="ln2951">      }</a>
<a name="ln2952"> </a>
<a name="ln2953">static qreal findLyricsMaxY(Measure* m, int staffIdx)</a>
<a name="ln2954">      {</a>
<a name="ln2955">      qreal yMax = 0.0;</a>
<a name="ln2956">      for (Segment&amp; s : m-&gt;segments())</a>
<a name="ln2957">            yMax = qMax(yMax, findLyricsMaxY(s, staffIdx));</a>
<a name="ln2958">      return yMax;</a>
<a name="ln2959">      }</a>
<a name="ln2960"> </a>
<a name="ln2961">static qreal findLyricsMinY(Measure* m, int staffIdx)</a>
<a name="ln2962">      {</a>
<a name="ln2963">      qreal yMin = 0.0;</a>
<a name="ln2964">      for (Segment&amp; s : m-&gt;segments())</a>
<a name="ln2965">            yMin = qMin(yMin, findLyricsMinY(s, staffIdx));</a>
<a name="ln2966">      return yMin;</a>
<a name="ln2967">      }</a>
<a name="ln2968"> </a>
<a name="ln2969">//---------------------------------------------------------</a>
<a name="ln2970">//   applyLyricsMax</a>
<a name="ln2971">//---------------------------------------------------------</a>
<a name="ln2972"> </a>
<a name="ln2973">static void applyLyricsMax(Segment&amp; s, int staffIdx, qreal yMax)</a>
<a name="ln2974">      {</a>
<a name="ln2975">      if (!s.isChordRestType())</a>
<a name="ln2976">            return;</a>
<a name="ln2977">      Skyline&amp; sk = s.measure()-&gt;system()-&gt;staff(staffIdx)-&gt;skyline();</a>
<a name="ln2978">      for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln2979">            ChordRest* cr = s.cr(staffIdx * VOICES + voice);</a>
<a name="ln2980">            if (cr &amp;&amp; !cr-&gt;lyrics().empty()) {</a>
<a name="ln2981">                  qreal lyricsMinBottomDistance = s.score()-&gt;styleP(Sid::lyricsMinBottomDistance);</a>
<a name="ln2982">                  for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln2983">                        if (l-&gt;autoplace() &amp;&amp; l-&gt;placeBelow()) {</a>
<a name="ln2984">                              l-&gt;rypos() += yMax - l-&gt;propertyDefault(Pid::OFFSET).toPointF().y();</a>
<a name="ln2985">                              if (l-&gt;addToSkyline()) {</a>
<a name="ln2986">                                    QPointF offset = l-&gt;pos() + cr-&gt;pos() + s.pos() + s.measure()-&gt;pos();</a>
<a name="ln2987">                                    sk.add(l-&gt;bbox().translated(offset).adjusted(0.0, 0.0, 0.0, lyricsMinBottomDistance));</a>
<a name="ln2988">                                    }</a>
<a name="ln2989">                              }</a>
<a name="ln2990">                        }</a>
<a name="ln2991">                  }</a>
<a name="ln2992">            }</a>
<a name="ln2993">      }</a>
<a name="ln2994"> </a>
<a name="ln2995">static void applyLyricsMax(Measure* m, int staffIdx, qreal yMax)</a>
<a name="ln2996">      {</a>
<a name="ln2997">      for (Segment&amp; s : m-&gt;segments())</a>
<a name="ln2998">            applyLyricsMax(s, staffIdx, yMax);</a>
<a name="ln2999">      }</a>
<a name="ln3000"> </a>
<a name="ln3001">//---------------------------------------------------------</a>
<a name="ln3002">//   applyLyricsMin</a>
<a name="ln3003">//---------------------------------------------------------</a>
<a name="ln3004"> </a>
<a name="ln3005">static void applyLyricsMin(ChordRest* cr, int staffIdx, qreal yMin)</a>
<a name="ln3006">      {</a>
<a name="ln3007">      Skyline&amp; sk = cr-&gt;measure()-&gt;system()-&gt;staff(staffIdx)-&gt;skyline();</a>
<a name="ln3008">      for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln3009">            if (l-&gt;autoplace() &amp;&amp; l-&gt;placeAbove()) {</a>
<a name="ln3010">                  l-&gt;rypos() += yMin - l-&gt;propertyDefault(Pid::OFFSET).toPointF().y();</a>
<a name="ln3011">                  if (l-&gt;addToSkyline()) {</a>
<a name="ln3012">                        QPointF offset = l-&gt;pos() + cr-&gt;pos() + cr-&gt;segment()-&gt;pos() + cr-&gt;segment()-&gt;measure()-&gt;pos();</a>
<a name="ln3013">                        sk.add(l-&gt;bbox().translated(offset));</a>
<a name="ln3014">                        }</a>
<a name="ln3015">                  }</a>
<a name="ln3016">            }</a>
<a name="ln3017">      }</a>
<a name="ln3018"> </a>
<a name="ln3019">static void applyLyricsMin(Measure* m, int staffIdx, qreal yMin)</a>
<a name="ln3020">      {</a>
<a name="ln3021">      for (Segment&amp; s : m-&gt;segments()) {</a>
<a name="ln3022">            if (s.isChordRestType()) {</a>
<a name="ln3023">                  for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln3024">                        ChordRest* cr = s.cr(staffIdx * VOICES + voice);</a>
<a name="ln3025">                        if (cr)</a>
<a name="ln3026">                              applyLyricsMin(cr, staffIdx, yMin);</a>
<a name="ln3027">                        }</a>
<a name="ln3028">                  }</a>
<a name="ln3029">            }</a>
<a name="ln3030">      }</a>
<a name="ln3031"> </a>
<a name="ln3032">//---------------------------------------------------------</a>
<a name="ln3033">//   restoreBeams</a>
<a name="ln3034">//---------------------------------------------------------</a>
<a name="ln3035"> </a>
<a name="ln3036">static void restoreBeams(Measure* m)</a>
<a name="ln3037">      {</a>
<a name="ln3038">      for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln3039">            for (Element* e : s-&gt;elist()) {</a>
<a name="ln3040">                  if (e &amp;&amp; e-&gt;isChordRest()) {</a>
<a name="ln3041">                        ChordRest* cr = toChordRest(e);</a>
<a name="ln3042">                        if (isTopBeam(cr)) {</a>
<a name="ln3043">                              Beam* b = cr-&gt;beam();</a>
<a name="ln3044">                              b-&gt;layout();</a>
<a name="ln3045">                              b-&gt;addSkyline(m-&gt;system()-&gt;staff(b-&gt;staffIdx())-&gt;skyline());</a>
<a name="ln3046">                              }</a>
<a name="ln3047">                        }</a>
<a name="ln3048">                  }</a>
<a name="ln3049">            }</a>
<a name="ln3050">      }</a>
<a name="ln3051"> </a>
<a name="ln3052">//---------------------------------------------------------</a>
<a name="ln3053">//   layoutLyrics</a>
<a name="ln3054">//</a>
<a name="ln3055">//    vertical align lyrics</a>
<a name="ln3056">//</a>
<a name="ln3057">//---------------------------------------------------------</a>
<a name="ln3058"> </a>
<a name="ln3059">void Score::layoutLyrics(System* system)</a>
<a name="ln3060">      {</a>
<a name="ln3061">      std::vector&lt;int&gt; visibleStaves;</a>
<a name="ln3062">      for (int staffIdx = system-&gt;firstVisibleStaff(); staffIdx &lt; nstaves(); staffIdx = system-&gt;nextVisibleStaff(staffIdx))</a>
<a name="ln3063">            visibleStaves.push_back(staffIdx);</a>
<a name="ln3064"> </a>
<a name="ln3065">      //int nAbove[nstaves()];</a>
<a name="ln3066">      std::vector&lt;int&gt; VnAbove(nstaves());</a>
<a name="ln3067"> </a>
<a name="ln3068">      for (int staffIdx : visibleStaves) {</a>
<a name="ln3069">            VnAbove[staffIdx] = 0;</a>
<a name="ln3070">            for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3071">                  if (!mb-&gt;isMeasure())</a>
<a name="ln3072">                        continue;</a>
<a name="ln3073">                  Measure* m = toMeasure(mb);</a>
<a name="ln3074">                  for (Segment&amp; s : m-&gt;segments()) {</a>
<a name="ln3075">                        if (s.isChordRestType()) {</a>
<a name="ln3076">                              for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln3077">                                    ChordRest* cr = s.cr(staffIdx * VOICES + voice);</a>
<a name="ln3078">                                    if (cr) {</a>
<a name="ln3079">                                          int nA = 0;</a>
<a name="ln3080">                                          for (Lyrics* l : cr-&gt;lyrics()) {</a>
<a name="ln3081">                                                // user adjusted offset can possibly change placement</a>
<a name="ln3082">                                                if (l-&gt;offsetChanged() != OffsetChange::NONE) {</a>
<a name="ln3083">                                                      Placement p = l-&gt;placement();</a>
<a name="ln3084">                                                      l-&gt;rebaseOffset();</a>
<a name="ln3085">                                                      if (l-&gt;placement() != p) {</a>
<a name="ln3086">                                                            l-&gt;undoResetProperty(Pid::AUTOPLACE);</a>
<a name="ln3087">                                                            //l-&gt;undoResetProperty(Pid::OFFSET);</a>
<a name="ln3088">                                                            //l-&gt;layout();</a>
<a name="ln3089">                                                            }</a>
<a name="ln3090">                                                      }</a>
<a name="ln3091">                                                l-&gt;setOffsetChanged(false);</a>
<a name="ln3092">                                                if (l-&gt;placeAbove())</a>
<a name="ln3093">                                                      ++nA;</a>
<a name="ln3094">                                                }</a>
<a name="ln3095">                                          VnAbove[staffIdx] = qMax(VnAbove[staffIdx], nA);</a>
<a name="ln3096">                                          }</a>
<a name="ln3097">                                    }</a>
<a name="ln3098">                              }</a>
<a name="ln3099">                        }</a>
<a name="ln3100">                  }</a>
<a name="ln3101">            }</a>
<a name="ln3102"> </a>
<a name="ln3103">      for (int staffIdx : visibleStaves) {</a>
<a name="ln3104">            for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3105">                  if (!mb-&gt;isMeasure())</a>
<a name="ln3106">                        continue;</a>
<a name="ln3107">                  Measure* m = toMeasure(mb);</a>
<a name="ln3108">                  for (Segment&amp; s : m-&gt;segments()) {</a>
<a name="ln3109">                        if (s.isChordRestType()) {</a>
<a name="ln3110">                              for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln3111">                                    ChordRest* cr = s.cr(staffIdx * VOICES + voice);</a>
<a name="ln3112">                                    if (cr) {</a>
<a name="ln3113">                                          for (Lyrics* l : cr-&gt;lyrics())</a>
<a name="ln3114">                                                l-&gt;layout2(VnAbove[staffIdx]);</a>
<a name="ln3115">                                          }</a>
<a name="ln3116">                                    }</a>
<a name="ln3117">                              }</a>
<a name="ln3118">                        }</a>
<a name="ln3119">                  }</a>
<a name="ln3120">            }</a>
<a name="ln3121"> </a>
<a name="ln3122">      VerticalAlignRange ar = VerticalAlignRange(styleI(Sid::autoplaceVerticalAlignRange));</a>
<a name="ln3123"> </a>
<a name="ln3124">      switch (ar) {</a>
<a name="ln3125">            case VerticalAlignRange::MEASURE:</a>
<a name="ln3126">                  for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3127">                        if (!mb-&gt;isMeasure())</a>
<a name="ln3128">                              continue;</a>
<a name="ln3129">                        Measure* m = toMeasure(mb);</a>
<a name="ln3130">                        for (int staffIdx : visibleStaves) {</a>
<a name="ln3131">                              qreal yMax = findLyricsMaxY(m, staffIdx);</a>
<a name="ln3132">                              applyLyricsMax(m, staffIdx, yMax);</a>
<a name="ln3133">                              }</a>
<a name="ln3134">                        }</a>
<a name="ln3135">                  break;</a>
<a name="ln3136">            case VerticalAlignRange::SYSTEM:</a>
<a name="ln3137">                  for (int staffIdx : visibleStaves) {</a>
<a name="ln3138">                        qreal yMax = 0.0;</a>
<a name="ln3139">                        qreal yMin = 0.0;</a>
<a name="ln3140">                        for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3141">                              if (!mb-&gt;isMeasure())</a>
<a name="ln3142">                                    continue;</a>
<a name="ln3143">                              yMax = qMax&lt;qreal&gt;(yMax, findLyricsMaxY(toMeasure(mb), staffIdx));</a>
<a name="ln3144">                              yMin = qMin(yMin, findLyricsMinY(toMeasure(mb), staffIdx));</a>
<a name="ln3145">                              }</a>
<a name="ln3146">                        for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3147">                              if (!mb-&gt;isMeasure())</a>
<a name="ln3148">                                    continue;</a>
<a name="ln3149">                              applyLyricsMax(toMeasure(mb), staffIdx, yMax);</a>
<a name="ln3150">                              applyLyricsMin(toMeasure(mb), staffIdx, yMin);</a>
<a name="ln3151">                              }</a>
<a name="ln3152">                        }</a>
<a name="ln3153">                  break;</a>
<a name="ln3154">            case VerticalAlignRange::SEGMENT:</a>
<a name="ln3155">                  for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3156">                        if (!mb-&gt;isMeasure())</a>
<a name="ln3157">                              continue;</a>
<a name="ln3158">                        Measure* m = toMeasure(mb);</a>
<a name="ln3159">                        for (int staffIdx : visibleStaves) {</a>
<a name="ln3160">                              for (Segment&amp; s : m-&gt;segments()) {</a>
<a name="ln3161">                                    qreal yMax = findLyricsMaxY(s, staffIdx);</a>
<a name="ln3162">                                    applyLyricsMax(s, staffIdx, yMax);</a>
<a name="ln3163">                                    }</a>
<a name="ln3164">                              }</a>
<a name="ln3165">                        }</a>
<a name="ln3166">                  break;</a>
<a name="ln3167">            }</a>
<a name="ln3168">      }</a>
<a name="ln3169"> </a>
<a name="ln3170">//---------------------------------------------------------</a>
<a name="ln3171">//   layoutTies</a>
<a name="ln3172">//---------------------------------------------------------</a>
<a name="ln3173"> </a>
<a name="ln3174">void layoutTies(Chord* ch, System* system, const Fraction&amp; stick)</a>
<a name="ln3175">      {</a>
<a name="ln3176">      SysStaff* staff = system-&gt;staff(ch-&gt;staffIdx());</a>
<a name="ln3177">      if (!staff-&gt;show())</a>
<a name="ln3178">            return;</a>
<a name="ln3179">      for (Note* note : ch-&gt;notes()) {</a>
<a name="ln3180">            Tie* t = note-&gt;tieFor();</a>
<a name="ln3181">            if (t) {</a>
<a name="ln3182">                  TieSegment* ts = t-&gt;layoutFor(system);</a>
<a name="ln3183">                  if (ts &amp;&amp; ts-&gt;addToSkyline())</a>
<a name="ln3184">                        staff-&gt;skyline().add(ts-&gt;shape().translated(ts-&gt;pos()));</a>
<a name="ln3185">                  }</a>
<a name="ln3186">            t = note-&gt;tieBack();</a>
<a name="ln3187">            if (t) {</a>
<a name="ln3188">                  if (t-&gt;startNote()-&gt;tick() &lt; stick) {</a>
<a name="ln3189">                        TieSegment* ts = t-&gt;layoutBack(system);</a>
<a name="ln3190">                        if (ts &amp;&amp; ts-&gt;addToSkyline())</a>
<a name="ln3191">                              staff-&gt;skyline().add(ts-&gt;shape().translated(ts-&gt;pos()));</a>
<a name="ln3192">                        }</a>
<a name="ln3193">                  }</a>
<a name="ln3194">            }</a>
<a name="ln3195">      }</a>
<a name="ln3196"> </a>
<a name="ln3197">//---------------------------------------------------------</a>
<a name="ln3198">//   layoutHarmonies</a>
<a name="ln3199">//---------------------------------------------------------</a>
<a name="ln3200"> </a>
<a name="ln3201">void layoutHarmonies(const std::vector&lt;Segment*&gt;&amp; sl)</a>
<a name="ln3202">      {</a>
<a name="ln3203">      for (const Segment* s : sl) {</a>
<a name="ln3204">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln3205">                  if (e-&gt;isHarmony()) {</a>
<a name="ln3206">                        Harmony* h = toHarmony(e);</a>
<a name="ln3207">                        // For chord symbols that coincide with a chord or rest,</a>
<a name="ln3208">                        // a partial layout can also happen (if needed) during ChordRest layout</a>
<a name="ln3209">                        // in order to calculate a bbox and allocate its shape to the ChordRest.</a>
<a name="ln3210">                        // But that layout (if it happens at all) does not do autoplace,</a>
<a name="ln3211">                        // so we need the full layout here.</a>
<a name="ln3212">                        h-&gt;layout();</a>
<a name="ln3213">                        h-&gt;autoplaceSegmentElement();</a>
<a name="ln3214">                        }</a>
<a name="ln3215">                  }</a>
<a name="ln3216">            }</a>
<a name="ln3217">      }</a>
<a name="ln3218"> </a>
<a name="ln3219">//---------------------------------------------------------</a>
<a name="ln3220">//   processLines</a>
<a name="ln3221">//---------------------------------------------------------</a>
<a name="ln3222"> </a>
<a name="ln3223">static void processLines(System* system, std::vector&lt;Spanner*&gt; lines, bool align)</a>
<a name="ln3224">      {</a>
<a name="ln3225">      std::vector&lt;SpannerSegment*&gt; segments;</a>
<a name="ln3226">      for (Spanner* sp : lines) {</a>
<a name="ln3227">            SpannerSegment* ss = sp-&gt;layoutSystem(system);     // create/layout spanner segment for this system</a>
<a name="ln3228">            if (ss-&gt;autoplace())</a>
<a name="ln3229">                  segments.push_back(ss);</a>
<a name="ln3230">            }</a>
<a name="ln3231"> </a>
<a name="ln3232">      if (align &amp;&amp; segments.size() &gt; 1) {</a>
<a name="ln3233">            const int nstaves = system-&gt;staves()-&gt;size();</a>
<a name="ln3234">            constexpr qreal minY = -1000000.0;</a>
<a name="ln3235">            const qreal defaultY = segments[0]-&gt;rypos();</a>
<a name="ln3236">            std::vector&lt;qreal&gt; y(nstaves, minY);</a>
<a name="ln3237"> </a>
<a name="ln3238">            for (SpannerSegment* ss : segments) {</a>
<a name="ln3239">                  if (ss-&gt;visible()) {</a>
<a name="ln3240">                        qreal&amp; staffY = y[ss-&gt;staffIdx()];</a>
<a name="ln3241">                        staffY = qMax(staffY, ss-&gt;rypos());</a>
<a name="ln3242">                        }</a>
<a name="ln3243">                  }</a>
<a name="ln3244">            for (SpannerSegment* ss : segments) {</a>
<a name="ln3245">                  const qreal staffY = y[ss-&gt;staffIdx()];</a>
<a name="ln3246">                  if (staffY &gt; minY)</a>
<a name="ln3247">                        ss-&gt;rypos() = staffY;</a>
<a name="ln3248">                  else</a>
<a name="ln3249">                        ss-&gt;rypos() = defaultY;</a>
<a name="ln3250">                  }</a>
<a name="ln3251">            }</a>
<a name="ln3252"> </a>
<a name="ln3253">      //</a>
<a name="ln3254">      // add shapes to skyline</a>
<a name="ln3255">      //</a>
<a name="ln3256">      for (SpannerSegment* ss : segments) {</a>
<a name="ln3257">            if (ss-&gt;addToSkyline())</a>
<a name="ln3258">                  system-&gt;staff(ss-&gt;staffIdx())-&gt;skyline().add(ss-&gt;shape().translated(ss-&gt;pos()));</a>
<a name="ln3259">            }</a>
<a name="ln3260">      }</a>
<a name="ln3261"> </a>
<a name="ln3262">//---------------------------------------------------------</a>
<a name="ln3263">//   collectSystem</a>
<a name="ln3264">//---------------------------------------------------------</a>
<a name="ln3265"> </a>
<a name="ln3266">System* Score::collectSystem(LayoutContext&amp; lc)</a>
<a name="ln3267">      {</a>
<a name="ln3268">      if (!lc.curMeasure)</a>
<a name="ln3269">            return 0;</a>
<a name="ln3270">      Measure* measure  = _systems.empty() ? 0 : _systems.back()-&gt;lastMeasure();</a>
<a name="ln3271">      if (measure) {</a>
<a name="ln3272">            lc.firstSystem        = measure-&gt;sectionBreak() &amp;&amp; _layoutMode != LayoutMode::FLOAT;</a>
<a name="ln3273">            lc.startWithLongNames = lc.firstSystem &amp;&amp; measure-&gt;sectionBreakElement()-&gt;startWithLongNames();</a>
<a name="ln3274">            }</a>
<a name="ln3275">      System* system = getNextSystem(lc);</a>
<a name="ln3276">      Fraction lcmTick = lc.curMeasure ? lc.curMeasure-&gt;tick() : Fraction(0,1);</a>
<a name="ln3277">      system-&gt;setInstrumentNames(lc.startWithLongNames, lcmTick);</a>
<a name="ln3278"> </a>
<a name="ln3279">      qreal minWidth    = 0;</a>
<a name="ln3280">      qreal layoutSystemMinWidth = 0;</a>
<a name="ln3281">      bool firstMeasure = true;</a>
<a name="ln3282">      bool createHeader = false;</a>
<a name="ln3283">      qreal systemWidth = styleD(Sid::pagePrintableWidth) * DPI;</a>
<a name="ln3284">      system-&gt;setWidth(systemWidth);</a>
<a name="ln3285"> </a>
<a name="ln3286">      // save state of measure</a>
<a name="ln3287">      qreal curWidth = lc.curMeasure-&gt;width();</a>
<a name="ln3288">      bool curHeader = lc.curMeasure-&gt;header();</a>
<a name="ln3289">      bool curTrailer = lc.curMeasure-&gt;trailer();</a>
<a name="ln3290"> </a>
<a name="ln3291">      while (lc.curMeasure) {    // collect measure for system</a>
<a name="ln3292">            System* oldSystem = lc.curMeasure-&gt;system();</a>
<a name="ln3293">            system-&gt;appendMeasure(lc.curMeasure);</a>
<a name="ln3294"> </a>
<a name="ln3295">            qreal ww  = 0;      // width of current measure</a>
<a name="ln3296"> </a>
<a name="ln3297">            if (lc.curMeasure-&gt;isMeasure()) {</a>
<a name="ln3298">                  Measure* m = toMeasure(lc.curMeasure);</a>
<a name="ln3299">                  if (firstMeasure) {</a>
<a name="ln3300">                        layoutSystemMinWidth = minWidth;</a>
<a name="ln3301">                        system-&gt;layoutSystem(minWidth);</a>
<a name="ln3302">                        minWidth += system-&gt;leftMargin();</a>
<a name="ln3303">                        if (m-&gt;repeatStart()) {</a>
<a name="ln3304">                              Segment* s = m-&gt;findSegmentR(SegmentType::StartRepeatBarLine, Fraction(0,1));</a>
<a name="ln3305">                              if (!s-&gt;enabled())</a>
<a name="ln3306">                                    s-&gt;setEnabled(true);</a>
<a name="ln3307">                              }</a>
<a name="ln3308">                        m-&gt;addSystemHeader(lc.firstSystem);</a>
<a name="ln3309">                        firstMeasure = false;</a>
<a name="ln3310">                        createHeader = false;</a>
<a name="ln3311">                        }</a>
<a name="ln3312">                  else {</a>
<a name="ln3313">                        if (createHeader) {</a>
<a name="ln3314">                              m-&gt;addSystemHeader(false);</a>
<a name="ln3315">                              createHeader = false;</a>
<a name="ln3316">                              }</a>
<a name="ln3317">                        else if (m-&gt;header())</a>
<a name="ln3318">                              m-&gt;removeSystemHeader();</a>
<a name="ln3319">                        }</a>
<a name="ln3320"> </a>
<a name="ln3321">                  m-&gt;createEndBarLines(true);</a>
<a name="ln3322">                  m-&gt;addSystemTrailer(m-&gt;nextMeasure());</a>
<a name="ln3323">                  m-&gt;computeMinWidth();</a>
<a name="ln3324">                  ww = m-&gt;width();</a>
<a name="ln3325">                  }</a>
<a name="ln3326">            else if (lc.curMeasure-&gt;isHBox()) {</a>
<a name="ln3327">                  lc.curMeasure-&gt;computeMinWidth();</a>
<a name="ln3328">                  ww = lc.curMeasure-&gt;width();</a>
<a name="ln3329">                  createHeader = toHBox(lc.curMeasure)-&gt;createSystemHeader();</a>
<a name="ln3330">                  }</a>
<a name="ln3331">            else {</a>
<a name="ln3332">                  // vbox:</a>
<a name="ln3333">                  getNextMeasure(lc);</a>
<a name="ln3334">                  system-&gt;layout2();   // compute staff distances</a>
<a name="ln3335">                  return system;</a>
<a name="ln3336">                  }</a>
<a name="ln3337">            // check if lc.curMeasure fits, remove if not</a>
<a name="ln3338">            // collect at least one measure and the break</a>
<a name="ln3339"> </a>
<a name="ln3340">            bool doBreak = (system-&gt;measures().size() &gt; 1) &amp;&amp; ((minWidth + ww) &gt; systemWidth);</a>
<a name="ln3341">            if (doBreak) {</a>
<a name="ln3342">                  if (lc.prevMeasure-&gt;noBreak() &amp;&amp; system-&gt;measures().size() &gt; 2) {</a>
<a name="ln3343">                        // remove last two measures</a>
<a name="ln3344">                        // TODO: check more measures for noBreak()</a>
<a name="ln3345">                        system-&gt;removeLastMeasure();</a>
<a name="ln3346">                        system-&gt;removeLastMeasure();</a>
<a name="ln3347">                        lc.curMeasure-&gt;setSystem(oldSystem);</a>
<a name="ln3348">                        lc.prevMeasure-&gt;setSystem(oldSystem);</a>
<a name="ln3349">                        lc.nextMeasure = lc.curMeasure;</a>
<a name="ln3350">                        lc.curMeasure  = lc.prevMeasure;</a>
<a name="ln3351">                        lc.prevMeasure = lc.curMeasure-&gt;prevMeasure();</a>
<a name="ln3352">                        break;</a>
<a name="ln3353">                        }</a>
<a name="ln3354">                  else if (!lc.prevMeasure-&gt;noBreak()) {</a>
<a name="ln3355">                        // remove last measure</a>
<a name="ln3356">                        system-&gt;removeLastMeasure();</a>
<a name="ln3357">                        lc.curMeasure-&gt;setSystem(oldSystem);</a>
<a name="ln3358">                        break;</a>
<a name="ln3359">                        }</a>
<a name="ln3360">                  }</a>
<a name="ln3361"> </a>
<a name="ln3362">            if (lc.prevMeasure &amp;&amp; lc.prevMeasure-&gt;isMeasure() &amp;&amp; lc.prevMeasure-&gt;system() == system) {</a>
<a name="ln3363">                  //</a>
<a name="ln3364">                  // now we know that the previous measure is not the last</a>
<a name="ln3365">                  // measure in the system and we finally can create the end barline for it</a>
<a name="ln3366"> </a>
<a name="ln3367">                  Measure* m = toMeasure(lc.prevMeasure);</a>
<a name="ln3368">                  if (m-&gt;trailer()) {</a>
<a name="ln3369">                        qreal ow = m-&gt;width();</a>
<a name="ln3370">                        m-&gt;removeSystemTrailer();</a>
<a name="ln3371">                        minWidth += m-&gt;width() - ow;</a>
<a name="ln3372">                        }</a>
<a name="ln3373">                  // if the prev measure is an end repeat and the cur measure</a>
<a name="ln3374">                  // is an repeat, the createEndBarLines() created an start-end repeat barline</a>
<a name="ln3375">                  // and we can remove the start repeat barline of the current barline</a>
<a name="ln3376"> </a>
<a name="ln3377">                  if (lc.curMeasure-&gt;isMeasure()) {</a>
<a name="ln3378">                        Measure* m1 = toMeasure(lc.curMeasure);</a>
<a name="ln3379">                        if (m1-&gt;repeatStart()) {</a>
<a name="ln3380">                              Segment* s = m1-&gt;findSegmentR(SegmentType::StartRepeatBarLine, Fraction(0,1));</a>
<a name="ln3381">                              if (!s-&gt;enabled()) {</a>
<a name="ln3382">                                    s-&gt;setEnabled(true);</a>
<a name="ln3383">                                    m1-&gt;computeMinWidth();</a>
<a name="ln3384">                                    ww = m1-&gt;width();</a>
<a name="ln3385">                                    }</a>
<a name="ln3386">                              }</a>
<a name="ln3387">                        }</a>
<a name="ln3388">                  minWidth += m-&gt;createEndBarLines(false);    // create final barLine</a>
<a name="ln3389">                  }</a>
<a name="ln3390"> </a>
<a name="ln3391">            MeasureBase* mb = lc.curMeasure;</a>
<a name="ln3392">            bool lineBreak  = false;</a>
<a name="ln3393">            switch (_layoutMode) {</a>
<a name="ln3394">                  case LayoutMode::PAGE:</a>
<a name="ln3395">                  case LayoutMode::SYSTEM:</a>
<a name="ln3396">                        lineBreak = mb-&gt;pageBreak() || mb-&gt;lineBreak() || mb-&gt;sectionBreak();</a>
<a name="ln3397">                        break;</a>
<a name="ln3398">                  case LayoutMode::FLOAT:</a>
<a name="ln3399">                  case LayoutMode::LINE:</a>
<a name="ln3400">                        lineBreak = false;</a>
<a name="ln3401">                        break;</a>
<a name="ln3402">                  }</a>
<a name="ln3403"> </a>
<a name="ln3404">            // preserve state of next measure (which is about to become current measure)</a>
<a name="ln3405">            if (lc.nextMeasure) {</a>
<a name="ln3406">                  MeasureBase* nmb = lc.nextMeasure;</a>
<a name="ln3407">                  if (nmb-&gt;isMeasure() &amp;&amp; styleB(Sid::createMultiMeasureRests)) {</a>
<a name="ln3408">                        Measure* nm = toMeasure(nmb);</a>
<a name="ln3409">                        if (nm-&gt;hasMMRest())</a>
<a name="ln3410">                              nmb = nm-&gt;mmRest();</a>
<a name="ln3411">                        }</a>
<a name="ln3412">                  curWidth = nmb-&gt;width();</a>
<a name="ln3413">                  curHeader = nmb-&gt;header();</a>
<a name="ln3414">                  curTrailer = nmb-&gt;trailer();</a>
<a name="ln3415">                  }</a>
<a name="ln3416"> </a>
<a name="ln3417">            getNextMeasure(lc);</a>
<a name="ln3418"> </a>
<a name="ln3419">            minWidth += ww;</a>
<a name="ln3420"> </a>
<a name="ln3421">            // ElementType nt = lc.curMeasure ? lc.curMeasure-&gt;type() : ElementType::INVALID;</a>
<a name="ln3422">            mb = lc.curMeasure;</a>
<a name="ln3423">            bool tooWide = false; // minWidth + minMeasureWidth &gt; systemWidth;  // TODO: noBreak</a>
<a name="ln3424">            if (lineBreak || !mb || mb-&gt;isVBox() || mb-&gt;isTBox() || mb-&gt;isFBox() || tooWide)</a>
<a name="ln3425">                  break;</a>
<a name="ln3426">            }</a>
<a name="ln3427"> </a>
<a name="ln3428">      if (lc.endTick &lt; lc.prevMeasure-&gt;tick()) {</a>
<a name="ln3429">            // we've processed the entire range</a>
<a name="ln3430">            // but we need to continue layout until we reach a system whose last measure is the same as previous layout</a>
<a name="ln3431">            if (lc.prevMeasure == lc.systemOldMeasure) {</a>
<a name="ln3432">                  // this system ends in the same place as the previous layout</a>
<a name="ln3433">                  // ok to stop</a>
<a name="ln3434">                  if (lc.curMeasure &amp;&amp; lc.curMeasure-&gt;isMeasure()) {</a>
<a name="ln3435">                        // we may have previously processed first measure of next system</a>
<a name="ln3436">                        // so now we must restore it to its original state</a>
<a name="ln3437">                        Measure* m = toMeasure(lc.curMeasure);</a>
<a name="ln3438">                        if (m-&gt;repeatStart()) {</a>
<a name="ln3439">                              Segment* s = m-&gt;findSegmentR(SegmentType::StartRepeatBarLine, Fraction(0,1));</a>
<a name="ln3440">                              if (!s-&gt;enabled())</a>
<a name="ln3441">                                    s-&gt;setEnabled(true);</a>
<a name="ln3442">                              }</a>
<a name="ln3443">                        bool firstSystem = lc.prevMeasure-&gt;sectionBreak() &amp;&amp; _layoutMode != LayoutMode::FLOAT;</a>
<a name="ln3444">                        if (curHeader)</a>
<a name="ln3445">                              m-&gt;addSystemHeader(firstSystem);</a>
<a name="ln3446">                        else</a>
<a name="ln3447">                              m-&gt;removeSystemHeader();</a>
<a name="ln3448">                        if (curTrailer)</a>
<a name="ln3449">                              m-&gt;addSystemTrailer(m-&gt;nextMeasure());</a>
<a name="ln3450">                        else</a>
<a name="ln3451">                              m-&gt;removeSystemTrailer();</a>
<a name="ln3452">                        m-&gt;computeMinWidth();</a>
<a name="ln3453">                        m-&gt;stretchMeasure(curWidth);</a>
<a name="ln3454">                        restoreBeams(m);</a>
<a name="ln3455">                        }</a>
<a name="ln3456">                  lc.rangeDone = true;</a>
<a name="ln3457">                  }</a>
<a name="ln3458">            }</a>
<a name="ln3459"> </a>
<a name="ln3460">      //</a>
<a name="ln3461">      // now we have a complete set of measures for this system</a>
<a name="ln3462">      //</a>
<a name="ln3463">      // prevMeasure is the last measure in the system</a>
<a name="ln3464">      if (lc.prevMeasure &amp;&amp; lc.prevMeasure-&gt;isMeasure()) {</a>
<a name="ln3465">            breakCrossMeasureBeams(toMeasure(lc.prevMeasure));</a>
<a name="ln3466">            qreal w = toMeasure(lc.prevMeasure)-&gt;createEndBarLines(true);</a>
<a name="ln3467">            minWidth += w;</a>
<a name="ln3468">            }</a>
<a name="ln3469"> </a>
<a name="ln3470">      hideEmptyStaves(system, lc.firstSystem);</a>
<a name="ln3471">      bool allShown = true;</a>
<a name="ln3472">      for (const SysStaff* ss : *system-&gt;staves()) {</a>
<a name="ln3473">            if (!ss-&gt;show()) {</a>
<a name="ln3474">                  allShown = false;</a>
<a name="ln3475">                  break;</a>
<a name="ln3476">                  }</a>
<a name="ln3477">            }</a>
<a name="ln3478">      if (!allShown) {</a>
<a name="ln3479">            // Relayout system decorations to reuse space properly for</a>
<a name="ln3480">            // hidden staves' instrument names or other hidden elements.</a>
<a name="ln3481">            minWidth -= system-&gt;leftMargin();</a>
<a name="ln3482">            system-&gt;layoutSystem(layoutSystemMinWidth);</a>
<a name="ln3483">            minWidth += system-&gt;leftMargin();</a>
<a name="ln3484">            }</a>
<a name="ln3485"> </a>
<a name="ln3486">      //-------------------------------------------------------</a>
<a name="ln3487">      //    add system trailer if needed</a>
<a name="ln3488">      //    (cautionary time/key signatures etc)</a>
<a name="ln3489">      //-------------------------------------------------------</a>
<a name="ln3490"> </a>
<a name="ln3491">      Measure* lm  = system-&gt;lastMeasure();</a>
<a name="ln3492">      if (lm) {</a>
<a name="ln3493">            Measure* nm = lm-&gt;nextMeasure();</a>
<a name="ln3494">            if (nm) {</a>
<a name="ln3495">                  qreal w = lm-&gt;width();</a>
<a name="ln3496">                  lm-&gt;addSystemTrailer(nm);</a>
<a name="ln3497">                  if (lm-&gt;trailer())</a>
<a name="ln3498">                        lm-&gt;computeMinWidth();</a>
<a name="ln3499">                  minWidth += lm-&gt;width() - w;</a>
<a name="ln3500">                  }</a>
<a name="ln3501">            }</a>
<a name="ln3502"> </a>
<a name="ln3503">      //</a>
<a name="ln3504">      // stretch incomplete row</a>
<a name="ln3505">      //</a>
<a name="ln3506">      qreal rest;</a>
<a name="ln3507">      if (MScore::noHorizontalStretch)</a>
<a name="ln3508">            rest = 0;</a>
<a name="ln3509">      else {</a>
<a name="ln3510">            qreal mw          = system-&gt;leftMargin();      // DEBUG</a>
<a name="ln3511">            qreal totalWeight = 0.0;</a>
<a name="ln3512"> </a>
<a name="ln3513">            for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3514">                  if (mb-&gt;isHBox()) {</a>
<a name="ln3515">                        mw += mb-&gt;width();</a>
<a name="ln3516">                        }</a>
<a name="ln3517">                  else if (mb-&gt;isMeasure()) {</a>
<a name="ln3518">                        Measure* m  = toMeasure(mb);</a>
<a name="ln3519">                        mw          += m-&gt;width();               // measures are stretched already with basicStretch()</a>
<a name="ln3520">                        int weight   = m-&gt;layoutWeight();</a>
<a name="ln3521">                        totalWeight += weight * m-&gt;basicStretch();</a>
<a name="ln3522">                        }</a>
<a name="ln3523">                  }</a>
<a name="ln3524"> </a>
<a name="ln3525">#ifndef NDEBUG</a>
<a name="ln3526">            if (!qFuzzyCompare(mw, minWidth))</a>
<a name="ln3527">                  qDebug(&quot;==layoutSystem %6d old %.1f new %.1f&quot;, system-&gt;measures().front()-&gt;tick().ticks(), minWidth, mw);</a>
<a name="ln3528">#endif</a>
<a name="ln3529">            rest = systemWidth - minWidth;</a>
<a name="ln3530">            //</a>
<a name="ln3531">            // dont stretch last system row, if accumulated minWidth is &lt;= lastSystemFillLimit</a>
<a name="ln3532">            //</a>
<a name="ln3533">            if (lc.curMeasure == 0 &amp;&amp; ((minWidth / systemWidth) &lt;= styleD(Sid::lastSystemFillLimit))) {</a>
<a name="ln3534">                  if (minWidth &gt; rest)</a>
<a name="ln3535">                        rest = rest * .5;</a>
<a name="ln3536">                  else</a>
<a name="ln3537">                        rest = minWidth;</a>
<a name="ln3538">                  }</a>
<a name="ln3539">            rest /= totalWeight;</a>
<a name="ln3540">            }</a>
<a name="ln3541"> </a>
<a name="ln3542">      QPointF pos;</a>
<a name="ln3543">      firstMeasure = true;</a>
<a name="ln3544">      bool createBrackets = false;</a>
<a name="ln3545">      for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3546">            qreal ww = mb-&gt;width();</a>
<a name="ln3547">            if (mb-&gt;isMeasure()) {</a>
<a name="ln3548">                  if (firstMeasure) {</a>
<a name="ln3549">                        pos.rx() += system-&gt;leftMargin();</a>
<a name="ln3550">                        firstMeasure = false;</a>
<a name="ln3551">                        }</a>
<a name="ln3552">                  mb-&gt;setPos(pos);</a>
<a name="ln3553">                  Measure* m = toMeasure(mb);</a>
<a name="ln3554">                  qreal stretch = m-&gt;basicStretch();</a>
<a name="ln3555">                  int weight = m-&gt;layoutWeight();</a>
<a name="ln3556">                  ww  += rest * weight * stretch;</a>
<a name="ln3557">                  m-&gt;stretchMeasure(ww);</a>
<a name="ln3558">                  m-&gt;layoutStaffLines();</a>
<a name="ln3559">                  if (createBrackets) {</a>
<a name="ln3560">                        system-&gt;addBrackets(toMeasure(mb));</a>
<a name="ln3561">                        createBrackets = false;</a>
<a name="ln3562">                        }</a>
<a name="ln3563">                  }</a>
<a name="ln3564">            else if (mb-&gt;isHBox()) {</a>
<a name="ln3565">                  mb-&gt;setPos(pos + QPointF(toHBox(mb)-&gt;topGap(), 0.0));</a>
<a name="ln3566">                  mb-&gt;layout();</a>
<a name="ln3567">                  createBrackets = toHBox(mb)-&gt;createSystemHeader();</a>
<a name="ln3568">                  }</a>
<a name="ln3569">            else if (mb-&gt;isVBox())</a>
<a name="ln3570">                  mb-&gt;setPos(pos);</a>
<a name="ln3571">            pos.rx() += ww;</a>
<a name="ln3572">            }</a>
<a name="ln3573">      system-&gt;setWidth(pos.x());</a>
<a name="ln3574"> </a>
<a name="ln3575">      layoutSystemElements(system, lc);</a>
<a name="ln3576">      system-&gt;layout2();   // compute staff distances</a>
<a name="ln3577"> </a>
<a name="ln3578">      lm  = system-&gt;lastMeasure();</a>
<a name="ln3579">      if (lm) {</a>
<a name="ln3580">            lc.firstSystem        = lm-&gt;sectionBreak() &amp;&amp; _layoutMode != LayoutMode::FLOAT;</a>
<a name="ln3581">            lc.startWithLongNames = lc.firstSystem &amp;&amp; lm-&gt;sectionBreakElement()-&gt;startWithLongNames();</a>
<a name="ln3582">            }</a>
<a name="ln3583"> </a>
<a name="ln3584">      return system;</a>
<a name="ln3585">      }</a>
<a name="ln3586"> </a>
<a name="ln3587">//---------------------------------------------------------</a>
<a name="ln3588">//   layoutSystemElements</a>
<a name="ln3589">//---------------------------------------------------------</a>
<a name="ln3590"> </a>
<a name="ln3591">void Score::layoutSystemElements(System* system, LayoutContext&amp; lc)</a>
<a name="ln3592">      {</a>
<a name="ln3593">      //-------------------------------------------------------------</a>
<a name="ln3594">      //    create cr segment list to speed up computations</a>
<a name="ln3595">      //-------------------------------------------------------------</a>
<a name="ln3596"> </a>
<a name="ln3597">      std::vector&lt;Segment*&gt; sl;</a>
<a name="ln3598">      for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3599">            if (!mb-&gt;isMeasure())</a>
<a name="ln3600">                  continue;</a>
<a name="ln3601">            Measure* m = toMeasure(mb);</a>
<a name="ln3602">            m-&gt;layoutMeasureNumber();</a>
<a name="ln3603">            // in continuous view, entire score is one system</a>
<a name="ln3604">            // but we only need to process the range</a>
<a name="ln3605">            if (lineMode() &amp;&amp; (m-&gt;tick() &lt; lc.startTick || m-&gt;tick() &gt; lc.endTick))</a>
<a name="ln3606">                  continue;</a>
<a name="ln3607">            for (Segment* s = m-&gt;first(); s; s = s-&gt;next()) {</a>
<a name="ln3608">                  if (s-&gt;isChordRestType() || !s-&gt;annotations().empty())</a>
<a name="ln3609">                        sl.push_back(s);</a>
<a name="ln3610">                  }</a>
<a name="ln3611">            }</a>
<a name="ln3612"> </a>
<a name="ln3613">      //-------------------------------------------------------------</a>
<a name="ln3614">      // layout beams</a>
<a name="ln3615">      //  Needs to be done before creating skylines as stem lengths</a>
<a name="ln3616">      //  may change.</a>
<a name="ln3617">      //-------------------------------------------------------------</a>
<a name="ln3618"> </a>
<a name="ln3619">      for (Segment* s : sl) {</a>
<a name="ln3620">            for (Element* e : s-&gt;elist()) {</a>
<a name="ln3621">                  if (!e || !e-&gt;isChordRest() || !score()-&gt;staff(e-&gt;staffIdx())-&gt;show()) {</a>
<a name="ln3622">                        // the beam and its system may still be referenced when selecting all,</a>
<a name="ln3623">                        // even if the staff is invisible. The old system is invalid and does cause problems in #284012</a>
<a name="ln3624">                        if (e &amp;&amp; e-&gt;isChordRest() &amp;&amp; !score()-&gt;staff(e-&gt;staffIdx())-&gt;show() &amp;&amp; toChordRest(e)-&gt;beam())</a>
<a name="ln3625">                              toChordRest(e)-&gt;beam()-&gt;setParent(nullptr);</a>
<a name="ln3626">                        continue;</a>
<a name="ln3627">                        }</a>
<a name="ln3628">                  ChordRest* cr = toChordRest(e);</a>
<a name="ln3629"> </a>
<a name="ln3630">                  // layout beam</a>
<a name="ln3631">                  if (isTopBeam(cr)) {</a>
<a name="ln3632">                        Beam* b = cr-&gt;beam();</a>
<a name="ln3633">                        b-&gt;layout();</a>
<a name="ln3634">                        }</a>
<a name="ln3635">                  }</a>
<a name="ln3636">            }</a>
<a name="ln3637"> </a>
<a name="ln3638">      //-------------------------------------------------------------</a>
<a name="ln3639">      //    create skylines</a>
<a name="ln3640">      //-------------------------------------------------------------</a>
<a name="ln3641"> </a>
<a name="ln3642">      for (int staffIdx = 0; staffIdx &lt; nstaves(); ++staffIdx) {</a>
<a name="ln3643">            SysStaff* ss = system-&gt;staff(staffIdx);</a>
<a name="ln3644">            Skyline&amp; skyline = ss-&gt;skyline();</a>
<a name="ln3645">            skyline.clear();</a>
<a name="ln3646">            for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln3647">                  if (!mb-&gt;isMeasure())</a>
<a name="ln3648">                        continue;</a>
<a name="ln3649">                  Measure* m = toMeasure(mb);</a>
<a name="ln3650">                  MeasureNumber* mno = m-&gt;noText(staffIdx);</a>
<a name="ln3651">                  // no need to build skyline outside of range in continuous view</a>
<a name="ln3652">                  if (lineMode() &amp;&amp; (m-&gt;tick() &lt; lc.startTick || m-&gt;tick() &gt; lc.endTick))</a>
<a name="ln3653">                        continue;</a>
<a name="ln3654">                  if (mno &amp;&amp; mno-&gt;addToSkyline())</a>
<a name="ln3655">                        ss-&gt;skyline().add(mno-&gt;bbox().translated(m-&gt;pos() + mno-&gt;pos()));</a>
<a name="ln3656">                  if (m-&gt;staffLines(staffIdx)-&gt;addToSkyline())</a>
<a name="ln3657">                        ss-&gt;skyline().add(m-&gt;staffLines(staffIdx)-&gt;bbox().translated(m-&gt;pos()));</a>
<a name="ln3658">                  for (Segment&amp; s : m-&gt;segments()) {</a>
<a name="ln3659">                        if (!s.enabled() || s.isTimeSigType())       // hack: ignore time signatures</a>
<a name="ln3660">                              continue;</a>
<a name="ln3661">                        QPointF p(s.pos() + m-&gt;pos());</a>
<a name="ln3662">                        if (s.segmentType() &amp; (SegmentType::BarLine | SegmentType::EndBarLine | SegmentType::StartRepeatBarLine | SegmentType::BeginBarLine)) {</a>
<a name="ln3663">                              BarLine* bl = toBarLine(s.element(staffIdx * VOICES));</a>
<a name="ln3664">                              if (bl &amp;&amp; bl-&gt;addToSkyline()) {</a>
<a name="ln3665">                                    QRectF r = bl-&gt;layoutRect();</a>
<a name="ln3666">                                    skyline.add(r.translated(bl-&gt;pos() + p));</a>
<a name="ln3667">                                    }</a>
<a name="ln3668">                              }</a>
<a name="ln3669">                        else {</a>
<a name="ln3670">                              int strack = staffIdx * VOICES;</a>
<a name="ln3671">                              int etrack = strack + VOICES;</a>
<a name="ln3672">                              for (Element* e : s.elist()) {</a>
<a name="ln3673">                                    if (!e)</a>
<a name="ln3674">                                          continue;</a>
<a name="ln3675">                                    int effectiveTrack = e-&gt;vStaffIdx() * VOICES + e-&gt;voice();</a>
<a name="ln3676">                                    if (effectiveTrack &lt; strack || effectiveTrack &gt;= etrack)</a>
<a name="ln3677">                                          continue;</a>
<a name="ln3678"> </a>
<a name="ln3679">                                    // clear layout for chord-based fingerings</a>
<a name="ln3680">                                    // do this before adding chord to skyline</a>
<a name="ln3681">                                    if (e-&gt;isChord()) {</a>
<a name="ln3682">                                          Chord* c = toChord(e);</a>
<a name="ln3683">                                          std::list&lt;Note*&gt; notes;</a>
<a name="ln3684">                                          for (auto gc : c-&gt;graceNotes()) {</a>
<a name="ln3685">                                                for (auto n : gc-&gt;notes())</a>
<a name="ln3686">                                                      notes.push_back(n);</a>
<a name="ln3687">                                                }</a>
<a name="ln3688">                                          for (auto n : c-&gt;notes())</a>
<a name="ln3689">                                                notes.push_back(n);</a>
<a name="ln3690">                                          for (Note* note : notes) {</a>
<a name="ln3691">                                                for (Element* en : note-&gt;el()) {</a>
<a name="ln3692">                                                      if (en-&gt;isFingering()) {</a>
<a name="ln3693">                                                            Fingering* f = toFingering(en);</a>
<a name="ln3694">                                                            if (f-&gt;layoutType() == ElementType::CHORD) {</a>
<a name="ln3695">                                                                  f-&gt;setPos(QPointF());</a>
<a name="ln3696">                                                                  f-&gt;setbbox(QRectF());</a>
<a name="ln3697">                                                                  }</a>
<a name="ln3698">                                                            }</a>
<a name="ln3699">                                                      }</a>
<a name="ln3700">                                                }</a>
<a name="ln3701">                                          }</a>
<a name="ln3702"> </a>
<a name="ln3703">                                    // add element to skyline</a>
<a name="ln3704">                                    if (e-&gt;addToSkyline())</a>
<a name="ln3705">                                          skyline.add(e-&gt;shape().translated(e-&gt;pos() + p));</a>
<a name="ln3706"> </a>
<a name="ln3707">                                    // add tremolo to skyline</a>
<a name="ln3708">                                    if (e-&gt;isChord() &amp;&amp; toChord(e)-&gt;tremolo()) {</a>
<a name="ln3709">                                          Tremolo* t = toChord(e)-&gt;tremolo();</a>
<a name="ln3710">                                          Chord* c1 = t-&gt;chord1();</a>
<a name="ln3711">                                          Chord* c2 = t-&gt;chord2();</a>
<a name="ln3712">                                          if (!t-&gt;twoNotes() || (c1 &amp;&amp; !c1-&gt;staffMove() &amp;&amp; c2 &amp;&amp; !c2-&gt;staffMove())) {</a>
<a name="ln3713">                                                if (t-&gt;chord() == e &amp;&amp; t-&gt;addToSkyline())</a>
<a name="ln3714">                                                      skyline.add(t-&gt;shape().translated(t-&gt;pos() + e-&gt;pos() + p));</a>
<a name="ln3715">                                                }</a>
<a name="ln3716">                                          }</a>
<a name="ln3717">                                    }</a>
<a name="ln3718">                              }</a>
<a name="ln3719">                        }</a>
<a name="ln3720">                  }</a>
<a name="ln3721">            }</a>
<a name="ln3722"> </a>
<a name="ln3723">      //-------------------------------------------------------------</a>
<a name="ln3724">      // layout fingerings, add beams to skylines</a>
<a name="ln3725">      //-------------------------------------------------------------</a>
<a name="ln3726"> </a>
<a name="ln3727">      for (Segment* s : sl) {</a>
<a name="ln3728">            for (Element* e : s-&gt;elist()) {</a>
<a name="ln3729">                  if (!e || !e-&gt;isChordRest() || !score()-&gt;staff(e-&gt;staffIdx())-&gt;show())</a>
<a name="ln3730">                        continue;</a>
<a name="ln3731">                  ChordRest* cr = toChordRest(e);</a>
<a name="ln3732"> </a>
<a name="ln3733">                  // add beam to skyline</a>
<a name="ln3734">                  if (isTopBeam(cr)) {</a>
<a name="ln3735">                        Beam* b = cr-&gt;beam();</a>
<a name="ln3736">                        b-&gt;addSkyline(system-&gt;staff(b-&gt;staffIdx())-&gt;skyline());</a>
<a name="ln3737">                        }</a>
<a name="ln3738"> </a>
<a name="ln3739">                  // layout chord-based fingerings</a>
<a name="ln3740">                  if (e-&gt;isChord()) {</a>
<a name="ln3741">                        Chord* c = toChord(e);</a>
<a name="ln3742">                        std::list&lt;Note*&gt; notes;</a>
<a name="ln3743">                        for (auto gc : c-&gt;graceNotes()) {</a>
<a name="ln3744">                              for (auto n : gc-&gt;notes())</a>
<a name="ln3745">                                    notes.push_back(n);</a>
<a name="ln3746">                              }</a>
<a name="ln3747">                        for (auto n : c-&gt;notes())</a>
<a name="ln3748">                              notes.push_back(n);</a>
<a name="ln3749">                        std::list&lt;Fingering*&gt; fingerings;</a>
<a name="ln3750">                        for (Note* note : notes) {</a>
<a name="ln3751">                              for (Element* el : note-&gt;el()) {</a>
<a name="ln3752">                                    if (el-&gt;isFingering()) {</a>
<a name="ln3753">                                          Fingering* f = toFingering(el);</a>
<a name="ln3754">                                          if (f-&gt;layoutType() == ElementType::CHORD) {</a>
<a name="ln3755">                                                if (f-&gt;placeAbove())</a>
<a name="ln3756">                                                      fingerings.push_back(f);</a>
<a name="ln3757">                                                else</a>
<a name="ln3758">                                                      fingerings.push_front(f);</a>
<a name="ln3759">                                                }</a>
<a name="ln3760">                                          }</a>
<a name="ln3761">                                    }</a>
<a name="ln3762">                              }</a>
<a name="ln3763">                        for (Fingering* f : fingerings) {</a>
<a name="ln3764">                              f-&gt;layout();</a>
<a name="ln3765">                              if (f-&gt;addToSkyline()) {</a>
<a name="ln3766">                                    Note* n = f-&gt;note();</a>
<a name="ln3767">                                    QRectF r = f-&gt;bbox().translated(f-&gt;pos() + n-&gt;pos() + n-&gt;chord()-&gt;pos() + s-&gt;pos() + s-&gt;measure()-&gt;pos());</a>
<a name="ln3768">                                    system-&gt;staff(f-&gt;note()-&gt;chord()-&gt;vStaffIdx())-&gt;skyline().add(r);</a>
<a name="ln3769">                                    }</a>
<a name="ln3770">                              }</a>
<a name="ln3771">                        }</a>
<a name="ln3772">                  }</a>
<a name="ln3773">            }</a>
<a name="ln3774"> </a>
<a name="ln3775">      //-------------------------------------------------------------</a>
<a name="ln3776">      // layout articulations</a>
<a name="ln3777">      //-------------------------------------------------------------</a>
<a name="ln3778"> </a>
<a name="ln3779">      for (Segment* s : sl) {</a>
<a name="ln3780">            for (Element* e : s-&gt;elist()) {</a>
<a name="ln3781">                  if (!e || !e-&gt;isChordRest() || !score()-&gt;staff(e-&gt;staffIdx())-&gt;show())</a>
<a name="ln3782">                        continue;</a>
<a name="ln3783">                  ChordRest* cr = toChordRest(e);</a>
<a name="ln3784">                  // articulations</a>
<a name="ln3785">                  if (cr-&gt;isChord()) {</a>
<a name="ln3786">                        Chord* c = toChord(cr);</a>
<a name="ln3787">                        c-&gt;layoutArticulations();</a>
<a name="ln3788">                        c-&gt;layoutArticulations2();</a>
<a name="ln3789">                        }</a>
<a name="ln3790">                  }</a>
<a name="ln3791">            }</a>
<a name="ln3792"> </a>
<a name="ln3793">      //-------------------------------------------------------------</a>
<a name="ln3794">      // layout tuplets</a>
<a name="ln3795">      //-------------------------------------------------------------</a>
<a name="ln3796"> </a>
<a name="ln3797">      for (Segment* s : sl) {</a>
<a name="ln3798">            for (Element* e : s-&gt;elist()) {</a>
<a name="ln3799">                  if (!e || !e-&gt;isChordRest() || !score()-&gt;staff(e-&gt;staffIdx())-&gt;show())</a>
<a name="ln3800">                        continue;</a>
<a name="ln3801">                  ChordRest* cr = toChordRest(e);</a>
<a name="ln3802">                  if (!isTopTuplet(cr))</a>
<a name="ln3803">                        continue;</a>
<a name="ln3804">                  DurationElement* de = cr;</a>
<a name="ln3805">                  while (de-&gt;tuplet() &amp;&amp; de-&gt;tuplet()-&gt;elements().front() == de) {</a>
<a name="ln3806">                        Tuplet* t = de-&gt;tuplet();</a>
<a name="ln3807">                        t-&gt;layout();</a>
<a name="ln3808">                        de = t;</a>
<a name="ln3809">                        }</a>
<a name="ln3810">                  }</a>
<a name="ln3811">            }</a>
<a name="ln3812"> </a>
<a name="ln3813">      //-------------------------------------------------------------</a>
<a name="ln3814">      // Drumline sticking</a>
<a name="ln3815">      //-------------------------------------------------------------</a>
<a name="ln3816"> </a>
<a name="ln3817">      for (const Segment* s : sl) {</a>
<a name="ln3818">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln3819">                  if (e-&gt;isSticking())</a>
<a name="ln3820">                        e-&gt;layout();</a>
<a name="ln3821">                  }</a>
<a name="ln3822">            }</a>
<a name="ln3823"> </a>
<a name="ln3824">      //-------------------------------------------------------------</a>
<a name="ln3825">      // layout slurs</a>
<a name="ln3826">      //-------------------------------------------------------------</a>
<a name="ln3827"> </a>
<a name="ln3828">      bool useRange = false;  // TODO: lineMode();</a>
<a name="ln3829">      Fraction stick = useRange ? lc.startTick : system-&gt;measures().front()-&gt;tick();</a>
<a name="ln3830">      Fraction etick = useRange ? lc.endTick : system-&gt;measures().back()-&gt;endTick();</a>
<a name="ln3831">      auto spanners = score()-&gt;spannerMap().findOverlapping(stick.ticks(), etick.ticks());</a>
<a name="ln3832"> </a>
<a name="ln3833">      std::vector&lt;Spanner*&gt; spanner;</a>
<a name="ln3834">      for (auto interval : spanners) {</a>
<a name="ln3835">            Spanner* sp = interval.value;</a>
<a name="ln3836">            sp-&gt;computeStartElement();</a>
<a name="ln3837">            sp-&gt;computeEndElement();</a>
<a name="ln3838">            lc.processedSpanners.insert(sp);</a>
<a name="ln3839">            if (sp-&gt;tick() &lt; etick &amp;&amp; sp-&gt;tick2() &gt;= stick) {</a>
<a name="ln3840">                  if (sp-&gt;isSlur()) {</a>
<a name="ln3841">                        // skip cross-staff slurs</a>
<a name="ln3842">                        ChordRest* scr = sp-&gt;startCR();</a>
<a name="ln3843">                        ChordRest* ecr = sp-&gt;endCR();</a>
<a name="ln3844">                        int idx = sp-&gt;vStaffIdx();</a>
<a name="ln3845">                        if (scr &amp;&amp; ecr &amp;&amp; (scr-&gt;vStaffIdx() != idx || ecr-&gt;vStaffIdx() != idx))</a>
<a name="ln3846">                              continue;</a>
<a name="ln3847">                        spanner.push_back(sp);</a>
<a name="ln3848">                        }</a>
<a name="ln3849">                  }</a>
<a name="ln3850">            }</a>
<a name="ln3851">      processLines(system, spanner, false);</a>
<a name="ln3852">      for (auto s : spanner) {</a>
<a name="ln3853">            Slur* slur = toSlur(s);</a>
<a name="ln3854">            ChordRest* scr = s-&gt;startCR();</a>
<a name="ln3855">            ChordRest* ecr = s-&gt;endCR();</a>
<a name="ln3856">            if (scr &amp;&amp; scr-&gt;isChord())</a>
<a name="ln3857">                  toChord(scr)-&gt;layoutArticulations3(slur);</a>
<a name="ln3858">            if (ecr &amp;&amp; ecr-&gt;isChord())</a>
<a name="ln3859">                  toChord(ecr)-&gt;layoutArticulations3(slur);</a>
<a name="ln3860">            }</a>
<a name="ln3861"> </a>
<a name="ln3862">      std::vector&lt;Dynamic*&gt; dynamics;</a>
<a name="ln3863">      for (Segment* s : sl) {</a>
<a name="ln3864">            for (Element* e : s-&gt;elist()) {</a>
<a name="ln3865">                  if (!e)</a>
<a name="ln3866">                        continue;</a>
<a name="ln3867">                  if (e-&gt;isChord()) {</a>
<a name="ln3868">                        Chord* c = toChord(e);</a>
<a name="ln3869">                        for (Chord* ch : c-&gt;graceNotes())</a>
<a name="ln3870">                              layoutTies(ch, system, stick);</a>
<a name="ln3871">                        layoutTies(c, system, stick);</a>
<a name="ln3872">                        }</a>
<a name="ln3873">                  }</a>
<a name="ln3874">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln3875">                  if (e-&gt;isDynamic()) {</a>
<a name="ln3876">                        Dynamic* d = toDynamic(e);</a>
<a name="ln3877">                        d-&gt;layout();</a>
<a name="ln3878"> </a>
<a name="ln3879">                        if (d-&gt;autoplace()) {</a>
<a name="ln3880">                              d-&gt;autoplaceSegmentElement(false);</a>
<a name="ln3881">                              dynamics.push_back(d);</a>
<a name="ln3882">                              }</a>
<a name="ln3883">                        }</a>
<a name="ln3884">                  else if (e-&gt;isFiguredBass()) {</a>
<a name="ln3885">                        e-&gt;layout();</a>
<a name="ln3886">                        e-&gt;autoplaceSegmentElement();</a>
<a name="ln3887">                        }</a>
<a name="ln3888">                  }</a>
<a name="ln3889">            }</a>
<a name="ln3890"> </a>
<a name="ln3891">      // add dynamics shape to skyline</a>
<a name="ln3892"> </a>
<a name="ln3893">      for (Dynamic* d : dynamics) {</a>
<a name="ln3894">            if (!d-&gt;addToSkyline())</a>
<a name="ln3895">                  continue;</a>
<a name="ln3896">            int si = d-&gt;staffIdx();</a>
<a name="ln3897">            Segment* s = d-&gt;segment();</a>
<a name="ln3898">            Measure* m = s-&gt;measure();</a>
<a name="ln3899">            system-&gt;staff(si)-&gt;skyline().add(d-&gt;shape().translated(d-&gt;pos() + s-&gt;pos() + m-&gt;pos()));</a>
<a name="ln3900">            }</a>
<a name="ln3901"> </a>
<a name="ln3902">      //-------------------------------------------------------------</a>
<a name="ln3903">      // layout SpannerSegments for current system</a>
<a name="ln3904">      // ottavas, pedals, voltas are collected here, but layouted later</a>
<a name="ln3905">      //-------------------------------------------------------------</a>
<a name="ln3906"> </a>
<a name="ln3907">      spanner.clear();</a>
<a name="ln3908">      std::vector&lt;Spanner*&gt; hairpins;</a>
<a name="ln3909">      std::vector&lt;Spanner*&gt; ottavas;</a>
<a name="ln3910">      std::vector&lt;Spanner*&gt; pedal;</a>
<a name="ln3911">      std::vector&lt;Spanner*&gt; voltas;</a>
<a name="ln3912"> </a>
<a name="ln3913">      for (auto interval : spanners) {</a>
<a name="ln3914">            Spanner* sp = interval.value;</a>
<a name="ln3915">            if (sp-&gt;tick() &lt; etick &amp;&amp; sp-&gt;tick2() &gt; stick) {</a>
<a name="ln3916">                  if (sp-&gt;isOttava())</a>
<a name="ln3917">                        ottavas.push_back(sp);</a>
<a name="ln3918">                  else if (sp-&gt;isPedal())</a>
<a name="ln3919">                        pedal.push_back(sp);</a>
<a name="ln3920">                  else if (sp-&gt;isVolta())</a>
<a name="ln3921">                        voltas.push_back(sp);</a>
<a name="ln3922">                  else if (sp-&gt;isHairpin())</a>
<a name="ln3923">                        hairpins.push_back(sp);</a>
<a name="ln3924">                  else if (!sp-&gt;isSlur() &amp;&amp; !sp-&gt;isVolta())    // slurs are already</a>
<a name="ln3925">                        spanner.push_back(sp);</a>
<a name="ln3926">                  }</a>
<a name="ln3927">            }</a>
<a name="ln3928">      processLines(system, hairpins, false);</a>
<a name="ln3929">      processLines(system, spanner, false);</a>
<a name="ln3930"> </a>
<a name="ln3931">      //-------------------------------------------------------------</a>
<a name="ln3932">      // Fermata, TremoloBar</a>
<a name="ln3933">      //-------------------------------------------------------------</a>
<a name="ln3934"> </a>
<a name="ln3935">      for (const Segment* s : sl) {</a>
<a name="ln3936">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln3937">                  if (e-&gt;isFermata() || e-&gt;isTremoloBar())</a>
<a name="ln3938">                        e-&gt;layout();</a>
<a name="ln3939">                  }</a>
<a name="ln3940">            }</a>
<a name="ln3941"> </a>
<a name="ln3942">      //-------------------------------------------------------------</a>
<a name="ln3943">      // Ottava, Pedal</a>
<a name="ln3944">      //-------------------------------------------------------------</a>
<a name="ln3945"> </a>
<a name="ln3946">      processLines(system, ottavas, false);</a>
<a name="ln3947">      processLines(system, pedal,   true);</a>
<a name="ln3948"> </a>
<a name="ln3949">      //-------------------------------------------------------------</a>
<a name="ln3950">      // Lyric</a>
<a name="ln3951">      //-------------------------------------------------------------</a>
<a name="ln3952"> </a>
<a name="ln3953">      layoutLyrics(system);</a>
<a name="ln3954"> </a>
<a name="ln3955">      // here are lyrics dashes and melisma</a>
<a name="ln3956">      for (Spanner* sp : _unmanagedSpanner) {</a>
<a name="ln3957">            if (sp-&gt;tick() &gt;= etick || sp-&gt;tick2() &lt;= stick)</a>
<a name="ln3958">                  continue;</a>
<a name="ln3959">            sp-&gt;layoutSystem(system);</a>
<a name="ln3960">            }</a>
<a name="ln3961"> </a>
<a name="ln3962">      //</a>
<a name="ln3963">      // We need to known if we have FretDiagrams in the system to decide when to layout the Harmonies</a>
<a name="ln3964">      //</a>
<a name="ln3965"> </a>
<a name="ln3966">      bool hasFretDiagram = false;</a>
<a name="ln3967">      for (const Segment* s : sl) {</a>
<a name="ln3968">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln3969">                  if (e-&gt;isFretDiagram()) {</a>
<a name="ln3970">                        hasFretDiagram = true;</a>
<a name="ln3971">                        break;</a>
<a name="ln3972">                        }</a>
<a name="ln3973">                  }</a>
<a name="ln3974"> </a>
<a name="ln3975">            if (hasFretDiagram)</a>
<a name="ln3976">                  break;</a>
<a name="ln3977">            }</a>
<a name="ln3978"> </a>
<a name="ln3979">      //-------------------------------------------------------------</a>
<a name="ln3980">      // Harmony, 1st place</a>
<a name="ln3981">      // If we have FretDiagrams, we want the Harmony above this and</a>
<a name="ln3982">      // above the volta, therefore we delay the layout.</a>
<a name="ln3983">      //-------------------------------------------------------------</a>
<a name="ln3984"> </a>
<a name="ln3985">      if (!hasFretDiagram)</a>
<a name="ln3986">            layoutHarmonies(sl);</a>
<a name="ln3987"> </a>
<a name="ln3988">      //-------------------------------------------------------------</a>
<a name="ln3989">      // StaffText, InstrumentChange</a>
<a name="ln3990">      //-------------------------------------------------------------</a>
<a name="ln3991"> </a>
<a name="ln3992">      for (const Segment* s : sl) {</a>
<a name="ln3993">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln3994">                  if (e-&gt;isStaffText() || e-&gt;isSystemText() || e-&gt;isInstrumentChange())</a>
<a name="ln3995">                        e-&gt;layout();</a>
<a name="ln3996">                  }</a>
<a name="ln3997">            }</a>
<a name="ln3998"> </a>
<a name="ln3999">      //-------------------------------------------------------------</a>
<a name="ln4000">      // Jump, Marker</a>
<a name="ln4001">      //-------------------------------------------------------------</a>
<a name="ln4002"> </a>
<a name="ln4003">      for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln4004">            if (!mb-&gt;isMeasure())</a>
<a name="ln4005">                  continue;</a>
<a name="ln4006">            Measure* m = toMeasure(mb);</a>
<a name="ln4007">            for (Element* e : m-&gt;el()) {</a>
<a name="ln4008">                  if (e-&gt;isJump() || e-&gt;isMarker())</a>
<a name="ln4009">                        e-&gt;layout();</a>
<a name="ln4010">                  }</a>
<a name="ln4011">            }</a>
<a name="ln4012"> </a>
<a name="ln4013">      //-------------------------------------------------------------</a>
<a name="ln4014">      // TempoText</a>
<a name="ln4015">      //-------------------------------------------------------------</a>
<a name="ln4016"> </a>
<a name="ln4017">      for (const Segment* s : sl) {</a>
<a name="ln4018">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln4019">                  if (e-&gt;isTempoText())</a>
<a name="ln4020">                        e-&gt;layout();</a>
<a name="ln4021">                  }</a>
<a name="ln4022">            }</a>
<a name="ln4023"> </a>
<a name="ln4024">      //-------------------------------------------------------------</a>
<a name="ln4025">      // layout Voltas for current system</a>
<a name="ln4026">      //-------------------------------------------------------------</a>
<a name="ln4027"> </a>
<a name="ln4028">      processLines(system, voltas, false);</a>
<a name="ln4029"> </a>
<a name="ln4030">      //</a>
<a name="ln4031">      // vertical align volta segments</a>
<a name="ln4032">      //</a>
<a name="ln4033">      for (int staffIdx = 0; staffIdx &lt; nstaves(); ++staffIdx) {</a>
<a name="ln4034">            std::vector&lt;SpannerSegment*&gt; voltaSegments;</a>
<a name="ln4035">            for (SpannerSegment* ss : system-&gt;spannerSegments()) {</a>
<a name="ln4036">                  if (ss-&gt;isVoltaSegment() &amp;&amp; ss-&gt;staffIdx() == staffIdx)</a>
<a name="ln4037">                        voltaSegments.push_back(ss);</a>
<a name="ln4038">                  }</a>
<a name="ln4039">            while (!voltaSegments.empty()) {</a>
<a name="ln4040">                  // we assume voltas are sorted left to right (by tick values)</a>
<a name="ln4041">                  qreal y = 0;</a>
<a name="ln4042">                  int idx = 0;</a>
<a name="ln4043">                  Volta* prevVolta = 0;</a>
<a name="ln4044">                  for (SpannerSegment* ss : voltaSegments) {</a>
<a name="ln4045">                        Volta* volta = toVolta(ss-&gt;spanner());</a>
<a name="ln4046">                        if (prevVolta &amp;&amp; prevVolta != volta) {</a>
<a name="ln4047">                              // check if volta is adjacent to prevVolta</a>
<a name="ln4048">                              if (prevVolta-&gt;tick2() != volta-&gt;tick())</a>
<a name="ln4049">                                    break;</a>
<a name="ln4050">                              }</a>
<a name="ln4051">                        y = qMin(y, ss-&gt;rypos());</a>
<a name="ln4052">                        ++idx;</a>
<a name="ln4053">                        prevVolta = volta;</a>
<a name="ln4054">                        }</a>
<a name="ln4055"> </a>
<a name="ln4056">                  for (int i = 0; i &lt; idx; ++i) {</a>
<a name="ln4057">                        SpannerSegment* ss = voltaSegments[i];</a>
<a name="ln4058">                        ss-&gt;rypos() = y;</a>
<a name="ln4059">                        if (ss-&gt;addToSkyline())</a>
<a name="ln4060">                              system-&gt;staff(staffIdx)-&gt;skyline().add(ss-&gt;shape().translated(ss-&gt;pos()));</a>
<a name="ln4061">                        }</a>
<a name="ln4062"> </a>
<a name="ln4063">                  voltaSegments.erase(voltaSegments.begin(), voltaSegments.begin() + idx);</a>
<a name="ln4064">                  }</a>
<a name="ln4065">            }</a>
<a name="ln4066"> </a>
<a name="ln4067">      //-------------------------------------------------------------</a>
<a name="ln4068">      // FretDiagram</a>
<a name="ln4069">      //-------------------------------------------------------------</a>
<a name="ln4070"> </a>
<a name="ln4071">      if (hasFretDiagram) {</a>
<a name="ln4072">            for (const Segment* s : sl) {</a>
<a name="ln4073">                  for (Element* e : s-&gt;annotations()) {</a>
<a name="ln4074">                        if (e-&gt;isFretDiagram())</a>
<a name="ln4075">                              e-&gt;layout();</a>
<a name="ln4076">                        }</a>
<a name="ln4077">                  }</a>
<a name="ln4078"> </a>
<a name="ln4079">            //-------------------------------------------------------------</a>
<a name="ln4080">            // Harmony, 2nd place</a>
<a name="ln4081">            // We have FretDiagrams, we want the Harmony above this and</a>
<a name="ln4082">            // above the volta.</a>
<a name="ln4083">            //-------------------------------------------------------------</a>
<a name="ln4084"> </a>
<a name="ln4085">            layoutHarmonies(sl);</a>
<a name="ln4086">            }</a>
<a name="ln4087"> </a>
<a name="ln4088">      //-------------------------------------------------------------</a>
<a name="ln4089">      // RehearsalMark</a>
<a name="ln4090">      //-------------------------------------------------------------</a>
<a name="ln4091"> </a>
<a name="ln4092">      for (const Segment* s : sl) {</a>
<a name="ln4093">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln4094">                  if (e-&gt;isRehearsalMark())</a>
<a name="ln4095">                        e-&gt;layout();</a>
<a name="ln4096">                  }</a>
<a name="ln4097">            }</a>
<a name="ln4098">      }</a>
<a name="ln4099"> </a>
<a name="ln4100">//---------------------------------------------------------</a>
<a name="ln4101">//   collectPage</a>
<a name="ln4102">//---------------------------------------------------------</a>
<a name="ln4103"> </a>
<a name="ln4104">void LayoutContext::collectPage()</a>
<a name="ln4105">      {</a>
<a name="ln4106">      const qreal slb = score-&gt;styleP(Sid::staffLowerBorder);</a>
<a name="ln4107">      bool breakPages = score-&gt;layoutMode() != LayoutMode::SYSTEM;</a>
<a name="ln4108">      //qreal y         = prevSystem ? prevSystem-&gt;y() + prevSystem-&gt;height() : page-&gt;tm();</a>
<a name="ln4109">      qreal ey        = page-&gt;height() - page-&gt;bm();</a>
<a name="ln4110"> </a>
<a name="ln4111">      System* nextSystem = 0;</a>
<a name="ln4112">      int systemIdx = -1;</a>
<a name="ln4113"> </a>
<a name="ln4114">      qreal y = page-&gt;systems().isEmpty() ? page-&gt;tm() : page-&gt;system(0)-&gt;y() + page-&gt;system(0)-&gt;height();</a>
<a name="ln4115">      // re-calculate positions for systems before current</a>
<a name="ln4116">      // (they may have been filled on previous layout)</a>
<a name="ln4117">      int pSystems = page-&gt;systems().size();</a>
<a name="ln4118">      for (int i = 1; i &lt; pSystems; ++i) {</a>
<a name="ln4119">            System* cs = page-&gt;system(i);</a>
<a name="ln4120">            System* ps = page-&gt;system(i - 1);</a>
<a name="ln4121">            qreal distance = ps-&gt;minDistance(cs);</a>
<a name="ln4122">            y += distance;</a>
<a name="ln4123">            cs-&gt;setPos(page-&gt;lm(), y);</a>
<a name="ln4124">            y += cs-&gt;height();</a>
<a name="ln4125">            }</a>
<a name="ln4126"> </a>
<a name="ln4127">      for (int k = 0;;++k) {</a>
<a name="ln4128">            //</a>
<a name="ln4129">            // calculate distance to previous system</a>
<a name="ln4130">            //</a>
<a name="ln4131">            qreal distance;</a>
<a name="ln4132">            if (prevSystem)</a>
<a name="ln4133">                  distance = prevSystem-&gt;minDistance(curSystem);</a>
<a name="ln4134">            else {</a>
<a name="ln4135">                  // this is the first system on page</a>
<a name="ln4136">                  if (curSystem-&gt;vbox())</a>
<a name="ln4137">                        distance = 0.0;</a>
<a name="ln4138">                  else {</a>
<a name="ln4139">                        distance = score-&gt;styleP(Sid::staffUpperBorder);</a>
<a name="ln4140">                        bool fixedDistance = false;</a>
<a name="ln4141">                        // TODO: curSystem-&gt;spacerDistance(true)</a>
<a name="ln4142">                        for (MeasureBase* mb : curSystem-&gt;measures()) {</a>
<a name="ln4143">                              if (mb-&gt;isMeasure()) {</a>
<a name="ln4144">                                    Measure* m = toMeasure(mb);</a>
<a name="ln4145">                                    Spacer* sp = m-&gt;vspacerUp(0);       // TODO: first visible?</a>
<a name="ln4146">                                    if (sp) {</a>
<a name="ln4147">                                          if (sp-&gt;spacerType() == SpacerType::FIXED) {</a>
<a name="ln4148">                                                distance = sp-&gt;gap();</a>
<a name="ln4149">                                                fixedDistance = true;</a>
<a name="ln4150">                                                break;</a>
<a name="ln4151">                                                }</a>
<a name="ln4152">                                          else</a>
<a name="ln4153">                                                distance = qMax(distance, sp-&gt;gap());</a>
<a name="ln4154">                                          }</a>
<a name="ln4155">//TODO::ws                                    distance = qMax(distance, -m-&gt;staffShape(0).top());</a>
<a name="ln4156">                                    }</a>
<a name="ln4157">                              }</a>
<a name="ln4158">                        if (!fixedDistance)</a>
<a name="ln4159">                              distance = qMax(distance, curSystem-&gt;minTop());</a>
<a name="ln4160">                        }</a>
<a name="ln4161">                  }</a>
<a name="ln4162">//TODO-ws ??</a>
<a name="ln4163">//          distance += score-&gt;staves().front()-&gt;userDist();</a>
<a name="ln4164"> </a>
<a name="ln4165">            y += distance;</a>
<a name="ln4166">            curSystem-&gt;setPos(page-&gt;lm(), y);</a>
<a name="ln4167">            page-&gt;appendSystem(curSystem);</a>
<a name="ln4168">            y += curSystem-&gt;height();</a>
<a name="ln4169"> </a>
<a name="ln4170">            //</a>
<a name="ln4171">            //  check for page break or if next system will fit on page</a>
<a name="ln4172">            //</a>
<a name="ln4173">            bool collected = false;</a>
<a name="ln4174">            if (rangeDone) {</a>
<a name="ln4175">                  // take next system unchanged</a>
<a name="ln4176">                  if (systemIdx &gt; 0) {</a>
<a name="ln4177">                        nextSystem = score-&gt;systems().value(systemIdx++);</a>
<a name="ln4178">                        if (!nextSystem) {</a>
<a name="ln4179">                              // TODO: handle next movement</a>
<a name="ln4180">                              }</a>
<a name="ln4181">                        }</a>
<a name="ln4182">                  else {</a>
<a name="ln4183">                        nextSystem = systemList.empty() ? 0 : systemList.takeFirst();</a>
<a name="ln4184">                        if (nextSystem)</a>
<a name="ln4185">                              score-&gt;systems().append(nextSystem);</a>
<a name="ln4186">                        else if (score-&gt;isMaster()) {</a>
<a name="ln4187">                              MasterScore* ms = static_cast&lt;MasterScore*&gt;(score)-&gt;next();</a>
<a name="ln4188">                              if (ms) {</a>
<a name="ln4189">                                    score     = ms;</a>
<a name="ln4190">                                    systemIdx = 0;</a>
<a name="ln4191">                                    nextSystem = score-&gt;systems().value(systemIdx++);</a>
<a name="ln4192">                                    }</a>
<a name="ln4193">                              }</a>
<a name="ln4194">                        }</a>
<a name="ln4195">                  }</a>
<a name="ln4196">            else {</a>
<a name="ln4197">                  nextSystem = score-&gt;collectSystem(*this);</a>
<a name="ln4198">                  if (nextSystem)</a>
<a name="ln4199">                        collected = true;</a>
<a name="ln4200">                  if (!nextSystem &amp;&amp; score-&gt;isMaster()) {</a>
<a name="ln4201">                        MasterScore* ms = static_cast&lt;MasterScore*&gt;(score)-&gt;next();</a>
<a name="ln4202">                        if (ms) {</a>
<a name="ln4203">                              score = ms;</a>
<a name="ln4204">                              QList&lt;System*&gt;&amp; systems = ms-&gt;systems();</a>
<a name="ln4205">                              if (systems.empty() || systems.front()-&gt;measures().empty()) {</a>
<a name="ln4206">                                    systemList         = systems;</a>
<a name="ln4207">                                    systems.clear();</a>
<a name="ln4208">                                    measureNo          = 0;</a>
<a name="ln4209">                                    startWithLongNames = true;</a>
<a name="ln4210">                                    firstSystem        = true;</a>
<a name="ln4211">                                    tick               = Fraction(0,1);</a>
<a name="ln4212">                                    prevMeasure        = 0;</a>
<a name="ln4213">                                    curMeasure         = 0;</a>
<a name="ln4214">                                    nextMeasure        = ms-&gt;measures()-&gt;first();</a>
<a name="ln4215">                                    ms-&gt;getNextMeasure(*this);</a>
<a name="ln4216">                                    nextSystem         = ms-&gt;collectSystem(*this);</a>
<a name="ln4217">                                    ms-&gt;setScoreFont(ScoreFont::fontFactory(ms-&gt;styleSt(Sid::MusicalSymbolFont)));</a>
<a name="ln4218">                                    ms-&gt;setNoteHeadWidth(ms-&gt;scoreFont()-&gt;width(SymId::noteheadBlack, ms-&gt;spatium() / SPATIUM20));</a>
<a name="ln4219">                                    }</a>
<a name="ln4220">                              else {</a>
<a name="ln4221">                                    rangeDone = true;</a>
<a name="ln4222">                                    systemIdx = 0;</a>
<a name="ln4223">                                    nextSystem = score-&gt;systems().value(systemIdx++);</a>
<a name="ln4224">                                    }</a>
<a name="ln4225">                              }</a>
<a name="ln4226">                        }</a>
<a name="ln4227">                  }</a>
<a name="ln4228">            prevSystem = curSystem;</a>
<a name="ln4229">            Q_ASSERT(curSystem != nextSystem);</a>
<a name="ln4230">            curSystem  = nextSystem;</a>
<a name="ln4231"> </a>
<a name="ln4232">            bool breakPage = !curSystem || (breakPages &amp;&amp; prevSystem-&gt;pageBreak());</a>
<a name="ln4233"> </a>
<a name="ln4234">            if (!breakPage) {</a>
<a name="ln4235">                  qreal dist = prevSystem-&gt;minDistance(curSystem) + curSystem-&gt;height();</a>
<a name="ln4236">                  Box* vbox = curSystem-&gt;vbox();</a>
<a name="ln4237">                  if (vbox) {</a>
<a name="ln4238">                        dist += vbox-&gt;bottomGap();</a>
<a name="ln4239">                        }</a>
<a name="ln4240">                  else if (!prevSystem-&gt;hasFixedDownDistance()) {</a>
<a name="ln4241">                        qreal margin = qMax(curSystem-&gt;minBottom(), curSystem-&gt;spacerDistance(false));</a>
<a name="ln4242">                        dist += qMax(margin, slb);</a>
<a name="ln4243">                        }</a>
<a name="ln4244">                  breakPage = (y + dist) &gt;= ey &amp;&amp; breakPages;</a>
<a name="ln4245">                  }</a>
<a name="ln4246">            if (breakPage) {</a>
<a name="ln4247">                  qreal dist = qMax(prevSystem-&gt;minBottom(), prevSystem-&gt;spacerDistance(false));</a>
<a name="ln4248">                  dist = qMax(dist, slb);</a>
<a name="ln4249">                  layoutPage(page, ey - (y + dist));</a>
<a name="ln4250">                  // if we collected a system we cannot fit onto this page,</a>
<a name="ln4251">                  // we need to collect next page in order to correctly set system positions</a>
<a name="ln4252">                  if (collected)</a>
<a name="ln4253">                        pageOldMeasure = nullptr;</a>
<a name="ln4254">                  break;</a>
<a name="ln4255">                  }</a>
<a name="ln4256">            }</a>
<a name="ln4257"> </a>
<a name="ln4258">      Fraction stick = Fraction(-1,1);</a>
<a name="ln4259">      for (System* s : page-&gt;systems()) {</a>
<a name="ln4260">            Score* currentScore = s-&gt;score();</a>
<a name="ln4261">            for (MeasureBase* mb : s-&gt;measures()) {</a>
<a name="ln4262">                  if (!mb-&gt;isMeasure())</a>
<a name="ln4263">                        continue;</a>
<a name="ln4264">                  Measure* m = toMeasure(mb);</a>
<a name="ln4265">                  if (stick == Fraction(-1,1))</a>
<a name="ln4266">                        stick = m-&gt;tick();</a>
<a name="ln4267"> </a>
<a name="ln4268">                  for (int track = 0; track &lt; currentScore-&gt;ntracks(); ++track) {</a>
<a name="ln4269">                        for (Segment* segment = m-&gt;first(); segment; segment = segment-&gt;next()) {</a>
<a name="ln4270">                              Element* e = segment-&gt;element(track);</a>
<a name="ln4271">                              if (!e)</a>
<a name="ln4272">                                    continue;</a>
<a name="ln4273">                              if (e-&gt;isChordRest()) {</a>
<a name="ln4274">                                    if (!currentScore-&gt;staff(track2staff(track))-&gt;show())</a>
<a name="ln4275">                                          continue;</a>
<a name="ln4276">                                    ChordRest* cr = toChordRest(e);</a>
<a name="ln4277">                                    if (notTopBeam(cr))                 // layout cross staff beams</a>
<a name="ln4278">                                          cr-&gt;beam()-&gt;layout();</a>
<a name="ln4279">                                    if (notTopTuplet(cr)) {</a>
<a name="ln4280">                                          // fix layout of tuplets</a>
<a name="ln4281">                                          DurationElement* de = cr;</a>
<a name="ln4282">                                          while (de-&gt;tuplet() &amp;&amp; de-&gt;tuplet()-&gt;elements().front() == de) {</a>
<a name="ln4283">                                                Tuplet* t = de-&gt;tuplet();</a>
<a name="ln4284">                                                t-&gt;layout();</a>
<a name="ln4285">                                                de = t;</a>
<a name="ln4286">                                                }</a>
<a name="ln4287">                                          }</a>
<a name="ln4288"> </a>
<a name="ln4289">                                    if (cr-&gt;isChord()) {</a>
<a name="ln4290">                                          Chord* c = toChord(cr);</a>
<a name="ln4291">                                          for (Chord* cc : c-&gt;graceNotes()) {</a>
<a name="ln4292">                                                if (cc-&gt;beam() &amp;&amp; cc-&gt;beam()-&gt;elements().front() == cc)</a>
<a name="ln4293">                                                      cc-&gt;beam()-&gt;layout();</a>
<a name="ln4294">                                                for (Note* n : cc-&gt;notes()) {</a>
<a name="ln4295">                                                      Tie* tie = n-&gt;tieFor();</a>
<a name="ln4296">                                                      if (tie)</a>
<a name="ln4297">                                                            tie-&gt;layout();</a>
<a name="ln4298">                                                      for (Spanner* sp : n-&gt;spannerFor())</a>
<a name="ln4299">                                                            sp-&gt;layout();</a>
<a name="ln4300">                                                      }</a>
<a name="ln4301">                                                for (Element* element : cc-&gt;el()) {</a>
<a name="ln4302">                                                      if (element-&gt;isSlur())</a>
<a name="ln4303">                                                            element-&gt;layout();</a>
<a name="ln4304">                                                      }</a>
<a name="ln4305">                                                }</a>
<a name="ln4306">                                          c-&gt;layoutArpeggio2();</a>
<a name="ln4307">                                          for (Note* n : c-&gt;notes()) {</a>
<a name="ln4308">                                                Tie* tie = n-&gt;tieFor();</a>
<a name="ln4309">                                                if (tie)</a>
<a name="ln4310">                                                      tie-&gt;layout();</a>
<a name="ln4311">                                                for (Spanner* sp : n-&gt;spannerFor())</a>
<a name="ln4312">                                                      sp-&gt;layout();</a>
<a name="ln4313">                                                }</a>
<a name="ln4314">                                          if (c-&gt;tremolo()) {</a>
<a name="ln4315">                                                Tremolo* t = c-&gt;tremolo();</a>
<a name="ln4316">                                                Chord* c1 = t-&gt;chord1();</a>
<a name="ln4317">                                                Chord* c2 = t-&gt;chord2();</a>
<a name="ln4318">                                                if (t-&gt;twoNotes() &amp;&amp; c1 &amp;&amp; c2 &amp;&amp; (c1-&gt;staffMove() || c2-&gt;staffMove()))</a>
<a name="ln4319">                                                      t-&gt;layout();</a>
<a name="ln4320">                                                }</a>
<a name="ln4321">                                          }</a>
<a name="ln4322">                                    }</a>
<a name="ln4323">                              else if (e-&gt;isBarLine())</a>
<a name="ln4324">                                    toBarLine(e)-&gt;layout2();</a>
<a name="ln4325">                              }</a>
<a name="ln4326">                        }</a>
<a name="ln4327">                  m-&gt;layout2();</a>
<a name="ln4328">                  }</a>
<a name="ln4329">            }</a>
<a name="ln4330"> </a>
<a name="ln4331">      if (score-&gt;systemMode()) {</a>
<a name="ln4332">            System* s = page-&gt;systems().last();</a>
<a name="ln4333">            qreal height = s ? s-&gt;pos().y() + s-&gt;height() + s-&gt;minBottom() : page-&gt;tm();</a>
<a name="ln4334">            page-&gt;bbox().setRect(0.0, 0.0, score-&gt;loWidth(), height + page-&gt;bm());</a>
<a name="ln4335">            }</a>
<a name="ln4336"> </a>
<a name="ln4337">      page-&gt;rebuildBspTree();</a>
<a name="ln4338">      }</a>
<a name="ln4339"> </a>
<a name="ln4340">//---------------------------------------------------------</a>
<a name="ln4341">//   doLayout</a>
<a name="ln4342">//    do a complete (re-) layout</a>
<a name="ln4343">//---------------------------------------------------------</a>
<a name="ln4344"> </a>
<a name="ln4345">void Score::doLayout()</a>
<a name="ln4346">      {</a>
<a name="ln4347">      doLayoutRange(Fraction(0,1), Fraction(-1,1));</a>
<a name="ln4348">      }</a>
<a name="ln4349"> </a>
<a name="ln4350">//---------------------------------------------------------</a>
<a name="ln4351">//   CmdStateLocker</a>
<a name="ln4352">//---------------------------------------------------------</a>
<a name="ln4353"> </a>
<a name="ln4354">class CmdStateLocker {</a>
<a name="ln4355">      Score* score;</a>
<a name="ln4356">   public:</a>
<a name="ln4357">      CmdStateLocker(Score* s) : score(s) { score-&gt;cmdState().lock(); }</a>
<a name="ln4358">      ~CmdStateLocker() { score-&gt;cmdState().unlock(); }</a>
<a name="ln4359">      };</a>
<a name="ln4360"> </a>
<a name="ln4361">//---------------------------------------------------------</a>
<a name="ln4362">//   doLayoutRange</a>
<a name="ln4363">//---------------------------------------------------------</a>
<a name="ln4364"> </a>
<a name="ln4365">void Score::doLayoutRange(const Fraction&amp; st, const Fraction&amp; et)</a>
<a name="ln4366">      {</a>
<a name="ln4367">      CmdStateLocker cmdStateLocker(this);</a>
<a name="ln4368">      LayoutContext lc(this);</a>
<a name="ln4369"> </a>
<a name="ln4370">      Fraction stick(st);</a>
<a name="ln4371">      Fraction etick(et);</a>
<a name="ln4372">      Q_ASSERT(!(stick == Fraction(-1,1) &amp;&amp; etick == Fraction(-1,1)));</a>
<a name="ln4373"> </a>
<a name="ln4374">      if (!last() || (lineMode() &amp;&amp; !firstMeasure())) {</a>
<a name="ln4375">            qDebug(&quot;empty score&quot;);</a>
<a name="ln4376">            qDeleteAll(_systems);</a>
<a name="ln4377">            _systems.clear();</a>
<a name="ln4378">            qDeleteAll(pages());</a>
<a name="ln4379">            pages().clear();</a>
<a name="ln4380">            lc.getNextPage();</a>
<a name="ln4381">            return;</a>
<a name="ln4382">            }</a>
<a name="ln4383">//      if (!_systems.isEmpty())</a>
<a name="ln4384">//            return;</a>
<a name="ln4385">      bool layoutAll = stick &lt;= Fraction(0,1) &amp;&amp; (etick &lt; Fraction(0,1) || etick &gt;= masterScore()-&gt;last()-&gt;endTick());</a>
<a name="ln4386">      if (stick &lt; Fraction(0,1))</a>
<a name="ln4387">            stick = Fraction(0,1);</a>
<a name="ln4388">      if (etick &lt; Fraction(0,1))</a>
<a name="ln4389">            etick = last()-&gt;endTick();</a>
<a name="ln4390"> </a>
<a name="ln4391">      lc.endTick     = etick;</a>
<a name="ln4392">      _scoreFont     = ScoreFont::fontFactory(style().value(Sid::MusicalSymbolFont).toString());</a>
<a name="ln4393">      _noteHeadWidth = _scoreFont-&gt;width(SymId::noteheadBlack, spatium() / SPATIUM20);</a>
<a name="ln4394"> </a>
<a name="ln4395">      if (cmdState().layoutFlags &amp; LayoutFlag::REBUILD_MIDI_MAPPING) {</a>
<a name="ln4396">            if (isMaster())</a>
<a name="ln4397">                  masterScore()-&gt;rebuildMidiMapping();</a>
<a name="ln4398">            }</a>
<a name="ln4399">      if (cmdState().layoutFlags &amp; LayoutFlag::FIX_PITCH_VELO)</a>
<a name="ln4400">            updateVelo();</a>
<a name="ln4401">#if 0 // TODO: needed? It was introduced in ab9774ec4098512068b8ef708167d9aa6e702c50</a>
<a name="ln4402">      if (cmdState().layoutFlags &amp; LayoutFlag::PLAY_EVENTS)</a>
<a name="ln4403">            createPlayEvents();</a>
<a name="ln4404">#endif</a>
<a name="ln4405"> </a>
<a name="ln4406">      //---------------------------------------------------</a>
<a name="ln4407">      //    initialize layout context lc</a>
<a name="ln4408">      //---------------------------------------------------</a>
<a name="ln4409"> </a>
<a name="ln4410">      MeasureBase* m = tick2measure(stick);</a>
<a name="ln4411">      if (m == 0)</a>
<a name="ln4412">            m = first();</a>
<a name="ln4413">      // start layout one measure earlier to handle clefs and cautionary elements</a>
<a name="ln4414">      if (m-&gt;prevMeasureMM())</a>
<a name="ln4415">            m = m-&gt;prevMeasureMM();</a>
<a name="ln4416">      else if (m-&gt;prev())</a>
<a name="ln4417">            m = m-&gt;prev();</a>
<a name="ln4418">      while (!m-&gt;isMeasure() &amp;&amp; m-&gt;prev())</a>
<a name="ln4419">            m = m-&gt;prev();</a>
<a name="ln4420"> </a>
<a name="ln4421">      // if the first measure of the score is part of a multi measure rest</a>
<a name="ln4422">      // m-&gt;system() will return a nullptr. We need to find the multi measure</a>
<a name="ln4423">      // rest which replaces the measure range</a>
<a name="ln4424"> </a>
<a name="ln4425">      if (!m-&gt;system() &amp;&amp; m-&gt;isMeasure() &amp;&amp; toMeasure(m)-&gt;hasMMRest()) {</a>
<a name="ln4426">            qDebug(&quot;  dont start with mmrest&quot;);</a>
<a name="ln4427">            m = toMeasure(m)-&gt;mmRest();</a>
<a name="ln4428">            }</a>
<a name="ln4429"> </a>
<a name="ln4430">//      qDebug(&quot;start &lt;%s&gt; tick %d, system %p&quot;, m-&gt;name(), m-&gt;tick(), m-&gt;system());</a>
<a name="ln4431"> </a>
<a name="ln4432">      if (lineMode()) {</a>
<a name="ln4433">            lc.prevMeasure = 0;</a>
<a name="ln4434">            lc.nextMeasure = m;     //_showVBox ? first() : firstMeasure();</a>
<a name="ln4435">            lc.startTick   = m-&gt;tick();</a>
<a name="ln4436">            layoutLinear(layoutAll, lc);</a>
<a name="ln4437">            return;</a>
<a name="ln4438">            }</a>
<a name="ln4439">      if (!layoutAll &amp;&amp; m-&gt;system()) {</a>
<a name="ln4440">            System* system  = m-&gt;system();</a>
<a name="ln4441">            int systemIndex = _systems.indexOf(system);</a>
<a name="ln4442">            lc.page         = system-&gt;page();</a>
<a name="ln4443">            lc.curPage      = pageIdx(lc.page);</a>
<a name="ln4444">            if (lc.curPage == -1)</a>
<a name="ln4445">                  lc.curPage = 0;</a>
<a name="ln4446">            lc.curSystem   = system;</a>
<a name="ln4447">            lc.systemList  = _systems.mid(systemIndex);</a>
<a name="ln4448"> </a>
<a name="ln4449">            if (systemIndex == 0)</a>
<a name="ln4450">                  lc.nextMeasure = _showVBox ? first() : firstMeasure();</a>
<a name="ln4451">            else {</a>
<a name="ln4452">                  System* prevSystem = _systems[systemIndex-1];</a>
<a name="ln4453">                  lc.nextMeasure = prevSystem-&gt;measures().back()-&gt;next();</a>
<a name="ln4454">                  }</a>
<a name="ln4455"> </a>
<a name="ln4456">            _systems.erase(_systems.begin() + systemIndex, _systems.end());</a>
<a name="ln4457">            if (!lc.nextMeasure-&gt;prevMeasure()) {</a>
<a name="ln4458">                  lc.measureNo = 0;</a>
<a name="ln4459">                  lc.tick      = Fraction(0,1);</a>
<a name="ln4460">                  }</a>
<a name="ln4461">            else {</a>
<a name="ln4462">                  LayoutBreak* sectionBreak = lc.nextMeasure-&gt;prevMeasure()-&gt;sectionBreakElement();</a>
<a name="ln4463">                  if (sectionBreak &amp;&amp; sectionBreak-&gt;startWithMeasureOne())</a>
<a name="ln4464">                        lc.measureNo = 0;</a>
<a name="ln4465">                  else</a>
<a name="ln4466">                        lc.measureNo = lc.nextMeasure-&gt;prevMeasure()-&gt;no() + 1; // will be adjusted later with respect</a>
<a name="ln4467">                                                                                // to the user-defined offset.</a>
<a name="ln4468">                  lc.tick      = lc.nextMeasure-&gt;tick();</a>
<a name="ln4469">                  }</a>
<a name="ln4470">            }</a>
<a name="ln4471">      else {</a>
<a name="ln4472">//  qDebug(&quot;layoutAll, systems %p %d&quot;, &amp;_systems, int(_systems.size()));</a>
<a name="ln4473">            //lc.measureNo   = 0;</a>
<a name="ln4474">            //lc.tick        = 0;</a>
<a name="ln4475">            // qDeleteAll(_systems);</a>
<a name="ln4476">            // _systems.clear();</a>
<a name="ln4477">                  // lc.systemList  = _systems;</a>
<a name="ln4478">                  // _systems.clear();</a>
<a name="ln4479"> </a>
<a name="ln4480">            for (System* s : _systems) {</a>
<a name="ln4481">                  for (Bracket* b : s-&gt;brackets()) {</a>
<a name="ln4482">                        if (b-&gt;selected()) {</a>
<a name="ln4483">                              _selection.remove(b);</a>
<a name="ln4484">                              setSelectionChanged(true);</a>
<a name="ln4485">                              }</a>
<a name="ln4486">                        }</a>
<a name="ln4487">//                  for (SpannerSegment* ss : s-&gt;spannerSegments())</a>
<a name="ln4488">//                        ss-&gt;setParent(0);</a>
<a name="ln4489">                  s-&gt;setParent(nullptr);</a>
<a name="ln4490">                  }</a>
<a name="ln4491">            for (MeasureBase* mb = first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln4492">                  mb-&gt;setSystem(0);</a>
<a name="ln4493">                  if (mb-&gt;isMeasure() &amp;&amp; toMeasure(mb)-&gt;mmRest())</a>
<a name="ln4494">                        toMeasure(mb)-&gt;mmRest()-&gt;setSystem(0);</a>
<a name="ln4495">                  }</a>
<a name="ln4496">            qDeleteAll(_systems);</a>
<a name="ln4497">            _systems.clear();</a>
<a name="ln4498"> </a>
<a name="ln4499">            qDeleteAll(pages());</a>
<a name="ln4500">            pages().clear();</a>
<a name="ln4501"> </a>
<a name="ln4502">            lc.nextMeasure = _showVBox ? first() : firstMeasure();</a>
<a name="ln4503">            }</a>
<a name="ln4504"> </a>
<a name="ln4505">      lc.prevMeasure = 0;</a>
<a name="ln4506"> </a>
<a name="ln4507">      getNextMeasure(lc);</a>
<a name="ln4508">      lc.curSystem = collectSystem(lc);</a>
<a name="ln4509"> </a>
<a name="ln4510">      lc.layout();</a>
<a name="ln4511">      }</a>
<a name="ln4512"> </a>
<a name="ln4513">//---------------------------------------------------------</a>
<a name="ln4514">//   layout</a>
<a name="ln4515">//---------------------------------------------------------</a>
<a name="ln4516"> </a>
<a name="ln4517">void LayoutContext::layout()</a>
<a name="ln4518">      {</a>
<a name="ln4519">      MeasureBase* lmb;</a>
<a name="ln4520">      do {</a>
<a name="ln4521">            getNextPage();</a>
<a name="ln4522">            collectPage();</a>
<a name="ln4523"> </a>
<a name="ln4524">            if (page &amp;&amp; !page-&gt;systems().isEmpty())</a>
<a name="ln4525">                  lmb = page-&gt;systems().back()-&gt;measures().back();</a>
<a name="ln4526">            else</a>
<a name="ln4527">                  lmb = nullptr;</a>
<a name="ln4528"> </a>
<a name="ln4529">            // we can stop collecting pages when:</a>
<a name="ln4530">            // 1) we reach the end of score (curSystem is nullptr)</a>
<a name="ln4531">            // or</a>
<a name="ln4532">            // 2) we have fully processed the range and reached a point of stability:</a>
<a name="ln4533">            //    a) we have completed layout for the range (rangeDone is true)</a>
<a name="ln4534">            //    b) we haven't collected a system that will need to go on the next page</a>
<a name="ln4535">            //    c) this page ends with the same measure as the previous layout</a>
<a name="ln4536">            //    pageOldMeasure will be last measure from previous layout if range was completed on or before this page</a>
<a name="ln4537">            //    it will be nullptr if this page was never laid out or if we collected a system for next page</a>
<a name="ln4538">            } while (curSystem &amp;&amp; !(rangeDone &amp;&amp; lmb == pageOldMeasure));</a>
<a name="ln4539">            // &amp;&amp; page-&gt;system(0)-&gt;measures().back()-&gt;tick() &gt; endTick // FIXME: perhaps the first measure was meant? Or last system?</a>
<a name="ln4540"> </a>
<a name="ln4541">      if (!curSystem) {</a>
<a name="ln4542">            // The end of the score. The remaining systems are not needed...</a>
<a name="ln4543">            qDeleteAll(systemList);</a>
<a name="ln4544">            systemList.clear();</a>
<a name="ln4545">            // ...and the remaining pages too</a>
<a name="ln4546">            while (score-&gt;npages() &gt; curPage)</a>
<a name="ln4547">                  delete score-&gt;pages().takeLast();</a>
<a name="ln4548">            }</a>
<a name="ln4549">      else {</a>
<a name="ln4550">            Page* p = curSystem-&gt;page();</a>
<a name="ln4551">            if (p &amp;&amp; (p != page))</a>
<a name="ln4552">                  p-&gt;rebuildBspTree();</a>
<a name="ln4553">            }</a>
<a name="ln4554">      score-&gt;systems().append(systemList);     // TODO</a>
<a name="ln4555">      }</a>
<a name="ln4556"> </a>
<a name="ln4557">//---------------------------------------------------------</a>
<a name="ln4558">//   LayoutContext::~LayoutContext</a>
<a name="ln4559">//---------------------------------------------------------</a>
<a name="ln4560"> </a>
<a name="ln4561">LayoutContext::~LayoutContext()</a>
<a name="ln4562">      {</a>
<a name="ln4563">      for (Spanner* s : processedSpanners)</a>
<a name="ln4564">            s-&gt;layoutSystemsDone();</a>
<a name="ln4565"> </a>
<a name="ln4566">      for (MuseScoreView* v : score-&gt;getViewer())</a>
<a name="ln4567">            v-&gt;layoutChanged();</a>
<a name="ln4568">      }</a>
<a name="ln4569">}</a>

</code></pre>
<div class="balloon" rel="214"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v793/" target="_blank">V793</a> It is odd that the result of the 'upVoices + downVoices' statement is a part of the condition. Perhaps, this statement should have been compared with something else.</p></div>
<div class="balloon" rel="508"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '(A && !B) || (!A && B)' expression is equivalent to the 'bool(A) != bool(B)' expression.</p></div>
<div class="balloon" rel="1904"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v789/" target="_blank">V789</a> Iterators for the 'oldList' container, used in the range-based for loop, become invalid upon the call of the 'erase' function.</p></div>
<div class="balloon" rel="3287"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'lc.curMeasure' pointer was used unsafely after it was verified against nullptr. Check lines: 3276, 3287.</p></div>
<div class="balloon" rel="3443"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'lc.prevMeasure' pointer was utilized before it was verified against nullptr. Check lines: 3443, 3464.</p></div>
<div class="balloon" rel="3829"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'useRange' is always false.</p></div>
<div class="balloon" rel="3830"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'useRange' is always false.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
