
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>Diff.hpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/**</a>
<a name="ln2">   dtl -- Diff Template Library</a>
<a name="ln3">   </a>
<a name="ln4">   In short, Diff Template Library is distributed under so called &quot;BSD license&quot;,</a>
<a name="ln5">   </a>
<a name="ln6">   Copyright (c) 2015 Tatsuhiko Kubo &lt;cubicdaiya@gmail.com&gt;</a>
<a name="ln7">   All rights reserved.</a>
<a name="ln8">   </a>
<a name="ln9">   Redistribution and use in source and binary forms, with or without modification,</a>
<a name="ln10">   are permitted provided that the following conditions are met:</a>
<a name="ln11">   </a>
<a name="ln12">   * Redistributions of source code must retain the above copyright notice,</a>
<a name="ln13">   this list of conditions and the following disclaimer.</a>
<a name="ln14">   </a>
<a name="ln15">   * Redistributions in binary form must reproduce the above copyright notice,</a>
<a name="ln16">   this list of conditions and the following disclaimer in the documentation</a>
<a name="ln17">   and/or other materials provided with the distribution.</a>
<a name="ln18">   </a>
<a name="ln19">   * Neither the name of the authors nor the names of its contributors</a>
<a name="ln20">   may be used to endorse or promote products derived from this software </a>
<a name="ln21">   without specific prior written permission.</a>
<a name="ln22">   </a>
<a name="ln23">   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS</a>
<a name="ln24">   &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT</a>
<a name="ln25">   LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR</a>
<a name="ln26">   A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT</a>
<a name="ln27">   OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,</a>
<a name="ln28">   SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED</a>
<a name="ln29">   TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR</a>
<a name="ln30">   PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF</a>
<a name="ln31">   LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING</a>
<a name="ln32">   NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS</a>
<a name="ln33">   SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</a>
<a name="ln34">*/</a>
<a name="ln35"> </a>
<a name="ln36">/* If you use this library, you must include dtl.hpp only. */</a>
<a name="ln37"> </a>
<a name="ln38">#ifndef DTL_DIFF_H</a>
<a name="ln39">#define DTL_DIFF_H</a>
<a name="ln40"> </a>
<a name="ln41">namespace dtl {</a>
<a name="ln42">    </a>
<a name="ln43">    /**</a>
<a name="ln44">     * diff class template</a>
<a name="ln45">     * sequence must support random_access_iterator.</a>
<a name="ln46">     */</a>
<a name="ln47">    template &lt;typename elem, typename sequence = vector&lt; elem &gt;, typename comparator = Compare&lt; elem &gt; &gt;</a>
<a name="ln48">    class Diff</a>
<a name="ln49">    {</a>
<a name="ln50">    private :</a>
<a name="ln51">        dtl_typedefs(elem, sequence)</a>
<a name="ln52">        sequence           A;</a>
<a name="ln53">        sequence           B;</a>
<a name="ln54">        size_t             M;</a>
<a name="ln55">        size_t             N;</a>
<a name="ln56">        size_t             delta;</a>
<a name="ln57">        size_t             offset;</a>
<a name="ln58">        long long          *fp;</a>
<a name="ln59">        long long          editDistance;</a>
<a name="ln60">        Lcs&lt; elem &gt;        lcs;</a>
<a name="ln61">        Ses&lt; elem &gt;        ses;</a>
<a name="ln62">        editPath           path;</a>
<a name="ln63">        editPathCordinates pathCordinates;</a>
<a name="ln64">        bool               swapped;</a>
<a name="ln65">        bool               huge;</a>
<a name="ln66">        bool               trivial;</a>
<a name="ln67">        bool               editDistanceOnly;</a>
<a name="ln68">        uniHunkVec         uniHunks;</a>
<a name="ln69">        comparator         cmp;</a>
<a name="ln70">    public :</a>
<a name="ln71">        Diff () {}</a>
<a name="ln72">        </a>
<a name="ln73">        Diff (const sequence&amp; a, </a>
<a name="ln74">              const sequence&amp; b) : A(a), B(b), ses(false) {</a>
<a name="ln75">            init();</a>
<a name="ln76">        }</a>
<a name="ln77">        </a>
<a name="ln78">        Diff (const sequence&amp; a,</a>
<a name="ln79">              const sequence&amp; b,</a>
<a name="ln80">              bool deletesFirst) : A(a), B(b), ses(deletesFirst) {</a>
<a name="ln81">            init();</a>
<a name="ln82">        }</a>
<a name="ln83">        </a>
<a name="ln84">        Diff (const sequence&amp; a,</a>
<a name="ln85">              const sequence&amp; b, </a>
<a name="ln86">              const comparator&amp; comp) : A(a), B(b), ses(false), cmp(comp) {</a>
<a name="ln87">            init();</a>
<a name="ln88">        }</a>
<a name="ln89">        </a>
<a name="ln90">        Diff (const sequence&amp; a, </a>
<a name="ln91">              const sequence&amp; b, </a>
<a name="ln92">              bool deleteFirst,</a>
<a name="ln93">              const comparator&amp; comp) : A(a), B(b), ses(deleteFirst), cmp(comp) {</a>
<a name="ln94">            init();</a>
<a name="ln95">        }</a>
<a name="ln96">        </a>
<a name="ln97">        ~Diff() {}</a>
<a name="ln98">        </a>
<a name="ln99">        long long getEditDistance () const {</a>
<a name="ln100">            return editDistance;</a>
<a name="ln101">        }</a>
<a name="ln102">        </a>
<a name="ln103">        Lcs&lt; elem &gt; getLcs () const {</a>
<a name="ln104">            return lcs;</a>
<a name="ln105">        }</a>
<a name="ln106">        </a>
<a name="ln107">        elemVec getLcsVec () const {</a>
<a name="ln108">            return lcs.getSequence();</a>
<a name="ln109">        }</a>
<a name="ln110">        </a>
<a name="ln111">        Ses&lt; elem &gt; getSes () const {</a>
<a name="ln112">            return ses;</a>
<a name="ln113">        }</a>
<a name="ln114">        </a>
<a name="ln115">        uniHunkVec getUniHunks () const {</a>
<a name="ln116">            return uniHunks;</a>
<a name="ln117">        }</a>
<a name="ln118">        </a>
<a name="ln119">        /* These should be deprecated */</a>
<a name="ln120">        bool isHuge () const {</a>
<a name="ln121">            return huge;</a>
<a name="ln122">        }</a>
<a name="ln123">        </a>
<a name="ln124">        void onHuge () {</a>
<a name="ln125">            this-&gt;huge = true;</a>
<a name="ln126">        }</a>
<a name="ln127">        </a>
<a name="ln128">        void offHuge () {</a>
<a name="ln129">            this-&gt;huge = false;</a>
<a name="ln130">        }</a>
<a name="ln131">        </a>
<a name="ln132">        bool isUnserious () const {</a>
<a name="ln133">            return trivial;</a>
<a name="ln134">        }</a>
<a name="ln135">        </a>
<a name="ln136">        void onUnserious () {</a>
<a name="ln137">            this-&gt;trivial = true;</a>
<a name="ln138">        }</a>
<a name="ln139">        </a>
<a name="ln140">        void offUnserious () {</a>
<a name="ln141">            this-&gt;trivial = false;</a>
<a name="ln142">        }</a>
<a name="ln143">        </a>
<a name="ln144">        void onOnlyEditDistance () {</a>
<a name="ln145">            this-&gt;editDistanceOnly = true;</a>
<a name="ln146">        }</a>
<a name="ln147">        </a>
<a name="ln148">        /* These are the replacements for the above */</a>
<a name="ln149">        bool hugeEnabled () const {</a>
<a name="ln150">            return huge;</a>
<a name="ln151">        }</a>
<a name="ln152">        </a>
<a name="ln153">        void enableHuge () {</a>
<a name="ln154">            this-&gt;huge = true;</a>
<a name="ln155">        }</a>
<a name="ln156">        </a>
<a name="ln157">        void disableHuge () {</a>
<a name="ln158">            this-&gt;huge = false;</a>
<a name="ln159">        }</a>
<a name="ln160">        </a>
<a name="ln161">        bool trivialEnabled () const {</a>
<a name="ln162">            return trivial;</a>
<a name="ln163">        }</a>
<a name="ln164">        </a>
<a name="ln165">        void enableTrivial () const {</a>
<a name="ln166">            this-&gt;trivial = true;</a>
<a name="ln167">        }</a>
<a name="ln168">        </a>
<a name="ln169">        void disableTrivial () {</a>
<a name="ln170">            this-&gt;trivial = false;</a>
<a name="ln171">        }</a>
<a name="ln172">        </a>
<a name="ln173">        void editDistanceOnlyEnabled () {</a>
<a name="ln174">            this-&gt;editDistanceOnly = true;</a>
<a name="ln175">        }</a>
<a name="ln176">        </a>
<a name="ln177">        /**</a>
<a name="ln178">         * patching with Unified Format Hunks</a>
<a name="ln179">         */</a>
<a name="ln180">        sequence uniPatch (const sequence&amp; seq) {</a>
<a name="ln181">            elemList        seqLst(seq.begin(), seq.end());</a>
<a name="ln182">            sesElemVec      shunk;</a>
<a name="ln183">            sesElemVec_iter vsesIt;</a>
<a name="ln184">            elemList_iter   lstIt         = seqLst.begin();</a>
<a name="ln185">            long long       inc_dec_total = 0;</a>
<a name="ln186">            long long       gap           = 1;</a>
<a name="ln187">            for (uniHunkVec_iter it=uniHunks.begin();it!=uniHunks.end();++it) {</a>
<a name="ln188">                joinSesVec(shunk, it-&gt;common[0]);</a>
<a name="ln189">                joinSesVec(shunk, it-&gt;change);</a>
<a name="ln190">                joinSesVec(shunk, it-&gt;common[1]);</a>
<a name="ln191">                it-&gt;a         += inc_dec_total;</a>
<a name="ln192">                inc_dec_total += it-&gt;inc_dec_count;</a>
<a name="ln193">                for (long long i=0;i&lt;it-&gt;a - gap;++i) {</a>
<a name="ln194">                    ++lstIt;</a>
<a name="ln195">                }</a>
<a name="ln196">                gap = it-&gt;a + it-&gt;b + it-&gt;inc_dec_count;</a>
<a name="ln197">                vsesIt = shunk.begin();</a>
<a name="ln198">                while (vsesIt!=shunk.end()) {</a>
<a name="ln199">                    switch (vsesIt-&gt;second.type) {</a>
<a name="ln200">                    case SES_ADD :</a>
<a name="ln201">                        seqLst.insert(lstIt, vsesIt-&gt;first);</a>
<a name="ln202">                        break;</a>
<a name="ln203">                    case SES_DELETE :</a>
<a name="ln204">                        if (lstIt != seqLst.end()) {</a>
<a name="ln205">                            lstIt = seqLst.erase(lstIt);</a>
<a name="ln206">                        }</a>
<a name="ln207">                        break;</a>
<a name="ln208">                    case SES_COMMON :</a>
<a name="ln209">                        if (lstIt != seqLst.end()) {</a>
<a name="ln210">                            ++lstIt;</a>
<a name="ln211">                        }</a>
<a name="ln212">                        break;</a>
<a name="ln213">                    default :</a>
<a name="ln214">                        // no fall-through</a>
<a name="ln215">                        break;</a>
<a name="ln216">                    }</a>
<a name="ln217">                    ++vsesIt;</a>
<a name="ln218">                }</a>
<a name="ln219">                shunk.clear();</a>
<a name="ln220">            }</a>
<a name="ln221">            </a>
<a name="ln222">            sequence patchedSeq(seqLst.begin(), seqLst.end());</a>
<a name="ln223">            return patchedSeq;</a>
<a name="ln224">        }</a>
<a name="ln225">        </a>
<a name="ln226">        /**</a>
<a name="ln227">         * patching with Shortest Edit Script (SES)</a>
<a name="ln228">         */</a>
<a name="ln229">        sequence patch (const sequence&amp; seq) const {</a>
<a name="ln230">            sesElemVec    sesSeq = ses.getSequence();</a>
<a name="ln231">            elemList      seqLst(seq.begin(), seq.end());</a>
<a name="ln232">            elemList_iter lstIt  = seqLst.begin();</a>
<a name="ln233">            for (sesElemVec_iter sesIt=sesSeq.begin();sesIt!=sesSeq.end();++sesIt) {</a>
<a name="ln234">                switch (sesIt-&gt;second.type) {</a>
<a name="ln235">                case SES_ADD :</a>
<a name="ln236">                    seqLst.insert(lstIt, sesIt-&gt;first);</a>
<a name="ln237">                    break;</a>
<a name="ln238">                case SES_DELETE :</a>
<a name="ln239">                    lstIt = seqLst.erase(lstIt);</a>
<a name="ln240">                    break;</a>
<a name="ln241">                case SES_COMMON :</a>
<a name="ln242">                    ++lstIt;</a>
<a name="ln243">                    break;</a>
<a name="ln244">                default :</a>
<a name="ln245">                    // no through</a>
<a name="ln246">                    break;</a>
<a name="ln247">                }</a>
<a name="ln248">            }</a>
<a name="ln249">            sequence patchedSeq(seqLst.begin(), seqLst.end());</a>
<a name="ln250">            return patchedSeq;</a>
<a name="ln251">        }</a>
<a name="ln252">        </a>
<a name="ln253">        /**</a>
<a name="ln254">         * compose Longest Common Subsequence and Shortest Edit Script.</a>
<a name="ln255">         * The algorithm implemented here is based on &quot;An O(NP) Sequence Comparison Algorithm&quot;</a>
<a name="ln256">         * described by Sun Wu, Udi Manber and Gene Myers</a>
<a name="ln257">         */</a>
<a name="ln258">        void compose() {</a>
<a name="ln259">            </a>
<a name="ln260">            if (isHuge()) {</a>
<a name="ln261">                pathCordinates.reserve(MAX_CORDINATES_SIZE);</a>
<a name="ln262">            }</a>
<a name="ln263">            </a>
<a name="ln264">            long long p = -1;</a>
<a name="ln265">            fp = new long long[M + N + 3];</a>
<a name="ln266">            fill(&amp;fp[0], &amp;fp[M + N + 3], -1);</a>
<a name="ln267">            path = editPath(M + N + 3);</a>
<a name="ln268">            fill(path.begin(), path.end(), -1);</a>
<a name="ln269">        ONP:</a>
<a name="ln270">            do {</a>
<a name="ln271">                ++p;</a>
<a name="ln272">                for (long long k=-p;k&lt;=static_cast&lt;long long&gt;(delta)-1;++k) {</a>
<a name="ln273">                    fp[k+offset] = snake(k, fp[k-1+offset]+1, fp[k+1+offset]);</a>
<a name="ln274">                }</a>
<a name="ln275">                for (long long k=static_cast&lt;long long&gt;(delta)+p;k&gt;=static_cast&lt;long long&gt;(delta)+1;--k) {</a>
<a name="ln276">                    fp[k+offset] = snake(k, fp[k-1+offset]+1, fp[k+1+offset]);</a>
<a name="ln277">                }</a>
<a name="ln278">                fp[delta+offset] = snake(static_cast&lt;long long&gt;(delta), fp[delta-1+offset]+1, fp[delta+1+offset]);</a>
<a name="ln279">            } while (fp[delta+offset] != static_cast&lt;long long&gt;(N) &amp;&amp; pathCordinates.size() &lt; MAX_CORDINATES_SIZE);</a>
<a name="ln280">            </a>
<a name="ln281">            editDistance += static_cast&lt;long long&gt;(delta) + 2 * p;</a>
<a name="ln282">            long long r = path[delta+offset];</a>
<a name="ln283">            P cordinate;</a>
<a name="ln284">            editPathCordinates epc(0);</a>
<a name="ln285">            </a>
<a name="ln286">            // recording edit distance only</a>
<a name="ln287">            if (editDistanceOnly) {</a>
<a name="ln288">                delete[] this-&gt;fp;</a>
<a name="ln289">                return;</a>
<a name="ln290">            }</a>
<a name="ln291">            </a>
<a name="ln292">            while(r != -1) {</a>
<a name="ln293">                cordinate.x = pathCordinates[(size_t)r].x;</a>
<a name="ln294">                cordinate.y = pathCordinates[(size_t)r].y;</a>
<a name="ln295">                epc.push_back(cordinate);</a>
<a name="ln296">                r = pathCordinates[(size_t)r].k;</a>
<a name="ln297">            }</a>
<a name="ln298">            </a>
<a name="ln299">            // record Longest Common Subsequence &amp; Shortest Edit Script</a>
<a name="ln300">            if (!recordSequence(epc)) {</a>
<a name="ln301">                pathCordinates.resize(0);</a>
<a name="ln302">                epc.resize(0);</a>
<a name="ln303">                p = -1;</a>
<a name="ln304">                goto ONP;</a>
<a name="ln305">            }</a>
<a name="ln306">            delete[] this-&gt;fp;</a>
<a name="ln307">        }</a>
<a name="ln308"> </a>
<a name="ln309">        /**</a>
<a name="ln310">         * print difference between A and B as an SES</a>
<a name="ln311">         */</a>
<a name="ln312">        template &lt; typename stream &gt;</a>
<a name="ln313">        void printSES (stream&amp; out) const {</a>
<a name="ln314">            sesElemVec ses_v = ses.getSequence();</a>
<a name="ln315">            for_each(ses_v.begin(), ses_v.end(), ChangePrinter&lt; sesElem, stream &gt;(out));</a>
<a name="ln316">        }</a>
<a name="ln317">        </a>
<a name="ln318">        void printSES (ostream&amp; out = cout) const {</a>
<a name="ln319">            printSES&lt; ostream &gt;(out);</a>
<a name="ln320">        }</a>
<a name="ln321">        </a>
<a name="ln322">        /**</a>
<a name="ln323">         * print differences given an SES</a>
<a name="ln324">         */</a>
<a name="ln325">        template &lt; typename stream &gt;</a>
<a name="ln326">        static void printSES (const Ses&lt; elem &gt;&amp; s, stream&amp; out) {</a>
<a name="ln327">            sesElemVec ses_v = s.getSequence();</a>
<a name="ln328">            for_each(ses_v.begin(), ses_v.end(), ChangePrinter&lt; sesElem, stream &gt;(out));</a>
<a name="ln329">        }</a>
<a name="ln330">        </a>
<a name="ln331">        static void printSES (const Ses&lt; elem &gt;&amp; s, ostream&amp; out = cout) {</a>
<a name="ln332">            printSES&lt; ostream &gt;(s, out);</a>
<a name="ln333">        }</a>
<a name="ln334"> </a>
<a name="ln335">        /**</a>
<a name="ln336">         * print difference between A and B as an SES with custom printer</a>
<a name="ln337">         */</a>
<a name="ln338">        template &lt; typename stream, template &lt; typename SEET, typename STRT &gt; class PT &gt;</a>
<a name="ln339">        void printSES (stream&amp; out) const {</a>
<a name="ln340">            sesElemVec ses_v = ses.getSequence ();</a>
<a name="ln341">            for_each (ses_v.begin (), ses_v.end(), PT &lt; sesElem, stream &gt; (out));</a>
<a name="ln342">        }</a>
<a name="ln343">        </a>
<a name="ln344">        /**</a>
<a name="ln345">         * print difference between A and B in the Unified Format</a>
<a name="ln346">         */</a>
<a name="ln347">        template &lt; typename stream &gt;</a>
<a name="ln348">        void printUnifiedFormat (stream&amp; out) const {</a>
<a name="ln349">            for_each(uniHunks.begin(), uniHunks.end(), UniHunkPrinter&lt; sesElem, stream &gt;(out));</a>
<a name="ln350">        }</a>
<a name="ln351">        </a>
<a name="ln352">        void printUnifiedFormat (ostream&amp; out = cout) const {</a>
<a name="ln353">            printUnifiedFormat&lt; ostream &gt;(out);</a>
<a name="ln354">        }</a>
<a name="ln355">        </a>
<a name="ln356">        /**</a>
<a name="ln357">         * print unified format difference with given unified format hunks</a>
<a name="ln358">         */</a>
<a name="ln359">        template &lt; typename stream &gt;</a>
<a name="ln360">        static void printUnifiedFormat (const uniHunkVec&amp; hunks, stream&amp; out) {</a>
<a name="ln361">            for_each(hunks.begin(), hunks.end(), UniHunkPrinter&lt; sesElem &gt;(out));</a>
<a name="ln362">        }</a>
<a name="ln363"> </a>
<a name="ln364">        static void printUnifiedFormat (const uniHunkVec&amp; hunks, ostream&amp; out = cout) {</a>
<a name="ln365">            printUnifiedFormat&lt; ostream &gt;(hunks, out);</a>
<a name="ln366">        }</a>
<a name="ln367"> </a>
<a name="ln368">        /**</a>
<a name="ln369">         * compose Unified Format Hunks from Shortest Edit Script</a>
<a name="ln370">         */</a>
<a name="ln371">        void composeUnifiedHunks () {</a>
<a name="ln372">            sesElemVec         common[2];</a>
<a name="ln373">            sesElemVec         change;</a>
<a name="ln374">            sesElemVec         ses_v  = ses.getSequence();</a>
<a name="ln375">            long long          l_cnt  = 1;</a>
<a name="ln376">            long long          length = distance(ses_v.begin(), ses_v.end());</a>
<a name="ln377">            long long          middle = 0;</a>
<a name="ln378">            bool               isMiddle, isAfter;</a>
<a name="ln379">            elemInfo           einfo;</a>
<a name="ln380">            long long          a, b, c, d;        // @@ -a,b +c,d @@</a>
<a name="ln381">            long long          inc_dec_count = 0;</a>
<a name="ln382">            uniHunk&lt; sesElem &gt; hunk;</a>
<a name="ln383">            sesElemVec         adds;</a>
<a name="ln384">            sesElemVec         deletes;</a>
<a name="ln385">            </a>
<a name="ln386">            isMiddle = isAfter = false;</a>
<a name="ln387">            a = b = c = d = 0;</a>
<a name="ln388">            </a>
<a name="ln389">            for (sesElemVec_iter it=ses_v.begin();it!=ses_v.end();++it, ++l_cnt) {</a>
<a name="ln390">                einfo = it-&gt;second;</a>
<a name="ln391">                switch (einfo.type) {</a>
<a name="ln392">                case SES_ADD :</a>
<a name="ln393">                    middle = 0;</a>
<a name="ln394">                    ++inc_dec_count;</a>
<a name="ln395">                    adds.push_back(*it);</a>
<a name="ln396">                    if (!isMiddle)       isMiddle = true;</a>
<a name="ln397">                    if (isMiddle)        ++d;</a>
<a name="ln398">                    if (l_cnt &gt;= length) {</a>
<a name="ln399">                        joinSesVec(change, deletes);</a>
<a name="ln400">                        joinSesVec(change, adds);</a>
<a name="ln401">                        isAfter = true;</a>
<a name="ln402">                    }</a>
<a name="ln403">                    break;</a>
<a name="ln404">                case SES_DELETE :</a>
<a name="ln405">                    middle = 0;</a>
<a name="ln406">                    --inc_dec_count;</a>
<a name="ln407">                    deletes.push_back(*it);</a>
<a name="ln408">                    if (!isMiddle)       isMiddle = true;</a>
<a name="ln409">                    if (isMiddle)        ++b;</a>
<a name="ln410">                    if (l_cnt &gt;= length) {</a>
<a name="ln411">                        joinSesVec(change, deletes);</a>
<a name="ln412">                        joinSesVec(change, adds);</a>
<a name="ln413">                        isAfter = true;</a>
<a name="ln414">                    }</a>
<a name="ln415">                    break;</a>
<a name="ln416">                case SES_COMMON :</a>
<a name="ln417">                    ++b;++d;</a>
<a name="ln418">                    if (common[1].empty() &amp;&amp; adds.empty() &amp;&amp; deletes.empty() &amp;&amp; change.empty()) {</a>
<a name="ln419">                        if (static_cast&lt;long long&gt;(common[0].size()) &lt; DTL_CONTEXT_SIZE) {</a>
<a name="ln420">                            if (a == 0 &amp;&amp; c == 0) {</a>
<a name="ln421">                                if (!wasSwapped()) {</a>
<a name="ln422">                                    a = einfo.beforeIdx;</a>
<a name="ln423">                                    c = einfo.afterIdx;</a>
<a name="ln424">                                } else {</a>
<a name="ln425">                                    a = einfo.afterIdx;</a>
<a name="ln426">                                    c = einfo.beforeIdx;</a>
<a name="ln427">                                }</a>
<a name="ln428">                            }</a>
<a name="ln429">                            common[0].push_back(*it);</a>
<a name="ln430">                        } else {</a>
<a name="ln431">                            rotate(common[0].begin(), common[0].begin() + 1, common[0].end());</a>
<a name="ln432">                            common[0].pop_back();</a>
<a name="ln433">                            common[0].push_back(*it);</a>
<a name="ln434">                            ++a;++c;</a>
<a name="ln435">                            --b;--d;</a>
<a name="ln436">                        }</a>
<a name="ln437">                    }</a>
<a name="ln438">                    if (isMiddle &amp;&amp; !isAfter) {</a>
<a name="ln439">                        ++middle;</a>
<a name="ln440">                        joinSesVec(change, deletes);</a>
<a name="ln441">                        joinSesVec(change, adds);</a>
<a name="ln442">                        change.push_back(*it);</a>
<a name="ln443">                        if (middle &gt;= DTL_SEPARATE_SIZE || l_cnt &gt;= length) {</a>
<a name="ln444">                            isAfter = true;</a>
<a name="ln445">                        }</a>
<a name="ln446">                        adds.clear();</a>
<a name="ln447">                        deletes.clear();</a>
<a name="ln448">                    }</a>
<a name="ln449">                    break;</a>
<a name="ln450">                default :</a>
<a name="ln451">                    // no through</a>
<a name="ln452">                    break;</a>
<a name="ln453">                }</a>
<a name="ln454">                // compose unified format hunk</a>
<a name="ln455">                if (isAfter &amp;&amp; !change.empty()) {</a>
<a name="ln456">                    sesElemVec_iter cit = it;</a>
<a name="ln457">                    long long       cnt = 0;</a>
<a name="ln458">                    for (long long i=0;i&lt;DTL_SEPARATE_SIZE &amp;&amp; (cit != ses_v.end());++i, ++cit) {</a>
<a name="ln459">                        if (cit-&gt;second.type == SES_COMMON) {</a>
<a name="ln460">                            ++cnt;</a>
<a name="ln461">                        }</a>
<a name="ln462">                    }</a>
<a name="ln463">                    if (cnt &lt; DTL_SEPARATE_SIZE &amp;&amp; l_cnt &lt; length) {</a>
<a name="ln464">                        middle = 0;</a>
<a name="ln465">                        isAfter = false;</a>
<a name="ln466">                        continue;</a>
<a name="ln467">                    }</a>
<a name="ln468">                    if (static_cast&lt;long long&gt;(common[0].size()) &gt;= DTL_SEPARATE_SIZE) {</a>
<a name="ln469">                        long long c0size = static_cast&lt;long long&gt;(common[0].size());</a>
<a name="ln470">                        rotate(common[0].begin(), </a>
<a name="ln471">                               common[0].begin() + (size_t)c0size - DTL_SEPARATE_SIZE, </a>
<a name="ln472">                               common[0].end());</a>
<a name="ln473">                        for (long long i=0;i&lt;c0size - DTL_SEPARATE_SIZE;++i) {</a>
<a name="ln474">                            common[0].pop_back();</a>
<a name="ln475">                        }</a>
<a name="ln476">                        a += c0size - DTL_SEPARATE_SIZE;</a>
<a name="ln477">                        c += c0size - DTL_SEPARATE_SIZE;</a>
<a name="ln478">                    }</a>
<a name="ln479">                    if (a == 0) ++a;</a>
<a name="ln480">                    if (c == 0) ++c;</a>
<a name="ln481">                    if (wasSwapped()) swap(a, c);</a>
<a name="ln482">                    hunk.a = a;</a>
<a name="ln483">                    hunk.b = b;</a>
<a name="ln484">                    hunk.c = c;</a>
<a name="ln485">                    hunk.d = d;</a>
<a name="ln486">                    hunk.common[0]     = common[0];</a>
<a name="ln487">                    hunk.change        = change;</a>
<a name="ln488">                    hunk.common[1]     = common[1];</a>
<a name="ln489">                    hunk.inc_dec_count = inc_dec_count;</a>
<a name="ln490">                    uniHunks.push_back(hunk);</a>
<a name="ln491">                    isMiddle = false;</a>
<a name="ln492">                    isAfter  = false;</a>
<a name="ln493">                    common[0].clear();</a>
<a name="ln494">                    common[1].clear();</a>
<a name="ln495">                    adds.clear();</a>
<a name="ln496">                    deletes.clear();</a>
<a name="ln497">                    change.clear();</a>
<a name="ln498">                    a = b = c = d = middle = inc_dec_count = 0;</a>
<a name="ln499">                }</a>
<a name="ln500">            }</a>
<a name="ln501">        }</a>
<a name="ln502">        </a>
<a name="ln503">        /**</a>
<a name="ln504">         * compose ses from stream</a>
<a name="ln505">         */</a>
<a name="ln506">        template &lt;typename stream&gt;</a>
<a name="ln507">        static Ses&lt; elem &gt; composeSesFromStream (stream&amp; st)</a>
<a name="ln508">        {</a>
<a name="ln509">            elem        line;</a>
<a name="ln510">            Ses&lt; elem &gt; ret;</a>
<a name="ln511">            long long   x_idx, y_idx;</a>
<a name="ln512">            x_idx = y_idx = 1;</a>
<a name="ln513">            while (getline(st, line)) {</a>
<a name="ln514">                elem mark(line.begin(), line.begin() + 1);</a>
<a name="ln515">                elem e(line.begin() + 1, line.end());</a>
<a name="ln516">                if (mark == SES_MARK_DELETE) {</a>
<a name="ln517">                    ret.addSequence(e, x_idx, 0, SES_DELETE);</a>
<a name="ln518">                    ++x_idx;</a>
<a name="ln519">                } else if (mark == SES_MARK_ADD) {</a>
<a name="ln520">                    ret.addSequence(e, y_idx, 0, SES_ADD);</a>
<a name="ln521">                    ++y_idx;</a>
<a name="ln522">                } else if (mark == SES_MARK_COMMON) {</a>
<a name="ln523">                    ret.addSequence(e, x_idx, y_idx, SES_COMMON);</a>
<a name="ln524">                    ++x_idx;</a>
<a name="ln525">                    ++y_idx;</a>
<a name="ln526">                }</a>
<a name="ln527">            }</a>
<a name="ln528">            return ret;</a>
<a name="ln529">        }</a>
<a name="ln530">        </a>
<a name="ln531">    private :</a>
<a name="ln532">        /**</a>
<a name="ln533">         * initialize</a>
<a name="ln534">         */</a>
<a name="ln535">        void init () {</a>
<a name="ln536">            M = distance(A.begin(), A.end());</a>
<a name="ln537">            N = distance(B.begin(), B.end());</a>
<a name="ln538">            if (M &lt; N) {</a>
<a name="ln539">                swapped = false;</a>
<a name="ln540">            } else {</a>
<a name="ln541">                swap(A, B);</a>
<a name="ln542">                swap(M, N);</a>
<a name="ln543">                swapped = true;</a>
<a name="ln544">            }</a>
<a name="ln545">            editDistance     = 0;</a>
<a name="ln546">            delta            = N - M;</a>
<a name="ln547">            offset           = M + 1;</a>
<a name="ln548">            huge             = false;</a>
<a name="ln549">            trivial          = false;</a>
<a name="ln550">            editDistanceOnly = false;</a>
<a name="ln551">            fp               = NULL;</a>
<a name="ln552">        }</a>
<a name="ln553">        </a>
<a name="ln554">        /**</a>
<a name="ln555">         * search shortest path and record the path</a>
<a name="ln556">         */</a>
<a name="ln557">        long long snake(const long long&amp; k, const long long&amp; above, const long long&amp; below) {</a>
<a name="ln558">            long long r = above &gt; below ? path[(size_t)k-1+offset] : path[(size_t)k+1+offset];</a>
<a name="ln559">            long long y = max(above, below);</a>
<a name="ln560">            long long x = y - k;</a>
<a name="ln561">            while ((size_t)x &lt; M &amp;&amp; (size_t)y &lt; N &amp;&amp; (swapped ? cmp.impl(B[(size_t)y], A[(size_t)x]) : cmp.impl(A[(size_t)x], B[(size_t)y]))) {</a>
<a name="ln562">                ++x;++y;</a>
<a name="ln563">            }</a>
<a name="ln564">            </a>
<a name="ln565">            path[(size_t)k+offset] = static_cast&lt;long long&gt;(pathCordinates.size());</a>
<a name="ln566">            if (!editDistanceOnly) {</a>
<a name="ln567">                P p;</a>
<a name="ln568">                p.x = x;p.y = y;p.k = r;</a>
<a name="ln569">                pathCordinates.push_back(p);      </a>
<a name="ln570">            }</a>
<a name="ln571">            return y;</a>
<a name="ln572">        }</a>
<a name="ln573">        </a>
<a name="ln574">        /**</a>
<a name="ln575">         * record SES and LCS</a>
<a name="ln576">         */</a>
<a name="ln577">        bool recordSequence (const editPathCordinates&amp; v) {</a>
<a name="ln578">            sequence_const_iter x(A.begin());</a>
<a name="ln579">            sequence_const_iter y(B.begin());</a>
<a name="ln580">            long long           x_idx,  y_idx;  // line number for Unified Format</a>
<a name="ln581">            long long           px_idx, py_idx; // cordinates</a>
<a name="ln582">            bool                complete = false;</a>
<a name="ln583">            x_idx  = y_idx  = 1;</a>
<a name="ln584">            px_idx = py_idx = 0;</a>
<a name="ln585">            for (size_t i=v.size()-1;!complete;--i) {</a>
<a name="ln586">                while(px_idx &lt; v[i].x || py_idx &lt; v[i].y) {</a>
<a name="ln587">                    if (v[i].y - v[i].x &gt; py_idx - px_idx) {</a>
<a name="ln588">                        if (!wasSwapped()) {</a>
<a name="ln589">                            ses.addSequence(*y, 0, y_idx, SES_ADD);</a>
<a name="ln590">                        } else {</a>
<a name="ln591">                            ses.addSequence(*y, y_idx, 0, SES_DELETE);</a>
<a name="ln592">                        }</a>
<a name="ln593">                        ++y;</a>
<a name="ln594">                        ++y_idx;</a>
<a name="ln595">                        ++py_idx;</a>
<a name="ln596">                    } else if (v[i].y - v[i].x &lt; py_idx - px_idx) {</a>
<a name="ln597">                        if (!wasSwapped()) {</a>
<a name="ln598">                            ses.addSequence(*x, x_idx, 0, SES_DELETE);</a>
<a name="ln599">                        } else {</a>
<a name="ln600">                            ses.addSequence(*x, 0, x_idx, SES_ADD);</a>
<a name="ln601">                        }</a>
<a name="ln602">                        ++x;</a>
<a name="ln603">                        ++x_idx;</a>
<a name="ln604">                        ++px_idx;</a>
<a name="ln605">                    } else {</a>
<a name="ln606">                        if (!wasSwapped()) {</a>
<a name="ln607">                            lcs.addSequence(*x);</a>
<a name="ln608">                            ses.addSequence(*x, x_idx, y_idx, SES_COMMON);</a>
<a name="ln609">                        } else {</a>
<a name="ln610">                            lcs.addSequence(*y);</a>
<a name="ln611">                            ses.addSequence(*y, y_idx, x_idx, SES_COMMON);</a>
<a name="ln612">                        }</a>
<a name="ln613">                        ++x;</a>
<a name="ln614">                        ++y;</a>
<a name="ln615">                        ++x_idx;</a>
<a name="ln616">                        ++y_idx;</a>
<a name="ln617">                        ++px_idx;</a>
<a name="ln618">                        ++py_idx;</a>
<a name="ln619">                    }</a>
<a name="ln620">                }</a>
<a name="ln621">                if (i == 0) complete = true;</a>
<a name="ln622">            }</a>
<a name="ln623">            </a>
<a name="ln624">            if (x_idx &gt; static_cast&lt;long long&gt;(M) &amp;&amp; y_idx &gt; static_cast&lt;long long&gt;(N)) {</a>
<a name="ln625">                // all recording succeeded</a>
<a name="ln626">            } else {</a>
<a name="ln627">                // trivial difference</a>
<a name="ln628">                if (trivialEnabled()) {</a>
<a name="ln629">                    if (!wasSwapped()) {</a>
<a name="ln630">                        recordOddSequence(x_idx, M, x, SES_DELETE);</a>
<a name="ln631">                        recordOddSequence(y_idx, N, y, SES_ADD);</a>
<a name="ln632">                    } else {</a>
<a name="ln633">                        recordOddSequence(x_idx, M, x, SES_ADD);</a>
<a name="ln634">                        recordOddSequence(y_idx, N, y, SES_DELETE);</a>
<a name="ln635">                    }</a>
<a name="ln636">                    return true;</a>
<a name="ln637">                }</a>
<a name="ln638">                </a>
<a name="ln639">                // nontrivial difference</a>
<a name="ln640">                sequence A_(A.begin() + (size_t)x_idx - 1, A.end());</a>
<a name="ln641">                sequence B_(B.begin() + (size_t)y_idx - 1, B.end());</a>
<a name="ln642">                A        = A_;</a>
<a name="ln643">                B        = B_;</a>
<a name="ln644">                M        = distance(A.begin(), A.end());</a>
<a name="ln645">                N        = distance(B.begin(), B.end());</a>
<a name="ln646">                delta    = N - M;</a>
<a name="ln647">                offset   = M + 1;</a>
<a name="ln648">                delete[] fp;</a>
<a name="ln649">                fp = new long long[M + N + 3];</a>
<a name="ln650">                fill(&amp;fp[0], &amp;fp[M + N + 3], -1);</a>
<a name="ln651">                fill(path.begin(), path.end(), -1);</a>
<a name="ln652">                return false;</a>
<a name="ln653">            }</a>
<a name="ln654">            return true;</a>
<a name="ln655">        }</a>
<a name="ln656">        </a>
<a name="ln657">        /**</a>
<a name="ln658">         * record odd sequence in SES</a>
<a name="ln659">         */</a>
<a name="ln660">        void inline recordOddSequence (long long idx, long long length, sequence_const_iter it, const edit_t et) {</a>
<a name="ln661">            while(idx &lt; length){</a>
<a name="ln662">                ses.addSequence(*it, idx, 0, et);</a>
<a name="ln663">                ++it;</a>
<a name="ln664">                ++idx;</a>
<a name="ln665">                ++editDistance;</a>
<a name="ln666">            }</a>
<a name="ln667">            ses.addSequence(*it, idx, 0, et);</a>
<a name="ln668">            ++editDistance;</a>
<a name="ln669">        }</a>
<a name="ln670">        </a>
<a name="ln671">        /**</a>
<a name="ln672">         * join SES vectors</a>
<a name="ln673">         */</a>
<a name="ln674">        void inline joinSesVec (sesElemVec&amp; s1, sesElemVec&amp; s2) const {</a>
<a name="ln675">            if (!s2.empty()) {</a>
<a name="ln676">                for (sesElemVec_iter vit=s2.begin();vit!=s2.end();++vit) {</a>
<a name="ln677">                    s1.push_back(*vit);</a>
<a name="ln678">                }</a>
<a name="ln679">            }      </a>
<a name="ln680">        }</a>
<a name="ln681">        </a>
<a name="ln682">        /**</a>
<a name="ln683">         * check if the sequences have been swapped</a>
<a name="ln684">         */</a>
<a name="ln685">        bool inline wasSwapped () const {</a>
<a name="ln686">            return swapped;</a>
<a name="ln687">        }</a>
<a name="ln688"> </a>
<a name="ln689">    };</a>
<a name="ln690">}</a>
<a name="ln691"> </a>
<a name="ln692">#endif // DTL_DIFF_H</a>

</code></pre>
<div class="balloon" rel="397"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'isMiddle' is always true.</p></div>
<div class="balloon" rel="409"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'isMiddle' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
