
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ttinterp.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***************************************************************************/</a>
<a name="ln2">/*                                                                         */</a>
<a name="ln3">/*  ttinterp.c                                                             */</a>
<a name="ln4">/*                                                                         */</a>
<a name="ln5">/*    TrueType bytecode interpreter (body).                                */</a>
<a name="ln6">/*                                                                         */</a>
<a name="ln7">/*  Copyright 1996-2015 by                                                 */</a>
<a name="ln8">/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</a>
<a name="ln9">/*                                                                         */</a>
<a name="ln10">/*  This file is part of the FreeType project, and may only be used,       */</a>
<a name="ln11">/*  modified, and distributed under the terms of the FreeType project      */</a>
<a name="ln12">/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</a>
<a name="ln13">/*  this file you indicate that you have read the license and              */</a>
<a name="ln14">/*  understand and accept it fully.                                        */</a>
<a name="ln15">/*                                                                         */</a>
<a name="ln16">/***************************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">/* Greg Hitchcock from Microsoft has helped a lot in resolving unclear */</a>
<a name="ln20">/* issues; many thanks!                                                */</a>
<a name="ln21"> </a>
<a name="ln22"> </a>
<a name="ln23">#include &lt;ft2build.h&gt;</a>
<a name="ln24">#include FT_INTERNAL_DEBUG_H</a>
<a name="ln25">#include FT_INTERNAL_CALC_H</a>
<a name="ln26">#include FT_TRIGONOMETRY_H</a>
<a name="ln27">#include FT_SYSTEM_H</a>
<a name="ln28">#include FT_TRUETYPE_DRIVER_H</a>
<a name="ln29"> </a>
<a name="ln30">#include &quot;ttinterp.h&quot;</a>
<a name="ln31">#include &quot;tterrors.h&quot;</a>
<a name="ln32">#include &quot;ttsubpix.h&quot;</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">#ifdef TT_USE_BYTECODE_INTERPRETER</a>
<a name="ln36"> </a>
<a name="ln37"> </a>
<a name="ln38">  /*************************************************************************/</a>
<a name="ln39">  /*                                                                       */</a>
<a name="ln40">  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</a>
<a name="ln41">  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</a>
<a name="ln42">  /* messages during execution.                                            */</a>
<a name="ln43">  /*                                                                       */</a>
<a name="ln44">#undef  FT_COMPONENT</a>
<a name="ln45">#define FT_COMPONENT  trace_ttinterp</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">  /*************************************************************************/</a>
<a name="ln49">  /*                                                                       */</a>
<a name="ln50">  /* In order to detect infinite loops in the code, we set up a counter    */</a>
<a name="ln51">  /* within the run loop.  A single stroke of interpretation is now        */</a>
<a name="ln52">  /* limited to a maximum number of opcodes defined below.                 */</a>
<a name="ln53">  /*                                                                       */</a>
<a name="ln54">#define MAX_RUNNABLE_OPCODES  1000000L</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">#define SUBPIXEL_HINTING                                                     \</a>
<a name="ln58">          ( ((TT_Driver)FT_FACE_DRIVER( exc-&gt;face ))-&gt;interpreter_version == \</a>
<a name="ln59">            TT_INTERPRETER_VERSION_38 )</a>
<a name="ln60"> </a>
<a name="ln61"> </a>
<a name="ln62">#define PROJECT( v1, v2 )                                                \</a>
<a name="ln63">          exc-&gt;func_project( exc, (v1)-&gt;x - (v2)-&gt;x, (v1)-&gt;y - (v2)-&gt;y )</a>
<a name="ln64"> </a>
<a name="ln65">#define DUALPROJ( v1, v2 )                                                \</a>
<a name="ln66">          exc-&gt;func_dualproj( exc, (v1)-&gt;x - (v2)-&gt;x, (v1)-&gt;y - (v2)-&gt;y )</a>
<a name="ln67"> </a>
<a name="ln68">#define FAST_PROJECT( v )                          \</a>
<a name="ln69">          exc-&gt;func_project( exc, (v)-&gt;x, (v)-&gt;y )</a>
<a name="ln70"> </a>
<a name="ln71">#define FAST_DUALPROJ( v )                          \</a>
<a name="ln72">          exc-&gt;func_dualproj( exc, (v)-&gt;x, (v)-&gt;y )</a>
<a name="ln73"> </a>
<a name="ln74"> </a>
<a name="ln75">  /*************************************************************************/</a>
<a name="ln76">  /*                                                                       */</a>
<a name="ln77">  /* Instruction dispatch function, as used by the interpreter.            */</a>
<a name="ln78">  /*                                                                       */</a>
<a name="ln79">  typedef void  (*TInstruction_Function)( TT_ExecContext  exc,</a>
<a name="ln80">                                          FT_Long*        args );</a>
<a name="ln81"> </a>
<a name="ln82"> </a>
<a name="ln83">  /*************************************************************************/</a>
<a name="ln84">  /*                                                                       */</a>
<a name="ln85">  /* Two simple bounds-checking macros.                                    */</a>
<a name="ln86">  /*                                                                       */</a>
<a name="ln87">#define BOUNDS( x, n )   ( (FT_UInt)(x)  &gt;= (FT_UInt)(n)  )</a>
<a name="ln88">#define BOUNDSL( x, n )  ( (FT_ULong)(x) &gt;= (FT_ULong)(n) )</a>
<a name="ln89"> </a>
<a name="ln90"> </a>
<a name="ln91">#undef  SUCCESS</a>
<a name="ln92">#define SUCCESS  0</a>
<a name="ln93"> </a>
<a name="ln94">#undef  FAILURE</a>
<a name="ln95">#define FAILURE  1</a>
<a name="ln96"> </a>
<a name="ln97">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln98">#define GUESS_VECTOR( V )                                             \</a>
<a name="ln99">  do                                                                  \</a>
<a name="ln100">  {                                                                   \</a>
<a name="ln101">    if ( exc-&gt;face-&gt;unpatented_hinting )                              \</a>
<a name="ln102">    {                                                                 \</a>
<a name="ln103">      exc-&gt;GS.V.x = (FT_F2Dot14)( exc-&gt;GS.both_x_axis ? 0x4000 : 0 ); \</a>
<a name="ln104">      exc-&gt;GS.V.y = (FT_F2Dot14)( exc-&gt;GS.both_x_axis ? 0 : 0x4000 ); \</a>
<a name="ln105">    }                                                                 \</a>
<a name="ln106">  } while (0)</a>
<a name="ln107">#else</a>
<a name="ln108">#define GUESS_VECTOR( V )  do { } while (0)</a>
<a name="ln109">#endif</a>
<a name="ln110"> </a>
<a name="ln111"> </a>
<a name="ln112">  /*************************************************************************/</a>
<a name="ln113">  /*                                                                       */</a>
<a name="ln114">  /*                        CODERANGE FUNCTIONS                            */</a>
<a name="ln115">  /*                                                                       */</a>
<a name="ln116">  /*************************************************************************/</a>
<a name="ln117"> </a>
<a name="ln118"> </a>
<a name="ln119">  /*************************************************************************/</a>
<a name="ln120">  /*                                                                       */</a>
<a name="ln121">  /* &lt;Function&gt;                                                            */</a>
<a name="ln122">  /*    TT_Goto_CodeRange                                                  */</a>
<a name="ln123">  /*                                                                       */</a>
<a name="ln124">  /* &lt;Description&gt;                                                         */</a>
<a name="ln125">  /*    Switches to a new code range (updates the code related elements in */</a>
<a name="ln126">  /*    `exec', and `IP').                                                 */</a>
<a name="ln127">  /*                                                                       */</a>
<a name="ln128">  /* &lt;Input&gt;                                                               */</a>
<a name="ln129">  /*    range :: The new execution code range.                             */</a>
<a name="ln130">  /*                                                                       */</a>
<a name="ln131">  /*    IP    :: The new IP in the new code range.                         */</a>
<a name="ln132">  /*                                                                       */</a>
<a name="ln133">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln134">  /*    exec  :: The target execution context.                             */</a>
<a name="ln135">  /*                                                                       */</a>
<a name="ln136">  FT_LOCAL_DEF( void )</a>
<a name="ln137">  TT_Goto_CodeRange( TT_ExecContext  exec,</a>
<a name="ln138">                     FT_Int          range,</a>
<a name="ln139">                     FT_Long         IP )</a>
<a name="ln140">  {</a>
<a name="ln141">    TT_CodeRange*  coderange;</a>
<a name="ln142"> </a>
<a name="ln143"> </a>
<a name="ln144">    FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );</a>
<a name="ln145"> </a>
<a name="ln146">    coderange = &amp;exec-&gt;codeRangeTable[range - 1];</a>
<a name="ln147"> </a>
<a name="ln148">    FT_ASSERT( coderange-&gt;base != NULL );</a>
<a name="ln149"> </a>
<a name="ln150">    /* NOTE: Because the last instruction of a program may be a CALL */</a>
<a name="ln151">    /*       which will return to the first byte *after* the code    */</a>
<a name="ln152">    /*       range, we test for IP &lt;= Size instead of IP &lt; Size.     */</a>
<a name="ln153">    /*                                                               */</a>
<a name="ln154">    FT_ASSERT( IP &lt;= coderange-&gt;size );</a>
<a name="ln155"> </a>
<a name="ln156">    exec-&gt;code     = coderange-&gt;base;</a>
<a name="ln157">    exec-&gt;codeSize = coderange-&gt;size;</a>
<a name="ln158">    exec-&gt;IP       = IP;</a>
<a name="ln159">    exec-&gt;curRange = range;</a>
<a name="ln160">  }</a>
<a name="ln161"> </a>
<a name="ln162"> </a>
<a name="ln163">  /*************************************************************************/</a>
<a name="ln164">  /*                                                                       */</a>
<a name="ln165">  /* &lt;Function&gt;                                                            */</a>
<a name="ln166">  /*    TT_Set_CodeRange                                                   */</a>
<a name="ln167">  /*                                                                       */</a>
<a name="ln168">  /* &lt;Description&gt;                                                         */</a>
<a name="ln169">  /*    Sets a code range.                                                 */</a>
<a name="ln170">  /*                                                                       */</a>
<a name="ln171">  /* &lt;Input&gt;                                                               */</a>
<a name="ln172">  /*    range  :: The code range index.                                    */</a>
<a name="ln173">  /*                                                                       */</a>
<a name="ln174">  /*    base   :: The new code base.                                       */</a>
<a name="ln175">  /*                                                                       */</a>
<a name="ln176">  /*    length :: The range size in bytes.                                 */</a>
<a name="ln177">  /*                                                                       */</a>
<a name="ln178">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln179">  /*    exec   :: The target execution context.                            */</a>
<a name="ln180">  /*                                                                       */</a>
<a name="ln181">  FT_LOCAL_DEF( void )</a>
<a name="ln182">  TT_Set_CodeRange( TT_ExecContext  exec,</a>
<a name="ln183">                    FT_Int          range,</a>
<a name="ln184">                    void*           base,</a>
<a name="ln185">                    FT_Long         length )</a>
<a name="ln186">  {</a>
<a name="ln187">    FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );</a>
<a name="ln188"> </a>
<a name="ln189">    exec-&gt;codeRangeTable[range - 1].base = (FT_Byte*)base;</a>
<a name="ln190">    exec-&gt;codeRangeTable[range - 1].size = length;</a>
<a name="ln191">  }</a>
<a name="ln192"> </a>
<a name="ln193"> </a>
<a name="ln194">  /*************************************************************************/</a>
<a name="ln195">  /*                                                                       */</a>
<a name="ln196">  /* &lt;Function&gt;                                                            */</a>
<a name="ln197">  /*    TT_Clear_CodeRange                                                 */</a>
<a name="ln198">  /*                                                                       */</a>
<a name="ln199">  /* &lt;Description&gt;                                                         */</a>
<a name="ln200">  /*    Clears a code range.                                               */</a>
<a name="ln201">  /*                                                                       */</a>
<a name="ln202">  /* &lt;Input&gt;                                                               */</a>
<a name="ln203">  /*    range :: The code range index.                                     */</a>
<a name="ln204">  /*                                                                       */</a>
<a name="ln205">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln206">  /*    exec  :: The target execution context.                             */</a>
<a name="ln207">  /*                                                                       */</a>
<a name="ln208">  FT_LOCAL_DEF( void )</a>
<a name="ln209">  TT_Clear_CodeRange( TT_ExecContext  exec,</a>
<a name="ln210">                      FT_Int          range )</a>
<a name="ln211">  {</a>
<a name="ln212">    FT_ASSERT( range &gt;= 1 &amp;&amp; range &lt;= 3 );</a>
<a name="ln213"> </a>
<a name="ln214">    exec-&gt;codeRangeTable[range - 1].base = NULL;</a>
<a name="ln215">    exec-&gt;codeRangeTable[range - 1].size = 0;</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">  /*************************************************************************/</a>
<a name="ln220">  /*                                                                       */</a>
<a name="ln221">  /*                   EXECUTION CONTEXT ROUTINES                          */</a>
<a name="ln222">  /*                                                                       */</a>
<a name="ln223">  /*************************************************************************/</a>
<a name="ln224"> </a>
<a name="ln225"> </a>
<a name="ln226">  /*************************************************************************/</a>
<a name="ln227">  /*                                                                       */</a>
<a name="ln228">  /* &lt;Function&gt;                                                            */</a>
<a name="ln229">  /*    TT_Done_Context                                                    */</a>
<a name="ln230">  /*                                                                       */</a>
<a name="ln231">  /* &lt;Description&gt;                                                         */</a>
<a name="ln232">  /*    Destroys a given context.                                          */</a>
<a name="ln233">  /*                                                                       */</a>
<a name="ln234">  /* &lt;Input&gt;                                                               */</a>
<a name="ln235">  /*    exec   :: A handle to the target execution context.                */</a>
<a name="ln236">  /*                                                                       */</a>
<a name="ln237">  /*    memory :: A handle to the parent memory object.                    */</a>
<a name="ln238">  /*                                                                       */</a>
<a name="ln239">  /* &lt;Note&gt;                                                                */</a>
<a name="ln240">  /*    Only the glyph loader and debugger should call this function.      */</a>
<a name="ln241">  /*                                                                       */</a>
<a name="ln242">  FT_LOCAL_DEF( void )</a>
<a name="ln243">  TT_Done_Context( TT_ExecContext  exec )</a>
<a name="ln244">  {</a>
<a name="ln245">    FT_Memory  memory = exec-&gt;memory;</a>
<a name="ln246"> </a>
<a name="ln247"> </a>
<a name="ln248">    /* points zone */</a>
<a name="ln249">    exec-&gt;maxPoints   = 0;</a>
<a name="ln250">    exec-&gt;maxContours = 0;</a>
<a name="ln251"> </a>
<a name="ln252">    /* free stack */</a>
<a name="ln253">    FT_FREE( exec-&gt;stack );</a>
<a name="ln254">    exec-&gt;stackSize = 0;</a>
<a name="ln255"> </a>
<a name="ln256">    /* free call stack */</a>
<a name="ln257">    FT_FREE( exec-&gt;callStack );</a>
<a name="ln258">    exec-&gt;callSize = 0;</a>
<a name="ln259">    exec-&gt;callTop  = 0;</a>
<a name="ln260"> </a>
<a name="ln261">    /* free glyph code range */</a>
<a name="ln262">    FT_FREE( exec-&gt;glyphIns );</a>
<a name="ln263">    exec-&gt;glyphSize = 0;</a>
<a name="ln264"> </a>
<a name="ln265">    exec-&gt;size = NULL;</a>
<a name="ln266">    exec-&gt;face = NULL;</a>
<a name="ln267"> </a>
<a name="ln268">    FT_FREE( exec );</a>
<a name="ln269">  }</a>
<a name="ln270"> </a>
<a name="ln271"> </a>
<a name="ln272">  /*************************************************************************/</a>
<a name="ln273">  /*                                                                       */</a>
<a name="ln274">  /* &lt;Function&gt;                                                            */</a>
<a name="ln275">  /*    Init_Context                                                       */</a>
<a name="ln276">  /*                                                                       */</a>
<a name="ln277">  /* &lt;Description&gt;                                                         */</a>
<a name="ln278">  /*    Initializes a context object.                                      */</a>
<a name="ln279">  /*                                                                       */</a>
<a name="ln280">  /* &lt;Input&gt;                                                               */</a>
<a name="ln281">  /*    memory :: A handle to the parent memory object.                    */</a>
<a name="ln282">  /*                                                                       */</a>
<a name="ln283">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln284">  /*    exec   :: A handle to the target execution context.                */</a>
<a name="ln285">  /*                                                                       */</a>
<a name="ln286">  /* &lt;Return&gt;                                                              */</a>
<a name="ln287">  /*    FreeType error code.  0 means success.                             */</a>
<a name="ln288">  /*                                                                       */</a>
<a name="ln289">  static FT_Error</a>
<a name="ln290">  Init_Context( TT_ExecContext  exec,</a>
<a name="ln291">                FT_Memory       memory )</a>
<a name="ln292">  {</a>
<a name="ln293">    FT_Error  error;</a>
<a name="ln294"> </a>
<a name="ln295"> </a>
<a name="ln296">    FT_TRACE1(( &quot;Init_Context: new object at 0x%08p\n&quot;, exec ));</a>
<a name="ln297"> </a>
<a name="ln298">    exec-&gt;memory   = memory;</a>
<a name="ln299">    exec-&gt;callSize = 32;</a>
<a name="ln300"> </a>
<a name="ln301">    if ( FT_NEW_ARRAY( exec-&gt;callStack, exec-&gt;callSize ) )</a>
<a name="ln302">      goto Fail_Memory;</a>
<a name="ln303"> </a>
<a name="ln304">    /* all values in the context are set to 0 already, but this is */</a>
<a name="ln305">    /* here as a remainder                                         */</a>
<a name="ln306">    exec-&gt;maxPoints   = 0;</a>
<a name="ln307">    exec-&gt;maxContours = 0;</a>
<a name="ln308"> </a>
<a name="ln309">    exec-&gt;stackSize = 0;</a>
<a name="ln310">    exec-&gt;glyphSize = 0;</a>
<a name="ln311"> </a>
<a name="ln312">    exec-&gt;stack     = NULL;</a>
<a name="ln313">    exec-&gt;glyphIns  = NULL;</a>
<a name="ln314"> </a>
<a name="ln315">    exec-&gt;face = NULL;</a>
<a name="ln316">    exec-&gt;size = NULL;</a>
<a name="ln317"> </a>
<a name="ln318">    return FT_Err_Ok;</a>
<a name="ln319"> </a>
<a name="ln320">  Fail_Memory:</a>
<a name="ln321">    FT_ERROR(( &quot;Init_Context: not enough memory for %p\n&quot;, exec ));</a>
<a name="ln322">    TT_Done_Context( exec );</a>
<a name="ln323"> </a>
<a name="ln324">    return error;</a>
<a name="ln325"> }</a>
<a name="ln326"> </a>
<a name="ln327"> </a>
<a name="ln328">  /*************************************************************************/</a>
<a name="ln329">  /*                                                                       */</a>
<a name="ln330">  /* &lt;Function&gt;                                                            */</a>
<a name="ln331">  /*    Update_Max                                                         */</a>
<a name="ln332">  /*                                                                       */</a>
<a name="ln333">  /* &lt;Description&gt;                                                         */</a>
<a name="ln334">  /*    Checks the size of a buffer and reallocates it if necessary.       */</a>
<a name="ln335">  /*                                                                       */</a>
<a name="ln336">  /* &lt;Input&gt;                                                               */</a>
<a name="ln337">  /*    memory     :: A handle to the parent memory object.                */</a>
<a name="ln338">  /*                                                                       */</a>
<a name="ln339">  /*    multiplier :: The size in bytes of each element in the buffer.     */</a>
<a name="ln340">  /*                                                                       */</a>
<a name="ln341">  /*    new_max    :: The new capacity (size) of the buffer.               */</a>
<a name="ln342">  /*                                                                       */</a>
<a name="ln343">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln344">  /*    size       :: The address of the buffer's current size expressed   */</a>
<a name="ln345">  /*                  in elements.                                         */</a>
<a name="ln346">  /*                                                                       */</a>
<a name="ln347">  /*    buff       :: The address of the buffer base pointer.              */</a>
<a name="ln348">  /*                                                                       */</a>
<a name="ln349">  /* &lt;Return&gt;                                                              */</a>
<a name="ln350">  /*    FreeType error code.  0 means success.                             */</a>
<a name="ln351">  /*                                                                       */</a>
<a name="ln352">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln353">  Update_Max( FT_Memory  memory,</a>
<a name="ln354">              FT_ULong*  size,</a>
<a name="ln355">              FT_ULong   multiplier,</a>
<a name="ln356">              void*      _pbuff,</a>
<a name="ln357">              FT_ULong   new_max )</a>
<a name="ln358">  {</a>
<a name="ln359">    FT_Error  error;</a>
<a name="ln360">    void**    pbuff = (void**)_pbuff;</a>
<a name="ln361"> </a>
<a name="ln362"> </a>
<a name="ln363">    if ( *size &lt; new_max )</a>
<a name="ln364">    {</a>
<a name="ln365">      if ( FT_REALLOC( *pbuff, *size * multiplier, new_max * multiplier ) )</a>
<a name="ln366">        return error;</a>
<a name="ln367">      *size = new_max;</a>
<a name="ln368">    }</a>
<a name="ln369"> </a>
<a name="ln370">    return FT_Err_Ok;</a>
<a name="ln371">  }</a>
<a name="ln372"> </a>
<a name="ln373"> </a>
<a name="ln374">  /*************************************************************************/</a>
<a name="ln375">  /*                                                                       */</a>
<a name="ln376">  /* &lt;Function&gt;                                                            */</a>
<a name="ln377">  /*    TT_Load_Context                                                    */</a>
<a name="ln378">  /*                                                                       */</a>
<a name="ln379">  /* &lt;Description&gt;                                                         */</a>
<a name="ln380">  /*    Prepare an execution context for glyph hinting.                    */</a>
<a name="ln381">  /*                                                                       */</a>
<a name="ln382">  /* &lt;Input&gt;                                                               */</a>
<a name="ln383">  /*    face :: A handle to the source face object.                        */</a>
<a name="ln384">  /*                                                                       */</a>
<a name="ln385">  /*    size :: A handle to the source size object.                        */</a>
<a name="ln386">  /*                                                                       */</a>
<a name="ln387">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln388">  /*    exec :: A handle to the target execution context.                  */</a>
<a name="ln389">  /*                                                                       */</a>
<a name="ln390">  /* &lt;Return&gt;                                                              */</a>
<a name="ln391">  /*    FreeType error code.  0 means success.                             */</a>
<a name="ln392">  /*                                                                       */</a>
<a name="ln393">  /* &lt;Note&gt;                                                                */</a>
<a name="ln394">  /*    Only the glyph loader and debugger should call this function.      */</a>
<a name="ln395">  /*                                                                       */</a>
<a name="ln396">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln397">  TT_Load_Context( TT_ExecContext  exec,</a>
<a name="ln398">                   TT_Face         face,</a>
<a name="ln399">                   TT_Size         size )</a>
<a name="ln400">  {</a>
<a name="ln401">    FT_Int          i;</a>
<a name="ln402">    FT_ULong        tmp;</a>
<a name="ln403">    TT_MaxProfile*  maxp;</a>
<a name="ln404">    FT_Error        error;</a>
<a name="ln405"> </a>
<a name="ln406"> </a>
<a name="ln407">    exec-&gt;face = face;</a>
<a name="ln408">    maxp       = &amp;face-&gt;max_profile;</a>
<a name="ln409">    exec-&gt;size = size;</a>
<a name="ln410"> </a>
<a name="ln411">    if ( size )</a>
<a name="ln412">    {</a>
<a name="ln413">      exec-&gt;numFDefs   = size-&gt;num_function_defs;</a>
<a name="ln414">      exec-&gt;maxFDefs   = size-&gt;max_function_defs;</a>
<a name="ln415">      exec-&gt;numIDefs   = size-&gt;num_instruction_defs;</a>
<a name="ln416">      exec-&gt;maxIDefs   = size-&gt;max_instruction_defs;</a>
<a name="ln417">      exec-&gt;FDefs      = size-&gt;function_defs;</a>
<a name="ln418">      exec-&gt;IDefs      = size-&gt;instruction_defs;</a>
<a name="ln419">      exec-&gt;tt_metrics = size-&gt;ttmetrics;</a>
<a name="ln420">      exec-&gt;metrics    = size-&gt;metrics;</a>
<a name="ln421"> </a>
<a name="ln422">      exec-&gt;maxFunc    = size-&gt;max_func;</a>
<a name="ln423">      exec-&gt;maxIns     = size-&gt;max_ins;</a>
<a name="ln424"> </a>
<a name="ln425">      for ( i = 0; i &lt; TT_MAX_CODE_RANGES; i++ )</a>
<a name="ln426">        exec-&gt;codeRangeTable[i] = size-&gt;codeRangeTable[i];</a>
<a name="ln427"> </a>
<a name="ln428">      /* set graphics state */</a>
<a name="ln429">      exec-&gt;GS = size-&gt;GS;</a>
<a name="ln430"> </a>
<a name="ln431">      exec-&gt;cvtSize = size-&gt;cvt_size;</a>
<a name="ln432">      exec-&gt;cvt     = size-&gt;cvt;</a>
<a name="ln433"> </a>
<a name="ln434">      exec-&gt;storeSize = size-&gt;storage_size;</a>
<a name="ln435">      exec-&gt;storage   = size-&gt;storage;</a>
<a name="ln436"> </a>
<a name="ln437">      exec-&gt;twilight  = size-&gt;twilight;</a>
<a name="ln438"> </a>
<a name="ln439">      /* In case of multi-threading it can happen that the old size object */</a>
<a name="ln440">      /* no longer exists, thus we must clear all glyph zone references.   */</a>
<a name="ln441">      ft_memset( &amp;exec-&gt;zp0, 0, sizeof ( exec-&gt;zp0 ) );</a>
<a name="ln442">      exec-&gt;zp1 = exec-&gt;zp0;</a>
<a name="ln443">      exec-&gt;zp2 = exec-&gt;zp0;</a>
<a name="ln444">    }</a>
<a name="ln445"> </a>
<a name="ln446">    /* XXX: We reserve a little more elements on the stack to deal safely */</a>
<a name="ln447">    /*      with broken fonts like arialbs, courbs, timesbs, etc.         */</a>
<a name="ln448">    tmp = (FT_ULong)exec-&gt;stackSize;</a>
<a name="ln449">    error = Update_Max( exec-&gt;memory,</a>
<a name="ln450">                        &amp;tmp,</a>
<a name="ln451">                        sizeof ( FT_F26Dot6 ),</a>
<a name="ln452">                        (void*)&amp;exec-&gt;stack,</a>
<a name="ln453">                        maxp-&gt;maxStackElements + 32 );</a>
<a name="ln454">    exec-&gt;stackSize = (FT_Long)tmp;</a>
<a name="ln455">    if ( error )</a>
<a name="ln456">      return error;</a>
<a name="ln457"> </a>
<a name="ln458">    tmp = exec-&gt;glyphSize;</a>
<a name="ln459">    error = Update_Max( exec-&gt;memory,</a>
<a name="ln460">                        &amp;tmp,</a>
<a name="ln461">                        sizeof ( FT_Byte ),</a>
<a name="ln462">                        (void*)&amp;exec-&gt;glyphIns,</a>
<a name="ln463">                        maxp-&gt;maxSizeOfInstructions );</a>
<a name="ln464">    exec-&gt;glyphSize = (FT_UShort)tmp;</a>
<a name="ln465">    if ( error )</a>
<a name="ln466">      return error;</a>
<a name="ln467"> </a>
<a name="ln468">    exec-&gt;pts.n_points   = 0;</a>
<a name="ln469">    exec-&gt;pts.n_contours = 0;</a>
<a name="ln470"> </a>
<a name="ln471">    exec-&gt;zp1 = exec-&gt;pts;</a>
<a name="ln472">    exec-&gt;zp2 = exec-&gt;pts;</a>
<a name="ln473">    exec-&gt;zp0 = exec-&gt;pts;</a>
<a name="ln474"> </a>
<a name="ln475">    exec-&gt;instruction_trap = FALSE;</a>
<a name="ln476"> </a>
<a name="ln477">    return FT_Err_Ok;</a>
<a name="ln478">  }</a>
<a name="ln479"> </a>
<a name="ln480"> </a>
<a name="ln481">  /*************************************************************************/</a>
<a name="ln482">  /*                                                                       */</a>
<a name="ln483">  /* &lt;Function&gt;                                                            */</a>
<a name="ln484">  /*    TT_Save_Context                                                    */</a>
<a name="ln485">  /*                                                                       */</a>
<a name="ln486">  /* &lt;Description&gt;                                                         */</a>
<a name="ln487">  /*    Saves the code ranges in a `size' object.                          */</a>
<a name="ln488">  /*                                                                       */</a>
<a name="ln489">  /* &lt;Input&gt;                                                               */</a>
<a name="ln490">  /*    exec :: A handle to the source execution context.                  */</a>
<a name="ln491">  /*                                                                       */</a>
<a name="ln492">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln493">  /*    size :: A handle to the target size object.                        */</a>
<a name="ln494">  /*                                                                       */</a>
<a name="ln495">  /* &lt;Note&gt;                                                                */</a>
<a name="ln496">  /*    Only the glyph loader and debugger should call this function.      */</a>
<a name="ln497">  /*                                                                       */</a>
<a name="ln498">  FT_LOCAL_DEF( void )</a>
<a name="ln499">  TT_Save_Context( TT_ExecContext  exec,</a>
<a name="ln500">                   TT_Size         size )</a>
<a name="ln501">  {</a>
<a name="ln502">    FT_Int  i;</a>
<a name="ln503"> </a>
<a name="ln504"> </a>
<a name="ln505">    /* XXX: Will probably disappear soon with all the code range */</a>
<a name="ln506">    /*      management, which is now rather obsolete.            */</a>
<a name="ln507">    /*                                                           */</a>
<a name="ln508">    size-&gt;num_function_defs    = exec-&gt;numFDefs;</a>
<a name="ln509">    size-&gt;num_instruction_defs = exec-&gt;numIDefs;</a>
<a name="ln510"> </a>
<a name="ln511">    size-&gt;max_func = exec-&gt;maxFunc;</a>
<a name="ln512">    size-&gt;max_ins  = exec-&gt;maxIns;</a>
<a name="ln513"> </a>
<a name="ln514">    for ( i = 0; i &lt; TT_MAX_CODE_RANGES; i++ )</a>
<a name="ln515">      size-&gt;codeRangeTable[i] = exec-&gt;codeRangeTable[i];</a>
<a name="ln516">  }</a>
<a name="ln517"> </a>
<a name="ln518"> </a>
<a name="ln519">  /*************************************************************************/</a>
<a name="ln520">  /*                                                                       */</a>
<a name="ln521">  /* &lt;Function&gt;                                                            */</a>
<a name="ln522">  /*    TT_Run_Context                                                     */</a>
<a name="ln523">  /*                                                                       */</a>
<a name="ln524">  /* &lt;Description&gt;                                                         */</a>
<a name="ln525">  /*    Executes one or more instructions in the execution context.        */</a>
<a name="ln526">  /*                                                                       */</a>
<a name="ln527">  /* &lt;Input&gt;                                                               */</a>
<a name="ln528">  /*    debug :: A Boolean flag.  If set, the function sets some internal  */</a>
<a name="ln529">  /*             variables and returns immediately, otherwise TT_RunIns()  */</a>
<a name="ln530">  /*             is called.                                                */</a>
<a name="ln531">  /*                                                                       */</a>
<a name="ln532">  /*             This is commented out currently.                          */</a>
<a name="ln533">  /*                                                                       */</a>
<a name="ln534">  /* &lt;Input&gt;                                                               */</a>
<a name="ln535">  /*    exec  :: A handle to the target execution context.                 */</a>
<a name="ln536">  /*                                                                       */</a>
<a name="ln537">  /* &lt;Return&gt;                                                              */</a>
<a name="ln538">  /*    TrueType error code.  0 means success.                             */</a>
<a name="ln539">  /*                                                                       */</a>
<a name="ln540">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln541">  TT_Run_Context( TT_ExecContext  exec )</a>
<a name="ln542">  {</a>
<a name="ln543">    TT_Goto_CodeRange( exec, tt_coderange_glyph, 0 );</a>
<a name="ln544"> </a>
<a name="ln545">    exec-&gt;zp0 = exec-&gt;pts;</a>
<a name="ln546">    exec-&gt;zp1 = exec-&gt;pts;</a>
<a name="ln547">    exec-&gt;zp2 = exec-&gt;pts;</a>
<a name="ln548"> </a>
<a name="ln549">    exec-&gt;GS.gep0 = 1;</a>
<a name="ln550">    exec-&gt;GS.gep1 = 1;</a>
<a name="ln551">    exec-&gt;GS.gep2 = 1;</a>
<a name="ln552"> </a>
<a name="ln553">    exec-&gt;GS.projVector.x = 0x4000;</a>
<a name="ln554">    exec-&gt;GS.projVector.y = 0x0000;</a>
<a name="ln555"> </a>
<a name="ln556">    exec-&gt;GS.freeVector = exec-&gt;GS.projVector;</a>
<a name="ln557">    exec-&gt;GS.dualVector = exec-&gt;GS.projVector;</a>
<a name="ln558"> </a>
<a name="ln559">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln560">    exec-&gt;GS.both_x_axis = TRUE;</a>
<a name="ln561">#endif</a>
<a name="ln562"> </a>
<a name="ln563">    exec-&gt;GS.round_state = 1;</a>
<a name="ln564">    exec-&gt;GS.loop        = 1;</a>
<a name="ln565"> </a>
<a name="ln566">    /* some glyphs leave something on the stack. so we clean it */</a>
<a name="ln567">    /* before a new execution.                                  */</a>
<a name="ln568">    exec-&gt;top     = 0;</a>
<a name="ln569">    exec-&gt;callTop = 0;</a>
<a name="ln570"> </a>
<a name="ln571">    return exec-&gt;face-&gt;interpreter( exec );</a>
<a name="ln572">  }</a>
<a name="ln573"> </a>
<a name="ln574"> </a>
<a name="ln575">  /* The default value for `scan_control' is documented as FALSE in the */</a>
<a name="ln576">  /* TrueType specification.  This is confusing since it implies a      */</a>
<a name="ln577">  /* Boolean value.  However, this is not the case, thus both the       */</a>
<a name="ln578">  /* default values of our `scan_type' and `scan_control' fields (which */</a>
<a name="ln579">  /* the documentation's `scan_control' variable is split into) are     */</a>
<a name="ln580">  /* zero.                                                              */</a>
<a name="ln581"> </a>
<a name="ln582">  const TT_GraphicsState  tt_default_graphics_state =</a>
<a name="ln583">  {</a>
<a name="ln584">    0, 0, 0,</a>
<a name="ln585">    { 0x4000, 0 },</a>
<a name="ln586">    { 0x4000, 0 },</a>
<a name="ln587">    { 0x4000, 0 },</a>
<a name="ln588"> </a>
<a name="ln589">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln590">    TRUE,</a>
<a name="ln591">#endif</a>
<a name="ln592"> </a>
<a name="ln593">    1, 64, 1,</a>
<a name="ln594">    TRUE, 68, 0, 0, 9, 3,</a>
<a name="ln595">    0, FALSE, 0, 1, 1, 1</a>
<a name="ln596">  };</a>
<a name="ln597"> </a>
<a name="ln598"> </a>
<a name="ln599">  /* documentation is in ttinterp.h */</a>
<a name="ln600"> </a>
<a name="ln601">  FT_EXPORT_DEF( TT_ExecContext )</a>
<a name="ln602">  TT_New_Context( TT_Driver  driver )</a>
<a name="ln603">  {</a>
<a name="ln604">    FT_Memory  memory;</a>
<a name="ln605">    FT_Error   error;</a>
<a name="ln606"> </a>
<a name="ln607">    TT_ExecContext  exec = NULL;</a>
<a name="ln608"> </a>
<a name="ln609"> </a>
<a name="ln610">    if ( !driver )</a>
<a name="ln611">      goto Fail;</a>
<a name="ln612"> </a>
<a name="ln613">    memory = driver-&gt;root.root.memory;</a>
<a name="ln614"> </a>
<a name="ln615">    /* allocate object */</a>
<a name="ln616">    if ( FT_NEW( exec ) )</a>
<a name="ln617">      goto Fail;</a>
<a name="ln618"> </a>
<a name="ln619">    /* initialize it; in case of error this deallocates `exec' too */</a>
<a name="ln620">    error = Init_Context( exec, memory );</a>
<a name="ln621">    if ( error )</a>
<a name="ln622">      goto Fail;</a>
<a name="ln623"> </a>
<a name="ln624">    return exec;</a>
<a name="ln625"> </a>
<a name="ln626">  Fail:</a>
<a name="ln627">    return NULL;</a>
<a name="ln628">  }</a>
<a name="ln629"> </a>
<a name="ln630"> </a>
<a name="ln631">  /*************************************************************************/</a>
<a name="ln632">  /*                                                                       */</a>
<a name="ln633">  /* Before an opcode is executed, the interpreter verifies that there are */</a>
<a name="ln634">  /* enough arguments on the stack, with the help of the `Pop_Push_Count'  */</a>
<a name="ln635">  /* table.                                                                */</a>
<a name="ln636">  /*                                                                       */</a>
<a name="ln637">  /* For each opcode, the first column gives the number of arguments that  */</a>
<a name="ln638">  /* are popped from the stack; the second one gives the number of those   */</a>
<a name="ln639">  /* that are pushed in result.                                            */</a>
<a name="ln640">  /*                                                                       */</a>
<a name="ln641">  /* Opcodes which have a varying number of parameters in the data stream  */</a>
<a name="ln642">  /* (NPUSHB, NPUSHW) are handled specially; they have a negative value in */</a>
<a name="ln643">  /* the `opcode_length' table, and the value in `Pop_Push_Count' is set   */</a>
<a name="ln644">  /* to zero.                                                              */</a>
<a name="ln645">  /*                                                                       */</a>
<a name="ln646">  /*************************************************************************/</a>
<a name="ln647"> </a>
<a name="ln648"> </a>
<a name="ln649">#undef  PACK</a>
<a name="ln650">#define PACK( x, y )  ( ( x &lt;&lt; 4 ) | y )</a>
<a name="ln651"> </a>
<a name="ln652"> </a>
<a name="ln653">  static</a>
<a name="ln654">  const FT_Byte  Pop_Push_Count[256] =</a>
<a name="ln655">  {</a>
<a name="ln656">    /* opcodes are gathered in groups of 16 */</a>
<a name="ln657">    /* please keep the spaces as they are   */</a>
<a name="ln658"> </a>
<a name="ln659">    /*  SVTCA  y  */  PACK( 0, 0 ),</a>
<a name="ln660">    /*  SVTCA  x  */  PACK( 0, 0 ),</a>
<a name="ln661">    /*  SPvTCA y  */  PACK( 0, 0 ),</a>
<a name="ln662">    /*  SPvTCA x  */  PACK( 0, 0 ),</a>
<a name="ln663">    /*  SFvTCA y  */  PACK( 0, 0 ),</a>
<a name="ln664">    /*  SFvTCA x  */  PACK( 0, 0 ),</a>
<a name="ln665">    /*  SPvTL //  */  PACK( 2, 0 ),</a>
<a name="ln666">    /*  SPvTL +   */  PACK( 2, 0 ),</a>
<a name="ln667">    /*  SFvTL //  */  PACK( 2, 0 ),</a>
<a name="ln668">    /*  SFvTL +   */  PACK( 2, 0 ),</a>
<a name="ln669">    /*  SPvFS     */  PACK( 2, 0 ),</a>
<a name="ln670">    /*  SFvFS     */  PACK( 2, 0 ),</a>
<a name="ln671">    /*  GPv       */  PACK( 0, 2 ),</a>
<a name="ln672">    /*  GFv       */  PACK( 0, 2 ),</a>
<a name="ln673">    /*  SFvTPv    */  PACK( 0, 0 ),</a>
<a name="ln674">    /*  ISECT     */  PACK( 5, 0 ),</a>
<a name="ln675"> </a>
<a name="ln676">    /*  SRP0      */  PACK( 1, 0 ),</a>
<a name="ln677">    /*  SRP1      */  PACK( 1, 0 ),</a>
<a name="ln678">    /*  SRP2      */  PACK( 1, 0 ),</a>
<a name="ln679">    /*  SZP0      */  PACK( 1, 0 ),</a>
<a name="ln680">    /*  SZP1      */  PACK( 1, 0 ),</a>
<a name="ln681">    /*  SZP2      */  PACK( 1, 0 ),</a>
<a name="ln682">    /*  SZPS      */  PACK( 1, 0 ),</a>
<a name="ln683">    /*  SLOOP     */  PACK( 1, 0 ),</a>
<a name="ln684">    /*  RTG       */  PACK( 0, 0 ),</a>
<a name="ln685">    /*  RTHG      */  PACK( 0, 0 ),</a>
<a name="ln686">    /*  SMD       */  PACK( 1, 0 ),</a>
<a name="ln687">    /*  ELSE      */  PACK( 0, 0 ),</a>
<a name="ln688">    /*  JMPR      */  PACK( 1, 0 ),</a>
<a name="ln689">    /*  SCvTCi    */  PACK( 1, 0 ),</a>
<a name="ln690">    /*  SSwCi     */  PACK( 1, 0 ),</a>
<a name="ln691">    /*  SSW       */  PACK( 1, 0 ),</a>
<a name="ln692"> </a>
<a name="ln693">    /*  DUP       */  PACK( 1, 2 ),</a>
<a name="ln694">    /*  POP       */  PACK( 1, 0 ),</a>
<a name="ln695">    /*  CLEAR     */  PACK( 0, 0 ),</a>
<a name="ln696">    /*  SWAP      */  PACK( 2, 2 ),</a>
<a name="ln697">    /*  DEPTH     */  PACK( 0, 1 ),</a>
<a name="ln698">    /*  CINDEX    */  PACK( 1, 1 ),</a>
<a name="ln699">    /*  MINDEX    */  PACK( 1, 0 ),</a>
<a name="ln700">    /*  AlignPTS  */  PACK( 2, 0 ),</a>
<a name="ln701">    /*  INS_$28   */  PACK( 0, 0 ),</a>
<a name="ln702">    /*  UTP       */  PACK( 1, 0 ),</a>
<a name="ln703">    /*  LOOPCALL  */  PACK( 2, 0 ),</a>
<a name="ln704">    /*  CALL      */  PACK( 1, 0 ),</a>
<a name="ln705">    /*  FDEF      */  PACK( 1, 0 ),</a>
<a name="ln706">    /*  ENDF      */  PACK( 0, 0 ),</a>
<a name="ln707">    /*  MDAP[0]   */  PACK( 1, 0 ),</a>
<a name="ln708">    /*  MDAP[1]   */  PACK( 1, 0 ),</a>
<a name="ln709"> </a>
<a name="ln710">    /*  IUP[0]    */  PACK( 0, 0 ),</a>
<a name="ln711">    /*  IUP[1]    */  PACK( 0, 0 ),</a>
<a name="ln712">    /*  SHP[0]    */  PACK( 0, 0 ),</a>
<a name="ln713">    /*  SHP[1]    */  PACK( 0, 0 ),</a>
<a name="ln714">    /*  SHC[0]    */  PACK( 1, 0 ),</a>
<a name="ln715">    /*  SHC[1]    */  PACK( 1, 0 ),</a>
<a name="ln716">    /*  SHZ[0]    */  PACK( 1, 0 ),</a>
<a name="ln717">    /*  SHZ[1]    */  PACK( 1, 0 ),</a>
<a name="ln718">    /*  SHPIX     */  PACK( 1, 0 ),</a>
<a name="ln719">    /*  IP        */  PACK( 0, 0 ),</a>
<a name="ln720">    /*  MSIRP[0]  */  PACK( 2, 0 ),</a>
<a name="ln721">    /*  MSIRP[1]  */  PACK( 2, 0 ),</a>
<a name="ln722">    /*  AlignRP   */  PACK( 0, 0 ),</a>
<a name="ln723">    /*  RTDG      */  PACK( 0, 0 ),</a>
<a name="ln724">    /*  MIAP[0]   */  PACK( 2, 0 ),</a>
<a name="ln725">    /*  MIAP[1]   */  PACK( 2, 0 ),</a>
<a name="ln726"> </a>
<a name="ln727">    /*  NPushB    */  PACK( 0, 0 ),</a>
<a name="ln728">    /*  NPushW    */  PACK( 0, 0 ),</a>
<a name="ln729">    /*  WS        */  PACK( 2, 0 ),</a>
<a name="ln730">    /*  RS        */  PACK( 1, 1 ),</a>
<a name="ln731">    /*  WCvtP     */  PACK( 2, 0 ),</a>
<a name="ln732">    /*  RCvt      */  PACK( 1, 1 ),</a>
<a name="ln733">    /*  GC[0]     */  PACK( 1, 1 ),</a>
<a name="ln734">    /*  GC[1]     */  PACK( 1, 1 ),</a>
<a name="ln735">    /*  SCFS      */  PACK( 2, 0 ),</a>
<a name="ln736">    /*  MD[0]     */  PACK( 2, 1 ),</a>
<a name="ln737">    /*  MD[1]     */  PACK( 2, 1 ),</a>
<a name="ln738">    /*  MPPEM     */  PACK( 0, 1 ),</a>
<a name="ln739">    /*  MPS       */  PACK( 0, 1 ),</a>
<a name="ln740">    /*  FlipON    */  PACK( 0, 0 ),</a>
<a name="ln741">    /*  FlipOFF   */  PACK( 0, 0 ),</a>
<a name="ln742">    /*  DEBUG     */  PACK( 1, 0 ),</a>
<a name="ln743"> </a>
<a name="ln744">    /*  LT        */  PACK( 2, 1 ),</a>
<a name="ln745">    /*  LTEQ      */  PACK( 2, 1 ),</a>
<a name="ln746">    /*  GT        */  PACK( 2, 1 ),</a>
<a name="ln747">    /*  GTEQ      */  PACK( 2, 1 ),</a>
<a name="ln748">    /*  EQ        */  PACK( 2, 1 ),</a>
<a name="ln749">    /*  NEQ       */  PACK( 2, 1 ),</a>
<a name="ln750">    /*  ODD       */  PACK( 1, 1 ),</a>
<a name="ln751">    /*  EVEN      */  PACK( 1, 1 ),</a>
<a name="ln752">    /*  IF        */  PACK( 1, 0 ),</a>
<a name="ln753">    /*  EIF       */  PACK( 0, 0 ),</a>
<a name="ln754">    /*  AND       */  PACK( 2, 1 ),</a>
<a name="ln755">    /*  OR        */  PACK( 2, 1 ),</a>
<a name="ln756">    /*  NOT       */  PACK( 1, 1 ),</a>
<a name="ln757">    /*  DeltaP1   */  PACK( 1, 0 ),</a>
<a name="ln758">    /*  SDB       */  PACK( 1, 0 ),</a>
<a name="ln759">    /*  SDS       */  PACK( 1, 0 ),</a>
<a name="ln760"> </a>
<a name="ln761">    /*  ADD       */  PACK( 2, 1 ),</a>
<a name="ln762">    /*  SUB       */  PACK( 2, 1 ),</a>
<a name="ln763">    /*  DIV       */  PACK( 2, 1 ),</a>
<a name="ln764">    /*  MUL       */  PACK( 2, 1 ),</a>
<a name="ln765">    /*  ABS       */  PACK( 1, 1 ),</a>
<a name="ln766">    /*  NEG       */  PACK( 1, 1 ),</a>
<a name="ln767">    /*  FLOOR     */  PACK( 1, 1 ),</a>
<a name="ln768">    /*  CEILING   */  PACK( 1, 1 ),</a>
<a name="ln769">    /*  ROUND[0]  */  PACK( 1, 1 ),</a>
<a name="ln770">    /*  ROUND[1]  */  PACK( 1, 1 ),</a>
<a name="ln771">    /*  ROUND[2]  */  PACK( 1, 1 ),</a>
<a name="ln772">    /*  ROUND[3]  */  PACK( 1, 1 ),</a>
<a name="ln773">    /*  NROUND[0] */  PACK( 1, 1 ),</a>
<a name="ln774">    /*  NROUND[1] */  PACK( 1, 1 ),</a>
<a name="ln775">    /*  NROUND[2] */  PACK( 1, 1 ),</a>
<a name="ln776">    /*  NROUND[3] */  PACK( 1, 1 ),</a>
<a name="ln777"> </a>
<a name="ln778">    /*  WCvtF     */  PACK( 2, 0 ),</a>
<a name="ln779">    /*  DeltaP2   */  PACK( 1, 0 ),</a>
<a name="ln780">    /*  DeltaP3   */  PACK( 1, 0 ),</a>
<a name="ln781">    /*  DeltaCn[0] */ PACK( 1, 0 ),</a>
<a name="ln782">    /*  DeltaCn[1] */ PACK( 1, 0 ),</a>
<a name="ln783">    /*  DeltaCn[2] */ PACK( 1, 0 ),</a>
<a name="ln784">    /*  SROUND    */  PACK( 1, 0 ),</a>
<a name="ln785">    /*  S45Round  */  PACK( 1, 0 ),</a>
<a name="ln786">    /*  JROT      */  PACK( 2, 0 ),</a>
<a name="ln787">    /*  JROF      */  PACK( 2, 0 ),</a>
<a name="ln788">    /*  ROFF      */  PACK( 0, 0 ),</a>
<a name="ln789">    /*  INS_$7B   */  PACK( 0, 0 ),</a>
<a name="ln790">    /*  RUTG      */  PACK( 0, 0 ),</a>
<a name="ln791">    /*  RDTG      */  PACK( 0, 0 ),</a>
<a name="ln792">    /*  SANGW     */  PACK( 1, 0 ),</a>
<a name="ln793">    /*  AA        */  PACK( 1, 0 ),</a>
<a name="ln794"> </a>
<a name="ln795">    /*  FlipPT    */  PACK( 0, 0 ),</a>
<a name="ln796">    /*  FlipRgON  */  PACK( 2, 0 ),</a>
<a name="ln797">    /*  FlipRgOFF */  PACK( 2, 0 ),</a>
<a name="ln798">    /*  INS_$83   */  PACK( 0, 0 ),</a>
<a name="ln799">    /*  INS_$84   */  PACK( 0, 0 ),</a>
<a name="ln800">    /*  ScanCTRL  */  PACK( 1, 0 ),</a>
<a name="ln801">    /*  SDPvTL[0] */  PACK( 2, 0 ),</a>
<a name="ln802">    /*  SDPvTL[1] */  PACK( 2, 0 ),</a>
<a name="ln803">    /*  GetINFO   */  PACK( 1, 1 ),</a>
<a name="ln804">    /*  IDEF      */  PACK( 1, 0 ),</a>
<a name="ln805">    /*  ROLL      */  PACK( 3, 3 ),</a>
<a name="ln806">    /*  MAX       */  PACK( 2, 1 ),</a>
<a name="ln807">    /*  MIN       */  PACK( 2, 1 ),</a>
<a name="ln808">    /*  ScanTYPE  */  PACK( 1, 0 ),</a>
<a name="ln809">    /*  InstCTRL  */  PACK( 2, 0 ),</a>
<a name="ln810">    /*  INS_$8F   */  PACK( 0, 0 ),</a>
<a name="ln811"> </a>
<a name="ln812">    /*  INS_$90  */   PACK( 0, 0 ),</a>
<a name="ln813">    /*  INS_$91  */   PACK( 0, 0 ),</a>
<a name="ln814">    /*  INS_$92  */   PACK( 0, 0 ),</a>
<a name="ln815">    /*  INS_$93  */   PACK( 0, 0 ),</a>
<a name="ln816">    /*  INS_$94  */   PACK( 0, 0 ),</a>
<a name="ln817">    /*  INS_$95  */   PACK( 0, 0 ),</a>
<a name="ln818">    /*  INS_$96  */   PACK( 0, 0 ),</a>
<a name="ln819">    /*  INS_$97  */   PACK( 0, 0 ),</a>
<a name="ln820">    /*  INS_$98  */   PACK( 0, 0 ),</a>
<a name="ln821">    /*  INS_$99  */   PACK( 0, 0 ),</a>
<a name="ln822">    /*  INS_$9A  */   PACK( 0, 0 ),</a>
<a name="ln823">    /*  INS_$9B  */   PACK( 0, 0 ),</a>
<a name="ln824">    /*  INS_$9C  */   PACK( 0, 0 ),</a>
<a name="ln825">    /*  INS_$9D  */   PACK( 0, 0 ),</a>
<a name="ln826">    /*  INS_$9E  */   PACK( 0, 0 ),</a>
<a name="ln827">    /*  INS_$9F  */   PACK( 0, 0 ),</a>
<a name="ln828"> </a>
<a name="ln829">    /*  INS_$A0  */   PACK( 0, 0 ),</a>
<a name="ln830">    /*  INS_$A1  */   PACK( 0, 0 ),</a>
<a name="ln831">    /*  INS_$A2  */   PACK( 0, 0 ),</a>
<a name="ln832">    /*  INS_$A3  */   PACK( 0, 0 ),</a>
<a name="ln833">    /*  INS_$A4  */   PACK( 0, 0 ),</a>
<a name="ln834">    /*  INS_$A5  */   PACK( 0, 0 ),</a>
<a name="ln835">    /*  INS_$A6  */   PACK( 0, 0 ),</a>
<a name="ln836">    /*  INS_$A7  */   PACK( 0, 0 ),</a>
<a name="ln837">    /*  INS_$A8  */   PACK( 0, 0 ),</a>
<a name="ln838">    /*  INS_$A9  */   PACK( 0, 0 ),</a>
<a name="ln839">    /*  INS_$AA  */   PACK( 0, 0 ),</a>
<a name="ln840">    /*  INS_$AB  */   PACK( 0, 0 ),</a>
<a name="ln841">    /*  INS_$AC  */   PACK( 0, 0 ),</a>
<a name="ln842">    /*  INS_$AD  */   PACK( 0, 0 ),</a>
<a name="ln843">    /*  INS_$AE  */   PACK( 0, 0 ),</a>
<a name="ln844">    /*  INS_$AF  */   PACK( 0, 0 ),</a>
<a name="ln845"> </a>
<a name="ln846">    /*  PushB[0]  */  PACK( 0, 1 ),</a>
<a name="ln847">    /*  PushB[1]  */  PACK( 0, 2 ),</a>
<a name="ln848">    /*  PushB[2]  */  PACK( 0, 3 ),</a>
<a name="ln849">    /*  PushB[3]  */  PACK( 0, 4 ),</a>
<a name="ln850">    /*  PushB[4]  */  PACK( 0, 5 ),</a>
<a name="ln851">    /*  PushB[5]  */  PACK( 0, 6 ),</a>
<a name="ln852">    /*  PushB[6]  */  PACK( 0, 7 ),</a>
<a name="ln853">    /*  PushB[7]  */  PACK( 0, 8 ),</a>
<a name="ln854">    /*  PushW[0]  */  PACK( 0, 1 ),</a>
<a name="ln855">    /*  PushW[1]  */  PACK( 0, 2 ),</a>
<a name="ln856">    /*  PushW[2]  */  PACK( 0, 3 ),</a>
<a name="ln857">    /*  PushW[3]  */  PACK( 0, 4 ),</a>
<a name="ln858">    /*  PushW[4]  */  PACK( 0, 5 ),</a>
<a name="ln859">    /*  PushW[5]  */  PACK( 0, 6 ),</a>
<a name="ln860">    /*  PushW[6]  */  PACK( 0, 7 ),</a>
<a name="ln861">    /*  PushW[7]  */  PACK( 0, 8 ),</a>
<a name="ln862"> </a>
<a name="ln863">    /*  MDRP[00]  */  PACK( 1, 0 ),</a>
<a name="ln864">    /*  MDRP[01]  */  PACK( 1, 0 ),</a>
<a name="ln865">    /*  MDRP[02]  */  PACK( 1, 0 ),</a>
<a name="ln866">    /*  MDRP[03]  */  PACK( 1, 0 ),</a>
<a name="ln867">    /*  MDRP[04]  */  PACK( 1, 0 ),</a>
<a name="ln868">    /*  MDRP[05]  */  PACK( 1, 0 ),</a>
<a name="ln869">    /*  MDRP[06]  */  PACK( 1, 0 ),</a>
<a name="ln870">    /*  MDRP[07]  */  PACK( 1, 0 ),</a>
<a name="ln871">    /*  MDRP[08]  */  PACK( 1, 0 ),</a>
<a name="ln872">    /*  MDRP[09]  */  PACK( 1, 0 ),</a>
<a name="ln873">    /*  MDRP[10]  */  PACK( 1, 0 ),</a>
<a name="ln874">    /*  MDRP[11]  */  PACK( 1, 0 ),</a>
<a name="ln875">    /*  MDRP[12]  */  PACK( 1, 0 ),</a>
<a name="ln876">    /*  MDRP[13]  */  PACK( 1, 0 ),</a>
<a name="ln877">    /*  MDRP[14]  */  PACK( 1, 0 ),</a>
<a name="ln878">    /*  MDRP[15]  */  PACK( 1, 0 ),</a>
<a name="ln879"> </a>
<a name="ln880">    /*  MDRP[16]  */  PACK( 1, 0 ),</a>
<a name="ln881">    /*  MDRP[17]  */  PACK( 1, 0 ),</a>
<a name="ln882">    /*  MDRP[18]  */  PACK( 1, 0 ),</a>
<a name="ln883">    /*  MDRP[19]  */  PACK( 1, 0 ),</a>
<a name="ln884">    /*  MDRP[20]  */  PACK( 1, 0 ),</a>
<a name="ln885">    /*  MDRP[21]  */  PACK( 1, 0 ),</a>
<a name="ln886">    /*  MDRP[22]  */  PACK( 1, 0 ),</a>
<a name="ln887">    /*  MDRP[23]  */  PACK( 1, 0 ),</a>
<a name="ln888">    /*  MDRP[24]  */  PACK( 1, 0 ),</a>
<a name="ln889">    /*  MDRP[25]  */  PACK( 1, 0 ),</a>
<a name="ln890">    /*  MDRP[26]  */  PACK( 1, 0 ),</a>
<a name="ln891">    /*  MDRP[27]  */  PACK( 1, 0 ),</a>
<a name="ln892">    /*  MDRP[28]  */  PACK( 1, 0 ),</a>
<a name="ln893">    /*  MDRP[29]  */  PACK( 1, 0 ),</a>
<a name="ln894">    /*  MDRP[30]  */  PACK( 1, 0 ),</a>
<a name="ln895">    /*  MDRP[31]  */  PACK( 1, 0 ),</a>
<a name="ln896"> </a>
<a name="ln897">    /*  MIRP[00]  */  PACK( 2, 0 ),</a>
<a name="ln898">    /*  MIRP[01]  */  PACK( 2, 0 ),</a>
<a name="ln899">    /*  MIRP[02]  */  PACK( 2, 0 ),</a>
<a name="ln900">    /*  MIRP[03]  */  PACK( 2, 0 ),</a>
<a name="ln901">    /*  MIRP[04]  */  PACK( 2, 0 ),</a>
<a name="ln902">    /*  MIRP[05]  */  PACK( 2, 0 ),</a>
<a name="ln903">    /*  MIRP[06]  */  PACK( 2, 0 ),</a>
<a name="ln904">    /*  MIRP[07]  */  PACK( 2, 0 ),</a>
<a name="ln905">    /*  MIRP[08]  */  PACK( 2, 0 ),</a>
<a name="ln906">    /*  MIRP[09]  */  PACK( 2, 0 ),</a>
<a name="ln907">    /*  MIRP[10]  */  PACK( 2, 0 ),</a>
<a name="ln908">    /*  MIRP[11]  */  PACK( 2, 0 ),</a>
<a name="ln909">    /*  MIRP[12]  */  PACK( 2, 0 ),</a>
<a name="ln910">    /*  MIRP[13]  */  PACK( 2, 0 ),</a>
<a name="ln911">    /*  MIRP[14]  */  PACK( 2, 0 ),</a>
<a name="ln912">    /*  MIRP[15]  */  PACK( 2, 0 ),</a>
<a name="ln913"> </a>
<a name="ln914">    /*  MIRP[16]  */  PACK( 2, 0 ),</a>
<a name="ln915">    /*  MIRP[17]  */  PACK( 2, 0 ),</a>
<a name="ln916">    /*  MIRP[18]  */  PACK( 2, 0 ),</a>
<a name="ln917">    /*  MIRP[19]  */  PACK( 2, 0 ),</a>
<a name="ln918">    /*  MIRP[20]  */  PACK( 2, 0 ),</a>
<a name="ln919">    /*  MIRP[21]  */  PACK( 2, 0 ),</a>
<a name="ln920">    /*  MIRP[22]  */  PACK( 2, 0 ),</a>
<a name="ln921">    /*  MIRP[23]  */  PACK( 2, 0 ),</a>
<a name="ln922">    /*  MIRP[24]  */  PACK( 2, 0 ),</a>
<a name="ln923">    /*  MIRP[25]  */  PACK( 2, 0 ),</a>
<a name="ln924">    /*  MIRP[26]  */  PACK( 2, 0 ),</a>
<a name="ln925">    /*  MIRP[27]  */  PACK( 2, 0 ),</a>
<a name="ln926">    /*  MIRP[28]  */  PACK( 2, 0 ),</a>
<a name="ln927">    /*  MIRP[29]  */  PACK( 2, 0 ),</a>
<a name="ln928">    /*  MIRP[30]  */  PACK( 2, 0 ),</a>
<a name="ln929">    /*  MIRP[31]  */  PACK( 2, 0 )</a>
<a name="ln930">  };</a>
<a name="ln931"> </a>
<a name="ln932"> </a>
<a name="ln933">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln934"> </a>
<a name="ln935">  /* the first hex digit gives the length of the opcode name; the space */</a>
<a name="ln936">  /* after the digit is here just to increase readability of the source */</a>
<a name="ln937">  /* code                                                               */</a>
<a name="ln938"> </a>
<a name="ln939">  static</a>
<a name="ln940">  const char*  const opcode_name[256] =</a>
<a name="ln941">  {</a>
<a name="ln942">    &quot;7 SVTCA y&quot;,</a>
<a name="ln943">    &quot;7 SVTCA x&quot;,</a>
<a name="ln944">    &quot;8 SPvTCA y&quot;,</a>
<a name="ln945">    &quot;8 SPvTCA x&quot;,</a>
<a name="ln946">    &quot;8 SFvTCA y&quot;,</a>
<a name="ln947">    &quot;8 SFvTCA x&quot;,</a>
<a name="ln948">    &quot;8 SPvTL ||&quot;,</a>
<a name="ln949">    &quot;7 SPvTL +&quot;,</a>
<a name="ln950">    &quot;8 SFvTL ||&quot;,</a>
<a name="ln951">    &quot;7 SFvTL +&quot;,</a>
<a name="ln952">    &quot;5 SPvFS&quot;,</a>
<a name="ln953">    &quot;5 SFvFS&quot;,</a>
<a name="ln954">    &quot;3 GPv&quot;,</a>
<a name="ln955">    &quot;3 GFv&quot;,</a>
<a name="ln956">    &quot;6 SFvTPv&quot;,</a>
<a name="ln957">    &quot;5 ISECT&quot;,</a>
<a name="ln958"> </a>
<a name="ln959">    &quot;4 SRP0&quot;,</a>
<a name="ln960">    &quot;4 SRP1&quot;,</a>
<a name="ln961">    &quot;4 SRP2&quot;,</a>
<a name="ln962">    &quot;4 SZP0&quot;,</a>
<a name="ln963">    &quot;4 SZP1&quot;,</a>
<a name="ln964">    &quot;4 SZP2&quot;,</a>
<a name="ln965">    &quot;4 SZPS&quot;,</a>
<a name="ln966">    &quot;5 SLOOP&quot;,</a>
<a name="ln967">    &quot;3 RTG&quot;,</a>
<a name="ln968">    &quot;4 RTHG&quot;,</a>
<a name="ln969">    &quot;3 SMD&quot;,</a>
<a name="ln970">    &quot;4 ELSE&quot;,</a>
<a name="ln971">    &quot;4 JMPR&quot;,</a>
<a name="ln972">    &quot;6 SCvTCi&quot;,</a>
<a name="ln973">    &quot;5 SSwCi&quot;,</a>
<a name="ln974">    &quot;3 SSW&quot;,</a>
<a name="ln975"> </a>
<a name="ln976">    &quot;3 DUP&quot;,</a>
<a name="ln977">    &quot;3 POP&quot;,</a>
<a name="ln978">    &quot;5 CLEAR&quot;,</a>
<a name="ln979">    &quot;4 SWAP&quot;,</a>
<a name="ln980">    &quot;5 DEPTH&quot;,</a>
<a name="ln981">    &quot;6 CINDEX&quot;,</a>
<a name="ln982">    &quot;6 MINDEX&quot;,</a>
<a name="ln983">    &quot;8 AlignPTS&quot;,</a>
<a name="ln984">    &quot;7 INS_$28&quot;,</a>
<a name="ln985">    &quot;3 UTP&quot;,</a>
<a name="ln986">    &quot;8 LOOPCALL&quot;,</a>
<a name="ln987">    &quot;4 CALL&quot;,</a>
<a name="ln988">    &quot;4 FDEF&quot;,</a>
<a name="ln989">    &quot;4 ENDF&quot;,</a>
<a name="ln990">    &quot;7 MDAP[0]&quot;,</a>
<a name="ln991">    &quot;7 MDAP[1]&quot;,</a>
<a name="ln992"> </a>
<a name="ln993">    &quot;6 IUP[0]&quot;,</a>
<a name="ln994">    &quot;6 IUP[1]&quot;,</a>
<a name="ln995">    &quot;6 SHP[0]&quot;,</a>
<a name="ln996">    &quot;6 SHP[1]&quot;,</a>
<a name="ln997">    &quot;6 SHC[0]&quot;,</a>
<a name="ln998">    &quot;6 SHC[1]&quot;,</a>
<a name="ln999">    &quot;6 SHZ[0]&quot;,</a>
<a name="ln1000">    &quot;6 SHZ[1]&quot;,</a>
<a name="ln1001">    &quot;5 SHPIX&quot;,</a>
<a name="ln1002">    &quot;2 IP&quot;,</a>
<a name="ln1003">    &quot;8 MSIRP[0]&quot;,</a>
<a name="ln1004">    &quot;8 MSIRP[1]&quot;,</a>
<a name="ln1005">    &quot;7 AlignRP&quot;,</a>
<a name="ln1006">    &quot;4 RTDG&quot;,</a>
<a name="ln1007">    &quot;7 MIAP[0]&quot;,</a>
<a name="ln1008">    &quot;7 MIAP[1]&quot;,</a>
<a name="ln1009"> </a>
<a name="ln1010">    &quot;6 NPushB&quot;,</a>
<a name="ln1011">    &quot;6 NPushW&quot;,</a>
<a name="ln1012">    &quot;2 WS&quot;,</a>
<a name="ln1013">    &quot;2 RS&quot;,</a>
<a name="ln1014">    &quot;5 WCvtP&quot;,</a>
<a name="ln1015">    &quot;4 RCvt&quot;,</a>
<a name="ln1016">    &quot;5 GC[0]&quot;,</a>
<a name="ln1017">    &quot;5 GC[1]&quot;,</a>
<a name="ln1018">    &quot;4 SCFS&quot;,</a>
<a name="ln1019">    &quot;5 MD[0]&quot;,</a>
<a name="ln1020">    &quot;5 MD[1]&quot;,</a>
<a name="ln1021">    &quot;5 MPPEM&quot;,</a>
<a name="ln1022">    &quot;3 MPS&quot;,</a>
<a name="ln1023">    &quot;6 FlipON&quot;,</a>
<a name="ln1024">    &quot;7 FlipOFF&quot;,</a>
<a name="ln1025">    &quot;5 DEBUG&quot;,</a>
<a name="ln1026"> </a>
<a name="ln1027">    &quot;2 LT&quot;,</a>
<a name="ln1028">    &quot;4 LTEQ&quot;,</a>
<a name="ln1029">    &quot;2 GT&quot;,</a>
<a name="ln1030">    &quot;4 GTEQ&quot;,</a>
<a name="ln1031">    &quot;2 EQ&quot;,</a>
<a name="ln1032">    &quot;3 NEQ&quot;,</a>
<a name="ln1033">    &quot;3 ODD&quot;,</a>
<a name="ln1034">    &quot;4 EVEN&quot;,</a>
<a name="ln1035">    &quot;2 IF&quot;,</a>
<a name="ln1036">    &quot;3 EIF&quot;,</a>
<a name="ln1037">    &quot;3 AND&quot;,</a>
<a name="ln1038">    &quot;2 OR&quot;,</a>
<a name="ln1039">    &quot;3 NOT&quot;,</a>
<a name="ln1040">    &quot;7 DeltaP1&quot;,</a>
<a name="ln1041">    &quot;3 SDB&quot;,</a>
<a name="ln1042">    &quot;3 SDS&quot;,</a>
<a name="ln1043"> </a>
<a name="ln1044">    &quot;3 ADD&quot;,</a>
<a name="ln1045">    &quot;3 SUB&quot;,</a>
<a name="ln1046">    &quot;3 DIV&quot;,</a>
<a name="ln1047">    &quot;3 MUL&quot;,</a>
<a name="ln1048">    &quot;3 ABS&quot;,</a>
<a name="ln1049">    &quot;3 NEG&quot;,</a>
<a name="ln1050">    &quot;5 FLOOR&quot;,</a>
<a name="ln1051">    &quot;7 CEILING&quot;,</a>
<a name="ln1052">    &quot;8 ROUND[0]&quot;,</a>
<a name="ln1053">    &quot;8 ROUND[1]&quot;,</a>
<a name="ln1054">    &quot;8 ROUND[2]&quot;,</a>
<a name="ln1055">    &quot;8 ROUND[3]&quot;,</a>
<a name="ln1056">    &quot;9 NROUND[0]&quot;,</a>
<a name="ln1057">    &quot;9 NROUND[1]&quot;,</a>
<a name="ln1058">    &quot;9 NROUND[2]&quot;,</a>
<a name="ln1059">    &quot;9 NROUND[3]&quot;,</a>
<a name="ln1060"> </a>
<a name="ln1061">    &quot;5 WCvtF&quot;,</a>
<a name="ln1062">    &quot;7 DeltaP2&quot;,</a>
<a name="ln1063">    &quot;7 DeltaP3&quot;,</a>
<a name="ln1064">    &quot;A DeltaCn[0]&quot;,</a>
<a name="ln1065">    &quot;A DeltaCn[1]&quot;,</a>
<a name="ln1066">    &quot;A DeltaCn[2]&quot;,</a>
<a name="ln1067">    &quot;6 SROUND&quot;,</a>
<a name="ln1068">    &quot;8 S45Round&quot;,</a>
<a name="ln1069">    &quot;4 JROT&quot;,</a>
<a name="ln1070">    &quot;4 JROF&quot;,</a>
<a name="ln1071">    &quot;4 ROFF&quot;,</a>
<a name="ln1072">    &quot;7 INS_$7B&quot;,</a>
<a name="ln1073">    &quot;4 RUTG&quot;,</a>
<a name="ln1074">    &quot;4 RDTG&quot;,</a>
<a name="ln1075">    &quot;5 SANGW&quot;,</a>
<a name="ln1076">    &quot;2 AA&quot;,</a>
<a name="ln1077"> </a>
<a name="ln1078">    &quot;6 FlipPT&quot;,</a>
<a name="ln1079">    &quot;8 FlipRgON&quot;,</a>
<a name="ln1080">    &quot;9 FlipRgOFF&quot;,</a>
<a name="ln1081">    &quot;7 INS_$83&quot;,</a>
<a name="ln1082">    &quot;7 INS_$84&quot;,</a>
<a name="ln1083">    &quot;8 ScanCTRL&quot;,</a>
<a name="ln1084">    &quot;9 SDPvTL[0]&quot;,</a>
<a name="ln1085">    &quot;9 SDPvTL[1]&quot;,</a>
<a name="ln1086">    &quot;7 GetINFO&quot;,</a>
<a name="ln1087">    &quot;4 IDEF&quot;,</a>
<a name="ln1088">    &quot;4 ROLL&quot;,</a>
<a name="ln1089">    &quot;3 MAX&quot;,</a>
<a name="ln1090">    &quot;3 MIN&quot;,</a>
<a name="ln1091">    &quot;8 ScanTYPE&quot;,</a>
<a name="ln1092">    &quot;8 InstCTRL&quot;,</a>
<a name="ln1093">    &quot;7 INS_$8F&quot;,</a>
<a name="ln1094"> </a>
<a name="ln1095">    &quot;7 INS_$90&quot;,</a>
<a name="ln1096">    &quot;7 INS_$91&quot;,</a>
<a name="ln1097">    &quot;7 INS_$92&quot;,</a>
<a name="ln1098">    &quot;7 INS_$93&quot;,</a>
<a name="ln1099">    &quot;7 INS_$94&quot;,</a>
<a name="ln1100">    &quot;7 INS_$95&quot;,</a>
<a name="ln1101">    &quot;7 INS_$96&quot;,</a>
<a name="ln1102">    &quot;7 INS_$97&quot;,</a>
<a name="ln1103">    &quot;7 INS_$98&quot;,</a>
<a name="ln1104">    &quot;7 INS_$99&quot;,</a>
<a name="ln1105">    &quot;7 INS_$9A&quot;,</a>
<a name="ln1106">    &quot;7 INS_$9B&quot;,</a>
<a name="ln1107">    &quot;7 INS_$9C&quot;,</a>
<a name="ln1108">    &quot;7 INS_$9D&quot;,</a>
<a name="ln1109">    &quot;7 INS_$9E&quot;,</a>
<a name="ln1110">    &quot;7 INS_$9F&quot;,</a>
<a name="ln1111"> </a>
<a name="ln1112">    &quot;7 INS_$A0&quot;,</a>
<a name="ln1113">    &quot;7 INS_$A1&quot;,</a>
<a name="ln1114">    &quot;7 INS_$A2&quot;,</a>
<a name="ln1115">    &quot;7 INS_$A3&quot;,</a>
<a name="ln1116">    &quot;7 INS_$A4&quot;,</a>
<a name="ln1117">    &quot;7 INS_$A5&quot;,</a>
<a name="ln1118">    &quot;7 INS_$A6&quot;,</a>
<a name="ln1119">    &quot;7 INS_$A7&quot;,</a>
<a name="ln1120">    &quot;7 INS_$A8&quot;,</a>
<a name="ln1121">    &quot;7 INS_$A9&quot;,</a>
<a name="ln1122">    &quot;7 INS_$AA&quot;,</a>
<a name="ln1123">    &quot;7 INS_$AB&quot;,</a>
<a name="ln1124">    &quot;7 INS_$AC&quot;,</a>
<a name="ln1125">    &quot;7 INS_$AD&quot;,</a>
<a name="ln1126">    &quot;7 INS_$AE&quot;,</a>
<a name="ln1127">    &quot;7 INS_$AF&quot;,</a>
<a name="ln1128"> </a>
<a name="ln1129">    &quot;8 PushB[0]&quot;,</a>
<a name="ln1130">    &quot;8 PushB[1]&quot;,</a>
<a name="ln1131">    &quot;8 PushB[2]&quot;,</a>
<a name="ln1132">    &quot;8 PushB[3]&quot;,</a>
<a name="ln1133">    &quot;8 PushB[4]&quot;,</a>
<a name="ln1134">    &quot;8 PushB[5]&quot;,</a>
<a name="ln1135">    &quot;8 PushB[6]&quot;,</a>
<a name="ln1136">    &quot;8 PushB[7]&quot;,</a>
<a name="ln1137">    &quot;8 PushW[0]&quot;,</a>
<a name="ln1138">    &quot;8 PushW[1]&quot;,</a>
<a name="ln1139">    &quot;8 PushW[2]&quot;,</a>
<a name="ln1140">    &quot;8 PushW[3]&quot;,</a>
<a name="ln1141">    &quot;8 PushW[4]&quot;,</a>
<a name="ln1142">    &quot;8 PushW[5]&quot;,</a>
<a name="ln1143">    &quot;8 PushW[6]&quot;,</a>
<a name="ln1144">    &quot;8 PushW[7]&quot;,</a>
<a name="ln1145"> </a>
<a name="ln1146">    &quot;8 MDRP[00]&quot;,</a>
<a name="ln1147">    &quot;8 MDRP[01]&quot;,</a>
<a name="ln1148">    &quot;8 MDRP[02]&quot;,</a>
<a name="ln1149">    &quot;8 MDRP[03]&quot;,</a>
<a name="ln1150">    &quot;8 MDRP[04]&quot;,</a>
<a name="ln1151">    &quot;8 MDRP[05]&quot;,</a>
<a name="ln1152">    &quot;8 MDRP[06]&quot;,</a>
<a name="ln1153">    &quot;8 MDRP[07]&quot;,</a>
<a name="ln1154">    &quot;8 MDRP[08]&quot;,</a>
<a name="ln1155">    &quot;8 MDRP[09]&quot;,</a>
<a name="ln1156">    &quot;8 MDRP[10]&quot;,</a>
<a name="ln1157">    &quot;8 MDRP[11]&quot;,</a>
<a name="ln1158">    &quot;8 MDRP[12]&quot;,</a>
<a name="ln1159">    &quot;8 MDRP[13]&quot;,</a>
<a name="ln1160">    &quot;8 MDRP[14]&quot;,</a>
<a name="ln1161">    &quot;8 MDRP[15]&quot;,</a>
<a name="ln1162"> </a>
<a name="ln1163">    &quot;8 MDRP[16]&quot;,</a>
<a name="ln1164">    &quot;8 MDRP[17]&quot;,</a>
<a name="ln1165">    &quot;8 MDRP[18]&quot;,</a>
<a name="ln1166">    &quot;8 MDRP[19]&quot;,</a>
<a name="ln1167">    &quot;8 MDRP[20]&quot;,</a>
<a name="ln1168">    &quot;8 MDRP[21]&quot;,</a>
<a name="ln1169">    &quot;8 MDRP[22]&quot;,</a>
<a name="ln1170">    &quot;8 MDRP[23]&quot;,</a>
<a name="ln1171">    &quot;8 MDRP[24]&quot;,</a>
<a name="ln1172">    &quot;8 MDRP[25]&quot;,</a>
<a name="ln1173">    &quot;8 MDRP[26]&quot;,</a>
<a name="ln1174">    &quot;8 MDRP[27]&quot;,</a>
<a name="ln1175">    &quot;8 MDRP[28]&quot;,</a>
<a name="ln1176">    &quot;8 MDRP[29]&quot;,</a>
<a name="ln1177">    &quot;8 MDRP[30]&quot;,</a>
<a name="ln1178">    &quot;8 MDRP[31]&quot;,</a>
<a name="ln1179"> </a>
<a name="ln1180">    &quot;8 MIRP[00]&quot;,</a>
<a name="ln1181">    &quot;8 MIRP[01]&quot;,</a>
<a name="ln1182">    &quot;8 MIRP[02]&quot;,</a>
<a name="ln1183">    &quot;8 MIRP[03]&quot;,</a>
<a name="ln1184">    &quot;8 MIRP[04]&quot;,</a>
<a name="ln1185">    &quot;8 MIRP[05]&quot;,</a>
<a name="ln1186">    &quot;8 MIRP[06]&quot;,</a>
<a name="ln1187">    &quot;8 MIRP[07]&quot;,</a>
<a name="ln1188">    &quot;8 MIRP[08]&quot;,</a>
<a name="ln1189">    &quot;8 MIRP[09]&quot;,</a>
<a name="ln1190">    &quot;8 MIRP[10]&quot;,</a>
<a name="ln1191">    &quot;8 MIRP[11]&quot;,</a>
<a name="ln1192">    &quot;8 MIRP[12]&quot;,</a>
<a name="ln1193">    &quot;8 MIRP[13]&quot;,</a>
<a name="ln1194">    &quot;8 MIRP[14]&quot;,</a>
<a name="ln1195">    &quot;8 MIRP[15]&quot;,</a>
<a name="ln1196"> </a>
<a name="ln1197">    &quot;8 MIRP[16]&quot;,</a>
<a name="ln1198">    &quot;8 MIRP[17]&quot;,</a>
<a name="ln1199">    &quot;8 MIRP[18]&quot;,</a>
<a name="ln1200">    &quot;8 MIRP[19]&quot;,</a>
<a name="ln1201">    &quot;8 MIRP[20]&quot;,</a>
<a name="ln1202">    &quot;8 MIRP[21]&quot;,</a>
<a name="ln1203">    &quot;8 MIRP[22]&quot;,</a>
<a name="ln1204">    &quot;8 MIRP[23]&quot;,</a>
<a name="ln1205">    &quot;8 MIRP[24]&quot;,</a>
<a name="ln1206">    &quot;8 MIRP[25]&quot;,</a>
<a name="ln1207">    &quot;8 MIRP[26]&quot;,</a>
<a name="ln1208">    &quot;8 MIRP[27]&quot;,</a>
<a name="ln1209">    &quot;8 MIRP[28]&quot;,</a>
<a name="ln1210">    &quot;8 MIRP[29]&quot;,</a>
<a name="ln1211">    &quot;8 MIRP[30]&quot;,</a>
<a name="ln1212">    &quot;8 MIRP[31]&quot;</a>
<a name="ln1213">  };</a>
<a name="ln1214"> </a>
<a name="ln1215">#endif /* FT_DEBUG_LEVEL_TRACE */</a>
<a name="ln1216"> </a>
<a name="ln1217"> </a>
<a name="ln1218">  static</a>
<a name="ln1219">  const FT_Char  opcode_length[256] =</a>
<a name="ln1220">  {</a>
<a name="ln1221">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1222">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1223">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1224">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1225"> </a>
<a name="ln1226">   -1,-2, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1227">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1228">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1229">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1230"> </a>
<a name="ln1231">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1232">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1233">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1234">    2, 3, 4, 5,  6, 7, 8, 9,  3, 5, 7, 9, 11,13,15,17,</a>
<a name="ln1235"> </a>
<a name="ln1236">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1237">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1238">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,</a>
<a name="ln1239">    1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1,  1, 1, 1, 1</a>
<a name="ln1240">  };</a>
<a name="ln1241"> </a>
<a name="ln1242">#undef PACK</a>
<a name="ln1243"> </a>
<a name="ln1244"> </a>
<a name="ln1245">#ifndef FT_CONFIG_OPTION_NO_ASSEMBLER</a>
<a name="ln1246"> </a>
<a name="ln1247">#if defined( __arm__ )                                 &amp;&amp; \</a>
<a name="ln1248">    ( defined( __thumb2__ ) || !defined( __thumb__ ) )</a>
<a name="ln1249"> </a>
<a name="ln1250">#define TT_MulFix14  TT_MulFix14_arm</a>
<a name="ln1251"> </a>
<a name="ln1252">  static FT_Int32</a>
<a name="ln1253">  TT_MulFix14_arm( FT_Int32  a,</a>
<a name="ln1254">                   FT_Int    b )</a>
<a name="ln1255">  {</a>
<a name="ln1256">    FT_Int32  t, t2;</a>
<a name="ln1257"> </a>
<a name="ln1258"> </a>
<a name="ln1259">#if defined( __CC_ARM ) || defined( __ARMCC__ )</a>
<a name="ln1260"> </a>
<a name="ln1261">    __asm</a>
<a name="ln1262">    {</a>
<a name="ln1263">      smull t2, t,  b,  a           /* (lo=t2,hi=t) = a*b */</a>
<a name="ln1264">      mov   a,  t,  asr #31         /* a   = (hi &gt;&gt; 31) */</a>
<a name="ln1265">      add   a,  a,  #0x2000         /* a  += 0x2000 */</a>
<a name="ln1266">      adds  t2, t2, a               /* t2 += a */</a>
<a name="ln1267">      adc   t,  t,  #0              /* t  += carry */</a>
<a name="ln1268">      mov   a,  t2, lsr #14         /* a   = t2 &gt;&gt; 14 */</a>
<a name="ln1269">      orr   a,  a,  t,  lsl #18     /* a  |= t &lt;&lt; 18 */</a>
<a name="ln1270">    }</a>
<a name="ln1271"> </a>
<a name="ln1272">#elif defined( __GNUC__ )</a>
<a name="ln1273"> </a>
<a name="ln1274">    __asm__ __volatile__ (</a>
<a name="ln1275">      &quot;smull  %1, %2, %4, %3\n\t&quot;       /* (lo=%1,hi=%2) = a*b */</a>
<a name="ln1276">      &quot;mov    %0, %2, asr #31\n\t&quot;      /* %0  = (hi &gt;&gt; 31) */</a>
<a name="ln1277">#if defined( __clang__ ) &amp;&amp; defined( __thumb2__ )</a>
<a name="ln1278">      &quot;add.w  %0, %0, #0x2000\n\t&quot;      /* %0 += 0x2000 */</a>
<a name="ln1279">#else</a>
<a name="ln1280">      &quot;add    %0, %0, #0x2000\n\t&quot;      /* %0 += 0x2000 */</a>
<a name="ln1281">#endif</a>
<a name="ln1282">      &quot;adds   %1, %1, %0\n\t&quot;           /* %1 += %0 */</a>
<a name="ln1283">      &quot;adc    %2, %2, #0\n\t&quot;           /* %2 += carry */</a>
<a name="ln1284">      &quot;mov    %0, %1, lsr #14\n\t&quot;      /* %0  = %1 &gt;&gt; 16 */</a>
<a name="ln1285">      &quot;orr    %0, %0, %2, lsl #18\n\t&quot;  /* %0 |= %2 &lt;&lt; 16 */</a>
<a name="ln1286">      : &quot;=r&quot;(a), &quot;=&amp;r&quot;(t2), &quot;=&amp;r&quot;(t)</a>
<a name="ln1287">      : &quot;r&quot;(a), &quot;r&quot;(b)</a>
<a name="ln1288">      : &quot;cc&quot; );</a>
<a name="ln1289"> </a>
<a name="ln1290">#endif</a>
<a name="ln1291"> </a>
<a name="ln1292">    return a;</a>
<a name="ln1293">  }</a>
<a name="ln1294"> </a>
<a name="ln1295">#endif /* __arm__ &amp;&amp; ( __thumb2__ || !__thumb__ ) */</a>
<a name="ln1296"> </a>
<a name="ln1297">#endif /* !FT_CONFIG_OPTION_NO_ASSEMBLER */</a>
<a name="ln1298"> </a>
<a name="ln1299"> </a>
<a name="ln1300">#if defined( __GNUC__ )                              &amp;&amp; \</a>
<a name="ln1301">    ( defined( __i386__ ) || defined( __x86_64__ ) )</a>
<a name="ln1302"> </a>
<a name="ln1303">#define TT_MulFix14  TT_MulFix14_long_long</a>
<a name="ln1304"> </a>
<a name="ln1305">  /* Temporarily disable the warning that C90 doesn't support `long long'. */</a>
<a name="ln1306">#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) &gt;= 406</a>
<a name="ln1307">#pragma GCC diagnostic push</a>
<a name="ln1308">#endif</a>
<a name="ln1309">#pragma GCC diagnostic ignored &quot;-Wlong-long&quot;</a>
<a name="ln1310"> </a>
<a name="ln1311">  /* This is declared `noinline' because inlining the function results */</a>
<a name="ln1312">  /* in slower code.  The `pure' attribute indicates that the result   */</a>
<a name="ln1313">  /* only depends on the parameters.                                   */</a>
<a name="ln1314">  static __attribute__(( noinline ))</a>
<a name="ln1315">         __attribute__(( pure )) FT_Int32</a>
<a name="ln1316">  TT_MulFix14_long_long( FT_Int32  a,</a>
<a name="ln1317">                         FT_Int    b )</a>
<a name="ln1318">  {</a>
<a name="ln1319"> </a>
<a name="ln1320">    long long  ret = (long long)a * b;</a>
<a name="ln1321"> </a>
<a name="ln1322">    /* The following line assumes that right shifting of signed values */</a>
<a name="ln1323">    /* will actually preserve the sign bit.  The exact behaviour is    */</a>
<a name="ln1324">    /* undefined, but this is true on x86 and x86_64.                  */</a>
<a name="ln1325">    long long  tmp = ret &gt;&gt; 63;</a>
<a name="ln1326"> </a>
<a name="ln1327"> </a>
<a name="ln1328">    ret += 0x2000 + tmp;</a>
<a name="ln1329"> </a>
<a name="ln1330">    return (FT_Int32)( ret &gt;&gt; 14 );</a>
<a name="ln1331">  }</a>
<a name="ln1332"> </a>
<a name="ln1333">#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) &gt;= 406</a>
<a name="ln1334">#pragma GCC diagnostic pop</a>
<a name="ln1335">#endif</a>
<a name="ln1336"> </a>
<a name="ln1337">#endif /* __GNUC__ &amp;&amp; ( __i386__ || __x86_64__ ) */</a>
<a name="ln1338"> </a>
<a name="ln1339"> </a>
<a name="ln1340">#ifndef TT_MulFix14</a>
<a name="ln1341"> </a>
<a name="ln1342">  /* Compute (a*b)/2^14 with maximum accuracy and rounding.  */</a>
<a name="ln1343">  /* This is optimized to be faster than calling FT_MulFix() */</a>
<a name="ln1344">  /* for platforms where sizeof(int) == 2.                   */</a>
<a name="ln1345">  static FT_Int32</a>
<a name="ln1346">  TT_MulFix14( FT_Int32  a,</a>
<a name="ln1347">               FT_Int    b )</a>
<a name="ln1348">  {</a>
<a name="ln1349">    FT_Int32   sign;</a>
<a name="ln1350">    FT_UInt32  ah, al, mid, lo, hi;</a>
<a name="ln1351"> </a>
<a name="ln1352"> </a>
<a name="ln1353">    sign = a ^ b;</a>
<a name="ln1354"> </a>
<a name="ln1355">    if ( a &lt; 0 )</a>
<a name="ln1356">      a = -a;</a>
<a name="ln1357">    if ( b &lt; 0 )</a>
<a name="ln1358">      b = -b;</a>
<a name="ln1359"> </a>
<a name="ln1360">    ah = (FT_UInt32)( ( a &gt;&gt; 16 ) &amp; 0xFFFFU );</a>
<a name="ln1361">    al = (FT_UInt32)( a &amp; 0xFFFFU );</a>
<a name="ln1362"> </a>
<a name="ln1363">    lo    = al * b;</a>
<a name="ln1364">    mid   = ah * b;</a>
<a name="ln1365">    hi    = mid &gt;&gt; 16;</a>
<a name="ln1366">    mid   = ( mid &lt;&lt; 16 ) + ( 1 &lt;&lt; 13 ); /* rounding */</a>
<a name="ln1367">    lo   += mid;</a>
<a name="ln1368">    if ( lo &lt; mid )</a>
<a name="ln1369">      hi += 1;</a>
<a name="ln1370"> </a>
<a name="ln1371">    mid = ( lo &gt;&gt; 14 ) | ( hi &lt;&lt; 18 );</a>
<a name="ln1372"> </a>
<a name="ln1373">    return sign &gt;= 0 ? (FT_Int32)mid : -(FT_Int32)mid;</a>
<a name="ln1374">  }</a>
<a name="ln1375"> </a>
<a name="ln1376">#endif  /* !TT_MulFix14 */</a>
<a name="ln1377"> </a>
<a name="ln1378"> </a>
<a name="ln1379">#if defined( __GNUC__ )        &amp;&amp; \</a>
<a name="ln1380">    ( defined( __i386__ )   ||    \</a>
<a name="ln1381">      defined( __x86_64__ ) ||    \</a>
<a name="ln1382">      defined( __arm__ )    )</a>
<a name="ln1383"> </a>
<a name="ln1384">#define TT_DotFix14  TT_DotFix14_long_long</a>
<a name="ln1385"> </a>
<a name="ln1386">#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) &gt;= 406</a>
<a name="ln1387">#pragma GCC diagnostic push</a>
<a name="ln1388">#endif</a>
<a name="ln1389">#pragma GCC diagnostic ignored &quot;-Wlong-long&quot;</a>
<a name="ln1390"> </a>
<a name="ln1391">  static __attribute__(( pure )) FT_Int32</a>
<a name="ln1392">  TT_DotFix14_long_long( FT_Int32  ax,</a>
<a name="ln1393">                         FT_Int32  ay,</a>
<a name="ln1394">                         FT_Int    bx,</a>
<a name="ln1395">                         FT_Int    by )</a>
<a name="ln1396">  {</a>
<a name="ln1397">    /* Temporarily disable the warning that C90 doesn't support */</a>
<a name="ln1398">    /* `long long'.                                             */</a>
<a name="ln1399"> </a>
<a name="ln1400">    long long  temp1 = (long long)ax * bx;</a>
<a name="ln1401">    long long  temp2 = (long long)ay * by;</a>
<a name="ln1402"> </a>
<a name="ln1403"> </a>
<a name="ln1404">    temp1 += temp2;</a>
<a name="ln1405">    temp2  = temp1 &gt;&gt; 63;</a>
<a name="ln1406">    temp1 += 0x2000 + temp2;</a>
<a name="ln1407"> </a>
<a name="ln1408">    return (FT_Int32)( temp1 &gt;&gt; 14 );</a>
<a name="ln1409"> </a>
<a name="ln1410">  }</a>
<a name="ln1411"> </a>
<a name="ln1412">#if ( __GNUC__ * 100 + __GNUC_MINOR__ ) &gt;= 406</a>
<a name="ln1413">#pragma GCC diagnostic pop</a>
<a name="ln1414">#endif</a>
<a name="ln1415"> </a>
<a name="ln1416">#endif /* __GNUC__ &amp;&amp; (__arm__ || __i386__ || __x86_64__) */</a>
<a name="ln1417"> </a>
<a name="ln1418"> </a>
<a name="ln1419">#ifndef TT_DotFix14</a>
<a name="ln1420"> </a>
<a name="ln1421">  /* compute (ax*bx+ay*by)/2^14 with maximum accuracy and rounding */</a>
<a name="ln1422">  static FT_Int32</a>
<a name="ln1423">  TT_DotFix14( FT_Int32  ax,</a>
<a name="ln1424">               FT_Int32  ay,</a>
<a name="ln1425">               FT_Int    bx,</a>
<a name="ln1426">               FT_Int    by )</a>
<a name="ln1427">  {</a>
<a name="ln1428">    FT_Int32   m, s, hi1, hi2, hi;</a>
<a name="ln1429">    FT_UInt32  l, lo1, lo2, lo;</a>
<a name="ln1430"> </a>
<a name="ln1431"> </a>
<a name="ln1432">    /* compute ax*bx as 64-bit value */</a>
<a name="ln1433">    l = (FT_UInt32)( ( ax &amp; 0xFFFFU ) * bx );</a>
<a name="ln1434">    m = ( ax &gt;&gt; 16 ) * bx;</a>
<a name="ln1435"> </a>
<a name="ln1436">    lo1 = l + ( (FT_UInt32)m &lt;&lt; 16 );</a>
<a name="ln1437">    hi1 = ( m &gt;&gt; 16 ) + ( (FT_Int32)l &gt;&gt; 31 ) + ( lo1 &lt; l );</a>
<a name="ln1438"> </a>
<a name="ln1439">    /* compute ay*by as 64-bit value */</a>
<a name="ln1440">    l = (FT_UInt32)( ( ay &amp; 0xFFFFU ) * by );</a>
<a name="ln1441">    m = ( ay &gt;&gt; 16 ) * by;</a>
<a name="ln1442"> </a>
<a name="ln1443">    lo2 = l + ( (FT_UInt32)m &lt;&lt; 16 );</a>
<a name="ln1444">    hi2 = ( m &gt;&gt; 16 ) + ( (FT_Int32)l &gt;&gt; 31 ) + ( lo2 &lt; l );</a>
<a name="ln1445"> </a>
<a name="ln1446">    /* add them */</a>
<a name="ln1447">    lo = lo1 + lo2;</a>
<a name="ln1448">    hi = hi1 + hi2 + ( lo &lt; lo1 );</a>
<a name="ln1449"> </a>
<a name="ln1450">    /* divide the result by 2^14 with rounding */</a>
<a name="ln1451">    s   = hi &gt;&gt; 31;</a>
<a name="ln1452">    l   = lo + (FT_UInt32)s;</a>
<a name="ln1453">    hi += s + ( l &lt; lo );</a>
<a name="ln1454">    lo  = l;</a>
<a name="ln1455"> </a>
<a name="ln1456">    l   = lo + 0x2000U;</a>
<a name="ln1457">    hi += ( l &lt; lo );</a>
<a name="ln1458"> </a>
<a name="ln1459">    return (FT_Int32)( ( (FT_UInt32)hi &lt;&lt; 18 ) | ( l &gt;&gt; 14 ) );</a>
<a name="ln1460">  }</a>
<a name="ln1461"> </a>
<a name="ln1462">#endif /* TT_DotFix14 */</a>
<a name="ln1463"> </a>
<a name="ln1464"> </a>
<a name="ln1465">  /*************************************************************************/</a>
<a name="ln1466">  /*                                                                       */</a>
<a name="ln1467">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1468">  /*    Current_Ratio                                                      */</a>
<a name="ln1469">  /*                                                                       */</a>
<a name="ln1470">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1471">  /*    Returns the current aspect ratio scaling factor depending on the   */</a>
<a name="ln1472">  /*    projection vector's state and device resolutions.                  */</a>
<a name="ln1473">  /*                                                                       */</a>
<a name="ln1474">  /* &lt;Return&gt;                                                              */</a>
<a name="ln1475">  /*    The aspect ratio in 16.16 format, always &lt;= 1.0 .                  */</a>
<a name="ln1476">  /*                                                                       */</a>
<a name="ln1477">  static FT_Long</a>
<a name="ln1478">  Current_Ratio( TT_ExecContext  exc )</a>
<a name="ln1479">  {</a>
<a name="ln1480">    if ( !exc-&gt;tt_metrics.ratio )</a>
<a name="ln1481">    {</a>
<a name="ln1482">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln1483">      if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln1484">      {</a>
<a name="ln1485">        if ( exc-&gt;GS.both_x_axis )</a>
<a name="ln1486">          exc-&gt;tt_metrics.ratio = exc-&gt;tt_metrics.x_ratio;</a>
<a name="ln1487">        else</a>
<a name="ln1488">          exc-&gt;tt_metrics.ratio = exc-&gt;tt_metrics.y_ratio;</a>
<a name="ln1489">      }</a>
<a name="ln1490">      else</a>
<a name="ln1491">#endif</a>
<a name="ln1492">      {</a>
<a name="ln1493">        if ( exc-&gt;GS.projVector.y == 0 )</a>
<a name="ln1494">          exc-&gt;tt_metrics.ratio = exc-&gt;tt_metrics.x_ratio;</a>
<a name="ln1495"> </a>
<a name="ln1496">        else if ( exc-&gt;GS.projVector.x == 0 )</a>
<a name="ln1497">          exc-&gt;tt_metrics.ratio = exc-&gt;tt_metrics.y_ratio;</a>
<a name="ln1498"> </a>
<a name="ln1499">        else</a>
<a name="ln1500">        {</a>
<a name="ln1501">          FT_F26Dot6  x, y;</a>
<a name="ln1502"> </a>
<a name="ln1503"> </a>
<a name="ln1504">          x = TT_MulFix14( exc-&gt;tt_metrics.x_ratio,</a>
<a name="ln1505">                           exc-&gt;GS.projVector.x );</a>
<a name="ln1506">          y = TT_MulFix14( exc-&gt;tt_metrics.y_ratio,</a>
<a name="ln1507">                           exc-&gt;GS.projVector.y );</a>
<a name="ln1508">          exc-&gt;tt_metrics.ratio = FT_Hypot( x, y );</a>
<a name="ln1509">        }</a>
<a name="ln1510">      }</a>
<a name="ln1511">    }</a>
<a name="ln1512">    return exc-&gt;tt_metrics.ratio;</a>
<a name="ln1513">  }</a>
<a name="ln1514"> </a>
<a name="ln1515"> </a>
<a name="ln1516">  FT_CALLBACK_DEF( FT_Long )</a>
<a name="ln1517">  Current_Ppem( TT_ExecContext  exc )</a>
<a name="ln1518">  {</a>
<a name="ln1519">    return exc-&gt;tt_metrics.ppem;</a>
<a name="ln1520">  }</a>
<a name="ln1521"> </a>
<a name="ln1522"> </a>
<a name="ln1523">  FT_CALLBACK_DEF( FT_Long )</a>
<a name="ln1524">  Current_Ppem_Stretched( TT_ExecContext  exc )</a>
<a name="ln1525">  {</a>
<a name="ln1526">    return FT_MulFix( exc-&gt;tt_metrics.ppem, Current_Ratio( exc ) );</a>
<a name="ln1527">  }</a>
<a name="ln1528"> </a>
<a name="ln1529"> </a>
<a name="ln1530">  /*************************************************************************/</a>
<a name="ln1531">  /*                                                                       */</a>
<a name="ln1532">  /* Functions related to the control value table (CVT).                   */</a>
<a name="ln1533">  /*                                                                       */</a>
<a name="ln1534">  /*************************************************************************/</a>
<a name="ln1535"> </a>
<a name="ln1536"> </a>
<a name="ln1537">  FT_CALLBACK_DEF( FT_F26Dot6 )</a>
<a name="ln1538">  Read_CVT( TT_ExecContext  exc,</a>
<a name="ln1539">            FT_ULong        idx )</a>
<a name="ln1540">  {</a>
<a name="ln1541">    return exc-&gt;cvt[idx];</a>
<a name="ln1542">  }</a>
<a name="ln1543"> </a>
<a name="ln1544"> </a>
<a name="ln1545">  FT_CALLBACK_DEF( FT_F26Dot6 )</a>
<a name="ln1546">  Read_CVT_Stretched( TT_ExecContext  exc,</a>
<a name="ln1547">                      FT_ULong        idx )</a>
<a name="ln1548">  {</a>
<a name="ln1549">    return FT_MulFix( exc-&gt;cvt[idx], Current_Ratio( exc ) );</a>
<a name="ln1550">  }</a>
<a name="ln1551"> </a>
<a name="ln1552"> </a>
<a name="ln1553">  FT_CALLBACK_DEF( void )</a>
<a name="ln1554">  Write_CVT( TT_ExecContext  exc,</a>
<a name="ln1555">             FT_ULong        idx,</a>
<a name="ln1556">             FT_F26Dot6      value )</a>
<a name="ln1557">  {</a>
<a name="ln1558">    exc-&gt;cvt[idx] = value;</a>
<a name="ln1559">  }</a>
<a name="ln1560"> </a>
<a name="ln1561"> </a>
<a name="ln1562">  FT_CALLBACK_DEF( void )</a>
<a name="ln1563">  Write_CVT_Stretched( TT_ExecContext  exc,</a>
<a name="ln1564">                       FT_ULong        idx,</a>
<a name="ln1565">                       FT_F26Dot6      value )</a>
<a name="ln1566">  {</a>
<a name="ln1567">    exc-&gt;cvt[idx] = FT_DivFix( value, Current_Ratio( exc ) );</a>
<a name="ln1568">  }</a>
<a name="ln1569"> </a>
<a name="ln1570"> </a>
<a name="ln1571">  FT_CALLBACK_DEF( void )</a>
<a name="ln1572">  Move_CVT( TT_ExecContext  exc,</a>
<a name="ln1573">            FT_ULong        idx,</a>
<a name="ln1574">            FT_F26Dot6      value )</a>
<a name="ln1575">  {</a>
<a name="ln1576">    exc-&gt;cvt[idx] += value;</a>
<a name="ln1577">  }</a>
<a name="ln1578"> </a>
<a name="ln1579"> </a>
<a name="ln1580">  FT_CALLBACK_DEF( void )</a>
<a name="ln1581">  Move_CVT_Stretched( TT_ExecContext  exc,</a>
<a name="ln1582">                      FT_ULong        idx,</a>
<a name="ln1583">                      FT_F26Dot6      value )</a>
<a name="ln1584">  {</a>
<a name="ln1585">    exc-&gt;cvt[idx] += FT_DivFix( value, Current_Ratio( exc ) );</a>
<a name="ln1586">  }</a>
<a name="ln1587"> </a>
<a name="ln1588"> </a>
<a name="ln1589">  /*************************************************************************/</a>
<a name="ln1590">  /*                                                                       */</a>
<a name="ln1591">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1592">  /*    GetShortIns                                                        */</a>
<a name="ln1593">  /*                                                                       */</a>
<a name="ln1594">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1595">  /*    Returns a short integer taken from the instruction stream at       */</a>
<a name="ln1596">  /*    address IP.                                                        */</a>
<a name="ln1597">  /*                                                                       */</a>
<a name="ln1598">  /* &lt;Return&gt;                                                              */</a>
<a name="ln1599">  /*    Short read at code[IP].                                            */</a>
<a name="ln1600">  /*                                                                       */</a>
<a name="ln1601">  /* &lt;Note&gt;                                                                */</a>
<a name="ln1602">  /*    This one could become a macro.                                     */</a>
<a name="ln1603">  /*                                                                       */</a>
<a name="ln1604">  static FT_Short</a>
<a name="ln1605">  GetShortIns( TT_ExecContext  exc )</a>
<a name="ln1606">  {</a>
<a name="ln1607">    /* Reading a byte stream so there is no endianess (DaveP) */</a>
<a name="ln1608">    exc-&gt;IP += 2;</a>
<a name="ln1609">    return (FT_Short)( ( exc-&gt;code[exc-&gt;IP - 2] &lt;&lt; 8 ) +</a>
<a name="ln1610">                         exc-&gt;code[exc-&gt;IP - 1]      );</a>
<a name="ln1611">  }</a>
<a name="ln1612"> </a>
<a name="ln1613"> </a>
<a name="ln1614">  /*************************************************************************/</a>
<a name="ln1615">  /*                                                                       */</a>
<a name="ln1616">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1617">  /*    Ins_Goto_CodeRange                                                 */</a>
<a name="ln1618">  /*                                                                       */</a>
<a name="ln1619">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1620">  /*    Goes to a certain code range in the instruction stream.            */</a>
<a name="ln1621">  /*                                                                       */</a>
<a name="ln1622">  /* &lt;Input&gt;                                                               */</a>
<a name="ln1623">  /*    aRange :: The index of the code range.                             */</a>
<a name="ln1624">  /*                                                                       */</a>
<a name="ln1625">  /*    aIP    :: The new IP address in the code range.                    */</a>
<a name="ln1626">  /*                                                                       */</a>
<a name="ln1627">  /* &lt;Return&gt;                                                              */</a>
<a name="ln1628">  /*    SUCCESS or FAILURE.                                                */</a>
<a name="ln1629">  /*                                                                       */</a>
<a name="ln1630">  static FT_Bool</a>
<a name="ln1631">  Ins_Goto_CodeRange( TT_ExecContext  exc,</a>
<a name="ln1632">                      FT_Int          aRange,</a>
<a name="ln1633">                      FT_Long         aIP )</a>
<a name="ln1634">  {</a>
<a name="ln1635">    TT_CodeRange*  range;</a>
<a name="ln1636"> </a>
<a name="ln1637"> </a>
<a name="ln1638">    if ( aRange &lt; 1 || aRange &gt; 3 )</a>
<a name="ln1639">    {</a>
<a name="ln1640">      exc-&gt;error = FT_THROW( Bad_Argument );</a>
<a name="ln1641">      return FAILURE;</a>
<a name="ln1642">    }</a>
<a name="ln1643"> </a>
<a name="ln1644">    range = &amp;exc-&gt;codeRangeTable[aRange - 1];</a>
<a name="ln1645"> </a>
<a name="ln1646">    if ( range-&gt;base == NULL )     /* invalid coderange */</a>
<a name="ln1647">    {</a>
<a name="ln1648">      exc-&gt;error = FT_THROW( Invalid_CodeRange );</a>
<a name="ln1649">      return FAILURE;</a>
<a name="ln1650">    }</a>
<a name="ln1651"> </a>
<a name="ln1652">    /* NOTE: Because the last instruction of a program may be a CALL */</a>
<a name="ln1653">    /*       which will return to the first byte *after* the code    */</a>
<a name="ln1654">    /*       range, we test for aIP &lt;= Size, instead of aIP &lt; Size.  */</a>
<a name="ln1655"> </a>
<a name="ln1656">    if ( aIP &gt; range-&gt;size )</a>
<a name="ln1657">    {</a>
<a name="ln1658">      exc-&gt;error = FT_THROW( Code_Overflow );</a>
<a name="ln1659">      return FAILURE;</a>
<a name="ln1660">    }</a>
<a name="ln1661"> </a>
<a name="ln1662">    exc-&gt;code     = range-&gt;base;</a>
<a name="ln1663">    exc-&gt;codeSize = range-&gt;size;</a>
<a name="ln1664">    exc-&gt;IP       = aIP;</a>
<a name="ln1665">    exc-&gt;curRange = aRange;</a>
<a name="ln1666"> </a>
<a name="ln1667">    return SUCCESS;</a>
<a name="ln1668">  }</a>
<a name="ln1669"> </a>
<a name="ln1670"> </a>
<a name="ln1671">  /*************************************************************************/</a>
<a name="ln1672">  /*                                                                       */</a>
<a name="ln1673">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1674">  /*    Direct_Move                                                        */</a>
<a name="ln1675">  /*                                                                       */</a>
<a name="ln1676">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1677">  /*    Moves a point by a given distance along the freedom vector.  The   */</a>
<a name="ln1678">  /*    point will be `touched'.                                           */</a>
<a name="ln1679">  /*                                                                       */</a>
<a name="ln1680">  /* &lt;Input&gt;                                                               */</a>
<a name="ln1681">  /*    point    :: The index of the point to move.                        */</a>
<a name="ln1682">  /*                                                                       */</a>
<a name="ln1683">  /*    distance :: The distance to apply.                                 */</a>
<a name="ln1684">  /*                                                                       */</a>
<a name="ln1685">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln1686">  /*    zone     :: The affected glyph zone.                               */</a>
<a name="ln1687">  /*                                                                       */</a>
<a name="ln1688">  static void</a>
<a name="ln1689">  Direct_Move( TT_ExecContext  exc,</a>
<a name="ln1690">               TT_GlyphZone    zone,</a>
<a name="ln1691">               FT_UShort       point,</a>
<a name="ln1692">               FT_F26Dot6      distance )</a>
<a name="ln1693">  {</a>
<a name="ln1694">    FT_F26Dot6  v;</a>
<a name="ln1695"> </a>
<a name="ln1696"> </a>
<a name="ln1697">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln1698">    FT_ASSERT( !exc-&gt;face-&gt;unpatented_hinting );</a>
<a name="ln1699">#endif</a>
<a name="ln1700"> </a>
<a name="ln1701">    v = exc-&gt;GS.freeVector.x;</a>
<a name="ln1702"> </a>
<a name="ln1703">    if ( v != 0 )</a>
<a name="ln1704">    {</a>
<a name="ln1705">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln1706">      if ( !SUBPIXEL_HINTING                                      ||</a>
<a name="ln1707">           ( !exc-&gt;ignore_x_mode                                ||</a>
<a name="ln1708">             ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ALLOW_X_DMOVE ) ) )</a>
<a name="ln1709">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln1710">        zone-&gt;cur[point].x += FT_MulDiv( distance, v, exc-&gt;F_dot_P );</a>
<a name="ln1711"> </a>
<a name="ln1712">      zone-&gt;tags[point] |= FT_CURVE_TAG_TOUCH_X;</a>
<a name="ln1713">    }</a>
<a name="ln1714"> </a>
<a name="ln1715">    v = exc-&gt;GS.freeVector.y;</a>
<a name="ln1716"> </a>
<a name="ln1717">    if ( v != 0 )</a>
<a name="ln1718">    {</a>
<a name="ln1719">      zone-&gt;cur[point].y += FT_MulDiv( distance, v, exc-&gt;F_dot_P );</a>
<a name="ln1720"> </a>
<a name="ln1721">      zone-&gt;tags[point] |= FT_CURVE_TAG_TOUCH_Y;</a>
<a name="ln1722">    }</a>
<a name="ln1723">  }</a>
<a name="ln1724"> </a>
<a name="ln1725"> </a>
<a name="ln1726">  /*************************************************************************/</a>
<a name="ln1727">  /*                                                                       */</a>
<a name="ln1728">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1729">  /*    Direct_Move_Orig                                                   */</a>
<a name="ln1730">  /*                                                                       */</a>
<a name="ln1731">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1732">  /*    Moves the *original* position of a point by a given distance along */</a>
<a name="ln1733">  /*    the freedom vector.  Obviously, the point will not be `touched'.   */</a>
<a name="ln1734">  /*                                                                       */</a>
<a name="ln1735">  /* &lt;Input&gt;                                                               */</a>
<a name="ln1736">  /*    point    :: The index of the point to move.                        */</a>
<a name="ln1737">  /*                                                                       */</a>
<a name="ln1738">  /*    distance :: The distance to apply.                                 */</a>
<a name="ln1739">  /*                                                                       */</a>
<a name="ln1740">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln1741">  /*    zone     :: The affected glyph zone.                               */</a>
<a name="ln1742">  /*                                                                       */</a>
<a name="ln1743">  static void</a>
<a name="ln1744">  Direct_Move_Orig( TT_ExecContext  exc,</a>
<a name="ln1745">                    TT_GlyphZone    zone,</a>
<a name="ln1746">                    FT_UShort       point,</a>
<a name="ln1747">                    FT_F26Dot6      distance )</a>
<a name="ln1748">  {</a>
<a name="ln1749">    FT_F26Dot6  v;</a>
<a name="ln1750"> </a>
<a name="ln1751"> </a>
<a name="ln1752">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln1753">    FT_ASSERT( !exc-&gt;face-&gt;unpatented_hinting );</a>
<a name="ln1754">#endif</a>
<a name="ln1755"> </a>
<a name="ln1756">    v = exc-&gt;GS.freeVector.x;</a>
<a name="ln1757"> </a>
<a name="ln1758">    if ( v != 0 )</a>
<a name="ln1759">      zone-&gt;org[point].x += FT_MulDiv( distance, v, exc-&gt;F_dot_P );</a>
<a name="ln1760"> </a>
<a name="ln1761">    v = exc-&gt;GS.freeVector.y;</a>
<a name="ln1762"> </a>
<a name="ln1763">    if ( v != 0 )</a>
<a name="ln1764">      zone-&gt;org[point].y += FT_MulDiv( distance, v, exc-&gt;F_dot_P );</a>
<a name="ln1765">  }</a>
<a name="ln1766"> </a>
<a name="ln1767"> </a>
<a name="ln1768">  /*************************************************************************/</a>
<a name="ln1769">  /*                                                                       */</a>
<a name="ln1770">  /* Special versions of Direct_Move()                                     */</a>
<a name="ln1771">  /*                                                                       */</a>
<a name="ln1772">  /*   The following versions are used whenever both vectors are both      */</a>
<a name="ln1773">  /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */</a>
<a name="ln1774">  /*                                                                       */</a>
<a name="ln1775">  /*************************************************************************/</a>
<a name="ln1776"> </a>
<a name="ln1777"> </a>
<a name="ln1778">  static void</a>
<a name="ln1779">  Direct_Move_X( TT_ExecContext  exc,</a>
<a name="ln1780">                 TT_GlyphZone    zone,</a>
<a name="ln1781">                 FT_UShort       point,</a>
<a name="ln1782">                 FT_F26Dot6      distance )</a>
<a name="ln1783">  {</a>
<a name="ln1784">    FT_UNUSED( exc );</a>
<a name="ln1785"> </a>
<a name="ln1786">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln1787">    if ( !SUBPIXEL_HINTING   ||</a>
<a name="ln1788">         !exc-&gt;ignore_x_mode )</a>
<a name="ln1789">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln1790">      zone-&gt;cur[point].x += distance;</a>
<a name="ln1791"> </a>
<a name="ln1792">    zone-&gt;tags[point]  |= FT_CURVE_TAG_TOUCH_X;</a>
<a name="ln1793">  }</a>
<a name="ln1794"> </a>
<a name="ln1795"> </a>
<a name="ln1796">  static void</a>
<a name="ln1797">  Direct_Move_Y( TT_ExecContext  exc,</a>
<a name="ln1798">                 TT_GlyphZone    zone,</a>
<a name="ln1799">                 FT_UShort       point,</a>
<a name="ln1800">                 FT_F26Dot6      distance )</a>
<a name="ln1801">  {</a>
<a name="ln1802">    FT_UNUSED( exc );</a>
<a name="ln1803"> </a>
<a name="ln1804">    zone-&gt;cur[point].y += distance;</a>
<a name="ln1805">    zone-&gt;tags[point]  |= FT_CURVE_TAG_TOUCH_Y;</a>
<a name="ln1806">  }</a>
<a name="ln1807"> </a>
<a name="ln1808"> </a>
<a name="ln1809">  /*************************************************************************/</a>
<a name="ln1810">  /*                                                                       */</a>
<a name="ln1811">  /* Special versions of Direct_Move_Orig()                                */</a>
<a name="ln1812">  /*                                                                       */</a>
<a name="ln1813">  /*   The following versions are used whenever both vectors are both      */</a>
<a name="ln1814">  /*   along one of the coordinate unit vectors, i.e. in 90% of the cases. */</a>
<a name="ln1815">  /*                                                                       */</a>
<a name="ln1816">  /*************************************************************************/</a>
<a name="ln1817"> </a>
<a name="ln1818"> </a>
<a name="ln1819">  static void</a>
<a name="ln1820">  Direct_Move_Orig_X( TT_ExecContext  exc,</a>
<a name="ln1821">                      TT_GlyphZone    zone,</a>
<a name="ln1822">                      FT_UShort       point,</a>
<a name="ln1823">                      FT_F26Dot6      distance )</a>
<a name="ln1824">  {</a>
<a name="ln1825">    FT_UNUSED( exc );</a>
<a name="ln1826"> </a>
<a name="ln1827">    zone-&gt;org[point].x += distance;</a>
<a name="ln1828">  }</a>
<a name="ln1829"> </a>
<a name="ln1830"> </a>
<a name="ln1831">  static void</a>
<a name="ln1832">  Direct_Move_Orig_Y( TT_ExecContext  exc,</a>
<a name="ln1833">                      TT_GlyphZone    zone,</a>
<a name="ln1834">                      FT_UShort       point,</a>
<a name="ln1835">                      FT_F26Dot6      distance )</a>
<a name="ln1836">  {</a>
<a name="ln1837">    FT_UNUSED( exc );</a>
<a name="ln1838"> </a>
<a name="ln1839">    zone-&gt;org[point].y += distance;</a>
<a name="ln1840">  }</a>
<a name="ln1841"> </a>
<a name="ln1842"> </a>
<a name="ln1843">  /*************************************************************************/</a>
<a name="ln1844">  /*                                                                       */</a>
<a name="ln1845">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1846">  /*    Round_None                                                         */</a>
<a name="ln1847">  /*                                                                       */</a>
<a name="ln1848">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1849">  /*    Does not round, but adds engine compensation.                      */</a>
<a name="ln1850">  /*                                                                       */</a>
<a name="ln1851">  /* &lt;Input&gt;                                                               */</a>
<a name="ln1852">  /*    distance     :: The distance (not) to round.                       */</a>
<a name="ln1853">  /*                                                                       */</a>
<a name="ln1854">  /*    compensation :: The engine compensation.                           */</a>
<a name="ln1855">  /*                                                                       */</a>
<a name="ln1856">  /* &lt;Return&gt;                                                              */</a>
<a name="ln1857">  /*    The compensated distance.                                          */</a>
<a name="ln1858">  /*                                                                       */</a>
<a name="ln1859">  /* &lt;Note&gt;                                                                */</a>
<a name="ln1860">  /*    The TrueType specification says very few about the relationship    */</a>
<a name="ln1861">  /*    between rounding and engine compensation.  However, it seems from  */</a>
<a name="ln1862">  /*    the description of super round that we should add the compensation */</a>
<a name="ln1863">  /*    before rounding.                                                   */</a>
<a name="ln1864">  /*                                                                       */</a>
<a name="ln1865">  static FT_F26Dot6</a>
<a name="ln1866">  Round_None( TT_ExecContext  exc,</a>
<a name="ln1867">              FT_F26Dot6      distance,</a>
<a name="ln1868">              FT_F26Dot6      compensation )</a>
<a name="ln1869">  {</a>
<a name="ln1870">    FT_F26Dot6  val;</a>
<a name="ln1871"> </a>
<a name="ln1872">    FT_UNUSED( exc );</a>
<a name="ln1873"> </a>
<a name="ln1874"> </a>
<a name="ln1875">    if ( distance &gt;= 0 )</a>
<a name="ln1876">    {</a>
<a name="ln1877">      val = distance + compensation;</a>
<a name="ln1878">      if ( val &lt; 0 )</a>
<a name="ln1879">        val = 0;</a>
<a name="ln1880">    }</a>
<a name="ln1881">    else</a>
<a name="ln1882">    {</a>
<a name="ln1883">      val = distance - compensation;</a>
<a name="ln1884">      if ( val &gt; 0 )</a>
<a name="ln1885">        val = 0;</a>
<a name="ln1886">    }</a>
<a name="ln1887">    return val;</a>
<a name="ln1888">  }</a>
<a name="ln1889"> </a>
<a name="ln1890"> </a>
<a name="ln1891">  /*************************************************************************/</a>
<a name="ln1892">  /*                                                                       */</a>
<a name="ln1893">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1894">  /*    Round_To_Grid                                                      */</a>
<a name="ln1895">  /*                                                                       */</a>
<a name="ln1896">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1897">  /*    Rounds value to grid after adding engine compensation.             */</a>
<a name="ln1898">  /*                                                                       */</a>
<a name="ln1899">  /* &lt;Input&gt;                                                               */</a>
<a name="ln1900">  /*    distance     :: The distance to round.                             */</a>
<a name="ln1901">  /*                                                                       */</a>
<a name="ln1902">  /*    compensation :: The engine compensation.                           */</a>
<a name="ln1903">  /*                                                                       */</a>
<a name="ln1904">  /* &lt;Return&gt;                                                              */</a>
<a name="ln1905">  /*    Rounded distance.                                                  */</a>
<a name="ln1906">  /*                                                                       */</a>
<a name="ln1907">  static FT_F26Dot6</a>
<a name="ln1908">  Round_To_Grid( TT_ExecContext  exc,</a>
<a name="ln1909">                 FT_F26Dot6      distance,</a>
<a name="ln1910">                 FT_F26Dot6      compensation )</a>
<a name="ln1911">  {</a>
<a name="ln1912">    FT_F26Dot6  val;</a>
<a name="ln1913"> </a>
<a name="ln1914">    FT_UNUSED( exc );</a>
<a name="ln1915"> </a>
<a name="ln1916"> </a>
<a name="ln1917">    if ( distance &gt;= 0 )</a>
<a name="ln1918">    {</a>
<a name="ln1919">      val = FT_PIX_ROUND( distance + compensation );</a>
<a name="ln1920">      if ( val &lt; 0 )</a>
<a name="ln1921">        val = 0;</a>
<a name="ln1922">    }</a>
<a name="ln1923">    else</a>
<a name="ln1924">    {</a>
<a name="ln1925">      val = -FT_PIX_ROUND( compensation - distance );</a>
<a name="ln1926">      if ( val &gt; 0 )</a>
<a name="ln1927">        val = 0;</a>
<a name="ln1928">    }</a>
<a name="ln1929"> </a>
<a name="ln1930">    return val;</a>
<a name="ln1931">  }</a>
<a name="ln1932"> </a>
<a name="ln1933"> </a>
<a name="ln1934">  /*************************************************************************/</a>
<a name="ln1935">  /*                                                                       */</a>
<a name="ln1936">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1937">  /*    Round_To_Half_Grid                                                 */</a>
<a name="ln1938">  /*                                                                       */</a>
<a name="ln1939">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1940">  /*    Rounds value to half grid after adding engine compensation.        */</a>
<a name="ln1941">  /*                                                                       */</a>
<a name="ln1942">  /* &lt;Input&gt;                                                               */</a>
<a name="ln1943">  /*    distance     :: The distance to round.                             */</a>
<a name="ln1944">  /*                                                                       */</a>
<a name="ln1945">  /*    compensation :: The engine compensation.                           */</a>
<a name="ln1946">  /*                                                                       */</a>
<a name="ln1947">  /* &lt;Return&gt;                                                              */</a>
<a name="ln1948">  /*    Rounded distance.                                                  */</a>
<a name="ln1949">  /*                                                                       */</a>
<a name="ln1950">  static FT_F26Dot6</a>
<a name="ln1951">  Round_To_Half_Grid( TT_ExecContext  exc,</a>
<a name="ln1952">                      FT_F26Dot6      distance,</a>
<a name="ln1953">                      FT_F26Dot6      compensation )</a>
<a name="ln1954">  {</a>
<a name="ln1955">    FT_F26Dot6  val;</a>
<a name="ln1956"> </a>
<a name="ln1957">    FT_UNUSED( exc );</a>
<a name="ln1958"> </a>
<a name="ln1959"> </a>
<a name="ln1960">    if ( distance &gt;= 0 )</a>
<a name="ln1961">    {</a>
<a name="ln1962">      val = FT_PIX_FLOOR( distance + compensation ) + 32;</a>
<a name="ln1963">      if ( val &lt; 0 )</a>
<a name="ln1964">        val = 32;</a>
<a name="ln1965">    }</a>
<a name="ln1966">    else</a>
<a name="ln1967">    {</a>
<a name="ln1968">      val = -( FT_PIX_FLOOR( compensation - distance ) + 32 );</a>
<a name="ln1969">      if ( val &gt; 0 )</a>
<a name="ln1970">        val = -32;</a>
<a name="ln1971">    }</a>
<a name="ln1972"> </a>
<a name="ln1973">    return val;</a>
<a name="ln1974">  }</a>
<a name="ln1975"> </a>
<a name="ln1976"> </a>
<a name="ln1977">  /*************************************************************************/</a>
<a name="ln1978">  /*                                                                       */</a>
<a name="ln1979">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1980">  /*    Round_Down_To_Grid                                                 */</a>
<a name="ln1981">  /*                                                                       */</a>
<a name="ln1982">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1983">  /*    Rounds value down to grid after adding engine compensation.        */</a>
<a name="ln1984">  /*                                                                       */</a>
<a name="ln1985">  /* &lt;Input&gt;                                                               */</a>
<a name="ln1986">  /*    distance     :: The distance to round.                             */</a>
<a name="ln1987">  /*                                                                       */</a>
<a name="ln1988">  /*    compensation :: The engine compensation.                           */</a>
<a name="ln1989">  /*                                                                       */</a>
<a name="ln1990">  /* &lt;Return&gt;                                                              */</a>
<a name="ln1991">  /*    Rounded distance.                                                  */</a>
<a name="ln1992">  /*                                                                       */</a>
<a name="ln1993">  static FT_F26Dot6</a>
<a name="ln1994">  Round_Down_To_Grid( TT_ExecContext  exc,</a>
<a name="ln1995">                      FT_F26Dot6      distance,</a>
<a name="ln1996">                      FT_F26Dot6      compensation )</a>
<a name="ln1997">  {</a>
<a name="ln1998">    FT_F26Dot6  val;</a>
<a name="ln1999"> </a>
<a name="ln2000">    FT_UNUSED( exc );</a>
<a name="ln2001"> </a>
<a name="ln2002"> </a>
<a name="ln2003">    if ( distance &gt;= 0 )</a>
<a name="ln2004">    {</a>
<a name="ln2005">      val = FT_PIX_FLOOR( distance + compensation );</a>
<a name="ln2006">      if ( val &lt; 0 )</a>
<a name="ln2007">        val = 0;</a>
<a name="ln2008">    }</a>
<a name="ln2009">    else</a>
<a name="ln2010">    {</a>
<a name="ln2011">      val = -FT_PIX_FLOOR( compensation - distance );</a>
<a name="ln2012">      if ( val &gt; 0 )</a>
<a name="ln2013">        val = 0;</a>
<a name="ln2014">    }</a>
<a name="ln2015"> </a>
<a name="ln2016">    return val;</a>
<a name="ln2017">  }</a>
<a name="ln2018"> </a>
<a name="ln2019"> </a>
<a name="ln2020">  /*************************************************************************/</a>
<a name="ln2021">  /*                                                                       */</a>
<a name="ln2022">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2023">  /*    Round_Up_To_Grid                                                   */</a>
<a name="ln2024">  /*                                                                       */</a>
<a name="ln2025">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2026">  /*    Rounds value up to grid after adding engine compensation.          */</a>
<a name="ln2027">  /*                                                                       */</a>
<a name="ln2028">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2029">  /*    distance     :: The distance to round.                             */</a>
<a name="ln2030">  /*                                                                       */</a>
<a name="ln2031">  /*    compensation :: The engine compensation.                           */</a>
<a name="ln2032">  /*                                                                       */</a>
<a name="ln2033">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2034">  /*    Rounded distance.                                                  */</a>
<a name="ln2035">  /*                                                                       */</a>
<a name="ln2036">  static FT_F26Dot6</a>
<a name="ln2037">  Round_Up_To_Grid( TT_ExecContext  exc,</a>
<a name="ln2038">                    FT_F26Dot6      distance,</a>
<a name="ln2039">                    FT_F26Dot6      compensation )</a>
<a name="ln2040">  {</a>
<a name="ln2041">    FT_F26Dot6  val;</a>
<a name="ln2042"> </a>
<a name="ln2043">    FT_UNUSED( exc );</a>
<a name="ln2044"> </a>
<a name="ln2045"> </a>
<a name="ln2046">    if ( distance &gt;= 0 )</a>
<a name="ln2047">    {</a>
<a name="ln2048">      val = FT_PIX_CEIL( distance + compensation );</a>
<a name="ln2049">      if ( val &lt; 0 )</a>
<a name="ln2050">        val = 0;</a>
<a name="ln2051">    }</a>
<a name="ln2052">    else</a>
<a name="ln2053">    {</a>
<a name="ln2054">      val = -FT_PIX_CEIL( compensation - distance );</a>
<a name="ln2055">      if ( val &gt; 0 )</a>
<a name="ln2056">        val = 0;</a>
<a name="ln2057">    }</a>
<a name="ln2058"> </a>
<a name="ln2059">    return val;</a>
<a name="ln2060">  }</a>
<a name="ln2061"> </a>
<a name="ln2062"> </a>
<a name="ln2063">  /*************************************************************************/</a>
<a name="ln2064">  /*                                                                       */</a>
<a name="ln2065">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2066">  /*    Round_To_Double_Grid                                               */</a>
<a name="ln2067">  /*                                                                       */</a>
<a name="ln2068">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2069">  /*    Rounds value to double grid after adding engine compensation.      */</a>
<a name="ln2070">  /*                                                                       */</a>
<a name="ln2071">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2072">  /*    distance     :: The distance to round.                             */</a>
<a name="ln2073">  /*                                                                       */</a>
<a name="ln2074">  /*    compensation :: The engine compensation.                           */</a>
<a name="ln2075">  /*                                                                       */</a>
<a name="ln2076">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2077">  /*    Rounded distance.                                                  */</a>
<a name="ln2078">  /*                                                                       */</a>
<a name="ln2079">  static FT_F26Dot6</a>
<a name="ln2080">  Round_To_Double_Grid( TT_ExecContext  exc,</a>
<a name="ln2081">                        FT_F26Dot6      distance,</a>
<a name="ln2082">                        FT_F26Dot6      compensation )</a>
<a name="ln2083">  {</a>
<a name="ln2084">    FT_F26Dot6 val;</a>
<a name="ln2085"> </a>
<a name="ln2086">    FT_UNUSED( exc );</a>
<a name="ln2087"> </a>
<a name="ln2088"> </a>
<a name="ln2089">    if ( distance &gt;= 0 )</a>
<a name="ln2090">    {</a>
<a name="ln2091">      val = FT_PAD_ROUND( distance + compensation, 32 );</a>
<a name="ln2092">      if ( val &lt; 0 )</a>
<a name="ln2093">        val = 0;</a>
<a name="ln2094">    }</a>
<a name="ln2095">    else</a>
<a name="ln2096">    {</a>
<a name="ln2097">      val = -FT_PAD_ROUND( compensation - distance, 32 );</a>
<a name="ln2098">      if ( val &gt; 0 )</a>
<a name="ln2099">        val = 0;</a>
<a name="ln2100">    }</a>
<a name="ln2101"> </a>
<a name="ln2102">    return val;</a>
<a name="ln2103">  }</a>
<a name="ln2104"> </a>
<a name="ln2105"> </a>
<a name="ln2106">  /*************************************************************************/</a>
<a name="ln2107">  /*                                                                       */</a>
<a name="ln2108">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2109">  /*    Round_Super                                                        */</a>
<a name="ln2110">  /*                                                                       */</a>
<a name="ln2111">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2112">  /*    Super-rounds value to grid after adding engine compensation.       */</a>
<a name="ln2113">  /*                                                                       */</a>
<a name="ln2114">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2115">  /*    distance     :: The distance to round.                             */</a>
<a name="ln2116">  /*                                                                       */</a>
<a name="ln2117">  /*    compensation :: The engine compensation.                           */</a>
<a name="ln2118">  /*                                                                       */</a>
<a name="ln2119">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2120">  /*    Rounded distance.                                                  */</a>
<a name="ln2121">  /*                                                                       */</a>
<a name="ln2122">  /* &lt;Note&gt;                                                                */</a>
<a name="ln2123">  /*    The TrueType specification says very few about the relationship    */</a>
<a name="ln2124">  /*    between rounding and engine compensation.  However, it seems from  */</a>
<a name="ln2125">  /*    the description of super round that we should add the compensation */</a>
<a name="ln2126">  /*    before rounding.                                                   */</a>
<a name="ln2127">  /*                                                                       */</a>
<a name="ln2128">  static FT_F26Dot6</a>
<a name="ln2129">  Round_Super( TT_ExecContext  exc,</a>
<a name="ln2130">               FT_F26Dot6      distance,</a>
<a name="ln2131">               FT_F26Dot6      compensation )</a>
<a name="ln2132">  {</a>
<a name="ln2133">    FT_F26Dot6  val;</a>
<a name="ln2134"> </a>
<a name="ln2135"> </a>
<a name="ln2136">    if ( distance &gt;= 0 )</a>
<a name="ln2137">    {</a>
<a name="ln2138">      val = ( distance - exc-&gt;phase + exc-&gt;threshold + compensation ) &amp;</a>
<a name="ln2139">              -exc-&gt;period;</a>
<a name="ln2140">      val += exc-&gt;phase;</a>
<a name="ln2141">      if ( val &lt; 0 )</a>
<a name="ln2142">        val = exc-&gt;phase;</a>
<a name="ln2143">    }</a>
<a name="ln2144">    else</a>
<a name="ln2145">    {</a>
<a name="ln2146">      val = -( ( exc-&gt;threshold - exc-&gt;phase - distance + compensation ) &amp;</a>
<a name="ln2147">               -exc-&gt;period );</a>
<a name="ln2148">      val -= exc-&gt;phase;</a>
<a name="ln2149">      if ( val &gt; 0 )</a>
<a name="ln2150">        val = -exc-&gt;phase;</a>
<a name="ln2151">    }</a>
<a name="ln2152"> </a>
<a name="ln2153">    return val;</a>
<a name="ln2154">  }</a>
<a name="ln2155"> </a>
<a name="ln2156"> </a>
<a name="ln2157">  /*************************************************************************/</a>
<a name="ln2158">  /*                                                                       */</a>
<a name="ln2159">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2160">  /*    Round_Super_45                                                     */</a>
<a name="ln2161">  /*                                                                       */</a>
<a name="ln2162">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2163">  /*    Super-rounds value to grid after adding engine compensation.       */</a>
<a name="ln2164">  /*                                                                       */</a>
<a name="ln2165">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2166">  /*    distance     :: The distance to round.                             */</a>
<a name="ln2167">  /*                                                                       */</a>
<a name="ln2168">  /*    compensation :: The engine compensation.                           */</a>
<a name="ln2169">  /*                                                                       */</a>
<a name="ln2170">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2171">  /*    Rounded distance.                                                  */</a>
<a name="ln2172">  /*                                                                       */</a>
<a name="ln2173">  /* &lt;Note&gt;                                                                */</a>
<a name="ln2174">  /*    There is a separate function for Round_Super_45() as we may need   */</a>
<a name="ln2175">  /*    greater precision.                                                 */</a>
<a name="ln2176">  /*                                                                       */</a>
<a name="ln2177">  static FT_F26Dot6</a>
<a name="ln2178">  Round_Super_45( TT_ExecContext  exc,</a>
<a name="ln2179">                  FT_F26Dot6      distance,</a>
<a name="ln2180">                  FT_F26Dot6      compensation )</a>
<a name="ln2181">  {</a>
<a name="ln2182">    FT_F26Dot6  val;</a>
<a name="ln2183"> </a>
<a name="ln2184"> </a>
<a name="ln2185">    if ( distance &gt;= 0 )</a>
<a name="ln2186">    {</a>
<a name="ln2187">      val = ( ( distance - exc-&gt;phase + exc-&gt;threshold + compensation ) /</a>
<a name="ln2188">                exc-&gt;period ) * exc-&gt;period;</a>
<a name="ln2189">      val += exc-&gt;phase;</a>
<a name="ln2190">      if ( val &lt; 0 )</a>
<a name="ln2191">        val = exc-&gt;phase;</a>
<a name="ln2192">    }</a>
<a name="ln2193">    else</a>
<a name="ln2194">    {</a>
<a name="ln2195">      val = -( ( ( exc-&gt;threshold - exc-&gt;phase - distance + compensation ) /</a>
<a name="ln2196">                   exc-&gt;period ) * exc-&gt;period );</a>
<a name="ln2197">      val -= exc-&gt;phase;</a>
<a name="ln2198">      if ( val &gt; 0 )</a>
<a name="ln2199">        val = -exc-&gt;phase;</a>
<a name="ln2200">    }</a>
<a name="ln2201"> </a>
<a name="ln2202">    return val;</a>
<a name="ln2203">  }</a>
<a name="ln2204"> </a>
<a name="ln2205"> </a>
<a name="ln2206">  /*************************************************************************/</a>
<a name="ln2207">  /*                                                                       */</a>
<a name="ln2208">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2209">  /*    Compute_Round                                                      */</a>
<a name="ln2210">  /*                                                                       */</a>
<a name="ln2211">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2212">  /*    Sets the rounding mode.                                            */</a>
<a name="ln2213">  /*                                                                       */</a>
<a name="ln2214">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2215">  /*    round_mode :: The rounding mode to be used.                        */</a>
<a name="ln2216">  /*                                                                       */</a>
<a name="ln2217">  static void</a>
<a name="ln2218">  Compute_Round( TT_ExecContext  exc,</a>
<a name="ln2219">                 FT_Byte         round_mode )</a>
<a name="ln2220">  {</a>
<a name="ln2221">    switch ( round_mode )</a>
<a name="ln2222">    {</a>
<a name="ln2223">    case TT_Round_Off:</a>
<a name="ln2224">      exc-&gt;func_round = (TT_Round_Func)Round_None;</a>
<a name="ln2225">      break;</a>
<a name="ln2226"> </a>
<a name="ln2227">    case TT_Round_To_Grid:</a>
<a name="ln2228">      exc-&gt;func_round = (TT_Round_Func)Round_To_Grid;</a>
<a name="ln2229">      break;</a>
<a name="ln2230"> </a>
<a name="ln2231">    case TT_Round_Up_To_Grid:</a>
<a name="ln2232">      exc-&gt;func_round = (TT_Round_Func)Round_Up_To_Grid;</a>
<a name="ln2233">      break;</a>
<a name="ln2234"> </a>
<a name="ln2235">    case TT_Round_Down_To_Grid:</a>
<a name="ln2236">      exc-&gt;func_round = (TT_Round_Func)Round_Down_To_Grid;</a>
<a name="ln2237">      break;</a>
<a name="ln2238"> </a>
<a name="ln2239">    case TT_Round_To_Half_Grid:</a>
<a name="ln2240">      exc-&gt;func_round = (TT_Round_Func)Round_To_Half_Grid;</a>
<a name="ln2241">      break;</a>
<a name="ln2242"> </a>
<a name="ln2243">    case TT_Round_To_Double_Grid:</a>
<a name="ln2244">      exc-&gt;func_round = (TT_Round_Func)Round_To_Double_Grid;</a>
<a name="ln2245">      break;</a>
<a name="ln2246"> </a>
<a name="ln2247">    case TT_Round_Super:</a>
<a name="ln2248">      exc-&gt;func_round = (TT_Round_Func)Round_Super;</a>
<a name="ln2249">      break;</a>
<a name="ln2250"> </a>
<a name="ln2251">    case TT_Round_Super_45:</a>
<a name="ln2252">      exc-&gt;func_round = (TT_Round_Func)Round_Super_45;</a>
<a name="ln2253">      break;</a>
<a name="ln2254">    }</a>
<a name="ln2255">  }</a>
<a name="ln2256"> </a>
<a name="ln2257"> </a>
<a name="ln2258">  /*************************************************************************/</a>
<a name="ln2259">  /*                                                                       */</a>
<a name="ln2260">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2261">  /*    SetSuperRound                                                      */</a>
<a name="ln2262">  /*                                                                       */</a>
<a name="ln2263">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2264">  /*    Sets Super Round parameters.                                       */</a>
<a name="ln2265">  /*                                                                       */</a>
<a name="ln2266">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2267">  /*    GridPeriod :: The grid period.                                     */</a>
<a name="ln2268">  /*                                                                       */</a>
<a name="ln2269">  /*    selector   :: The SROUND opcode.                                   */</a>
<a name="ln2270">  /*                                                                       */</a>
<a name="ln2271">  static void</a>
<a name="ln2272">  SetSuperRound( TT_ExecContext  exc,</a>
<a name="ln2273">                 FT_F2Dot14      GridPeriod,</a>
<a name="ln2274">                 FT_Long         selector )</a>
<a name="ln2275">  {</a>
<a name="ln2276">    switch ( (FT_Int)( selector &amp; 0xC0 ) )</a>
<a name="ln2277">    {</a>
<a name="ln2278">      case 0:</a>
<a name="ln2279">        exc-&gt;period = GridPeriod / 2;</a>
<a name="ln2280">        break;</a>
<a name="ln2281"> </a>
<a name="ln2282">      case 0x40:</a>
<a name="ln2283">        exc-&gt;period = GridPeriod;</a>
<a name="ln2284">        break;</a>
<a name="ln2285"> </a>
<a name="ln2286">      case 0x80:</a>
<a name="ln2287">        exc-&gt;period = GridPeriod * 2;</a>
<a name="ln2288">        break;</a>
<a name="ln2289"> </a>
<a name="ln2290">      /* This opcode is reserved, but... */</a>
<a name="ln2291">      case 0xC0:</a>
<a name="ln2292">        exc-&gt;period = GridPeriod;</a>
<a name="ln2293">        break;</a>
<a name="ln2294">    }</a>
<a name="ln2295"> </a>
<a name="ln2296">    switch ( (FT_Int)( selector &amp; 0x30 ) )</a>
<a name="ln2297">    {</a>
<a name="ln2298">    case 0:</a>
<a name="ln2299">      exc-&gt;phase = 0;</a>
<a name="ln2300">      break;</a>
<a name="ln2301"> </a>
<a name="ln2302">    case 0x10:</a>
<a name="ln2303">      exc-&gt;phase = exc-&gt;period / 4;</a>
<a name="ln2304">      break;</a>
<a name="ln2305"> </a>
<a name="ln2306">    case 0x20:</a>
<a name="ln2307">      exc-&gt;phase = exc-&gt;period / 2;</a>
<a name="ln2308">      break;</a>
<a name="ln2309"> </a>
<a name="ln2310">    case 0x30:</a>
<a name="ln2311">      exc-&gt;phase = exc-&gt;period * 3 / 4;</a>
<a name="ln2312">      break;</a>
<a name="ln2313">    }</a>
<a name="ln2314"> </a>
<a name="ln2315">    if ( ( selector &amp; 0x0F ) == 0 )</a>
<a name="ln2316">      exc-&gt;threshold = exc-&gt;period - 1;</a>
<a name="ln2317">    else</a>
<a name="ln2318">      exc-&gt;threshold = ( (FT_Int)( selector &amp; 0x0F ) - 4 ) * exc-&gt;period / 8;</a>
<a name="ln2319"> </a>
<a name="ln2320">    /* convert to F26Dot6 format */</a>
<a name="ln2321">    exc-&gt;period    &gt;&gt;= 8;</a>
<a name="ln2322">    exc-&gt;phase     &gt;&gt;= 8;</a>
<a name="ln2323">    exc-&gt;threshold &gt;&gt;= 8;</a>
<a name="ln2324">  }</a>
<a name="ln2325"> </a>
<a name="ln2326"> </a>
<a name="ln2327">  /*************************************************************************/</a>
<a name="ln2328">  /*                                                                       */</a>
<a name="ln2329">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2330">  /*    Project                                                            */</a>
<a name="ln2331">  /*                                                                       */</a>
<a name="ln2332">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2333">  /*    Computes the projection of vector given by (v2-v1) along the       */</a>
<a name="ln2334">  /*    current projection vector.                                         */</a>
<a name="ln2335">  /*                                                                       */</a>
<a name="ln2336">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2337">  /*    v1 :: First input vector.                                          */</a>
<a name="ln2338">  /*    v2 :: Second input vector.                                         */</a>
<a name="ln2339">  /*                                                                       */</a>
<a name="ln2340">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2341">  /*    The distance in F26dot6 format.                                    */</a>
<a name="ln2342">  /*                                                                       */</a>
<a name="ln2343">  static FT_F26Dot6</a>
<a name="ln2344">  Project( TT_ExecContext  exc,</a>
<a name="ln2345">           FT_Pos          dx,</a>
<a name="ln2346">           FT_Pos          dy )</a>
<a name="ln2347">  {</a>
<a name="ln2348">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln2349">    FT_ASSERT( !exc-&gt;face-&gt;unpatented_hinting );</a>
<a name="ln2350">#endif</a>
<a name="ln2351"> </a>
<a name="ln2352">    return TT_DotFix14( dx, dy,</a>
<a name="ln2353">                        exc-&gt;GS.projVector.x,</a>
<a name="ln2354">                        exc-&gt;GS.projVector.y );</a>
<a name="ln2355">  }</a>
<a name="ln2356"> </a>
<a name="ln2357"> </a>
<a name="ln2358">  /*************************************************************************/</a>
<a name="ln2359">  /*                                                                       */</a>
<a name="ln2360">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2361">  /*    Dual_Project                                                       */</a>
<a name="ln2362">  /*                                                                       */</a>
<a name="ln2363">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2364">  /*    Computes the projection of the vector given by (v2-v1) along the   */</a>
<a name="ln2365">  /*    current dual vector.                                               */</a>
<a name="ln2366">  /*                                                                       */</a>
<a name="ln2367">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2368">  /*    v1 :: First input vector.                                          */</a>
<a name="ln2369">  /*    v2 :: Second input vector.                                         */</a>
<a name="ln2370">  /*                                                                       */</a>
<a name="ln2371">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2372">  /*    The distance in F26dot6 format.                                    */</a>
<a name="ln2373">  /*                                                                       */</a>
<a name="ln2374">  static FT_F26Dot6</a>
<a name="ln2375">  Dual_Project( TT_ExecContext  exc,</a>
<a name="ln2376">                FT_Pos          dx,</a>
<a name="ln2377">                FT_Pos          dy )</a>
<a name="ln2378">  {</a>
<a name="ln2379">    return TT_DotFix14( dx, dy,</a>
<a name="ln2380">                        exc-&gt;GS.dualVector.x,</a>
<a name="ln2381">                        exc-&gt;GS.dualVector.y );</a>
<a name="ln2382">  }</a>
<a name="ln2383"> </a>
<a name="ln2384"> </a>
<a name="ln2385">  /*************************************************************************/</a>
<a name="ln2386">  /*                                                                       */</a>
<a name="ln2387">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2388">  /*    Project_x                                                          */</a>
<a name="ln2389">  /*                                                                       */</a>
<a name="ln2390">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2391">  /*    Computes the projection of the vector given by (v2-v1) along the   */</a>
<a name="ln2392">  /*    horizontal axis.                                                   */</a>
<a name="ln2393">  /*                                                                       */</a>
<a name="ln2394">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2395">  /*    v1 :: First input vector.                                          */</a>
<a name="ln2396">  /*    v2 :: Second input vector.                                         */</a>
<a name="ln2397">  /*                                                                       */</a>
<a name="ln2398">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2399">  /*    The distance in F26dot6 format.                                    */</a>
<a name="ln2400">  /*                                                                       */</a>
<a name="ln2401">  static FT_F26Dot6</a>
<a name="ln2402">  Project_x( TT_ExecContext  exc,</a>
<a name="ln2403">             FT_Pos          dx,</a>
<a name="ln2404">             FT_Pos          dy )</a>
<a name="ln2405">  {</a>
<a name="ln2406">    FT_UNUSED( exc );</a>
<a name="ln2407">    FT_UNUSED( dy );</a>
<a name="ln2408"> </a>
<a name="ln2409">    return dx;</a>
<a name="ln2410">  }</a>
<a name="ln2411"> </a>
<a name="ln2412"> </a>
<a name="ln2413">  /*************************************************************************/</a>
<a name="ln2414">  /*                                                                       */</a>
<a name="ln2415">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2416">  /*    Project_y                                                          */</a>
<a name="ln2417">  /*                                                                       */</a>
<a name="ln2418">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2419">  /*    Computes the projection of the vector given by (v2-v1) along the   */</a>
<a name="ln2420">  /*    vertical axis.                                                     */</a>
<a name="ln2421">  /*                                                                       */</a>
<a name="ln2422">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2423">  /*    v1 :: First input vector.                                          */</a>
<a name="ln2424">  /*    v2 :: Second input vector.                                         */</a>
<a name="ln2425">  /*                                                                       */</a>
<a name="ln2426">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2427">  /*    The distance in F26dot6 format.                                    */</a>
<a name="ln2428">  /*                                                                       */</a>
<a name="ln2429">  static FT_F26Dot6</a>
<a name="ln2430">  Project_y( TT_ExecContext  exc,</a>
<a name="ln2431">             FT_Pos          dx,</a>
<a name="ln2432">             FT_Pos          dy )</a>
<a name="ln2433">  {</a>
<a name="ln2434">    FT_UNUSED( exc );</a>
<a name="ln2435">    FT_UNUSED( dx );</a>
<a name="ln2436"> </a>
<a name="ln2437">    return dy;</a>
<a name="ln2438">  }</a>
<a name="ln2439"> </a>
<a name="ln2440"> </a>
<a name="ln2441">  /*************************************************************************/</a>
<a name="ln2442">  /*                                                                       */</a>
<a name="ln2443">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2444">  /*    Compute_Funcs                                                      */</a>
<a name="ln2445">  /*                                                                       */</a>
<a name="ln2446">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2447">  /*    Computes the projection and movement function pointers according   */</a>
<a name="ln2448">  /*    to the current graphics state.                                     */</a>
<a name="ln2449">  /*                                                                       */</a>
<a name="ln2450">  static void</a>
<a name="ln2451">  Compute_Funcs( TT_ExecContext  exc )</a>
<a name="ln2452">  {</a>
<a name="ln2453">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln2454">    if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln2455">    {</a>
<a name="ln2456">      /* If both vectors point rightwards along the x axis, set          */</a>
<a name="ln2457">      /* `both-x-axis' true, otherwise set it false.  The x values only  */</a>
<a name="ln2458">      /* need be tested because the vector has been normalised to a unit */</a>
<a name="ln2459">      /* vector of length 0x4000 = unity.                                */</a>
<a name="ln2460">      exc-&gt;GS.both_x_axis = (FT_Bool)( exc-&gt;GS.projVector.x == 0x4000 &amp;&amp;</a>
<a name="ln2461">                                       exc-&gt;GS.freeVector.x == 0x4000 );</a>
<a name="ln2462"> </a>
<a name="ln2463">      /* Throw away projection and freedom vector information */</a>
<a name="ln2464">      /* because the patents don't allow them to be stored.   */</a>
<a name="ln2465">      /* The relevant US Patents are 5155805 and 5325479.     */</a>
<a name="ln2466">      exc-&gt;GS.projVector.x = 0;</a>
<a name="ln2467">      exc-&gt;GS.projVector.y = 0;</a>
<a name="ln2468">      exc-&gt;GS.freeVector.x = 0;</a>
<a name="ln2469">      exc-&gt;GS.freeVector.y = 0;</a>
<a name="ln2470"> </a>
<a name="ln2471">      if ( exc-&gt;GS.both_x_axis )</a>
<a name="ln2472">      {</a>
<a name="ln2473">        exc-&gt;func_project   = Project_x;</a>
<a name="ln2474">        exc-&gt;func_move      = Direct_Move_X;</a>
<a name="ln2475">        exc-&gt;func_move_orig = Direct_Move_Orig_X;</a>
<a name="ln2476">      }</a>
<a name="ln2477">      else</a>
<a name="ln2478">      {</a>
<a name="ln2479">        exc-&gt;func_project   = Project_y;</a>
<a name="ln2480">        exc-&gt;func_move      = Direct_Move_Y;</a>
<a name="ln2481">        exc-&gt;func_move_orig = Direct_Move_Orig_Y;</a>
<a name="ln2482">      }</a>
<a name="ln2483"> </a>
<a name="ln2484">      if ( exc-&gt;GS.dualVector.x == 0x4000 )</a>
<a name="ln2485">        exc-&gt;func_dualproj = Project_x;</a>
<a name="ln2486">      else if ( exc-&gt;GS.dualVector.y == 0x4000 )</a>
<a name="ln2487">        exc-&gt;func_dualproj = Project_y;</a>
<a name="ln2488">      else</a>
<a name="ln2489">        exc-&gt;func_dualproj = Dual_Project;</a>
<a name="ln2490"> </a>
<a name="ln2491">      /* Force recalculation of cached aspect ratio */</a>
<a name="ln2492">      exc-&gt;tt_metrics.ratio = 0;</a>
<a name="ln2493"> </a>
<a name="ln2494">      return;</a>
<a name="ln2495">    }</a>
<a name="ln2496">#endif /* TT_CONFIG_OPTION_UNPATENTED_HINTING */</a>
<a name="ln2497"> </a>
<a name="ln2498">    if ( exc-&gt;GS.freeVector.x == 0x4000 )</a>
<a name="ln2499">      exc-&gt;F_dot_P = exc-&gt;GS.projVector.x;</a>
<a name="ln2500">    else if ( exc-&gt;GS.freeVector.y == 0x4000 )</a>
<a name="ln2501">      exc-&gt;F_dot_P = exc-&gt;GS.projVector.y;</a>
<a name="ln2502">    else</a>
<a name="ln2503">      exc-&gt;F_dot_P =</a>
<a name="ln2504">        ( (FT_Long)exc-&gt;GS.projVector.x * exc-&gt;GS.freeVector.x +</a>
<a name="ln2505">          (FT_Long)exc-&gt;GS.projVector.y * exc-&gt;GS.freeVector.y ) &gt;&gt; 14;</a>
<a name="ln2506"> </a>
<a name="ln2507">    if ( exc-&gt;GS.projVector.x == 0x4000 )</a>
<a name="ln2508">      exc-&gt;func_project = (TT_Project_Func)Project_x;</a>
<a name="ln2509">    else if ( exc-&gt;GS.projVector.y == 0x4000 )</a>
<a name="ln2510">      exc-&gt;func_project = (TT_Project_Func)Project_y;</a>
<a name="ln2511">    else</a>
<a name="ln2512">      exc-&gt;func_project = (TT_Project_Func)Project;</a>
<a name="ln2513"> </a>
<a name="ln2514">    if ( exc-&gt;GS.dualVector.x == 0x4000 )</a>
<a name="ln2515">      exc-&gt;func_dualproj = (TT_Project_Func)Project_x;</a>
<a name="ln2516">    else if ( exc-&gt;GS.dualVector.y == 0x4000 )</a>
<a name="ln2517">      exc-&gt;func_dualproj = (TT_Project_Func)Project_y;</a>
<a name="ln2518">    else</a>
<a name="ln2519">      exc-&gt;func_dualproj = (TT_Project_Func)Dual_Project;</a>
<a name="ln2520"> </a>
<a name="ln2521">    exc-&gt;func_move      = (TT_Move_Func)Direct_Move;</a>
<a name="ln2522">    exc-&gt;func_move_orig = (TT_Move_Func)Direct_Move_Orig;</a>
<a name="ln2523"> </a>
<a name="ln2524">    if ( exc-&gt;F_dot_P == 0x4000L )</a>
<a name="ln2525">    {</a>
<a name="ln2526">      if ( exc-&gt;GS.freeVector.x == 0x4000 )</a>
<a name="ln2527">      {</a>
<a name="ln2528">        exc-&gt;func_move      = (TT_Move_Func)Direct_Move_X;</a>
<a name="ln2529">        exc-&gt;func_move_orig = (TT_Move_Func)Direct_Move_Orig_X;</a>
<a name="ln2530">      }</a>
<a name="ln2531">      else if ( exc-&gt;GS.freeVector.y == 0x4000 )</a>
<a name="ln2532">      {</a>
<a name="ln2533">        exc-&gt;func_move      = (TT_Move_Func)Direct_Move_Y;</a>
<a name="ln2534">        exc-&gt;func_move_orig = (TT_Move_Func)Direct_Move_Orig_Y;</a>
<a name="ln2535">      }</a>
<a name="ln2536">    }</a>
<a name="ln2537"> </a>
<a name="ln2538">    /* at small sizes, F_dot_P can become too small, resulting   */</a>
<a name="ln2539">    /* in overflows and `spikes' in a number of glyphs like `w'. */</a>
<a name="ln2540"> </a>
<a name="ln2541">    if ( FT_ABS( exc-&gt;F_dot_P ) &lt; 0x400L )</a>
<a name="ln2542">      exc-&gt;F_dot_P = 0x4000L;</a>
<a name="ln2543"> </a>
<a name="ln2544">    /* Disable cached aspect ratio */</a>
<a name="ln2545">    exc-&gt;tt_metrics.ratio = 0;</a>
<a name="ln2546">  }</a>
<a name="ln2547"> </a>
<a name="ln2548"> </a>
<a name="ln2549">  /*************************************************************************/</a>
<a name="ln2550">  /*                                                                       */</a>
<a name="ln2551">  /* &lt;Function&gt;                                                            */</a>
<a name="ln2552">  /*    Normalize                                                          */</a>
<a name="ln2553">  /*                                                                       */</a>
<a name="ln2554">  /* &lt;Description&gt;                                                         */</a>
<a name="ln2555">  /*    Norms a vector.                                                    */</a>
<a name="ln2556">  /*                                                                       */</a>
<a name="ln2557">  /* &lt;Input&gt;                                                               */</a>
<a name="ln2558">  /*    Vx :: The horizontal input vector coordinate.                      */</a>
<a name="ln2559">  /*    Vy :: The vertical input vector coordinate.                        */</a>
<a name="ln2560">  /*                                                                       */</a>
<a name="ln2561">  /* &lt;Output&gt;                                                              */</a>
<a name="ln2562">  /*    R  :: The normed unit vector.                                      */</a>
<a name="ln2563">  /*                                                                       */</a>
<a name="ln2564">  /* &lt;Return&gt;                                                              */</a>
<a name="ln2565">  /*    Returns FAILURE if a vector parameter is zero.                     */</a>
<a name="ln2566">  /*                                                                       */</a>
<a name="ln2567">  /* &lt;Note&gt;                                                                */</a>
<a name="ln2568">  /*    In case Vx and Vy are both zero, `Normalize' returns SUCCESS, and  */</a>
<a name="ln2569">  /*    R is undefined.                                                    */</a>
<a name="ln2570">  /*                                                                       */</a>
<a name="ln2571">  static FT_Bool</a>
<a name="ln2572">  Normalize( FT_F26Dot6      Vx,</a>
<a name="ln2573">             FT_F26Dot6      Vy,</a>
<a name="ln2574">             FT_UnitVector*  R )</a>
<a name="ln2575">  {</a>
<a name="ln2576">    FT_Vector V;</a>
<a name="ln2577"> </a>
<a name="ln2578"> </a>
<a name="ln2579">    if ( Vx == 0 &amp;&amp; Vy == 0 )</a>
<a name="ln2580">    {</a>
<a name="ln2581">      /* XXX: UNDOCUMENTED! It seems that it is possible to try   */</a>
<a name="ln2582">      /*      to normalize the vector (0,0).  Return immediately. */</a>
<a name="ln2583">      return SUCCESS;</a>
<a name="ln2584">    }</a>
<a name="ln2585"> </a>
<a name="ln2586">    V.x = Vx;</a>
<a name="ln2587">    V.y = Vy;</a>
<a name="ln2588"> </a>
<a name="ln2589">    FT_Vector_NormLen( &amp;V );</a>
<a name="ln2590"> </a>
<a name="ln2591">    R-&gt;x = (FT_F2Dot14)( V.x / 4 );</a>
<a name="ln2592">    R-&gt;y = (FT_F2Dot14)( V.y / 4 );</a>
<a name="ln2593"> </a>
<a name="ln2594">    return SUCCESS;</a>
<a name="ln2595">  }</a>
<a name="ln2596"> </a>
<a name="ln2597"> </a>
<a name="ln2598">  /*************************************************************************/</a>
<a name="ln2599">  /*                                                                       */</a>
<a name="ln2600">  /* Here we start with the implementation of the various opcodes.         */</a>
<a name="ln2601">  /*                                                                       */</a>
<a name="ln2602">  /*************************************************************************/</a>
<a name="ln2603"> </a>
<a name="ln2604"> </a>
<a name="ln2605">#define ARRAY_BOUND_ERROR                         \</a>
<a name="ln2606">    do                                            \</a>
<a name="ln2607">    {                                             \</a>
<a name="ln2608">      exc-&gt;error = FT_THROW( Invalid_Reference ); \</a>
<a name="ln2609">      return;                                     \</a>
<a name="ln2610">    } while (0)</a>
<a name="ln2611"> </a>
<a name="ln2612"> </a>
<a name="ln2613">  /*************************************************************************/</a>
<a name="ln2614">  /*                                                                       */</a>
<a name="ln2615">  /* MPPEM[]:      Measure Pixel Per EM                                    */</a>
<a name="ln2616">  /* Opcode range: 0x4B                                                    */</a>
<a name="ln2617">  /* Stack:        --&gt; Euint16                                             */</a>
<a name="ln2618">  /*                                                                       */</a>
<a name="ln2619">  static void</a>
<a name="ln2620">  Ins_MPPEM( TT_ExecContext  exc,</a>
<a name="ln2621">             FT_Long*        args )</a>
<a name="ln2622">  {</a>
<a name="ln2623">    args[0] = exc-&gt;func_cur_ppem( exc );</a>
<a name="ln2624">  }</a>
<a name="ln2625"> </a>
<a name="ln2626"> </a>
<a name="ln2627">  /*************************************************************************/</a>
<a name="ln2628">  /*                                                                       */</a>
<a name="ln2629">  /* MPS[]:        Measure Point Size                                      */</a>
<a name="ln2630">  /* Opcode range: 0x4C                                                    */</a>
<a name="ln2631">  /* Stack:        --&gt; Euint16                                             */</a>
<a name="ln2632">  /*                                                                       */</a>
<a name="ln2633">  static void</a>
<a name="ln2634">  Ins_MPS( TT_ExecContext  exc,</a>
<a name="ln2635">           FT_Long*        args )</a>
<a name="ln2636">  {</a>
<a name="ln2637">    /* Note: The point size should be irrelevant in a given font program; */</a>
<a name="ln2638">    /*       we thus decide to return only the PPEM value.                */</a>
<a name="ln2639">#if 0</a>
<a name="ln2640">    args[0] = exc-&gt;metrics.pointSize;</a>
<a name="ln2641">#else</a>
<a name="ln2642">    args[0] = exc-&gt;func_cur_ppem( exc );</a>
<a name="ln2643">#endif</a>
<a name="ln2644">  }</a>
<a name="ln2645"> </a>
<a name="ln2646"> </a>
<a name="ln2647">  /*************************************************************************/</a>
<a name="ln2648">  /*                                                                       */</a>
<a name="ln2649">  /* DUP[]:        DUPlicate the stack's top element                       */</a>
<a name="ln2650">  /* Opcode range: 0x20                                                    */</a>
<a name="ln2651">  /* Stack:        StkElt --&gt; StkElt StkElt                                */</a>
<a name="ln2652">  /*                                                                       */</a>
<a name="ln2653">  static void</a>
<a name="ln2654">  Ins_DUP( FT_Long*  args )</a>
<a name="ln2655">  {</a>
<a name="ln2656">    args[1] = args[0];</a>
<a name="ln2657">  }</a>
<a name="ln2658"> </a>
<a name="ln2659"> </a>
<a name="ln2660">  /*************************************************************************/</a>
<a name="ln2661">  /*                                                                       */</a>
<a name="ln2662">  /* POP[]:        POP the stack's top element                             */</a>
<a name="ln2663">  /* Opcode range: 0x21                                                    */</a>
<a name="ln2664">  /* Stack:        StkElt --&gt;                                              */</a>
<a name="ln2665">  /*                                                                       */</a>
<a name="ln2666">  static void</a>
<a name="ln2667">  Ins_POP( void )</a>
<a name="ln2668">  {</a>
<a name="ln2669">    /* nothing to do */</a>
<a name="ln2670">  }</a>
<a name="ln2671"> </a>
<a name="ln2672"> </a>
<a name="ln2673">  /*************************************************************************/</a>
<a name="ln2674">  /*                                                                       */</a>
<a name="ln2675">  /* CLEAR[]:      CLEAR the entire stack                                  */</a>
<a name="ln2676">  /* Opcode range: 0x22                                                    */</a>
<a name="ln2677">  /* Stack:        StkElt... --&gt;                                           */</a>
<a name="ln2678">  /*                                                                       */</a>
<a name="ln2679">  static void</a>
<a name="ln2680">  Ins_CLEAR( TT_ExecContext  exc )</a>
<a name="ln2681">  {</a>
<a name="ln2682">    exc-&gt;new_top = 0;</a>
<a name="ln2683">  }</a>
<a name="ln2684"> </a>
<a name="ln2685"> </a>
<a name="ln2686">  /*************************************************************************/</a>
<a name="ln2687">  /*                                                                       */</a>
<a name="ln2688">  /* SWAP[]:       SWAP the stack's top two elements                       */</a>
<a name="ln2689">  /* Opcode range: 0x23                                                    */</a>
<a name="ln2690">  /* Stack:        2 * StkElt --&gt; 2 * StkElt                               */</a>
<a name="ln2691">  /*                                                                       */</a>
<a name="ln2692">  static void</a>
<a name="ln2693">  Ins_SWAP( FT_Long*  args )</a>
<a name="ln2694">  {</a>
<a name="ln2695">    FT_Long  L;</a>
<a name="ln2696"> </a>
<a name="ln2697"> </a>
<a name="ln2698">    L       = args[0];</a>
<a name="ln2699">    args[0] = args[1];</a>
<a name="ln2700">    args[1] = L;</a>
<a name="ln2701">  }</a>
<a name="ln2702"> </a>
<a name="ln2703"> </a>
<a name="ln2704">  /*************************************************************************/</a>
<a name="ln2705">  /*                                                                       */</a>
<a name="ln2706">  /* DEPTH[]:      return the stack DEPTH                                  */</a>
<a name="ln2707">  /* Opcode range: 0x24                                                    */</a>
<a name="ln2708">  /* Stack:        --&gt; uint32                                              */</a>
<a name="ln2709">  /*                                                                       */</a>
<a name="ln2710">  static void</a>
<a name="ln2711">  Ins_DEPTH( TT_ExecContext  exc,</a>
<a name="ln2712">             FT_Long*        args )</a>
<a name="ln2713">  {</a>
<a name="ln2714">    args[0] = exc-&gt;top;</a>
<a name="ln2715">  }</a>
<a name="ln2716"> </a>
<a name="ln2717"> </a>
<a name="ln2718">  /*************************************************************************/</a>
<a name="ln2719">  /*                                                                       */</a>
<a name="ln2720">  /* LT[]:         Less Than                                               */</a>
<a name="ln2721">  /* Opcode range: 0x50                                                    */</a>
<a name="ln2722">  /* Stack:        int32? int32? --&gt; bool                                  */</a>
<a name="ln2723">  /*                                                                       */</a>
<a name="ln2724">  static void</a>
<a name="ln2725">  Ins_LT( FT_Long*  args )</a>
<a name="ln2726">  {</a>
<a name="ln2727">    args[0] = ( args[0] &lt; args[1] );</a>
<a name="ln2728">  }</a>
<a name="ln2729"> </a>
<a name="ln2730"> </a>
<a name="ln2731">  /*************************************************************************/</a>
<a name="ln2732">  /*                                                                       */</a>
<a name="ln2733">  /* LTEQ[]:       Less Than or EQual                                      */</a>
<a name="ln2734">  /* Opcode range: 0x51                                                    */</a>
<a name="ln2735">  /* Stack:        int32? int32? --&gt; bool                                  */</a>
<a name="ln2736">  /*                                                                       */</a>
<a name="ln2737">  static void</a>
<a name="ln2738">  Ins_LTEQ( FT_Long*  args )</a>
<a name="ln2739">  {</a>
<a name="ln2740">    args[0] = ( args[0] &lt;= args[1] );</a>
<a name="ln2741">  }</a>
<a name="ln2742"> </a>
<a name="ln2743"> </a>
<a name="ln2744">  /*************************************************************************/</a>
<a name="ln2745">  /*                                                                       */</a>
<a name="ln2746">  /* GT[]:         Greater Than                                            */</a>
<a name="ln2747">  /* Opcode range: 0x52                                                    */</a>
<a name="ln2748">  /* Stack:        int32? int32? --&gt; bool                                  */</a>
<a name="ln2749">  /*                                                                       */</a>
<a name="ln2750">  static void</a>
<a name="ln2751">  Ins_GT( FT_Long*  args )</a>
<a name="ln2752">  {</a>
<a name="ln2753">    args[0] = ( args[0] &gt; args[1] );</a>
<a name="ln2754">  }</a>
<a name="ln2755"> </a>
<a name="ln2756"> </a>
<a name="ln2757">  /*************************************************************************/</a>
<a name="ln2758">  /*                                                                       */</a>
<a name="ln2759">  /* GTEQ[]:       Greater Than or EQual                                   */</a>
<a name="ln2760">  /* Opcode range: 0x53                                                    */</a>
<a name="ln2761">  /* Stack:        int32? int32? --&gt; bool                                  */</a>
<a name="ln2762">  /*                                                                       */</a>
<a name="ln2763">  static void</a>
<a name="ln2764">  Ins_GTEQ( FT_Long*  args )</a>
<a name="ln2765">  {</a>
<a name="ln2766">    args[0] = ( args[0] &gt;= args[1] );</a>
<a name="ln2767">  }</a>
<a name="ln2768"> </a>
<a name="ln2769"> </a>
<a name="ln2770">  /*************************************************************************/</a>
<a name="ln2771">  /*                                                                       */</a>
<a name="ln2772">  /* EQ[]:         EQual                                                   */</a>
<a name="ln2773">  /* Opcode range: 0x54                                                    */</a>
<a name="ln2774">  /* Stack:        StkElt StkElt --&gt; bool                                  */</a>
<a name="ln2775">  /*                                                                       */</a>
<a name="ln2776">  static void</a>
<a name="ln2777">  Ins_EQ( FT_Long*  args )</a>
<a name="ln2778">  {</a>
<a name="ln2779">    args[0] = ( args[0] == args[1] );</a>
<a name="ln2780">  }</a>
<a name="ln2781"> </a>
<a name="ln2782"> </a>
<a name="ln2783">  /*************************************************************************/</a>
<a name="ln2784">  /*                                                                       */</a>
<a name="ln2785">  /* NEQ[]:        Not EQual                                               */</a>
<a name="ln2786">  /* Opcode range: 0x55                                                    */</a>
<a name="ln2787">  /* Stack:        StkElt StkElt --&gt; bool                                  */</a>
<a name="ln2788">  /*                                                                       */</a>
<a name="ln2789">  static void</a>
<a name="ln2790">  Ins_NEQ( FT_Long*  args )</a>
<a name="ln2791">  {</a>
<a name="ln2792">    args[0] = ( args[0] != args[1] );</a>
<a name="ln2793">  }</a>
<a name="ln2794"> </a>
<a name="ln2795"> </a>
<a name="ln2796">  /*************************************************************************/</a>
<a name="ln2797">  /*                                                                       */</a>
<a name="ln2798">  /* ODD[]:        Is ODD                                                  */</a>
<a name="ln2799">  /* Opcode range: 0x56                                                    */</a>
<a name="ln2800">  /* Stack:        f26.6 --&gt; bool                                          */</a>
<a name="ln2801">  /*                                                                       */</a>
<a name="ln2802">  static void</a>
<a name="ln2803">  Ins_ODD( TT_ExecContext  exc,</a>
<a name="ln2804">           FT_Long*        args )</a>
<a name="ln2805">  {</a>
<a name="ln2806">    args[0] = ( ( exc-&gt;func_round( exc, args[0], 0 ) &amp; 127 ) == 64 );</a>
<a name="ln2807">  }</a>
<a name="ln2808"> </a>
<a name="ln2809"> </a>
<a name="ln2810">  /*************************************************************************/</a>
<a name="ln2811">  /*                                                                       */</a>
<a name="ln2812">  /* EVEN[]:       Is EVEN                                                 */</a>
<a name="ln2813">  /* Opcode range: 0x57                                                    */</a>
<a name="ln2814">  /* Stack:        f26.6 --&gt; bool                                          */</a>
<a name="ln2815">  /*                                                                       */</a>
<a name="ln2816">  static void</a>
<a name="ln2817">  Ins_EVEN( TT_ExecContext  exc,</a>
<a name="ln2818">            FT_Long*        args )</a>
<a name="ln2819">  {</a>
<a name="ln2820">    args[0] = ( ( exc-&gt;func_round( exc, args[0], 0 ) &amp; 127 ) == 0 );</a>
<a name="ln2821">  }</a>
<a name="ln2822"> </a>
<a name="ln2823"> </a>
<a name="ln2824">  /*************************************************************************/</a>
<a name="ln2825">  /*                                                                       */</a>
<a name="ln2826">  /* AND[]:        logical AND                                             */</a>
<a name="ln2827">  /* Opcode range: 0x5A                                                    */</a>
<a name="ln2828">  /* Stack:        uint32 uint32 --&gt; uint32                                */</a>
<a name="ln2829">  /*                                                                       */</a>
<a name="ln2830">  static void</a>
<a name="ln2831">  Ins_AND( FT_Long*  args )</a>
<a name="ln2832">  {</a>
<a name="ln2833">    args[0] = ( args[0] &amp;&amp; args[1] );</a>
<a name="ln2834">  }</a>
<a name="ln2835"> </a>
<a name="ln2836"> </a>
<a name="ln2837">  /*************************************************************************/</a>
<a name="ln2838">  /*                                                                       */</a>
<a name="ln2839">  /* OR[]:         logical OR                                              */</a>
<a name="ln2840">  /* Opcode range: 0x5B                                                    */</a>
<a name="ln2841">  /* Stack:        uint32 uint32 --&gt; uint32                                */</a>
<a name="ln2842">  /*                                                                       */</a>
<a name="ln2843">  static void</a>
<a name="ln2844">  Ins_OR( FT_Long*  args )</a>
<a name="ln2845">  {</a>
<a name="ln2846">    args[0] = ( args[0] || args[1] );</a>
<a name="ln2847">  }</a>
<a name="ln2848"> </a>
<a name="ln2849"> </a>
<a name="ln2850">  /*************************************************************************/</a>
<a name="ln2851">  /*                                                                       */</a>
<a name="ln2852">  /* NOT[]:        logical NOT                                             */</a>
<a name="ln2853">  /* Opcode range: 0x5C                                                    */</a>
<a name="ln2854">  /* Stack:        StkElt --&gt; uint32                                       */</a>
<a name="ln2855">  /*                                                                       */</a>
<a name="ln2856">  static void</a>
<a name="ln2857">  Ins_NOT( FT_Long*  args )</a>
<a name="ln2858">  {</a>
<a name="ln2859">    args[0] = !args[0];</a>
<a name="ln2860">  }</a>
<a name="ln2861"> </a>
<a name="ln2862"> </a>
<a name="ln2863">  /*************************************************************************/</a>
<a name="ln2864">  /*                                                                       */</a>
<a name="ln2865">  /* ADD[]:        ADD                                                     */</a>
<a name="ln2866">  /* Opcode range: 0x60                                                    */</a>
<a name="ln2867">  /* Stack:        f26.6 f26.6 --&gt; f26.6                                   */</a>
<a name="ln2868">  /*                                                                       */</a>
<a name="ln2869">  static void</a>
<a name="ln2870">  Ins_ADD( FT_Long*  args )</a>
<a name="ln2871">  {</a>
<a name="ln2872">    args[0] += args[1];</a>
<a name="ln2873">  }</a>
<a name="ln2874"> </a>
<a name="ln2875"> </a>
<a name="ln2876">  /*************************************************************************/</a>
<a name="ln2877">  /*                                                                       */</a>
<a name="ln2878">  /* SUB[]:        SUBtract                                                */</a>
<a name="ln2879">  /* Opcode range: 0x61                                                    */</a>
<a name="ln2880">  /* Stack:        f26.6 f26.6 --&gt; f26.6                                   */</a>
<a name="ln2881">  /*                                                                       */</a>
<a name="ln2882">  static void</a>
<a name="ln2883">  Ins_SUB( FT_Long*  args )</a>
<a name="ln2884">  {</a>
<a name="ln2885">    args[0] -= args[1];</a>
<a name="ln2886">  }</a>
<a name="ln2887"> </a>
<a name="ln2888"> </a>
<a name="ln2889">  /*************************************************************************/</a>
<a name="ln2890">  /*                                                                       */</a>
<a name="ln2891">  /* DIV[]:        DIVide                                                  */</a>
<a name="ln2892">  /* Opcode range: 0x62                                                    */</a>
<a name="ln2893">  /* Stack:        f26.6 f26.6 --&gt; f26.6                                   */</a>
<a name="ln2894">  /*                                                                       */</a>
<a name="ln2895">  static void</a>
<a name="ln2896">  Ins_DIV( TT_ExecContext  exc,</a>
<a name="ln2897">           FT_Long*        args )</a>
<a name="ln2898">  {</a>
<a name="ln2899">    if ( args[1] == 0 )</a>
<a name="ln2900">      exc-&gt;error = FT_THROW( Divide_By_Zero );</a>
<a name="ln2901">    else</a>
<a name="ln2902">      args[0] = FT_MulDiv_No_Round( args[0], 64L, args[1] );</a>
<a name="ln2903">  }</a>
<a name="ln2904"> </a>
<a name="ln2905"> </a>
<a name="ln2906">  /*************************************************************************/</a>
<a name="ln2907">  /*                                                                       */</a>
<a name="ln2908">  /* MUL[]:        MULtiply                                                */</a>
<a name="ln2909">  /* Opcode range: 0x63                                                    */</a>
<a name="ln2910">  /* Stack:        f26.6 f26.6 --&gt; f26.6                                   */</a>
<a name="ln2911">  /*                                                                       */</a>
<a name="ln2912">  static void</a>
<a name="ln2913">  Ins_MUL( FT_Long*  args )</a>
<a name="ln2914">  {</a>
<a name="ln2915">    args[0] = FT_MulDiv( args[0], args[1], 64L );</a>
<a name="ln2916">  }</a>
<a name="ln2917"> </a>
<a name="ln2918"> </a>
<a name="ln2919">  /*************************************************************************/</a>
<a name="ln2920">  /*                                                                       */</a>
<a name="ln2921">  /* ABS[]:        ABSolute value                                          */</a>
<a name="ln2922">  /* Opcode range: 0x64                                                    */</a>
<a name="ln2923">  /* Stack:        f26.6 --&gt; f26.6                                         */</a>
<a name="ln2924">  /*                                                                       */</a>
<a name="ln2925">  static void</a>
<a name="ln2926">  Ins_ABS( FT_Long*  args )</a>
<a name="ln2927">  {</a>
<a name="ln2928">    args[0] = FT_ABS( args[0] );</a>
<a name="ln2929">  }</a>
<a name="ln2930"> </a>
<a name="ln2931"> </a>
<a name="ln2932">  /*************************************************************************/</a>
<a name="ln2933">  /*                                                                       */</a>
<a name="ln2934">  /* NEG[]:        NEGate                                                  */</a>
<a name="ln2935">  /* Opcode range: 0x65                                                    */</a>
<a name="ln2936">  /* Stack: f26.6 --&gt; f26.6                                                */</a>
<a name="ln2937">  /*                                                                       */</a>
<a name="ln2938">  static void</a>
<a name="ln2939">  Ins_NEG( FT_Long*  args )</a>
<a name="ln2940">  {</a>
<a name="ln2941">    args[0] = -args[0];</a>
<a name="ln2942">  }</a>
<a name="ln2943"> </a>
<a name="ln2944"> </a>
<a name="ln2945">  /*************************************************************************/</a>
<a name="ln2946">  /*                                                                       */</a>
<a name="ln2947">  /* FLOOR[]:      FLOOR                                                   */</a>
<a name="ln2948">  /* Opcode range: 0x66                                                    */</a>
<a name="ln2949">  /* Stack:        f26.6 --&gt; f26.6                                         */</a>
<a name="ln2950">  /*                                                                       */</a>
<a name="ln2951">  static void</a>
<a name="ln2952">  Ins_FLOOR( FT_Long*  args )</a>
<a name="ln2953">  {</a>
<a name="ln2954">    args[0] = FT_PIX_FLOOR( args[0] );</a>
<a name="ln2955">  }</a>
<a name="ln2956"> </a>
<a name="ln2957"> </a>
<a name="ln2958">  /*************************************************************************/</a>
<a name="ln2959">  /*                                                                       */</a>
<a name="ln2960">  /* CEILING[]:    CEILING                                                 */</a>
<a name="ln2961">  /* Opcode range: 0x67                                                    */</a>
<a name="ln2962">  /* Stack:        f26.6 --&gt; f26.6                                         */</a>
<a name="ln2963">  /*                                                                       */</a>
<a name="ln2964">  static void</a>
<a name="ln2965">  Ins_CEILING( FT_Long*  args )</a>
<a name="ln2966">  {</a>
<a name="ln2967">    args[0] = FT_PIX_CEIL( args[0] );</a>
<a name="ln2968">  }</a>
<a name="ln2969"> </a>
<a name="ln2970"> </a>
<a name="ln2971">  /*************************************************************************/</a>
<a name="ln2972">  /*                                                                       */</a>
<a name="ln2973">  /* RS[]:         Read Store                                              */</a>
<a name="ln2974">  /* Opcode range: 0x43                                                    */</a>
<a name="ln2975">  /* Stack:        uint32 --&gt; uint32                                       */</a>
<a name="ln2976">  /*                                                                       */</a>
<a name="ln2977">  static void</a>
<a name="ln2978">  Ins_RS( TT_ExecContext  exc,</a>
<a name="ln2979">          FT_Long*        args )</a>
<a name="ln2980">  {</a>
<a name="ln2981">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln2982"> </a>
<a name="ln2983">    FT_ULong  I = (FT_ULong)args[0];</a>
<a name="ln2984"> </a>
<a name="ln2985"> </a>
<a name="ln2986">    if ( BOUNDSL( I, exc-&gt;storeSize ) )</a>
<a name="ln2987">    {</a>
<a name="ln2988">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln2989">        ARRAY_BOUND_ERROR;</a>
<a name="ln2990">      else</a>
<a name="ln2991">        args[0] = 0;</a>
<a name="ln2992">    }</a>
<a name="ln2993">    else</a>
<a name="ln2994">    {</a>
<a name="ln2995">      /* subpixel hinting - avoid Typeman Dstroke and */</a>
<a name="ln2996">      /* IStroke and Vacuform rounds                  */</a>
<a name="ln2997">      if ( SUBPIXEL_HINTING                            &amp;&amp;</a>
<a name="ln2998">           exc-&gt;ignore_x_mode                          &amp;&amp;</a>
<a name="ln2999">           ( ( I == 24                             &amp;&amp;</a>
<a name="ln3000">               ( exc-&gt;face-&gt;sph_found_func_flags &amp;</a>
<a name="ln3001">                 ( SPH_FDEF_SPACING_1 |</a>
<a name="ln3002">                   SPH_FDEF_SPACING_2 )          ) ) ||</a>
<a name="ln3003">             ( I == 22                      &amp;&amp;</a>
<a name="ln3004">               ( exc-&gt;sph_in_func_flags   &amp;</a>
<a name="ln3005">                 SPH_FDEF_TYPEMAN_STROKES ) )        ||</a>
<a name="ln3006">             ( I == 8                              &amp;&amp;</a>
<a name="ln3007">               ( exc-&gt;face-&gt;sph_found_func_flags &amp;</a>
<a name="ln3008">                 SPH_FDEF_VACUFORM_ROUND_1       ) &amp;&amp;</a>
<a name="ln3009">               exc-&gt;iup_called                     ) ) )</a>
<a name="ln3010">        args[0] = 0;</a>
<a name="ln3011">      else</a>
<a name="ln3012">        args[0] = exc-&gt;storage[I];</a>
<a name="ln3013">    }</a>
<a name="ln3014"> </a>
<a name="ln3015">#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln3016"> </a>
<a name="ln3017">    FT_ULong  I = (FT_ULong)args[0];</a>
<a name="ln3018"> </a>
<a name="ln3019"> </a>
<a name="ln3020">    if ( BOUNDSL( I, exc-&gt;storeSize ) )</a>
<a name="ln3021">    {</a>
<a name="ln3022">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln3023">        ARRAY_BOUND_ERROR;</a>
<a name="ln3024">      else</a>
<a name="ln3025">        args[0] = 0;</a>
<a name="ln3026">    }</a>
<a name="ln3027">    else</a>
<a name="ln3028">      args[0] = exc-&gt;storage[I];</a>
<a name="ln3029"> </a>
<a name="ln3030">#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln3031">  }</a>
<a name="ln3032"> </a>
<a name="ln3033"> </a>
<a name="ln3034">  /*************************************************************************/</a>
<a name="ln3035">  /*                                                                       */</a>
<a name="ln3036">  /* WS[]:         Write Store                                             */</a>
<a name="ln3037">  /* Opcode range: 0x42                                                    */</a>
<a name="ln3038">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln3039">  /*                                                                       */</a>
<a name="ln3040">  static void</a>
<a name="ln3041">  Ins_WS( TT_ExecContext  exc,</a>
<a name="ln3042">          FT_Long*        args )</a>
<a name="ln3043">  {</a>
<a name="ln3044">    FT_ULong  I = (FT_ULong)args[0];</a>
<a name="ln3045"> </a>
<a name="ln3046"> </a>
<a name="ln3047">    if ( BOUNDSL( I, exc-&gt;storeSize ) )</a>
<a name="ln3048">    {</a>
<a name="ln3049">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln3050">        ARRAY_BOUND_ERROR;</a>
<a name="ln3051">    }</a>
<a name="ln3052">    else</a>
<a name="ln3053">      exc-&gt;storage[I] = args[1];</a>
<a name="ln3054">  }</a>
<a name="ln3055"> </a>
<a name="ln3056"> </a>
<a name="ln3057">  /*************************************************************************/</a>
<a name="ln3058">  /*                                                                       */</a>
<a name="ln3059">  /* WCVTP[]:      Write CVT in Pixel units                                */</a>
<a name="ln3060">  /* Opcode range: 0x44                                                    */</a>
<a name="ln3061">  /* Stack:        f26.6 uint32 --&gt;                                        */</a>
<a name="ln3062">  /*                                                                       */</a>
<a name="ln3063">  static void</a>
<a name="ln3064">  Ins_WCVTP( TT_ExecContext  exc,</a>
<a name="ln3065">             FT_Long*        args )</a>
<a name="ln3066">  {</a>
<a name="ln3067">    FT_ULong  I = (FT_ULong)args[0];</a>
<a name="ln3068"> </a>
<a name="ln3069"> </a>
<a name="ln3070">    if ( BOUNDSL( I, exc-&gt;cvtSize ) )</a>
<a name="ln3071">    {</a>
<a name="ln3072">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln3073">        ARRAY_BOUND_ERROR;</a>
<a name="ln3074">    }</a>
<a name="ln3075">    else</a>
<a name="ln3076">      exc-&gt;func_write_cvt( exc, I, args[1] );</a>
<a name="ln3077">  }</a>
<a name="ln3078"> </a>
<a name="ln3079"> </a>
<a name="ln3080">  /*************************************************************************/</a>
<a name="ln3081">  /*                                                                       */</a>
<a name="ln3082">  /* WCVTF[]:      Write CVT in Funits                                     */</a>
<a name="ln3083">  /* Opcode range: 0x70                                                    */</a>
<a name="ln3084">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln3085">  /*                                                                       */</a>
<a name="ln3086">  static void</a>
<a name="ln3087">  Ins_WCVTF( TT_ExecContext  exc,</a>
<a name="ln3088">             FT_Long*        args )</a>
<a name="ln3089">  {</a>
<a name="ln3090">    FT_ULong  I = (FT_ULong)args[0];</a>
<a name="ln3091"> </a>
<a name="ln3092"> </a>
<a name="ln3093">    if ( BOUNDSL( I, exc-&gt;cvtSize ) )</a>
<a name="ln3094">    {</a>
<a name="ln3095">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln3096">        ARRAY_BOUND_ERROR;</a>
<a name="ln3097">    }</a>
<a name="ln3098">    else</a>
<a name="ln3099">      exc-&gt;cvt[I] = FT_MulFix( args[1], exc-&gt;tt_metrics.scale );</a>
<a name="ln3100">  }</a>
<a name="ln3101"> </a>
<a name="ln3102"> </a>
<a name="ln3103">  /*************************************************************************/</a>
<a name="ln3104">  /*                                                                       */</a>
<a name="ln3105">  /* RCVT[]:       Read CVT                                                */</a>
<a name="ln3106">  /* Opcode range: 0x45                                                    */</a>
<a name="ln3107">  /* Stack:        uint32 --&gt; f26.6                                        */</a>
<a name="ln3108">  /*                                                                       */</a>
<a name="ln3109">  static void</a>
<a name="ln3110">  Ins_RCVT( TT_ExecContext  exc,</a>
<a name="ln3111">            FT_Long*        args )</a>
<a name="ln3112">  {</a>
<a name="ln3113">    FT_ULong  I = (FT_ULong)args[0];</a>
<a name="ln3114"> </a>
<a name="ln3115"> </a>
<a name="ln3116">    if ( BOUNDSL( I, exc-&gt;cvtSize ) )</a>
<a name="ln3117">    {</a>
<a name="ln3118">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln3119">        ARRAY_BOUND_ERROR;</a>
<a name="ln3120">      else</a>
<a name="ln3121">        args[0] = 0;</a>
<a name="ln3122">    }</a>
<a name="ln3123">    else</a>
<a name="ln3124">      args[0] = exc-&gt;func_read_cvt( exc, I );</a>
<a name="ln3125">  }</a>
<a name="ln3126"> </a>
<a name="ln3127"> </a>
<a name="ln3128">  /*************************************************************************/</a>
<a name="ln3129">  /*                                                                       */</a>
<a name="ln3130">  /* AA[]:         Adjust Angle                                            */</a>
<a name="ln3131">  /* Opcode range: 0x7F                                                    */</a>
<a name="ln3132">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln3133">  /*                                                                       */</a>
<a name="ln3134">  static void</a>
<a name="ln3135">  Ins_AA( void )</a>
<a name="ln3136">  {</a>
<a name="ln3137">    /* intentionally no longer supported */</a>
<a name="ln3138">  }</a>
<a name="ln3139"> </a>
<a name="ln3140"> </a>
<a name="ln3141">  /*************************************************************************/</a>
<a name="ln3142">  /*                                                                       */</a>
<a name="ln3143">  /* DEBUG[]:      DEBUG.  Unsupported.                                    */</a>
<a name="ln3144">  /* Opcode range: 0x4F                                                    */</a>
<a name="ln3145">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln3146">  /*                                                                       */</a>
<a name="ln3147">  /* Note: The original instruction pops a value from the stack.           */</a>
<a name="ln3148">  /*                                                                       */</a>
<a name="ln3149">  static void</a>
<a name="ln3150">  Ins_DEBUG( TT_ExecContext  exc )</a>
<a name="ln3151">  {</a>
<a name="ln3152">    exc-&gt;error = FT_THROW( Debug_OpCode );</a>
<a name="ln3153">  }</a>
<a name="ln3154"> </a>
<a name="ln3155"> </a>
<a name="ln3156">  /*************************************************************************/</a>
<a name="ln3157">  /*                                                                       */</a>
<a name="ln3158">  /* ROUND[ab]:    ROUND value                                             */</a>
<a name="ln3159">  /* Opcode range: 0x68-0x6B                                               */</a>
<a name="ln3160">  /* Stack:        f26.6 --&gt; f26.6                                         */</a>
<a name="ln3161">  /*                                                                       */</a>
<a name="ln3162">  static void</a>
<a name="ln3163">  Ins_ROUND( TT_ExecContext  exc,</a>
<a name="ln3164">             FT_Long*        args )</a>
<a name="ln3165">  {</a>
<a name="ln3166">    args[0] = exc-&gt;func_round(</a>
<a name="ln3167">                exc,</a>
<a name="ln3168">                args[0],</a>
<a name="ln3169">                exc-&gt;tt_metrics.compensations[exc-&gt;opcode - 0x68] );</a>
<a name="ln3170">  }</a>
<a name="ln3171"> </a>
<a name="ln3172"> </a>
<a name="ln3173">  /*************************************************************************/</a>
<a name="ln3174">  /*                                                                       */</a>
<a name="ln3175">  /* NROUND[ab]:   No ROUNDing of value                                    */</a>
<a name="ln3176">  /* Opcode range: 0x6C-0x6F                                               */</a>
<a name="ln3177">  /* Stack:        f26.6 --&gt; f26.6                                         */</a>
<a name="ln3178">  /*                                                                       */</a>
<a name="ln3179">  static void</a>
<a name="ln3180">  Ins_NROUND( TT_ExecContext  exc,</a>
<a name="ln3181">              FT_Long*        args )</a>
<a name="ln3182">  {</a>
<a name="ln3183">    args[0] = Round_None(</a>
<a name="ln3184">                exc,</a>
<a name="ln3185">                args[0],</a>
<a name="ln3186">                exc-&gt;tt_metrics.compensations[exc-&gt;opcode - 0x6C] );</a>
<a name="ln3187">  }</a>
<a name="ln3188"> </a>
<a name="ln3189"> </a>
<a name="ln3190">  /*************************************************************************/</a>
<a name="ln3191">  /*                                                                       */</a>
<a name="ln3192">  /* MAX[]:        MAXimum                                                 */</a>
<a name="ln3193">  /* Opcode range: 0x68                                                    */</a>
<a name="ln3194">  /* Stack:        int32? int32? --&gt; int32                                 */</a>
<a name="ln3195">  /*                                                                       */</a>
<a name="ln3196">  static void</a>
<a name="ln3197">  Ins_MAX( FT_Long*  args )</a>
<a name="ln3198">  {</a>
<a name="ln3199">    if ( args[1] &gt; args[0] )</a>
<a name="ln3200">      args[0] = args[1];</a>
<a name="ln3201">  }</a>
<a name="ln3202"> </a>
<a name="ln3203"> </a>
<a name="ln3204">  /*************************************************************************/</a>
<a name="ln3205">  /*                                                                       */</a>
<a name="ln3206">  /* MIN[]:        MINimum                                                 */</a>
<a name="ln3207">  /* Opcode range: 0x69                                                    */</a>
<a name="ln3208">  /* Stack:        int32? int32? --&gt; int32                                 */</a>
<a name="ln3209">  /*                                                                       */</a>
<a name="ln3210">  static void</a>
<a name="ln3211">  Ins_MIN( FT_Long*  args )</a>
<a name="ln3212">  {</a>
<a name="ln3213">    if ( args[1] &lt; args[0] )</a>
<a name="ln3214">      args[0] = args[1];</a>
<a name="ln3215">  }</a>
<a name="ln3216"> </a>
<a name="ln3217"> </a>
<a name="ln3218">  /*************************************************************************/</a>
<a name="ln3219">  /*                                                                       */</a>
<a name="ln3220">  /* MINDEX[]:     Move INDEXed element                                    */</a>
<a name="ln3221">  /* Opcode range: 0x26                                                    */</a>
<a name="ln3222">  /* Stack:        int32? --&gt; StkElt                                       */</a>
<a name="ln3223">  /*                                                                       */</a>
<a name="ln3224">  static void</a>
<a name="ln3225">  Ins_MINDEX( TT_ExecContext  exc,</a>
<a name="ln3226">              FT_Long*        args )</a>
<a name="ln3227">  {</a>
<a name="ln3228">    FT_Long  L, K;</a>
<a name="ln3229"> </a>
<a name="ln3230"> </a>
<a name="ln3231">    L = args[0];</a>
<a name="ln3232"> </a>
<a name="ln3233">    if ( L &lt;= 0 || L &gt; exc-&gt;args )</a>
<a name="ln3234">    {</a>
<a name="ln3235">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln3236">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln3237">    }</a>
<a name="ln3238">    else</a>
<a name="ln3239">    {</a>
<a name="ln3240">      K = exc-&gt;stack[exc-&gt;args - L];</a>
<a name="ln3241"> </a>
<a name="ln3242">      FT_ARRAY_MOVE( &amp;exc-&gt;stack[exc-&gt;args - L    ],</a>
<a name="ln3243">                     &amp;exc-&gt;stack[exc-&gt;args - L + 1],</a>
<a name="ln3244">                     ( L - 1 ) );</a>
<a name="ln3245"> </a>
<a name="ln3246">      exc-&gt;stack[exc-&gt;args - 1] = K;</a>
<a name="ln3247">    }</a>
<a name="ln3248">  }</a>
<a name="ln3249"> </a>
<a name="ln3250"> </a>
<a name="ln3251">  /*************************************************************************/</a>
<a name="ln3252">  /*                                                                       */</a>
<a name="ln3253">  /* CINDEX[]:     Copy INDEXed element                                    */</a>
<a name="ln3254">  /* Opcode range: 0x25                                                    */</a>
<a name="ln3255">  /* Stack:        int32 --&gt; StkElt                                        */</a>
<a name="ln3256">  /*                                                                       */</a>
<a name="ln3257">  static void</a>
<a name="ln3258">  Ins_CINDEX( TT_ExecContext  exc,</a>
<a name="ln3259">              FT_Long*        args )</a>
<a name="ln3260">  {</a>
<a name="ln3261">    FT_Long  L;</a>
<a name="ln3262"> </a>
<a name="ln3263"> </a>
<a name="ln3264">    L = args[0];</a>
<a name="ln3265"> </a>
<a name="ln3266">    if ( L &lt;= 0 || L &gt; exc-&gt;args )</a>
<a name="ln3267">    {</a>
<a name="ln3268">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln3269">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln3270">      args[0] = 0;</a>
<a name="ln3271">    }</a>
<a name="ln3272">    else</a>
<a name="ln3273">      args[0] = exc-&gt;stack[exc-&gt;args - L];</a>
<a name="ln3274">  }</a>
<a name="ln3275"> </a>
<a name="ln3276"> </a>
<a name="ln3277">  /*************************************************************************/</a>
<a name="ln3278">  /*                                                                       */</a>
<a name="ln3279">  /* ROLL[]:       ROLL top three elements                                 */</a>
<a name="ln3280">  /* Opcode range: 0x8A                                                    */</a>
<a name="ln3281">  /* Stack:        3 * StkElt --&gt; 3 * StkElt                               */</a>
<a name="ln3282">  /*                                                                       */</a>
<a name="ln3283">  static void</a>
<a name="ln3284">  Ins_ROLL( FT_Long*  args )</a>
<a name="ln3285">  {</a>
<a name="ln3286">    FT_Long  A, B, C;</a>
<a name="ln3287"> </a>
<a name="ln3288"> </a>
<a name="ln3289">    A = args[2];</a>
<a name="ln3290">    B = args[1];</a>
<a name="ln3291">    C = args[0];</a>
<a name="ln3292"> </a>
<a name="ln3293">    args[2] = C;</a>
<a name="ln3294">    args[1] = A;</a>
<a name="ln3295">    args[0] = B;</a>
<a name="ln3296">  }</a>
<a name="ln3297"> </a>
<a name="ln3298"> </a>
<a name="ln3299">  /*************************************************************************/</a>
<a name="ln3300">  /*                                                                       */</a>
<a name="ln3301">  /* MANAGING THE FLOW OF CONTROL                                          */</a>
<a name="ln3302">  /*                                                                       */</a>
<a name="ln3303">  /*************************************************************************/</a>
<a name="ln3304"> </a>
<a name="ln3305"> </a>
<a name="ln3306">  /*************************************************************************/</a>
<a name="ln3307">  /*                                                                       */</a>
<a name="ln3308">  /* SLOOP[]:      Set LOOP variable                                       */</a>
<a name="ln3309">  /* Opcode range: 0x17                                                    */</a>
<a name="ln3310">  /* Stack:        int32? --&gt;                                              */</a>
<a name="ln3311">  /*                                                                       */</a>
<a name="ln3312">  static void</a>
<a name="ln3313">  Ins_SLOOP( TT_ExecContext  exc,</a>
<a name="ln3314">             FT_Long*        args )</a>
<a name="ln3315">  {</a>
<a name="ln3316">    if ( args[0] &lt; 0 )</a>
<a name="ln3317">      exc-&gt;error = FT_THROW( Bad_Argument );</a>
<a name="ln3318">    else</a>
<a name="ln3319">      exc-&gt;GS.loop = args[0];</a>
<a name="ln3320">  }</a>
<a name="ln3321"> </a>
<a name="ln3322"> </a>
<a name="ln3323">  static FT_Bool</a>
<a name="ln3324">  SkipCode( TT_ExecContext  exc )</a>
<a name="ln3325">  {</a>
<a name="ln3326">    exc-&gt;IP += exc-&gt;length;</a>
<a name="ln3327"> </a>
<a name="ln3328">    if ( exc-&gt;IP &lt; exc-&gt;codeSize )</a>
<a name="ln3329">    {</a>
<a name="ln3330">      exc-&gt;opcode = exc-&gt;code[exc-&gt;IP];</a>
<a name="ln3331"> </a>
<a name="ln3332">      exc-&gt;length = opcode_length[exc-&gt;opcode];</a>
<a name="ln3333">      if ( exc-&gt;length &lt; 0 )</a>
<a name="ln3334">      {</a>
<a name="ln3335">        if ( exc-&gt;IP + 1 &gt;= exc-&gt;codeSize )</a>
<a name="ln3336">          goto Fail_Overflow;</a>
<a name="ln3337">        exc-&gt;length = 2 - exc-&gt;length * exc-&gt;code[exc-&gt;IP + 1];</a>
<a name="ln3338">      }</a>
<a name="ln3339"> </a>
<a name="ln3340">      if ( exc-&gt;IP + exc-&gt;length &lt;= exc-&gt;codeSize )</a>
<a name="ln3341">        return SUCCESS;</a>
<a name="ln3342">    }</a>
<a name="ln3343"> </a>
<a name="ln3344">  Fail_Overflow:</a>
<a name="ln3345">    exc-&gt;error = FT_THROW( Code_Overflow );</a>
<a name="ln3346">    return FAILURE;</a>
<a name="ln3347">  }</a>
<a name="ln3348"> </a>
<a name="ln3349"> </a>
<a name="ln3350">  /*************************************************************************/</a>
<a name="ln3351">  /*                                                                       */</a>
<a name="ln3352">  /* IF[]:         IF test                                                 */</a>
<a name="ln3353">  /* Opcode range: 0x58                                                    */</a>
<a name="ln3354">  /* Stack:        StkElt --&gt;                                              */</a>
<a name="ln3355">  /*                                                                       */</a>
<a name="ln3356">  static void</a>
<a name="ln3357">  Ins_IF( TT_ExecContext  exc,</a>
<a name="ln3358">          FT_Long*        args )</a>
<a name="ln3359">  {</a>
<a name="ln3360">    FT_Int   nIfs;</a>
<a name="ln3361">    FT_Bool  Out;</a>
<a name="ln3362"> </a>
<a name="ln3363"> </a>
<a name="ln3364">    if ( args[0] != 0 )</a>
<a name="ln3365">      return;</a>
<a name="ln3366"> </a>
<a name="ln3367">    nIfs = 1;</a>
<a name="ln3368">    Out = 0;</a>
<a name="ln3369"> </a>
<a name="ln3370">    do</a>
<a name="ln3371">    {</a>
<a name="ln3372">      if ( SkipCode( exc ) == FAILURE )</a>
<a name="ln3373">        return;</a>
<a name="ln3374"> </a>
<a name="ln3375">      switch ( exc-&gt;opcode )</a>
<a name="ln3376">      {</a>
<a name="ln3377">      case 0x58:      /* IF */</a>
<a name="ln3378">        nIfs++;</a>
<a name="ln3379">        break;</a>
<a name="ln3380"> </a>
<a name="ln3381">      case 0x1B:      /* ELSE */</a>
<a name="ln3382">        Out = FT_BOOL( nIfs == 1 );</a>
<a name="ln3383">        break;</a>
<a name="ln3384"> </a>
<a name="ln3385">      case 0x59:      /* EIF */</a>
<a name="ln3386">        nIfs--;</a>
<a name="ln3387">        Out = FT_BOOL( nIfs == 0 );</a>
<a name="ln3388">        break;</a>
<a name="ln3389">      }</a>
<a name="ln3390">    } while ( Out == 0 );</a>
<a name="ln3391">  }</a>
<a name="ln3392"> </a>
<a name="ln3393"> </a>
<a name="ln3394">  /*************************************************************************/</a>
<a name="ln3395">  /*                                                                       */</a>
<a name="ln3396">  /* ELSE[]:       ELSE                                                    */</a>
<a name="ln3397">  /* Opcode range: 0x1B                                                    */</a>
<a name="ln3398">  /* Stack:        --&gt;                                                     */</a>
<a name="ln3399">  /*                                                                       */</a>
<a name="ln3400">  static void</a>
<a name="ln3401">  Ins_ELSE( TT_ExecContext  exc )</a>
<a name="ln3402">  {</a>
<a name="ln3403">    FT_Int  nIfs;</a>
<a name="ln3404"> </a>
<a name="ln3405"> </a>
<a name="ln3406">    nIfs = 1;</a>
<a name="ln3407"> </a>
<a name="ln3408">    do</a>
<a name="ln3409">    {</a>
<a name="ln3410">      if ( SkipCode( exc ) == FAILURE )</a>
<a name="ln3411">        return;</a>
<a name="ln3412"> </a>
<a name="ln3413">      switch ( exc-&gt;opcode )</a>
<a name="ln3414">      {</a>
<a name="ln3415">      case 0x58:    /* IF */</a>
<a name="ln3416">        nIfs++;</a>
<a name="ln3417">        break;</a>
<a name="ln3418"> </a>
<a name="ln3419">      case 0x59:    /* EIF */</a>
<a name="ln3420">        nIfs--;</a>
<a name="ln3421">        break;</a>
<a name="ln3422">      }</a>
<a name="ln3423">    } while ( nIfs != 0 );</a>
<a name="ln3424">  }</a>
<a name="ln3425"> </a>
<a name="ln3426"> </a>
<a name="ln3427">  /*************************************************************************/</a>
<a name="ln3428">  /*                                                                       */</a>
<a name="ln3429">  /* EIF[]:        End IF                                                  */</a>
<a name="ln3430">  /* Opcode range: 0x59                                                    */</a>
<a name="ln3431">  /* Stack:        --&gt;                                                     */</a>
<a name="ln3432">  /*                                                                       */</a>
<a name="ln3433">  static void</a>
<a name="ln3434">  Ins_EIF( void )</a>
<a name="ln3435">  {</a>
<a name="ln3436">    /* nothing to do */</a>
<a name="ln3437">  }</a>
<a name="ln3438"> </a>
<a name="ln3439"> </a>
<a name="ln3440">  /*************************************************************************/</a>
<a name="ln3441">  /*                                                                       */</a>
<a name="ln3442">  /* JMPR[]:       JuMP Relative                                           */</a>
<a name="ln3443">  /* Opcode range: 0x1C                                                    */</a>
<a name="ln3444">  /* Stack:        int32 --&gt;                                               */</a>
<a name="ln3445">  /*                                                                       */</a>
<a name="ln3446">  static void</a>
<a name="ln3447">  Ins_JMPR( TT_ExecContext  exc,</a>
<a name="ln3448">            FT_Long*        args )</a>
<a name="ln3449">  {</a>
<a name="ln3450">    if ( args[0] == 0 &amp;&amp; exc-&gt;args == 0 )</a>
<a name="ln3451">      exc-&gt;error = FT_THROW( Bad_Argument );</a>
<a name="ln3452">    exc-&gt;IP += args[0];</a>
<a name="ln3453">    if ( exc-&gt;IP &lt; 0                                             ||</a>
<a name="ln3454">         ( exc-&gt;callTop &gt; 0                                    &amp;&amp;</a>
<a name="ln3455">           exc-&gt;IP &gt; exc-&gt;callStack[exc-&gt;callTop - 1].Def-&gt;end ) )</a>
<a name="ln3456">      exc-&gt;error = FT_THROW( Bad_Argument );</a>
<a name="ln3457">    exc-&gt;step_ins = FALSE;</a>
<a name="ln3458">  }</a>
<a name="ln3459"> </a>
<a name="ln3460"> </a>
<a name="ln3461">  /*************************************************************************/</a>
<a name="ln3462">  /*                                                                       */</a>
<a name="ln3463">  /* JROT[]:       Jump Relative On True                                   */</a>
<a name="ln3464">  /* Opcode range: 0x78                                                    */</a>
<a name="ln3465">  /* Stack:        StkElt int32 --&gt;                                        */</a>
<a name="ln3466">  /*                                                                       */</a>
<a name="ln3467">  static void</a>
<a name="ln3468">  Ins_JROT( TT_ExecContext  exc,</a>
<a name="ln3469">            FT_Long*        args )</a>
<a name="ln3470">  {</a>
<a name="ln3471">    if ( args[1] != 0 )</a>
<a name="ln3472">      Ins_JMPR( exc, args );</a>
<a name="ln3473">  }</a>
<a name="ln3474"> </a>
<a name="ln3475"> </a>
<a name="ln3476">  /*************************************************************************/</a>
<a name="ln3477">  /*                                                                       */</a>
<a name="ln3478">  /* JROF[]:       Jump Relative On False                                  */</a>
<a name="ln3479">  /* Opcode range: 0x79                                                    */</a>
<a name="ln3480">  /* Stack:        StkElt int32 --&gt;                                        */</a>
<a name="ln3481">  /*                                                                       */</a>
<a name="ln3482">  static void</a>
<a name="ln3483">  Ins_JROF( TT_ExecContext  exc,</a>
<a name="ln3484">            FT_Long*        args )</a>
<a name="ln3485">  {</a>
<a name="ln3486">    if ( args[1] == 0 )</a>
<a name="ln3487">      Ins_JMPR( exc, args );</a>
<a name="ln3488">  }</a>
<a name="ln3489"> </a>
<a name="ln3490"> </a>
<a name="ln3491">  /*************************************************************************/</a>
<a name="ln3492">  /*                                                                       */</a>
<a name="ln3493">  /* DEFINING AND USING FUNCTIONS AND INSTRUCTIONS                         */</a>
<a name="ln3494">  /*                                                                       */</a>
<a name="ln3495">  /*************************************************************************/</a>
<a name="ln3496"> </a>
<a name="ln3497"> </a>
<a name="ln3498">  /*************************************************************************/</a>
<a name="ln3499">  /*                                                                       */</a>
<a name="ln3500">  /* FDEF[]:       Function DEFinition                                     */</a>
<a name="ln3501">  /* Opcode range: 0x2C                                                    */</a>
<a name="ln3502">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln3503">  /*                                                                       */</a>
<a name="ln3504">  static void</a>
<a name="ln3505">  Ins_FDEF( TT_ExecContext  exc,</a>
<a name="ln3506">            FT_Long*        args )</a>
<a name="ln3507">  {</a>
<a name="ln3508">    FT_ULong       n;</a>
<a name="ln3509">    TT_DefRecord*  rec;</a>
<a name="ln3510">    TT_DefRecord*  limit;</a>
<a name="ln3511"> </a>
<a name="ln3512">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln3513">    /* arguments to opcodes are skipped by `SKIP_Code' */</a>
<a name="ln3514">    FT_Byte    opcode_pattern[9][12] = {</a>
<a name="ln3515">                 /* #0 inline delta function 1 */</a>
<a name="ln3516">                 {</a>
<a name="ln3517">                   0x4B, /* PPEM    */</a>
<a name="ln3518">                   0x53, /* GTEQ    */</a>
<a name="ln3519">                   0x23, /* SWAP    */</a>
<a name="ln3520">                   0x4B, /* PPEM    */</a>
<a name="ln3521">                   0x51, /* LTEQ    */</a>
<a name="ln3522">                   0x5A, /* AND     */</a>
<a name="ln3523">                   0x58, /* IF      */</a>
<a name="ln3524">                   0x38, /*   SHPIX */</a>
<a name="ln3525">                   0x1B, /* ELSE    */</a>
<a name="ln3526">                   0x21, /*   POP   */</a>
<a name="ln3527">                   0x21, /*   POP   */</a>
<a name="ln3528">                   0x59  /* EIF     */</a>
<a name="ln3529">                 },</a>
<a name="ln3530">                 /* #1 inline delta function 2 */</a>
<a name="ln3531">                 {</a>
<a name="ln3532">                   0x4B, /* PPEM    */</a>
<a name="ln3533">                   0x54, /* EQ      */</a>
<a name="ln3534">                   0x58, /* IF      */</a>
<a name="ln3535">                   0x38, /*   SHPIX */</a>
<a name="ln3536">                   0x1B, /* ELSE    */</a>
<a name="ln3537">                   0x21, /*   POP   */</a>
<a name="ln3538">                   0x21, /*   POP   */</a>
<a name="ln3539">                   0x59  /* EIF     */</a>
<a name="ln3540">                 },</a>
<a name="ln3541">                 /* #2 diagonal stroke function */</a>
<a name="ln3542">                 {</a>
<a name="ln3543">                   0x20, /* DUP     */</a>
<a name="ln3544">                   0x20, /* DUP     */</a>
<a name="ln3545">                   0xB0, /* PUSHB_1 */</a>
<a name="ln3546">                         /*   1     */</a>
<a name="ln3547">                   0x60, /* ADD     */</a>
<a name="ln3548">                   0x46, /* GC_cur  */</a>
<a name="ln3549">                   0xB0, /* PUSHB_1 */</a>
<a name="ln3550">                         /*   64    */</a>
<a name="ln3551">                   0x23, /* SWAP    */</a>
<a name="ln3552">                   0x42  /* WS      */</a>
<a name="ln3553">                 },</a>
<a name="ln3554">                 /* #3 VacuFormRound function */</a>
<a name="ln3555">                 {</a>
<a name="ln3556">                   0x45, /* RCVT    */</a>
<a name="ln3557">                   0x23, /* SWAP    */</a>
<a name="ln3558">                   0x46, /* GC_cur  */</a>
<a name="ln3559">                   0x60, /* ADD     */</a>
<a name="ln3560">                   0x20, /* DUP     */</a>
<a name="ln3561">                   0xB0  /* PUSHB_1 */</a>
<a name="ln3562">                         /*   38    */</a>
<a name="ln3563">                 },</a>
<a name="ln3564">                 /* #4 TTFautohint bytecode (old) */</a>
<a name="ln3565">                 {</a>
<a name="ln3566">                   0x20, /* DUP     */</a>
<a name="ln3567">                   0x64, /* ABS     */</a>
<a name="ln3568">                   0xB0, /* PUSHB_1 */</a>
<a name="ln3569">                         /*   32    */</a>
<a name="ln3570">                   0x60, /* ADD     */</a>
<a name="ln3571">                   0x66, /* FLOOR   */</a>
<a name="ln3572">                   0x23, /* SWAP    */</a>
<a name="ln3573">                   0xB0  /* PUSHB_1 */</a>
<a name="ln3574">                 },</a>
<a name="ln3575">                 /* #5 spacing function 1 */</a>
<a name="ln3576">                 {</a>
<a name="ln3577">                   0x01, /* SVTCA_x */</a>
<a name="ln3578">                   0xB0, /* PUSHB_1 */</a>
<a name="ln3579">                         /*   24    */</a>
<a name="ln3580">                   0x43, /* RS      */</a>
<a name="ln3581">                   0x58  /* IF      */</a>
<a name="ln3582">                 },</a>
<a name="ln3583">                 /* #6 spacing function 2 */</a>
<a name="ln3584">                 {</a>
<a name="ln3585">                   0x01, /* SVTCA_x */</a>
<a name="ln3586">                   0x18, /* RTG     */</a>
<a name="ln3587">                   0xB0, /* PUSHB_1 */</a>
<a name="ln3588">                         /*   24    */</a>
<a name="ln3589">                   0x43, /* RS      */</a>
<a name="ln3590">                   0x58  /* IF      */</a>
<a name="ln3591">                 },</a>
<a name="ln3592">                 /* #7 TypeMan Talk DiagEndCtrl function */</a>
<a name="ln3593">                 {</a>
<a name="ln3594">                   0x01, /* SVTCA_x */</a>
<a name="ln3595">                   0x20, /* DUP     */</a>
<a name="ln3596">                   0xB0, /* PUSHB_1 */</a>
<a name="ln3597">                         /*   3     */</a>
<a name="ln3598">                   0x25, /* CINDEX  */</a>
<a name="ln3599">                 },</a>
<a name="ln3600">                 /* #8 TypeMan Talk Align */</a>
<a name="ln3601">                 {</a>
<a name="ln3602">                   0x06, /* SPVTL   */</a>
<a name="ln3603">                   0x7D, /* RDTG    */</a>
<a name="ln3604">                 },</a>
<a name="ln3605">               };</a>
<a name="ln3606">    FT_UShort  opcode_patterns   = 9;</a>
<a name="ln3607">    FT_UShort  opcode_pointer[9] = {  0, 0, 0, 0, 0, 0, 0, 0, 0 };</a>
<a name="ln3608">    FT_UShort  opcode_size[9]    = { 12, 8, 8, 6, 7, 4, 5, 4, 2 };</a>
<a name="ln3609">    FT_UShort  i;</a>
<a name="ln3610">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln3611"> </a>
<a name="ln3612"> </a>
<a name="ln3613">    /* some font programs are broken enough to redefine functions! */</a>
<a name="ln3614">    /* We will then parse the current table.                       */</a>
<a name="ln3615"> </a>
<a name="ln3616">    rec   = exc-&gt;FDefs;</a>
<a name="ln3617">    limit = rec + exc-&gt;numFDefs;</a>
<a name="ln3618">    n     = (FT_ULong)args[0];</a>
<a name="ln3619"> </a>
<a name="ln3620">    for ( ; rec &lt; limit; rec++ )</a>
<a name="ln3621">    {</a>
<a name="ln3622">      if ( rec-&gt;opc == n )</a>
<a name="ln3623">        break;</a>
<a name="ln3624">    }</a>
<a name="ln3625"> </a>
<a name="ln3626">    if ( rec == limit )</a>
<a name="ln3627">    {</a>
<a name="ln3628">      /* check that there is enough room for new functions */</a>
<a name="ln3629">      if ( exc-&gt;numFDefs &gt;= exc-&gt;maxFDefs )</a>
<a name="ln3630">      {</a>
<a name="ln3631">        exc-&gt;error = FT_THROW( Too_Many_Function_Defs );</a>
<a name="ln3632">        return;</a>
<a name="ln3633">      }</a>
<a name="ln3634">      exc-&gt;numFDefs++;</a>
<a name="ln3635">    }</a>
<a name="ln3636"> </a>
<a name="ln3637">    /* Although FDEF takes unsigned 32-bit integer,  */</a>
<a name="ln3638">    /* func # must be within unsigned 16-bit integer */</a>
<a name="ln3639">    if ( n &gt; 0xFFFFU )</a>
<a name="ln3640">    {</a>
<a name="ln3641">      exc-&gt;error = FT_THROW( Too_Many_Function_Defs );</a>
<a name="ln3642">      return;</a>
<a name="ln3643">    }</a>
<a name="ln3644"> </a>
<a name="ln3645">    rec-&gt;range          = exc-&gt;curRange;</a>
<a name="ln3646">    rec-&gt;opc            = (FT_UInt16)n;</a>
<a name="ln3647">    rec-&gt;start          = exc-&gt;IP + 1;</a>
<a name="ln3648">    rec-&gt;active         = TRUE;</a>
<a name="ln3649">    rec-&gt;inline_delta   = FALSE;</a>
<a name="ln3650">    rec-&gt;sph_fdef_flags = 0x0000;</a>
<a name="ln3651"> </a>
<a name="ln3652">    if ( n &gt; exc-&gt;maxFunc )</a>
<a name="ln3653">      exc-&gt;maxFunc = (FT_UInt16)n;</a>
<a name="ln3654"> </a>
<a name="ln3655">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln3656">    /* We don't know for sure these are typeman functions, */</a>
<a name="ln3657">    /* however they are only active when RS 22 is called   */</a>
<a name="ln3658">    if ( n &gt;= 64 &amp;&amp; n &lt;= 66 )</a>
<a name="ln3659">      rec-&gt;sph_fdef_flags |= SPH_FDEF_TYPEMAN_STROKES;</a>
<a name="ln3660">#endif</a>
<a name="ln3661"> </a>
<a name="ln3662">    /* Now skip the whole function definition. */</a>
<a name="ln3663">    /* We don't allow nested IDEFS &amp; FDEFs.    */</a>
<a name="ln3664"> </a>
<a name="ln3665">    while ( SkipCode( exc ) == SUCCESS )</a>
<a name="ln3666">    {</a>
<a name="ln3667"> </a>
<a name="ln3668">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln3669"> </a>
<a name="ln3670">      if ( SUBPIXEL_HINTING )</a>
<a name="ln3671">      {</a>
<a name="ln3672">        for ( i = 0; i &lt; opcode_patterns; i++ )</a>
<a name="ln3673">        {</a>
<a name="ln3674">          if ( opcode_pointer[i] &lt; opcode_size[i]                  &amp;&amp;</a>
<a name="ln3675">               exc-&gt;opcode == opcode_pattern[i][opcode_pointer[i]] )</a>
<a name="ln3676">          {</a>
<a name="ln3677">            opcode_pointer[i] += 1;</a>
<a name="ln3678"> </a>
<a name="ln3679">            if ( opcode_pointer[i] == opcode_size[i] )</a>
<a name="ln3680">            {</a>
<a name="ln3681">              FT_TRACE6(( &quot;sph: Function %d, opcode ptrn: %d, %s %s\n&quot;,</a>
<a name="ln3682">                          i, n,</a>
<a name="ln3683">                          exc-&gt;face-&gt;root.family_name,</a>
<a name="ln3684">                          exc-&gt;face-&gt;root.style_name ));</a>
<a name="ln3685"> </a>
<a name="ln3686">              switch ( i )</a>
<a name="ln3687">              {</a>
<a name="ln3688">              case 0:</a>
<a name="ln3689">                rec-&gt;sph_fdef_flags             |= SPH_FDEF_INLINE_DELTA_1;</a>
<a name="ln3690">                exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_1;</a>
<a name="ln3691">                break;</a>
<a name="ln3692"> </a>
<a name="ln3693">              case 1:</a>
<a name="ln3694">                rec-&gt;sph_fdef_flags             |= SPH_FDEF_INLINE_DELTA_2;</a>
<a name="ln3695">                exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_INLINE_DELTA_2;</a>
<a name="ln3696">                break;</a>
<a name="ln3697"> </a>
<a name="ln3698">              case 2:</a>
<a name="ln3699">                switch ( n )</a>
<a name="ln3700">                {</a>
<a name="ln3701">                  /* needs to be implemented still */</a>
<a name="ln3702">                case 58:</a>
<a name="ln3703">                  rec-&gt;sph_fdef_flags             |= SPH_FDEF_DIAGONAL_STROKE;</a>
<a name="ln3704">                  exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_DIAGONAL_STROKE;</a>
<a name="ln3705">                }</a>
<a name="ln3706">                break;</a>
<a name="ln3707"> </a>
<a name="ln3708">              case 3:</a>
<a name="ln3709">                switch ( n )</a>
<a name="ln3710">                {</a>
<a name="ln3711">                case 0:</a>
<a name="ln3712">                  rec-&gt;sph_fdef_flags             |= SPH_FDEF_VACUFORM_ROUND_1;</a>
<a name="ln3713">                  exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_VACUFORM_ROUND_1;</a>
<a name="ln3714">                }</a>
<a name="ln3715">                break;</a>
<a name="ln3716"> </a>
<a name="ln3717">              case 4:</a>
<a name="ln3718">                /* probably not necessary to detect anymore */</a>
<a name="ln3719">                rec-&gt;sph_fdef_flags             |= SPH_FDEF_TTFAUTOHINT_1;</a>
<a name="ln3720">                exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_TTFAUTOHINT_1;</a>
<a name="ln3721">                break;</a>
<a name="ln3722"> </a>
<a name="ln3723">              case 5:</a>
<a name="ln3724">                switch ( n )</a>
<a name="ln3725">                {</a>
<a name="ln3726">                case 0:</a>
<a name="ln3727">                case 1:</a>
<a name="ln3728">                case 2:</a>
<a name="ln3729">                case 4:</a>
<a name="ln3730">                case 7:</a>
<a name="ln3731">                case 8:</a>
<a name="ln3732">                  rec-&gt;sph_fdef_flags             |= SPH_FDEF_SPACING_1;</a>
<a name="ln3733">                  exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_SPACING_1;</a>
<a name="ln3734">                }</a>
<a name="ln3735">                break;</a>
<a name="ln3736"> </a>
<a name="ln3737">              case 6:</a>
<a name="ln3738">                switch ( n )</a>
<a name="ln3739">                {</a>
<a name="ln3740">                case 0:</a>
<a name="ln3741">                case 1:</a>
<a name="ln3742">                case 2:</a>
<a name="ln3743">                case 4:</a>
<a name="ln3744">                case 7:</a>
<a name="ln3745">                case 8:</a>
<a name="ln3746">                  rec-&gt;sph_fdef_flags             |= SPH_FDEF_SPACING_2;</a>
<a name="ln3747">                  exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_SPACING_2;</a>
<a name="ln3748">                }</a>
<a name="ln3749">                break;</a>
<a name="ln3750"> </a>
<a name="ln3751">               case 7:</a>
<a name="ln3752">                 rec-&gt;sph_fdef_flags             |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;</a>
<a name="ln3753">                 exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;</a>
<a name="ln3754">                 break;</a>
<a name="ln3755"> </a>
<a name="ln3756">               case 8:</a>
<a name="ln3757">#if 0</a>
<a name="ln3758">                 rec-&gt;sph_fdef_flags             |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;</a>
<a name="ln3759">                 exc-&gt;face-&gt;sph_found_func_flags |= SPH_FDEF_TYPEMAN_DIAGENDCTRL;</a>
<a name="ln3760">#endif</a>
<a name="ln3761">                 break;</a>
<a name="ln3762">              }</a>
<a name="ln3763">              opcode_pointer[i] = 0;</a>
<a name="ln3764">            }</a>
<a name="ln3765">          }</a>
<a name="ln3766"> </a>
<a name="ln3767">          else</a>
<a name="ln3768">            opcode_pointer[i] = 0;</a>
<a name="ln3769">        }</a>
<a name="ln3770"> </a>
<a name="ln3771">        /* Set sph_compatibility_mode only when deltas are detected */</a>
<a name="ln3772">        exc-&gt;face-&gt;sph_compatibility_mode =</a>
<a name="ln3773">          ( ( exc-&gt;face-&gt;sph_found_func_flags &amp; SPH_FDEF_INLINE_DELTA_1 ) |</a>
<a name="ln3774">            ( exc-&gt;face-&gt;sph_found_func_flags &amp; SPH_FDEF_INLINE_DELTA_2 ) );</a>
<a name="ln3775">      }</a>
<a name="ln3776"> </a>
<a name="ln3777">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln3778"> </a>
<a name="ln3779">      switch ( exc-&gt;opcode )</a>
<a name="ln3780">      {</a>
<a name="ln3781">      case 0x89:    /* IDEF */</a>
<a name="ln3782">      case 0x2C:    /* FDEF */</a>
<a name="ln3783">        exc-&gt;error = FT_THROW( Nested_DEFS );</a>
<a name="ln3784">        return;</a>
<a name="ln3785"> </a>
<a name="ln3786">      case 0x2D:   /* ENDF */</a>
<a name="ln3787">        rec-&gt;end = exc-&gt;IP;</a>
<a name="ln3788">        return;</a>
<a name="ln3789">      }</a>
<a name="ln3790">    }</a>
<a name="ln3791">  }</a>
<a name="ln3792"> </a>
<a name="ln3793"> </a>
<a name="ln3794">  /*************************************************************************/</a>
<a name="ln3795">  /*                                                                       */</a>
<a name="ln3796">  /* ENDF[]:       END Function definition                                 */</a>
<a name="ln3797">  /* Opcode range: 0x2D                                                    */</a>
<a name="ln3798">  /* Stack:        --&gt;                                                     */</a>
<a name="ln3799">  /*                                                                       */</a>
<a name="ln3800">  static void</a>
<a name="ln3801">  Ins_ENDF( TT_ExecContext  exc )</a>
<a name="ln3802">  {</a>
<a name="ln3803">    TT_CallRec*  pRec;</a>
<a name="ln3804"> </a>
<a name="ln3805"> </a>
<a name="ln3806">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln3807">    exc-&gt;sph_in_func_flags = 0x0000;</a>
<a name="ln3808">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln3809"> </a>
<a name="ln3810">    if ( exc-&gt;callTop &lt;= 0 )     /* We encountered an ENDF without a call */</a>
<a name="ln3811">    {</a>
<a name="ln3812">      exc-&gt;error = FT_THROW( ENDF_In_Exec_Stream );</a>
<a name="ln3813">      return;</a>
<a name="ln3814">    }</a>
<a name="ln3815"> </a>
<a name="ln3816">    exc-&gt;callTop--;</a>
<a name="ln3817"> </a>
<a name="ln3818">    pRec = &amp;exc-&gt;callStack[exc-&gt;callTop];</a>
<a name="ln3819"> </a>
<a name="ln3820">    pRec-&gt;Cur_Count--;</a>
<a name="ln3821"> </a>
<a name="ln3822">    exc-&gt;step_ins = FALSE;</a>
<a name="ln3823"> </a>
<a name="ln3824">    if ( pRec-&gt;Cur_Count &gt; 0 )</a>
<a name="ln3825">    {</a>
<a name="ln3826">      exc-&gt;callTop++;</a>
<a name="ln3827">      exc-&gt;IP = pRec-&gt;Def-&gt;start;</a>
<a name="ln3828">    }</a>
<a name="ln3829">    else</a>
<a name="ln3830">      /* Loop through the current function */</a>
<a name="ln3831">      Ins_Goto_CodeRange( exc, pRec-&gt;Caller_Range, pRec-&gt;Caller_IP );</a>
<a name="ln3832"> </a>
<a name="ln3833">    /* Exit the current call frame.                      */</a>
<a name="ln3834"> </a>
<a name="ln3835">    /* NOTE: If the last instruction of a program is a   */</a>
<a name="ln3836">    /*       CALL or LOOPCALL, the return address is     */</a>
<a name="ln3837">    /*       always out of the code range.  This is a    */</a>
<a name="ln3838">    /*       valid address, and it is why we do not test */</a>
<a name="ln3839">    /*       the result of Ins_Goto_CodeRange() here!    */</a>
<a name="ln3840">  }</a>
<a name="ln3841"> </a>
<a name="ln3842"> </a>
<a name="ln3843">  /*************************************************************************/</a>
<a name="ln3844">  /*                                                                       */</a>
<a name="ln3845">  /* CALL[]:       CALL function                                           */</a>
<a name="ln3846">  /* Opcode range: 0x2B                                                    */</a>
<a name="ln3847">  /* Stack:        uint32? --&gt;                                             */</a>
<a name="ln3848">  /*                                                                       */</a>
<a name="ln3849">  static void</a>
<a name="ln3850">  Ins_CALL( TT_ExecContext  exc,</a>
<a name="ln3851">            FT_Long*        args )</a>
<a name="ln3852">  {</a>
<a name="ln3853">    FT_ULong       F;</a>
<a name="ln3854">    TT_CallRec*    pCrec;</a>
<a name="ln3855">    TT_DefRecord*  def;</a>
<a name="ln3856"> </a>
<a name="ln3857"> </a>
<a name="ln3858">    /* first of all, check the index */</a>
<a name="ln3859"> </a>
<a name="ln3860">    F = (FT_ULong)args[0];</a>
<a name="ln3861">    if ( BOUNDSL( F, exc-&gt;maxFunc + 1 ) )</a>
<a name="ln3862">      goto Fail;</a>
<a name="ln3863"> </a>
<a name="ln3864">    /* Except for some old Apple fonts, all functions in a TrueType */</a>
<a name="ln3865">    /* font are defined in increasing order, starting from 0.  This */</a>
<a name="ln3866">    /* means that we normally have                                  */</a>
<a name="ln3867">    /*                                                              */</a>
<a name="ln3868">    /*    exc-&gt;maxFunc+1 == exc-&gt;numFDefs                           */</a>
<a name="ln3869">    /*    exc-&gt;FDefs[n].opc == n for n in 0..exc-&gt;maxFunc           */</a>
<a name="ln3870">    /*                                                              */</a>
<a name="ln3871">    /* If this isn't true, we need to look up the function table.   */</a>
<a name="ln3872"> </a>
<a name="ln3873">    def = exc-&gt;FDefs + F;</a>
<a name="ln3874">    if ( exc-&gt;maxFunc + 1 != exc-&gt;numFDefs || def-&gt;opc != F )</a>
<a name="ln3875">    {</a>
<a name="ln3876">      /* look up the FDefs table */</a>
<a name="ln3877">      TT_DefRecord*  limit;</a>
<a name="ln3878"> </a>
<a name="ln3879"> </a>
<a name="ln3880">      def   = exc-&gt;FDefs;</a>
<a name="ln3881">      limit = def + exc-&gt;numFDefs;</a>
<a name="ln3882"> </a>
<a name="ln3883">      while ( def &lt; limit &amp;&amp; def-&gt;opc != F )</a>
<a name="ln3884">        def++;</a>
<a name="ln3885"> </a>
<a name="ln3886">      if ( def == limit )</a>
<a name="ln3887">        goto Fail;</a>
<a name="ln3888">    }</a>
<a name="ln3889"> </a>
<a name="ln3890">    /* check that the function is active */</a>
<a name="ln3891">    if ( !def-&gt;active )</a>
<a name="ln3892">      goto Fail;</a>
<a name="ln3893"> </a>
<a name="ln3894">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln3895">    if ( SUBPIXEL_HINTING                                               &amp;&amp;</a>
<a name="ln3896">         exc-&gt;ignore_x_mode                                             &amp;&amp;</a>
<a name="ln3897">         ( ( exc-&gt;iup_called                                        &amp;&amp;</a>
<a name="ln3898">             ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NO_CALL_AFTER_IUP ) ) ||</a>
<a name="ln3899">           ( def-&gt;sph_fdef_flags &amp; SPH_FDEF_VACUFORM_ROUND_1 )        ) )</a>
<a name="ln3900">      goto Fail;</a>
<a name="ln3901">    else</a>
<a name="ln3902">      exc-&gt;sph_in_func_flags = def-&gt;sph_fdef_flags;</a>
<a name="ln3903">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln3904"> </a>
<a name="ln3905">    /* check the call stack */</a>
<a name="ln3906">    if ( exc-&gt;callTop &gt;= exc-&gt;callSize )</a>
<a name="ln3907">    {</a>
<a name="ln3908">      exc-&gt;error = FT_THROW( Stack_Overflow );</a>
<a name="ln3909">      return;</a>
<a name="ln3910">    }</a>
<a name="ln3911"> </a>
<a name="ln3912">    pCrec = exc-&gt;callStack + exc-&gt;callTop;</a>
<a name="ln3913"> </a>
<a name="ln3914">    pCrec-&gt;Caller_Range = exc-&gt;curRange;</a>
<a name="ln3915">    pCrec-&gt;Caller_IP    = exc-&gt;IP + 1;</a>
<a name="ln3916">    pCrec-&gt;Cur_Count    = 1;</a>
<a name="ln3917">    pCrec-&gt;Def          = def;</a>
<a name="ln3918"> </a>
<a name="ln3919">    exc-&gt;callTop++;</a>
<a name="ln3920"> </a>
<a name="ln3921">    Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );</a>
<a name="ln3922"> </a>
<a name="ln3923">    exc-&gt;step_ins = FALSE;</a>
<a name="ln3924"> </a>
<a name="ln3925">    return;</a>
<a name="ln3926"> </a>
<a name="ln3927">  Fail:</a>
<a name="ln3928">    exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln3929">  }</a>
<a name="ln3930"> </a>
<a name="ln3931"> </a>
<a name="ln3932">  /*************************************************************************/</a>
<a name="ln3933">  /*                                                                       */</a>
<a name="ln3934">  /* LOOPCALL[]:   LOOP and CALL function                                  */</a>
<a name="ln3935">  /* Opcode range: 0x2A                                                    */</a>
<a name="ln3936">  /* Stack:        uint32? Eint16? --&gt;                                     */</a>
<a name="ln3937">  /*                                                                       */</a>
<a name="ln3938">  static void</a>
<a name="ln3939">  Ins_LOOPCALL( TT_ExecContext  exc,</a>
<a name="ln3940">                FT_Long*        args )</a>
<a name="ln3941">  {</a>
<a name="ln3942">    FT_ULong       F;</a>
<a name="ln3943">    TT_CallRec*    pCrec;</a>
<a name="ln3944">    TT_DefRecord*  def;</a>
<a name="ln3945"> </a>
<a name="ln3946"> </a>
<a name="ln3947">    /* first of all, check the index */</a>
<a name="ln3948">    F = (FT_ULong)args[1];</a>
<a name="ln3949">    if ( BOUNDSL( F, exc-&gt;maxFunc + 1 ) )</a>
<a name="ln3950">      goto Fail;</a>
<a name="ln3951"> </a>
<a name="ln3952">    /* Except for some old Apple fonts, all functions in a TrueType */</a>
<a name="ln3953">    /* font are defined in increasing order, starting from 0.  This */</a>
<a name="ln3954">    /* means that we normally have                                  */</a>
<a name="ln3955">    /*                                                              */</a>
<a name="ln3956">    /*    exc-&gt;maxFunc+1 == exc-&gt;numFDefs                           */</a>
<a name="ln3957">    /*    exc-&gt;FDefs[n].opc == n for n in 0..exc-&gt;maxFunc           */</a>
<a name="ln3958">    /*                                                              */</a>
<a name="ln3959">    /* If this isn't true, we need to look up the function table.   */</a>
<a name="ln3960"> </a>
<a name="ln3961">    def = exc-&gt;FDefs + F;</a>
<a name="ln3962">    if ( exc-&gt;maxFunc + 1 != exc-&gt;numFDefs || def-&gt;opc != F )</a>
<a name="ln3963">    {</a>
<a name="ln3964">      /* look up the FDefs table */</a>
<a name="ln3965">      TT_DefRecord*  limit;</a>
<a name="ln3966"> </a>
<a name="ln3967"> </a>
<a name="ln3968">      def   = exc-&gt;FDefs;</a>
<a name="ln3969">      limit = def + exc-&gt;numFDefs;</a>
<a name="ln3970"> </a>
<a name="ln3971">      while ( def &lt; limit &amp;&amp; def-&gt;opc != F )</a>
<a name="ln3972">        def++;</a>
<a name="ln3973"> </a>
<a name="ln3974">      if ( def == limit )</a>
<a name="ln3975">        goto Fail;</a>
<a name="ln3976">    }</a>
<a name="ln3977"> </a>
<a name="ln3978">    /* check that the function is active */</a>
<a name="ln3979">    if ( !def-&gt;active )</a>
<a name="ln3980">      goto Fail;</a>
<a name="ln3981"> </a>
<a name="ln3982">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln3983">    if ( SUBPIXEL_HINTING                                    &amp;&amp;</a>
<a name="ln3984">         exc-&gt;ignore_x_mode                                  &amp;&amp;</a>
<a name="ln3985">         ( def-&gt;sph_fdef_flags &amp; SPH_FDEF_VACUFORM_ROUND_1 ) )</a>
<a name="ln3986">      goto Fail;</a>
<a name="ln3987">    else</a>
<a name="ln3988">      exc-&gt;sph_in_func_flags = def-&gt;sph_fdef_flags;</a>
<a name="ln3989">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln3990"> </a>
<a name="ln3991">    /* check stack */</a>
<a name="ln3992">    if ( exc-&gt;callTop &gt;= exc-&gt;callSize )</a>
<a name="ln3993">    {</a>
<a name="ln3994">      exc-&gt;error = FT_THROW( Stack_Overflow );</a>
<a name="ln3995">      return;</a>
<a name="ln3996">    }</a>
<a name="ln3997"> </a>
<a name="ln3998">    if ( args[0] &gt; 0 )</a>
<a name="ln3999">    {</a>
<a name="ln4000">      pCrec = exc-&gt;callStack + exc-&gt;callTop;</a>
<a name="ln4001"> </a>
<a name="ln4002">      pCrec-&gt;Caller_Range = exc-&gt;curRange;</a>
<a name="ln4003">      pCrec-&gt;Caller_IP    = exc-&gt;IP + 1;</a>
<a name="ln4004">      pCrec-&gt;Cur_Count    = (FT_Int)args[0];</a>
<a name="ln4005">      pCrec-&gt;Def          = def;</a>
<a name="ln4006"> </a>
<a name="ln4007">      exc-&gt;callTop++;</a>
<a name="ln4008"> </a>
<a name="ln4009">      Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );</a>
<a name="ln4010"> </a>
<a name="ln4011">      exc-&gt;step_ins = FALSE;</a>
<a name="ln4012">    }</a>
<a name="ln4013"> </a>
<a name="ln4014">    return;</a>
<a name="ln4015"> </a>
<a name="ln4016">  Fail:</a>
<a name="ln4017">    exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln4018">  }</a>
<a name="ln4019"> </a>
<a name="ln4020"> </a>
<a name="ln4021">  /*************************************************************************/</a>
<a name="ln4022">  /*                                                                       */</a>
<a name="ln4023">  /* IDEF[]:       Instruction DEFinition                                  */</a>
<a name="ln4024">  /* Opcode range: 0x89                                                    */</a>
<a name="ln4025">  /* Stack:        Eint8 --&gt;                                               */</a>
<a name="ln4026">  /*                                                                       */</a>
<a name="ln4027">  static void</a>
<a name="ln4028">  Ins_IDEF( TT_ExecContext  exc,</a>
<a name="ln4029">            FT_Long*        args )</a>
<a name="ln4030">  {</a>
<a name="ln4031">    TT_DefRecord*  def;</a>
<a name="ln4032">    TT_DefRecord*  limit;</a>
<a name="ln4033"> </a>
<a name="ln4034"> </a>
<a name="ln4035">    /*  First of all, look for the same function in our table */</a>
<a name="ln4036"> </a>
<a name="ln4037">    def   = exc-&gt;IDefs;</a>
<a name="ln4038">    limit = def + exc-&gt;numIDefs;</a>
<a name="ln4039"> </a>
<a name="ln4040">    for ( ; def &lt; limit; def++ )</a>
<a name="ln4041">      if ( def-&gt;opc == (FT_ULong)args[0] )</a>
<a name="ln4042">        break;</a>
<a name="ln4043"> </a>
<a name="ln4044">    if ( def == limit )</a>
<a name="ln4045">    {</a>
<a name="ln4046">      /* check that there is enough room for a new instruction */</a>
<a name="ln4047">      if ( exc-&gt;numIDefs &gt;= exc-&gt;maxIDefs )</a>
<a name="ln4048">      {</a>
<a name="ln4049">        exc-&gt;error = FT_THROW( Too_Many_Instruction_Defs );</a>
<a name="ln4050">        return;</a>
<a name="ln4051">      }</a>
<a name="ln4052">      exc-&gt;numIDefs++;</a>
<a name="ln4053">    }</a>
<a name="ln4054"> </a>
<a name="ln4055">    /* opcode must be unsigned 8-bit integer */</a>
<a name="ln4056">    if ( 0 &gt; args[0] || args[0] &gt; 0x00FF )</a>
<a name="ln4057">    {</a>
<a name="ln4058">      exc-&gt;error = FT_THROW( Too_Many_Instruction_Defs );</a>
<a name="ln4059">      return;</a>
<a name="ln4060">    }</a>
<a name="ln4061"> </a>
<a name="ln4062">    def-&gt;opc    = (FT_Byte)args[0];</a>
<a name="ln4063">    def-&gt;start  = exc-&gt;IP + 1;</a>
<a name="ln4064">    def-&gt;range  = exc-&gt;curRange;</a>
<a name="ln4065">    def-&gt;active = TRUE;</a>
<a name="ln4066"> </a>
<a name="ln4067">    if ( (FT_ULong)args[0] &gt; exc-&gt;maxIns )</a>
<a name="ln4068">      exc-&gt;maxIns = (FT_Byte)args[0];</a>
<a name="ln4069"> </a>
<a name="ln4070">    /* Now skip the whole function definition. */</a>
<a name="ln4071">    /* We don't allow nested IDEFs &amp; FDEFs.    */</a>
<a name="ln4072"> </a>
<a name="ln4073">    while ( SkipCode( exc ) == SUCCESS )</a>
<a name="ln4074">    {</a>
<a name="ln4075">      switch ( exc-&gt;opcode )</a>
<a name="ln4076">      {</a>
<a name="ln4077">      case 0x89:   /* IDEF */</a>
<a name="ln4078">      case 0x2C:   /* FDEF */</a>
<a name="ln4079">        exc-&gt;error = FT_THROW( Nested_DEFS );</a>
<a name="ln4080">        return;</a>
<a name="ln4081">      case 0x2D:   /* ENDF */</a>
<a name="ln4082">        return;</a>
<a name="ln4083">      }</a>
<a name="ln4084">    }</a>
<a name="ln4085">  }</a>
<a name="ln4086"> </a>
<a name="ln4087"> </a>
<a name="ln4088">  /*************************************************************************/</a>
<a name="ln4089">  /*                                                                       */</a>
<a name="ln4090">  /* PUSHING DATA ONTO THE INTERPRETER STACK                               */</a>
<a name="ln4091">  /*                                                                       */</a>
<a name="ln4092">  /*************************************************************************/</a>
<a name="ln4093"> </a>
<a name="ln4094"> </a>
<a name="ln4095">  /*************************************************************************/</a>
<a name="ln4096">  /*                                                                       */</a>
<a name="ln4097">  /* NPUSHB[]:     PUSH N Bytes                                            */</a>
<a name="ln4098">  /* Opcode range: 0x40                                                    */</a>
<a name="ln4099">  /* Stack:        --&gt; uint32...                                           */</a>
<a name="ln4100">  /*                                                                       */</a>
<a name="ln4101">  static void</a>
<a name="ln4102">  Ins_NPUSHB( TT_ExecContext  exc,</a>
<a name="ln4103">              FT_Long*        args )</a>
<a name="ln4104">  {</a>
<a name="ln4105">    FT_UShort  L, K;</a>
<a name="ln4106"> </a>
<a name="ln4107"> </a>
<a name="ln4108">    L = (FT_UShort)exc-&gt;code[exc-&gt;IP + 1];</a>
<a name="ln4109"> </a>
<a name="ln4110">    if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )</a>
<a name="ln4111">    {</a>
<a name="ln4112">      exc-&gt;error = FT_THROW( Stack_Overflow );</a>
<a name="ln4113">      return;</a>
<a name="ln4114">    }</a>
<a name="ln4115"> </a>
<a name="ln4116">    for ( K = 1; K &lt;= L; K++ )</a>
<a name="ln4117">      args[K - 1] = exc-&gt;code[exc-&gt;IP + K + 1];</a>
<a name="ln4118"> </a>
<a name="ln4119">    exc-&gt;new_top += L;</a>
<a name="ln4120">  }</a>
<a name="ln4121"> </a>
<a name="ln4122"> </a>
<a name="ln4123">  /*************************************************************************/</a>
<a name="ln4124">  /*                                                                       */</a>
<a name="ln4125">  /* NPUSHW[]:     PUSH N Words                                            */</a>
<a name="ln4126">  /* Opcode range: 0x41                                                    */</a>
<a name="ln4127">  /* Stack:        --&gt; int32...                                            */</a>
<a name="ln4128">  /*                                                                       */</a>
<a name="ln4129">  static void</a>
<a name="ln4130">  Ins_NPUSHW( TT_ExecContext  exc,</a>
<a name="ln4131">              FT_Long*        args )</a>
<a name="ln4132">  {</a>
<a name="ln4133">    FT_UShort  L, K;</a>
<a name="ln4134"> </a>
<a name="ln4135"> </a>
<a name="ln4136">    L = (FT_UShort)exc-&gt;code[exc-&gt;IP + 1];</a>
<a name="ln4137"> </a>
<a name="ln4138">    if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )</a>
<a name="ln4139">    {</a>
<a name="ln4140">      exc-&gt;error = FT_THROW( Stack_Overflow );</a>
<a name="ln4141">      return;</a>
<a name="ln4142">    }</a>
<a name="ln4143"> </a>
<a name="ln4144">    exc-&gt;IP += 2;</a>
<a name="ln4145"> </a>
<a name="ln4146">    for ( K = 0; K &lt; L; K++ )</a>
<a name="ln4147">      args[K] = GetShortIns( exc );</a>
<a name="ln4148"> </a>
<a name="ln4149">    exc-&gt;step_ins = FALSE;</a>
<a name="ln4150">    exc-&gt;new_top += L;</a>
<a name="ln4151">  }</a>
<a name="ln4152"> </a>
<a name="ln4153"> </a>
<a name="ln4154">  /*************************************************************************/</a>
<a name="ln4155">  /*                                                                       */</a>
<a name="ln4156">  /* PUSHB[abc]:   PUSH Bytes                                              */</a>
<a name="ln4157">  /* Opcode range: 0xB0-0xB7                                               */</a>
<a name="ln4158">  /* Stack:        --&gt; uint32...                                           */</a>
<a name="ln4159">  /*                                                                       */</a>
<a name="ln4160">  static void</a>
<a name="ln4161">  Ins_PUSHB( TT_ExecContext  exc,</a>
<a name="ln4162">             FT_Long*        args )</a>
<a name="ln4163">  {</a>
<a name="ln4164">    FT_UShort  L, K;</a>
<a name="ln4165"> </a>
<a name="ln4166"> </a>
<a name="ln4167">    L = (FT_UShort)( exc-&gt;opcode - 0xB0 + 1 );</a>
<a name="ln4168"> </a>
<a name="ln4169">    if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )</a>
<a name="ln4170">    {</a>
<a name="ln4171">      exc-&gt;error = FT_THROW( Stack_Overflow );</a>
<a name="ln4172">      return;</a>
<a name="ln4173">    }</a>
<a name="ln4174"> </a>
<a name="ln4175">    for ( K = 1; K &lt;= L; K++ )</a>
<a name="ln4176">      args[K - 1] = exc-&gt;code[exc-&gt;IP + K];</a>
<a name="ln4177">  }</a>
<a name="ln4178"> </a>
<a name="ln4179"> </a>
<a name="ln4180">  /*************************************************************************/</a>
<a name="ln4181">  /*                                                                       */</a>
<a name="ln4182">  /* PUSHW[abc]:   PUSH Words                                              */</a>
<a name="ln4183">  /* Opcode range: 0xB8-0xBF                                               */</a>
<a name="ln4184">  /* Stack:        --&gt; int32...                                            */</a>
<a name="ln4185">  /*                                                                       */</a>
<a name="ln4186">  static void</a>
<a name="ln4187">  Ins_PUSHW( TT_ExecContext  exc,</a>
<a name="ln4188">             FT_Long*        args )</a>
<a name="ln4189">  {</a>
<a name="ln4190">    FT_UShort  L, K;</a>
<a name="ln4191"> </a>
<a name="ln4192"> </a>
<a name="ln4193">    L = (FT_UShort)( exc-&gt;opcode - 0xB8 + 1 );</a>
<a name="ln4194"> </a>
<a name="ln4195">    if ( BOUNDS( L, exc-&gt;stackSize + 1 - exc-&gt;top ) )</a>
<a name="ln4196">    {</a>
<a name="ln4197">      exc-&gt;error = FT_THROW( Stack_Overflow );</a>
<a name="ln4198">      return;</a>
<a name="ln4199">    }</a>
<a name="ln4200"> </a>
<a name="ln4201">    exc-&gt;IP++;</a>
<a name="ln4202"> </a>
<a name="ln4203">    for ( K = 0; K &lt; L; K++ )</a>
<a name="ln4204">      args[K] = GetShortIns( exc );</a>
<a name="ln4205"> </a>
<a name="ln4206">    exc-&gt;step_ins = FALSE;</a>
<a name="ln4207">  }</a>
<a name="ln4208"> </a>
<a name="ln4209"> </a>
<a name="ln4210">  /*************************************************************************/</a>
<a name="ln4211">  /*                                                                       */</a>
<a name="ln4212">  /* MANAGING THE GRAPHICS STATE                                           */</a>
<a name="ln4213">  /*                                                                       */</a>
<a name="ln4214">  /*************************************************************************/</a>
<a name="ln4215"> </a>
<a name="ln4216"> </a>
<a name="ln4217">  static FT_Bool</a>
<a name="ln4218">  Ins_SxVTL( TT_ExecContext  exc,</a>
<a name="ln4219">             FT_UShort       aIdx1,</a>
<a name="ln4220">             FT_UShort       aIdx2,</a>
<a name="ln4221">             FT_UnitVector*  Vec )</a>
<a name="ln4222">  {</a>
<a name="ln4223">    FT_Long     A, B, C;</a>
<a name="ln4224">    FT_Vector*  p1;</a>
<a name="ln4225">    FT_Vector*  p2;</a>
<a name="ln4226"> </a>
<a name="ln4227">    FT_Byte  opcode = exc-&gt;opcode;</a>
<a name="ln4228"> </a>
<a name="ln4229"> </a>
<a name="ln4230">    if ( BOUNDS( aIdx1, exc-&gt;zp2.n_points ) ||</a>
<a name="ln4231">         BOUNDS( aIdx2, exc-&gt;zp1.n_points ) )</a>
<a name="ln4232">    {</a>
<a name="ln4233">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln4234">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln4235">      return FAILURE;</a>
<a name="ln4236">    }</a>
<a name="ln4237"> </a>
<a name="ln4238">    p1 = exc-&gt;zp1.cur + aIdx2;</a>
<a name="ln4239">    p2 = exc-&gt;zp2.cur + aIdx1;</a>
<a name="ln4240"> </a>
<a name="ln4241">    A = p1-&gt;x - p2-&gt;x;</a>
<a name="ln4242">    B = p1-&gt;y - p2-&gt;y;</a>
<a name="ln4243"> </a>
<a name="ln4244">    /* If p1 == p2, SPvTL and SFvTL behave the same as */</a>
<a name="ln4245">    /* SPvTCA[X] and SFvTCA[X], respectively.          */</a>
<a name="ln4246">    /*                                                 */</a>
<a name="ln4247">    /* Confirmed by Greg Hitchcock.                    */</a>
<a name="ln4248"> </a>
<a name="ln4249">    if ( A == 0 &amp;&amp; B == 0 )</a>
<a name="ln4250">    {</a>
<a name="ln4251">      A      = 0x4000;</a>
<a name="ln4252">      opcode = 0;</a>
<a name="ln4253">    }</a>
<a name="ln4254"> </a>
<a name="ln4255">    if ( ( opcode &amp; 1 ) != 0 )</a>
<a name="ln4256">    {</a>
<a name="ln4257">      C =  B;   /* counter clockwise rotation */</a>
<a name="ln4258">      B =  A;</a>
<a name="ln4259">      A = -C;</a>
<a name="ln4260">    }</a>
<a name="ln4261"> </a>
<a name="ln4262">    Normalize( A, B, Vec );</a>
<a name="ln4263"> </a>
<a name="ln4264">    return SUCCESS;</a>
<a name="ln4265">  }</a>
<a name="ln4266"> </a>
<a name="ln4267"> </a>
<a name="ln4268">  /*************************************************************************/</a>
<a name="ln4269">  /*                                                                       */</a>
<a name="ln4270">  /* SVTCA[a]:     Set (F and P) Vectors to Coordinate Axis                */</a>
<a name="ln4271">  /* Opcode range: 0x00-0x01                                               */</a>
<a name="ln4272">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4273">  /*                                                                       */</a>
<a name="ln4274">  /* SPvTCA[a]:    Set PVector to Coordinate Axis                          */</a>
<a name="ln4275">  /* Opcode range: 0x02-0x03                                               */</a>
<a name="ln4276">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4277">  /*                                                                       */</a>
<a name="ln4278">  /* SFvTCA[a]:    Set FVector to Coordinate Axis                          */</a>
<a name="ln4279">  /* Opcode range: 0x04-0x05                                               */</a>
<a name="ln4280">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4281">  /*                                                                       */</a>
<a name="ln4282">  static void</a>
<a name="ln4283">  Ins_SxyTCA( TT_ExecContext  exc )</a>
<a name="ln4284">  {</a>
<a name="ln4285">    FT_Short  AA, BB;</a>
<a name="ln4286"> </a>
<a name="ln4287">    FT_Byte  opcode = exc-&gt;opcode;</a>
<a name="ln4288"> </a>
<a name="ln4289"> </a>
<a name="ln4290">    AA = (FT_Short)( ( opcode &amp; 1 ) &lt;&lt; 14 );</a>
<a name="ln4291">    BB = (FT_Short)( AA ^ 0x4000 );</a>
<a name="ln4292"> </a>
<a name="ln4293">    if ( opcode &lt; 4 )</a>
<a name="ln4294">    {</a>
<a name="ln4295">      exc-&gt;GS.projVector.x = AA;</a>
<a name="ln4296">      exc-&gt;GS.projVector.y = BB;</a>
<a name="ln4297"> </a>
<a name="ln4298">      exc-&gt;GS.dualVector.x = AA;</a>
<a name="ln4299">      exc-&gt;GS.dualVector.y = BB;</a>
<a name="ln4300">    }</a>
<a name="ln4301">    else</a>
<a name="ln4302">      GUESS_VECTOR( projVector );</a>
<a name="ln4303"> </a>
<a name="ln4304">    if ( ( opcode &amp; 2 ) == 0 )</a>
<a name="ln4305">    {</a>
<a name="ln4306">      exc-&gt;GS.freeVector.x = AA;</a>
<a name="ln4307">      exc-&gt;GS.freeVector.y = BB;</a>
<a name="ln4308">    }</a>
<a name="ln4309">    else</a>
<a name="ln4310">      GUESS_VECTOR( freeVector );</a>
<a name="ln4311"> </a>
<a name="ln4312">    Compute_Funcs( exc );</a>
<a name="ln4313">  }</a>
<a name="ln4314"> </a>
<a name="ln4315"> </a>
<a name="ln4316">  /*************************************************************************/</a>
<a name="ln4317">  /*                                                                       */</a>
<a name="ln4318">  /* SPvTL[a]:     Set PVector To Line                                     */</a>
<a name="ln4319">  /* Opcode range: 0x06-0x07                                               */</a>
<a name="ln4320">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln4321">  /*                                                                       */</a>
<a name="ln4322">  static void</a>
<a name="ln4323">  Ins_SPVTL( TT_ExecContext  exc,</a>
<a name="ln4324">             FT_Long*        args )</a>
<a name="ln4325">  {</a>
<a name="ln4326">    if ( Ins_SxVTL( exc,</a>
<a name="ln4327">                    (FT_UShort)args[1],</a>
<a name="ln4328">                    (FT_UShort)args[0],</a>
<a name="ln4329">                    &amp;exc-&gt;GS.projVector ) == SUCCESS )</a>
<a name="ln4330">    {</a>
<a name="ln4331">      exc-&gt;GS.dualVector = exc-&gt;GS.projVector;</a>
<a name="ln4332">      GUESS_VECTOR( freeVector );</a>
<a name="ln4333">      Compute_Funcs( exc );</a>
<a name="ln4334">    }</a>
<a name="ln4335">  }</a>
<a name="ln4336"> </a>
<a name="ln4337"> </a>
<a name="ln4338">  /*************************************************************************/</a>
<a name="ln4339">  /*                                                                       */</a>
<a name="ln4340">  /* SFvTL[a]:     Set FVector To Line                                     */</a>
<a name="ln4341">  /* Opcode range: 0x08-0x09                                               */</a>
<a name="ln4342">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln4343">  /*                                                                       */</a>
<a name="ln4344">  static void</a>
<a name="ln4345">  Ins_SFVTL( TT_ExecContext  exc,</a>
<a name="ln4346">             FT_Long*        args )</a>
<a name="ln4347">  {</a>
<a name="ln4348">    if ( Ins_SxVTL( exc,</a>
<a name="ln4349">                    (FT_UShort)args[1],</a>
<a name="ln4350">                    (FT_UShort)args[0],</a>
<a name="ln4351">                    &amp;exc-&gt;GS.freeVector ) == SUCCESS )</a>
<a name="ln4352">    {</a>
<a name="ln4353">      GUESS_VECTOR( projVector );</a>
<a name="ln4354">      Compute_Funcs( exc );</a>
<a name="ln4355">    }</a>
<a name="ln4356">  }</a>
<a name="ln4357"> </a>
<a name="ln4358"> </a>
<a name="ln4359">  /*************************************************************************/</a>
<a name="ln4360">  /*                                                                       */</a>
<a name="ln4361">  /* SFvTPv[]:     Set FVector To PVector                                  */</a>
<a name="ln4362">  /* Opcode range: 0x0E                                                    */</a>
<a name="ln4363">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4364">  /*                                                                       */</a>
<a name="ln4365">  static void</a>
<a name="ln4366">  Ins_SFVTPV( TT_ExecContext  exc )</a>
<a name="ln4367">  {</a>
<a name="ln4368">    GUESS_VECTOR( projVector );</a>
<a name="ln4369">    exc-&gt;GS.freeVector = exc-&gt;GS.projVector;</a>
<a name="ln4370">    Compute_Funcs( exc );</a>
<a name="ln4371">  }</a>
<a name="ln4372"> </a>
<a name="ln4373"> </a>
<a name="ln4374">  /*************************************************************************/</a>
<a name="ln4375">  /*                                                                       */</a>
<a name="ln4376">  /* SPvFS[]:      Set PVector From Stack                                  */</a>
<a name="ln4377">  /* Opcode range: 0x0A                                                    */</a>
<a name="ln4378">  /* Stack:        f2.14 f2.14 --&gt;                                         */</a>
<a name="ln4379">  /*                                                                       */</a>
<a name="ln4380">  static void</a>
<a name="ln4381">  Ins_SPVFS( TT_ExecContext  exc,</a>
<a name="ln4382">             FT_Long*        args )</a>
<a name="ln4383">  {</a>
<a name="ln4384">    FT_Short  S;</a>
<a name="ln4385">    FT_Long   X, Y;</a>
<a name="ln4386"> </a>
<a name="ln4387"> </a>
<a name="ln4388">    /* Only use low 16bits, then sign extend */</a>
<a name="ln4389">    S = (FT_Short)args[1];</a>
<a name="ln4390">    Y = (FT_Long)S;</a>
<a name="ln4391">    S = (FT_Short)args[0];</a>
<a name="ln4392">    X = (FT_Long)S;</a>
<a name="ln4393"> </a>
<a name="ln4394">    Normalize( X, Y, &amp;exc-&gt;GS.projVector );</a>
<a name="ln4395"> </a>
<a name="ln4396">    exc-&gt;GS.dualVector = exc-&gt;GS.projVector;</a>
<a name="ln4397">    GUESS_VECTOR( freeVector );</a>
<a name="ln4398">    Compute_Funcs( exc );</a>
<a name="ln4399">  }</a>
<a name="ln4400"> </a>
<a name="ln4401"> </a>
<a name="ln4402">  /*************************************************************************/</a>
<a name="ln4403">  /*                                                                       */</a>
<a name="ln4404">  /* SFvFS[]:      Set FVector From Stack                                  */</a>
<a name="ln4405">  /* Opcode range: 0x0B                                                    */</a>
<a name="ln4406">  /* Stack:        f2.14 f2.14 --&gt;                                         */</a>
<a name="ln4407">  /*                                                                       */</a>
<a name="ln4408">  static void</a>
<a name="ln4409">  Ins_SFVFS( TT_ExecContext  exc,</a>
<a name="ln4410">             FT_Long*        args )</a>
<a name="ln4411">  {</a>
<a name="ln4412">    FT_Short  S;</a>
<a name="ln4413">    FT_Long   X, Y;</a>
<a name="ln4414"> </a>
<a name="ln4415"> </a>
<a name="ln4416">    /* Only use low 16bits, then sign extend */</a>
<a name="ln4417">    S = (FT_Short)args[1];</a>
<a name="ln4418">    Y = (FT_Long)S;</a>
<a name="ln4419">    S = (FT_Short)args[0];</a>
<a name="ln4420">    X = S;</a>
<a name="ln4421"> </a>
<a name="ln4422">    Normalize( X, Y, &amp;exc-&gt;GS.freeVector );</a>
<a name="ln4423">    GUESS_VECTOR( projVector );</a>
<a name="ln4424">    Compute_Funcs( exc );</a>
<a name="ln4425">  }</a>
<a name="ln4426"> </a>
<a name="ln4427"> </a>
<a name="ln4428">  /*************************************************************************/</a>
<a name="ln4429">  /*                                                                       */</a>
<a name="ln4430">  /* GPv[]:        Get Projection Vector                                   */</a>
<a name="ln4431">  /* Opcode range: 0x0C                                                    */</a>
<a name="ln4432">  /* Stack:        ef2.14 --&gt; ef2.14                                       */</a>
<a name="ln4433">  /*                                                                       */</a>
<a name="ln4434">  static void</a>
<a name="ln4435">  Ins_GPV( TT_ExecContext  exc,</a>
<a name="ln4436">           FT_Long*        args )</a>
<a name="ln4437">  {</a>
<a name="ln4438">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln4439">    if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln4440">    {</a>
<a name="ln4441">      args[0] = exc-&gt;GS.both_x_axis ? 0x4000 : 0;</a>
<a name="ln4442">      args[1] = exc-&gt;GS.both_x_axis ? 0 : 0x4000;</a>
<a name="ln4443">    }</a>
<a name="ln4444">    else</a>
<a name="ln4445">    {</a>
<a name="ln4446">      args[0] = exc-&gt;GS.projVector.x;</a>
<a name="ln4447">      args[1] = exc-&gt;GS.projVector.y;</a>
<a name="ln4448">    }</a>
<a name="ln4449">#else</a>
<a name="ln4450">    args[0] = exc-&gt;GS.projVector.x;</a>
<a name="ln4451">    args[1] = exc-&gt;GS.projVector.y;</a>
<a name="ln4452">#endif</a>
<a name="ln4453">  }</a>
<a name="ln4454"> </a>
<a name="ln4455"> </a>
<a name="ln4456">  /*************************************************************************/</a>
<a name="ln4457">  /*                                                                       */</a>
<a name="ln4458">  /* GFv[]:        Get Freedom Vector                                      */</a>
<a name="ln4459">  /* Opcode range: 0x0D                                                    */</a>
<a name="ln4460">  /* Stack:        ef2.14 --&gt; ef2.14                                       */</a>
<a name="ln4461">  /*                                                                       */</a>
<a name="ln4462">  static void</a>
<a name="ln4463">  Ins_GFV( TT_ExecContext  exc,</a>
<a name="ln4464">           FT_Long*        args )</a>
<a name="ln4465">  {</a>
<a name="ln4466">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln4467">    if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln4468">    {</a>
<a name="ln4469">      args[0] = exc-&gt;GS.both_x_axis ? 0x4000 : 0;</a>
<a name="ln4470">      args[1] = exc-&gt;GS.both_x_axis ? 0 : 0x4000;</a>
<a name="ln4471">    }</a>
<a name="ln4472">    else</a>
<a name="ln4473">    {</a>
<a name="ln4474">      args[0] = exc-&gt;GS.freeVector.x;</a>
<a name="ln4475">      args[1] = exc-&gt;GS.freeVector.y;</a>
<a name="ln4476">    }</a>
<a name="ln4477">#else</a>
<a name="ln4478">    args[0] = exc-&gt;GS.freeVector.x;</a>
<a name="ln4479">    args[1] = exc-&gt;GS.freeVector.y;</a>
<a name="ln4480">#endif</a>
<a name="ln4481">  }</a>
<a name="ln4482"> </a>
<a name="ln4483"> </a>
<a name="ln4484">  /*************************************************************************/</a>
<a name="ln4485">  /*                                                                       */</a>
<a name="ln4486">  /* SRP0[]:       Set Reference Point 0                                   */</a>
<a name="ln4487">  /* Opcode range: 0x10                                                    */</a>
<a name="ln4488">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln4489">  /*                                                                       */</a>
<a name="ln4490">  static void</a>
<a name="ln4491">  Ins_SRP0( TT_ExecContext  exc,</a>
<a name="ln4492">            FT_Long*        args )</a>
<a name="ln4493">  {</a>
<a name="ln4494">    exc-&gt;GS.rp0 = (FT_UShort)args[0];</a>
<a name="ln4495">  }</a>
<a name="ln4496"> </a>
<a name="ln4497"> </a>
<a name="ln4498">  /*************************************************************************/</a>
<a name="ln4499">  /*                                                                       */</a>
<a name="ln4500">  /* SRP1[]:       Set Reference Point 1                                   */</a>
<a name="ln4501">  /* Opcode range: 0x11                                                    */</a>
<a name="ln4502">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln4503">  /*                                                                       */</a>
<a name="ln4504">  static void</a>
<a name="ln4505">  Ins_SRP1( TT_ExecContext  exc,</a>
<a name="ln4506">            FT_Long*        args )</a>
<a name="ln4507">  {</a>
<a name="ln4508">    exc-&gt;GS.rp1 = (FT_UShort)args[0];</a>
<a name="ln4509">  }</a>
<a name="ln4510"> </a>
<a name="ln4511"> </a>
<a name="ln4512">  /*************************************************************************/</a>
<a name="ln4513">  /*                                                                       */</a>
<a name="ln4514">  /* SRP2[]:       Set Reference Point 2                                   */</a>
<a name="ln4515">  /* Opcode range: 0x12                                                    */</a>
<a name="ln4516">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln4517">  /*                                                                       */</a>
<a name="ln4518">  static void</a>
<a name="ln4519">  Ins_SRP2( TT_ExecContext  exc,</a>
<a name="ln4520">            FT_Long*        args )</a>
<a name="ln4521">  {</a>
<a name="ln4522">    exc-&gt;GS.rp2 = (FT_UShort)args[0];</a>
<a name="ln4523">  }</a>
<a name="ln4524"> </a>
<a name="ln4525"> </a>
<a name="ln4526">  /*************************************************************************/</a>
<a name="ln4527">  /*                                                                       */</a>
<a name="ln4528">  /* SMD[]:        Set Minimum Distance                                    */</a>
<a name="ln4529">  /* Opcode range: 0x1A                                                    */</a>
<a name="ln4530">  /* Stack:        f26.6 --&gt;                                               */</a>
<a name="ln4531">  /*                                                                       */</a>
<a name="ln4532">  static void</a>
<a name="ln4533">  Ins_SMD( TT_ExecContext  exc,</a>
<a name="ln4534">           FT_Long*        args )</a>
<a name="ln4535">  {</a>
<a name="ln4536">    exc-&gt;GS.minimum_distance = args[0];</a>
<a name="ln4537">  }</a>
<a name="ln4538"> </a>
<a name="ln4539"> </a>
<a name="ln4540">  /*************************************************************************/</a>
<a name="ln4541">  /*                                                                       */</a>
<a name="ln4542">  /* SCVTCI[]:     Set Control Value Table Cut In                          */</a>
<a name="ln4543">  /* Opcode range: 0x1D                                                    */</a>
<a name="ln4544">  /* Stack:        f26.6 --&gt;                                               */</a>
<a name="ln4545">  /*                                                                       */</a>
<a name="ln4546">  static void</a>
<a name="ln4547">  Ins_SCVTCI( TT_ExecContext  exc,</a>
<a name="ln4548">              FT_Long*        args )</a>
<a name="ln4549">  {</a>
<a name="ln4550">    exc-&gt;GS.control_value_cutin = (FT_F26Dot6)args[0];</a>
<a name="ln4551">  }</a>
<a name="ln4552"> </a>
<a name="ln4553"> </a>
<a name="ln4554">  /*************************************************************************/</a>
<a name="ln4555">  /*                                                                       */</a>
<a name="ln4556">  /* SSWCI[]:      Set Single Width Cut In                                 */</a>
<a name="ln4557">  /* Opcode range: 0x1E                                                    */</a>
<a name="ln4558">  /* Stack:        f26.6 --&gt;                                               */</a>
<a name="ln4559">  /*                                                                       */</a>
<a name="ln4560">  static void</a>
<a name="ln4561">  Ins_SSWCI( TT_ExecContext  exc,</a>
<a name="ln4562">             FT_Long*        args )</a>
<a name="ln4563">  {</a>
<a name="ln4564">    exc-&gt;GS.single_width_cutin = (FT_F26Dot6)args[0];</a>
<a name="ln4565">  }</a>
<a name="ln4566"> </a>
<a name="ln4567"> </a>
<a name="ln4568">  /*************************************************************************/</a>
<a name="ln4569">  /*                                                                       */</a>
<a name="ln4570">  /* SSW[]:        Set Single Width                                        */</a>
<a name="ln4571">  /* Opcode range: 0x1F                                                    */</a>
<a name="ln4572">  /* Stack:        int32? --&gt;                                              */</a>
<a name="ln4573">  /*                                                                       */</a>
<a name="ln4574">  static void</a>
<a name="ln4575">  Ins_SSW( TT_ExecContext  exc,</a>
<a name="ln4576">           FT_Long*        args )</a>
<a name="ln4577">  {</a>
<a name="ln4578">    exc-&gt;GS.single_width_value = FT_MulFix( args[0],</a>
<a name="ln4579">                                            exc-&gt;tt_metrics.scale );</a>
<a name="ln4580">  }</a>
<a name="ln4581"> </a>
<a name="ln4582"> </a>
<a name="ln4583">  /*************************************************************************/</a>
<a name="ln4584">  /*                                                                       */</a>
<a name="ln4585">  /* FLIPON[]:     Set auto-FLIP to ON                                     */</a>
<a name="ln4586">  /* Opcode range: 0x4D                                                    */</a>
<a name="ln4587">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4588">  /*                                                                       */</a>
<a name="ln4589">  static void</a>
<a name="ln4590">  Ins_FLIPON( TT_ExecContext  exc )</a>
<a name="ln4591">  {</a>
<a name="ln4592">    exc-&gt;GS.auto_flip = TRUE;</a>
<a name="ln4593">  }</a>
<a name="ln4594"> </a>
<a name="ln4595"> </a>
<a name="ln4596">  /*************************************************************************/</a>
<a name="ln4597">  /*                                                                       */</a>
<a name="ln4598">  /* FLIPOFF[]:    Set auto-FLIP to OFF                                    */</a>
<a name="ln4599">  /* Opcode range: 0x4E                                                    */</a>
<a name="ln4600">  /* Stack: --&gt;                                                            */</a>
<a name="ln4601">  /*                                                                       */</a>
<a name="ln4602">  static void</a>
<a name="ln4603">  Ins_FLIPOFF( TT_ExecContext  exc )</a>
<a name="ln4604">  {</a>
<a name="ln4605">    exc-&gt;GS.auto_flip = FALSE;</a>
<a name="ln4606">  }</a>
<a name="ln4607"> </a>
<a name="ln4608"> </a>
<a name="ln4609">  /*************************************************************************/</a>
<a name="ln4610">  /*                                                                       */</a>
<a name="ln4611">  /* SANGW[]:      Set ANGle Weight                                        */</a>
<a name="ln4612">  /* Opcode range: 0x7E                                                    */</a>
<a name="ln4613">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln4614">  /*                                                                       */</a>
<a name="ln4615">  static void</a>
<a name="ln4616">  Ins_SANGW( void )</a>
<a name="ln4617">  {</a>
<a name="ln4618">    /* instruction not supported anymore */</a>
<a name="ln4619">  }</a>
<a name="ln4620"> </a>
<a name="ln4621"> </a>
<a name="ln4622">  /*************************************************************************/</a>
<a name="ln4623">  /*                                                                       */</a>
<a name="ln4624">  /* SDB[]:        Set Delta Base                                          */</a>
<a name="ln4625">  /* Opcode range: 0x5E                                                    */</a>
<a name="ln4626">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln4627">  /*                                                                       */</a>
<a name="ln4628">  static void</a>
<a name="ln4629">  Ins_SDB( TT_ExecContext  exc,</a>
<a name="ln4630">           FT_Long*        args )</a>
<a name="ln4631">  {</a>
<a name="ln4632">    exc-&gt;GS.delta_base = (FT_UShort)args[0];</a>
<a name="ln4633">  }</a>
<a name="ln4634"> </a>
<a name="ln4635"> </a>
<a name="ln4636">  /*************************************************************************/</a>
<a name="ln4637">  /*                                                                       */</a>
<a name="ln4638">  /* SDS[]:        Set Delta Shift                                         */</a>
<a name="ln4639">  /* Opcode range: 0x5F                                                    */</a>
<a name="ln4640">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln4641">  /*                                                                       */</a>
<a name="ln4642">  static void</a>
<a name="ln4643">  Ins_SDS( TT_ExecContext  exc,</a>
<a name="ln4644">           FT_Long*        args )</a>
<a name="ln4645">  {</a>
<a name="ln4646">    if ( (FT_ULong)args[0] &gt; 6UL )</a>
<a name="ln4647">      exc-&gt;error = FT_THROW( Bad_Argument );</a>
<a name="ln4648">    else</a>
<a name="ln4649">      exc-&gt;GS.delta_shift = (FT_UShort)args[0];</a>
<a name="ln4650">  }</a>
<a name="ln4651"> </a>
<a name="ln4652"> </a>
<a name="ln4653">  /*************************************************************************/</a>
<a name="ln4654">  /*                                                                       */</a>
<a name="ln4655">  /* RTHG[]:       Round To Half Grid                                      */</a>
<a name="ln4656">  /* Opcode range: 0x19                                                    */</a>
<a name="ln4657">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4658">  /*                                                                       */</a>
<a name="ln4659">  static void</a>
<a name="ln4660">  Ins_RTHG( TT_ExecContext  exc )</a>
<a name="ln4661">  {</a>
<a name="ln4662">    exc-&gt;GS.round_state = TT_Round_To_Half_Grid;</a>
<a name="ln4663">    exc-&gt;func_round     = (TT_Round_Func)Round_To_Half_Grid;</a>
<a name="ln4664">  }</a>
<a name="ln4665"> </a>
<a name="ln4666"> </a>
<a name="ln4667">  /*************************************************************************/</a>
<a name="ln4668">  /*                                                                       */</a>
<a name="ln4669">  /* RTG[]:        Round To Grid                                           */</a>
<a name="ln4670">  /* Opcode range: 0x18                                                    */</a>
<a name="ln4671">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4672">  /*                                                                       */</a>
<a name="ln4673">  static void</a>
<a name="ln4674">  Ins_RTG( TT_ExecContext  exc )</a>
<a name="ln4675">  {</a>
<a name="ln4676">    exc-&gt;GS.round_state = TT_Round_To_Grid;</a>
<a name="ln4677">    exc-&gt;func_round     = (TT_Round_Func)Round_To_Grid;</a>
<a name="ln4678">  }</a>
<a name="ln4679"> </a>
<a name="ln4680"> </a>
<a name="ln4681">  /*************************************************************************/</a>
<a name="ln4682">  /* RTDG[]:       Round To Double Grid                                    */</a>
<a name="ln4683">  /* Opcode range: 0x3D                                                    */</a>
<a name="ln4684">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4685">  /*                                                                       */</a>
<a name="ln4686">  static void</a>
<a name="ln4687">  Ins_RTDG( TT_ExecContext  exc )</a>
<a name="ln4688">  {</a>
<a name="ln4689">    exc-&gt;GS.round_state = TT_Round_To_Double_Grid;</a>
<a name="ln4690">    exc-&gt;func_round     = (TT_Round_Func)Round_To_Double_Grid;</a>
<a name="ln4691">  }</a>
<a name="ln4692"> </a>
<a name="ln4693"> </a>
<a name="ln4694">  /*************************************************************************/</a>
<a name="ln4695">  /* RUTG[]:       Round Up To Grid                                        */</a>
<a name="ln4696">  /* Opcode range: 0x7C                                                    */</a>
<a name="ln4697">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4698">  /*                                                                       */</a>
<a name="ln4699">  static void</a>
<a name="ln4700">  Ins_RUTG( TT_ExecContext  exc )</a>
<a name="ln4701">  {</a>
<a name="ln4702">    exc-&gt;GS.round_state = TT_Round_Up_To_Grid;</a>
<a name="ln4703">    exc-&gt;func_round     = (TT_Round_Func)Round_Up_To_Grid;</a>
<a name="ln4704">  }</a>
<a name="ln4705"> </a>
<a name="ln4706"> </a>
<a name="ln4707">  /*************************************************************************/</a>
<a name="ln4708">  /*                                                                       */</a>
<a name="ln4709">  /* RDTG[]:       Round Down To Grid                                      */</a>
<a name="ln4710">  /* Opcode range: 0x7D                                                    */</a>
<a name="ln4711">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4712">  /*                                                                       */</a>
<a name="ln4713">  static void</a>
<a name="ln4714">  Ins_RDTG( TT_ExecContext  exc )</a>
<a name="ln4715">  {</a>
<a name="ln4716">    exc-&gt;GS.round_state = TT_Round_Down_To_Grid;</a>
<a name="ln4717">    exc-&gt;func_round     = (TT_Round_Func)Round_Down_To_Grid;</a>
<a name="ln4718">  }</a>
<a name="ln4719"> </a>
<a name="ln4720"> </a>
<a name="ln4721">  /*************************************************************************/</a>
<a name="ln4722">  /*                                                                       */</a>
<a name="ln4723">  /* ROFF[]:       Round OFF                                               */</a>
<a name="ln4724">  /* Opcode range: 0x7A                                                    */</a>
<a name="ln4725">  /* Stack:        --&gt;                                                     */</a>
<a name="ln4726">  /*                                                                       */</a>
<a name="ln4727">  static void</a>
<a name="ln4728">  Ins_ROFF( TT_ExecContext  exc )</a>
<a name="ln4729">  {</a>
<a name="ln4730">    exc-&gt;GS.round_state = TT_Round_Off;</a>
<a name="ln4731">    exc-&gt;func_round     = (TT_Round_Func)Round_None;</a>
<a name="ln4732">  }</a>
<a name="ln4733"> </a>
<a name="ln4734"> </a>
<a name="ln4735">  /*************************************************************************/</a>
<a name="ln4736">  /*                                                                       */</a>
<a name="ln4737">  /* SROUND[]:     Super ROUND                                             */</a>
<a name="ln4738">  /* Opcode range: 0x76                                                    */</a>
<a name="ln4739">  /* Stack:        Eint8 --&gt;                                               */</a>
<a name="ln4740">  /*                                                                       */</a>
<a name="ln4741">  static void</a>
<a name="ln4742">  Ins_SROUND( TT_ExecContext  exc,</a>
<a name="ln4743">              FT_Long*        args )</a>
<a name="ln4744">  {</a>
<a name="ln4745">    SetSuperRound( exc, 0x4000, args[0] );</a>
<a name="ln4746"> </a>
<a name="ln4747">    exc-&gt;GS.round_state = TT_Round_Super;</a>
<a name="ln4748">    exc-&gt;func_round     = (TT_Round_Func)Round_Super;</a>
<a name="ln4749">  }</a>
<a name="ln4750"> </a>
<a name="ln4751"> </a>
<a name="ln4752">  /*************************************************************************/</a>
<a name="ln4753">  /*                                                                       */</a>
<a name="ln4754">  /* S45ROUND[]:   Super ROUND 45 degrees                                  */</a>
<a name="ln4755">  /* Opcode range: 0x77                                                    */</a>
<a name="ln4756">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln4757">  /*                                                                       */</a>
<a name="ln4758">  static void</a>
<a name="ln4759">  Ins_S45ROUND( TT_ExecContext  exc,</a>
<a name="ln4760">                FT_Long*        args )</a>
<a name="ln4761">  {</a>
<a name="ln4762">    SetSuperRound( exc, 0x2D41, args[0] );</a>
<a name="ln4763"> </a>
<a name="ln4764">    exc-&gt;GS.round_state = TT_Round_Super_45;</a>
<a name="ln4765">    exc-&gt;func_round     = (TT_Round_Func)Round_Super_45;</a>
<a name="ln4766">  }</a>
<a name="ln4767"> </a>
<a name="ln4768"> </a>
<a name="ln4769">  /*************************************************************************/</a>
<a name="ln4770">  /*                                                                       */</a>
<a name="ln4771">  /* GC[a]:        Get Coordinate projected onto                           */</a>
<a name="ln4772">  /* Opcode range: 0x46-0x47                                               */</a>
<a name="ln4773">  /* Stack:        uint32 --&gt; f26.6                                        */</a>
<a name="ln4774">  /*                                                                       */</a>
<a name="ln4775">  /* XXX: UNDOCUMENTED: Measures from the original glyph must be taken     */</a>
<a name="ln4776">  /*      along the dual projection vector!                                */</a>
<a name="ln4777">  /*                                                                       */</a>
<a name="ln4778">  static void</a>
<a name="ln4779">  Ins_GC( TT_ExecContext  exc,</a>
<a name="ln4780">          FT_Long*        args )</a>
<a name="ln4781">  {</a>
<a name="ln4782">    FT_ULong    L;</a>
<a name="ln4783">    FT_F26Dot6  R;</a>
<a name="ln4784"> </a>
<a name="ln4785"> </a>
<a name="ln4786">    L = (FT_ULong)args[0];</a>
<a name="ln4787"> </a>
<a name="ln4788">    if ( BOUNDSL( L, exc-&gt;zp2.n_points ) )</a>
<a name="ln4789">    {</a>
<a name="ln4790">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln4791">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln4792">      R = 0;</a>
<a name="ln4793">    }</a>
<a name="ln4794">    else</a>
<a name="ln4795">    {</a>
<a name="ln4796">      if ( exc-&gt;opcode &amp; 1 )</a>
<a name="ln4797">        R = FAST_DUALPROJ( &amp;exc-&gt;zp2.org[L] );</a>
<a name="ln4798">      else</a>
<a name="ln4799">        R = FAST_PROJECT( &amp;exc-&gt;zp2.cur[L] );</a>
<a name="ln4800">    }</a>
<a name="ln4801"> </a>
<a name="ln4802">    args[0] = R;</a>
<a name="ln4803">  }</a>
<a name="ln4804"> </a>
<a name="ln4805"> </a>
<a name="ln4806">  /*************************************************************************/</a>
<a name="ln4807">  /*                                                                       */</a>
<a name="ln4808">  /* SCFS[]:       Set Coordinate From Stack                               */</a>
<a name="ln4809">  /* Opcode range: 0x48                                                    */</a>
<a name="ln4810">  /* Stack:        f26.6 uint32 --&gt;                                        */</a>
<a name="ln4811">  /*                                                                       */</a>
<a name="ln4812">  /* Formula:                                                              */</a>
<a name="ln4813">  /*                                                                       */</a>
<a name="ln4814">  /*   OA := OA + ( value - OA.p )/( f.p ) * f                             */</a>
<a name="ln4815">  /*                                                                       */</a>
<a name="ln4816">  static void</a>
<a name="ln4817">  Ins_SCFS( TT_ExecContext  exc,</a>
<a name="ln4818">            FT_Long*        args )</a>
<a name="ln4819">  {</a>
<a name="ln4820">    FT_Long    K;</a>
<a name="ln4821">    FT_UShort  L;</a>
<a name="ln4822"> </a>
<a name="ln4823"> </a>
<a name="ln4824">    L = (FT_UShort)args[0];</a>
<a name="ln4825"> </a>
<a name="ln4826">    if ( BOUNDS( L, exc-&gt;zp2.n_points ) )</a>
<a name="ln4827">    {</a>
<a name="ln4828">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln4829">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln4830">      return;</a>
<a name="ln4831">    }</a>
<a name="ln4832"> </a>
<a name="ln4833">    K = FAST_PROJECT( &amp;exc-&gt;zp2.cur[L] );</a>
<a name="ln4834"> </a>
<a name="ln4835">    exc-&gt;func_move( exc, &amp;exc-&gt;zp2, L, args[1] - K );</a>
<a name="ln4836"> </a>
<a name="ln4837">    /* UNDOCUMENTED!  The MS rasterizer does that with */</a>
<a name="ln4838">    /* twilight points (confirmed by Greg Hitchcock)   */</a>
<a name="ln4839">    if ( exc-&gt;GS.gep2 == 0 )</a>
<a name="ln4840">      exc-&gt;zp2.org[L] = exc-&gt;zp2.cur[L];</a>
<a name="ln4841">  }</a>
<a name="ln4842"> </a>
<a name="ln4843"> </a>
<a name="ln4844">  /*************************************************************************/</a>
<a name="ln4845">  /*                                                                       */</a>
<a name="ln4846">  /* MD[a]:        Measure Distance                                        */</a>
<a name="ln4847">  /* Opcode range: 0x49-0x4A                                               */</a>
<a name="ln4848">  /* Stack:        uint32 uint32 --&gt; f26.6                                 */</a>
<a name="ln4849">  /*                                                                       */</a>
<a name="ln4850">  /* XXX: UNDOCUMENTED: Measure taken in the original glyph must be along  */</a>
<a name="ln4851">  /*                    the dual projection vector.                        */</a>
<a name="ln4852">  /*                                                                       */</a>
<a name="ln4853">  /* XXX: UNDOCUMENTED: Flag attributes are inverted!                      */</a>
<a name="ln4854">  /*                      0 =&gt; measure distance in original outline        */</a>
<a name="ln4855">  /*                      1 =&gt; measure distance in grid-fitted outline     */</a>
<a name="ln4856">  /*                                                                       */</a>
<a name="ln4857">  /* XXX: UNDOCUMENTED: `zp0 - zp1', and not `zp2 - zp1!                   */</a>
<a name="ln4858">  /*                                                                       */</a>
<a name="ln4859">  static void</a>
<a name="ln4860">  Ins_MD( TT_ExecContext  exc,</a>
<a name="ln4861">          FT_Long*        args )</a>
<a name="ln4862">  {</a>
<a name="ln4863">    FT_UShort   K, L;</a>
<a name="ln4864">    FT_F26Dot6  D;</a>
<a name="ln4865"> </a>
<a name="ln4866"> </a>
<a name="ln4867">    K = (FT_UShort)args[1];</a>
<a name="ln4868">    L = (FT_UShort)args[0];</a>
<a name="ln4869"> </a>
<a name="ln4870">    if ( BOUNDS( L, exc-&gt;zp0.n_points ) ||</a>
<a name="ln4871">         BOUNDS( K, exc-&gt;zp1.n_points ) )</a>
<a name="ln4872">    {</a>
<a name="ln4873">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln4874">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln4875">      D = 0;</a>
<a name="ln4876">    }</a>
<a name="ln4877">    else</a>
<a name="ln4878">    {</a>
<a name="ln4879">      if ( exc-&gt;opcode &amp; 1 )</a>
<a name="ln4880">        D = PROJECT( exc-&gt;zp0.cur + L, exc-&gt;zp1.cur + K );</a>
<a name="ln4881">      else</a>
<a name="ln4882">      {</a>
<a name="ln4883">        /* XXX: UNDOCUMENTED: twilight zone special case */</a>
<a name="ln4884"> </a>
<a name="ln4885">        if ( exc-&gt;GS.gep0 == 0 || exc-&gt;GS.gep1 == 0 )</a>
<a name="ln4886">        {</a>
<a name="ln4887">          FT_Vector*  vec1 = exc-&gt;zp0.org + L;</a>
<a name="ln4888">          FT_Vector*  vec2 = exc-&gt;zp1.org + K;</a>
<a name="ln4889"> </a>
<a name="ln4890"> </a>
<a name="ln4891">          D = DUALPROJ( vec1, vec2 );</a>
<a name="ln4892">        }</a>
<a name="ln4893">        else</a>
<a name="ln4894">        {</a>
<a name="ln4895">          FT_Vector*  vec1 = exc-&gt;zp0.orus + L;</a>
<a name="ln4896">          FT_Vector*  vec2 = exc-&gt;zp1.orus + K;</a>
<a name="ln4897"> </a>
<a name="ln4898"> </a>
<a name="ln4899">          if ( exc-&gt;metrics.x_scale == exc-&gt;metrics.y_scale )</a>
<a name="ln4900">          {</a>
<a name="ln4901">            /* this should be faster */</a>
<a name="ln4902">            D = DUALPROJ( vec1, vec2 );</a>
<a name="ln4903">            D = FT_MulFix( D, exc-&gt;metrics.x_scale );</a>
<a name="ln4904">          }</a>
<a name="ln4905">          else</a>
<a name="ln4906">          {</a>
<a name="ln4907">            FT_Vector  vec;</a>
<a name="ln4908"> </a>
<a name="ln4909"> </a>
<a name="ln4910">            vec.x = FT_MulFix( vec1-&gt;x - vec2-&gt;x, exc-&gt;metrics.x_scale );</a>
<a name="ln4911">            vec.y = FT_MulFix( vec1-&gt;y - vec2-&gt;y, exc-&gt;metrics.y_scale );</a>
<a name="ln4912"> </a>
<a name="ln4913">            D = FAST_DUALPROJ( &amp;vec );</a>
<a name="ln4914">          }</a>
<a name="ln4915">        }</a>
<a name="ln4916">      }</a>
<a name="ln4917">    }</a>
<a name="ln4918"> </a>
<a name="ln4919">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln4920">    /* Disable Type 2 Vacuform Rounds - e.g. Arial Narrow */</a>
<a name="ln4921">    if ( SUBPIXEL_HINTING   &amp;&amp;</a>
<a name="ln4922">         exc-&gt;ignore_x_mode &amp;&amp;</a>
<a name="ln4923">         FT_ABS( D ) == 64  )</a>
<a name="ln4924">      D += 1;</a>
<a name="ln4925">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln4926"> </a>
<a name="ln4927">    args[0] = D;</a>
<a name="ln4928">  }</a>
<a name="ln4929"> </a>
<a name="ln4930"> </a>
<a name="ln4931">  /*************************************************************************/</a>
<a name="ln4932">  /*                                                                       */</a>
<a name="ln4933">  /* SDPvTL[a]:    Set Dual PVector to Line                                */</a>
<a name="ln4934">  /* Opcode range: 0x86-0x87                                               */</a>
<a name="ln4935">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln4936">  /*                                                                       */</a>
<a name="ln4937">  static void</a>
<a name="ln4938">  Ins_SDPVTL( TT_ExecContext  exc,</a>
<a name="ln4939">              FT_Long*        args )</a>
<a name="ln4940">  {</a>
<a name="ln4941">    FT_Long    A, B, C;</a>
<a name="ln4942">    FT_UShort  p1, p2;            /* was FT_Int in pas type ERROR */</a>
<a name="ln4943"> </a>
<a name="ln4944">    FT_Byte  opcode = exc-&gt;opcode;</a>
<a name="ln4945"> </a>
<a name="ln4946"> </a>
<a name="ln4947">    p1 = (FT_UShort)args[1];</a>
<a name="ln4948">    p2 = (FT_UShort)args[0];</a>
<a name="ln4949"> </a>
<a name="ln4950">    if ( BOUNDS( p2, exc-&gt;zp1.n_points ) ||</a>
<a name="ln4951">         BOUNDS( p1, exc-&gt;zp2.n_points ) )</a>
<a name="ln4952">    {</a>
<a name="ln4953">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln4954">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln4955">      return;</a>
<a name="ln4956">    }</a>
<a name="ln4957"> </a>
<a name="ln4958">    {</a>
<a name="ln4959">      FT_Vector* v1 = exc-&gt;zp1.org + p2;</a>
<a name="ln4960">      FT_Vector* v2 = exc-&gt;zp2.org + p1;</a>
<a name="ln4961"> </a>
<a name="ln4962"> </a>
<a name="ln4963">      A = v1-&gt;x - v2-&gt;x;</a>
<a name="ln4964">      B = v1-&gt;y - v2-&gt;y;</a>
<a name="ln4965"> </a>
<a name="ln4966">      /* If v1 == v2, SDPvTL behaves the same as */</a>
<a name="ln4967">      /* SVTCA[X], respectively.                 */</a>
<a name="ln4968">      /*                                         */</a>
<a name="ln4969">      /* Confirmed by Greg Hitchcock.            */</a>
<a name="ln4970"> </a>
<a name="ln4971">      if ( A == 0 &amp;&amp; B == 0 )</a>
<a name="ln4972">      {</a>
<a name="ln4973">        A      = 0x4000;</a>
<a name="ln4974">        opcode = 0;</a>
<a name="ln4975">      }</a>
<a name="ln4976">    }</a>
<a name="ln4977"> </a>
<a name="ln4978">    if ( ( opcode &amp; 1 ) != 0 )</a>
<a name="ln4979">    {</a>
<a name="ln4980">      C =  B;   /* counter clockwise rotation */</a>
<a name="ln4981">      B =  A;</a>
<a name="ln4982">      A = -C;</a>
<a name="ln4983">    }</a>
<a name="ln4984"> </a>
<a name="ln4985">    Normalize( A, B, &amp;exc-&gt;GS.dualVector );</a>
<a name="ln4986"> </a>
<a name="ln4987">    {</a>
<a name="ln4988">      FT_Vector*  v1 = exc-&gt;zp1.cur + p2;</a>
<a name="ln4989">      FT_Vector*  v2 = exc-&gt;zp2.cur + p1;</a>
<a name="ln4990"> </a>
<a name="ln4991"> </a>
<a name="ln4992">      A = v1-&gt;x - v2-&gt;x;</a>
<a name="ln4993">      B = v1-&gt;y - v2-&gt;y;</a>
<a name="ln4994"> </a>
<a name="ln4995">      if ( A == 0 &amp;&amp; B == 0 )</a>
<a name="ln4996">      {</a>
<a name="ln4997">        A      = 0x4000;</a>
<a name="ln4998">        opcode = 0;</a>
<a name="ln4999">      }</a>
<a name="ln5000">    }</a>
<a name="ln5001"> </a>
<a name="ln5002">    if ( ( opcode &amp; 1 ) != 0 )</a>
<a name="ln5003">    {</a>
<a name="ln5004">      C =  B;   /* counter clockwise rotation */</a>
<a name="ln5005">      B =  A;</a>
<a name="ln5006">      A = -C;</a>
<a name="ln5007">    }</a>
<a name="ln5008"> </a>
<a name="ln5009">    Normalize( A, B, &amp;exc-&gt;GS.projVector );</a>
<a name="ln5010">    GUESS_VECTOR( freeVector );</a>
<a name="ln5011">    Compute_Funcs( exc );</a>
<a name="ln5012">  }</a>
<a name="ln5013"> </a>
<a name="ln5014"> </a>
<a name="ln5015">  /*************************************************************************/</a>
<a name="ln5016">  /*                                                                       */</a>
<a name="ln5017">  /* SZP0[]:       Set Zone Pointer 0                                      */</a>
<a name="ln5018">  /* Opcode range: 0x13                                                    */</a>
<a name="ln5019">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln5020">  /*                                                                       */</a>
<a name="ln5021">  static void</a>
<a name="ln5022">  Ins_SZP0( TT_ExecContext  exc,</a>
<a name="ln5023">            FT_Long*        args )</a>
<a name="ln5024">  {</a>
<a name="ln5025">    switch ( (FT_Int)args[0] )</a>
<a name="ln5026">    {</a>
<a name="ln5027">    case 0:</a>
<a name="ln5028">      exc-&gt;zp0 = exc-&gt;twilight;</a>
<a name="ln5029">      break;</a>
<a name="ln5030"> </a>
<a name="ln5031">    case 1:</a>
<a name="ln5032">      exc-&gt;zp0 = exc-&gt;pts;</a>
<a name="ln5033">      break;</a>
<a name="ln5034"> </a>
<a name="ln5035">    default:</a>
<a name="ln5036">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5037">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5038">      return;</a>
<a name="ln5039">    }</a>
<a name="ln5040"> </a>
<a name="ln5041">    exc-&gt;GS.gep0 = (FT_UShort)args[0];</a>
<a name="ln5042">  }</a>
<a name="ln5043"> </a>
<a name="ln5044"> </a>
<a name="ln5045">  /*************************************************************************/</a>
<a name="ln5046">  /*                                                                       */</a>
<a name="ln5047">  /* SZP1[]:       Set Zone Pointer 1                                      */</a>
<a name="ln5048">  /* Opcode range: 0x14                                                    */</a>
<a name="ln5049">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln5050">  /*                                                                       */</a>
<a name="ln5051">  static void</a>
<a name="ln5052">  Ins_SZP1( TT_ExecContext  exc,</a>
<a name="ln5053">            FT_Long*        args )</a>
<a name="ln5054">  {</a>
<a name="ln5055">    switch ( (FT_Int)args[0] )</a>
<a name="ln5056">    {</a>
<a name="ln5057">    case 0:</a>
<a name="ln5058">      exc-&gt;zp1 = exc-&gt;twilight;</a>
<a name="ln5059">      break;</a>
<a name="ln5060"> </a>
<a name="ln5061">    case 1:</a>
<a name="ln5062">      exc-&gt;zp1 = exc-&gt;pts;</a>
<a name="ln5063">      break;</a>
<a name="ln5064"> </a>
<a name="ln5065">    default:</a>
<a name="ln5066">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5067">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5068">      return;</a>
<a name="ln5069">    }</a>
<a name="ln5070"> </a>
<a name="ln5071">    exc-&gt;GS.gep1 = (FT_UShort)args[0];</a>
<a name="ln5072">  }</a>
<a name="ln5073"> </a>
<a name="ln5074"> </a>
<a name="ln5075">  /*************************************************************************/</a>
<a name="ln5076">  /*                                                                       */</a>
<a name="ln5077">  /* SZP2[]:       Set Zone Pointer 2                                      */</a>
<a name="ln5078">  /* Opcode range: 0x15                                                    */</a>
<a name="ln5079">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln5080">  /*                                                                       */</a>
<a name="ln5081">  static void</a>
<a name="ln5082">  Ins_SZP2( TT_ExecContext  exc,</a>
<a name="ln5083">            FT_Long*        args )</a>
<a name="ln5084">  {</a>
<a name="ln5085">    switch ( (FT_Int)args[0] )</a>
<a name="ln5086">    {</a>
<a name="ln5087">    case 0:</a>
<a name="ln5088">      exc-&gt;zp2 = exc-&gt;twilight;</a>
<a name="ln5089">      break;</a>
<a name="ln5090"> </a>
<a name="ln5091">    case 1:</a>
<a name="ln5092">      exc-&gt;zp2 = exc-&gt;pts;</a>
<a name="ln5093">      break;</a>
<a name="ln5094"> </a>
<a name="ln5095">    default:</a>
<a name="ln5096">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5097">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5098">      return;</a>
<a name="ln5099">    }</a>
<a name="ln5100"> </a>
<a name="ln5101">    exc-&gt;GS.gep2 = (FT_UShort)args[0];</a>
<a name="ln5102">  }</a>
<a name="ln5103"> </a>
<a name="ln5104"> </a>
<a name="ln5105">  /*************************************************************************/</a>
<a name="ln5106">  /*                                                                       */</a>
<a name="ln5107">  /* SZPS[]:       Set Zone PointerS                                       */</a>
<a name="ln5108">  /* Opcode range: 0x16                                                    */</a>
<a name="ln5109">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln5110">  /*                                                                       */</a>
<a name="ln5111">  static void</a>
<a name="ln5112">  Ins_SZPS( TT_ExecContext  exc,</a>
<a name="ln5113">            FT_Long*        args )</a>
<a name="ln5114">  {</a>
<a name="ln5115">    switch ( (FT_Int)args[0] )</a>
<a name="ln5116">    {</a>
<a name="ln5117">    case 0:</a>
<a name="ln5118">      exc-&gt;zp0 = exc-&gt;twilight;</a>
<a name="ln5119">      break;</a>
<a name="ln5120"> </a>
<a name="ln5121">    case 1:</a>
<a name="ln5122">      exc-&gt;zp0 = exc-&gt;pts;</a>
<a name="ln5123">      break;</a>
<a name="ln5124"> </a>
<a name="ln5125">    default:</a>
<a name="ln5126">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5127">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5128">      return;</a>
<a name="ln5129">    }</a>
<a name="ln5130"> </a>
<a name="ln5131">    exc-&gt;zp1 = exc-&gt;zp0;</a>
<a name="ln5132">    exc-&gt;zp2 = exc-&gt;zp0;</a>
<a name="ln5133"> </a>
<a name="ln5134">    exc-&gt;GS.gep0 = (FT_UShort)args[0];</a>
<a name="ln5135">    exc-&gt;GS.gep1 = (FT_UShort)args[0];</a>
<a name="ln5136">    exc-&gt;GS.gep2 = (FT_UShort)args[0];</a>
<a name="ln5137">  }</a>
<a name="ln5138"> </a>
<a name="ln5139"> </a>
<a name="ln5140">  /*************************************************************************/</a>
<a name="ln5141">  /*                                                                       */</a>
<a name="ln5142">  /* INSTCTRL[]:   INSTruction ConTRoL                                     */</a>
<a name="ln5143">  /* Opcode range: 0x8E                                                    */</a>
<a name="ln5144">  /* Stack:        int32 int32 --&gt;                                         */</a>
<a name="ln5145">  /*                                                                       */</a>
<a name="ln5146">  static void</a>
<a name="ln5147">  Ins_INSTCTRL( TT_ExecContext  exc,</a>
<a name="ln5148">                FT_Long*        args )</a>
<a name="ln5149">  {</a>
<a name="ln5150">    FT_ULong  K, L, Kf;</a>
<a name="ln5151"> </a>
<a name="ln5152"> </a>
<a name="ln5153">    K = (FT_ULong)args[1];</a>
<a name="ln5154">    L = (FT_ULong)args[0];</a>
<a name="ln5155"> </a>
<a name="ln5156">    /* selector values cannot be `OR'ed;                 */</a>
<a name="ln5157">    /* they are indices starting with index 1, not flags */</a>
<a name="ln5158">    if ( K &lt; 1 || K &gt; 3 )</a>
<a name="ln5159">    {</a>
<a name="ln5160">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5161">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5162">      return;</a>
<a name="ln5163">    }</a>
<a name="ln5164"> </a>
<a name="ln5165">    /* convert index to flag value */</a>
<a name="ln5166">    Kf = 1 &lt;&lt; ( K - 1 );</a>
<a name="ln5167"> </a>
<a name="ln5168">    if ( L != 0 )</a>
<a name="ln5169">    {</a>
<a name="ln5170">      /* arguments to selectors look like flag values */</a>
<a name="ln5171">      if ( L != Kf )</a>
<a name="ln5172">      {</a>
<a name="ln5173">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5174">          exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5175">        return;</a>
<a name="ln5176">      }</a>
<a name="ln5177">    }</a>
<a name="ln5178"> </a>
<a name="ln5179">    exc-&gt;GS.instruct_control &amp;= ~(FT_Byte)Kf;</a>
<a name="ln5180">    exc-&gt;GS.instruct_control |= (FT_Byte)L;</a>
<a name="ln5181"> </a>
<a name="ln5182">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5183">    /* INSTCTRL modifying flag 3 also has an effect */</a>
<a name="ln5184">    /* outside of the CVT program                   */</a>
<a name="ln5185">    if ( K == 3 )</a>
<a name="ln5186">      exc-&gt;ignore_x_mode = FT_BOOL( L == 4 );</a>
<a name="ln5187">#endif</a>
<a name="ln5188">  }</a>
<a name="ln5189"> </a>
<a name="ln5190"> </a>
<a name="ln5191">  /*************************************************************************/</a>
<a name="ln5192">  /*                                                                       */</a>
<a name="ln5193">  /* SCANCTRL[]:   SCAN ConTRoL                                            */</a>
<a name="ln5194">  /* Opcode range: 0x85                                                    */</a>
<a name="ln5195">  /* Stack:        uint32? --&gt;                                             */</a>
<a name="ln5196">  /*                                                                       */</a>
<a name="ln5197">  static void</a>
<a name="ln5198">  Ins_SCANCTRL( TT_ExecContext  exc,</a>
<a name="ln5199">                FT_Long*        args )</a>
<a name="ln5200">  {</a>
<a name="ln5201">    FT_Int  A;</a>
<a name="ln5202"> </a>
<a name="ln5203"> </a>
<a name="ln5204">    /* Get Threshold */</a>
<a name="ln5205">    A = (FT_Int)( args[0] &amp; 0xFF );</a>
<a name="ln5206"> </a>
<a name="ln5207">    if ( A == 0xFF )</a>
<a name="ln5208">    {</a>
<a name="ln5209">      exc-&gt;GS.scan_control = TRUE;</a>
<a name="ln5210">      return;</a>
<a name="ln5211">    }</a>
<a name="ln5212">    else if ( A == 0 )</a>
<a name="ln5213">    {</a>
<a name="ln5214">      exc-&gt;GS.scan_control = FALSE;</a>
<a name="ln5215">      return;</a>
<a name="ln5216">    }</a>
<a name="ln5217"> </a>
<a name="ln5218">    if ( ( args[0] &amp; 0x100 ) != 0 &amp;&amp; exc-&gt;tt_metrics.ppem &lt;= A )</a>
<a name="ln5219">      exc-&gt;GS.scan_control = TRUE;</a>
<a name="ln5220"> </a>
<a name="ln5221">    if ( ( args[0] &amp; 0x200 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )</a>
<a name="ln5222">      exc-&gt;GS.scan_control = TRUE;</a>
<a name="ln5223"> </a>
<a name="ln5224">    if ( ( args[0] &amp; 0x400 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )</a>
<a name="ln5225">      exc-&gt;GS.scan_control = TRUE;</a>
<a name="ln5226"> </a>
<a name="ln5227">    if ( ( args[0] &amp; 0x800 ) != 0 &amp;&amp; exc-&gt;tt_metrics.ppem &gt; A )</a>
<a name="ln5228">      exc-&gt;GS.scan_control = FALSE;</a>
<a name="ln5229"> </a>
<a name="ln5230">    if ( ( args[0] &amp; 0x1000 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )</a>
<a name="ln5231">      exc-&gt;GS.scan_control = FALSE;</a>
<a name="ln5232"> </a>
<a name="ln5233">    if ( ( args[0] &amp; 0x2000 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )</a>
<a name="ln5234">      exc-&gt;GS.scan_control = FALSE;</a>
<a name="ln5235">  }</a>
<a name="ln5236"> </a>
<a name="ln5237"> </a>
<a name="ln5238">  /*************************************************************************/</a>
<a name="ln5239">  /*                                                                       */</a>
<a name="ln5240">  /* SCANTYPE[]:   SCAN TYPE                                               */</a>
<a name="ln5241">  /* Opcode range: 0x8D                                                    */</a>
<a name="ln5242">  /* Stack:        uint32? --&gt;                                             */</a>
<a name="ln5243">  /*                                                                       */</a>
<a name="ln5244">  static void</a>
<a name="ln5245">  Ins_SCANTYPE( TT_ExecContext  exc,</a>
<a name="ln5246">                FT_Long*        args )</a>
<a name="ln5247">  {</a>
<a name="ln5248">    if ( args[0] &gt;= 0 )</a>
<a name="ln5249">      exc-&gt;GS.scan_type = (FT_Int)args[0];</a>
<a name="ln5250">  }</a>
<a name="ln5251"> </a>
<a name="ln5252"> </a>
<a name="ln5253">  /*************************************************************************/</a>
<a name="ln5254">  /*                                                                       */</a>
<a name="ln5255">  /* MANAGING OUTLINES                                                     */</a>
<a name="ln5256">  /*                                                                       */</a>
<a name="ln5257">  /*************************************************************************/</a>
<a name="ln5258"> </a>
<a name="ln5259"> </a>
<a name="ln5260">  /*************************************************************************/</a>
<a name="ln5261">  /*                                                                       */</a>
<a name="ln5262">  /* FLIPPT[]:     FLIP PoinT                                              */</a>
<a name="ln5263">  /* Opcode range: 0x80                                                    */</a>
<a name="ln5264">  /* Stack:        uint32... --&gt;                                           */</a>
<a name="ln5265">  /*                                                                       */</a>
<a name="ln5266">  static void</a>
<a name="ln5267">  Ins_FLIPPT( TT_ExecContext  exc )</a>
<a name="ln5268">  {</a>
<a name="ln5269">    FT_UShort  point;</a>
<a name="ln5270"> </a>
<a name="ln5271"> </a>
<a name="ln5272">    if ( exc-&gt;top &lt; exc-&gt;GS.loop )</a>
<a name="ln5273">    {</a>
<a name="ln5274">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5275">        exc-&gt;error = FT_THROW( Too_Few_Arguments );</a>
<a name="ln5276">      goto Fail;</a>
<a name="ln5277">    }</a>
<a name="ln5278"> </a>
<a name="ln5279">    while ( exc-&gt;GS.loop &gt; 0 )</a>
<a name="ln5280">    {</a>
<a name="ln5281">      exc-&gt;args--;</a>
<a name="ln5282"> </a>
<a name="ln5283">      point = (FT_UShort)exc-&gt;stack[exc-&gt;args];</a>
<a name="ln5284"> </a>
<a name="ln5285">      if ( BOUNDS( point, exc-&gt;pts.n_points ) )</a>
<a name="ln5286">      {</a>
<a name="ln5287">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5288">        {</a>
<a name="ln5289">          exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5290">          return;</a>
<a name="ln5291">        }</a>
<a name="ln5292">      }</a>
<a name="ln5293">      else</a>
<a name="ln5294">        exc-&gt;pts.tags[point] ^= FT_CURVE_TAG_ON;</a>
<a name="ln5295"> </a>
<a name="ln5296">      exc-&gt;GS.loop--;</a>
<a name="ln5297">    }</a>
<a name="ln5298"> </a>
<a name="ln5299">  Fail:</a>
<a name="ln5300">    exc-&gt;GS.loop = 1;</a>
<a name="ln5301">    exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln5302">  }</a>
<a name="ln5303"> </a>
<a name="ln5304"> </a>
<a name="ln5305">  /*************************************************************************/</a>
<a name="ln5306">  /*                                                                       */</a>
<a name="ln5307">  /* FLIPRGON[]:   FLIP RanGe ON                                           */</a>
<a name="ln5308">  /* Opcode range: 0x81                                                    */</a>
<a name="ln5309">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln5310">  /*                                                                       */</a>
<a name="ln5311">  static void</a>
<a name="ln5312">  Ins_FLIPRGON( TT_ExecContext  exc,</a>
<a name="ln5313">                FT_Long*        args )</a>
<a name="ln5314">  {</a>
<a name="ln5315">    FT_UShort  I, K, L;</a>
<a name="ln5316"> </a>
<a name="ln5317"> </a>
<a name="ln5318">    K = (FT_UShort)args[1];</a>
<a name="ln5319">    L = (FT_UShort)args[0];</a>
<a name="ln5320"> </a>
<a name="ln5321">    if ( BOUNDS( K, exc-&gt;pts.n_points ) ||</a>
<a name="ln5322">         BOUNDS( L, exc-&gt;pts.n_points ) )</a>
<a name="ln5323">    {</a>
<a name="ln5324">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5325">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5326">      return;</a>
<a name="ln5327">    }</a>
<a name="ln5328"> </a>
<a name="ln5329">    for ( I = L; I &lt;= K; I++ )</a>
<a name="ln5330">      exc-&gt;pts.tags[I] |= FT_CURVE_TAG_ON;</a>
<a name="ln5331">  }</a>
<a name="ln5332"> </a>
<a name="ln5333"> </a>
<a name="ln5334">  /*************************************************************************/</a>
<a name="ln5335">  /*                                                                       */</a>
<a name="ln5336">  /* FLIPRGOFF:    FLIP RanGe OFF                                          */</a>
<a name="ln5337">  /* Opcode range: 0x82                                                    */</a>
<a name="ln5338">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln5339">  /*                                                                       */</a>
<a name="ln5340">  static void</a>
<a name="ln5341">  Ins_FLIPRGOFF( TT_ExecContext  exc,</a>
<a name="ln5342">                 FT_Long*        args )</a>
<a name="ln5343">  {</a>
<a name="ln5344">    FT_UShort  I, K, L;</a>
<a name="ln5345"> </a>
<a name="ln5346"> </a>
<a name="ln5347">    K = (FT_UShort)args[1];</a>
<a name="ln5348">    L = (FT_UShort)args[0];</a>
<a name="ln5349"> </a>
<a name="ln5350">    if ( BOUNDS( K, exc-&gt;pts.n_points ) ||</a>
<a name="ln5351">         BOUNDS( L, exc-&gt;pts.n_points ) )</a>
<a name="ln5352">    {</a>
<a name="ln5353">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5354">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5355">      return;</a>
<a name="ln5356">    }</a>
<a name="ln5357"> </a>
<a name="ln5358">    for ( I = L; I &lt;= K; I++ )</a>
<a name="ln5359">      exc-&gt;pts.tags[I] &amp;= ~FT_CURVE_TAG_ON;</a>
<a name="ln5360">  }</a>
<a name="ln5361"> </a>
<a name="ln5362"> </a>
<a name="ln5363">  static FT_Bool</a>
<a name="ln5364">  Compute_Point_Displacement( TT_ExecContext  exc,</a>
<a name="ln5365">                              FT_F26Dot6*     x,</a>
<a name="ln5366">                              FT_F26Dot6*     y,</a>
<a name="ln5367">                              TT_GlyphZone    zone,</a>
<a name="ln5368">                              FT_UShort*      refp )</a>
<a name="ln5369">  {</a>
<a name="ln5370">    TT_GlyphZoneRec  zp;</a>
<a name="ln5371">    FT_UShort        p;</a>
<a name="ln5372">    FT_F26Dot6       d;</a>
<a name="ln5373"> </a>
<a name="ln5374"> </a>
<a name="ln5375">    if ( exc-&gt;opcode &amp; 1 )</a>
<a name="ln5376">    {</a>
<a name="ln5377">      zp = exc-&gt;zp0;</a>
<a name="ln5378">      p  = exc-&gt;GS.rp1;</a>
<a name="ln5379">    }</a>
<a name="ln5380">    else</a>
<a name="ln5381">    {</a>
<a name="ln5382">      zp = exc-&gt;zp1;</a>
<a name="ln5383">      p  = exc-&gt;GS.rp2;</a>
<a name="ln5384">    }</a>
<a name="ln5385"> </a>
<a name="ln5386">    if ( BOUNDS( p, zp.n_points ) )</a>
<a name="ln5387">    {</a>
<a name="ln5388">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5389">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5390">      *refp = 0;</a>
<a name="ln5391">      return FAILURE;</a>
<a name="ln5392">    }</a>
<a name="ln5393"> </a>
<a name="ln5394">    *zone = zp;</a>
<a name="ln5395">    *refp = p;</a>
<a name="ln5396"> </a>
<a name="ln5397">    d = PROJECT( zp.cur + p, zp.org + p );</a>
<a name="ln5398"> </a>
<a name="ln5399">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln5400">    if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln5401">    {</a>
<a name="ln5402">      if ( exc-&gt;GS.both_x_axis )</a>
<a name="ln5403">      {</a>
<a name="ln5404">        *x = d;</a>
<a name="ln5405">        *y = 0;</a>
<a name="ln5406">      }</a>
<a name="ln5407">      else</a>
<a name="ln5408">      {</a>
<a name="ln5409">        *x = 0;</a>
<a name="ln5410">        *y = d;</a>
<a name="ln5411">      }</a>
<a name="ln5412">    }</a>
<a name="ln5413">    else</a>
<a name="ln5414">#endif</a>
<a name="ln5415">    {</a>
<a name="ln5416">      *x = FT_MulDiv( d, (FT_Long)exc-&gt;GS.freeVector.x, exc-&gt;F_dot_P );</a>
<a name="ln5417">      *y = FT_MulDiv( d, (FT_Long)exc-&gt;GS.freeVector.y, exc-&gt;F_dot_P );</a>
<a name="ln5418">    }</a>
<a name="ln5419"> </a>
<a name="ln5420">    return SUCCESS;</a>
<a name="ln5421">  }</a>
<a name="ln5422"> </a>
<a name="ln5423"> </a>
<a name="ln5424">  static void</a>
<a name="ln5425">  Move_Zp2_Point( TT_ExecContext  exc,</a>
<a name="ln5426">                  FT_UShort       point,</a>
<a name="ln5427">                  FT_F26Dot6      dx,</a>
<a name="ln5428">                  FT_F26Dot6      dy,</a>
<a name="ln5429">                  FT_Bool         touch )</a>
<a name="ln5430">  {</a>
<a name="ln5431">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln5432">    if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln5433">    {</a>
<a name="ln5434">      if ( exc-&gt;GS.both_x_axis )</a>
<a name="ln5435">      {</a>
<a name="ln5436">        exc-&gt;zp2.cur[point].x += dx;</a>
<a name="ln5437">        if ( touch )</a>
<a name="ln5438">          exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;</a>
<a name="ln5439">      }</a>
<a name="ln5440">      else</a>
<a name="ln5441">      {</a>
<a name="ln5442">        exc-&gt;zp2.cur[point].y += dy;</a>
<a name="ln5443">        if ( touch )</a>
<a name="ln5444">          exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;</a>
<a name="ln5445">      }</a>
<a name="ln5446">      return;</a>
<a name="ln5447">    }</a>
<a name="ln5448">#endif</a>
<a name="ln5449"> </a>
<a name="ln5450">    if ( exc-&gt;GS.freeVector.x != 0 )</a>
<a name="ln5451">    {</a>
<a name="ln5452">      exc-&gt;zp2.cur[point].x += dx;</a>
<a name="ln5453">      if ( touch )</a>
<a name="ln5454">        exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_X;</a>
<a name="ln5455">    }</a>
<a name="ln5456"> </a>
<a name="ln5457">    if ( exc-&gt;GS.freeVector.y != 0 )</a>
<a name="ln5458">    {</a>
<a name="ln5459">      exc-&gt;zp2.cur[point].y += dy;</a>
<a name="ln5460">      if ( touch )</a>
<a name="ln5461">        exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_Y;</a>
<a name="ln5462">    }</a>
<a name="ln5463">  }</a>
<a name="ln5464"> </a>
<a name="ln5465"> </a>
<a name="ln5466">  /*************************************************************************/</a>
<a name="ln5467">  /*                                                                       */</a>
<a name="ln5468">  /* SHP[a]:       SHift Point by the last point                           */</a>
<a name="ln5469">  /* Opcode range: 0x32-0x33                                               */</a>
<a name="ln5470">  /* Stack:        uint32... --&gt;                                           */</a>
<a name="ln5471">  /*                                                                       */</a>
<a name="ln5472">  static void</a>
<a name="ln5473">  Ins_SHP( TT_ExecContext  exc )</a>
<a name="ln5474">  {</a>
<a name="ln5475">    TT_GlyphZoneRec  zp;</a>
<a name="ln5476">    FT_UShort        refp;</a>
<a name="ln5477"> </a>
<a name="ln5478">    FT_F26Dot6       dx, dy;</a>
<a name="ln5479">    FT_UShort        point;</a>
<a name="ln5480"> </a>
<a name="ln5481"> </a>
<a name="ln5482">    if ( exc-&gt;top &lt; exc-&gt;GS.loop )</a>
<a name="ln5483">    {</a>
<a name="ln5484">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5485">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5486">      goto Fail;</a>
<a name="ln5487">    }</a>
<a name="ln5488"> </a>
<a name="ln5489">    if ( Compute_Point_Displacement( exc, &amp;dx, &amp;dy, &amp;zp, &amp;refp ) )</a>
<a name="ln5490">      return;</a>
<a name="ln5491"> </a>
<a name="ln5492">    while ( exc-&gt;GS.loop &gt; 0 )</a>
<a name="ln5493">    {</a>
<a name="ln5494">      exc-&gt;args--;</a>
<a name="ln5495">      point = (FT_UShort)exc-&gt;stack[exc-&gt;args];</a>
<a name="ln5496"> </a>
<a name="ln5497">      if ( BOUNDS( point, exc-&gt;zp2.n_points ) )</a>
<a name="ln5498">      {</a>
<a name="ln5499">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5500">        {</a>
<a name="ln5501">          exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5502">          return;</a>
<a name="ln5503">        }</a>
<a name="ln5504">      }</a>
<a name="ln5505">      else</a>
<a name="ln5506">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5507">      /* doesn't follow Cleartype spec but produces better result */</a>
<a name="ln5508">      if ( SUBPIXEL_HINTING   &amp;&amp;</a>
<a name="ln5509">           exc-&gt;ignore_x_mode )</a>
<a name="ln5510">        Move_Zp2_Point( exc, point, 0, dy, TRUE );</a>
<a name="ln5511">      else</a>
<a name="ln5512">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln5513">        Move_Zp2_Point( exc, point, dx, dy, TRUE );</a>
<a name="ln5514"> </a>
<a name="ln5515">      exc-&gt;GS.loop--;</a>
<a name="ln5516">    }</a>
<a name="ln5517"> </a>
<a name="ln5518">  Fail:</a>
<a name="ln5519">    exc-&gt;GS.loop = 1;</a>
<a name="ln5520">    exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln5521">  }</a>
<a name="ln5522"> </a>
<a name="ln5523"> </a>
<a name="ln5524">  /*************************************************************************/</a>
<a name="ln5525">  /*                                                                       */</a>
<a name="ln5526">  /* SHC[a]:       SHift Contour                                           */</a>
<a name="ln5527">  /* Opcode range: 0x34-35                                                 */</a>
<a name="ln5528">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln5529">  /*                                                                       */</a>
<a name="ln5530">  /* UNDOCUMENTED: According to Greg Hitchcock, there is one (virtual)     */</a>
<a name="ln5531">  /*               contour in the twilight zone, namely contour number     */</a>
<a name="ln5532">  /*               zero which includes all points of it.                   */</a>
<a name="ln5533">  /*                                                                       */</a>
<a name="ln5534">  static void</a>
<a name="ln5535">  Ins_SHC( TT_ExecContext  exc,</a>
<a name="ln5536">           FT_Long*        args )</a>
<a name="ln5537">  {</a>
<a name="ln5538">    TT_GlyphZoneRec  zp;</a>
<a name="ln5539">    FT_UShort        refp;</a>
<a name="ln5540">    FT_F26Dot6       dx, dy;</a>
<a name="ln5541"> </a>
<a name="ln5542">    FT_Short         contour, bounds;</a>
<a name="ln5543">    FT_UShort        start, limit, i;</a>
<a name="ln5544"> </a>
<a name="ln5545"> </a>
<a name="ln5546">    contour = (FT_Short)args[0];</a>
<a name="ln5547">    bounds  = ( exc-&gt;GS.gep2 == 0 ) ? 1 : exc-&gt;zp2.n_contours;</a>
<a name="ln5548"> </a>
<a name="ln5549">    if ( BOUNDS( contour, bounds ) )</a>
<a name="ln5550">    {</a>
<a name="ln5551">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5552">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5553">      return;</a>
<a name="ln5554">    }</a>
<a name="ln5555"> </a>
<a name="ln5556">    if ( Compute_Point_Displacement( exc, &amp;dx, &amp;dy, &amp;zp, &amp;refp ) )</a>
<a name="ln5557">      return;</a>
<a name="ln5558"> </a>
<a name="ln5559">    if ( contour == 0 )</a>
<a name="ln5560">      start = 0;</a>
<a name="ln5561">    else</a>
<a name="ln5562">      start = (FT_UShort)( exc-&gt;zp2.contours[contour - 1] + 1 -</a>
<a name="ln5563">                           exc-&gt;zp2.first_point );</a>
<a name="ln5564"> </a>
<a name="ln5565">    /* we use the number of points if in the twilight zone */</a>
<a name="ln5566">    if ( exc-&gt;GS.gep2 == 0 )</a>
<a name="ln5567">      limit = exc-&gt;zp2.n_points;</a>
<a name="ln5568">    else</a>
<a name="ln5569">      limit = (FT_UShort)( exc-&gt;zp2.contours[contour] -</a>
<a name="ln5570">                           exc-&gt;zp2.first_point + 1 );</a>
<a name="ln5571"> </a>
<a name="ln5572">    for ( i = start; i &lt; limit; i++ )</a>
<a name="ln5573">    {</a>
<a name="ln5574">      if ( zp.cur != exc-&gt;zp2.cur || refp != i )</a>
<a name="ln5575">        Move_Zp2_Point( exc, i, dx, dy, TRUE );</a>
<a name="ln5576">    }</a>
<a name="ln5577">  }</a>
<a name="ln5578"> </a>
<a name="ln5579"> </a>
<a name="ln5580">  /*************************************************************************/</a>
<a name="ln5581">  /*                                                                       */</a>
<a name="ln5582">  /* SHZ[a]:       SHift Zone                                              */</a>
<a name="ln5583">  /* Opcode range: 0x36-37                                                 */</a>
<a name="ln5584">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln5585">  /*                                                                       */</a>
<a name="ln5586">  static void</a>
<a name="ln5587">  Ins_SHZ( TT_ExecContext  exc,</a>
<a name="ln5588">           FT_Long*        args )</a>
<a name="ln5589">  {</a>
<a name="ln5590">    TT_GlyphZoneRec  zp;</a>
<a name="ln5591">    FT_UShort        refp;</a>
<a name="ln5592">    FT_F26Dot6       dx,</a>
<a name="ln5593">                     dy;</a>
<a name="ln5594"> </a>
<a name="ln5595">    FT_UShort        limit, i;</a>
<a name="ln5596"> </a>
<a name="ln5597"> </a>
<a name="ln5598">    if ( BOUNDS( args[0], 2 ) )</a>
<a name="ln5599">    {</a>
<a name="ln5600">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5601">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5602">      return;</a>
<a name="ln5603">    }</a>
<a name="ln5604"> </a>
<a name="ln5605">    if ( Compute_Point_Displacement( exc, &amp;dx, &amp;dy, &amp;zp, &amp;refp ) )</a>
<a name="ln5606">      return;</a>
<a name="ln5607"> </a>
<a name="ln5608">    /* XXX: UNDOCUMENTED! SHZ doesn't move the phantom points.     */</a>
<a name="ln5609">    /*      Twilight zone has no real contours, so use `n_points'. */</a>
<a name="ln5610">    /*      Normal zone's `n_points' includes phantoms, so must    */</a>
<a name="ln5611">    /*      use end of last contour.                               */</a>
<a name="ln5612">    if ( exc-&gt;GS.gep2 == 0 )</a>
<a name="ln5613">      limit = (FT_UShort)exc-&gt;zp2.n_points;</a>
<a name="ln5614">    else if ( exc-&gt;GS.gep2 == 1 &amp;&amp; exc-&gt;zp2.n_contours &gt; 0 )</a>
<a name="ln5615">      limit = (FT_UShort)( exc-&gt;zp2.contours[exc-&gt;zp2.n_contours - 1] + 1 );</a>
<a name="ln5616">    else</a>
<a name="ln5617">      limit = 0;</a>
<a name="ln5618"> </a>
<a name="ln5619">    /* XXX: UNDOCUMENTED! SHZ doesn't touch the points */</a>
<a name="ln5620">    for ( i = 0; i &lt; limit; i++ )</a>
<a name="ln5621">    {</a>
<a name="ln5622">      if ( zp.cur != exc-&gt;zp2.cur || refp != i )</a>
<a name="ln5623">        Move_Zp2_Point( exc, i, dx, dy, FALSE );</a>
<a name="ln5624">    }</a>
<a name="ln5625">  }</a>
<a name="ln5626"> </a>
<a name="ln5627"> </a>
<a name="ln5628">  /*************************************************************************/</a>
<a name="ln5629">  /*                                                                       */</a>
<a name="ln5630">  /* SHPIX[]:      SHift points by a PIXel amount                          */</a>
<a name="ln5631">  /* Opcode range: 0x38                                                    */</a>
<a name="ln5632">  /* Stack:        f26.6 uint32... --&gt;                                     */</a>
<a name="ln5633">  /*                                                                       */</a>
<a name="ln5634">  static void</a>
<a name="ln5635">  Ins_SHPIX( TT_ExecContext  exc,</a>
<a name="ln5636">             FT_Long*        args )</a>
<a name="ln5637">  {</a>
<a name="ln5638">    FT_F26Dot6  dx, dy;</a>
<a name="ln5639">    FT_UShort   point;</a>
<a name="ln5640">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5641">    FT_Int      B1, B2;</a>
<a name="ln5642">#endif</a>
<a name="ln5643"> </a>
<a name="ln5644"> </a>
<a name="ln5645">    if ( exc-&gt;top &lt; exc-&gt;GS.loop + 1 )</a>
<a name="ln5646">    {</a>
<a name="ln5647">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5648">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5649">      goto Fail;</a>
<a name="ln5650">    }</a>
<a name="ln5651"> </a>
<a name="ln5652">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln5653">    if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln5654">    {</a>
<a name="ln5655">      if ( exc-&gt;GS.both_x_axis )</a>
<a name="ln5656">      {</a>
<a name="ln5657">        dx = (FT_UInt32)args[0];</a>
<a name="ln5658">        dy = 0;</a>
<a name="ln5659">      }</a>
<a name="ln5660">      else</a>
<a name="ln5661">      {</a>
<a name="ln5662">        dx = 0;</a>
<a name="ln5663">        dy = (FT_UInt32)args[0];</a>
<a name="ln5664">      }</a>
<a name="ln5665">    }</a>
<a name="ln5666">    else</a>
<a name="ln5667">#endif</a>
<a name="ln5668">    {</a>
<a name="ln5669">      dx = TT_MulFix14( args[0], exc-&gt;GS.freeVector.x );</a>
<a name="ln5670">      dy = TT_MulFix14( args[0], exc-&gt;GS.freeVector.y );</a>
<a name="ln5671">    }</a>
<a name="ln5672"> </a>
<a name="ln5673">    while ( exc-&gt;GS.loop &gt; 0 )</a>
<a name="ln5674">    {</a>
<a name="ln5675">      exc-&gt;args--;</a>
<a name="ln5676"> </a>
<a name="ln5677">      point = (FT_UShort)exc-&gt;stack[exc-&gt;args];</a>
<a name="ln5678"> </a>
<a name="ln5679">      if ( BOUNDS( point, exc-&gt;zp2.n_points ) )</a>
<a name="ln5680">      {</a>
<a name="ln5681">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5682">        {</a>
<a name="ln5683">          exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5684">          return;</a>
<a name="ln5685">        }</a>
<a name="ln5686">      }</a>
<a name="ln5687">      else</a>
<a name="ln5688">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5689">      {</a>
<a name="ln5690">        /*  If not using ignore_x_mode rendering, allow ZP2 move.        */</a>
<a name="ln5691">        /*  If inline deltas aren't allowed, skip ZP2 move.              */</a>
<a name="ln5692">        /*  If using ignore_x_mode rendering, allow ZP2 point move if:   */</a>
<a name="ln5693">        /*   - freedom vector is y and sph_compatibility_mode is off     */</a>
<a name="ln5694">        /*   - the glyph is composite and the move is in the Y direction */</a>
<a name="ln5695">        /*   - the glyph is specifically set to allow SHPIX moves        */</a>
<a name="ln5696">        /*   - the move is on a previously Y-touched point               */</a>
<a name="ln5697"> </a>
<a name="ln5698">        if ( SUBPIXEL_HINTING   &amp;&amp;</a>
<a name="ln5699">             exc-&gt;ignore_x_mode )</a>
<a name="ln5700">        {</a>
<a name="ln5701">          /* save point for later comparison */</a>
<a name="ln5702">          if ( exc-&gt;GS.freeVector.y != 0 )</a>
<a name="ln5703">            B1 = exc-&gt;zp2.cur[point].y;</a>
<a name="ln5704">          else</a>
<a name="ln5705">            B1 = exc-&gt;zp2.cur[point].x;</a>
<a name="ln5706"> </a>
<a name="ln5707">          if ( !exc-&gt;face-&gt;sph_compatibility_mode &amp;&amp;</a>
<a name="ln5708">               exc-&gt;GS.freeVector.y != 0          )</a>
<a name="ln5709">          {</a>
<a name="ln5710">            Move_Zp2_Point( exc, point, dx, dy, TRUE );</a>
<a name="ln5711"> </a>
<a name="ln5712">            /* save new point */</a>
<a name="ln5713">            if ( exc-&gt;GS.freeVector.y != 0 )</a>
<a name="ln5714">            {</a>
<a name="ln5715">              B2 = exc-&gt;zp2.cur[point].y;</a>
<a name="ln5716"> </a>
<a name="ln5717">              /* reverse any disallowed moves */</a>
<a name="ln5718">              if ( ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &amp;&amp;</a>
<a name="ln5719">                   ( B1 &amp; 63 ) != 0                                           &amp;&amp;</a>
<a name="ln5720">                   ( B2 &amp; 63 ) != 0                                           &amp;&amp;</a>
<a name="ln5721">                   B1 != B2                                                   )</a>
<a name="ln5722">                Move_Zp2_Point( exc, point, -dx, -dy, TRUE );</a>
<a name="ln5723">            }</a>
<a name="ln5724">          }</a>
<a name="ln5725">          else if ( exc-&gt;face-&gt;sph_compatibility_mode )</a>
<a name="ln5726">          {</a>
<a name="ln5727">            if ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )</a>
<a name="ln5728">            {</a>
<a name="ln5729">              dx = FT_PIX_ROUND( B1 + dx ) - B1;</a>
<a name="ln5730">              dy = FT_PIX_ROUND( B1 + dy ) - B1;</a>
<a name="ln5731">            }</a>
<a name="ln5732"> </a>
<a name="ln5733">            /* skip post-iup deltas */</a>
<a name="ln5734">            if ( exc-&gt;iup_called                                          &amp;&amp;</a>
<a name="ln5735">                 ( ( exc-&gt;sph_in_func_flags &amp; SPH_FDEF_INLINE_DELTA_1 ) ||</a>
<a name="ln5736">                   ( exc-&gt;sph_in_func_flags &amp; SPH_FDEF_INLINE_DELTA_2 ) ) )</a>
<a name="ln5737">              goto Skip;</a>
<a name="ln5738"> </a>
<a name="ln5739">            if ( !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ALWAYS_SKIP_DELTAP ) &amp;&amp;</a>
<a name="ln5740">                  ( ( exc-&gt;is_composite &amp;&amp; exc-&gt;GS.freeVector.y != 0 ) ||</a>
<a name="ln5741">                    ( exc-&gt;zp2.tags[point] &amp; FT_CURVE_TAG_TOUCH_Y )    ||</a>
<a name="ln5742">                    ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_DO_SHPIX )      )  )</a>
<a name="ln5743">              Move_Zp2_Point( exc, point, 0, dy, TRUE );</a>
<a name="ln5744"> </a>
<a name="ln5745">            /* save new point */</a>
<a name="ln5746">            if ( exc-&gt;GS.freeVector.y != 0 )</a>
<a name="ln5747">            {</a>
<a name="ln5748">              B2 = exc-&gt;zp2.cur[point].y;</a>
<a name="ln5749"> </a>
<a name="ln5750">              /* reverse any disallowed moves */</a>
<a name="ln5751">              if ( ( B1 &amp; 63 ) == 0 &amp;&amp;</a>
<a name="ln5752">                   ( B2 &amp; 63 ) != 0 &amp;&amp;</a>
<a name="ln5753">                   B1 != B2         )</a>
<a name="ln5754">                Move_Zp2_Point( exc, point, 0, -dy, TRUE );</a>
<a name="ln5755">            }</a>
<a name="ln5756">          }</a>
<a name="ln5757">          else if ( exc-&gt;sph_in_func_flags &amp; SPH_FDEF_TYPEMAN_DIAGENDCTRL )</a>
<a name="ln5758">            Move_Zp2_Point( exc, point, dx, dy, TRUE );</a>
<a name="ln5759">        }</a>
<a name="ln5760">        else</a>
<a name="ln5761">          Move_Zp2_Point( exc, point, dx, dy, TRUE );</a>
<a name="ln5762">      }</a>
<a name="ln5763"> </a>
<a name="ln5764">    Skip:</a>
<a name="ln5765"> </a>
<a name="ln5766">#else /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln5767"> </a>
<a name="ln5768">      Move_Zp2_Point( exc, point, dx, dy, TRUE );</a>
<a name="ln5769"> </a>
<a name="ln5770">#endif /* !TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln5771"> </a>
<a name="ln5772">      exc-&gt;GS.loop--;</a>
<a name="ln5773">    }</a>
<a name="ln5774"> </a>
<a name="ln5775">  Fail:</a>
<a name="ln5776">    exc-&gt;GS.loop = 1;</a>
<a name="ln5777">    exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln5778">  }</a>
<a name="ln5779"> </a>
<a name="ln5780"> </a>
<a name="ln5781">  /*************************************************************************/</a>
<a name="ln5782">  /*                                                                       */</a>
<a name="ln5783">  /* MSIRP[a]:     Move Stack Indirect Relative Position                   */</a>
<a name="ln5784">  /* Opcode range: 0x3A-0x3B                                               */</a>
<a name="ln5785">  /* Stack:        f26.6 uint32 --&gt;                                        */</a>
<a name="ln5786">  /*                                                                       */</a>
<a name="ln5787">  static void</a>
<a name="ln5788">  Ins_MSIRP( TT_ExecContext  exc,</a>
<a name="ln5789">             FT_Long*        args )</a>
<a name="ln5790">  {</a>
<a name="ln5791">    FT_UShort   point;</a>
<a name="ln5792">    FT_F26Dot6  distance;</a>
<a name="ln5793"> </a>
<a name="ln5794">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5795">    FT_F26Dot6  control_value_cutin = 0; /* pacify compiler */</a>
<a name="ln5796"> </a>
<a name="ln5797"> </a>
<a name="ln5798">    if ( SUBPIXEL_HINTING )</a>
<a name="ln5799">    {</a>
<a name="ln5800">      control_value_cutin = exc-&gt;GS.control_value_cutin;</a>
<a name="ln5801"> </a>
<a name="ln5802">      if ( exc-&gt;ignore_x_mode                                 &amp;&amp;</a>
<a name="ln5803">           exc-&gt;GS.freeVector.x != 0                          &amp;&amp;</a>
<a name="ln5804">           !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )</a>
<a name="ln5805">        control_value_cutin = 0;</a>
<a name="ln5806">    }</a>
<a name="ln5807"> </a>
<a name="ln5808">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln5809"> </a>
<a name="ln5810">    point = (FT_UShort)args[0];</a>
<a name="ln5811"> </a>
<a name="ln5812">    if ( BOUNDS( point,       exc-&gt;zp1.n_points ) ||</a>
<a name="ln5813">         BOUNDS( exc-&gt;GS.rp0, exc-&gt;zp0.n_points ) )</a>
<a name="ln5814">    {</a>
<a name="ln5815">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5816">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5817">      return;</a>
<a name="ln5818">    }</a>
<a name="ln5819"> </a>
<a name="ln5820">    /* UNDOCUMENTED!  The MS rasterizer does that with */</a>
<a name="ln5821">    /* twilight points (confirmed by Greg Hitchcock)   */</a>
<a name="ln5822">    if ( exc-&gt;GS.gep1 == 0 )</a>
<a name="ln5823">    {</a>
<a name="ln5824">      exc-&gt;zp1.org[point] = exc-&gt;zp0.org[exc-&gt;GS.rp0];</a>
<a name="ln5825">      exc-&gt;func_move_orig( exc, &amp;exc-&gt;zp1, point, args[1] );</a>
<a name="ln5826">      exc-&gt;zp1.cur[point] = exc-&gt;zp1.org[point];</a>
<a name="ln5827">    }</a>
<a name="ln5828"> </a>
<a name="ln5829">    distance = PROJECT( exc-&gt;zp1.cur + point, exc-&gt;zp0.cur + exc-&gt;GS.rp0 );</a>
<a name="ln5830"> </a>
<a name="ln5831">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5832">    /* subpixel hinting - make MSIRP respect CVT cut-in; */</a>
<a name="ln5833">    if ( SUBPIXEL_HINTING                                    &amp;&amp;</a>
<a name="ln5834">         exc-&gt;ignore_x_mode                                  &amp;&amp;</a>
<a name="ln5835">         exc-&gt;GS.freeVector.x != 0                           &amp;&amp;</a>
<a name="ln5836">         FT_ABS( distance - args[1] ) &gt;= control_value_cutin )</a>
<a name="ln5837">      distance = args[1];</a>
<a name="ln5838">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln5839"> </a>
<a name="ln5840">    exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, args[1] - distance );</a>
<a name="ln5841"> </a>
<a name="ln5842">    exc-&gt;GS.rp1 = exc-&gt;GS.rp0;</a>
<a name="ln5843">    exc-&gt;GS.rp2 = point;</a>
<a name="ln5844"> </a>
<a name="ln5845">    if ( ( exc-&gt;opcode &amp; 1 ) != 0 )</a>
<a name="ln5846">      exc-&gt;GS.rp0 = point;</a>
<a name="ln5847">  }</a>
<a name="ln5848"> </a>
<a name="ln5849"> </a>
<a name="ln5850">  /*************************************************************************/</a>
<a name="ln5851">  /*                                                                       */</a>
<a name="ln5852">  /* MDAP[a]:      Move Direct Absolute Point                              */</a>
<a name="ln5853">  /* Opcode range: 0x2E-0x2F                                               */</a>
<a name="ln5854">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln5855">  /*                                                                       */</a>
<a name="ln5856">  static void</a>
<a name="ln5857">  Ins_MDAP( TT_ExecContext  exc,</a>
<a name="ln5858">            FT_Long*        args )</a>
<a name="ln5859">  {</a>
<a name="ln5860">    FT_UShort   point;</a>
<a name="ln5861">    FT_F26Dot6  cur_dist;</a>
<a name="ln5862">    FT_F26Dot6  distance;</a>
<a name="ln5863"> </a>
<a name="ln5864"> </a>
<a name="ln5865">    point = (FT_UShort)args[0];</a>
<a name="ln5866"> </a>
<a name="ln5867">    if ( BOUNDS( point, exc-&gt;zp0.n_points ) )</a>
<a name="ln5868">    {</a>
<a name="ln5869">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5870">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5871">      return;</a>
<a name="ln5872">    }</a>
<a name="ln5873"> </a>
<a name="ln5874">    if ( ( exc-&gt;opcode &amp; 1 ) != 0 )</a>
<a name="ln5875">    {</a>
<a name="ln5876">      cur_dist = FAST_PROJECT( &amp;exc-&gt;zp0.cur[point] );</a>
<a name="ln5877">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5878">      if ( SUBPIXEL_HINTING          &amp;&amp;</a>
<a name="ln5879">           exc-&gt;ignore_x_mode        &amp;&amp;</a>
<a name="ln5880">           exc-&gt;GS.freeVector.x != 0 )</a>
<a name="ln5881">        distance = Round_None(</a>
<a name="ln5882">                     exc,</a>
<a name="ln5883">                     cur_dist,</a>
<a name="ln5884">                     exc-&gt;tt_metrics.compensations[0] ) - cur_dist;</a>
<a name="ln5885">      else</a>
<a name="ln5886">#endif</a>
<a name="ln5887">        distance = exc-&gt;func_round(</a>
<a name="ln5888">                     exc,</a>
<a name="ln5889">                     cur_dist,</a>
<a name="ln5890">                     exc-&gt;tt_metrics.compensations[0] ) - cur_dist;</a>
<a name="ln5891">    }</a>
<a name="ln5892">    else</a>
<a name="ln5893">      distance = 0;</a>
<a name="ln5894"> </a>
<a name="ln5895">    exc-&gt;func_move( exc, &amp;exc-&gt;zp0, point, distance );</a>
<a name="ln5896"> </a>
<a name="ln5897">    exc-&gt;GS.rp0 = point;</a>
<a name="ln5898">    exc-&gt;GS.rp1 = point;</a>
<a name="ln5899">  }</a>
<a name="ln5900"> </a>
<a name="ln5901"> </a>
<a name="ln5902">  /*************************************************************************/</a>
<a name="ln5903">  /*                                                                       */</a>
<a name="ln5904">  /* MIAP[a]:      Move Indirect Absolute Point                            */</a>
<a name="ln5905">  /* Opcode range: 0x3E-0x3F                                               */</a>
<a name="ln5906">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln5907">  /*                                                                       */</a>
<a name="ln5908">  static void</a>
<a name="ln5909">  Ins_MIAP( TT_ExecContext  exc,</a>
<a name="ln5910">            FT_Long*        args )</a>
<a name="ln5911">  {</a>
<a name="ln5912">    FT_ULong    cvtEntry;</a>
<a name="ln5913">    FT_UShort   point;</a>
<a name="ln5914">    FT_F26Dot6  distance;</a>
<a name="ln5915">    FT_F26Dot6  org_dist;</a>
<a name="ln5916">    FT_F26Dot6  control_value_cutin;</a>
<a name="ln5917"> </a>
<a name="ln5918"> </a>
<a name="ln5919">    control_value_cutin = exc-&gt;GS.control_value_cutin;</a>
<a name="ln5920">    cvtEntry            = (FT_ULong)args[1];</a>
<a name="ln5921">    point               = (FT_UShort)args[0];</a>
<a name="ln5922"> </a>
<a name="ln5923">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5924">    if ( SUBPIXEL_HINTING                                   &amp;&amp;</a>
<a name="ln5925">         exc-&gt;ignore_x_mode                                 &amp;&amp;</a>
<a name="ln5926">         exc-&gt;GS.freeVector.x != 0                          &amp;&amp;</a>
<a name="ln5927">         exc-&gt;GS.freeVector.y == 0                          &amp;&amp;</a>
<a name="ln5928">         !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )</a>
<a name="ln5929">      control_value_cutin = 0;</a>
<a name="ln5930">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln5931"> </a>
<a name="ln5932">    if ( BOUNDS( point,     exc-&gt;zp0.n_points ) ||</a>
<a name="ln5933">         BOUNDSL( cvtEntry, exc-&gt;cvtSize )      )</a>
<a name="ln5934">    {</a>
<a name="ln5935">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln5936">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln5937">      goto Fail;</a>
<a name="ln5938">    }</a>
<a name="ln5939"> </a>
<a name="ln5940">    /* UNDOCUMENTED!                                                      */</a>
<a name="ln5941">    /*                                                                    */</a>
<a name="ln5942">    /* The behaviour of an MIAP instruction is quite different when used  */</a>
<a name="ln5943">    /* in the twilight zone.                                              */</a>
<a name="ln5944">    /*                                                                    */</a>
<a name="ln5945">    /* First, no control value cut-in test is performed as it would fail  */</a>
<a name="ln5946">    /* anyway.  Second, the original point, i.e. (org_x,org_y) of         */</a>
<a name="ln5947">    /* zp0.point, is set to the absolute, unrounded distance found in the */</a>
<a name="ln5948">    /* CVT.                                                               */</a>
<a name="ln5949">    /*                                                                    */</a>
<a name="ln5950">    /* This is used in the CVT programs of the Microsoft fonts Arial,     */</a>
<a name="ln5951">    /* Times, etc., in order to re-adjust some key font heights.  It      */</a>
<a name="ln5952">    /* allows the use of the IP instruction in the twilight zone, which   */</a>
<a name="ln5953">    /* otherwise would be invalid according to the specification.         */</a>
<a name="ln5954">    /*                                                                    */</a>
<a name="ln5955">    /* We implement it with a special sequence for the twilight zone.     */</a>
<a name="ln5956">    /* This is a bad hack, but it seems to work.                          */</a>
<a name="ln5957">    /*                                                                    */</a>
<a name="ln5958">    /* Confirmed by Greg Hitchcock.                                       */</a>
<a name="ln5959"> </a>
<a name="ln5960">    distance = exc-&gt;func_read_cvt( exc, cvtEntry );</a>
<a name="ln5961"> </a>
<a name="ln5962">    if ( exc-&gt;GS.gep0 == 0 )   /* If in twilight zone */</a>
<a name="ln5963">    {</a>
<a name="ln5964">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5965">      /* Only adjust if not in sph_compatibility_mode or ignore_x_mode. */</a>
<a name="ln5966">      /* Determined via experimentation and may be incorrect...         */</a>
<a name="ln5967">      if ( !SUBPIXEL_HINTING                      ||</a>
<a name="ln5968">           ( !exc-&gt;ignore_x_mode                ||</a>
<a name="ln5969">             !exc-&gt;face-&gt;sph_compatibility_mode ) )</a>
<a name="ln5970">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln5971">        exc-&gt;zp0.org[point].x = TT_MulFix14( distance,</a>
<a name="ln5972">                                             exc-&gt;GS.freeVector.x );</a>
<a name="ln5973">      exc-&gt;zp0.org[point].y = TT_MulFix14( distance,</a>
<a name="ln5974">                                           exc-&gt;GS.freeVector.y ),</a>
<a name="ln5975">      exc-&gt;zp0.cur[point]   = exc-&gt;zp0.org[point];</a>
<a name="ln5976">    }</a>
<a name="ln5977">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5978">    if ( SUBPIXEL_HINTING                               &amp;&amp;</a>
<a name="ln5979">         exc-&gt;ignore_x_mode                             &amp;&amp;</a>
<a name="ln5980">         ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_MIAP_HACK ) &amp;&amp;</a>
<a name="ln5981">         distance &gt; 0                                   &amp;&amp;</a>
<a name="ln5982">         exc-&gt;GS.freeVector.y != 0                      )</a>
<a name="ln5983">      distance = 0;</a>
<a name="ln5984">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln5985"> </a>
<a name="ln5986">    org_dist = FAST_PROJECT( &amp;exc-&gt;zp0.cur[point] );</a>
<a name="ln5987"> </a>
<a name="ln5988">    if ( ( exc-&gt;opcode &amp; 1 ) != 0 )   /* rounding and control cut-in flag */</a>
<a name="ln5989">    {</a>
<a name="ln5990">      if ( FT_ABS( distance - org_dist ) &gt; control_value_cutin )</a>
<a name="ln5991">        distance = org_dist;</a>
<a name="ln5992"> </a>
<a name="ln5993">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln5994">      if ( SUBPIXEL_HINTING          &amp;&amp;</a>
<a name="ln5995">           exc-&gt;ignore_x_mode        &amp;&amp;</a>
<a name="ln5996">           exc-&gt;GS.freeVector.x != 0 )</a>
<a name="ln5997">        distance = Round_None( exc,</a>
<a name="ln5998">                               distance,</a>
<a name="ln5999">                               exc-&gt;tt_metrics.compensations[0] );</a>
<a name="ln6000">      else</a>
<a name="ln6001">#endif</a>
<a name="ln6002">        distance = exc-&gt;func_round( exc,</a>
<a name="ln6003">                                    distance,</a>
<a name="ln6004">                                    exc-&gt;tt_metrics.compensations[0] );</a>
<a name="ln6005">    }</a>
<a name="ln6006"> </a>
<a name="ln6007">    exc-&gt;func_move( exc, &amp;exc-&gt;zp0, point, distance - org_dist );</a>
<a name="ln6008"> </a>
<a name="ln6009">  Fail:</a>
<a name="ln6010">    exc-&gt;GS.rp0 = point;</a>
<a name="ln6011">    exc-&gt;GS.rp1 = point;</a>
<a name="ln6012">  }</a>
<a name="ln6013"> </a>
<a name="ln6014"> </a>
<a name="ln6015">  /*************************************************************************/</a>
<a name="ln6016">  /*                                                                       */</a>
<a name="ln6017">  /* MDRP[abcde]:  Move Direct Relative Point                              */</a>
<a name="ln6018">  /* Opcode range: 0xC0-0xDF                                               */</a>
<a name="ln6019">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln6020">  /*                                                                       */</a>
<a name="ln6021">  static void</a>
<a name="ln6022">  Ins_MDRP( TT_ExecContext  exc,</a>
<a name="ln6023">            FT_Long*        args )</a>
<a name="ln6024">  {</a>
<a name="ln6025">    FT_UShort   point;</a>
<a name="ln6026">    FT_F26Dot6  org_dist, distance, minimum_distance;</a>
<a name="ln6027"> </a>
<a name="ln6028"> </a>
<a name="ln6029">    minimum_distance = exc-&gt;GS.minimum_distance;</a>
<a name="ln6030"> </a>
<a name="ln6031">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6032">    if ( SUBPIXEL_HINTING                                   &amp;&amp;</a>
<a name="ln6033">         exc-&gt;ignore_x_mode                                 &amp;&amp;</a>
<a name="ln6034">         exc-&gt;GS.freeVector.x != 0                          &amp;&amp;</a>
<a name="ln6035">         !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )</a>
<a name="ln6036">      minimum_distance = 0;</a>
<a name="ln6037">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6038"> </a>
<a name="ln6039">    point = (FT_UShort)args[0];</a>
<a name="ln6040"> </a>
<a name="ln6041">    if ( BOUNDS( point,       exc-&gt;zp1.n_points ) ||</a>
<a name="ln6042">         BOUNDS( exc-&gt;GS.rp0, exc-&gt;zp0.n_points ) )</a>
<a name="ln6043">    {</a>
<a name="ln6044">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6045">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6046">      goto Fail;</a>
<a name="ln6047">    }</a>
<a name="ln6048"> </a>
<a name="ln6049">    /* XXX: Is there some undocumented feature while in the */</a>
<a name="ln6050">    /*      twilight zone?                                  */</a>
<a name="ln6051"> </a>
<a name="ln6052">    /* XXX: UNDOCUMENTED: twilight zone special case */</a>
<a name="ln6053"> </a>
<a name="ln6054">    if ( exc-&gt;GS.gep0 == 0 || exc-&gt;GS.gep1 == 0 )</a>
<a name="ln6055">    {</a>
<a name="ln6056">      FT_Vector*  vec1 = &amp;exc-&gt;zp1.org[point];</a>
<a name="ln6057">      FT_Vector*  vec2 = &amp;exc-&gt;zp0.org[exc-&gt;GS.rp0];</a>
<a name="ln6058"> </a>
<a name="ln6059"> </a>
<a name="ln6060">      org_dist = DUALPROJ( vec1, vec2 );</a>
<a name="ln6061">    }</a>
<a name="ln6062">    else</a>
<a name="ln6063">    {</a>
<a name="ln6064">      FT_Vector*  vec1 = &amp;exc-&gt;zp1.orus[point];</a>
<a name="ln6065">      FT_Vector*  vec2 = &amp;exc-&gt;zp0.orus[exc-&gt;GS.rp0];</a>
<a name="ln6066"> </a>
<a name="ln6067"> </a>
<a name="ln6068">      if ( exc-&gt;metrics.x_scale == exc-&gt;metrics.y_scale )</a>
<a name="ln6069">      {</a>
<a name="ln6070">        /* this should be faster */</a>
<a name="ln6071">        org_dist = DUALPROJ( vec1, vec2 );</a>
<a name="ln6072">        org_dist = FT_MulFix( org_dist, exc-&gt;metrics.x_scale );</a>
<a name="ln6073">      }</a>
<a name="ln6074">      else</a>
<a name="ln6075">      {</a>
<a name="ln6076">        FT_Vector  vec;</a>
<a name="ln6077"> </a>
<a name="ln6078"> </a>
<a name="ln6079">        vec.x = FT_MulFix( vec1-&gt;x - vec2-&gt;x, exc-&gt;metrics.x_scale );</a>
<a name="ln6080">        vec.y = FT_MulFix( vec1-&gt;y - vec2-&gt;y, exc-&gt;metrics.y_scale );</a>
<a name="ln6081"> </a>
<a name="ln6082">        org_dist = FAST_DUALPROJ( &amp;vec );</a>
<a name="ln6083">      }</a>
<a name="ln6084">    }</a>
<a name="ln6085"> </a>
<a name="ln6086">    /* single width cut-in test */</a>
<a name="ln6087"> </a>
<a name="ln6088">    if ( FT_ABS( org_dist - exc-&gt;GS.single_width_value ) &lt;</a>
<a name="ln6089">         exc-&gt;GS.single_width_cutin )</a>
<a name="ln6090">    {</a>
<a name="ln6091">      if ( org_dist &gt;= 0 )</a>
<a name="ln6092">        org_dist = exc-&gt;GS.single_width_value;</a>
<a name="ln6093">      else</a>
<a name="ln6094">        org_dist = -exc-&gt;GS.single_width_value;</a>
<a name="ln6095">    }</a>
<a name="ln6096"> </a>
<a name="ln6097">    /* round flag */</a>
<a name="ln6098"> </a>
<a name="ln6099">    if ( ( exc-&gt;opcode &amp; 4 ) != 0 )</a>
<a name="ln6100">    {</a>
<a name="ln6101">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6102">      if ( SUBPIXEL_HINTING          &amp;&amp;</a>
<a name="ln6103">           exc-&gt;ignore_x_mode        &amp;&amp;</a>
<a name="ln6104">           exc-&gt;GS.freeVector.x != 0 )</a>
<a name="ln6105">        distance = Round_None(</a>
<a name="ln6106">                     exc,</a>
<a name="ln6107">                     org_dist,</a>
<a name="ln6108">                     exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );</a>
<a name="ln6109">      else</a>
<a name="ln6110">#endif</a>
<a name="ln6111">        distance = exc-&gt;func_round(</a>
<a name="ln6112">                     exc,</a>
<a name="ln6113">                     org_dist,</a>
<a name="ln6114">                     exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );</a>
<a name="ln6115">    }</a>
<a name="ln6116">    else</a>
<a name="ln6117">      distance = Round_None(</a>
<a name="ln6118">                   exc,</a>
<a name="ln6119">                   org_dist,</a>
<a name="ln6120">                   exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );</a>
<a name="ln6121"> </a>
<a name="ln6122">    /* minimum distance flag */</a>
<a name="ln6123"> </a>
<a name="ln6124">    if ( ( exc-&gt;opcode &amp; 8 ) != 0 )</a>
<a name="ln6125">    {</a>
<a name="ln6126">      if ( org_dist &gt;= 0 )</a>
<a name="ln6127">      {</a>
<a name="ln6128">        if ( distance &lt; minimum_distance )</a>
<a name="ln6129">          distance = minimum_distance;</a>
<a name="ln6130">      }</a>
<a name="ln6131">      else</a>
<a name="ln6132">      {</a>
<a name="ln6133">        if ( distance &gt; -minimum_distance )</a>
<a name="ln6134">          distance = -minimum_distance;</a>
<a name="ln6135">      }</a>
<a name="ln6136">    }</a>
<a name="ln6137"> </a>
<a name="ln6138">    /* now move the point */</a>
<a name="ln6139"> </a>
<a name="ln6140">    org_dist = PROJECT( exc-&gt;zp1.cur + point, exc-&gt;zp0.cur + exc-&gt;GS.rp0 );</a>
<a name="ln6141"> </a>
<a name="ln6142">    exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, distance - org_dist );</a>
<a name="ln6143"> </a>
<a name="ln6144">  Fail:</a>
<a name="ln6145">    exc-&gt;GS.rp1 = exc-&gt;GS.rp0;</a>
<a name="ln6146">    exc-&gt;GS.rp2 = point;</a>
<a name="ln6147"> </a>
<a name="ln6148">    if ( ( exc-&gt;opcode &amp; 16 ) != 0 )</a>
<a name="ln6149">      exc-&gt;GS.rp0 = point;</a>
<a name="ln6150">  }</a>
<a name="ln6151"> </a>
<a name="ln6152"> </a>
<a name="ln6153">  /*************************************************************************/</a>
<a name="ln6154">  /*                                                                       */</a>
<a name="ln6155">  /* MIRP[abcde]:  Move Indirect Relative Point                            */</a>
<a name="ln6156">  /* Opcode range: 0xE0-0xFF                                               */</a>
<a name="ln6157">  /* Stack:        int32? uint32 --&gt;                                       */</a>
<a name="ln6158">  /*                                                                       */</a>
<a name="ln6159">  static void</a>
<a name="ln6160">  Ins_MIRP( TT_ExecContext  exc,</a>
<a name="ln6161">            FT_Long*        args )</a>
<a name="ln6162">  {</a>
<a name="ln6163">    FT_UShort   point;</a>
<a name="ln6164">    FT_ULong    cvtEntry;</a>
<a name="ln6165"> </a>
<a name="ln6166">    FT_F26Dot6  cvt_dist,</a>
<a name="ln6167">                distance,</a>
<a name="ln6168">                cur_dist,</a>
<a name="ln6169">                org_dist,</a>
<a name="ln6170">                control_value_cutin,</a>
<a name="ln6171">                minimum_distance;</a>
<a name="ln6172">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6173">    FT_Int      B1           = 0; /* pacify compiler */</a>
<a name="ln6174">    FT_Int      B2           = 0;</a>
<a name="ln6175">    FT_Bool     reverse_move = FALSE;</a>
<a name="ln6176">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6177"> </a>
<a name="ln6178"> </a>
<a name="ln6179">    minimum_distance    = exc-&gt;GS.minimum_distance;</a>
<a name="ln6180">    control_value_cutin = exc-&gt;GS.control_value_cutin;</a>
<a name="ln6181">    point               = (FT_UShort)args[0];</a>
<a name="ln6182">    cvtEntry            = (FT_ULong)( args[1] + 1 );</a>
<a name="ln6183"> </a>
<a name="ln6184">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6185">    if ( SUBPIXEL_HINTING                                   &amp;&amp;</a>
<a name="ln6186">         exc-&gt;ignore_x_mode                                 &amp;&amp;</a>
<a name="ln6187">         exc-&gt;GS.freeVector.x != 0                          &amp;&amp;</a>
<a name="ln6188">         !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NORMAL_ROUND ) )</a>
<a name="ln6189">      control_value_cutin = minimum_distance = 0;</a>
<a name="ln6190">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6191"> </a>
<a name="ln6192">    /* XXX: UNDOCUMENTED! cvt[-1] = 0 always */</a>
<a name="ln6193"> </a>
<a name="ln6194">    if ( BOUNDS( point,       exc-&gt;zp1.n_points ) ||</a>
<a name="ln6195">         BOUNDSL( cvtEntry,   exc-&gt;cvtSize + 1 )  ||</a>
<a name="ln6196">         BOUNDS( exc-&gt;GS.rp0, exc-&gt;zp0.n_points ) )</a>
<a name="ln6197">    {</a>
<a name="ln6198">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6199">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6200">      goto Fail;</a>
<a name="ln6201">    }</a>
<a name="ln6202"> </a>
<a name="ln6203">    if ( !cvtEntry )</a>
<a name="ln6204">      cvt_dist = 0;</a>
<a name="ln6205">    else</a>
<a name="ln6206">      cvt_dist = exc-&gt;func_read_cvt( exc, cvtEntry - 1 );</a>
<a name="ln6207"> </a>
<a name="ln6208">    /* single width test */</a>
<a name="ln6209"> </a>
<a name="ln6210">    if ( FT_ABS( cvt_dist - exc-&gt;GS.single_width_value ) &lt;</a>
<a name="ln6211">         exc-&gt;GS.single_width_cutin )</a>
<a name="ln6212">    {</a>
<a name="ln6213">      if ( cvt_dist &gt;= 0 )</a>
<a name="ln6214">        cvt_dist =  exc-&gt;GS.single_width_value;</a>
<a name="ln6215">      else</a>
<a name="ln6216">        cvt_dist = -exc-&gt;GS.single_width_value;</a>
<a name="ln6217">    }</a>
<a name="ln6218"> </a>
<a name="ln6219">    /* UNDOCUMENTED!  The MS rasterizer does that with */</a>
<a name="ln6220">    /* twilight points (confirmed by Greg Hitchcock)   */</a>
<a name="ln6221">    if ( exc-&gt;GS.gep1 == 0 )</a>
<a name="ln6222">    {</a>
<a name="ln6223">      exc-&gt;zp1.org[point].x = exc-&gt;zp0.org[exc-&gt;GS.rp0].x +</a>
<a name="ln6224">                              TT_MulFix14( cvt_dist,</a>
<a name="ln6225">                                           exc-&gt;GS.freeVector.x );</a>
<a name="ln6226">      exc-&gt;zp1.org[point].y = exc-&gt;zp0.org[exc-&gt;GS.rp0].y +</a>
<a name="ln6227">                              TT_MulFix14( cvt_dist,</a>
<a name="ln6228">                                           exc-&gt;GS.freeVector.y );</a>
<a name="ln6229">      exc-&gt;zp1.cur[point]   = exc-&gt;zp1.org[point];</a>
<a name="ln6230">    }</a>
<a name="ln6231"> </a>
<a name="ln6232">    org_dist = DUALPROJ( &amp;exc-&gt;zp1.org[point], &amp;exc-&gt;zp0.org[exc-&gt;GS.rp0] );</a>
<a name="ln6233">    cur_dist = PROJECT ( &amp;exc-&gt;zp1.cur[point], &amp;exc-&gt;zp0.cur[exc-&gt;GS.rp0] );</a>
<a name="ln6234"> </a>
<a name="ln6235">    /* auto-flip test */</a>
<a name="ln6236"> </a>
<a name="ln6237">    if ( exc-&gt;GS.auto_flip )</a>
<a name="ln6238">    {</a>
<a name="ln6239">      if ( ( org_dist ^ cvt_dist ) &lt; 0 )</a>
<a name="ln6240">        cvt_dist = -cvt_dist;</a>
<a name="ln6241">    }</a>
<a name="ln6242"> </a>
<a name="ln6243">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6244">    if ( SUBPIXEL_HINTING                                          &amp;&amp;</a>
<a name="ln6245">         exc-&gt;ignore_x_mode                                        &amp;&amp;</a>
<a name="ln6246">         exc-&gt;GS.freeVector.y != 0                                 &amp;&amp;</a>
<a name="ln6247">         ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_TIMES_NEW_ROMAN_HACK ) )</a>
<a name="ln6248">    {</a>
<a name="ln6249">      if ( cur_dist &lt; -64 )</a>
<a name="ln6250">        cvt_dist -= 16;</a>
<a name="ln6251">      else if ( cur_dist &gt; 64 &amp;&amp; cur_dist &lt; 84 )</a>
<a name="ln6252">        cvt_dist += 32;</a>
<a name="ln6253">    }</a>
<a name="ln6254">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6255"> </a>
<a name="ln6256">    /* control value cut-in and round */</a>
<a name="ln6257"> </a>
<a name="ln6258">    if ( ( exc-&gt;opcode &amp; 4 ) != 0 )</a>
<a name="ln6259">    {</a>
<a name="ln6260">      /* XXX: UNDOCUMENTED!  Only perform cut-in test when both points */</a>
<a name="ln6261">      /*      refer to the same zone.                                  */</a>
<a name="ln6262"> </a>
<a name="ln6263">      if ( exc-&gt;GS.gep0 == exc-&gt;GS.gep1 )</a>
<a name="ln6264">      {</a>
<a name="ln6265">        /* XXX: According to Greg Hitchcock, the following wording is */</a>
<a name="ln6266">        /*      the right one:                                        */</a>
<a name="ln6267">        /*                                                            */</a>
<a name="ln6268">        /*        When the absolute difference between the value in   */</a>
<a name="ln6269">        /*        the table [CVT] and the measurement directly from   */</a>
<a name="ln6270">        /*        the outline is _greater_ than the cut_in value, the */</a>
<a name="ln6271">        /*        outline measurement is used.                        */</a>
<a name="ln6272">        /*                                                            */</a>
<a name="ln6273">        /*      This is from `instgly.doc'.  The description in       */</a>
<a name="ln6274">        /*      `ttinst2.doc', version 1.66, is thus incorrect since  */</a>
<a name="ln6275">        /*      it implies `&gt;=' instead of `&gt;'.                       */</a>
<a name="ln6276"> </a>
<a name="ln6277">        if ( FT_ABS( cvt_dist - org_dist ) &gt; control_value_cutin )</a>
<a name="ln6278">          cvt_dist = org_dist;</a>
<a name="ln6279">      }</a>
<a name="ln6280"> </a>
<a name="ln6281">      distance = exc-&gt;func_round(</a>
<a name="ln6282">                   exc,</a>
<a name="ln6283">                   cvt_dist,</a>
<a name="ln6284">                   exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );</a>
<a name="ln6285">    }</a>
<a name="ln6286">    else</a>
<a name="ln6287">    {</a>
<a name="ln6288"> </a>
<a name="ln6289">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6290">      /* do cvt cut-in always in MIRP for sph */</a>
<a name="ln6291">      if ( SUBPIXEL_HINTING             &amp;&amp;</a>
<a name="ln6292">           exc-&gt;ignore_x_mode           &amp;&amp;</a>
<a name="ln6293">           exc-&gt;GS.gep0 == exc-&gt;GS.gep1 )</a>
<a name="ln6294">      {</a>
<a name="ln6295">        if ( FT_ABS( cvt_dist - org_dist ) &gt; control_value_cutin )</a>
<a name="ln6296">          cvt_dist = org_dist;</a>
<a name="ln6297">      }</a>
<a name="ln6298">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6299"> </a>
<a name="ln6300">      distance = Round_None(</a>
<a name="ln6301">                   exc,</a>
<a name="ln6302">                   cvt_dist,</a>
<a name="ln6303">                   exc-&gt;tt_metrics.compensations[exc-&gt;opcode &amp; 3] );</a>
<a name="ln6304">    }</a>
<a name="ln6305"> </a>
<a name="ln6306">    /* minimum distance test */</a>
<a name="ln6307"> </a>
<a name="ln6308">    if ( ( exc-&gt;opcode &amp; 8 ) != 0 )</a>
<a name="ln6309">    {</a>
<a name="ln6310">      if ( org_dist &gt;= 0 )</a>
<a name="ln6311">      {</a>
<a name="ln6312">        if ( distance &lt; minimum_distance )</a>
<a name="ln6313">          distance = minimum_distance;</a>
<a name="ln6314">      }</a>
<a name="ln6315">      else</a>
<a name="ln6316">      {</a>
<a name="ln6317">        if ( distance &gt; -minimum_distance )</a>
<a name="ln6318">          distance = -minimum_distance;</a>
<a name="ln6319">      }</a>
<a name="ln6320">    }</a>
<a name="ln6321"> </a>
<a name="ln6322">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6323">    if ( SUBPIXEL_HINTING )</a>
<a name="ln6324">    {</a>
<a name="ln6325">      B1 = exc-&gt;zp1.cur[point].y;</a>
<a name="ln6326"> </a>
<a name="ln6327">      /* Round moves if necessary */</a>
<a name="ln6328">      if ( exc-&gt;ignore_x_mode                                          &amp;&amp;</a>
<a name="ln6329">           exc-&gt;GS.freeVector.y != 0                                   &amp;&amp;</a>
<a name="ln6330">           ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES ) )</a>
<a name="ln6331">        distance = FT_PIX_ROUND( B1 + distance - cur_dist ) - B1 + cur_dist;</a>
<a name="ln6332"> </a>
<a name="ln6333">      if ( exc-&gt;ignore_x_mode                                      &amp;&amp;</a>
<a name="ln6334">           exc-&gt;GS.freeVector.y != 0                               &amp;&amp;</a>
<a name="ln6335">           ( exc-&gt;opcode &amp; 16 ) == 0                               &amp;&amp;</a>
<a name="ln6336">           ( exc-&gt;opcode &amp; 8 ) == 0                                &amp;&amp;</a>
<a name="ln6337">           ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_COURIER_NEW_2_HACK ) )</a>
<a name="ln6338">        distance += 64;</a>
<a name="ln6339">    }</a>
<a name="ln6340">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6341"> </a>
<a name="ln6342">    exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, distance - cur_dist );</a>
<a name="ln6343"> </a>
<a name="ln6344">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6345">    if ( SUBPIXEL_HINTING )</a>
<a name="ln6346">    {</a>
<a name="ln6347">      B2 = exc-&gt;zp1.cur[point].y;</a>
<a name="ln6348"> </a>
<a name="ln6349">      /* Reverse move if necessary */</a>
<a name="ln6350">      if ( exc-&gt;ignore_x_mode )</a>
<a name="ln6351">      {</a>
<a name="ln6352">        if ( exc-&gt;face-&gt;sph_compatibility_mode &amp;&amp;</a>
<a name="ln6353">             exc-&gt;GS.freeVector.y != 0         &amp;&amp;</a>
<a name="ln6354">             ( B1 &amp; 63 ) == 0                  &amp;&amp;</a>
<a name="ln6355">             ( B2 &amp; 63 ) != 0                  )</a>
<a name="ln6356">          reverse_move = TRUE;</a>
<a name="ln6357"> </a>
<a name="ln6358">        if ( ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES ) &amp;&amp;</a>
<a name="ln6359">             exc-&gt;GS.freeVector.y != 0                                  &amp;&amp;</a>
<a name="ln6360">             ( B2 &amp; 63 ) != 0                                           &amp;&amp;</a>
<a name="ln6361">             ( B1 &amp; 63 ) != 0                                           )</a>
<a name="ln6362">          reverse_move = TRUE;</a>
<a name="ln6363">      }</a>
<a name="ln6364"> </a>
<a name="ln6365">      if ( reverse_move )</a>
<a name="ln6366">        exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, -( distance - cur_dist ) );</a>
<a name="ln6367">    }</a>
<a name="ln6368"> </a>
<a name="ln6369">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6370"> </a>
<a name="ln6371">  Fail:</a>
<a name="ln6372">    exc-&gt;GS.rp1 = exc-&gt;GS.rp0;</a>
<a name="ln6373"> </a>
<a name="ln6374">    if ( ( exc-&gt;opcode &amp; 16 ) != 0 )</a>
<a name="ln6375">      exc-&gt;GS.rp0 = point;</a>
<a name="ln6376"> </a>
<a name="ln6377">    exc-&gt;GS.rp2 = point;</a>
<a name="ln6378">  }</a>
<a name="ln6379"> </a>
<a name="ln6380"> </a>
<a name="ln6381">  /*************************************************************************/</a>
<a name="ln6382">  /*                                                                       */</a>
<a name="ln6383">  /* ALIGNRP[]:    ALIGN Relative Point                                    */</a>
<a name="ln6384">  /* Opcode range: 0x3C                                                    */</a>
<a name="ln6385">  /* Stack:        uint32 uint32... --&gt;                                    */</a>
<a name="ln6386">  /*                                                                       */</a>
<a name="ln6387">  static void</a>
<a name="ln6388">  Ins_ALIGNRP( TT_ExecContext  exc )</a>
<a name="ln6389">  {</a>
<a name="ln6390">    FT_UShort   point;</a>
<a name="ln6391">    FT_F26Dot6  distance;</a>
<a name="ln6392"> </a>
<a name="ln6393"> </a>
<a name="ln6394">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6395">    if ( SUBPIXEL_HINTING                                          &amp;&amp;</a>
<a name="ln6396">         exc-&gt;ignore_x_mode                                        &amp;&amp;</a>
<a name="ln6397">         exc-&gt;iup_called                                           &amp;&amp;</a>
<a name="ln6398">         ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NO_ALIGNRP_AFTER_IUP ) )</a>
<a name="ln6399">    {</a>
<a name="ln6400">      exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6401">      goto Fail;</a>
<a name="ln6402">    }</a>
<a name="ln6403">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6404"> </a>
<a name="ln6405">    if ( exc-&gt;top &lt; exc-&gt;GS.loop                  ||</a>
<a name="ln6406">         BOUNDS( exc-&gt;GS.rp0, exc-&gt;zp0.n_points ) )</a>
<a name="ln6407">    {</a>
<a name="ln6408">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6409">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6410">      goto Fail;</a>
<a name="ln6411">    }</a>
<a name="ln6412"> </a>
<a name="ln6413">    while ( exc-&gt;GS.loop &gt; 0 )</a>
<a name="ln6414">    {</a>
<a name="ln6415">      exc-&gt;args--;</a>
<a name="ln6416"> </a>
<a name="ln6417">      point = (FT_UShort)exc-&gt;stack[exc-&gt;args];</a>
<a name="ln6418"> </a>
<a name="ln6419">      if ( BOUNDS( point, exc-&gt;zp1.n_points ) )</a>
<a name="ln6420">      {</a>
<a name="ln6421">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6422">        {</a>
<a name="ln6423">          exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6424">          return;</a>
<a name="ln6425">        }</a>
<a name="ln6426">      }</a>
<a name="ln6427">      else</a>
<a name="ln6428">      {</a>
<a name="ln6429">        distance = PROJECT( exc-&gt;zp1.cur + point,</a>
<a name="ln6430">                            exc-&gt;zp0.cur + exc-&gt;GS.rp0 );</a>
<a name="ln6431"> </a>
<a name="ln6432">        exc-&gt;func_move( exc, &amp;exc-&gt;zp1, point, -distance );</a>
<a name="ln6433">      }</a>
<a name="ln6434"> </a>
<a name="ln6435">      exc-&gt;GS.loop--;</a>
<a name="ln6436">    }</a>
<a name="ln6437"> </a>
<a name="ln6438">  Fail:</a>
<a name="ln6439">    exc-&gt;GS.loop = 1;</a>
<a name="ln6440">    exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln6441">  }</a>
<a name="ln6442"> </a>
<a name="ln6443"> </a>
<a name="ln6444">  /*************************************************************************/</a>
<a name="ln6445">  /*                                                                       */</a>
<a name="ln6446">  /* ISECT[]:      moves point to InterSECTion                             */</a>
<a name="ln6447">  /* Opcode range: 0x0F                                                    */</a>
<a name="ln6448">  /* Stack:        5 * uint32 --&gt;                                          */</a>
<a name="ln6449">  /*                                                                       */</a>
<a name="ln6450">  static void</a>
<a name="ln6451">  Ins_ISECT( TT_ExecContext  exc,</a>
<a name="ln6452">             FT_Long*        args )</a>
<a name="ln6453">  {</a>
<a name="ln6454">    FT_UShort   point,</a>
<a name="ln6455">                a0, a1,</a>
<a name="ln6456">                b0, b1;</a>
<a name="ln6457"> </a>
<a name="ln6458">    FT_F26Dot6  discriminant, dotproduct;</a>
<a name="ln6459"> </a>
<a name="ln6460">    FT_F26Dot6  dx,  dy,</a>
<a name="ln6461">                dax, day,</a>
<a name="ln6462">                dbx, dby;</a>
<a name="ln6463"> </a>
<a name="ln6464">    FT_F26Dot6  val;</a>
<a name="ln6465"> </a>
<a name="ln6466">    FT_Vector   R;</a>
<a name="ln6467"> </a>
<a name="ln6468"> </a>
<a name="ln6469">    point = (FT_UShort)args[0];</a>
<a name="ln6470"> </a>
<a name="ln6471">    a0 = (FT_UShort)args[1];</a>
<a name="ln6472">    a1 = (FT_UShort)args[2];</a>
<a name="ln6473">    b0 = (FT_UShort)args[3];</a>
<a name="ln6474">    b1 = (FT_UShort)args[4];</a>
<a name="ln6475"> </a>
<a name="ln6476">    if ( BOUNDS( b0,    exc-&gt;zp0.n_points ) ||</a>
<a name="ln6477">         BOUNDS( b1,    exc-&gt;zp0.n_points ) ||</a>
<a name="ln6478">         BOUNDS( a0,    exc-&gt;zp1.n_points ) ||</a>
<a name="ln6479">         BOUNDS( a1,    exc-&gt;zp1.n_points ) ||</a>
<a name="ln6480">         BOUNDS( point, exc-&gt;zp2.n_points ) )</a>
<a name="ln6481">    {</a>
<a name="ln6482">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6483">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6484">      return;</a>
<a name="ln6485">    }</a>
<a name="ln6486"> </a>
<a name="ln6487">    /* Cramer's rule */</a>
<a name="ln6488"> </a>
<a name="ln6489">    dbx = exc-&gt;zp0.cur[b1].x - exc-&gt;zp0.cur[b0].x;</a>
<a name="ln6490">    dby = exc-&gt;zp0.cur[b1].y - exc-&gt;zp0.cur[b0].y;</a>
<a name="ln6491"> </a>
<a name="ln6492">    dax = exc-&gt;zp1.cur[a1].x - exc-&gt;zp1.cur[a0].x;</a>
<a name="ln6493">    day = exc-&gt;zp1.cur[a1].y - exc-&gt;zp1.cur[a0].y;</a>
<a name="ln6494"> </a>
<a name="ln6495">    dx = exc-&gt;zp0.cur[b0].x - exc-&gt;zp1.cur[a0].x;</a>
<a name="ln6496">    dy = exc-&gt;zp0.cur[b0].y - exc-&gt;zp1.cur[a0].y;</a>
<a name="ln6497"> </a>
<a name="ln6498">    discriminant = FT_MulDiv( dax, -dby, 0x40 ) +</a>
<a name="ln6499">                   FT_MulDiv( day, dbx, 0x40 );</a>
<a name="ln6500">    dotproduct   = FT_MulDiv( dax, dbx, 0x40 ) +</a>
<a name="ln6501">                   FT_MulDiv( day, dby, 0x40 );</a>
<a name="ln6502"> </a>
<a name="ln6503">    /* The discriminant above is actually a cross product of vectors     */</a>
<a name="ln6504">    /* da and db. Together with the dot product, they can be used as     */</a>
<a name="ln6505">    /* surrogates for sine and cosine of the angle between the vectors.  */</a>
<a name="ln6506">    /* Indeed,                                                           */</a>
<a name="ln6507">    /*       dotproduct   = |da||db|cos(angle)                           */</a>
<a name="ln6508">    /*       discriminant = |da||db|sin(angle)     .                     */</a>
<a name="ln6509">    /* We use these equations to reject grazing intersections by         */</a>
<a name="ln6510">    /* thresholding abs(tan(angle)) at 1/19, corresponding to 3 degrees. */</a>
<a name="ln6511">    if ( 19 * FT_ABS( discriminant ) &gt; FT_ABS( dotproduct ) )</a>
<a name="ln6512">    {</a>
<a name="ln6513">      val = FT_MulDiv( dx, -dby, 0x40 ) + FT_MulDiv( dy, dbx, 0x40 );</a>
<a name="ln6514"> </a>
<a name="ln6515">      R.x = FT_MulDiv( val, dax, discriminant );</a>
<a name="ln6516">      R.y = FT_MulDiv( val, day, discriminant );</a>
<a name="ln6517"> </a>
<a name="ln6518">      exc-&gt;zp2.cur[point].x = exc-&gt;zp1.cur[a0].x + R.x;</a>
<a name="ln6519">      exc-&gt;zp2.cur[point].y = exc-&gt;zp1.cur[a0].y + R.y;</a>
<a name="ln6520">    }</a>
<a name="ln6521">    else</a>
<a name="ln6522">    {</a>
<a name="ln6523">      /* else, take the middle of the middles of A and B */</a>
<a name="ln6524"> </a>
<a name="ln6525">      exc-&gt;zp2.cur[point].x = ( exc-&gt;zp1.cur[a0].x +</a>
<a name="ln6526">                                exc-&gt;zp1.cur[a1].x +</a>
<a name="ln6527">                                exc-&gt;zp0.cur[b0].x +</a>
<a name="ln6528">                                exc-&gt;zp0.cur[b1].x ) / 4;</a>
<a name="ln6529">      exc-&gt;zp2.cur[point].y = ( exc-&gt;zp1.cur[a0].y +</a>
<a name="ln6530">                                exc-&gt;zp1.cur[a1].y +</a>
<a name="ln6531">                                exc-&gt;zp0.cur[b0].y +</a>
<a name="ln6532">                                exc-&gt;zp0.cur[b1].y ) / 4;</a>
<a name="ln6533">    }</a>
<a name="ln6534"> </a>
<a name="ln6535">    exc-&gt;zp2.tags[point] |= FT_CURVE_TAG_TOUCH_BOTH;</a>
<a name="ln6536">  }</a>
<a name="ln6537"> </a>
<a name="ln6538"> </a>
<a name="ln6539">  /*************************************************************************/</a>
<a name="ln6540">  /*                                                                       */</a>
<a name="ln6541">  /* ALIGNPTS[]:   ALIGN PoinTS                                            */</a>
<a name="ln6542">  /* Opcode range: 0x27                                                    */</a>
<a name="ln6543">  /* Stack:        uint32 uint32 --&gt;                                       */</a>
<a name="ln6544">  /*                                                                       */</a>
<a name="ln6545">  static void</a>
<a name="ln6546">  Ins_ALIGNPTS( TT_ExecContext  exc,</a>
<a name="ln6547">                FT_Long*        args )</a>
<a name="ln6548">  {</a>
<a name="ln6549">    FT_UShort   p1, p2;</a>
<a name="ln6550">    FT_F26Dot6  distance;</a>
<a name="ln6551"> </a>
<a name="ln6552"> </a>
<a name="ln6553">    p1 = (FT_UShort)args[0];</a>
<a name="ln6554">    p2 = (FT_UShort)args[1];</a>
<a name="ln6555"> </a>
<a name="ln6556">    if ( BOUNDS( p1, exc-&gt;zp1.n_points ) ||</a>
<a name="ln6557">         BOUNDS( p2, exc-&gt;zp0.n_points ) )</a>
<a name="ln6558">    {</a>
<a name="ln6559">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6560">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6561">      return;</a>
<a name="ln6562">    }</a>
<a name="ln6563"> </a>
<a name="ln6564">    distance = PROJECT( exc-&gt;zp0.cur + p2, exc-&gt;zp1.cur + p1 ) / 2;</a>
<a name="ln6565"> </a>
<a name="ln6566">    exc-&gt;func_move( exc, &amp;exc-&gt;zp1, p1, distance );</a>
<a name="ln6567">    exc-&gt;func_move( exc, &amp;exc-&gt;zp0, p2, -distance );</a>
<a name="ln6568">  }</a>
<a name="ln6569"> </a>
<a name="ln6570"> </a>
<a name="ln6571">  /*************************************************************************/</a>
<a name="ln6572">  /*                                                                       */</a>
<a name="ln6573">  /* IP[]:         Interpolate Point                                       */</a>
<a name="ln6574">  /* Opcode range: 0x39                                                    */</a>
<a name="ln6575">  /* Stack:        uint32... --&gt;                                           */</a>
<a name="ln6576">  /*                                                                       */</a>
<a name="ln6577"> </a>
<a name="ln6578">  /* SOMETIMES, DUMBER CODE IS BETTER CODE */</a>
<a name="ln6579"> </a>
<a name="ln6580">  static void</a>
<a name="ln6581">  Ins_IP( TT_ExecContext  exc )</a>
<a name="ln6582">  {</a>
<a name="ln6583">    FT_F26Dot6  old_range, cur_range;</a>
<a name="ln6584">    FT_Vector*  orus_base;</a>
<a name="ln6585">    FT_Vector*  cur_base;</a>
<a name="ln6586">    FT_Int      twilight;</a>
<a name="ln6587"> </a>
<a name="ln6588"> </a>
<a name="ln6589">    if ( exc-&gt;top &lt; exc-&gt;GS.loop )</a>
<a name="ln6590">    {</a>
<a name="ln6591">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6592">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6593">      goto Fail;</a>
<a name="ln6594">    }</a>
<a name="ln6595"> </a>
<a name="ln6596">    /*</a>
<a name="ln6597">     * We need to deal in a special way with the twilight zone.</a>
<a name="ln6598">     * Otherwise, by definition, the value of exc-&gt;twilight.orus[n] is (0,0),</a>
<a name="ln6599">     * for every n.</a>
<a name="ln6600">     */</a>
<a name="ln6601">    twilight = exc-&gt;GS.gep0 == 0 || exc-&gt;GS.gep1 == 0 || exc-&gt;GS.gep2 == 0;</a>
<a name="ln6602"> </a>
<a name="ln6603">    if ( BOUNDS( exc-&gt;GS.rp1, exc-&gt;zp0.n_points ) )</a>
<a name="ln6604">    {</a>
<a name="ln6605">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6606">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6607">      goto Fail;</a>
<a name="ln6608">    }</a>
<a name="ln6609"> </a>
<a name="ln6610">    if ( twilight )</a>
<a name="ln6611">      orus_base = &amp;exc-&gt;zp0.org[exc-&gt;GS.rp1];</a>
<a name="ln6612">    else</a>
<a name="ln6613">      orus_base = &amp;exc-&gt;zp0.orus[exc-&gt;GS.rp1];</a>
<a name="ln6614"> </a>
<a name="ln6615">    cur_base = &amp;exc-&gt;zp0.cur[exc-&gt;GS.rp1];</a>
<a name="ln6616"> </a>
<a name="ln6617">    /* XXX: There are some glyphs in some braindead but popular */</a>
<a name="ln6618">    /*      fonts out there (e.g. [aeu]grave in monotype.ttf)   */</a>
<a name="ln6619">    /*      calling IP[] with bad values of rp[12].             */</a>
<a name="ln6620">    /*      Do something sane when this odd thing happens.      */</a>
<a name="ln6621">    if ( BOUNDS( exc-&gt;GS.rp1, exc-&gt;zp0.n_points ) ||</a>
<a name="ln6622">         BOUNDS( exc-&gt;GS.rp2, exc-&gt;zp1.n_points ) )</a>
<a name="ln6623">    {</a>
<a name="ln6624">      old_range = 0;</a>
<a name="ln6625">      cur_range = 0;</a>
<a name="ln6626">    }</a>
<a name="ln6627">    else</a>
<a name="ln6628">    {</a>
<a name="ln6629">      if ( twilight )</a>
<a name="ln6630">        old_range = DUALPROJ( &amp;exc-&gt;zp1.org[exc-&gt;GS.rp2], orus_base );</a>
<a name="ln6631">      else if ( exc-&gt;metrics.x_scale == exc-&gt;metrics.y_scale )</a>
<a name="ln6632">        old_range = DUALPROJ( &amp;exc-&gt;zp1.orus[exc-&gt;GS.rp2], orus_base );</a>
<a name="ln6633">      else</a>
<a name="ln6634">      {</a>
<a name="ln6635">        FT_Vector  vec;</a>
<a name="ln6636"> </a>
<a name="ln6637"> </a>
<a name="ln6638">        vec.x = FT_MulFix( exc-&gt;zp1.orus[exc-&gt;GS.rp2].x - orus_base-&gt;x,</a>
<a name="ln6639">                           exc-&gt;metrics.x_scale );</a>
<a name="ln6640">        vec.y = FT_MulFix( exc-&gt;zp1.orus[exc-&gt;GS.rp2].y - orus_base-&gt;y,</a>
<a name="ln6641">                           exc-&gt;metrics.y_scale );</a>
<a name="ln6642"> </a>
<a name="ln6643">        old_range = FAST_DUALPROJ( &amp;vec );</a>
<a name="ln6644">      }</a>
<a name="ln6645"> </a>
<a name="ln6646">      cur_range = PROJECT( &amp;exc-&gt;zp1.cur[exc-&gt;GS.rp2], cur_base );</a>
<a name="ln6647">    }</a>
<a name="ln6648"> </a>
<a name="ln6649">    for ( ; exc-&gt;GS.loop &gt; 0; --exc-&gt;GS.loop )</a>
<a name="ln6650">    {</a>
<a name="ln6651">      FT_UInt     point = (FT_UInt)exc-&gt;stack[--exc-&gt;args];</a>
<a name="ln6652">      FT_F26Dot6  org_dist, cur_dist, new_dist;</a>
<a name="ln6653"> </a>
<a name="ln6654"> </a>
<a name="ln6655">      /* check point bounds */</a>
<a name="ln6656">      if ( BOUNDS( point, exc-&gt;zp2.n_points ) )</a>
<a name="ln6657">      {</a>
<a name="ln6658">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6659">        {</a>
<a name="ln6660">          exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6661">          return;</a>
<a name="ln6662">        }</a>
<a name="ln6663">        continue;</a>
<a name="ln6664">      }</a>
<a name="ln6665"> </a>
<a name="ln6666">      if ( twilight )</a>
<a name="ln6667">        org_dist = DUALPROJ( &amp;exc-&gt;zp2.org[point], orus_base );</a>
<a name="ln6668">      else if ( exc-&gt;metrics.x_scale == exc-&gt;metrics.y_scale )</a>
<a name="ln6669">        org_dist = DUALPROJ( &amp;exc-&gt;zp2.orus[point], orus_base );</a>
<a name="ln6670">      else</a>
<a name="ln6671">      {</a>
<a name="ln6672">        FT_Vector  vec;</a>
<a name="ln6673"> </a>
<a name="ln6674"> </a>
<a name="ln6675">        vec.x = FT_MulFix( exc-&gt;zp2.orus[point].x - orus_base-&gt;x,</a>
<a name="ln6676">                           exc-&gt;metrics.x_scale );</a>
<a name="ln6677">        vec.y = FT_MulFix( exc-&gt;zp2.orus[point].y - orus_base-&gt;y,</a>
<a name="ln6678">                           exc-&gt;metrics.y_scale );</a>
<a name="ln6679"> </a>
<a name="ln6680">        org_dist = FAST_DUALPROJ( &amp;vec );</a>
<a name="ln6681">      }</a>
<a name="ln6682"> </a>
<a name="ln6683">      cur_dist = PROJECT( &amp;exc-&gt;zp2.cur[point], cur_base );</a>
<a name="ln6684"> </a>
<a name="ln6685">      if ( org_dist )</a>
<a name="ln6686">      {</a>
<a name="ln6687">        if ( old_range )</a>
<a name="ln6688">          new_dist = FT_MulDiv( org_dist, cur_range, old_range );</a>
<a name="ln6689">        else</a>
<a name="ln6690">        {</a>
<a name="ln6691">          /* This is the same as what MS does for the invalid case:  */</a>
<a name="ln6692">          /*                                                         */</a>
<a name="ln6693">          /*   delta = (Original_Pt - Original_RP1) -                */</a>
<a name="ln6694">          /*           (Current_Pt - Current_RP1)         ;          */</a>
<a name="ln6695">          /*                                                         */</a>
<a name="ln6696">          /* In FreeType speak:                                      */</a>
<a name="ln6697">          /*                                                         */</a>
<a name="ln6698">          /*   delta = org_dist - cur_dist          .                */</a>
<a name="ln6699">          /*                                                         */</a>
<a name="ln6700">          /* We move `point' by `new_dist - cur_dist' after leaving  */</a>
<a name="ln6701">          /* this block, thus we have                                */</a>
<a name="ln6702">          /*                                                         */</a>
<a name="ln6703">          /*   new_dist - cur_dist = delta                   ,       */</a>
<a name="ln6704">          /*   new_dist - cur_dist = org_dist - cur_dist     ,       */</a>
<a name="ln6705">          /*              new_dist = org_dist                .       */</a>
<a name="ln6706"> </a>
<a name="ln6707">          new_dist = org_dist;</a>
<a name="ln6708">        }</a>
<a name="ln6709">      }</a>
<a name="ln6710">      else</a>
<a name="ln6711">        new_dist = 0;</a>
<a name="ln6712"> </a>
<a name="ln6713">      exc-&gt;func_move( exc,</a>
<a name="ln6714">                      &amp;exc-&gt;zp2,</a>
<a name="ln6715">                      (FT_UShort)point,</a>
<a name="ln6716">                      new_dist - cur_dist );</a>
<a name="ln6717">    }</a>
<a name="ln6718"> </a>
<a name="ln6719">  Fail:</a>
<a name="ln6720">    exc-&gt;GS.loop = 1;</a>
<a name="ln6721">    exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln6722">  }</a>
<a name="ln6723"> </a>
<a name="ln6724"> </a>
<a name="ln6725">  /*************************************************************************/</a>
<a name="ln6726">  /*                                                                       */</a>
<a name="ln6727">  /* UTP[a]:       UnTouch Point                                           */</a>
<a name="ln6728">  /* Opcode range: 0x29                                                    */</a>
<a name="ln6729">  /* Stack:        uint32 --&gt;                                              */</a>
<a name="ln6730">  /*                                                                       */</a>
<a name="ln6731">  static void</a>
<a name="ln6732">  Ins_UTP( TT_ExecContext  exc,</a>
<a name="ln6733">           FT_Long*        args )</a>
<a name="ln6734">  {</a>
<a name="ln6735">    FT_UShort  point;</a>
<a name="ln6736">    FT_Byte    mask;</a>
<a name="ln6737"> </a>
<a name="ln6738"> </a>
<a name="ln6739">    point = (FT_UShort)args[0];</a>
<a name="ln6740"> </a>
<a name="ln6741">    if ( BOUNDS( point, exc-&gt;zp0.n_points ) )</a>
<a name="ln6742">    {</a>
<a name="ln6743">      if ( exc-&gt;pedantic_hinting )</a>
<a name="ln6744">        exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln6745">      return;</a>
<a name="ln6746">    }</a>
<a name="ln6747"> </a>
<a name="ln6748">    mask = 0xFF;</a>
<a name="ln6749"> </a>
<a name="ln6750">    if ( exc-&gt;GS.freeVector.x != 0 )</a>
<a name="ln6751">      mask &amp;= ~FT_CURVE_TAG_TOUCH_X;</a>
<a name="ln6752"> </a>
<a name="ln6753">    if ( exc-&gt;GS.freeVector.y != 0 )</a>
<a name="ln6754">      mask &amp;= ~FT_CURVE_TAG_TOUCH_Y;</a>
<a name="ln6755"> </a>
<a name="ln6756">    exc-&gt;zp0.tags[point] &amp;= mask;</a>
<a name="ln6757">  }</a>
<a name="ln6758"> </a>
<a name="ln6759"> </a>
<a name="ln6760">  /* Local variables for Ins_IUP: */</a>
<a name="ln6761">  typedef struct  IUP_WorkerRec_</a>
<a name="ln6762">  {</a>
<a name="ln6763">    FT_Vector*  orgs;   /* original and current coordinate */</a>
<a name="ln6764">    FT_Vector*  curs;   /* arrays                          */</a>
<a name="ln6765">    FT_Vector*  orus;</a>
<a name="ln6766">    FT_UInt     max_points;</a>
<a name="ln6767"> </a>
<a name="ln6768">  } IUP_WorkerRec, *IUP_Worker;</a>
<a name="ln6769"> </a>
<a name="ln6770"> </a>
<a name="ln6771">  static void</a>
<a name="ln6772">  _iup_worker_shift( IUP_Worker  worker,</a>
<a name="ln6773">                     FT_UInt     p1,</a>
<a name="ln6774">                     FT_UInt     p2,</a>
<a name="ln6775">                     FT_UInt     p )</a>
<a name="ln6776">  {</a>
<a name="ln6777">    FT_UInt     i;</a>
<a name="ln6778">    FT_F26Dot6  dx;</a>
<a name="ln6779"> </a>
<a name="ln6780"> </a>
<a name="ln6781">    dx = worker-&gt;curs[p].x - worker-&gt;orgs[p].x;</a>
<a name="ln6782">    if ( dx != 0 )</a>
<a name="ln6783">    {</a>
<a name="ln6784">      for ( i = p1; i &lt; p; i++ )</a>
<a name="ln6785">        worker-&gt;curs[i].x += dx;</a>
<a name="ln6786"> </a>
<a name="ln6787">      for ( i = p + 1; i &lt;= p2; i++ )</a>
<a name="ln6788">        worker-&gt;curs[i].x += dx;</a>
<a name="ln6789">    }</a>
<a name="ln6790">  }</a>
<a name="ln6791"> </a>
<a name="ln6792"> </a>
<a name="ln6793">  static void</a>
<a name="ln6794">  _iup_worker_interpolate( IUP_Worker  worker,</a>
<a name="ln6795">                           FT_UInt     p1,</a>
<a name="ln6796">                           FT_UInt     p2,</a>
<a name="ln6797">                           FT_UInt     ref1,</a>
<a name="ln6798">                           FT_UInt     ref2 )</a>
<a name="ln6799">  {</a>
<a name="ln6800">    FT_UInt     i;</a>
<a name="ln6801">    FT_F26Dot6  orus1, orus2, org1, org2, cur1, cur2, delta1, delta2;</a>
<a name="ln6802"> </a>
<a name="ln6803"> </a>
<a name="ln6804">    if ( p1 &gt; p2 )</a>
<a name="ln6805">      return;</a>
<a name="ln6806"> </a>
<a name="ln6807">    if ( BOUNDS( ref1, worker-&gt;max_points ) ||</a>
<a name="ln6808">         BOUNDS( ref2, worker-&gt;max_points ) )</a>
<a name="ln6809">      return;</a>
<a name="ln6810"> </a>
<a name="ln6811">    orus1 = worker-&gt;orus[ref1].x;</a>
<a name="ln6812">    orus2 = worker-&gt;orus[ref2].x;</a>
<a name="ln6813"> </a>
<a name="ln6814">    if ( orus1 &gt; orus2 )</a>
<a name="ln6815">    {</a>
<a name="ln6816">      FT_F26Dot6  tmp_o;</a>
<a name="ln6817">      FT_UInt     tmp_r;</a>
<a name="ln6818"> </a>
<a name="ln6819"> </a>
<a name="ln6820">      tmp_o = orus1;</a>
<a name="ln6821">      orus1 = orus2;</a>
<a name="ln6822">      orus2 = tmp_o;</a>
<a name="ln6823"> </a>
<a name="ln6824">      tmp_r = ref1;</a>
<a name="ln6825">      ref1  = ref2;</a>
<a name="ln6826">      ref2  = tmp_r;</a>
<a name="ln6827">    }</a>
<a name="ln6828"> </a>
<a name="ln6829">    org1   = worker-&gt;orgs[ref1].x;</a>
<a name="ln6830">    org2   = worker-&gt;orgs[ref2].x;</a>
<a name="ln6831">    cur1   = worker-&gt;curs[ref1].x;</a>
<a name="ln6832">    cur2   = worker-&gt;curs[ref2].x;</a>
<a name="ln6833">    delta1 = cur1 - org1;</a>
<a name="ln6834">    delta2 = cur2 - org2;</a>
<a name="ln6835"> </a>
<a name="ln6836">    if ( cur1 == cur2 || orus1 == orus2 )</a>
<a name="ln6837">    {</a>
<a name="ln6838"> </a>
<a name="ln6839">      /* trivial snap or shift of untouched points */</a>
<a name="ln6840">      for ( i = p1; i &lt;= p2; i++ )</a>
<a name="ln6841">      {</a>
<a name="ln6842">        FT_F26Dot6  x = worker-&gt;orgs[i].x;</a>
<a name="ln6843"> </a>
<a name="ln6844"> </a>
<a name="ln6845">        if ( x &lt;= org1 )</a>
<a name="ln6846">          x += delta1;</a>
<a name="ln6847"> </a>
<a name="ln6848">        else if ( x &gt;= org2 )</a>
<a name="ln6849">          x += delta2;</a>
<a name="ln6850"> </a>
<a name="ln6851">        else</a>
<a name="ln6852">          x = cur1;</a>
<a name="ln6853"> </a>
<a name="ln6854">        worker-&gt;curs[i].x = x;</a>
<a name="ln6855">      }</a>
<a name="ln6856">    }</a>
<a name="ln6857">    else</a>
<a name="ln6858">    {</a>
<a name="ln6859">      FT_Fixed  scale       = 0;</a>
<a name="ln6860">      FT_Bool   scale_valid = 0;</a>
<a name="ln6861"> </a>
<a name="ln6862"> </a>
<a name="ln6863">      /* interpolation */</a>
<a name="ln6864">      for ( i = p1; i &lt;= p2; i++ )</a>
<a name="ln6865">      {</a>
<a name="ln6866">        FT_F26Dot6  x = worker-&gt;orgs[i].x;</a>
<a name="ln6867"> </a>
<a name="ln6868"> </a>
<a name="ln6869">        if ( x &lt;= org1 )</a>
<a name="ln6870">          x += delta1;</a>
<a name="ln6871"> </a>
<a name="ln6872">        else if ( x &gt;= org2 )</a>
<a name="ln6873">          x += delta2;</a>
<a name="ln6874"> </a>
<a name="ln6875">        else</a>
<a name="ln6876">        {</a>
<a name="ln6877">          if ( !scale_valid )</a>
<a name="ln6878">          {</a>
<a name="ln6879">            scale_valid = 1;</a>
<a name="ln6880">            scale       = FT_DivFix( cur2 - cur1, orus2 - orus1 );</a>
<a name="ln6881">          }</a>
<a name="ln6882"> </a>
<a name="ln6883">          x = cur1 + FT_MulFix( worker-&gt;orus[i].x - orus1, scale );</a>
<a name="ln6884">        }</a>
<a name="ln6885">        worker-&gt;curs[i].x = x;</a>
<a name="ln6886">      }</a>
<a name="ln6887">    }</a>
<a name="ln6888">  }</a>
<a name="ln6889"> </a>
<a name="ln6890"> </a>
<a name="ln6891">  /*************************************************************************/</a>
<a name="ln6892">  /*                                                                       */</a>
<a name="ln6893">  /* IUP[a]:       Interpolate Untouched Points                            */</a>
<a name="ln6894">  /* Opcode range: 0x30-0x31                                               */</a>
<a name="ln6895">  /* Stack:        --&gt;                                                     */</a>
<a name="ln6896">  /*                                                                       */</a>
<a name="ln6897">  static void</a>
<a name="ln6898">  Ins_IUP( TT_ExecContext  exc )</a>
<a name="ln6899">  {</a>
<a name="ln6900">    IUP_WorkerRec  V;</a>
<a name="ln6901">    FT_Byte        mask;</a>
<a name="ln6902"> </a>
<a name="ln6903">    FT_UInt   first_point;   /* first point of contour        */</a>
<a name="ln6904">    FT_UInt   end_point;     /* end point (last+1) of contour */</a>
<a name="ln6905"> </a>
<a name="ln6906">    FT_UInt   first_touched; /* first touched point in contour   */</a>
<a name="ln6907">    FT_UInt   cur_touched;   /* current touched point in contour */</a>
<a name="ln6908"> </a>
<a name="ln6909">    FT_UInt   point;         /* current point   */</a>
<a name="ln6910">    FT_Short  contour;       /* current contour */</a>
<a name="ln6911"> </a>
<a name="ln6912"> </a>
<a name="ln6913">    /* ignore empty outlines */</a>
<a name="ln6914">    if ( exc-&gt;pts.n_contours == 0 )</a>
<a name="ln6915">      return;</a>
<a name="ln6916"> </a>
<a name="ln6917">    if ( exc-&gt;opcode &amp; 1 )</a>
<a name="ln6918">    {</a>
<a name="ln6919">      mask   = FT_CURVE_TAG_TOUCH_X;</a>
<a name="ln6920">      V.orgs = exc-&gt;pts.org;</a>
<a name="ln6921">      V.curs = exc-&gt;pts.cur;</a>
<a name="ln6922">      V.orus = exc-&gt;pts.orus;</a>
<a name="ln6923">    }</a>
<a name="ln6924">    else</a>
<a name="ln6925">    {</a>
<a name="ln6926">      mask   = FT_CURVE_TAG_TOUCH_Y;</a>
<a name="ln6927">      V.orgs = (FT_Vector*)( (FT_Pos*)exc-&gt;pts.org + 1 );</a>
<a name="ln6928">      V.curs = (FT_Vector*)( (FT_Pos*)exc-&gt;pts.cur + 1 );</a>
<a name="ln6929">      V.orus = (FT_Vector*)( (FT_Pos*)exc-&gt;pts.orus + 1 );</a>
<a name="ln6930">    }</a>
<a name="ln6931">    V.max_points = exc-&gt;pts.n_points;</a>
<a name="ln6932"> </a>
<a name="ln6933">    contour = 0;</a>
<a name="ln6934">    point   = 0;</a>
<a name="ln6935"> </a>
<a name="ln6936">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln6937">    if ( SUBPIXEL_HINTING   &amp;&amp;</a>
<a name="ln6938">         exc-&gt;ignore_x_mode )</a>
<a name="ln6939">    {</a>
<a name="ln6940">      exc-&gt;iup_called = TRUE;</a>
<a name="ln6941">      if ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_SKIP_IUP )</a>
<a name="ln6942">        return;</a>
<a name="ln6943">    }</a>
<a name="ln6944">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln6945"> </a>
<a name="ln6946">    do</a>
<a name="ln6947">    {</a>
<a name="ln6948">      end_point   = exc-&gt;pts.contours[contour] - exc-&gt;pts.first_point;</a>
<a name="ln6949">      first_point = point;</a>
<a name="ln6950"> </a>
<a name="ln6951">      if ( BOUNDS( end_point, exc-&gt;pts.n_points ) )</a>
<a name="ln6952">        end_point = exc-&gt;pts.n_points - 1;</a>
<a name="ln6953"> </a>
<a name="ln6954">      while ( point &lt;= end_point &amp;&amp; ( exc-&gt;pts.tags[point] &amp; mask ) == 0 )</a>
<a name="ln6955">        point++;</a>
<a name="ln6956"> </a>
<a name="ln6957">      if ( point &lt;= end_point )</a>
<a name="ln6958">      {</a>
<a name="ln6959">        first_touched = point;</a>
<a name="ln6960">        cur_touched   = point;</a>
<a name="ln6961"> </a>
<a name="ln6962">        point++;</a>
<a name="ln6963"> </a>
<a name="ln6964">        while ( point &lt;= end_point )</a>
<a name="ln6965">        {</a>
<a name="ln6966">          if ( ( exc-&gt;pts.tags[point] &amp; mask ) != 0 )</a>
<a name="ln6967">          {</a>
<a name="ln6968">            _iup_worker_interpolate( &amp;V,</a>
<a name="ln6969">                                     cur_touched + 1,</a>
<a name="ln6970">                                     point - 1,</a>
<a name="ln6971">                                     cur_touched,</a>
<a name="ln6972">                                     point );</a>
<a name="ln6973">            cur_touched = point;</a>
<a name="ln6974">          }</a>
<a name="ln6975"> </a>
<a name="ln6976">          point++;</a>
<a name="ln6977">        }</a>
<a name="ln6978"> </a>
<a name="ln6979">        if ( cur_touched == first_touched )</a>
<a name="ln6980">          _iup_worker_shift( &amp;V, first_point, end_point, cur_touched );</a>
<a name="ln6981">        else</a>
<a name="ln6982">        {</a>
<a name="ln6983">          _iup_worker_interpolate( &amp;V,</a>
<a name="ln6984">                                   (FT_UShort)( cur_touched + 1 ),</a>
<a name="ln6985">                                   end_point,</a>
<a name="ln6986">                                   cur_touched,</a>
<a name="ln6987">                                   first_touched );</a>
<a name="ln6988"> </a>
<a name="ln6989">          if ( first_touched &gt; 0 )</a>
<a name="ln6990">            _iup_worker_interpolate( &amp;V,</a>
<a name="ln6991">                                     first_point,</a>
<a name="ln6992">                                     first_touched - 1,</a>
<a name="ln6993">                                     cur_touched,</a>
<a name="ln6994">                                     first_touched );</a>
<a name="ln6995">        }</a>
<a name="ln6996">      }</a>
<a name="ln6997">      contour++;</a>
<a name="ln6998">    } while ( contour &lt; exc-&gt;pts.n_contours );</a>
<a name="ln6999">  }</a>
<a name="ln7000"> </a>
<a name="ln7001"> </a>
<a name="ln7002">  /*************************************************************************/</a>
<a name="ln7003">  /*                                                                       */</a>
<a name="ln7004">  /* DELTAPn[]:    DELTA exceptions P1, P2, P3                             */</a>
<a name="ln7005">  /* Opcode range: 0x5D,0x71,0x72                                          */</a>
<a name="ln7006">  /* Stack:        uint32 (2 * uint32)... --&gt;                              */</a>
<a name="ln7007">  /*                                                                       */</a>
<a name="ln7008">  static void</a>
<a name="ln7009">  Ins_DELTAP( TT_ExecContext  exc,</a>
<a name="ln7010">              FT_Long*        args )</a>
<a name="ln7011">  {</a>
<a name="ln7012">    FT_ULong   nump, k;</a>
<a name="ln7013">    FT_UShort  A;</a>
<a name="ln7014">    FT_ULong   C, P;</a>
<a name="ln7015">    FT_Long    B;</a>
<a name="ln7016">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln7017">    FT_UShort  B1, B2;</a>
<a name="ln7018"> </a>
<a name="ln7019"> </a>
<a name="ln7020">    if ( SUBPIXEL_HINTING                                         &amp;&amp;</a>
<a name="ln7021">         exc-&gt;ignore_x_mode                                       &amp;&amp;</a>
<a name="ln7022">         exc-&gt;iup_called                                          &amp;&amp;</a>
<a name="ln7023">         ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_NO_DELTAP_AFTER_IUP ) )</a>
<a name="ln7024">      goto Fail;</a>
<a name="ln7025">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln7026"> </a>
<a name="ln7027"> </a>
<a name="ln7028">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln7029">    /* Delta hinting is covered by US Patent 5159668. */</a>
<a name="ln7030">    if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln7031">    {</a>
<a name="ln7032">      FT_Long  n = args[0] * 2;</a>
<a name="ln7033"> </a>
<a name="ln7034"> </a>
<a name="ln7035">      if ( exc-&gt;args &lt; n )</a>
<a name="ln7036">      {</a>
<a name="ln7037">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln7038">          exc-&gt;error = FT_THROW( Too_Few_Arguments );</a>
<a name="ln7039">        n = exc-&gt;args;</a>
<a name="ln7040">      }</a>
<a name="ln7041"> </a>
<a name="ln7042">      exc-&gt;args -= n;</a>
<a name="ln7043">      exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln7044">      return;</a>
<a name="ln7045">    }</a>
<a name="ln7046">#endif</a>
<a name="ln7047"> </a>
<a name="ln7048">    P    = (FT_ULong)exc-&gt;func_cur_ppem( exc );</a>
<a name="ln7049">    nump = (FT_ULong)args[0];   /* some points theoretically may occur more</a>
<a name="ln7050">                                   than once, thus UShort isn't enough */</a>
<a name="ln7051"> </a>
<a name="ln7052">    for ( k = 1; k &lt;= nump; k++ )</a>
<a name="ln7053">    {</a>
<a name="ln7054">      if ( exc-&gt;args &lt; 2 )</a>
<a name="ln7055">      {</a>
<a name="ln7056">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln7057">          exc-&gt;error = FT_THROW( Too_Few_Arguments );</a>
<a name="ln7058">        exc-&gt;args = 0;</a>
<a name="ln7059">        goto Fail;</a>
<a name="ln7060">      }</a>
<a name="ln7061"> </a>
<a name="ln7062">      exc-&gt;args -= 2;</a>
<a name="ln7063"> </a>
<a name="ln7064">      A = (FT_UShort)exc-&gt;stack[exc-&gt;args + 1];</a>
<a name="ln7065">      B = exc-&gt;stack[exc-&gt;args];</a>
<a name="ln7066"> </a>
<a name="ln7067">      /* XXX: Because some popular fonts contain some invalid DeltaP */</a>
<a name="ln7068">      /*      instructions, we simply ignore them when the stacked   */</a>
<a name="ln7069">      /*      point reference is off limit, rather than returning an */</a>
<a name="ln7070">      /*      error.  As a delta instruction doesn't change a glyph  */</a>
<a name="ln7071">      /*      in great ways, this shouldn't be a problem.            */</a>
<a name="ln7072"> </a>
<a name="ln7073">      if ( !BOUNDS( A, exc-&gt;zp0.n_points ) )</a>
<a name="ln7074">      {</a>
<a name="ln7075">        C = ( (FT_ULong)B &amp; 0xF0 ) &gt;&gt; 4;</a>
<a name="ln7076"> </a>
<a name="ln7077">        switch ( exc-&gt;opcode )</a>
<a name="ln7078">        {</a>
<a name="ln7079">        case 0x5D:</a>
<a name="ln7080">          break;</a>
<a name="ln7081"> </a>
<a name="ln7082">        case 0x71:</a>
<a name="ln7083">          C += 16;</a>
<a name="ln7084">          break;</a>
<a name="ln7085"> </a>
<a name="ln7086">        case 0x72:</a>
<a name="ln7087">          C += 32;</a>
<a name="ln7088">          break;</a>
<a name="ln7089">        }</a>
<a name="ln7090"> </a>
<a name="ln7091">        C += exc-&gt;GS.delta_base;</a>
<a name="ln7092"> </a>
<a name="ln7093">        if ( P == C )</a>
<a name="ln7094">        {</a>
<a name="ln7095">          B = ( (FT_ULong)B &amp; 0xF ) - 8;</a>
<a name="ln7096">          if ( B &gt;= 0 )</a>
<a name="ln7097">            B++;</a>
<a name="ln7098">          B *= 1L &lt;&lt; ( 6 - exc-&gt;GS.delta_shift );</a>
<a name="ln7099"> </a>
<a name="ln7100">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln7101"> </a>
<a name="ln7102">          if ( SUBPIXEL_HINTING )</a>
<a name="ln7103">          {</a>
<a name="ln7104">            /*</a>
<a name="ln7105">             *  Allow delta move if</a>
<a name="ln7106">             *</a>
<a name="ln7107">             *  - not using ignore_x_mode rendering,</a>
<a name="ln7108">             *  - glyph is specifically set to allow it, or</a>
<a name="ln7109">             *  - glyph is composite and freedom vector is not in subpixel</a>
<a name="ln7110">             *    direction.</a>
<a name="ln7111">             */</a>
<a name="ln7112">            if ( !exc-&gt;ignore_x_mode                                   ||</a>
<a name="ln7113">                 ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ALWAYS_DO_DELTAP ) ||</a>
<a name="ln7114">                 ( exc-&gt;is_composite &amp;&amp; exc-&gt;GS.freeVector.y != 0 )    )</a>
<a name="ln7115">              exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );</a>
<a name="ln7116"> </a>
<a name="ln7117">            /* Otherwise, apply subpixel hinting and compatibility mode */</a>
<a name="ln7118">            /* rules, always skipping deltas in subpixel direction.     */</a>
<a name="ln7119">            else if ( exc-&gt;ignore_x_mode &amp;&amp; exc-&gt;GS.freeVector.y != 0 )</a>
<a name="ln7120">            {</a>
<a name="ln7121">              /* save the y value of the point now; compare after move */</a>
<a name="ln7122">              B1 = (FT_UShort)exc-&gt;zp0.cur[A].y;</a>
<a name="ln7123"> </a>
<a name="ln7124">              /* Standard subpixel hinting: Allow y move for y-touched */</a>
<a name="ln7125">              /* points.  This messes up DejaVu ...                    */</a>
<a name="ln7126">              if ( !exc-&gt;face-&gt;sph_compatibility_mode          &amp;&amp;</a>
<a name="ln7127">                   ( exc-&gt;zp0.tags[A] &amp; FT_CURVE_TAG_TOUCH_Y ) )</a>
<a name="ln7128">                exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );</a>
<a name="ln7129"> </a>
<a name="ln7130">              /* compatibility mode */</a>
<a name="ln7131">              else if ( exc-&gt;face-&gt;sph_compatibility_mode                        &amp;&amp;</a>
<a name="ln7132">                        !( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ALWAYS_SKIP_DELTAP ) )</a>
<a name="ln7133">              {</a>
<a name="ln7134">                if ( exc-&gt;sph_tweak_flags &amp; SPH_TWEAK_ROUND_NONPIXEL_Y_MOVES )</a>
<a name="ln7135">                  B = FT_PIX_ROUND( B1 + B ) - B1;</a>
<a name="ln7136"> </a>
<a name="ln7137">                /* Allow delta move if using sph_compatibility_mode,   */</a>
<a name="ln7138">                /* IUP has not been called, and point is touched on Y. */</a>
<a name="ln7139">                if ( !exc-&gt;iup_called                            &amp;&amp;</a>
<a name="ln7140">                     ( exc-&gt;zp0.tags[A] &amp; FT_CURVE_TAG_TOUCH_Y ) )</a>
<a name="ln7141">                  exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );</a>
<a name="ln7142">              }</a>
<a name="ln7143"> </a>
<a name="ln7144">              B2 = (FT_UShort)exc-&gt;zp0.cur[A].y;</a>
<a name="ln7145"> </a>
<a name="ln7146">              /* Reverse this move if it results in a disallowed move */</a>
<a name="ln7147">              if ( exc-&gt;GS.freeVector.y != 0                          &amp;&amp;</a>
<a name="ln7148">                   ( ( exc-&gt;face-&gt;sph_compatibility_mode          &amp;&amp;</a>
<a name="ln7149">                       ( B1 &amp; 63 ) == 0                           &amp;&amp;</a>
<a name="ln7150">                       ( B2 &amp; 63 ) != 0                           ) ||</a>
<a name="ln7151">                     ( ( exc-&gt;sph_tweak_flags                   &amp;</a>
<a name="ln7152">                         SPH_TWEAK_SKIP_NONPIXEL_Y_MOVES_DELTAP ) &amp;&amp;</a>
<a name="ln7153">                       ( B1 &amp; 63 ) != 0                           &amp;&amp;</a>
<a name="ln7154">                       ( B2 &amp; 63 ) != 0                           ) ) )</a>
<a name="ln7155">                exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, -B );</a>
<a name="ln7156">            }</a>
<a name="ln7157">          }</a>
<a name="ln7158">          else</a>
<a name="ln7159">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln7160"> </a>
<a name="ln7161">            exc-&gt;func_move( exc, &amp;exc-&gt;zp0, A, B );</a>
<a name="ln7162">        }</a>
<a name="ln7163">      }</a>
<a name="ln7164">      else</a>
<a name="ln7165">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln7166">          exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln7167">    }</a>
<a name="ln7168"> </a>
<a name="ln7169">  Fail:</a>
<a name="ln7170">    exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln7171">  }</a>
<a name="ln7172"> </a>
<a name="ln7173"> </a>
<a name="ln7174">  /*************************************************************************/</a>
<a name="ln7175">  /*                                                                       */</a>
<a name="ln7176">  /* DELTACn[]:    DELTA exceptions C1, C2, C3                             */</a>
<a name="ln7177">  /* Opcode range: 0x73,0x74,0x75                                          */</a>
<a name="ln7178">  /* Stack:        uint32 (2 * uint32)... --&gt;                              */</a>
<a name="ln7179">  /*                                                                       */</a>
<a name="ln7180">  static void</a>
<a name="ln7181">  Ins_DELTAC( TT_ExecContext  exc,</a>
<a name="ln7182">              FT_Long*        args )</a>
<a name="ln7183">  {</a>
<a name="ln7184">    FT_ULong  nump, k;</a>
<a name="ln7185">    FT_ULong  A, C, P;</a>
<a name="ln7186">    FT_Long   B;</a>
<a name="ln7187"> </a>
<a name="ln7188"> </a>
<a name="ln7189">#ifdef TT_CONFIG_OPTION_UNPATENTED_HINTING</a>
<a name="ln7190">    /* Delta hinting is covered by US Patent 5159668. */</a>
<a name="ln7191">    if ( exc-&gt;face-&gt;unpatented_hinting )</a>
<a name="ln7192">    {</a>
<a name="ln7193">      FT_Long  n = args[0] * 2;</a>
<a name="ln7194"> </a>
<a name="ln7195"> </a>
<a name="ln7196">      if ( exc-&gt;args &lt; n )</a>
<a name="ln7197">      {</a>
<a name="ln7198">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln7199">          exc-&gt;error = FT_THROW( Too_Few_Arguments );</a>
<a name="ln7200">        n = exc-&gt;args;</a>
<a name="ln7201">      }</a>
<a name="ln7202"> </a>
<a name="ln7203">      exc-&gt;args -= n;</a>
<a name="ln7204">      exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln7205">      return;</a>
<a name="ln7206">    }</a>
<a name="ln7207">#endif</a>
<a name="ln7208"> </a>
<a name="ln7209">    P    = (FT_ULong)exc-&gt;func_cur_ppem( exc );</a>
<a name="ln7210">    nump = (FT_ULong)args[0];</a>
<a name="ln7211"> </a>
<a name="ln7212">    for ( k = 1; k &lt;= nump; k++ )</a>
<a name="ln7213">    {</a>
<a name="ln7214">      if ( exc-&gt;args &lt; 2 )</a>
<a name="ln7215">      {</a>
<a name="ln7216">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln7217">          exc-&gt;error = FT_THROW( Too_Few_Arguments );</a>
<a name="ln7218">        exc-&gt;args = 0;</a>
<a name="ln7219">        goto Fail;</a>
<a name="ln7220">      }</a>
<a name="ln7221"> </a>
<a name="ln7222">      exc-&gt;args -= 2;</a>
<a name="ln7223"> </a>
<a name="ln7224">      A = (FT_ULong)exc-&gt;stack[exc-&gt;args + 1];</a>
<a name="ln7225">      B = exc-&gt;stack[exc-&gt;args];</a>
<a name="ln7226"> </a>
<a name="ln7227">      if ( BOUNDSL( A, exc-&gt;cvtSize ) )</a>
<a name="ln7228">      {</a>
<a name="ln7229">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln7230">        {</a>
<a name="ln7231">          exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln7232">          return;</a>
<a name="ln7233">        }</a>
<a name="ln7234">      }</a>
<a name="ln7235">      else</a>
<a name="ln7236">      {</a>
<a name="ln7237">        C = ( (FT_ULong)B &amp; 0xF0 ) &gt;&gt; 4;</a>
<a name="ln7238"> </a>
<a name="ln7239">        switch ( exc-&gt;opcode )</a>
<a name="ln7240">        {</a>
<a name="ln7241">        case 0x73:</a>
<a name="ln7242">          break;</a>
<a name="ln7243"> </a>
<a name="ln7244">        case 0x74:</a>
<a name="ln7245">          C += 16;</a>
<a name="ln7246">          break;</a>
<a name="ln7247"> </a>
<a name="ln7248">        case 0x75:</a>
<a name="ln7249">          C += 32;</a>
<a name="ln7250">          break;</a>
<a name="ln7251">        }</a>
<a name="ln7252"> </a>
<a name="ln7253">        C += exc-&gt;GS.delta_base;</a>
<a name="ln7254"> </a>
<a name="ln7255">        if ( P == C )</a>
<a name="ln7256">        {</a>
<a name="ln7257">          B = ( (FT_ULong)B &amp; 0xF ) - 8;</a>
<a name="ln7258">          if ( B &gt;= 0 )</a>
<a name="ln7259">            B++;</a>
<a name="ln7260">          B *= 1L &lt;&lt; ( 6 - exc-&gt;GS.delta_shift );</a>
<a name="ln7261"> </a>
<a name="ln7262">          exc-&gt;func_move_cvt( exc, A, B );</a>
<a name="ln7263">        }</a>
<a name="ln7264">      }</a>
<a name="ln7265">    }</a>
<a name="ln7266"> </a>
<a name="ln7267">  Fail:</a>
<a name="ln7268">    exc-&gt;new_top = exc-&gt;args;</a>
<a name="ln7269">  }</a>
<a name="ln7270"> </a>
<a name="ln7271"> </a>
<a name="ln7272">  /*************************************************************************/</a>
<a name="ln7273">  /*                                                                       */</a>
<a name="ln7274">  /* MISC. INSTRUCTIONS                                                    */</a>
<a name="ln7275">  /*                                                                       */</a>
<a name="ln7276">  /*************************************************************************/</a>
<a name="ln7277"> </a>
<a name="ln7278"> </a>
<a name="ln7279">  /*************************************************************************/</a>
<a name="ln7280">  /*                                                                       */</a>
<a name="ln7281">  /* GETINFO[]:    GET INFOrmation                                         */</a>
<a name="ln7282">  /* Opcode range: 0x88                                                    */</a>
<a name="ln7283">  /* Stack:        uint32 --&gt; uint32                                       */</a>
<a name="ln7284">  /*                                                                       */</a>
<a name="ln7285">  /* XXX: UNDOCUMENTED: Selector bits higher than 9 are currently (May     */</a>
<a name="ln7286">  /*      2015) not documented in the OpenType specification.              */</a>
<a name="ln7287">  /*                                                                       */</a>
<a name="ln7288">  /*      Selector bit 11 is incorrectly described as bit 8, while the     */</a>
<a name="ln7289">  /*      real meaning of bit 8 (vertical LCD subpixels) stays             */</a>
<a name="ln7290">  /*      undocumented.  The same mistake can be found in Greg Hitchcock's */</a>
<a name="ln7291">  /*      whitepaper.                                                      */</a>
<a name="ln7292">  /*                                                                       */</a>
<a name="ln7293">  static void</a>
<a name="ln7294">  Ins_GETINFO( TT_ExecContext  exc,</a>
<a name="ln7295">               FT_Long*        args )</a>
<a name="ln7296">  {</a>
<a name="ln7297">    FT_Long  K;</a>
<a name="ln7298"> </a>
<a name="ln7299"> </a>
<a name="ln7300">    K = 0;</a>
<a name="ln7301"> </a>
<a name="ln7302">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln7303">    /********************************/</a>
<a name="ln7304">    /* RASTERIZER VERSION           */</a>
<a name="ln7305">    /* Selector Bit:  0             */</a>
<a name="ln7306">    /* Return Bit(s): 0-7           */</a>
<a name="ln7307">    /*                              */</a>
<a name="ln7308">    if ( SUBPIXEL_HINTING      &amp;&amp;</a>
<a name="ln7309">         ( args[0] &amp; 1 ) != 0  &amp;&amp;</a>
<a name="ln7310">         exc-&gt;subpixel_hinting )</a>
<a name="ln7311">    {</a>
<a name="ln7312">      if ( exc-&gt;ignore_x_mode )</a>
<a name="ln7313">      {</a>
<a name="ln7314">        /* if in ClearType backwards compatibility mode,        */</a>
<a name="ln7315">        /* we sometimes change the TrueType version dynamically */</a>
<a name="ln7316">        K = exc-&gt;rasterizer_version;</a>
<a name="ln7317">        FT_TRACE6(( &quot;Setting rasterizer version %d\n&quot;,</a>
<a name="ln7318">                    exc-&gt;rasterizer_version ));</a>
<a name="ln7319">      }</a>
<a name="ln7320">      else</a>
<a name="ln7321">        K = TT_INTERPRETER_VERSION_38;</a>
<a name="ln7322">    }</a>
<a name="ln7323">    else</a>
<a name="ln7324">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln7325">      if ( ( args[0] &amp; 1 ) != 0 )</a>
<a name="ln7326">        K = TT_INTERPRETER_VERSION_35;</a>
<a name="ln7327"> </a>
<a name="ln7328">    /********************************/</a>
<a name="ln7329">    /* GLYPH ROTATED                */</a>
<a name="ln7330">    /* Selector Bit:  1             */</a>
<a name="ln7331">    /* Return Bit(s): 8             */</a>
<a name="ln7332">    /*                              */</a>
<a name="ln7333">    if ( ( args[0] &amp; 2 ) != 0 &amp;&amp; exc-&gt;tt_metrics.rotated )</a>
<a name="ln7334">      K |= 0x80;</a>
<a name="ln7335"> </a>
<a name="ln7336">    /********************************/</a>
<a name="ln7337">    /* GLYPH STRETCHED              */</a>
<a name="ln7338">    /* Selector Bit:  2             */</a>
<a name="ln7339">    /* Return Bit(s): 9             */</a>
<a name="ln7340">    /*                              */</a>
<a name="ln7341">    if ( ( args[0] &amp; 4 ) != 0 &amp;&amp; exc-&gt;tt_metrics.stretched )</a>
<a name="ln7342">      K |= 1 &lt;&lt; 8;</a>
<a name="ln7343"> </a>
<a name="ln7344">    /********************************/</a>
<a name="ln7345">    /* HINTING FOR GRAYSCALE        */</a>
<a name="ln7346">    /* Selector Bit:  5             */</a>
<a name="ln7347">    /* Return Bit(s): 12            */</a>
<a name="ln7348">    /*                              */</a>
<a name="ln7349">    if ( ( args[0] &amp; 32 ) != 0 &amp;&amp; exc-&gt;grayscale )</a>
<a name="ln7350">      K |= 1 &lt;&lt; 12;</a>
<a name="ln7351"> </a>
<a name="ln7352">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln7353"> </a>
<a name="ln7354">    if ( SUBPIXEL_HINTING                                     &amp;&amp;</a>
<a name="ln7355">         exc-&gt;rasterizer_version &gt;= TT_INTERPRETER_VERSION_35 )</a>
<a name="ln7356">    {</a>
<a name="ln7357"> </a>
<a name="ln7358">      if ( exc-&gt;rasterizer_version &gt;= 37 )</a>
<a name="ln7359">      {</a>
<a name="ln7360">        /********************************/</a>
<a name="ln7361">        /* HINTING FOR SUBPIXEL         */</a>
<a name="ln7362">        /* Selector Bit:  6             */</a>
<a name="ln7363">        /* Return Bit(s): 13            */</a>
<a name="ln7364">        /*                              */</a>
<a name="ln7365">        if ( ( args[0] &amp; 64 ) != 0 &amp;&amp; exc-&gt;subpixel_hinting )</a>
<a name="ln7366">          K |= 1 &lt;&lt; 13;</a>
<a name="ln7367"> </a>
<a name="ln7368">        /********************************/</a>
<a name="ln7369">        /* COMPATIBLE WIDTHS ENABLED    */</a>
<a name="ln7370">        /* Selector Bit:  7             */</a>
<a name="ln7371">        /* Return Bit(s): 14            */</a>
<a name="ln7372">        /*                              */</a>
<a name="ln7373">        /* Functionality still needs to be added */</a>
<a name="ln7374">        if ( ( args[0] &amp; 128 ) != 0 &amp;&amp; exc-&gt;compatible_widths )</a>
<a name="ln7375">          K |= 1 &lt;&lt; 14;</a>
<a name="ln7376"> </a>
<a name="ln7377">        /********************************/</a>
<a name="ln7378">        /* VERTICAL LCD SUBPIXELS?      */</a>
<a name="ln7379">        /* Selector Bit:  8             */</a>
<a name="ln7380">        /* Return Bit(s): 15            */</a>
<a name="ln7381">        /*                              */</a>
<a name="ln7382">        /* Functionality still needs to be added */</a>
<a name="ln7383">        if ( ( args[0] &amp; 256 ) != 0 &amp;&amp; exc-&gt;vertical_lcd )</a>
<a name="ln7384">          K |= 1 &lt;&lt; 15;</a>
<a name="ln7385"> </a>
<a name="ln7386">        /********************************/</a>
<a name="ln7387">        /* HINTING FOR BGR?             */</a>
<a name="ln7388">        /* Selector Bit:  9             */</a>
<a name="ln7389">        /* Return Bit(s): 16            */</a>
<a name="ln7390">        /*                              */</a>
<a name="ln7391">        /* Functionality still needs to be added */</a>
<a name="ln7392">        if ( ( args[0] &amp; 512 ) != 0 &amp;&amp; exc-&gt;bgr )</a>
<a name="ln7393">          K |= 1 &lt;&lt; 16;</a>
<a name="ln7394"> </a>
<a name="ln7395">        if ( exc-&gt;rasterizer_version &gt;= 38 )</a>
<a name="ln7396">        {</a>
<a name="ln7397">          /********************************/</a>
<a name="ln7398">          /* SUBPIXEL POSITIONED?         */</a>
<a name="ln7399">          /* Selector Bit:  10            */</a>
<a name="ln7400">          /* Return Bit(s): 17            */</a>
<a name="ln7401">          /*                              */</a>
<a name="ln7402">          /* Functionality still needs to be added */</a>
<a name="ln7403">          if ( ( args[0] &amp; 1024 ) != 0 &amp;&amp; exc-&gt;subpixel_positioned )</a>
<a name="ln7404">            K |= 1 &lt;&lt; 17;</a>
<a name="ln7405"> </a>
<a name="ln7406">          /********************************/</a>
<a name="ln7407">          /* SYMMETRICAL SMOOTHING        */</a>
<a name="ln7408">          /* Selector Bit:  11            */</a>
<a name="ln7409">          /* Return Bit(s): 18            */</a>
<a name="ln7410">          /*                              */</a>
<a name="ln7411">          /* Functionality still needs to be added */</a>
<a name="ln7412">          if ( ( args[0] &amp; 2048 ) != 0 &amp;&amp; exc-&gt;symmetrical_smoothing )</a>
<a name="ln7413">            K |= 1 &lt;&lt; 18;</a>
<a name="ln7414"> </a>
<a name="ln7415">          /********************************/</a>
<a name="ln7416">          /* GRAY CLEARTYPE               */</a>
<a name="ln7417">          /* Selector Bit:  12            */</a>
<a name="ln7418">          /* Return Bit(s): 19            */</a>
<a name="ln7419">          /*                              */</a>
<a name="ln7420">          /* Functionality still needs to be added */</a>
<a name="ln7421">          if ( ( args[0] &amp; 4096 ) != 0 &amp;&amp; exc-&gt;gray_cleartype )</a>
<a name="ln7422">            K |= 1 &lt;&lt; 19;</a>
<a name="ln7423">        }</a>
<a name="ln7424">      }</a>
<a name="ln7425">    }</a>
<a name="ln7426"> </a>
<a name="ln7427">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln7428"> </a>
<a name="ln7429">    args[0] = K;</a>
<a name="ln7430">  }</a>
<a name="ln7431"> </a>
<a name="ln7432"> </a>
<a name="ln7433">  static void</a>
<a name="ln7434">  Ins_UNKNOWN( TT_ExecContext  exc )</a>
<a name="ln7435">  {</a>
<a name="ln7436">    TT_DefRecord*  def   = exc-&gt;IDefs;</a>
<a name="ln7437">    TT_DefRecord*  limit = def + exc-&gt;numIDefs;</a>
<a name="ln7438"> </a>
<a name="ln7439"> </a>
<a name="ln7440">    for ( ; def &lt; limit; def++ )</a>
<a name="ln7441">    {</a>
<a name="ln7442">      if ( (FT_Byte)def-&gt;opc == exc-&gt;opcode &amp;&amp; def-&gt;active )</a>
<a name="ln7443">      {</a>
<a name="ln7444">        TT_CallRec*  call;</a>
<a name="ln7445"> </a>
<a name="ln7446"> </a>
<a name="ln7447">        if ( exc-&gt;callTop &gt;= exc-&gt;callSize )</a>
<a name="ln7448">        {</a>
<a name="ln7449">          exc-&gt;error = FT_THROW( Stack_Overflow );</a>
<a name="ln7450">          return;</a>
<a name="ln7451">        }</a>
<a name="ln7452"> </a>
<a name="ln7453">        call = exc-&gt;callStack + exc-&gt;callTop++;</a>
<a name="ln7454"> </a>
<a name="ln7455">        call-&gt;Caller_Range = exc-&gt;curRange;</a>
<a name="ln7456">        call-&gt;Caller_IP    = exc-&gt;IP + 1;</a>
<a name="ln7457">        call-&gt;Cur_Count    = 1;</a>
<a name="ln7458">        call-&gt;Def          = def;</a>
<a name="ln7459"> </a>
<a name="ln7460">        Ins_Goto_CodeRange( exc, def-&gt;range, def-&gt;start );</a>
<a name="ln7461"> </a>
<a name="ln7462">        exc-&gt;step_ins = FALSE;</a>
<a name="ln7463">        return;</a>
<a name="ln7464">      }</a>
<a name="ln7465">    }</a>
<a name="ln7466"> </a>
<a name="ln7467">    exc-&gt;error = FT_THROW( Invalid_Opcode );</a>
<a name="ln7468">  }</a>
<a name="ln7469"> </a>
<a name="ln7470"> </a>
<a name="ln7471">  /*************************************************************************/</a>
<a name="ln7472">  /*                                                                       */</a>
<a name="ln7473">  /* RUN                                                                   */</a>
<a name="ln7474">  /*                                                                       */</a>
<a name="ln7475">  /*  This function executes a run of opcodes.  It will exit in the        */</a>
<a name="ln7476">  /*  following cases:                                                     */</a>
<a name="ln7477">  /*                                                                       */</a>
<a name="ln7478">  /*  - Errors (in which case it returns FALSE).                           */</a>
<a name="ln7479">  /*                                                                       */</a>
<a name="ln7480">  /*  - Reaching the end of the main code range (returns TRUE).            */</a>
<a name="ln7481">  /*    Reaching the end of a code range within a function call is an      */</a>
<a name="ln7482">  /*    error.                                                             */</a>
<a name="ln7483">  /*                                                                       */</a>
<a name="ln7484">  /*  - After executing one single opcode, if the flag `Instruction_Trap'  */</a>
<a name="ln7485">  /*    is set to TRUE (returns TRUE).                                     */</a>
<a name="ln7486">  /*                                                                       */</a>
<a name="ln7487">  /*  On exit with TRUE, test IP &lt; CodeSize to know whether it comes from  */</a>
<a name="ln7488">  /*  an instruction trap or a normal termination.                         */</a>
<a name="ln7489">  /*                                                                       */</a>
<a name="ln7490">  /*                                                                       */</a>
<a name="ln7491">  /*  Note: The documented DEBUG opcode pops a value from the stack.  This */</a>
<a name="ln7492">  /*        behaviour is unsupported; here a DEBUG opcode is always an     */</a>
<a name="ln7493">  /*        error.                                                         */</a>
<a name="ln7494">  /*                                                                       */</a>
<a name="ln7495">  /*                                                                       */</a>
<a name="ln7496">  /* THIS IS THE INTERPRETER'S MAIN LOOP.                                  */</a>
<a name="ln7497">  /*                                                                       */</a>
<a name="ln7498">  /*************************************************************************/</a>
<a name="ln7499"> </a>
<a name="ln7500"> </a>
<a name="ln7501">  /* documentation is in ttinterp.h */</a>
<a name="ln7502"> </a>
<a name="ln7503">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln7504">  TT_RunIns( TT_ExecContext  exc )</a>
<a name="ln7505">  {</a>
<a name="ln7506">    FT_Long    ins_counter = 0;  /* executed instructions counter */</a>
<a name="ln7507">    FT_UShort  i;</a>
<a name="ln7508"> </a>
<a name="ln7509">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln7510">    FT_Byte    opcode_pattern[1][2] = {</a>
<a name="ln7511">                  /* #8 TypeMan Talk Align */</a>
<a name="ln7512">                  {</a>
<a name="ln7513">                    0x06, /* SPVTL   */</a>
<a name="ln7514">                    0x7D, /* RDTG    */</a>
<a name="ln7515">                  },</a>
<a name="ln7516">                };</a>
<a name="ln7517">    FT_UShort  opcode_patterns   = 1;</a>
<a name="ln7518">    FT_UShort  opcode_pointer[1] = { 0 };</a>
<a name="ln7519">    FT_UShort  opcode_size[1]    = { 1 };</a>
<a name="ln7520">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln7521"> </a>
<a name="ln7522"> </a>
<a name="ln7523">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln7524">    exc-&gt;iup_called = FALSE;</a>
<a name="ln7525">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln7526"> </a>
<a name="ln7527">    /* set PPEM and CVT functions */</a>
<a name="ln7528">    exc-&gt;tt_metrics.ratio = 0;</a>
<a name="ln7529">    if ( exc-&gt;metrics.x_ppem != exc-&gt;metrics.y_ppem )</a>
<a name="ln7530">    {</a>
<a name="ln7531">      /* non-square pixels, use the stretched routines */</a>
<a name="ln7532">      exc-&gt;func_cur_ppem  = Current_Ppem_Stretched;</a>
<a name="ln7533">      exc-&gt;func_read_cvt  = Read_CVT_Stretched;</a>
<a name="ln7534">      exc-&gt;func_write_cvt = Write_CVT_Stretched;</a>
<a name="ln7535">      exc-&gt;func_move_cvt  = Move_CVT_Stretched;</a>
<a name="ln7536">    }</a>
<a name="ln7537">    else</a>
<a name="ln7538">    {</a>
<a name="ln7539">      /* square pixels, use normal routines */</a>
<a name="ln7540">      exc-&gt;func_cur_ppem  = Current_Ppem;</a>
<a name="ln7541">      exc-&gt;func_read_cvt  = Read_CVT;</a>
<a name="ln7542">      exc-&gt;func_write_cvt = Write_CVT;</a>
<a name="ln7543">      exc-&gt;func_move_cvt  = Move_CVT;</a>
<a name="ln7544">    }</a>
<a name="ln7545"> </a>
<a name="ln7546">    Compute_Funcs( exc );</a>
<a name="ln7547">    Compute_Round( exc, (FT_Byte)exc-&gt;GS.round_state );</a>
<a name="ln7548"> </a>
<a name="ln7549">    do</a>
<a name="ln7550">    {</a>
<a name="ln7551">      exc-&gt;opcode = exc-&gt;code[exc-&gt;IP];</a>
<a name="ln7552"> </a>
<a name="ln7553">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln7554">      {</a>
<a name="ln7555">        FT_Long  cnt = FT_MIN( 8, exc-&gt;top );</a>
<a name="ln7556">        FT_Long  n;</a>
<a name="ln7557"> </a>
<a name="ln7558"> </a>
<a name="ln7559">        /* if tracing level is 7, show current code position */</a>
<a name="ln7560">        /* and the first few stack elements also             */</a>
<a name="ln7561">        FT_TRACE6(( &quot;  &quot; ));</a>
<a name="ln7562">        FT_TRACE7(( &quot;%06d &quot;, exc-&gt;IP ));</a>
<a name="ln7563">        FT_TRACE6(( opcode_name[exc-&gt;opcode] + 2 ));</a>
<a name="ln7564">        FT_TRACE7(( &quot;%*s&quot;, *opcode_name[exc-&gt;opcode] == 'A'</a>
<a name="ln7565">                              ? 2</a>
<a name="ln7566">                              : 12 - ( *opcode_name[exc-&gt;opcode] - '0' ),</a>
<a name="ln7567">                              &quot;#&quot; ));</a>
<a name="ln7568">        for ( n = 0; n &lt; cnt; n++ )</a>
<a name="ln7569">          FT_TRACE7(( &quot; %d&quot;, exc-&gt;stack[exc-&gt;top - n] ));</a>
<a name="ln7570">        FT_TRACE6(( &quot;\n&quot; ));</a>
<a name="ln7571">      }</a>
<a name="ln7572">#endif /* FT_DEBUG_LEVEL_TRACE */</a>
<a name="ln7573"> </a>
<a name="ln7574">      if ( ( exc-&gt;length = opcode_length[exc-&gt;opcode] ) &lt; 0 )</a>
<a name="ln7575">      {</a>
<a name="ln7576">        if ( exc-&gt;IP + 1 &gt;= exc-&gt;codeSize )</a>
<a name="ln7577">          goto LErrorCodeOverflow_;</a>
<a name="ln7578"> </a>
<a name="ln7579">        exc-&gt;length = 2 - exc-&gt;length * exc-&gt;code[exc-&gt;IP + 1];</a>
<a name="ln7580">      }</a>
<a name="ln7581"> </a>
<a name="ln7582">      if ( exc-&gt;IP + exc-&gt;length &gt; exc-&gt;codeSize )</a>
<a name="ln7583">        goto LErrorCodeOverflow_;</a>
<a name="ln7584"> </a>
<a name="ln7585">      /* First, let's check for empty stack and overflow */</a>
<a name="ln7586">      exc-&gt;args = exc-&gt;top - ( Pop_Push_Count[exc-&gt;opcode] &gt;&gt; 4 );</a>
<a name="ln7587"> </a>
<a name="ln7588">      /* `args' is the top of the stack once arguments have been popped. */</a>
<a name="ln7589">      /* One can also interpret it as the index of the last argument.    */</a>
<a name="ln7590">      if ( exc-&gt;args &lt; 0 )</a>
<a name="ln7591">      {</a>
<a name="ln7592">        if ( exc-&gt;pedantic_hinting )</a>
<a name="ln7593">        {</a>
<a name="ln7594">          exc-&gt;error = FT_THROW( Too_Few_Arguments );</a>
<a name="ln7595">          goto LErrorLabel_;</a>
<a name="ln7596">        }</a>
<a name="ln7597"> </a>
<a name="ln7598">        /* push zeroes onto the stack */</a>
<a name="ln7599">        for ( i = 0; i &lt; Pop_Push_Count[exc-&gt;opcode] &gt;&gt; 4; i++ )</a>
<a name="ln7600">          exc-&gt;stack[i] = 0;</a>
<a name="ln7601">        exc-&gt;args = 0;</a>
<a name="ln7602">      }</a>
<a name="ln7603"> </a>
<a name="ln7604">      exc-&gt;new_top = exc-&gt;args + ( Pop_Push_Count[exc-&gt;opcode] &amp; 15 );</a>
<a name="ln7605"> </a>
<a name="ln7606">      /* `new_top' is the new top of the stack, after the instruction's */</a>
<a name="ln7607">      /* execution.  `top' will be set to `new_top' after the `switch'  */</a>
<a name="ln7608">      /* statement.                                                     */</a>
<a name="ln7609">      if ( exc-&gt;new_top &gt; exc-&gt;stackSize )</a>
<a name="ln7610">      {</a>
<a name="ln7611">        exc-&gt;error = FT_THROW( Stack_Overflow );</a>
<a name="ln7612">        goto LErrorLabel_;</a>
<a name="ln7613">      }</a>
<a name="ln7614"> </a>
<a name="ln7615">      exc-&gt;step_ins = TRUE;</a>
<a name="ln7616">      exc-&gt;error    = FT_Err_Ok;</a>
<a name="ln7617"> </a>
<a name="ln7618">#ifdef TT_CONFIG_OPTION_SUBPIXEL_HINTING</a>
<a name="ln7619"> </a>
<a name="ln7620">      if ( SUBPIXEL_HINTING )</a>
<a name="ln7621">      {</a>
<a name="ln7622">        for ( i = 0; i &lt; opcode_patterns; i++ )</a>
<a name="ln7623">        {</a>
<a name="ln7624">          if ( opcode_pointer[i] &lt; opcode_size[i]                  &amp;&amp;</a>
<a name="ln7625">               exc-&gt;opcode == opcode_pattern[i][opcode_pointer[i]] )</a>
<a name="ln7626">          {</a>
<a name="ln7627">            opcode_pointer[i] += 1;</a>
<a name="ln7628"> </a>
<a name="ln7629">            if ( opcode_pointer[i] == opcode_size[i] )</a>
<a name="ln7630">            {</a>
<a name="ln7631">              FT_TRACE6(( &quot;sph: opcode ptrn: %d, %s %s\n&quot;,</a>
<a name="ln7632">                          i,</a>
<a name="ln7633">                          exc-&gt;face-&gt;root.family_name,</a>
<a name="ln7634">                          exc-&gt;face-&gt;root.style_name ));</a>
<a name="ln7635"> </a>
<a name="ln7636">              switch ( i )</a>
<a name="ln7637">              {</a>
<a name="ln7638">              case 0:</a>
<a name="ln7639">                break;</a>
<a name="ln7640">              }</a>
<a name="ln7641">              opcode_pointer[i] = 0;</a>
<a name="ln7642">            }</a>
<a name="ln7643">          }</a>
<a name="ln7644">          else</a>
<a name="ln7645">            opcode_pointer[i] = 0;</a>
<a name="ln7646">        }</a>
<a name="ln7647">      }</a>
<a name="ln7648"> </a>
<a name="ln7649">#endif /* TT_CONFIG_OPTION_SUBPIXEL_HINTING */</a>
<a name="ln7650"> </a>
<a name="ln7651">      {</a>
<a name="ln7652">        FT_Long*  args   = exc-&gt;stack + exc-&gt;args;</a>
<a name="ln7653">        FT_Byte   opcode = exc-&gt;opcode;</a>
<a name="ln7654"> </a>
<a name="ln7655"> </a>
<a name="ln7656">        switch ( opcode )</a>
<a name="ln7657">        {</a>
<a name="ln7658">        case 0x00:  /* SVTCA y  */</a>
<a name="ln7659">        case 0x01:  /* SVTCA x  */</a>
<a name="ln7660">        case 0x02:  /* SPvTCA y */</a>
<a name="ln7661">        case 0x03:  /* SPvTCA x */</a>
<a name="ln7662">        case 0x04:  /* SFvTCA y */</a>
<a name="ln7663">        case 0x05:  /* SFvTCA x */</a>
<a name="ln7664">          Ins_SxyTCA( exc );</a>
<a name="ln7665">          break;</a>
<a name="ln7666"> </a>
<a name="ln7667">        case 0x06:  /* SPvTL // */</a>
<a name="ln7668">        case 0x07:  /* SPvTL +  */</a>
<a name="ln7669">          Ins_SPVTL( exc, args );</a>
<a name="ln7670">          break;</a>
<a name="ln7671"> </a>
<a name="ln7672">        case 0x08:  /* SFvTL // */</a>
<a name="ln7673">        case 0x09:  /* SFvTL +  */</a>
<a name="ln7674">          Ins_SFVTL( exc, args );</a>
<a name="ln7675">          break;</a>
<a name="ln7676"> </a>
<a name="ln7677">        case 0x0A:  /* SPvFS */</a>
<a name="ln7678">          Ins_SPVFS( exc, args );</a>
<a name="ln7679">          break;</a>
<a name="ln7680"> </a>
<a name="ln7681">        case 0x0B:  /* SFvFS */</a>
<a name="ln7682">          Ins_SFVFS( exc, args );</a>
<a name="ln7683">          break;</a>
<a name="ln7684"> </a>
<a name="ln7685">        case 0x0C:  /* GPv */</a>
<a name="ln7686">          Ins_GPV( exc, args );</a>
<a name="ln7687">          break;</a>
<a name="ln7688"> </a>
<a name="ln7689">        case 0x0D:  /* GFv */</a>
<a name="ln7690">          Ins_GFV( exc, args );</a>
<a name="ln7691">          break;</a>
<a name="ln7692"> </a>
<a name="ln7693">        case 0x0E:  /* SFvTPv */</a>
<a name="ln7694">          Ins_SFVTPV( exc );</a>
<a name="ln7695">          break;</a>
<a name="ln7696"> </a>
<a name="ln7697">        case 0x0F:  /* ISECT  */</a>
<a name="ln7698">          Ins_ISECT( exc, args );</a>
<a name="ln7699">          break;</a>
<a name="ln7700"> </a>
<a name="ln7701">        case 0x10:  /* SRP0 */</a>
<a name="ln7702">          Ins_SRP0( exc, args );</a>
<a name="ln7703">          break;</a>
<a name="ln7704"> </a>
<a name="ln7705">        case 0x11:  /* SRP1 */</a>
<a name="ln7706">          Ins_SRP1( exc, args );</a>
<a name="ln7707">          break;</a>
<a name="ln7708"> </a>
<a name="ln7709">        case 0x12:  /* SRP2 */</a>
<a name="ln7710">          Ins_SRP2( exc, args );</a>
<a name="ln7711">          break;</a>
<a name="ln7712"> </a>
<a name="ln7713">        case 0x13:  /* SZP0 */</a>
<a name="ln7714">          Ins_SZP0( exc, args );</a>
<a name="ln7715">          break;</a>
<a name="ln7716"> </a>
<a name="ln7717">        case 0x14:  /* SZP1 */</a>
<a name="ln7718">          Ins_SZP1( exc, args );</a>
<a name="ln7719">          break;</a>
<a name="ln7720"> </a>
<a name="ln7721">        case 0x15:  /* SZP2 */</a>
<a name="ln7722">          Ins_SZP2( exc, args );</a>
<a name="ln7723">          break;</a>
<a name="ln7724"> </a>
<a name="ln7725">        case 0x16:  /* SZPS */</a>
<a name="ln7726">          Ins_SZPS( exc, args );</a>
<a name="ln7727">          break;</a>
<a name="ln7728"> </a>
<a name="ln7729">        case 0x17:  /* SLOOP */</a>
<a name="ln7730">          Ins_SLOOP( exc, args );</a>
<a name="ln7731">          break;</a>
<a name="ln7732"> </a>
<a name="ln7733">        case 0x18:  /* RTG */</a>
<a name="ln7734">          Ins_RTG( exc );</a>
<a name="ln7735">          break;</a>
<a name="ln7736"> </a>
<a name="ln7737">        case 0x19:  /* RTHG */</a>
<a name="ln7738">          Ins_RTHG( exc );</a>
<a name="ln7739">          break;</a>
<a name="ln7740"> </a>
<a name="ln7741">        case 0x1A:  /* SMD */</a>
<a name="ln7742">          Ins_SMD( exc, args );</a>
<a name="ln7743">          break;</a>
<a name="ln7744"> </a>
<a name="ln7745">        case 0x1B:  /* ELSE */</a>
<a name="ln7746">          Ins_ELSE( exc );</a>
<a name="ln7747">          break;</a>
<a name="ln7748"> </a>
<a name="ln7749">        case 0x1C:  /* JMPR */</a>
<a name="ln7750">          Ins_JMPR( exc, args );</a>
<a name="ln7751">          break;</a>
<a name="ln7752"> </a>
<a name="ln7753">        case 0x1D:  /* SCVTCI */</a>
<a name="ln7754">          Ins_SCVTCI( exc, args );</a>
<a name="ln7755">          break;</a>
<a name="ln7756"> </a>
<a name="ln7757">        case 0x1E:  /* SSWCI */</a>
<a name="ln7758">          Ins_SSWCI( exc, args );</a>
<a name="ln7759">          break;</a>
<a name="ln7760"> </a>
<a name="ln7761">        case 0x1F:  /* SSW */</a>
<a name="ln7762">          Ins_SSW( exc, args );</a>
<a name="ln7763">          break;</a>
<a name="ln7764"> </a>
<a name="ln7765">        case 0x20:  /* DUP */</a>
<a name="ln7766">          Ins_DUP( args );</a>
<a name="ln7767">          break;</a>
<a name="ln7768"> </a>
<a name="ln7769">        case 0x21:  /* POP */</a>
<a name="ln7770">          Ins_POP();</a>
<a name="ln7771">          break;</a>
<a name="ln7772"> </a>
<a name="ln7773">        case 0x22:  /* CLEAR */</a>
<a name="ln7774">          Ins_CLEAR( exc );</a>
<a name="ln7775">          break;</a>
<a name="ln7776"> </a>
<a name="ln7777">        case 0x23:  /* SWAP */</a>
<a name="ln7778">          Ins_SWAP( args );</a>
<a name="ln7779">          break;</a>
<a name="ln7780"> </a>
<a name="ln7781">        case 0x24:  /* DEPTH */</a>
<a name="ln7782">          Ins_DEPTH( exc, args );</a>
<a name="ln7783">          break;</a>
<a name="ln7784"> </a>
<a name="ln7785">        case 0x25:  /* CINDEX */</a>
<a name="ln7786">          Ins_CINDEX( exc, args );</a>
<a name="ln7787">          break;</a>
<a name="ln7788"> </a>
<a name="ln7789">        case 0x26:  /* MINDEX */</a>
<a name="ln7790">          Ins_MINDEX( exc, args );</a>
<a name="ln7791">          break;</a>
<a name="ln7792"> </a>
<a name="ln7793">        case 0x27:  /* ALIGNPTS */</a>
<a name="ln7794">          Ins_ALIGNPTS( exc, args );</a>
<a name="ln7795">          break;</a>
<a name="ln7796"> </a>
<a name="ln7797">        case 0x28:  /* ???? */</a>
<a name="ln7798">          Ins_UNKNOWN( exc );</a>
<a name="ln7799">          break;</a>
<a name="ln7800"> </a>
<a name="ln7801">        case 0x29:  /* UTP */</a>
<a name="ln7802">          Ins_UTP( exc, args );</a>
<a name="ln7803">          break;</a>
<a name="ln7804"> </a>
<a name="ln7805">        case 0x2A:  /* LOOPCALL */</a>
<a name="ln7806">          Ins_LOOPCALL( exc, args );</a>
<a name="ln7807">          break;</a>
<a name="ln7808"> </a>
<a name="ln7809">        case 0x2B:  /* CALL */</a>
<a name="ln7810">          Ins_CALL( exc, args );</a>
<a name="ln7811">          break;</a>
<a name="ln7812"> </a>
<a name="ln7813">        case 0x2C:  /* FDEF */</a>
<a name="ln7814">          Ins_FDEF( exc, args );</a>
<a name="ln7815">          break;</a>
<a name="ln7816"> </a>
<a name="ln7817">        case 0x2D:  /* ENDF */</a>
<a name="ln7818">          Ins_ENDF( exc );</a>
<a name="ln7819">          break;</a>
<a name="ln7820"> </a>
<a name="ln7821">        case 0x2E:  /* MDAP */</a>
<a name="ln7822">        case 0x2F:  /* MDAP */</a>
<a name="ln7823">          Ins_MDAP( exc, args );</a>
<a name="ln7824">          break;</a>
<a name="ln7825"> </a>
<a name="ln7826">        case 0x30:  /* IUP */</a>
<a name="ln7827">        case 0x31:  /* IUP */</a>
<a name="ln7828">          Ins_IUP( exc );</a>
<a name="ln7829">          break;</a>
<a name="ln7830"> </a>
<a name="ln7831">        case 0x32:  /* SHP */</a>
<a name="ln7832">        case 0x33:  /* SHP */</a>
<a name="ln7833">          Ins_SHP( exc );</a>
<a name="ln7834">          break;</a>
<a name="ln7835"> </a>
<a name="ln7836">        case 0x34:  /* SHC */</a>
<a name="ln7837">        case 0x35:  /* SHC */</a>
<a name="ln7838">          Ins_SHC( exc, args );</a>
<a name="ln7839">          break;</a>
<a name="ln7840"> </a>
<a name="ln7841">        case 0x36:  /* SHZ */</a>
<a name="ln7842">        case 0x37:  /* SHZ */</a>
<a name="ln7843">          Ins_SHZ( exc, args );</a>
<a name="ln7844">          break;</a>
<a name="ln7845"> </a>
<a name="ln7846">        case 0x38:  /* SHPIX */</a>
<a name="ln7847">          Ins_SHPIX( exc, args );</a>
<a name="ln7848">          break;</a>
<a name="ln7849"> </a>
<a name="ln7850">        case 0x39:  /* IP    */</a>
<a name="ln7851">          Ins_IP( exc );</a>
<a name="ln7852">          break;</a>
<a name="ln7853"> </a>
<a name="ln7854">        case 0x3A:  /* MSIRP */</a>
<a name="ln7855">        case 0x3B:  /* MSIRP */</a>
<a name="ln7856">          Ins_MSIRP( exc, args );</a>
<a name="ln7857">          break;</a>
<a name="ln7858"> </a>
<a name="ln7859">        case 0x3C:  /* AlignRP */</a>
<a name="ln7860">          Ins_ALIGNRP( exc );</a>
<a name="ln7861">          break;</a>
<a name="ln7862"> </a>
<a name="ln7863">        case 0x3D:  /* RTDG */</a>
<a name="ln7864">          Ins_RTDG( exc );</a>
<a name="ln7865">          break;</a>
<a name="ln7866"> </a>
<a name="ln7867">        case 0x3E:  /* MIAP */</a>
<a name="ln7868">        case 0x3F:  /* MIAP */</a>
<a name="ln7869">          Ins_MIAP( exc, args );</a>
<a name="ln7870">          break;</a>
<a name="ln7871"> </a>
<a name="ln7872">        case 0x40:  /* NPUSHB */</a>
<a name="ln7873">          Ins_NPUSHB( exc, args );</a>
<a name="ln7874">          break;</a>
<a name="ln7875"> </a>
<a name="ln7876">        case 0x41:  /* NPUSHW */</a>
<a name="ln7877">          Ins_NPUSHW( exc, args );</a>
<a name="ln7878">          break;</a>
<a name="ln7879"> </a>
<a name="ln7880">        case 0x42:  /* WS */</a>
<a name="ln7881">          Ins_WS( exc, args );</a>
<a name="ln7882">          break;</a>
<a name="ln7883"> </a>
<a name="ln7884">        case 0x43:  /* RS */</a>
<a name="ln7885">          Ins_RS( exc, args );</a>
<a name="ln7886">          break;</a>
<a name="ln7887"> </a>
<a name="ln7888">        case 0x44:  /* WCVTP */</a>
<a name="ln7889">          Ins_WCVTP( exc, args );</a>
<a name="ln7890">          break;</a>
<a name="ln7891"> </a>
<a name="ln7892">        case 0x45:  /* RCVT */</a>
<a name="ln7893">          Ins_RCVT( exc, args );</a>
<a name="ln7894">          break;</a>
<a name="ln7895"> </a>
<a name="ln7896">        case 0x46:  /* GC */</a>
<a name="ln7897">        case 0x47:  /* GC */</a>
<a name="ln7898">          Ins_GC( exc, args );</a>
<a name="ln7899">          break;</a>
<a name="ln7900"> </a>
<a name="ln7901">        case 0x48:  /* SCFS */</a>
<a name="ln7902">          Ins_SCFS( exc, args );</a>
<a name="ln7903">          break;</a>
<a name="ln7904"> </a>
<a name="ln7905">        case 0x49:  /* MD */</a>
<a name="ln7906">        case 0x4A:  /* MD */</a>
<a name="ln7907">          Ins_MD( exc, args );</a>
<a name="ln7908">          break;</a>
<a name="ln7909"> </a>
<a name="ln7910">        case 0x4B:  /* MPPEM */</a>
<a name="ln7911">          Ins_MPPEM( exc, args );</a>
<a name="ln7912">          break;</a>
<a name="ln7913"> </a>
<a name="ln7914">        case 0x4C:  /* MPS */</a>
<a name="ln7915">          Ins_MPS( exc, args );</a>
<a name="ln7916">          break;</a>
<a name="ln7917"> </a>
<a name="ln7918">        case 0x4D:  /* FLIPON */</a>
<a name="ln7919">          Ins_FLIPON( exc );</a>
<a name="ln7920">          break;</a>
<a name="ln7921"> </a>
<a name="ln7922">        case 0x4E:  /* FLIPOFF */</a>
<a name="ln7923">          Ins_FLIPOFF( exc );</a>
<a name="ln7924">          break;</a>
<a name="ln7925"> </a>
<a name="ln7926">        case 0x4F:  /* DEBUG */</a>
<a name="ln7927">          Ins_DEBUG( exc );</a>
<a name="ln7928">          break;</a>
<a name="ln7929"> </a>
<a name="ln7930">        case 0x50:  /* LT */</a>
<a name="ln7931">          Ins_LT( args );</a>
<a name="ln7932">          break;</a>
<a name="ln7933"> </a>
<a name="ln7934">        case 0x51:  /* LTEQ */</a>
<a name="ln7935">          Ins_LTEQ( args );</a>
<a name="ln7936">          break;</a>
<a name="ln7937"> </a>
<a name="ln7938">        case 0x52:  /* GT */</a>
<a name="ln7939">          Ins_GT( args );</a>
<a name="ln7940">          break;</a>
<a name="ln7941"> </a>
<a name="ln7942">        case 0x53:  /* GTEQ */</a>
<a name="ln7943">          Ins_GTEQ( args );</a>
<a name="ln7944">          break;</a>
<a name="ln7945"> </a>
<a name="ln7946">        case 0x54:  /* EQ */</a>
<a name="ln7947">          Ins_EQ( args );</a>
<a name="ln7948">          break;</a>
<a name="ln7949"> </a>
<a name="ln7950">        case 0x55:  /* NEQ */</a>
<a name="ln7951">          Ins_NEQ( args );</a>
<a name="ln7952">          break;</a>
<a name="ln7953"> </a>
<a name="ln7954">        case 0x56:  /* ODD */</a>
<a name="ln7955">          Ins_ODD( exc, args );</a>
<a name="ln7956">          break;</a>
<a name="ln7957"> </a>
<a name="ln7958">        case 0x57:  /* EVEN */</a>
<a name="ln7959">          Ins_EVEN( exc, args );</a>
<a name="ln7960">          break;</a>
<a name="ln7961"> </a>
<a name="ln7962">        case 0x58:  /* IF */</a>
<a name="ln7963">          Ins_IF( exc, args );</a>
<a name="ln7964">          break;</a>
<a name="ln7965"> </a>
<a name="ln7966">        case 0x59:  /* EIF */</a>
<a name="ln7967">          Ins_EIF();</a>
<a name="ln7968">          break;</a>
<a name="ln7969"> </a>
<a name="ln7970">        case 0x5A:  /* AND */</a>
<a name="ln7971">          Ins_AND( args );</a>
<a name="ln7972">          break;</a>
<a name="ln7973"> </a>
<a name="ln7974">        case 0x5B:  /* OR */</a>
<a name="ln7975">          Ins_OR( args );</a>
<a name="ln7976">          break;</a>
<a name="ln7977"> </a>
<a name="ln7978">        case 0x5C:  /* NOT */</a>
<a name="ln7979">          Ins_NOT( args );</a>
<a name="ln7980">          break;</a>
<a name="ln7981"> </a>
<a name="ln7982">        case 0x5D:  /* DELTAP1 */</a>
<a name="ln7983">          Ins_DELTAP( exc, args );</a>
<a name="ln7984">          break;</a>
<a name="ln7985"> </a>
<a name="ln7986">        case 0x5E:  /* SDB */</a>
<a name="ln7987">          Ins_SDB( exc, args );</a>
<a name="ln7988">          break;</a>
<a name="ln7989"> </a>
<a name="ln7990">        case 0x5F:  /* SDS */</a>
<a name="ln7991">          Ins_SDS( exc, args );</a>
<a name="ln7992">          break;</a>
<a name="ln7993"> </a>
<a name="ln7994">        case 0x60:  /* ADD */</a>
<a name="ln7995">          Ins_ADD( args );</a>
<a name="ln7996">          break;</a>
<a name="ln7997"> </a>
<a name="ln7998">        case 0x61:  /* SUB */</a>
<a name="ln7999">          Ins_SUB( args );</a>
<a name="ln8000">          break;</a>
<a name="ln8001"> </a>
<a name="ln8002">        case 0x62:  /* DIV */</a>
<a name="ln8003">          Ins_DIV( exc, args );</a>
<a name="ln8004">          break;</a>
<a name="ln8005"> </a>
<a name="ln8006">        case 0x63:  /* MUL */</a>
<a name="ln8007">          Ins_MUL( args );</a>
<a name="ln8008">          break;</a>
<a name="ln8009"> </a>
<a name="ln8010">        case 0x64:  /* ABS */</a>
<a name="ln8011">          Ins_ABS( args );</a>
<a name="ln8012">          break;</a>
<a name="ln8013"> </a>
<a name="ln8014">        case 0x65:  /* NEG */</a>
<a name="ln8015">          Ins_NEG( args );</a>
<a name="ln8016">          break;</a>
<a name="ln8017"> </a>
<a name="ln8018">        case 0x66:  /* FLOOR */</a>
<a name="ln8019">          Ins_FLOOR( args );</a>
<a name="ln8020">          break;</a>
<a name="ln8021"> </a>
<a name="ln8022">        case 0x67:  /* CEILING */</a>
<a name="ln8023">          Ins_CEILING( args );</a>
<a name="ln8024">          break;</a>
<a name="ln8025"> </a>
<a name="ln8026">        case 0x68:  /* ROUND */</a>
<a name="ln8027">        case 0x69:  /* ROUND */</a>
<a name="ln8028">        case 0x6A:  /* ROUND */</a>
<a name="ln8029">        case 0x6B:  /* ROUND */</a>
<a name="ln8030">          Ins_ROUND( exc, args );</a>
<a name="ln8031">          break;</a>
<a name="ln8032"> </a>
<a name="ln8033">        case 0x6C:  /* NROUND */</a>
<a name="ln8034">        case 0x6D:  /* NROUND */</a>
<a name="ln8035">        case 0x6E:  /* NRRUND */</a>
<a name="ln8036">        case 0x6F:  /* NROUND */</a>
<a name="ln8037">          Ins_NROUND( exc, args );</a>
<a name="ln8038">          break;</a>
<a name="ln8039"> </a>
<a name="ln8040">        case 0x70:  /* WCVTF */</a>
<a name="ln8041">          Ins_WCVTF( exc, args );</a>
<a name="ln8042">          break;</a>
<a name="ln8043"> </a>
<a name="ln8044">        case 0x71:  /* DELTAP2 */</a>
<a name="ln8045">        case 0x72:  /* DELTAP3 */</a>
<a name="ln8046">          Ins_DELTAP( exc, args );</a>
<a name="ln8047">          break;</a>
<a name="ln8048"> </a>
<a name="ln8049">        case 0x73:  /* DELTAC0 */</a>
<a name="ln8050">        case 0x74:  /* DELTAC1 */</a>
<a name="ln8051">        case 0x75:  /* DELTAC2 */</a>
<a name="ln8052">          Ins_DELTAC( exc, args );</a>
<a name="ln8053">          break;</a>
<a name="ln8054"> </a>
<a name="ln8055">        case 0x76:  /* SROUND */</a>
<a name="ln8056">          Ins_SROUND( exc, args );</a>
<a name="ln8057">          break;</a>
<a name="ln8058"> </a>
<a name="ln8059">        case 0x77:  /* S45Round */</a>
<a name="ln8060">          Ins_S45ROUND( exc, args );</a>
<a name="ln8061">          break;</a>
<a name="ln8062"> </a>
<a name="ln8063">        case 0x78:  /* JROT */</a>
<a name="ln8064">          Ins_JROT( exc, args );</a>
<a name="ln8065">          break;</a>
<a name="ln8066"> </a>
<a name="ln8067">        case 0x79:  /* JROF */</a>
<a name="ln8068">          Ins_JROF( exc, args );</a>
<a name="ln8069">          break;</a>
<a name="ln8070"> </a>
<a name="ln8071">        case 0x7A:  /* ROFF */</a>
<a name="ln8072">          Ins_ROFF( exc );</a>
<a name="ln8073">          break;</a>
<a name="ln8074"> </a>
<a name="ln8075">        case 0x7B:  /* ???? */</a>
<a name="ln8076">          Ins_UNKNOWN( exc );</a>
<a name="ln8077">          break;</a>
<a name="ln8078"> </a>
<a name="ln8079">        case 0x7C:  /* RUTG */</a>
<a name="ln8080">          Ins_RUTG( exc );</a>
<a name="ln8081">          break;</a>
<a name="ln8082"> </a>
<a name="ln8083">        case 0x7D:  /* RDTG */</a>
<a name="ln8084">          Ins_RDTG( exc );</a>
<a name="ln8085">          break;</a>
<a name="ln8086"> </a>
<a name="ln8087">        case 0x7E:  /* SANGW */</a>
<a name="ln8088">          Ins_SANGW();</a>
<a name="ln8089">          break;</a>
<a name="ln8090"> </a>
<a name="ln8091">        case 0x7F:  /* AA */</a>
<a name="ln8092">          Ins_AA();</a>
<a name="ln8093">          break;</a>
<a name="ln8094"> </a>
<a name="ln8095">        case 0x80:  /* FLIPPT */</a>
<a name="ln8096">          Ins_FLIPPT( exc );</a>
<a name="ln8097">          break;</a>
<a name="ln8098"> </a>
<a name="ln8099">        case 0x81:  /* FLIPRGON */</a>
<a name="ln8100">          Ins_FLIPRGON( exc, args );</a>
<a name="ln8101">          break;</a>
<a name="ln8102"> </a>
<a name="ln8103">        case 0x82:  /* FLIPRGOFF */</a>
<a name="ln8104">          Ins_FLIPRGOFF( exc, args );</a>
<a name="ln8105">          break;</a>
<a name="ln8106"> </a>
<a name="ln8107">        case 0x83:  /* UNKNOWN */</a>
<a name="ln8108">        case 0x84:  /* UNKNOWN */</a>
<a name="ln8109">          Ins_UNKNOWN( exc );</a>
<a name="ln8110">          break;</a>
<a name="ln8111"> </a>
<a name="ln8112">        case 0x85:  /* SCANCTRL */</a>
<a name="ln8113">          Ins_SCANCTRL( exc, args );</a>
<a name="ln8114">          break;</a>
<a name="ln8115"> </a>
<a name="ln8116">        case 0x86:  /* SDPvTL */</a>
<a name="ln8117">        case 0x87:  /* SDPvTL */</a>
<a name="ln8118">          Ins_SDPVTL( exc, args );</a>
<a name="ln8119">          break;</a>
<a name="ln8120"> </a>
<a name="ln8121">        case 0x88:  /* GETINFO */</a>
<a name="ln8122">          Ins_GETINFO( exc, args );</a>
<a name="ln8123">          break;</a>
<a name="ln8124"> </a>
<a name="ln8125">        case 0x89:  /* IDEF */</a>
<a name="ln8126">          Ins_IDEF( exc, args );</a>
<a name="ln8127">          break;</a>
<a name="ln8128"> </a>
<a name="ln8129">        case 0x8A:  /* ROLL */</a>
<a name="ln8130">          Ins_ROLL( args );</a>
<a name="ln8131">          break;</a>
<a name="ln8132"> </a>
<a name="ln8133">        case 0x8B:  /* MAX */</a>
<a name="ln8134">          Ins_MAX( args );</a>
<a name="ln8135">          break;</a>
<a name="ln8136"> </a>
<a name="ln8137">        case 0x8C:  /* MIN */</a>
<a name="ln8138">          Ins_MIN( args );</a>
<a name="ln8139">          break;</a>
<a name="ln8140"> </a>
<a name="ln8141">        case 0x8D:  /* SCANTYPE */</a>
<a name="ln8142">          Ins_SCANTYPE( exc, args );</a>
<a name="ln8143">          break;</a>
<a name="ln8144"> </a>
<a name="ln8145">        case 0x8E:  /* INSTCTRL */</a>
<a name="ln8146">          Ins_INSTCTRL( exc, args );</a>
<a name="ln8147">          break;</a>
<a name="ln8148"> </a>
<a name="ln8149">        case 0x8F:</a>
<a name="ln8150">          Ins_UNKNOWN( exc );</a>
<a name="ln8151">          break;</a>
<a name="ln8152"> </a>
<a name="ln8153">        default:</a>
<a name="ln8154">          if ( opcode &gt;= 0xE0 )</a>
<a name="ln8155">            Ins_MIRP( exc, args );</a>
<a name="ln8156">          else if ( opcode &gt;= 0xC0 )</a>
<a name="ln8157">            Ins_MDRP( exc, args );</a>
<a name="ln8158">          else if ( opcode &gt;= 0xB8 )</a>
<a name="ln8159">            Ins_PUSHW( exc, args );</a>
<a name="ln8160">          else if ( opcode &gt;= 0xB0 )</a>
<a name="ln8161">            Ins_PUSHB( exc, args );</a>
<a name="ln8162">          else</a>
<a name="ln8163">            Ins_UNKNOWN( exc );</a>
<a name="ln8164">        }</a>
<a name="ln8165">      }</a>
<a name="ln8166"> </a>
<a name="ln8167">      if ( exc-&gt;error )</a>
<a name="ln8168">      {</a>
<a name="ln8169">        switch ( exc-&gt;error )</a>
<a name="ln8170">        {</a>
<a name="ln8171">          /* looking for redefined instructions */</a>
<a name="ln8172">        case FT_ERR( Invalid_Opcode ):</a>
<a name="ln8173">          {</a>
<a name="ln8174">            TT_DefRecord*  def   = exc-&gt;IDefs;</a>
<a name="ln8175">            TT_DefRecord*  limit = def + exc-&gt;numIDefs;</a>
<a name="ln8176"> </a>
<a name="ln8177"> </a>
<a name="ln8178">            for ( ; def &lt; limit; def++ )</a>
<a name="ln8179">            {</a>
<a name="ln8180">              if ( def-&gt;active &amp;&amp; exc-&gt;opcode == (FT_Byte)def-&gt;opc )</a>
<a name="ln8181">              {</a>
<a name="ln8182">                TT_CallRec*  callrec;</a>
<a name="ln8183"> </a>
<a name="ln8184"> </a>
<a name="ln8185">                if ( exc-&gt;callTop &gt;= exc-&gt;callSize )</a>
<a name="ln8186">                {</a>
<a name="ln8187">                  exc-&gt;error = FT_THROW( Invalid_Reference );</a>
<a name="ln8188">                  goto LErrorLabel_;</a>
<a name="ln8189">                }</a>
<a name="ln8190"> </a>
<a name="ln8191">                callrec = &amp;exc-&gt;callStack[exc-&gt;callTop];</a>
<a name="ln8192"> </a>
<a name="ln8193">                callrec-&gt;Caller_Range = exc-&gt;curRange;</a>
<a name="ln8194">                callrec-&gt;Caller_IP    = exc-&gt;IP + 1;</a>
<a name="ln8195">                callrec-&gt;Cur_Count    = 1;</a>
<a name="ln8196">                callrec-&gt;Def          = def;</a>
<a name="ln8197"> </a>
<a name="ln8198">                if ( Ins_Goto_CodeRange( exc,</a>
<a name="ln8199">                                         def-&gt;range,</a>
<a name="ln8200">                                         def-&gt;start ) == FAILURE )</a>
<a name="ln8201">                  goto LErrorLabel_;</a>
<a name="ln8202"> </a>
<a name="ln8203">                goto LSuiteLabel_;</a>
<a name="ln8204">              }</a>
<a name="ln8205">            }</a>
<a name="ln8206">          }</a>
<a name="ln8207"> </a>
<a name="ln8208">          exc-&gt;error = FT_THROW( Invalid_Opcode );</a>
<a name="ln8209">          goto LErrorLabel_;</a>
<a name="ln8210"> </a>
<a name="ln8211">#if 0</a>
<a name="ln8212">          break;   /* Unreachable code warning suppression.             */</a>
<a name="ln8213">                   /* Leave to remind in case a later change the editor */</a>
<a name="ln8214">                   /* to consider break;                                */</a>
<a name="ln8215">#endif</a>
<a name="ln8216"> </a>
<a name="ln8217">        default:</a>
<a name="ln8218">          goto LErrorLabel_;</a>
<a name="ln8219"> </a>
<a name="ln8220">#if 0</a>
<a name="ln8221">        break;</a>
<a name="ln8222">#endif</a>
<a name="ln8223">        }</a>
<a name="ln8224">      }</a>
<a name="ln8225"> </a>
<a name="ln8226">      exc-&gt;top = exc-&gt;new_top;</a>
<a name="ln8227"> </a>
<a name="ln8228">      if ( exc-&gt;step_ins )</a>
<a name="ln8229">        exc-&gt;IP += exc-&gt;length;</a>
<a name="ln8230"> </a>
<a name="ln8231">      /* increment instruction counter and check if we didn't */</a>
<a name="ln8232">      /* run this program for too long (e.g. infinite loops). */</a>
<a name="ln8233">      if ( ++ins_counter &gt; MAX_RUNNABLE_OPCODES )</a>
<a name="ln8234">        return FT_THROW( Execution_Too_Long );</a>
<a name="ln8235"> </a>
<a name="ln8236">    LSuiteLabel_:</a>
<a name="ln8237">      if ( exc-&gt;IP &gt;= exc-&gt;codeSize )</a>
<a name="ln8238">      {</a>
<a name="ln8239">        if ( exc-&gt;callTop &gt; 0 )</a>
<a name="ln8240">        {</a>
<a name="ln8241">          exc-&gt;error = FT_THROW( Code_Overflow );</a>
<a name="ln8242">          goto LErrorLabel_;</a>
<a name="ln8243">        }</a>
<a name="ln8244">        else</a>
<a name="ln8245">          goto LNo_Error_;</a>
<a name="ln8246">      }</a>
<a name="ln8247">    } while ( !exc-&gt;instruction_trap );</a>
<a name="ln8248"> </a>
<a name="ln8249">  LNo_Error_:</a>
<a name="ln8250">    return FT_Err_Ok;</a>
<a name="ln8251"> </a>
<a name="ln8252">  LErrorCodeOverflow_:</a>
<a name="ln8253">    exc-&gt;error = FT_THROW( Code_Overflow );</a>
<a name="ln8254"> </a>
<a name="ln8255">  LErrorLabel_:</a>
<a name="ln8256">    /* If any errors have occurred, function tables may be broken. */</a>
<a name="ln8257">    /* Force a re-execution of `prep' and `fpgm' tables if no      */</a>
<a name="ln8258">    /* bytecode debugger is run.                                   */</a>
<a name="ln8259">    if ( exc-&gt;error                          &amp;&amp;</a>
<a name="ln8260">         !exc-&gt;instruction_trap              &amp;&amp;</a>
<a name="ln8261">         exc-&gt;curRange == tt_coderange_glyph )</a>
<a name="ln8262">    {</a>
<a name="ln8263">      FT_TRACE1(( &quot;  The interpreter returned error 0x%x\n&quot;, exc-&gt;error ));</a>
<a name="ln8264">      exc-&gt;size-&gt;bytecode_ready = -1;</a>
<a name="ln8265">      exc-&gt;size-&gt;cvt_ready      = -1;</a>
<a name="ln8266">    }</a>
<a name="ln8267"> </a>
<a name="ln8268">    return exc-&gt;error;</a>
<a name="ln8269">  }</a>
<a name="ln8270"> </a>
<a name="ln8271"> </a>
<a name="ln8272">#endif /* TT_USE_BYTECODE_INTERPRETER */</a>
<a name="ln8273"> </a>
<a name="ln8274"> </a>
<a name="ln8275">/* END */</a>

</code></pre>
<div class="balloon" rel="2283"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 2283, 2292</p></div>
<div class="balloon" rel="6621"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false.</p></div>
<div class="balloon" rel="6685"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1051/" target="_blank">V1051</a> Consider checking for misprints. It's possible that the 'cur_dist' should be checked here.</p></div>
<div class="balloon" rel="7983"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 7983, 8046</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
