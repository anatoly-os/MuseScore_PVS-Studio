
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>chordrest.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;chordrest.h&quot;</a>
<a name="ln14">#include &quot;chord.h&quot;</a>
<a name="ln15">#include &quot;xml.h&quot;</a>
<a name="ln16">#include &quot;style.h&quot;</a>
<a name="ln17">#include &quot;system.h&quot;</a>
<a name="ln18">#include &quot;measure.h&quot;</a>
<a name="ln19">#include &quot;staff.h&quot;</a>
<a name="ln20">#include &quot;tuplet.h&quot;</a>
<a name="ln21">#include &quot;score.h&quot;</a>
<a name="ln22">#include &quot;sym.h&quot;</a>
<a name="ln23">#include &quot;slur.h&quot;</a>
<a name="ln24">#include &quot;beam.h&quot;</a>
<a name="ln25">#include &quot;breath.h&quot;</a>
<a name="ln26">#include &quot;barline.h&quot;</a>
<a name="ln27">#include &quot;articulation.h&quot;</a>
<a name="ln28">#include &quot;tempo.h&quot;</a>
<a name="ln29">#include &quot;tempotext.h&quot;</a>
<a name="ln30">#include &quot;note.h&quot;</a>
<a name="ln31">#include &quot;arpeggio.h&quot;</a>
<a name="ln32">#include &quot;dynamic.h&quot;</a>
<a name="ln33">#include &quot;stafftext.h&quot;</a>
<a name="ln34">#include &quot;sig.h&quot;</a>
<a name="ln35">#include &quot;clef.h&quot;</a>
<a name="ln36">#include &quot;lyrics.h&quot;</a>
<a name="ln37">#include &quot;segment.h&quot;</a>
<a name="ln38">#include &quot;stafftype.h&quot;</a>
<a name="ln39">#include &quot;undo.h&quot;</a>
<a name="ln40">#include &quot;stem.h&quot;</a>
<a name="ln41">#include &quot;harmony.h&quot;</a>
<a name="ln42">#include &quot;hairpin.h&quot;</a>
<a name="ln43">#include &quot;figuredbass.h&quot;</a>
<a name="ln44">#include &quot;icon.h&quot;</a>
<a name="ln45">#include &quot;utils.h&quot;</a>
<a name="ln46">#include &quot;keysig.h&quot;</a>
<a name="ln47">#include &quot;page.h&quot;</a>
<a name="ln48">#include &quot;hook.h&quot;</a>
<a name="ln49">#include &quot;rehearsalmark.h&quot;</a>
<a name="ln50"> </a>
<a name="ln51">namespace Ms {</a>
<a name="ln52"> </a>
<a name="ln53">//---------------------------------------------------------</a>
<a name="ln54">//   ChordRest</a>
<a name="ln55">//---------------------------------------------------------</a>
<a name="ln56"> </a>
<a name="ln57">ChordRest::ChordRest(Score* s)</a>
<a name="ln58">   : DurationElement(s)</a>
<a name="ln59">      {</a>
<a name="ln60">      _staffMove   = 0;</a>
<a name="ln61">      _beam        = 0;</a>
<a name="ln62">      _tabDur      = 0;</a>
<a name="ln63">      _up          = true;</a>
<a name="ln64">      _beamMode    = Beam::Mode::AUTO;</a>
<a name="ln65">      _small       = false;</a>
<a name="ln66">      _crossMeasure = CrossMeasure::UNKNOWN;</a>
<a name="ln67">      }</a>
<a name="ln68"> </a>
<a name="ln69">ChordRest::ChordRest(const ChordRest&amp; cr, bool link)</a>
<a name="ln70">   : DurationElement(cr)</a>
<a name="ln71">      {</a>
<a name="ln72">      _durationType = cr._durationType;</a>
<a name="ln73">      _staffMove    = cr._staffMove;</a>
<a name="ln74">      _beam         = 0;</a>
<a name="ln75">      _tabDur       = 0;  // tab sur. symb. depends upon context: can't be</a>
<a name="ln76">                          // simply copied from another CR</a>
<a name="ln77"> </a>
<a name="ln78">      _beamMode     = cr._beamMode;</a>
<a name="ln79">      _up           = cr._up;</a>
<a name="ln80">      _small        = cr._small;</a>
<a name="ln81">      _crossMeasure = cr._crossMeasure;</a>
<a name="ln82"> </a>
<a name="ln83">      for (Lyrics* l : cr._lyrics) {        // make deep copy</a>
<a name="ln84">            Lyrics* nl = new Lyrics(*l);</a>
<a name="ln85">            if (link)</a>
<a name="ln86">                  nl-&gt;linkTo(l);</a>
<a name="ln87">            nl-&gt;setParent(this);</a>
<a name="ln88">            nl-&gt;setTrack(track());</a>
<a name="ln89">            _lyrics.push_back(nl);</a>
<a name="ln90">            }</a>
<a name="ln91">      }</a>
<a name="ln92"> </a>
<a name="ln93">//---------------------------------------------------------</a>
<a name="ln94">//   undoUnlink</a>
<a name="ln95">//---------------------------------------------------------</a>
<a name="ln96"> </a>
<a name="ln97">void ChordRest::undoUnlink()</a>
<a name="ln98">      {</a>
<a name="ln99">      DurationElement::undoUnlink();</a>
<a name="ln100">      for (Lyrics* l : _lyrics)</a>
<a name="ln101">            l-&gt;undoUnlink();</a>
<a name="ln102">      }</a>
<a name="ln103"> </a>
<a name="ln104">//---------------------------------------------------------</a>
<a name="ln105">//   ChordRest</a>
<a name="ln106">//---------------------------------------------------------</a>
<a name="ln107"> </a>
<a name="ln108">ChordRest::~ChordRest()</a>
<a name="ln109">      {</a>
<a name="ln110">      qDeleteAll(_lyrics);</a>
<a name="ln111">      qDeleteAll(_el);</a>
<a name="ln112">      delete _tabDur;</a>
<a name="ln113">      if (_beam &amp;&amp; _beam-&gt;contains(this))</a>
<a name="ln114">            delete _beam; // Beam destructor removes references to the deleted object</a>
<a name="ln115">      }</a>
<a name="ln116"> </a>
<a name="ln117">//---------------------------------------------------------</a>
<a name="ln118">//   scanElements</a>
<a name="ln119">//---------------------------------------------------------</a>
<a name="ln120"> </a>
<a name="ln121">void ChordRest::scanElements(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln122">      {</a>
<a name="ln123">      if (_beam &amp;&amp; (_beam-&gt;elements().front() == this)</a>
<a name="ln124">       &amp;&amp; !measure()-&gt;stemless(staffIdx()))</a>
<a name="ln125">            _beam-&gt;scanElements(data, func, all);</a>
<a name="ln126">      for (Lyrics* l : _lyrics)</a>
<a name="ln127">            l-&gt;scanElements(data, func, all);</a>
<a name="ln128">      DurationElement* de = this;</a>
<a name="ln129">      while (de-&gt;tuplet() &amp;&amp; de-&gt;tuplet()-&gt;elements().front() == de) {</a>
<a name="ln130">            de-&gt;tuplet()-&gt;scanElements(data, func, all);</a>
<a name="ln131">            de = de-&gt;tuplet();</a>
<a name="ln132">            }</a>
<a name="ln133">      if (_tabDur)</a>
<a name="ln134">            func(data, _tabDur);</a>
<a name="ln135">      }</a>
<a name="ln136"> </a>
<a name="ln137">//---------------------------------------------------------</a>
<a name="ln138">//   writeProperties</a>
<a name="ln139">//---------------------------------------------------------</a>
<a name="ln140"> </a>
<a name="ln141">void ChordRest::writeProperties(XmlWriter&amp; xml) const</a>
<a name="ln142">      {</a>
<a name="ln143">      DurationElement::writeProperties(xml);</a>
<a name="ln144"> </a>
<a name="ln145">      //</a>
<a name="ln146">      // Beam::Mode default:</a>
<a name="ln147">      //    REST  - Beam::Mode::NONE</a>
<a name="ln148">      //    CHORD - Beam::Mode::AUTO</a>
<a name="ln149">      //</a>
<a name="ln150">      if ((isRest() &amp;&amp; _beamMode != Beam::Mode::NONE) || (isChord() &amp;&amp; _beamMode != Beam::Mode::AUTO)) {</a>
<a name="ln151">            QString s;</a>
<a name="ln152">            switch(_beamMode) {</a>
<a name="ln153">                  case Beam::Mode::AUTO:    s = &quot;auto&quot;; break;</a>
<a name="ln154">                  case Beam::Mode::BEGIN:   s = &quot;begin&quot;; break;</a>
<a name="ln155">                  case Beam::Mode::MID:     s = &quot;mid&quot;; break;</a>
<a name="ln156">                  case Beam::Mode::END:     s = &quot;end&quot;; break;</a>
<a name="ln157">                  case Beam::Mode::NONE:    s = &quot;no&quot;; break;</a>
<a name="ln158">                  case Beam::Mode::BEGIN32: s = &quot;begin32&quot;; break;</a>
<a name="ln159">                  case Beam::Mode::BEGIN64: s = &quot;begin64&quot;; break;</a>
<a name="ln160">                  case Beam::Mode::INVALID: s = &quot;?&quot;; break;</a>
<a name="ln161">                  }</a>
<a name="ln162">            xml.tag(&quot;BeamMode&quot;, s);</a>
<a name="ln163">            }</a>
<a name="ln164">      writeProperty(xml, Pid::SMALL);</a>
<a name="ln165">      if (actualDurationType().dots())</a>
<a name="ln166">            xml.tag(&quot;dots&quot;, actualDurationType().dots());</a>
<a name="ln167">      writeProperty(xml, Pid::STAFF_MOVE);</a>
<a name="ln168"> </a>
<a name="ln169">      if (actualDurationType().isValid())</a>
<a name="ln170">            xml.tag(&quot;durationType&quot;, actualDurationType().name());</a>
<a name="ln171"> </a>
<a name="ln172">      if (!ticks().isZero() &amp;&amp; (!actualDurationType().fraction().isValid()</a>
<a name="ln173">         || (actualDurationType().fraction() != ticks()))) {</a>
<a name="ln174">            xml.tag(&quot;duration&quot;, ticks());</a>
<a name="ln175">            //xml.tagE(&quot;duration z=\&quot;%d\&quot; n=\&quot;%d\&quot;&quot;, ticks().numerator(), ticks().denominator());</a>
<a name="ln176">            }</a>
<a name="ln177"> </a>
<a name="ln178">      for (Lyrics* lyrics : _lyrics)</a>
<a name="ln179">            lyrics-&gt;write(xml);</a>
<a name="ln180"> </a>
<a name="ln181">      const int curTick = xml.curTick().ticks();</a>
<a name="ln182"> </a>
<a name="ln183">      if (!isGrace()) {</a>
<a name="ln184">            Fraction t(globalTicks());</a>
<a name="ln185">            if (staff())</a>
<a name="ln186">                  t /= staff()-&gt;timeStretch(xml.curTick());</a>
<a name="ln187">            xml.incCurTick(t);</a>
<a name="ln188">            }</a>
<a name="ln189"> </a>
<a name="ln190">      for (auto i : score()-&gt;spannerMap().findOverlapping(curTick - 1, curTick + 1)) {</a>
<a name="ln191">            Spanner* s = i.value;</a>
<a name="ln192">            if (s-&gt;generated() || !s-&gt;isSlur() || toSlur(s)-&gt;broken() || !xml.canWrite(s))</a>
<a name="ln193">                  continue;</a>
<a name="ln194"> </a>
<a name="ln195">            if (s-&gt;startElement() == this)</a>
<a name="ln196">                  s-&gt;writeSpannerStart(xml, this, track());</a>
<a name="ln197">            else if (s-&gt;endElement() == this)</a>
<a name="ln198">                  s-&gt;writeSpannerEnd(xml, this, track());</a>
<a name="ln199">            }</a>
<a name="ln200">      }</a>
<a name="ln201"> </a>
<a name="ln202">//---------------------------------------------------------</a>
<a name="ln203">//   readProperties</a>
<a name="ln204">//---------------------------------------------------------</a>
<a name="ln205"> </a>
<a name="ln206">bool ChordRest::readProperties(XmlReader&amp; e)</a>
<a name="ln207">      {</a>
<a name="ln208">      const QStringRef&amp; tag(e.name());</a>
<a name="ln209"> </a>
<a name="ln210">      if (tag == &quot;durationType&quot;) {</a>
<a name="ln211">            setDurationType(e.readElementText());</a>
<a name="ln212">            if (actualDurationType().type() != TDuration::DurationType::V_MEASURE) {</a>
<a name="ln213">                  if (score()-&gt;mscVersion() &lt; 112 &amp;&amp; (type() == ElementType::REST) &amp;&amp;</a>
<a name="ln214">                              // for backward compatibility, convert V_WHOLE rests to V_MEASURE</a>
<a name="ln215">                              // if long enough to fill a measure.</a>
<a name="ln216">                              // OTOH, freshly created (un-initialized) rests have numerator == 0 (&lt; 4/4)</a>
<a name="ln217">                              // (see Fraction() constructor in fraction.h; this happens for instance</a>
<a name="ln218">                              // when pasting selection from clipboard): they should not be converted</a>
<a name="ln219">                              ticks().numerator() != 0 &amp;&amp;</a>
<a name="ln220">                              // rest durations are initialized to full measure duration when</a>
<a name="ln221">                              // created upon reading the &lt;Rest&gt; tag (see Measure::read() )</a>
<a name="ln222">                              // so a V_WHOLE rest in a measure of 4/4 or less =&gt; V_MEASURE</a>
<a name="ln223">                              (actualDurationType()==TDuration::DurationType::V_WHOLE &amp;&amp; ticks() &lt;= Fraction(4, 4)) ) {</a>
<a name="ln224">                        // old pre 2.0 scores: convert</a>
<a name="ln225">                        setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln226">                        }</a>
<a name="ln227">                  else  // not from old score: set duration fraction from duration type</a>
<a name="ln228">                        setTicks(actualDurationType().fraction());</a>
<a name="ln229">                  }</a>
<a name="ln230">            else {</a>
<a name="ln231">                  if (score()-&gt;mscVersion() &lt;= 114) {</a>
<a name="ln232">                        SigEvent event = score()-&gt;sigmap()-&gt;timesig(e.tick());</a>
<a name="ln233">                        setTicks(event.timesig());</a>
<a name="ln234">                        }</a>
<a name="ln235">                  }</a>
<a name="ln236">            }</a>
<a name="ln237">      else if (tag == &quot;BeamMode&quot;) {</a>
<a name="ln238">            QString val(e.readElementText());</a>
<a name="ln239">            Beam::Mode bm = Beam::Mode::AUTO;</a>
<a name="ln240">            if (val == &quot;auto&quot;)</a>
<a name="ln241">                  bm = Beam::Mode::AUTO;</a>
<a name="ln242">            else if (val == &quot;begin&quot;)</a>
<a name="ln243">                  bm = Beam::Mode::BEGIN;</a>
<a name="ln244">            else if (val == &quot;mid&quot;)</a>
<a name="ln245">                  bm = Beam::Mode::MID;</a>
<a name="ln246">            else if (val == &quot;end&quot;)</a>
<a name="ln247">                  bm = Beam::Mode::END;</a>
<a name="ln248">            else if (val == &quot;no&quot;)</a>
<a name="ln249">                  bm = Beam::Mode::NONE;</a>
<a name="ln250">            else if (val == &quot;begin32&quot;)</a>
<a name="ln251">                  bm = Beam::Mode::BEGIN32;</a>
<a name="ln252">            else if (val == &quot;begin64&quot;)</a>
<a name="ln253">                  bm = Beam::Mode::BEGIN64;</a>
<a name="ln254">            else</a>
<a name="ln255">                  bm = Beam::Mode(val.toInt());</a>
<a name="ln256">            _beamMode = Beam::Mode(bm);</a>
<a name="ln257">            }</a>
<a name="ln258">      else if (tag == &quot;Articulation&quot;) {</a>
<a name="ln259">            Articulation* atr = new Articulation(score());</a>
<a name="ln260">            atr-&gt;setTrack(track());</a>
<a name="ln261">            atr-&gt;read(e);</a>
<a name="ln262">            add(atr);</a>
<a name="ln263">            }</a>
<a name="ln264">      else if (tag == &quot;leadingSpace&quot; || tag == &quot;trailingSpace&quot;) {</a>
<a name="ln265">            qDebug(&quot;ChordRest: %s obsolete&quot;, tag.toLocal8Bit().data());</a>
<a name="ln266">            e.skipCurrentElement();</a>
<a name="ln267">            }</a>
<a name="ln268">      else if (tag == &quot;small&quot;)</a>
<a name="ln269">            _small = e.readInt();</a>
<a name="ln270">      else if (tag == &quot;duration&quot;)</a>
<a name="ln271">            setTicks(e.readFraction());</a>
<a name="ln272">      else if (tag == &quot;ticklen&quot;) {      // obsolete (version &lt; 1.12)</a>
<a name="ln273">            int mticks = score()-&gt;sigmap()-&gt;timesig(e.tick()).timesig().ticks();</a>
<a name="ln274">            int i = e.readInt();</a>
<a name="ln275">            if (i == 0)</a>
<a name="ln276">                  i = mticks;</a>
<a name="ln277">            if ((type() == ElementType::REST) &amp;&amp; (mticks == i)) {</a>
<a name="ln278">                  setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln279">                  setTicks(Fraction::fromTicks(i));</a>
<a name="ln280">                  }</a>
<a name="ln281">            else {</a>
<a name="ln282">                  Fraction f = Fraction::fromTicks(i);</a>
<a name="ln283">                  setTicks(f);</a>
<a name="ln284">                  setDurationType(TDuration(f));</a>
<a name="ln285">                  }</a>
<a name="ln286">            }</a>
<a name="ln287">      else if (tag == &quot;dots&quot;)</a>
<a name="ln288">            setDots(e.readInt());</a>
<a name="ln289">      else if (tag == &quot;staffMove&quot;) {</a>
<a name="ln290">            _staffMove = e.readInt();</a>
<a name="ln291">            if (vStaffIdx() &lt; part()-&gt;staves()-&gt;first()-&gt;idx() || vStaffIdx() &gt; part()-&gt;staves()-&gt;last()-&gt;idx())</a>
<a name="ln292">                  _staffMove = 0;</a>
<a name="ln293">            }</a>
<a name="ln294">      else if (tag == &quot;Spanner&quot;)</a>
<a name="ln295">            Spanner::readSpanner(e, this, track());</a>
<a name="ln296">      else if (tag == &quot;Lyrics&quot;) {</a>
<a name="ln297">            Element* element = new Lyrics(score());</a>
<a name="ln298">            element-&gt;setTrack(e.track());</a>
<a name="ln299">            element-&gt;read(e);</a>
<a name="ln300">            add(element);</a>
<a name="ln301">            }</a>
<a name="ln302">      else if (tag == &quot;pos&quot;) {</a>
<a name="ln303">            QPointF pt = e.readPoint();</a>
<a name="ln304">            setOffset(pt * spatium());</a>
<a name="ln305">            }</a>
<a name="ln306">//      else if (tag == &quot;offset&quot;)</a>
<a name="ln307">//            DurationElement::readProperties(e);</a>
<a name="ln308">      else if (!DurationElement::readProperties(e))</a>
<a name="ln309">            return false;</a>
<a name="ln310">      return true;</a>
<a name="ln311">      }</a>
<a name="ln312"> </a>
<a name="ln313">//---------------------------------------------------------</a>
<a name="ln314">//   ChordRest::readAddConnector</a>
<a name="ln315">//---------------------------------------------------------</a>
<a name="ln316"> </a>
<a name="ln317">void ChordRest::readAddConnector(ConnectorInfoReader* info, bool pasteMode)</a>
<a name="ln318">      {</a>
<a name="ln319">      const ElementType type = info-&gt;type();</a>
<a name="ln320">      switch (type) {</a>
<a name="ln321">            case ElementType::SLUR:</a>
<a name="ln322">                  {</a>
<a name="ln323">                  Spanner* spanner = toSpanner(info-&gt;connector());</a>
<a name="ln324">                  const Location&amp; l = info-&gt;location();</a>
<a name="ln325"> </a>
<a name="ln326">                  if (info-&gt;isStart()) {</a>
<a name="ln327">                        spanner-&gt;setTrack(l.track());</a>
<a name="ln328">                        spanner-&gt;setTick(tick());</a>
<a name="ln329">                        spanner-&gt;setStartElement(this);</a>
<a name="ln330">                        if (pasteMode) {</a>
<a name="ln331">                              score()-&gt;undoAddElement(spanner);</a>
<a name="ln332">                              for (ScoreElement* ee : spanner-&gt;linkList()) {</a>
<a name="ln333">                                    if (ee == spanner)</a>
<a name="ln334">                                          continue;</a>
<a name="ln335">                                    Spanner* ls = toSpanner(ee);</a>
<a name="ln336">                                    ls-&gt;setTick(spanner-&gt;tick());</a>
<a name="ln337">                                    for (ScoreElement* eee : linkList()) {</a>
<a name="ln338">                                          ChordRest* cr = toChordRest(eee);</a>
<a name="ln339">                                          if (cr-&gt;score() == eee-&gt;score() &amp;&amp; cr-&gt;staffIdx() == ls-&gt;staffIdx()) {</a>
<a name="ln340">                                                ls-&gt;setTrack(cr-&gt;track());</a>
<a name="ln341">                                                if (ls-&gt;isSlur())</a>
<a name="ln342">                                                      ls-&gt;setStartElement(cr);</a>
<a name="ln343">                                                break;</a>
<a name="ln344">                                                }</a>
<a name="ln345">                                          }</a>
<a name="ln346">                                    }</a>
<a name="ln347">                              }</a>
<a name="ln348">                        else</a>
<a name="ln349">                              score()-&gt;addSpanner(spanner);</a>
<a name="ln350">                        }</a>
<a name="ln351">                  else if (info-&gt;isEnd()) {</a>
<a name="ln352">                        spanner-&gt;setTrack2(l.track());</a>
<a name="ln353">                        spanner-&gt;setTick2(tick());</a>
<a name="ln354">                        spanner-&gt;setEndElement(this);</a>
<a name="ln355">                        if (pasteMode) {</a>
<a name="ln356">                              for (ScoreElement* ee : spanner-&gt;linkList()) {</a>
<a name="ln357">                                    if (ee == spanner)</a>
<a name="ln358">                                          continue;</a>
<a name="ln359">                                    Spanner* ls = static_cast&lt;Spanner*&gt;(ee);</a>
<a name="ln360">                                    ls-&gt;setTick2(spanner-&gt;tick2());</a>
<a name="ln361">                                    for (ScoreElement* eee : linkList()) {</a>
<a name="ln362">                                          ChordRest* cr = toChordRest(eee);</a>
<a name="ln363">                                          if (cr-&gt;score() == eee-&gt;score() &amp;&amp; cr-&gt;staffIdx() == ls-&gt;staffIdx()) {</a>
<a name="ln364">                                                ls-&gt;setTrack2(cr-&gt;track());</a>
<a name="ln365">                                                if (ls-&gt;type() == ElementType::SLUR)</a>
<a name="ln366">                                                      ls-&gt;setEndElement(cr);</a>
<a name="ln367">                                                break;</a>
<a name="ln368">                                                }</a>
<a name="ln369">                                          }</a>
<a name="ln370">                                    }</a>
<a name="ln371">                              }</a>
<a name="ln372">                        }</a>
<a name="ln373">                  else</a>
<a name="ln374">                        qDebug(&quot;ChordRest::readAddConnector(): Slur end is neither start nor end&quot;);</a>
<a name="ln375">                  }</a>
<a name="ln376">                  break;</a>
<a name="ln377">            default:</a>
<a name="ln378">                  break;</a>
<a name="ln379">            }</a>
<a name="ln380">      }</a>
<a name="ln381"> </a>
<a name="ln382">//---------------------------------------------------------</a>
<a name="ln383">//   setSmall</a>
<a name="ln384">//---------------------------------------------------------</a>
<a name="ln385"> </a>
<a name="ln386">void ChordRest::setSmall(bool val)</a>
<a name="ln387">      {</a>
<a name="ln388">      _small = val;</a>
<a name="ln389">      }</a>
<a name="ln390"> </a>
<a name="ln391">//---------------------------------------------------------</a>
<a name="ln392">//   undoSetSmall</a>
<a name="ln393">//---------------------------------------------------------</a>
<a name="ln394"> </a>
<a name="ln395">void ChordRest::undoSetSmall(bool val)</a>
<a name="ln396">      {</a>
<a name="ln397">      undoChangeProperty(Pid::SMALL, val);</a>
<a name="ln398">      }</a>
<a name="ln399"> </a>
<a name="ln400">//---------------------------------------------------------</a>
<a name="ln401">//   drop</a>
<a name="ln402">//---------------------------------------------------------</a>
<a name="ln403"> </a>
<a name="ln404">Element* ChordRest::drop(EditData&amp; data)</a>
<a name="ln405">      {</a>
<a name="ln406">      Element* e       = data.dropElement;</a>
<a name="ln407">      Measure* m       = measure();</a>
<a name="ln408">      bool fromPalette = (e-&gt;track() == -1);</a>
<a name="ln409">      switch (e-&gt;type()) {</a>
<a name="ln410">            case ElementType::BREATH:</a>
<a name="ln411">                  {</a>
<a name="ln412">                  Breath* b = toBreath(e);</a>
<a name="ln413">                  b-&gt;setPos(QPointF());</a>
<a name="ln414">                  int track = staffIdx() * VOICES;</a>
<a name="ln415">                  b-&gt;setTrack(track);</a>
<a name="ln416"> </a>
<a name="ln417">                  // find start tick of next note in staff</a>
<a name="ln418">#if 0</a>
<a name="ln419">                  int bt = tick() + actualTicks();    // this could make sense if we allowed breath marks in voice &gt; 1</a>
<a name="ln420">#else</a>
<a name="ln421">                  Segment* next = segment()-&gt;nextCR(track);</a>
<a name="ln422">                  Fraction bt = next ? next-&gt;tick() : score()-&gt;lastSegment()-&gt;tick();</a>
<a name="ln423">#endif</a>
<a name="ln424"> </a>
<a name="ln425">                  // TODO: insert automatically in all staves?</a>
<a name="ln426"> </a>
<a name="ln427">                  Segment* seg = m-&gt;undoGetSegment(SegmentType::Breath, bt);</a>
<a name="ln428">                  b-&gt;setParent(seg);</a>
<a name="ln429">                  score()-&gt;undoAddElement(b);</a>
<a name="ln430">                  }</a>
<a name="ln431">                  return e;</a>
<a name="ln432"> </a>
<a name="ln433">            case ElementType::BAR_LINE:</a>
<a name="ln434">                  if (data.control())</a>
<a name="ln435">                        score()-&gt;splitMeasure(segment());</a>
<a name="ln436">                  else {</a>
<a name="ln437">                        BarLine* bl = toBarLine(e);</a>
<a name="ln438">                        bl-&gt;setPos(QPointF());</a>
<a name="ln439">                        bl-&gt;setTrack(staffIdx() * VOICES);</a>
<a name="ln440">                        bl-&gt;setGenerated(false);</a>
<a name="ln441"> </a>
<a name="ln442">                        if (tick() == m-&gt;tick())</a>
<a name="ln443">                              return m-&gt;drop(data);</a>
<a name="ln444"> </a>
<a name="ln445">                        BarLine* obl = 0;</a>
<a name="ln446">                        for (Staff* st  : staff()-&gt;staffList()) {</a>
<a name="ln447">                              Score* score = st-&gt;score();</a>
<a name="ln448">                              Measure* measure = score-&gt;tick2measure(m-&gt;tick());</a>
<a name="ln449">                              Segment* seg = measure-&gt;undoGetSegmentR(SegmentType::BarLine, rtick());</a>
<a name="ln450">                              BarLine* l;</a>
<a name="ln451">                              if (obl == 0)</a>
<a name="ln452">                                    obl = l = bl-&gt;clone();</a>
<a name="ln453">                              else</a>
<a name="ln454">                                    l = toBarLine(obl-&gt;linkedClone());</a>
<a name="ln455">                              l-&gt;setTrack(st-&gt;idx() * VOICES);</a>
<a name="ln456">                              l-&gt;setScore(score);</a>
<a name="ln457">                              l-&gt;setParent(seg);</a>
<a name="ln458">                              score-&gt;undoAddElement(l);</a>
<a name="ln459">                              l-&gt;layout();</a>
<a name="ln460">                              }</a>
<a name="ln461">                        }</a>
<a name="ln462">                  delete e;</a>
<a name="ln463">                  return 0;</a>
<a name="ln464"> </a>
<a name="ln465">            case ElementType::CLEF:</a>
<a name="ln466">                  score()-&gt;cmdInsertClef(toClef(e), this);</a>
<a name="ln467">                  break;</a>
<a name="ln468"> </a>
<a name="ln469">            case ElementType::TIMESIG:</a>
<a name="ln470">                  if (measure()-&gt;system()) {</a>
<a name="ln471">                        EditData ndd = data;</a>
<a name="ln472">                        // adding from palette sets pos, but normal paste does not</a>
<a name="ln473">                        if (!fromPalette)</a>
<a name="ln474">                              ndd.pos = pagePos();</a>
<a name="ln475">                        // convert page-relative pos to score-relative</a>
<a name="ln476">                        ndd.pos += measure()-&gt;system()-&gt;page()-&gt;pos();</a>
<a name="ln477">                        return measure()-&gt;drop(ndd);</a>
<a name="ln478">                        }</a>
<a name="ln479">                  else {</a>
<a name="ln480">                        delete e;</a>
<a name="ln481">                        return 0;</a>
<a name="ln482">                        }</a>
<a name="ln483"> </a>
<a name="ln484">            case ElementType::FERMATA:</a>
<a name="ln485">                  e-&gt;setPlacement(track() &amp; 1 ? Placement::BELOW : Placement::ABOVE);</a>
<a name="ln486">                  for (Element* el: segment()-&gt;annotations())</a>
<a name="ln487">                        if (el-&gt;isFermata() &amp;&amp; (el-&gt;track() == track())) {</a>
<a name="ln488">                              if (el-&gt;subtype() == e-&gt;subtype()) {</a>
<a name="ln489">                                    delete e;</a>
<a name="ln490">                                    return el;</a>
<a name="ln491">                                    }</a>
<a name="ln492">                              else {</a>
<a name="ln493">                                    e-&gt;setPlacement(el-&gt;placement());</a>
<a name="ln494">                                    e-&gt;setTrack(track());</a>
<a name="ln495">                                    e-&gt;setParent(segment());</a>
<a name="ln496">                                    score()-&gt;undoChangeElement(el, e);</a>
<a name="ln497">                                    return e;</a>
<a name="ln498">                                    }</a>
<a name="ln499">                              }</a>
<a name="ln500">                  // fall through</a>
<a name="ln501">            case ElementType::TEMPO_TEXT:</a>
<a name="ln502">            case ElementType::DYNAMIC:</a>
<a name="ln503">            case ElementType::FRET_DIAGRAM:</a>
<a name="ln504">            case ElementType::TREMOLOBAR:</a>
<a name="ln505">            case ElementType::SYMBOL:</a>
<a name="ln506">                  e-&gt;setTrack(track());</a>
<a name="ln507">                  e-&gt;setParent(segment());</a>
<a name="ln508">                  score()-&gt;undoAddElement(e);</a>
<a name="ln509">                  return e;</a>
<a name="ln510"> </a>
<a name="ln511">            case ElementType::NOTE: {</a>
<a name="ln512">                  Note* note = toNote(e);</a>
<a name="ln513">                  NoteVal nval;</a>
<a name="ln514">                  nval.pitch = note-&gt;pitch();</a>
<a name="ln515">                  nval.tpc1 = note-&gt;tpc1();</a>
<a name="ln516">                  nval.headGroup = note-&gt;headGroup();</a>
<a name="ln517">                  nval.fret = note-&gt;fret();</a>
<a name="ln518">                  nval.string = note-&gt;string();</a>
<a name="ln519">                  score()-&gt;setNoteRest(segment(), track(), nval, ticks(), Direction::AUTO);</a>
<a name="ln520">                  delete e;</a>
<a name="ln521">                  }</a>
<a name="ln522">                  break;</a>
<a name="ln523"> </a>
<a name="ln524">            case ElementType::HARMONY:</a>
<a name="ln525">                  {</a>
<a name="ln526">                  // transpose</a>
<a name="ln527">                  Harmony* harmony = toHarmony(e);</a>
<a name="ln528">                  Interval interval = staff()-&gt;part()-&gt;instrument(tick())-&gt;transpose();</a>
<a name="ln529">                  if (!score()-&gt;styleB(Sid::concertPitch) &amp;&amp; !interval.isZero()) {</a>
<a name="ln530">                        interval.flip();</a>
<a name="ln531">                        int rootTpc = transposeTpc(harmony-&gt;rootTpc(), interval, true);</a>
<a name="ln532">                        int baseTpc = transposeTpc(harmony-&gt;baseTpc(), interval, true);</a>
<a name="ln533">                        score()-&gt;undoTransposeHarmony(harmony, rootTpc, baseTpc);</a>
<a name="ln534">                        }</a>
<a name="ln535">                  // render</a>
<a name="ln536">                  harmony-&gt;render();</a>
<a name="ln537">                  }</a>
<a name="ln538">                  // fall through</a>
<a name="ln539">            case ElementType::TEXT:</a>
<a name="ln540">            case ElementType::STAFF_TEXT:</a>
<a name="ln541">            case ElementType::SYSTEM_TEXT:</a>
<a name="ln542">            case ElementType::STICKING:</a>
<a name="ln543">            case ElementType::STAFF_STATE:</a>
<a name="ln544">            case ElementType::INSTRUMENT_CHANGE:</a>
<a name="ln545">                  if (e-&gt;isInstrumentChange() &amp;&amp; part()-&gt;instruments()-&gt;find(tick().ticks()) != part()-&gt;instruments()-&gt;end()) {</a>
<a name="ln546">                        qDebug()&lt;&lt;&quot;InstrumentChange already exists at tick = &quot;&lt;&lt;tick().ticks();</a>
<a name="ln547">                        delete e;</a>
<a name="ln548">                        return 0;</a>
<a name="ln549">                        }</a>
<a name="ln550">                  // fall through</a>
<a name="ln551"> </a>
<a name="ln552">            case ElementType::REHEARSAL_MARK:</a>
<a name="ln553">                  {</a>
<a name="ln554">                  e-&gt;setParent(segment());</a>
<a name="ln555">                  e-&gt;setTrack((track() / VOICES) * VOICES);</a>
<a name="ln556">                  if (e-&gt;isRehearsalMark()) {</a>
<a name="ln557">                        RehearsalMark* r = toRehearsalMark(e);</a>
<a name="ln558">                        if (fromPalette)</a>
<a name="ln559">                              r-&gt;setXmlText(score()-&gt;createRehearsalMarkText(r));</a>
<a name="ln560">                        }</a>
<a name="ln561">                  score()-&gt;undoAddElement(e);</a>
<a name="ln562">                  return e;</a>
<a name="ln563">                  }</a>
<a name="ln564">            case ElementType::FIGURED_BASS:</a>
<a name="ln565">                  {</a>
<a name="ln566">                  bool bNew;</a>
<a name="ln567">                  FiguredBass * fb = toFiguredBass(e);</a>
<a name="ln568">                  fb-&gt;setParent( segment() );</a>
<a name="ln569">                  fb-&gt;setTrack( (track() / VOICES) * VOICES );</a>
<a name="ln570">                  fb-&gt;setTicks(ticks() );</a>
<a name="ln571">                  fb-&gt;setOnNote(true);</a>
<a name="ln572">                  FiguredBass::addFiguredBassToSegment(segment(), fb-&gt;track(), fb-&gt;ticks(), &amp;bNew);</a>
<a name="ln573">                  if (bNew)</a>
<a name="ln574">                        score()-&gt;undoAddElement(e);</a>
<a name="ln575">                  return e;</a>
<a name="ln576">                  }</a>
<a name="ln577"> </a>
<a name="ln578">            case ElementType::IMAGE:</a>
<a name="ln579">                  e-&gt;setParent(segment());</a>
<a name="ln580">                  score()-&gt;undoAddElement(e);</a>
<a name="ln581">                  return e;</a>
<a name="ln582"> </a>
<a name="ln583">            case ElementType::ICON:</a>
<a name="ln584">                  {</a>
<a name="ln585">                  switch (toIcon(e)-&gt;iconType()) {</a>
<a name="ln586">                        case IconType::SBEAM:</a>
<a name="ln587">                              undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::BEGIN));</a>
<a name="ln588">                              break;</a>
<a name="ln589">                        case IconType::MBEAM:</a>
<a name="ln590">                              undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::MID));</a>
<a name="ln591">                              break;</a>
<a name="ln592">                        case IconType::NBEAM:</a>
<a name="ln593">                              undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::NONE));</a>
<a name="ln594">                              break;</a>
<a name="ln595">                        case IconType::BEAM32:</a>
<a name="ln596">                              undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::BEGIN32));</a>
<a name="ln597">                              break;</a>
<a name="ln598">                        case IconType::BEAM64:</a>
<a name="ln599">                              undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::BEGIN64));</a>
<a name="ln600">                              break;</a>
<a name="ln601">                        case IconType::AUTOBEAM:</a>
<a name="ln602">                              undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::AUTO));</a>
<a name="ln603">                              break;</a>
<a name="ln604">                        default:</a>
<a name="ln605">                              break;</a>
<a name="ln606">                        }</a>
<a name="ln607">                  }</a>
<a name="ln608">                  delete e;</a>
<a name="ln609">                  break;</a>
<a name="ln610"> </a>
<a name="ln611">            case ElementType::KEYSIG:</a>
<a name="ln612">                  {</a>
<a name="ln613">                  KeySig* ks    = toKeySig(e);</a>
<a name="ln614">                  KeySigEvent k = ks-&gt;keySigEvent();</a>
<a name="ln615">                  delete ks;</a>
<a name="ln616"> </a>
<a name="ln617">                  // apply only to this stave</a>
<a name="ln618">                  score()-&gt;undoChangeKeySig(staff(), tick(), k);</a>
<a name="ln619">                  }</a>
<a name="ln620">                  break;</a>
<a name="ln621"> </a>
<a name="ln622">            case ElementType::HAIRPIN:</a>
<a name="ln623">                  {</a>
<a name="ln624">                  Hairpin* hairpin = toHairpin(e);</a>
<a name="ln625">                  hairpin-&gt;setTick(tick());</a>
<a name="ln626">                  hairpin-&gt;setTrack(track());</a>
<a name="ln627">                  hairpin-&gt;setTrack2(track());</a>
<a name="ln628">                  score()-&gt;undoAddElement(hairpin);</a>
<a name="ln629">                  }</a>
<a name="ln630">                  return e;</a>
<a name="ln631"> </a>
<a name="ln632">            default:</a>
<a name="ln633">                  qDebug(&quot;cannot drop %s&quot;, e-&gt;name());</a>
<a name="ln634">                  delete e;</a>
<a name="ln635">                  return 0;</a>
<a name="ln636">            }</a>
<a name="ln637">      return 0;</a>
<a name="ln638">      }</a>
<a name="ln639"> </a>
<a name="ln640">//---------------------------------------------------------</a>
<a name="ln641">//   setBeam</a>
<a name="ln642">//---------------------------------------------------------</a>
<a name="ln643"> </a>
<a name="ln644">void ChordRest::setBeam(Beam* b)</a>
<a name="ln645">      {</a>
<a name="ln646">      _beam = b;</a>
<a name="ln647">      }</a>
<a name="ln648"> </a>
<a name="ln649">//---------------------------------------------------------</a>
<a name="ln650">//   setDurationType</a>
<a name="ln651">//---------------------------------------------------------</a>
<a name="ln652"> </a>
<a name="ln653">void ChordRest::setDurationType(TDuration::DurationType t)</a>
<a name="ln654">      {</a>
<a name="ln655">      _durationType.setType(t);</a>
<a name="ln656">      _crossMeasure = CrossMeasure::UNKNOWN;</a>
<a name="ln657">      }</a>
<a name="ln658"> </a>
<a name="ln659">void ChordRest::setDurationType(const QString&amp; s)</a>
<a name="ln660">      {</a>
<a name="ln661">      _durationType.setType(s);</a>
<a name="ln662">      _crossMeasure = CrossMeasure::UNKNOWN;</a>
<a name="ln663">      }</a>
<a name="ln664"> </a>
<a name="ln665">void ChordRest::setDurationType(const Fraction&amp; ticks)</a>
<a name="ln666">      {</a>
<a name="ln667">      _durationType.setVal(ticks.ticks());</a>
<a name="ln668">      _crossMeasure = CrossMeasure::UNKNOWN;</a>
<a name="ln669">      }</a>
<a name="ln670"> </a>
<a name="ln671">void ChordRest::setDurationType(TDuration v)</a>
<a name="ln672">      {</a>
<a name="ln673">      _durationType = v;</a>
<a name="ln674">      _crossMeasure = CrossMeasure::UNKNOWN;</a>
<a name="ln675">      }</a>
<a name="ln676"> </a>
<a name="ln677">//---------------------------------------------------------</a>
<a name="ln678">//   durationUserName</a>
<a name="ln679">//---------------------------------------------------------</a>
<a name="ln680"> </a>
<a name="ln681">QString ChordRest::durationUserName() const</a>
<a name="ln682">      {</a>
<a name="ln683">      QString tupletType = &quot;&quot;;</a>
<a name="ln684">      if (tuplet()) {</a>
<a name="ln685">              switch (tuplet()-&gt;ratio().numerator()) {</a>
<a name="ln686">                  case 2:</a>
<a name="ln687">                        tupletType = QObject::tr(&quot;Duplet&quot;);</a>
<a name="ln688">                        break;</a>
<a name="ln689">                  case 3:</a>
<a name="ln690">                        tupletType = QObject::tr(&quot;Triplet&quot;);</a>
<a name="ln691">                        break;</a>
<a name="ln692">                  case 4:</a>
<a name="ln693">                        tupletType = QObject::tr(&quot;Quadruplet&quot;);</a>
<a name="ln694">                        break;</a>
<a name="ln695">                  case 5:</a>
<a name="ln696">                        tupletType = QObject::tr(&quot;Quintuplet&quot;);</a>
<a name="ln697">                        break;</a>
<a name="ln698">                  case 6:</a>
<a name="ln699">                        tupletType = QObject::tr(&quot;Sextuplet&quot;);</a>
<a name="ln700">                        break;</a>
<a name="ln701">                  case 7:</a>
<a name="ln702">                        tupletType = QObject::tr(&quot;Septuplet&quot;);</a>
<a name="ln703">                        break;</a>
<a name="ln704">                  case 8:</a>
<a name="ln705">                        tupletType = QObject::tr(&quot;Octuplet&quot;);</a>
<a name="ln706">                        break;</a>
<a name="ln707">                  case 9:</a>
<a name="ln708">                        tupletType = QObject::tr(&quot;Nonuplet&quot;);</a>
<a name="ln709">                        break;</a>
<a name="ln710">                  default:</a>
<a name="ln711">                        tupletType = QObject::tr(&quot;Custom tuplet&quot;);</a>
<a name="ln712">                  }</a>
<a name="ln713">            }</a>
<a name="ln714">      QString dotString = &quot;&quot;;</a>
<a name="ln715">      if(!tupletType.isEmpty())</a>
<a name="ln716">          dotString += &quot; &quot;;</a>
<a name="ln717"> </a>
<a name="ln718">      switch (dots()) {</a>
<a name="ln719">            case 1:</a>
<a name="ln720">                  dotString += QObject::tr(&quot;Dotted %1&quot;).arg(durationType().durationTypeUserName()).trimmed();</a>
<a name="ln721">                  break;</a>
<a name="ln722">            case 2:</a>
<a name="ln723">                  dotString += QObject::tr(&quot;Double dotted %1&quot;).arg(durationType().durationTypeUserName()).trimmed();</a>
<a name="ln724">                  break;</a>
<a name="ln725">            case 3:</a>
<a name="ln726">                  dotString += QObject::tr(&quot;Triple dotted %1&quot;).arg(durationType().durationTypeUserName()).trimmed();</a>
<a name="ln727">                  break;</a>
<a name="ln728">            case 4:</a>
<a name="ln729">                  dotString += QObject::tr(&quot;Quadruple dotted %1&quot;).arg(durationType().durationTypeUserName()).trimmed();</a>
<a name="ln730">                  break;</a>
<a name="ln731">            default:</a>
<a name="ln732">                  dotString += durationType().durationTypeUserName();</a>
<a name="ln733">            }</a>
<a name="ln734">      return QString(&quot;%1%2&quot;).arg(tupletType).arg(dotString);</a>
<a name="ln735">      }</a>
<a name="ln736"> </a>
<a name="ln737">//---------------------------------------------------------</a>
<a name="ln738">//   add</a>
<a name="ln739">//---------------------------------------------------------</a>
<a name="ln740"> </a>
<a name="ln741">void ChordRest::add(Element* e)</a>
<a name="ln742">      {</a>
<a name="ln743">      e-&gt;setParent(this);</a>
<a name="ln744">      e-&gt;setTrack(track());</a>
<a name="ln745">      switch (e-&gt;type()) {</a>
<a name="ln746">            case ElementType::ARTICULATION:     // for backward compatibility</a>
<a name="ln747">                  qDebug(&quot;ChordRest::add: unknown element %s&quot;, e-&gt;name());</a>
<a name="ln748">                  break;</a>
<a name="ln749">            case ElementType::LYRICS:</a>
<a name="ln750">                  if (e-&gt;isStyled(Pid::OFFSET))</a>
<a name="ln751">                        e-&gt;setOffset(e-&gt;propertyDefault(Pid::OFFSET).toPointF());</a>
<a name="ln752">                  _lyrics.push_back(toLyrics(e));</a>
<a name="ln753">                  break;</a>
<a name="ln754">            default:</a>
<a name="ln755">                  qFatal(&quot;ChordRest::add: unknown element %s&quot;, e-&gt;name());</a>
<a name="ln756">                  break;</a>
<a name="ln757">            }</a>
<a name="ln758">      }</a>
<a name="ln759"> </a>
<a name="ln760">//---------------------------------------------------------</a>
<a name="ln761">//   remove</a>
<a name="ln762">//---------------------------------------------------------</a>
<a name="ln763"> </a>
<a name="ln764">void ChordRest::remove(Element* e)</a>
<a name="ln765">      {</a>
<a name="ln766">      switch (e-&gt;type()) {</a>
<a name="ln767">            case ElementType::LYRICS: {</a>
<a name="ln768">                  toLyrics(e)-&gt;removeFromScore();</a>
<a name="ln769">                  auto i = std::find(_lyrics.begin(), _lyrics.end(), toLyrics(e));</a>
<a name="ln770">                  if (i != _lyrics.end())</a>
<a name="ln771">                        _lyrics.erase(i);</a>
<a name="ln772">                  else</a>
<a name="ln773">                        qDebug(&quot;ChordRest::remove: %s %p not found&quot;, e-&gt;name(), e);</a>
<a name="ln774">                  }</a>
<a name="ln775">                  break;</a>
<a name="ln776">            default:</a>
<a name="ln777">                  qFatal(&quot;ChordRest::remove: unknown element &lt;%s&gt;&quot;, e-&gt;name());</a>
<a name="ln778">            }</a>
<a name="ln779">      }</a>
<a name="ln780"> </a>
<a name="ln781">//---------------------------------------------------------</a>
<a name="ln782">//   removeDeleteBeam</a>
<a name="ln783">///   Remove ChordRest from beam, delete beam if empty.</a>
<a name="ln784">///   \param beamed - if the chordrest is beamed (will get</a>
<a name="ln785">///                   a (new) beam)</a>
<a name="ln786">//---------------------------------------------------------</a>
<a name="ln787"> </a>
<a name="ln788">void ChordRest::removeDeleteBeam(bool beamed)</a>
<a name="ln789">      {</a>
<a name="ln790">      if (_beam) {</a>
<a name="ln791">            Beam* b = _beam;</a>
<a name="ln792">            _beam-&gt;remove(this);</a>
<a name="ln793">            if (b-&gt;empty())</a>
<a name="ln794">                  score()-&gt;undoRemoveElement(b);</a>
<a name="ln795">            else</a>
<a name="ln796">                  b-&gt;layout1();</a>
<a name="ln797">            }</a>
<a name="ln798">      if (!beamed &amp;&amp; isChord())</a>
<a name="ln799">            toChord(this)-&gt;layoutStem();</a>
<a name="ln800">      }</a>
<a name="ln801"> </a>
<a name="ln802">//---------------------------------------------------------</a>
<a name="ln803">//   replaceBeam</a>
<a name="ln804">//---------------------------------------------------------</a>
<a name="ln805"> </a>
<a name="ln806">void ChordRest::replaceBeam(Beam* newBeam)</a>
<a name="ln807">      {</a>
<a name="ln808">      if (_beam == newBeam)</a>
<a name="ln809">            return;</a>
<a name="ln810">      removeDeleteBeam(true);</a>
<a name="ln811">      newBeam-&gt;add(this);</a>
<a name="ln812">      }</a>
<a name="ln813"> </a>
<a name="ln814">//---------------------------------------------------------</a>
<a name="ln815">//   undoSetBeamMode</a>
<a name="ln816">//---------------------------------------------------------</a>
<a name="ln817"> </a>
<a name="ln818">void ChordRest::undoSetBeamMode(Beam::Mode mode)</a>
<a name="ln819">      {</a>
<a name="ln820">      undoChangeProperty(Pid::BEAM_MODE, int(mode));</a>
<a name="ln821">      }</a>
<a name="ln822"> </a>
<a name="ln823">//---------------------------------------------------------</a>
<a name="ln824">//   localSpatiumChanged</a>
<a name="ln825">//---------------------------------------------------------</a>
<a name="ln826"> </a>
<a name="ln827">void ChordRest::localSpatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln828">      {</a>
<a name="ln829">      DurationElement::localSpatiumChanged(oldValue, newValue);</a>
<a name="ln830">      for (Element* e : lyrics())</a>
<a name="ln831">            e-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln832">      for (Element* e : el())</a>
<a name="ln833">            e-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln834">      }</a>
<a name="ln835"> </a>
<a name="ln836">//---------------------------------------------------------</a>
<a name="ln837">//   getProperty</a>
<a name="ln838">//---------------------------------------------------------</a>
<a name="ln839"> </a>
<a name="ln840">QVariant ChordRest::getProperty(Pid propertyId) const</a>
<a name="ln841">      {</a>
<a name="ln842">      switch (propertyId) {</a>
<a name="ln843">            case Pid::SMALL:      return QVariant(small());</a>
<a name="ln844">            case Pid::BEAM_MODE:  return int(beamMode());</a>
<a name="ln845">            case Pid::STAFF_MOVE: return staffMove();</a>
<a name="ln846">            case Pid::DURATION_TYPE: return QVariant::fromValue(actualDurationType());</a>
<a name="ln847">            default:               return DurationElement::getProperty(propertyId);</a>
<a name="ln848">            }</a>
<a name="ln849">      }</a>
<a name="ln850"> </a>
<a name="ln851">//---------------------------------------------------------</a>
<a name="ln852">//   setProperty</a>
<a name="ln853">//---------------------------------------------------------</a>
<a name="ln854"> </a>
<a name="ln855">bool ChordRest::setProperty(Pid propertyId, const QVariant&amp; v)</a>
<a name="ln856">      {</a>
<a name="ln857">      switch (propertyId) {</a>
<a name="ln858">            case Pid::SMALL:</a>
<a name="ln859">                  setSmall(v.toBool());</a>
<a name="ln860">                  break;</a>
<a name="ln861">            case Pid::BEAM_MODE:</a>
<a name="ln862">                  setBeamMode(Beam::Mode(v.toInt()));</a>
<a name="ln863">                  break;</a>
<a name="ln864">            case Pid::STAFF_MOVE:</a>
<a name="ln865">                  setStaffMove(v.toInt());</a>
<a name="ln866">                  break;</a>
<a name="ln867">            case Pid::VISIBLE:</a>
<a name="ln868">                  setVisible(v.toBool());</a>
<a name="ln869">                  measure()-&gt;checkMultiVoices(staffIdx());</a>
<a name="ln870">                  break;</a>
<a name="ln871">            case Pid::DURATION_TYPE:</a>
<a name="ln872">                  setDurationType(v.value&lt;TDuration&gt;());</a>
<a name="ln873">                  break;</a>
<a name="ln874">            default:</a>
<a name="ln875">                  return DurationElement::setProperty(propertyId, v);</a>
<a name="ln876">            }</a>
<a name="ln877">      triggerLayout();</a>
<a name="ln878">      return true;</a>
<a name="ln879">      }</a>
<a name="ln880"> </a>
<a name="ln881">//---------------------------------------------------------</a>
<a name="ln882">//   propertyDefault</a>
<a name="ln883">//---------------------------------------------------------</a>
<a name="ln884"> </a>
<a name="ln885">QVariant ChordRest::propertyDefault(Pid propertyId) const</a>
<a name="ln886">      {</a>
<a name="ln887">      switch (propertyId) {</a>
<a name="ln888">            case Pid::SMALL:</a>
<a name="ln889">                  return false;</a>
<a name="ln890">            case Pid::BEAM_MODE:</a>
<a name="ln891">                  return int(Beam::Mode::AUTO);</a>
<a name="ln892">            case Pid::STAFF_MOVE:</a>
<a name="ln893">                  return 0;</a>
<a name="ln894">            default:</a>
<a name="ln895">                  return DurationElement::propertyDefault(propertyId);</a>
<a name="ln896">            }</a>
<a name="ln897">      // Prevent unreachable code warning</a>
<a name="ln898">      // triggerLayout();</a>
<a name="ln899">      }</a>
<a name="ln900"> </a>
<a name="ln901">//---------------------------------------------------------</a>
<a name="ln902">//   isGrace</a>
<a name="ln903">//---------------------------------------------------------</a>
<a name="ln904"> </a>
<a name="ln905">bool ChordRest::isGrace() const</a>
<a name="ln906">      {</a>
<a name="ln907">      return isChord() &amp;&amp; toChord(this)-&gt;isGrace();</a>
<a name="ln908">      }</a>
<a name="ln909"> </a>
<a name="ln910">//---------------------------------------------------------</a>
<a name="ln911">//   isGraceBefore</a>
<a name="ln912">//---------------------------------------------------------</a>
<a name="ln913"> </a>
<a name="ln914">bool ChordRest::isGraceBefore() const</a>
<a name="ln915">      {</a>
<a name="ln916">      return isChord()</a>
<a name="ln917">         &amp;&amp; (toChord(this)-&gt;noteType() &amp; (</a>
<a name="ln918">           NoteType::ACCIACCATURA | NoteType::APPOGGIATURA | NoteType::GRACE4 | NoteType::GRACE16 | NoteType::GRACE32</a>
<a name="ln919">           ));</a>
<a name="ln920">      }</a>
<a name="ln921"> </a>
<a name="ln922">//---------------------------------------------------------</a>
<a name="ln923">//   isGraceAfter</a>
<a name="ln924">//---------------------------------------------------------</a>
<a name="ln925"> </a>
<a name="ln926">bool ChordRest::isGraceAfter() const</a>
<a name="ln927">      {</a>
<a name="ln928">      return isChord()</a>
<a name="ln929">         &amp;&amp; (toChord(this)-&gt;noteType() &amp; (NoteType::GRACE8_AFTER | NoteType::GRACE16_AFTER | NoteType::GRACE32_AFTER));</a>
<a name="ln930">      }</a>
<a name="ln931"> </a>
<a name="ln932">//---------------------------------------------------------</a>
<a name="ln933">//   writeBeam</a>
<a name="ln934">//---------------------------------------------------------</a>
<a name="ln935"> </a>
<a name="ln936">void ChordRest::writeBeam(XmlWriter&amp; xml) const</a>
<a name="ln937">      {</a>
<a name="ln938">      Beam* b = beam();</a>
<a name="ln939">      if (b &amp;&amp; b-&gt;elements().front() == this &amp;&amp; (MScore::testMode || !b-&gt;generated())) {</a>
<a name="ln940">            b-&gt;write(xml);</a>
<a name="ln941">            }</a>
<a name="ln942">      }</a>
<a name="ln943"> </a>
<a name="ln944">//---------------------------------------------------------</a>
<a name="ln945">//   nextSegmentAfterCR</a>
<a name="ln946">//    returns first segment at tick CR-&gt;tick + CR-&gt;actualTicks</a>
<a name="ln947">//    of given types</a>
<a name="ln948">//---------------------------------------------------------</a>
<a name="ln949"> </a>
<a name="ln950">Segment* ChordRest::nextSegmentAfterCR(SegmentType types) const</a>
<a name="ln951">      {</a>
<a name="ln952">      Fraction end = tick() + actualTicks();</a>
<a name="ln953">      for (Segment* s = segment()-&gt;next1MM(types); s; s = s-&gt;next1MM(types)) {</a>
<a name="ln954">            // chordrest ends at afrac+actualFraction</a>
<a name="ln955">            // we return the segment at or after the end of the chordrest</a>
<a name="ln956">            // Segment::afrac() is based on ticks; use DurationElement::afrac() if possible</a>
<a name="ln957">            Element* e = s;</a>
<a name="ln958">            if (s-&gt;isChordRestType()) {</a>
<a name="ln959">                  // Find the first non-NULL element in the segment</a>
<a name="ln960">                  for (Element* ee : s-&gt;elist()) {</a>
<a name="ln961">                        if (ee) {</a>
<a name="ln962">                              e = ee;</a>
<a name="ln963">                              break;</a>
<a name="ln964">                              }</a>
<a name="ln965">                        }</a>
<a name="ln966">                  }</a>
<a name="ln967">            if (e-&gt;tick() &gt;= end)</a>
<a name="ln968">                  return s;</a>
<a name="ln969">            }</a>
<a name="ln970">      return 0;</a>
<a name="ln971">      }</a>
<a name="ln972"> </a>
<a name="ln973">//---------------------------------------------------------</a>
<a name="ln974">//   setTrack</a>
<a name="ln975">//---------------------------------------------------------</a>
<a name="ln976"> </a>
<a name="ln977">void ChordRest::setTrack(int val)</a>
<a name="ln978">      {</a>
<a name="ln979">      Element::setTrack(val);</a>
<a name="ln980">      processSiblings([val] (Element* e) { e-&gt;setTrack(val); } );</a>
<a name="ln981">      }</a>
<a name="ln982"> </a>
<a name="ln983">//---------------------------------------------------------</a>
<a name="ln984">//   setScore</a>
<a name="ln985">//---------------------------------------------------------</a>
<a name="ln986"> </a>
<a name="ln987">void ChordRest::setScore(Score* s)</a>
<a name="ln988">      {</a>
<a name="ln989">      Element::setScore(s);</a>
<a name="ln990">      processSiblings([s] (Element* e) { e-&gt;setScore(s); } );</a>
<a name="ln991">      }</a>
<a name="ln992"> </a>
<a name="ln993">//---------------------------------------------------------</a>
<a name="ln994">//   processSiblings</a>
<a name="ln995">//---------------------------------------------------------</a>
<a name="ln996"> </a>
<a name="ln997">void ChordRest::processSiblings(std::function&lt;void(Element*)&gt; func)</a>
<a name="ln998">      {</a>
<a name="ln999">      if (_beam)</a>
<a name="ln1000">            func(_beam);</a>
<a name="ln1001">      if (_tabDur)</a>
<a name="ln1002">            func(_tabDur);</a>
<a name="ln1003">      for (Lyrics* l : _lyrics)</a>
<a name="ln1004">            func(l);</a>
<a name="ln1005">      if (tuplet())</a>
<a name="ln1006">            func(tuplet());</a>
<a name="ln1007">      }</a>
<a name="ln1008"> </a>
<a name="ln1009">//---------------------------------------------------------</a>
<a name="ln1010">//   nextArticulationOrLyric</a>
<a name="ln1011">//---------------------------------------------------------</a>
<a name="ln1012"> </a>
<a name="ln1013">Element* ChordRest::nextArticulationOrLyric(Element* e)</a>
<a name="ln1014">      {</a>
<a name="ln1015">      if (isChord() &amp;&amp; e-&gt;isArticulation()) {</a>
<a name="ln1016">            Chord* c = toChord(this);</a>
<a name="ln1017">            auto i = std::find(c-&gt;articulations().begin(), c-&gt;articulations().end(), e);</a>
<a name="ln1018">            if (i != c-&gt;articulations().end()) {</a>
<a name="ln1019">                  if (i != c-&gt;articulations().end() - 1) {</a>
<a name="ln1020">                        return *(i+1);</a>
<a name="ln1021">                        }</a>
<a name="ln1022">                  else {</a>
<a name="ln1023">                        if (!_lyrics.empty())</a>
<a name="ln1024">                              return _lyrics[0];</a>
<a name="ln1025">                        else</a>
<a name="ln1026">                              return nullptr;</a>
<a name="ln1027">                        }</a>
<a name="ln1028">                  }</a>
<a name="ln1029">            }</a>
<a name="ln1030">      else {</a>
<a name="ln1031">            auto i = std::find(_lyrics.begin(), _lyrics.end(), e);</a>
<a name="ln1032">            if (i != _lyrics.end()) {</a>
<a name="ln1033">                  if (i != _lyrics.end()-1)</a>
<a name="ln1034">                      return *(i+1);</a>
<a name="ln1035">                  }</a>
<a name="ln1036">            }</a>
<a name="ln1037">      return 0;</a>
<a name="ln1038">      }</a>
<a name="ln1039"> </a>
<a name="ln1040">//---------------------------------------------------------</a>
<a name="ln1041">//   prevArticulationOrLyric</a>
<a name="ln1042">//---------------------------------------------------------</a>
<a name="ln1043"> </a>
<a name="ln1044">Element* ChordRest::prevArticulationOrLyric(Element* e)</a>
<a name="ln1045">      {</a>
<a name="ln1046">      auto i = std::find(_lyrics.begin(), _lyrics.end(), e);</a>
<a name="ln1047">      if (i != _lyrics.end()) {</a>
<a name="ln1048">            if (i != _lyrics.begin()) {</a>
<a name="ln1049">                  return *(i-1);</a>
<a name="ln1050">                  }</a>
<a name="ln1051">            else {</a>
<a name="ln1052">                  if (isChord() &amp;&amp; !toChord(this)-&gt;articulations().empty())</a>
<a name="ln1053">                        return toChord(this)-&gt;articulations().back();</a>
<a name="ln1054">                  else</a>
<a name="ln1055">                        return nullptr;</a>
<a name="ln1056">                  }</a>
<a name="ln1057">            }</a>
<a name="ln1058">      else if (isChord() &amp;&amp; e-&gt;isArticulation()) {</a>
<a name="ln1059">            Chord* c = toChord(this);</a>
<a name="ln1060">            auto j = std::find(c-&gt;articulations().begin(), c-&gt;articulations().end(), e);</a>
<a name="ln1061">            if (j != c-&gt;articulations().end()) {</a>
<a name="ln1062">                  if (j != c-&gt;articulations().begin())</a>
<a name="ln1063">                        return *(j-1);</a>
<a name="ln1064">                  }</a>
<a name="ln1065">            }</a>
<a name="ln1066">      return 0;</a>
<a name="ln1067">      }</a>
<a name="ln1068"> </a>
<a name="ln1069">//---------------------------------------------------------</a>
<a name="ln1070">//   nextElement</a>
<a name="ln1071">//---------------------------------------------------------</a>
<a name="ln1072"> </a>
<a name="ln1073">Element* ChordRest::nextElement()</a>
<a name="ln1074">      {</a>
<a name="ln1075">      Element* e = score()-&gt;selection().element();</a>
<a name="ln1076">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty())</a>
<a name="ln1077">            e = score()-&gt;selection().elements().first();</a>
<a name="ln1078">      switch (e-&gt;type()) {</a>
<a name="ln1079">            case ElementType::ARTICULATION:</a>
<a name="ln1080">            case ElementType::LYRICS: {</a>
<a name="ln1081">                  Element* next = nextArticulationOrLyric(e);</a>
<a name="ln1082">                  if (next)</a>
<a name="ln1083">                        return next;</a>
<a name="ln1084">                  else</a>
<a name="ln1085">                        break;</a>
<a name="ln1086">                  }</a>
<a name="ln1087">            default: {</a>
<a name="ln1088">                  if (isChord() &amp;&amp; !toChord(this)-&gt;articulations().empty())</a>
<a name="ln1089">                        return toChord(this)-&gt;articulations()[0];</a>
<a name="ln1090">                  else if (!_lyrics.empty())</a>
<a name="ln1091">                        return _lyrics[0];</a>
<a name="ln1092">                  else</a>
<a name="ln1093">                        break;</a>
<a name="ln1094">                  }</a>
<a name="ln1095">            }</a>
<a name="ln1096">      int staffId = e-&gt;staffIdx();</a>
<a name="ln1097">      return segment()-&gt;nextElement(staffId);</a>
<a name="ln1098">      }</a>
<a name="ln1099"> </a>
<a name="ln1100">//---------------------------------------------------------</a>
<a name="ln1101">//   prevElement</a>
<a name="ln1102">//---------------------------------------------------------</a>
<a name="ln1103"> </a>
<a name="ln1104">Element* ChordRest::prevElement()</a>
<a name="ln1105">      {</a>
<a name="ln1106">      Element* e = score()-&gt;selection().element();</a>
<a name="ln1107">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty())</a>
<a name="ln1108">            e = score()-&gt;selection().elements().last();</a>
<a name="ln1109">      switch (e-&gt;type()) {</a>
<a name="ln1110">            case ElementType::ARTICULATION:</a>
<a name="ln1111">            case ElementType::LYRICS: {</a>
<a name="ln1112">                  Element* prev = prevArticulationOrLyric(e);</a>
<a name="ln1113">                  if (prev)</a>
<a name="ln1114">                        return prev;</a>
<a name="ln1115">                  else {</a>
<a name="ln1116">                        if (isChord())</a>
<a name="ln1117">                              return toChord(this)-&gt;lastElementBeforeSegment();</a>
<a name="ln1118">                        }</a>
<a name="ln1119">                  // fall through</a>
<a name="ln1120">                  }</a>
<a name="ln1121">            default: {</a>
<a name="ln1122">                  break;</a>
<a name="ln1123">                  }</a>
<a name="ln1124">            }</a>
<a name="ln1125">      int staffId = e-&gt;staffIdx();</a>
<a name="ln1126">      return segment()-&gt;prevElement(staffId);</a>
<a name="ln1127">      }</a>
<a name="ln1128"> </a>
<a name="ln1129">//---------------------------------------------------------</a>
<a name="ln1130">//   lastElementBeforeSegment</a>
<a name="ln1131">//---------------------------------------------------------</a>
<a name="ln1132"> </a>
<a name="ln1133">Element* ChordRest::lastElementBeforeSegment()</a>
<a name="ln1134">      {</a>
<a name="ln1135">      if (!_lyrics.empty())</a>
<a name="ln1136">            return _lyrics.back();</a>
<a name="ln1137">//      else if (!_articulations.empty()) {           // TODO:fermata</a>
<a name="ln1138">//            return _articulations.back();</a>
<a name="ln1139">//            }</a>
<a name="ln1140">      else</a>
<a name="ln1141">            return 0;</a>
<a name="ln1142">      }</a>
<a name="ln1143"> </a>
<a name="ln1144">//---------------------------------------------------------</a>
<a name="ln1145">//   nextSegmentElement</a>
<a name="ln1146">//---------------------------------------------------------</a>
<a name="ln1147"> </a>
<a name="ln1148">Element* ChordRest::nextSegmentElement()</a>
<a name="ln1149">      {</a>
<a name="ln1150">      return segment()-&gt;firstInNextSegments(staffIdx());</a>
<a name="ln1151">      }</a>
<a name="ln1152"> </a>
<a name="ln1153">//---------------------------------------------------------</a>
<a name="ln1154">//   prevSegmentElement</a>
<a name="ln1155">//---------------------------------------------------------</a>
<a name="ln1156"> </a>
<a name="ln1157">Element* ChordRest::prevSegmentElement()</a>
<a name="ln1158">      {</a>
<a name="ln1159">      return segment()-&gt;lastInPrevSegments(staffIdx());</a>
<a name="ln1160">      }</a>
<a name="ln1161"> </a>
<a name="ln1162">QString ChordRest::accessibleExtraInfo() const</a>
<a name="ln1163">      {</a>
<a name="ln1164">      QString rez = &quot;&quot;;</a>
<a name="ln1165">      for (Element* l : lyrics()) {</a>
<a name="ln1166">            if (!score()-&gt;selectionFilter().canSelect(l))</a>
<a name="ln1167">                  continue;</a>
<a name="ln1168">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(l-&gt;screenReaderInfo());</a>
<a name="ln1169">            }</a>
<a name="ln1170"> </a>
<a name="ln1171">      if (segment()) {</a>
<a name="ln1172">            for (Element* e : segment()-&gt;annotations()) {</a>
<a name="ln1173">                  if (!score()-&gt;selectionFilter().canSelect(e))</a>
<a name="ln1174">                        continue;</a>
<a name="ln1175">                  if (e-&gt;track() == track())</a>
<a name="ln1176">                        rez = QString(&quot;%1 %2&quot;).arg(rez).arg(e-&gt;screenReaderInfo());</a>
<a name="ln1177">                  }</a>
<a name="ln1178"> </a>
<a name="ln1179">            SpannerMap&amp; smap = score()-&gt;spannerMap();</a>
<a name="ln1180">            auto spanners = smap.findOverlapping(tick().ticks(), tick().ticks());</a>
<a name="ln1181">            for (auto interval : spanners) {</a>
<a name="ln1182">                  Spanner* s = interval.value;</a>
<a name="ln1183">                  if (!score()-&gt;selectionFilter().canSelect(s))</a>
<a name="ln1184">                        continue;</a>
<a name="ln1185">                  if (s-&gt;type() == ElementType::VOLTA || //voltas are added for barlines</a>
<a name="ln1186">                      s-&gt;type() == ElementType::TIE    ) //ties are added in notes</a>
<a name="ln1187">                        continue;</a>
<a name="ln1188"> </a>
<a name="ln1189">                  if (s-&gt;type() == ElementType::SLUR) {</a>
<a name="ln1190">                        if (s-&gt;tick() == tick() &amp;&amp; s-&gt;track() == track())</a>
<a name="ln1191">                              rez = QObject::tr(&quot;%1 Start of %2&quot;).arg(rez).arg(s-&gt;screenReaderInfo());</a>
<a name="ln1192">                        if (s-&gt;tick2() == tick() &amp;&amp; s-&gt;track2() == track())</a>
<a name="ln1193">                              rez = QObject::tr(&quot;%1 End of %2&quot;).arg(rez).arg(s-&gt;screenReaderInfo());</a>
<a name="ln1194">                        }</a>
<a name="ln1195">                  else if (s-&gt;staffIdx() == staffIdx()) {</a>
<a name="ln1196">                        bool start = s-&gt;tick()  == tick();</a>
<a name="ln1197">                        bool end   = s-&gt;tick2() == tick() + ticks();</a>
<a name="ln1198">                        if (start &amp;&amp; end)</a>
<a name="ln1199">                              rez = QObject::tr(&quot;%1 Start and end of %2&quot;).arg(rez).arg(s-&gt;screenReaderInfo());</a>
<a name="ln1200">                        else if (start)</a>
<a name="ln1201">                              rez = QObject::tr(&quot;%1 Start of %2&quot;).arg(rez).arg(s-&gt;screenReaderInfo());</a>
<a name="ln1202">                        else if (end)</a>
<a name="ln1203">                              rez = QObject::tr(&quot;%1 End of %2&quot;).arg(rez).arg(s-&gt;screenReaderInfo());</a>
<a name="ln1204">                        }</a>
<a name="ln1205">                  }</a>
<a name="ln1206">            }</a>
<a name="ln1207">      return rez;</a>
<a name="ln1208">      }</a>
<a name="ln1209"> </a>
<a name="ln1210">//---------------------------------------------------------</a>
<a name="ln1211">//   shape</a>
<a name="ln1212">//---------------------------------------------------------</a>
<a name="ln1213"> </a>
<a name="ln1214">Shape ChordRest::shape() const</a>
<a name="ln1215">      {</a>
<a name="ln1216">      Shape shape;</a>
<a name="ln1217">      {</a>
<a name="ln1218">      qreal x1 = 1000000.0;</a>
<a name="ln1219">      qreal x2 = -1000000.0;</a>
<a name="ln1220">      bool adjustWidth = false;</a>
<a name="ln1221">      for (Lyrics* l : _lyrics) {</a>
<a name="ln1222">            if (!l || !l-&gt;addToSkyline())</a>
<a name="ln1223">                  continue;</a>
<a name="ln1224">            qreal lmargin = score()-&gt;styleS(Sid::lyricsMinDistance).val() * spatium() * 0.5;</a>
<a name="ln1225">            qreal rmargin = lmargin;</a>
<a name="ln1226">            Lyrics::Syllabic syl = l-&gt;syllabic();</a>
<a name="ln1227">            if ((syl == Lyrics::Syllabic::BEGIN || syl == Lyrics::Syllabic::MIDDLE) &amp;&amp; score()-&gt;styleB(Sid::lyricsDashForce))</a>
<a name="ln1228">                  rmargin = qMax(rmargin, styleP(Sid::lyricsDashMinLength));</a>
<a name="ln1229">            // for horizontal spacing we only need the lyrics width:</a>
<a name="ln1230">            x1 = qMin(x1, l-&gt;bbox().x() - lmargin + l-&gt;pos().x());</a>
<a name="ln1231">            x2 = qMax(x2, l-&gt;bbox().x() + l-&gt;bbox().width() + rmargin + l-&gt;pos().x());</a>
<a name="ln1232">            if (l-&gt;ticks() == Fraction::fromTicks(Lyrics::TEMP_MELISMA_TICKS))</a>
<a name="ln1233">                  x2 += spatium();</a>
<a name="ln1234">            adjustWidth = true;</a>
<a name="ln1235">            }</a>
<a name="ln1236">      if (adjustWidth)</a>
<a name="ln1237">            shape.addHorizontalSpacing(Shape::SPACING_LYRICS, x1, x2);</a>
<a name="ln1238">      }</a>
<a name="ln1239"> </a>
<a name="ln1240">      {</a>
<a name="ln1241">      qreal x1 = 1000000.0;</a>
<a name="ln1242">      qreal x2 = -1000000.0;</a>
<a name="ln1243">      bool adjustWidth = false;</a>
<a name="ln1244">      for (Element* e : segment()-&gt;annotations()) {</a>
<a name="ln1245">            if (!e || !e-&gt;addToSkyline())</a>
<a name="ln1246">                  continue;</a>
<a name="ln1247">            if (e-&gt;isHarmony() &amp;&amp; e-&gt;staffIdx() == staffIdx()) {</a>
<a name="ln1248">                  Harmony* h = toHarmony(e);</a>
<a name="ln1249">                  // calculate bbox only (do not reset position)</a>
<a name="ln1250">                  h-&gt;layout1();</a>
<a name="ln1251">                  const qreal margin = styleP(Sid::minHarmonyDistance) * 0.5;</a>
<a name="ln1252">                  x1 = qMin(x1, e-&gt;bbox().x() - margin + e-&gt;pos().x());</a>
<a name="ln1253">                  x2 = qMax(x2, e-&gt;bbox().x() + e-&gt;bbox().width() + margin + e-&gt;pos().x());</a>
<a name="ln1254">                  adjustWidth = true;</a>
<a name="ln1255">                  }</a>
<a name="ln1256">            }</a>
<a name="ln1257">      if (adjustWidth)</a>
<a name="ln1258">            shape.addHorizontalSpacing(Shape::SPACING_HARMONY, x1, x2);</a>
<a name="ln1259">      }</a>
<a name="ln1260"> </a>
<a name="ln1261">      return shape;</a>
<a name="ln1262">      }</a>
<a name="ln1263"> </a>
<a name="ln1264">//---------------------------------------------------------</a>
<a name="ln1265">//   lyrics</a>
<a name="ln1266">//---------------------------------------------------------</a>
<a name="ln1267"> </a>
<a name="ln1268">Lyrics* ChordRest::lyrics(int no, Placement p) const</a>
<a name="ln1269">      {</a>
<a name="ln1270">      for (Lyrics* l : _lyrics) {</a>
<a name="ln1271">            if (l-&gt;placement() == p &amp;&amp; l-&gt;no() == no)</a>
<a name="ln1272">                  return l;</a>
<a name="ln1273">            }</a>
<a name="ln1274">      return 0;</a>
<a name="ln1275">      }</a>
<a name="ln1276"> </a>
<a name="ln1277">//---------------------------------------------------------</a>
<a name="ln1278">//   lastVerse</a>
<a name="ln1279">//    return last verse number (starting from 0)</a>
<a name="ln1280">//    return -1 if there are no lyrics;</a>
<a name="ln1281">//---------------------------------------------------------</a>
<a name="ln1282"> </a>
<a name="ln1283">int ChordRest::lastVerse(Placement p) const</a>
<a name="ln1284">      {</a>
<a name="ln1285">      int lastVerse = -1;</a>
<a name="ln1286"> </a>
<a name="ln1287">      for (Lyrics* l : _lyrics) {</a>
<a name="ln1288">            if (l-&gt;placement() == p &amp;&amp; l-&gt;no() &gt; lastVerse)</a>
<a name="ln1289">                  lastVerse = l-&gt;no();</a>
<a name="ln1290">            }</a>
<a name="ln1291"> </a>
<a name="ln1292">      return lastVerse;</a>
<a name="ln1293">      }</a>
<a name="ln1294"> </a>
<a name="ln1295">//---------------------------------------------------------</a>
<a name="ln1296">//   removeMarkings</a>
<a name="ln1297">//    - this is normally called after cloning a chord to tie a note over the barline</a>
<a name="ln1298">//    - there is no special undo handling; the assumption is that undo will simply remove the cloned chord</a>
<a name="ln1299">//    - two note tremolos are converted into simple notes</a>
<a name="ln1300">//    - single note tremolos are optionally retained</a>
<a name="ln1301">//---------------------------------------------------------</a>
<a name="ln1302"> </a>
<a name="ln1303">void ChordRest::removeMarkings(bool /* keepTremolo */)</a>
<a name="ln1304">      {</a>
<a name="ln1305">      qDeleteAll(el());</a>
<a name="ln1306">      el().clear();</a>
<a name="ln1307">      qDeleteAll(lyrics());</a>
<a name="ln1308">      lyrics().clear();</a>
<a name="ln1309">      }</a>
<a name="ln1310"> </a>
<a name="ln1311">//---------------------------------------------------------</a>
<a name="ln1312">//   isBefore</a>
<a name="ln1313">//---------------------------------------------------------</a>
<a name="ln1314"> </a>
<a name="ln1315">bool ChordRest::isBefore(const ChordRest* o) const</a>
<a name="ln1316">      {</a>
<a name="ln1317">      if (!o || this == o)</a>
<a name="ln1318">            return true;</a>
<a name="ln1319">      int otick = o-&gt;tick().ticks();</a>
<a name="ln1320">      int t     = tick().ticks();</a>
<a name="ln1321">      if (t == otick) { // At least one of the chord is a grace, order the grace notes</a>
<a name="ln1322">            bool oGraceAfter = o-&gt;isGraceAfter();</a>
<a name="ln1323">            bool graceAfter  = isGraceAfter();</a>
<a name="ln1324">            bool oGrace      = o-&gt;isGrace();</a>
<a name="ln1325">            bool grace       = isGrace();</a>
<a name="ln1326">            // normal note are initialized at graceIndex 0 and graceIndex is 0 based</a>
<a name="ln1327">            int oGraceIndex  = oGrace ? toChord(o)-&gt;graceIndex() +  1 : 0;</a>
<a name="ln1328">            int graceIndex   = grace ? toChord(this)-&gt;graceIndex() + 1 : 0;</a>
<a name="ln1329">            if (oGrace)</a>
<a name="ln1330">                  oGraceIndex = toChord(o-&gt;parent())-&gt;graceNotes().size() - oGraceIndex;</a>
<a name="ln1331">            if (grace)</a>
<a name="ln1332">                  graceIndex = toChord(parent())-&gt;graceNotes().size() - graceIndex;</a>
<a name="ln1333">            otick = otick + (oGraceAfter ? 1 : -1) *  oGraceIndex;</a>
<a name="ln1334">            t     = t + (graceAfter ? 1 : -1) *  graceIndex;</a>
<a name="ln1335">            }</a>
<a name="ln1336">      return t &lt; otick;</a>
<a name="ln1337">      }</a>
<a name="ln1338"> </a>
<a name="ln1339">//---------------------------------------------------------</a>
<a name="ln1340">//   undoAddAnnotation</a>
<a name="ln1341">//---------------------------------------------------------</a>
<a name="ln1342"> </a>
<a name="ln1343">void ChordRest::undoAddAnnotation(Element* a)</a>
<a name="ln1344">      {</a>
<a name="ln1345">      Segment* seg = segment();</a>
<a name="ln1346">      Measure* m = measure();</a>
<a name="ln1347">      if (m &amp;&amp; m-&gt;isMMRest())</a>
<a name="ln1348">            seg = m-&gt;mmRestFirst()-&gt;findSegmentR(SegmentType::ChordRest, Fraction(0,1));</a>
<a name="ln1349"> </a>
<a name="ln1350">      a-&gt;setTrack(a-&gt;systemFlag() ? 0 : track());</a>
<a name="ln1351">      a-&gt;setParent(seg);</a>
<a name="ln1352">      score()-&gt;undoAddElement(a);</a>
<a name="ln1353">      }</a>
<a name="ln1354"> </a>
<a name="ln1355">}</a>
<a name="ln1356"> </a>

</code></pre>
<div class="balloon" rel="265"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="633"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="747"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
