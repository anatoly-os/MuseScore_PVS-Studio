
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>score.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">/**</a>
<a name="ln14"> \file</a>
<a name="ln15"> Implementation of class Score (partial).</a>
<a name="ln16">*/</a>
<a name="ln17"> </a>
<a name="ln18">#include &lt;assert.h&gt;</a>
<a name="ln19">#include &quot;score.h&quot;</a>
<a name="ln20">#include &quot;fermata.h&quot;</a>
<a name="ln21">#include &quot;imageStore.h&quot;</a>
<a name="ln22">#include &quot;key.h&quot;</a>
<a name="ln23">#include &quot;sig.h&quot;</a>
<a name="ln24">#include &quot;clef.h&quot;</a>
<a name="ln25">#include &quot;tempo.h&quot;</a>
<a name="ln26">#include &quot;measure.h&quot;</a>
<a name="ln27">#include &quot;page.h&quot;</a>
<a name="ln28">#include &quot;undo.h&quot;</a>
<a name="ln29">#include &quot;system.h&quot;</a>
<a name="ln30">#include &quot;select.h&quot;</a>
<a name="ln31">#include &quot;segment.h&quot;</a>
<a name="ln32">#include &quot;xml.h&quot;</a>
<a name="ln33">#include &quot;text.h&quot;</a>
<a name="ln34">#include &quot;note.h&quot;</a>
<a name="ln35">#include &quot;chord.h&quot;</a>
<a name="ln36">#include &quot;rest.h&quot;</a>
<a name="ln37">#include &quot;slur.h&quot;</a>
<a name="ln38">#include &quot;staff.h&quot;</a>
<a name="ln39">#include &quot;part.h&quot;</a>
<a name="ln40">#include &quot;style.h&quot;</a>
<a name="ln41">#include &quot;tuplet.h&quot;</a>
<a name="ln42">#include &quot;lyrics.h&quot;</a>
<a name="ln43">#include &quot;pitchspelling.h&quot;</a>
<a name="ln44">#include &quot;line.h&quot;</a>
<a name="ln45">#include &quot;volta.h&quot;</a>
<a name="ln46">#include &quot;repeat.h&quot;</a>
<a name="ln47">#include &quot;ottava.h&quot;</a>
<a name="ln48">#include &quot;barline.h&quot;</a>
<a name="ln49">#include &quot;box.h&quot;</a>
<a name="ln50">#include &quot;utils.h&quot;</a>
<a name="ln51">#include &quot;excerpt.h&quot;</a>
<a name="ln52">#include &quot;stafftext.h&quot;</a>
<a name="ln53">#include &quot;repeatlist.h&quot;</a>
<a name="ln54">#include &quot;keysig.h&quot;</a>
<a name="ln55">#include &quot;beam.h&quot;</a>
<a name="ln56">#include &quot;stafftype.h&quot;</a>
<a name="ln57">#include &quot;tempotext.h&quot;</a>
<a name="ln58">#include &quot;articulation.h&quot;</a>
<a name="ln59">#include &quot;revisions.h&quot;</a>
<a name="ln60">#include &quot;tie.h&quot;</a>
<a name="ln61">#include &quot;tiemap.h&quot;</a>
<a name="ln62">#include &quot;layoutbreak.h&quot;</a>
<a name="ln63">#include &quot;harmony.h&quot;</a>
<a name="ln64">#include &quot;mscore.h&quot;</a>
<a name="ln65">#ifdef OMR</a>
<a name="ln66">#include &quot;omr/omr.h&quot;</a>
<a name="ln67">#endif</a>
<a name="ln68">#include &quot;bracket.h&quot;</a>
<a name="ln69">#include &quot;audio.h&quot;</a>
<a name="ln70">#include &quot;instrtemplate.h&quot;</a>
<a name="ln71">#include &quot;sym.h&quot;</a>
<a name="ln72">#include &quot;rehearsalmark.h&quot;</a>
<a name="ln73">#include &quot;breath.h&quot;</a>
<a name="ln74">#include &quot;instrchange.h&quot;</a>
<a name="ln75">#include &quot;synthesizerstate.h&quot;</a>
<a name="ln76"> </a>
<a name="ln77">namespace Ms {</a>
<a name="ln78"> </a>
<a name="ln79">MasterScore* gscore;                 ///&lt; system score, used for palettes etc.</a>
<a name="ln80">std::set&lt;Score*&gt; Score::validScores;</a>
<a name="ln81"> </a>
<a name="ln82">bool noSeq           = false;</a>
<a name="ln83">bool noMidi          = false;</a>
<a name="ln84">bool midiInputTrace  = false;</a>
<a name="ln85">bool midiOutputTrace = false;</a>
<a name="ln86"> </a>
<a name="ln87">//---------------------------------------------------------</a>
<a name="ln88">//   MeasureBaseList</a>
<a name="ln89">//---------------------------------------------------------</a>
<a name="ln90"> </a>
<a name="ln91">MeasureBaseList::MeasureBaseList()</a>
<a name="ln92">      {</a>
<a name="ln93">      _first = 0;</a>
<a name="ln94">      _last  = 0;</a>
<a name="ln95">      _size  = 0;</a>
<a name="ln96">      };</a>
<a name="ln97"> </a>
<a name="ln98">//---------------------------------------------------------</a>
<a name="ln99">//   push_back</a>
<a name="ln100">//---------------------------------------------------------</a>
<a name="ln101"> </a>
<a name="ln102">void MeasureBaseList::push_back(MeasureBase* e)</a>
<a name="ln103">      {</a>
<a name="ln104">      ++_size;</a>
<a name="ln105">      if (_last) {</a>
<a name="ln106">            _last-&gt;setNext(e);</a>
<a name="ln107">            e-&gt;setPrev(_last);</a>
<a name="ln108">            e-&gt;setNext(0);</a>
<a name="ln109">            }</a>
<a name="ln110">      else {</a>
<a name="ln111">            _first = e;</a>
<a name="ln112">            e-&gt;setPrev(0);</a>
<a name="ln113">            e-&gt;setNext(0);</a>
<a name="ln114">            }</a>
<a name="ln115">      _last = e;</a>
<a name="ln116">      }</a>
<a name="ln117"> </a>
<a name="ln118">//---------------------------------------------------------</a>
<a name="ln119">//   push_front</a>
<a name="ln120">//---------------------------------------------------------</a>
<a name="ln121"> </a>
<a name="ln122">void MeasureBaseList::push_front(MeasureBase* e)</a>
<a name="ln123">      {</a>
<a name="ln124">      ++_size;</a>
<a name="ln125">      if (_first) {</a>
<a name="ln126">            _first-&gt;setPrev(e);</a>
<a name="ln127">            e-&gt;setNext(_first);</a>
<a name="ln128">            e-&gt;setPrev(0);</a>
<a name="ln129">            }</a>
<a name="ln130">      else {</a>
<a name="ln131">            _last = e;</a>
<a name="ln132">            e-&gt;setPrev(0);</a>
<a name="ln133">            e-&gt;setNext(0);</a>
<a name="ln134">            }</a>
<a name="ln135">      _first = e;</a>
<a name="ln136">      }</a>
<a name="ln137"> </a>
<a name="ln138">//---------------------------------------------------------</a>
<a name="ln139">//   add</a>
<a name="ln140">//    insert e before e-&gt;next()</a>
<a name="ln141">//---------------------------------------------------------</a>
<a name="ln142"> </a>
<a name="ln143">void MeasureBaseList::add(MeasureBase* e)</a>
<a name="ln144">      {</a>
<a name="ln145">      MeasureBase* el = e-&gt;next();</a>
<a name="ln146">      if (el == 0) {</a>
<a name="ln147">            push_back(e);</a>
<a name="ln148">            return;</a>
<a name="ln149">            }</a>
<a name="ln150">      if (el == _first) {</a>
<a name="ln151">            push_front(e);</a>
<a name="ln152">            return;</a>
<a name="ln153">            }</a>
<a name="ln154">      ++_size;</a>
<a name="ln155">      e-&gt;setPrev(el-&gt;prev());</a>
<a name="ln156">      el-&gt;prev()-&gt;setNext(e);</a>
<a name="ln157">      el-&gt;setPrev(e);</a>
<a name="ln158">      }</a>
<a name="ln159"> </a>
<a name="ln160">//---------------------------------------------------------</a>
<a name="ln161">//   remove</a>
<a name="ln162">//---------------------------------------------------------</a>
<a name="ln163"> </a>
<a name="ln164">void MeasureBaseList::remove(MeasureBase* el)</a>
<a name="ln165">      {</a>
<a name="ln166">      --_size;</a>
<a name="ln167">      if (el-&gt;prev())</a>
<a name="ln168">            el-&gt;prev()-&gt;setNext(el-&gt;next());</a>
<a name="ln169">      else</a>
<a name="ln170">            _first = el-&gt;next();</a>
<a name="ln171">      if (el-&gt;next())</a>
<a name="ln172">            el-&gt;next()-&gt;setPrev(el-&gt;prev());</a>
<a name="ln173">      else</a>
<a name="ln174">            _last = el-&gt;prev();</a>
<a name="ln175">      }</a>
<a name="ln176"> </a>
<a name="ln177">//---------------------------------------------------------</a>
<a name="ln178">//   insert</a>
<a name="ln179">//---------------------------------------------------------</a>
<a name="ln180"> </a>
<a name="ln181">void MeasureBaseList::insert(MeasureBase* fm, MeasureBase* lm)</a>
<a name="ln182">      {</a>
<a name="ln183">      ++_size;</a>
<a name="ln184">      for (MeasureBase* m = fm; m != lm; m = m-&gt;next())</a>
<a name="ln185">            ++_size;</a>
<a name="ln186">      MeasureBase* pm = fm-&gt;prev();</a>
<a name="ln187">      if (pm)</a>
<a name="ln188">            pm-&gt;setNext(fm);</a>
<a name="ln189">      else</a>
<a name="ln190">            _first = fm;</a>
<a name="ln191">      MeasureBase* nm = lm-&gt;next();</a>
<a name="ln192">      if (nm)</a>
<a name="ln193">            nm-&gt;setPrev(lm);</a>
<a name="ln194">      else</a>
<a name="ln195">            _last = lm;</a>
<a name="ln196">      }</a>
<a name="ln197"> </a>
<a name="ln198">//---------------------------------------------------------</a>
<a name="ln199">//   remove</a>
<a name="ln200">//---------------------------------------------------------</a>
<a name="ln201"> </a>
<a name="ln202">void MeasureBaseList::remove(MeasureBase* fm, MeasureBase* lm)</a>
<a name="ln203">      {</a>
<a name="ln204">      --_size;</a>
<a name="ln205">      for (MeasureBase* m = fm; m != lm; m = m-&gt;next())</a>
<a name="ln206">            --_size;</a>
<a name="ln207">      MeasureBase* pm = fm-&gt;prev();</a>
<a name="ln208">      MeasureBase* nm = lm-&gt;next();</a>
<a name="ln209">      if (pm)</a>
<a name="ln210">            pm-&gt;setNext(nm);</a>
<a name="ln211">      else</a>
<a name="ln212">            _first = nm;</a>
<a name="ln213">      if (nm)</a>
<a name="ln214">            nm-&gt;setPrev(pm);</a>
<a name="ln215">      else</a>
<a name="ln216">            _last = pm;</a>
<a name="ln217">      }</a>
<a name="ln218"> </a>
<a name="ln219">//---------------------------------------------------------</a>
<a name="ln220">//   change</a>
<a name="ln221">//---------------------------------------------------------</a>
<a name="ln222"> </a>
<a name="ln223">void MeasureBaseList::change(MeasureBase* ob, MeasureBase* nb)</a>
<a name="ln224">      {</a>
<a name="ln225">      nb-&gt;setPrev(ob-&gt;prev());</a>
<a name="ln226">      nb-&gt;setNext(ob-&gt;next());</a>
<a name="ln227">      if (ob-&gt;prev())</a>
<a name="ln228">            ob-&gt;prev()-&gt;setNext(nb);</a>
<a name="ln229">      if (ob-&gt;next())</a>
<a name="ln230">            ob-&gt;next()-&gt;setPrev(nb);</a>
<a name="ln231">      if (ob == _last)</a>
<a name="ln232">            _last = nb;</a>
<a name="ln233">      if (ob == _first)</a>
<a name="ln234">            _first = nb;</a>
<a name="ln235">      if (nb-&gt;type() == ElementType::HBOX || nb-&gt;type() == ElementType::VBOX</a>
<a name="ln236">         || nb-&gt;type() == ElementType::TBOX || nb-&gt;type() == ElementType::FBOX)</a>
<a name="ln237">            nb-&gt;setSystem(ob-&gt;system());</a>
<a name="ln238">      foreach(Element* e, nb-&gt;el())</a>
<a name="ln239">            e-&gt;setParent(nb);</a>
<a name="ln240">      }</a>
<a name="ln241"> </a>
<a name="ln242">//---------------------------------------------------------</a>
<a name="ln243">//   Score</a>
<a name="ln244">//---------------------------------------------------------</a>
<a name="ln245"> </a>
<a name="ln246">Score::Score()</a>
<a name="ln247">   : ScoreElement(this), _selection(this), _selectionFilter(this)</a>
<a name="ln248">      {</a>
<a name="ln249">      Score::validScores.insert(this);</a>
<a name="ln250">      _masterScore = 0;</a>
<a name="ln251">      Layer l;</a>
<a name="ln252">      l.name          = &quot;default&quot;;</a>
<a name="ln253">      l.tags          = 1;</a>
<a name="ln254">      _layer.append(l);</a>
<a name="ln255">      _layerTags[0]   = &quot;default&quot;;</a>
<a name="ln256"> </a>
<a name="ln257">      _scoreFont = ScoreFont::fontFactory(&quot;emmentaler&quot;);</a>
<a name="ln258"> </a>
<a name="ln259">      _fileDivision           = MScore::division;</a>
<a name="ln260">      _style  = MScore::defaultStyle();</a>
<a name="ln261">//      accInfo = tr(&quot;No selection&quot;);     // ??</a>
<a name="ln262">      accInfo = &quot;No selection&quot;;</a>
<a name="ln263">      }</a>
<a name="ln264"> </a>
<a name="ln265">Score::Score(MasterScore* parent, bool forcePartStyle /* = true */)</a>
<a name="ln266">   : Score{}</a>
<a name="ln267">      {</a>
<a name="ln268">      Score::validScores.insert(this);</a>
<a name="ln269">      _masterScore = parent;</a>
<a name="ln270">      if (MScore::defaultStyleForParts())</a>
<a name="ln271">            _style = *MScore::defaultStyleForParts();</a>
<a name="ln272">      else {</a>
<a name="ln273">            // inherit most style settings from parent</a>
<a name="ln274">            _style = parent-&gt;style();</a>
<a name="ln275"> </a>
<a name="ln276">            static const Sid styles[] = {</a>
<a name="ln277">                  Sid::pageWidth,</a>
<a name="ln278">                  Sid::pageHeight,</a>
<a name="ln279">                  Sid::pagePrintableWidth,</a>
<a name="ln280">                  Sid::pageEvenLeftMargin,</a>
<a name="ln281">                  Sid::pageOddLeftMargin,</a>
<a name="ln282">                  Sid::pageEvenTopMargin,</a>
<a name="ln283">                  Sid::pageEvenBottomMargin,</a>
<a name="ln284">                  Sid::pageOddTopMargin,</a>
<a name="ln285">                  Sid::pageOddBottomMargin,</a>
<a name="ln286">                  Sid::pageTwosided,</a>
<a name="ln287">                  Sid::spatium</a>
<a name="ln288">                  };</a>
<a name="ln289">            // but borrow defaultStyle page layout settings</a>
<a name="ln290">            for (auto i : styles)</a>
<a name="ln291">                  _style.set(i, MScore::defaultStyle().value(i));</a>
<a name="ln292">            // and force some style settings that just make sense for parts</a>
<a name="ln293">            if (forcePartStyle) {</a>
<a name="ln294">                  style().set(Sid::concertPitch, false);</a>
<a name="ln295">                  style().set(Sid::createMultiMeasureRests, true);</a>
<a name="ln296">                  style().set(Sid::dividerLeft, false);</a>
<a name="ln297">                  style().set(Sid::dividerRight, false);</a>
<a name="ln298">                  }</a>
<a name="ln299">            }</a>
<a name="ln300">      // update style values</a>
<a name="ln301">      _style.precomputeValues();</a>
<a name="ln302">      _synthesizerState = parent-&gt;_synthesizerState;</a>
<a name="ln303">      _mscVersion = parent-&gt;_mscVersion;</a>
<a name="ln304">      }</a>
<a name="ln305"> </a>
<a name="ln306">Score::Score(MasterScore* parent, const MStyle&amp; s)</a>
<a name="ln307">   : Score{parent}</a>
<a name="ln308">      {</a>
<a name="ln309">      Score::validScores.insert(this);</a>
<a name="ln310">      _style  = s;</a>
<a name="ln311">      }</a>
<a name="ln312"> </a>
<a name="ln313">//---------------------------------------------------------</a>
<a name="ln314">//   ~Score</a>
<a name="ln315">//---------------------------------------------------------</a>
<a name="ln316"> </a>
<a name="ln317">Score::~Score()</a>
<a name="ln318">      {</a>
<a name="ln319">      Score::validScores.erase(this);</a>
<a name="ln320"> </a>
<a name="ln321">      foreach(MuseScoreView* v, viewer)</a>
<a name="ln322">            v-&gt;removeScore();</a>
<a name="ln323">      // deselectAll();</a>
<a name="ln324">      qDeleteAll(_systems); // systems are layout-only objects so we delete</a>
<a name="ln325">                            // them prior to measures.</a>
<a name="ln326">      for (MeasureBase* m = _measures.first(); m;) {</a>
<a name="ln327">            MeasureBase* nm = m-&gt;next();</a>
<a name="ln328">            if (m-&gt;isMeasure() &amp;&amp; toMeasure(m)-&gt;mmRest())</a>
<a name="ln329">                  delete toMeasure(m)-&gt;mmRest();</a>
<a name="ln330">            delete m;</a>
<a name="ln331">            m = nm;</a>
<a name="ln332">            }</a>
<a name="ln333"> </a>
<a name="ln334">      for (auto it = _spanner.cbegin(); it != _spanner.cend(); ++it)</a>
<a name="ln335">            delete it-&gt;second;</a>
<a name="ln336">      _spanner.clear();</a>
<a name="ln337"> </a>
<a name="ln338">      qDeleteAll(_parts);</a>
<a name="ln339">      qDeleteAll(_staves);</a>
<a name="ln340">//      qDeleteAll(_pages);         // TODO: check</a>
<a name="ln341">      _masterScore = 0;</a>
<a name="ln342"> </a>
<a name="ln343">      imageStore.clearUnused();</a>
<a name="ln344">      }</a>
<a name="ln345"> </a>
<a name="ln346">//---------------------------------------------------------</a>
<a name="ln347">//   Score::clone</a>
<a name="ln348">//         To create excerpt clone to show when changing PageSettings</a>
<a name="ln349">//         Use MasterScore::clone() instead</a>
<a name="ln350">//---------------------------------------------------------</a>
<a name="ln351"> </a>
<a name="ln352">Score* Score::clone()</a>
<a name="ln353">      {</a>
<a name="ln354">      QBuffer buffer;</a>
<a name="ln355">      buffer.open(QIODevice::WriteOnly);</a>
<a name="ln356">      XmlWriter xml(this, &amp;buffer);</a>
<a name="ln357">      xml.header();</a>
<a name="ln358"> </a>
<a name="ln359">      xml.stag(&quot;museScore version=\&quot;&quot; MSC_VERSION &quot;\&quot;&quot;);</a>
<a name="ln360">      write(xml, false);</a>
<a name="ln361">      xml.etag();</a>
<a name="ln362"> </a>
<a name="ln363">      buffer.close();</a>
<a name="ln364"> </a>
<a name="ln365">      XmlReader r(buffer.buffer());</a>
<a name="ln366">      MasterScore* score = new MasterScore(style());</a>
<a name="ln367">      score-&gt;read1(r, true);</a>
<a name="ln368"> </a>
<a name="ln369">      score-&gt;addLayoutFlags(LayoutFlag::FIX_PITCH_VELO);</a>
<a name="ln370">      score-&gt;doLayout();</a>
<a name="ln371">      return score;</a>
<a name="ln372">      }</a>
<a name="ln373"> </a>
<a name="ln374">//---------------------------------------------------------</a>
<a name="ln375">//   Score::onElementDestruction</a>
<a name="ln376">//    Ensure correct state of the score after destruction</a>
<a name="ln377">//    of the element (e.g. remove invalid pointers etc.).</a>
<a name="ln378">//---------------------------------------------------------</a>
<a name="ln379"> </a>
<a name="ln380">void Score::onElementDestruction(Element* e)</a>
<a name="ln381">      {</a>
<a name="ln382">      Score* score = e-&gt;score();</a>
<a name="ln383">      if (!score || Score::validScores.find(score) == Score::validScores.end()) {</a>
<a name="ln384">            // No score or the score is already deleted</a>
<a name="ln385">            return;</a>
<a name="ln386">            }</a>
<a name="ln387">      score-&gt;selection().remove(e);</a>
<a name="ln388">      score-&gt;cmdState().unsetElement(e);</a>
<a name="ln389">      for (MuseScoreView* v : score-&gt;viewer)</a>
<a name="ln390">            v-&gt;onElementDestruction(e);</a>
<a name="ln391">      }</a>
<a name="ln392"> </a>
<a name="ln393">//---------------------------------------------------------</a>
<a name="ln394">//   addMeasure</a>
<a name="ln395">//---------------------------------------------------------</a>
<a name="ln396"> </a>
<a name="ln397">void Score::addMeasure(MeasureBase* m, MeasureBase* pos)</a>
<a name="ln398">      {</a>
<a name="ln399">      m-&gt;setNext(pos);</a>
<a name="ln400">      _measures.add(m);</a>
<a name="ln401">      }</a>
<a name="ln402"> </a>
<a name="ln403">//---------------------------------------------------------</a>
<a name="ln404">//    fixTicks</a>
<a name="ln405">//    update:</a>
<a name="ln406">//      - measure ticks</a>
<a name="ln407">//      - tempo map</a>
<a name="ln408">//      - time signature map</a>
<a name="ln409">//---------------------------------------------------------</a>
<a name="ln410"> </a>
<a name="ln411">/**</a>
<a name="ln412"> This is needed after</a>
<a name="ln413">      - inserting or removing a measure</a>
<a name="ln414">      - changing the sigmap</a>
<a name="ln415">      - after inserting/deleting time (changes the sigmap)</a>
<a name="ln416">*/</a>
<a name="ln417"> </a>
<a name="ln418">void Score::fixTicks()</a>
<a name="ln419">      {</a>
<a name="ln420">      Fraction tick = Fraction(0,1);</a>
<a name="ln421">      Measure* fm = firstMeasure();</a>
<a name="ln422">      if (fm == 0)</a>
<a name="ln423">            return;</a>
<a name="ln424"> </a>
<a name="ln425">      for (Staff* staff : _staves)</a>
<a name="ln426">            staff-&gt;clearTimeSig();</a>
<a name="ln427"> </a>
<a name="ln428">      if (isMaster()) {</a>
<a name="ln429">            tempomap()-&gt;clear();</a>
<a name="ln430">            sigmap()-&gt;clear();</a>
<a name="ln431">            sigmap()-&gt;add(0, SigEvent(fm-&gt;ticks(),  fm-&gt;timesig(), 0));</a>
<a name="ln432">            }</a>
<a name="ln433"> </a>
<a name="ln434">      for (MeasureBase* mb = first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln435">            if (mb-&gt;type() != ElementType::MEASURE) {</a>
<a name="ln436">                  mb-&gt;setTick(tick);</a>
<a name="ln437">                  continue;</a>
<a name="ln438">                  }</a>
<a name="ln439">            Measure* m            = toMeasure(mb);</a>
<a name="ln440">            Fraction mtick        = m-&gt;tick();</a>
<a name="ln441">            Fraction diff         = tick - mtick;</a>
<a name="ln442">            Fraction measureTicks = m-&gt;ticks();</a>
<a name="ln443">            m-&gt;moveTicks(diff);</a>
<a name="ln444">            if (m-&gt;mmRest())</a>
<a name="ln445">                  m-&gt;mmRest()-&gt;moveTicks(diff);</a>
<a name="ln446"> </a>
<a name="ln447">            rebuildTempoAndTimeSigMaps(m);</a>
<a name="ln448"> </a>
<a name="ln449">            tick += measureTicks;</a>
<a name="ln450">            }</a>
<a name="ln451">      // Now done in getNextMeasure(), do we keep?</a>
<a name="ln452">      if (tempomap()-&gt;empty())</a>
<a name="ln453">            tempomap()-&gt;setTempo(0, _defaultTempo);</a>
<a name="ln454">      }</a>
<a name="ln455"> </a>
<a name="ln456">//---------------------------------------------------------</a>
<a name="ln457">//    fixTicks</a>
<a name="ln458">///    updates tempomap and time sig map for a measure</a>
<a name="ln459">//---------------------------------------------------------</a>
<a name="ln460"> </a>
<a name="ln461">void Score::rebuildTempoAndTimeSigMaps(Measure* measure)</a>
<a name="ln462">      {</a>
<a name="ln463">      if (isMaster()) {</a>
<a name="ln464">            // Reset tempo to set correct time stretch for fermata.</a>
<a name="ln465">            const Fraction&amp; startTick = measure-&gt;tick();</a>
<a name="ln466">            resetTempoRange(startTick, measure-&gt;endTick());</a>
<a name="ln467"> </a>
<a name="ln468">            // Implement section break rest</a>
<a name="ln469">            for (MeasureBase* mb = measure-&gt;prev(); mb &amp;&amp; mb-&gt;endTick() == startTick; mb = mb-&gt;prev()) {</a>
<a name="ln470">                  if (mb-&gt;pause())</a>
<a name="ln471">                        setPause(startTick, mb-&gt;pause());</a>
<a name="ln472">                  }</a>
<a name="ln473"> </a>
<a name="ln474">            // Add pauses from the end of the previous measure (at measure-&gt;tick()):</a>
<a name="ln475">            for (Segment* s = measure-&gt;first(); s &amp;&amp; s-&gt;tick() == startTick; s = s-&gt;prev1()) {</a>
<a name="ln476">                  if (!s-&gt;isBreathType())</a>
<a name="ln477">                        continue;</a>
<a name="ln478">                  qreal length = 0.0;</a>
<a name="ln479">                  for (Element* e : s-&gt;elist()) {</a>
<a name="ln480">                        if (e &amp;&amp; e-&gt;isBreath())</a>
<a name="ln481">                              length = qMax(length, toBreath(e)-&gt;pause());</a>
<a name="ln482">                        }</a>
<a name="ln483">                  if (length != 0.0)</a>
<a name="ln484">                        setPause(startTick, length);</a>
<a name="ln485">                  }</a>
<a name="ln486">            }</a>
<a name="ln487"> </a>
<a name="ln488">      for (Segment&amp; segment : measure-&gt;segments()) {</a>
<a name="ln489">            if (segment.isBreathType()) {</a>
<a name="ln490">                  if (!isMaster())</a>
<a name="ln491">                        continue;</a>
<a name="ln492">                  qreal length = 0.0;</a>
<a name="ln493">                  Fraction tick = segment.tick();</a>
<a name="ln494">                  // find longest pause</a>
<a name="ln495">                  for (int i = 0, n = ntracks(); i &lt; n; ++i) {</a>
<a name="ln496">                        Element* e = segment.element(i);</a>
<a name="ln497">                        if (e &amp;&amp; e-&gt;isBreath()) {</a>
<a name="ln498">                              Breath* b = toBreath(e);</a>
<a name="ln499">                              length = qMax(length, b-&gt;pause());</a>
<a name="ln500">                              }</a>
<a name="ln501">                        }</a>
<a name="ln502">                  if (length != 0.0)</a>
<a name="ln503">                        setPause(tick, length);</a>
<a name="ln504">                  }</a>
<a name="ln505">            else if (segment.isTimeSigType()) {</a>
<a name="ln506">                  for (int staffIdx = 0; staffIdx &lt; _staves.size(); ++staffIdx) {</a>
<a name="ln507">                        TimeSig* ts = toTimeSig(segment.element(staffIdx * VOICES));</a>
<a name="ln508">                        if (ts)</a>
<a name="ln509">                              staff(staffIdx)-&gt;addTimeSig(ts);</a>
<a name="ln510">                        }</a>
<a name="ln511">                  }</a>
<a name="ln512">            else if (segment.isChordRestType()) {</a>
<a name="ln513">                  if (!isMaster())</a>
<a name="ln514">                        continue;</a>
<a name="ln515">                  qreal stretch = 0.0;</a>
<a name="ln516">                  for (Element* e : segment.annotations()) {</a>
<a name="ln517">                        if (e-&gt;isFermata() &amp;&amp; toFermata(e)-&gt;play())</a>
<a name="ln518">                              stretch = qMax(stretch, toFermata(e)-&gt;timeStretch());</a>
<a name="ln519">                        else if (e-&gt;isTempoText()) {</a>
<a name="ln520">                              TempoText* tt = toTempoText(e);</a>
<a name="ln521">                              if (tt-&gt;isRelative())</a>
<a name="ln522">                                    tt-&gt;updateRelative();</a>
<a name="ln523">                              setTempo(tt-&gt;segment(), tt-&gt;tempo());</a>
<a name="ln524">                              }</a>
<a name="ln525">                        }</a>
<a name="ln526">                  if (stretch != 0.0 &amp;&amp; stretch != 1.0) {</a>
<a name="ln527">                        qreal otempo = tempomap()-&gt;tempo(segment.tick().ticks());</a>
<a name="ln528">                        qreal ntempo = otempo / stretch;</a>
<a name="ln529">                        setTempo(segment.tick(), ntempo);</a>
<a name="ln530">                        Fraction etick = segment.tick() + segment.ticks() - Fraction(1, 480*4);</a>
<a name="ln531">                        auto e = tempomap()-&gt;find(etick.ticks());</a>
<a name="ln532">                        if (e == tempomap()-&gt;end())</a>
<a name="ln533">                              setTempo(etick, otempo);</a>
<a name="ln534">                        }</a>
<a name="ln535">                  }</a>
<a name="ln536">            }</a>
<a name="ln537"> </a>
<a name="ln538">      // update time signature map</a>
<a name="ln539">      // create event if measure len and time signature are different</a>
<a name="ln540">      // even if they are equivalent 4/4 vs 2/2</a>
<a name="ln541">      // also check if nominal time signature has changed</a>
<a name="ln542"> </a>
<a name="ln543">      if (isMaster()) {</a>
<a name="ln544">            const Measure* m = measure;</a>
<a name="ln545">            const Fraction mTicks = m-&gt;isMMRest() ? m-&gt;mmRestFirst()-&gt;ticks() : m-&gt;ticks(); // for time signature the underlying measure length matters for MM rests</a>
<a name="ln546"> </a>
<a name="ln547">            const Measure* pm = measure-&gt;prevMeasure();</a>
<a name="ln548">            // prevMeasure() doesn't return MM rest so we don't handle it here</a>
<a name="ln549"> </a>
<a name="ln550">            if (pm &amp;&amp; (!mTicks.identical(pm-&gt;ticks()) || !m-&gt;timesig().identical(pm-&gt;timesig())))</a>
<a name="ln551">                  sigmap()-&gt;add(m-&gt;tick().ticks(), SigEvent(mTicks, m-&gt;timesig(), m-&gt;no()));</a>
<a name="ln552">            }</a>
<a name="ln553">      }</a>
<a name="ln554"> </a>
<a name="ln555">//---------------------------------------------------------</a>
<a name="ln556">//   validSegment</a>
<a name="ln557">//---------------------------------------------------------</a>
<a name="ln558"> </a>
<a name="ln559">static bool validSegment(Segment* s, int startTrack, int endTrack)</a>
<a name="ln560">      {</a>
<a name="ln561">      for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln562">            if (s-&gt;element(track))</a>
<a name="ln563">                  return true;</a>
<a name="ln564">            }</a>
<a name="ln565">      return false;</a>
<a name="ln566">      }</a>
<a name="ln567"> </a>
<a name="ln568">//---------------------------------------------------------</a>
<a name="ln569">//   pos2measure</a>
<a name="ln570">//     Return measure for canvas relative position \a p.</a>
<a name="ln571">//---------------------------------------------------------</a>
<a name="ln572"> </a>
<a name="ln573">Measure* Score::pos2measure(const QPointF&amp; p, int* rst, int* pitch, Segment** seg, QPointF* offset) const</a>
<a name="ln574">      {</a>
<a name="ln575">      Measure* m = searchMeasure(p);</a>
<a name="ln576">      if (m == 0)</a>
<a name="ln577">            return 0;</a>
<a name="ln578"> </a>
<a name="ln579">      System* s = m-&gt;system();</a>
<a name="ln580">      qreal y   = p.y() - s-&gt;canvasPos().y();</a>
<a name="ln581"> </a>
<a name="ln582">      int i = 0;</a>
<a name="ln583">      for (; i &lt; nstaves();) {</a>
<a name="ln584">            SysStaff* stff = s-&gt;staff(i);</a>
<a name="ln585">            if (!stff-&gt;show() || !staff(i)-&gt;show()) {</a>
<a name="ln586">                  ++i;</a>
<a name="ln587">                  continue;</a>
<a name="ln588">                  }</a>
<a name="ln589">            int ni = i;</a>
<a name="ln590">            for (;;) {</a>
<a name="ln591">                  ++ni;</a>
<a name="ln592">                  if (ni == nstaves() || (s-&gt;staff(ni)-&gt;show() &amp;&amp; staff(ni)-&gt;show()))</a>
<a name="ln593">                        break;</a>
<a name="ln594">                  }</a>
<a name="ln595"> </a>
<a name="ln596">            qreal sy2;</a>
<a name="ln597">            if (ni != nstaves()) {</a>
<a name="ln598">                  SysStaff* nstaff = s-&gt;staff(ni);</a>
<a name="ln599">                  qreal s1y2 = stff-&gt;bbox().y() + stff-&gt;bbox().height();</a>
<a name="ln600">                  sy2 = s1y2 + (nstaff-&gt;bbox().y() - s1y2)/2;</a>
<a name="ln601">                  }</a>
<a name="ln602">            else</a>
<a name="ln603">                  sy2 = s-&gt;page()-&gt;height() - s-&gt;pos().y();   // s-&gt;height();</a>
<a name="ln604">            if (y &gt; sy2) {</a>
<a name="ln605">                  i   = ni;</a>
<a name="ln606">                  continue;</a>
<a name="ln607">                  }</a>
<a name="ln608">            break;</a>
<a name="ln609">            }</a>
<a name="ln610"> </a>
<a name="ln611">      // search for segment + offset</a>
<a name="ln612">      QPointF pppp = p - m-&gt;canvasPos();</a>
<a name="ln613">      int strack = i * VOICES;</a>
<a name="ln614">      if (!staff(i))</a>
<a name="ln615">            return 0;</a>
<a name="ln616">//      int etrack = staff(i)-&gt;part()-&gt;nstaves() * VOICES + strack;</a>
<a name="ln617">      int etrack = VOICES + strack;</a>
<a name="ln618"> </a>
<a name="ln619">      SysStaff* sstaff = m-&gt;system()-&gt;staff(i);</a>
<a name="ln620">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln621">      for (Segment* segment = m-&gt;first(st); segment; segment = segment-&gt;next(st)) {</a>
<a name="ln622">            if (!validSegment(segment, strack, etrack))</a>
<a name="ln623">                  continue;</a>
<a name="ln624">            Segment* ns = segment-&gt;next(st);</a>
<a name="ln625">            for (; ns; ns = ns-&gt;next(st)) {</a>
<a name="ln626">                  if (validSegment(ns, strack, etrack))</a>
<a name="ln627">                        break;</a>
<a name="ln628">                  }</a>
<a name="ln629">            if (!ns || (pppp.x() &lt; (segment-&gt;x() + (ns-&gt;x() - segment-&gt;x())/2.0))) {</a>
<a name="ln630">                  *rst = i;</a>
<a name="ln631">                  if (pitch) {</a>
<a name="ln632">                        Staff* s1 = _staves[i];</a>
<a name="ln633">                        Fraction tick  = segment-&gt;tick();</a>
<a name="ln634">                        ClefType clef = s1-&gt;clef(tick);</a>
<a name="ln635">                        *pitch = y2pitch(pppp.y() - sstaff-&gt;bbox().y(), clef, s1-&gt;spatium(tick));</a>
<a name="ln636">                        }</a>
<a name="ln637">                  if (offset)</a>
<a name="ln638">                        *offset = pppp - QPointF(segment-&gt;x(), sstaff-&gt;bbox().y());</a>
<a name="ln639">                  if (seg)</a>
<a name="ln640">                        *seg = segment;</a>
<a name="ln641">                  return m;</a>
<a name="ln642">                  }</a>
<a name="ln643">            }</a>
<a name="ln644">      return 0;</a>
<a name="ln645">      }</a>
<a name="ln646"> </a>
<a name="ln647">//---------------------------------------------------------</a>
<a name="ln648">//   dragPosition</a>
<a name="ln649">//    on input:</a>
<a name="ln650">//          p   - canvas relative drag position</a>
<a name="ln651">//          rst - current staff index</a>
<a name="ln652">//          seg - current segment</a>
<a name="ln653">//    on output:</a>
<a name="ln654">//          rst - new staff index for drag position</a>
<a name="ln655">//          seg - new segment for drag position</a>
<a name="ln656">//---------------------------------------------------------</a>
<a name="ln657"> </a>
<a name="ln658">void Score::dragPosition(const QPointF&amp; p, int* rst, Segment** seg) const</a>
<a name="ln659">      {</a>
<a name="ln660">      Measure* m = searchMeasure(p);</a>
<a name="ln661">      if (m == 0)</a>
<a name="ln662">            return;</a>
<a name="ln663"> </a>
<a name="ln664">      System* s = m-&gt;system();</a>
<a name="ln665">      qreal y   = p.y() - s-&gt;canvasPos().y();</a>
<a name="ln666"> </a>
<a name="ln667">      int i;</a>
<a name="ln668">      for (i = 0; i &lt; nstaves();) {</a>
<a name="ln669">            SysStaff* stff = s-&gt;staff(i);</a>
<a name="ln670">            if (!stff-&gt;show() || !staff(i)-&gt;show()) {</a>
<a name="ln671">                  ++i;</a>
<a name="ln672">                  continue;</a>
<a name="ln673">                  }</a>
<a name="ln674">            int ni = i;</a>
<a name="ln675">            for (;;) {</a>
<a name="ln676">                  ++ni;</a>
<a name="ln677">                  if (ni == nstaves() || (s-&gt;staff(ni)-&gt;show() &amp;&amp; staff(ni)-&gt;show()))</a>
<a name="ln678">                        break;</a>
<a name="ln679">                  }</a>
<a name="ln680"> </a>
<a name="ln681">            qreal sy2;</a>
<a name="ln682">            if (ni != nstaves()) {</a>
<a name="ln683">                  SysStaff* nstaff = s-&gt;staff(ni);</a>
<a name="ln684">                  qreal s1y2       = stff-&gt;bbox().y() + stff-&gt;bbox().height();</a>
<a name="ln685">                  if (i == *rst)</a>
<a name="ln686">                        sy2 = s1y2 + (nstaff-&gt;bbox().y() - s1y2);</a>
<a name="ln687">                  else if (ni == *rst)</a>
<a name="ln688">                        sy2 = s1y2;</a>
<a name="ln689">                  else</a>
<a name="ln690">                        sy2 = s1y2 + (nstaff-&gt;bbox().y() - s1y2) * .5;</a>
<a name="ln691">                  }</a>
<a name="ln692">            else</a>
<a name="ln693">                  sy2 = s-&gt;page()-&gt;height() - s-&gt;pos().y();</a>
<a name="ln694">            if (y &gt; sy2) {</a>
<a name="ln695">                  i   = ni;</a>
<a name="ln696">                  continue;</a>
<a name="ln697">                  }</a>
<a name="ln698">            break;</a>
<a name="ln699">            }</a>
<a name="ln700"> </a>
<a name="ln701">      // search for segment + offset</a>
<a name="ln702">      QPointF pppp = p - m-&gt;canvasPos();</a>
<a name="ln703">      int strack   = i * VOICES;</a>
<a name="ln704">      if (!staff(i))</a>
<a name="ln705">            return;</a>
<a name="ln706">      int etrack = staff(i)-&gt;part()-&gt;nstaves() * VOICES + strack;</a>
<a name="ln707"> </a>
<a name="ln708">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln709">      for (Segment* segment = m-&gt;first(st); segment; segment = segment-&gt;next(st)) {</a>
<a name="ln710">            if (!validSegment(segment, strack, etrack))</a>
<a name="ln711">                  continue;</a>
<a name="ln712">            Segment* ns = segment-&gt;next(st);</a>
<a name="ln713">            for (; ns; ns = ns-&gt;next(st)) {</a>
<a name="ln714">                  if (validSegment(ns, strack, etrack))</a>
<a name="ln715">                        break;</a>
<a name="ln716">                  }</a>
<a name="ln717">            if (!ns) {</a>
<a name="ln718">                  *rst = i;</a>
<a name="ln719">                  *seg = segment;</a>
<a name="ln720">                  return;</a>
<a name="ln721">                  }</a>
<a name="ln722">            if (*seg == segment) {</a>
<a name="ln723">                  if (pppp.x() &lt; (segment-&gt;x() + (ns-&gt;x() - segment-&gt;x()))) {</a>
<a name="ln724">                        *rst = i;</a>
<a name="ln725">                        *seg = segment;</a>
<a name="ln726">                        return;</a>
<a name="ln727">                        }</a>
<a name="ln728">                  }</a>
<a name="ln729">            else if (*seg == ns) {</a>
<a name="ln730">                  if (pppp.x() &lt;= segment-&gt;x()) {</a>
<a name="ln731">                        *rst = i;</a>
<a name="ln732">                        *seg = segment;</a>
<a name="ln733">                        return;</a>
<a name="ln734">                        }</a>
<a name="ln735">                  }</a>
<a name="ln736">            else {</a>
<a name="ln737">                  if (pppp.x() &lt; (segment-&gt;x() + (ns-&gt;x() - segment-&gt;x())/2.0)) {</a>
<a name="ln738">                        *rst = i;</a>
<a name="ln739">                        *seg = segment;</a>
<a name="ln740">                        return;</a>
<a name="ln741">                        }</a>
<a name="ln742">                  }</a>
<a name="ln743">            }</a>
<a name="ln744">      return;</a>
<a name="ln745">      }</a>
<a name="ln746"> </a>
<a name="ln747">//---------------------------------------------------------</a>
<a name="ln748">//   setShowInvisible</a>
<a name="ln749">//---------------------------------------------------------</a>
<a name="ln750"> </a>
<a name="ln751">void Score::setShowInvisible(bool v)</a>
<a name="ln752">      {</a>
<a name="ln753">      _showInvisible = v;</a>
<a name="ln754">      setUpdateAll();</a>
<a name="ln755">      }</a>
<a name="ln756"> </a>
<a name="ln757">//---------------------------------------------------------</a>
<a name="ln758">//   setShowUnprintable</a>
<a name="ln759">//---------------------------------------------------------</a>
<a name="ln760"> </a>
<a name="ln761">void Score::setShowUnprintable(bool v)</a>
<a name="ln762">      {</a>
<a name="ln763">      _showUnprintable = v;</a>
<a name="ln764">      setUpdateAll();</a>
<a name="ln765">      }</a>
<a name="ln766"> </a>
<a name="ln767">//---------------------------------------------------------</a>
<a name="ln768">//   setShowFrames</a>
<a name="ln769">//---------------------------------------------------------</a>
<a name="ln770"> </a>
<a name="ln771">void Score::setShowFrames(bool v)</a>
<a name="ln772">      {</a>
<a name="ln773">      _showFrames = v;</a>
<a name="ln774">      setUpdateAll();</a>
<a name="ln775">      }</a>
<a name="ln776"> </a>
<a name="ln777">//---------------------------------------------------------</a>
<a name="ln778">//   setShowPageborders</a>
<a name="ln779">//---------------------------------------------------------</a>
<a name="ln780"> </a>
<a name="ln781">void Score::setShowPageborders(bool v)</a>
<a name="ln782">      {</a>
<a name="ln783">      _showPageborders = v;</a>
<a name="ln784">      setUpdateAll();</a>
<a name="ln785">      }</a>
<a name="ln786"> </a>
<a name="ln787">//---------------------------------------------------------</a>
<a name="ln788">//   setMarkIrregularMeasures</a>
<a name="ln789">//---------------------------------------------------------</a>
<a name="ln790"> </a>
<a name="ln791">void Score::setMarkIrregularMeasures(bool v)</a>
<a name="ln792">      {</a>
<a name="ln793">      _markIrregularMeasures = v;</a>
<a name="ln794">      setUpdateAll();</a>
<a name="ln795">      }</a>
<a name="ln796"> </a>
<a name="ln797">//---------------------------------------------------------</a>
<a name="ln798">//   readOnly</a>
<a name="ln799">//---------------------------------------------------------</a>
<a name="ln800"> </a>
<a name="ln801">bool Score::readOnly() const</a>
<a name="ln802">      {</a>
<a name="ln803">      return _masterScore-&gt;readOnly();</a>
<a name="ln804">      }</a>
<a name="ln805"> </a>
<a name="ln806">//---------------------------------------------------------</a>
<a name="ln807">//   dirty</a>
<a name="ln808">//---------------------------------------------------------</a>
<a name="ln809"> </a>
<a name="ln810">bool Score::dirty() const</a>
<a name="ln811">      {</a>
<a name="ln812">      return !undoStack()-&gt;isClean();</a>
<a name="ln813">      }</a>
<a name="ln814"> </a>
<a name="ln815">//---------------------------------------------------------</a>
<a name="ln816">//   state</a>
<a name="ln817">//---------------------------------------------------------</a>
<a name="ln818"> </a>
<a name="ln819">ScoreContentState Score::state() const</a>
<a name="ln820">      {</a>
<a name="ln821">      return ScoreContentState(this, undoStack()-&gt;state());</a>
<a name="ln822">      }</a>
<a name="ln823"> </a>
<a name="ln824">//---------------------------------------------------------</a>
<a name="ln825">//   playlistDirty</a>
<a name="ln826">//---------------------------------------------------------</a>
<a name="ln827"> </a>
<a name="ln828">bool Score::playlistDirty() const</a>
<a name="ln829">      {</a>
<a name="ln830">      return masterScore()-&gt;playlistDirty();</a>
<a name="ln831">      }</a>
<a name="ln832"> </a>
<a name="ln833">//---------------------------------------------------------</a>
<a name="ln834">//   setPlaylistDirty</a>
<a name="ln835">//---------------------------------------------------------</a>
<a name="ln836"> </a>
<a name="ln837">void Score::setPlaylistDirty()</a>
<a name="ln838">      {</a>
<a name="ln839">      masterScore()-&gt;setPlaylistDirty();</a>
<a name="ln840">      }</a>
<a name="ln841"> </a>
<a name="ln842">//---------------------------------------------------------</a>
<a name="ln843">//   setPlaylistDirty</a>
<a name="ln844">//---------------------------------------------------------</a>
<a name="ln845"> </a>
<a name="ln846">void MasterScore::setPlaylistDirty()</a>
<a name="ln847">      {</a>
<a name="ln848">      _playlistDirty = true;</a>
<a name="ln849">      _repeatList-&gt;setScoreChanged();</a>
<a name="ln850">      }</a>
<a name="ln851"> </a>
<a name="ln852">//---------------------------------------------------------</a>
<a name="ln853">//   spell</a>
<a name="ln854">//---------------------------------------------------------</a>
<a name="ln855"> </a>
<a name="ln856">void Score::spell()</a>
<a name="ln857">      {</a>
<a name="ln858">      for (int i = 0; i &lt; nstaves(); ++i) {</a>
<a name="ln859">            std::vector&lt;Note*&gt; notes;</a>
<a name="ln860">            for (Segment* s = firstSegment(SegmentType::All); s; s = s-&gt;next1()) {</a>
<a name="ln861">                  int strack = i * VOICES;</a>
<a name="ln862">                  int etrack = strack + VOICES;</a>
<a name="ln863">                  for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln864">                        Element* e = s-&gt;element(track);</a>
<a name="ln865">                        if (e &amp;&amp; e-&gt;type() == ElementType::CHORD)</a>
<a name="ln866">                              notes.insert(notes.end(),</a>
<a name="ln867">                                 toChord(e)-&gt;notes().begin(),</a>
<a name="ln868">                                 toChord(e)-&gt;notes().end());</a>
<a name="ln869">                        }</a>
<a name="ln870">                  }</a>
<a name="ln871">            spellNotelist(notes);</a>
<a name="ln872">            }</a>
<a name="ln873">      }</a>
<a name="ln874"> </a>
<a name="ln875">void Score::spell(int startStaff, int endStaff, Segment* startSegment, Segment* endSegment)</a>
<a name="ln876">      {</a>
<a name="ln877">      for (int i = startStaff; i &lt; endStaff; ++i) {</a>
<a name="ln878">            std::vector&lt;Note*&gt; notes;</a>
<a name="ln879">            for (Segment* s = startSegment; s &amp;&amp; s != endSegment; s = s-&gt;next()) {</a>
<a name="ln880">                  int strack = i * VOICES;</a>
<a name="ln881">                  int etrack = strack + VOICES;</a>
<a name="ln882">                  for (int track = strack; track &lt; etrack; ++track) {</a>
<a name="ln883">                        Element* e = s-&gt;element(track);</a>
<a name="ln884">                        if (e &amp;&amp; e-&gt;type() == ElementType::CHORD)</a>
<a name="ln885">                              notes.insert(notes.end(),</a>
<a name="ln886">                                 toChord(e)-&gt;notes().begin(),</a>
<a name="ln887">                                 toChord(e)-&gt;notes().end());</a>
<a name="ln888">                        }</a>
<a name="ln889">                  }</a>
<a name="ln890">            spellNotelist(notes);</a>
<a name="ln891">            }</a>
<a name="ln892">      }</a>
<a name="ln893"> </a>
<a name="ln894">//---------------------------------------------------------</a>
<a name="ln895">//   prevNote</a>
<a name="ln896">//---------------------------------------------------------</a>
<a name="ln897"> </a>
<a name="ln898">Note* prevNote(Note* n)</a>
<a name="ln899">      {</a>
<a name="ln900">      Chord* chord = n-&gt;chord();</a>
<a name="ln901">      Segment* seg = chord-&gt;segment();</a>
<a name="ln902">      const std::vector&lt;Note*&gt; nl = chord-&gt;notes();</a>
<a name="ln903">      auto i = std::find(nl.begin(), nl.end(), n);</a>
<a name="ln904">      if (i != nl.begin())</a>
<a name="ln905">            return *(i-1);</a>
<a name="ln906">      int staff      = n-&gt;staffIdx();</a>
<a name="ln907">      int startTrack = staff * VOICES + n-&gt;voice() - 1;</a>
<a name="ln908">      int endTrack   = 0;</a>
<a name="ln909">      while (seg) {</a>
<a name="ln910">            if (seg-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln911">                  for (int track = startTrack; track &gt;= endTrack; --track) {</a>
<a name="ln912">                        Element* e = seg-&gt;element(track);</a>
<a name="ln913">                        if (e &amp;&amp; e-&gt;type() == ElementType::CHORD)</a>
<a name="ln914">                              return toChord(e)-&gt;upNote();</a>
<a name="ln915">                        }</a>
<a name="ln916">                  }</a>
<a name="ln917">            seg = seg-&gt;prev1();</a>
<a name="ln918">            startTrack = staff * VOICES + VOICES - 1;</a>
<a name="ln919">            }</a>
<a name="ln920">      return n;</a>
<a name="ln921">      }</a>
<a name="ln922"> </a>
<a name="ln923">//---------------------------------------------------------</a>
<a name="ln924">//   nextNote</a>
<a name="ln925">//---------------------------------------------------------</a>
<a name="ln926"> </a>
<a name="ln927">static Note* nextNote(Note* n)</a>
<a name="ln928">      {</a>
<a name="ln929">      Chord* chord = n-&gt;chord();</a>
<a name="ln930">      const std::vector&lt;Note*&gt; nl = chord-&gt;notes();</a>
<a name="ln931">      auto i = std::find(nl.begin(), nl.end(), n);</a>
<a name="ln932">      if (i != nl.end()) {</a>
<a name="ln933">            ++i;</a>
<a name="ln934">            if (i != nl.end())</a>
<a name="ln935">                  return *i;</a>
<a name="ln936">            }</a>
<a name="ln937">      Segment* seg   = chord-&gt;segment();</a>
<a name="ln938">      int staff      = n-&gt;staffIdx();</a>
<a name="ln939">      int startTrack = staff * VOICES + n-&gt;voice() + 1;</a>
<a name="ln940">      int endTrack   = staff * VOICES + VOICES;</a>
<a name="ln941">      while (seg) {</a>
<a name="ln942">            if (seg-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln943">                  for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln944">                        Element* e = seg-&gt;element(track);</a>
<a name="ln945">                        if (e &amp;&amp; e-&gt;type() == ElementType::CHORD) {</a>
<a name="ln946">                              return ((Chord*)e)-&gt;downNote();</a>
<a name="ln947">                              }</a>
<a name="ln948">                        }</a>
<a name="ln949">                  }</a>
<a name="ln950">            seg = seg-&gt;next1();</a>
<a name="ln951">            startTrack = staff * VOICES;</a>
<a name="ln952">            }</a>
<a name="ln953">      return n;</a>
<a name="ln954">      }</a>
<a name="ln955"> </a>
<a name="ln956">//---------------------------------------------------------</a>
<a name="ln957">//   spell</a>
<a name="ln958">//---------------------------------------------------------</a>
<a name="ln959"> </a>
<a name="ln960">void Score::spell(Note* note)</a>
<a name="ln961">      {</a>
<a name="ln962">      std::vector&lt;Note*&gt; notes;</a>
<a name="ln963"> </a>
<a name="ln964">      notes.push_back(note);</a>
<a name="ln965">      Note* nn = nextNote(note);</a>
<a name="ln966">      notes.push_back(nn);</a>
<a name="ln967">      nn = nextNote(nn);</a>
<a name="ln968">      notes.push_back(nn);</a>
<a name="ln969">      nn = nextNote(nn);</a>
<a name="ln970">      notes.push_back(nn);</a>
<a name="ln971"> </a>
<a name="ln972">      nn = prevNote(note);</a>
<a name="ln973">      notes.insert(notes.begin(), nn);</a>
<a name="ln974">      nn = prevNote(nn);</a>
<a name="ln975">      notes.insert(notes.begin(), nn);</a>
<a name="ln976">      nn = prevNote(nn);</a>
<a name="ln977">      notes.insert(notes.begin(), nn);</a>
<a name="ln978"> </a>
<a name="ln979">      int opt = Ms::computeWindow(notes, 0, 7);</a>
<a name="ln980">      note-&gt;setTpc(Ms::tpc(3, note-&gt;pitch(), opt));</a>
<a name="ln981">      }</a>
<a name="ln982"> </a>
<a name="ln983">//---------------------------------------------------------</a>
<a name="ln984">//   appendPart</a>
<a name="ln985">//---------------------------------------------------------</a>
<a name="ln986"> </a>
<a name="ln987">void Score::appendPart(Part* p)</a>
<a name="ln988">      {</a>
<a name="ln989">      _parts.append(p);</a>
<a name="ln990">      }</a>
<a name="ln991"> </a>
<a name="ln992">//---------------------------------------------------------</a>
<a name="ln993">//   searchPage</a>
<a name="ln994">//    p is in canvas coordinates</a>
<a name="ln995">//---------------------------------------------------------</a>
<a name="ln996"> </a>
<a name="ln997">Page* Score::searchPage(const QPointF&amp; p) const</a>
<a name="ln998">      {</a>
<a name="ln999">      for (Page* page : pages()) {</a>
<a name="ln1000">            QRectF r = page-&gt;bbox().translated(page-&gt;pos());</a>
<a name="ln1001">            if (r.contains(p))</a>
<a name="ln1002">                  return page;</a>
<a name="ln1003">            }</a>
<a name="ln1004">      return 0;</a>
<a name="ln1005">      }</a>
<a name="ln1006"> </a>
<a name="ln1007">//---------------------------------------------------------</a>
<a name="ln1008">//   searchSystem</a>
<a name="ln1009">//    return list of systems as there may be more than</a>
<a name="ln1010">//    one system in a row</a>
<a name="ln1011">//    p is in canvas coordinates</a>
<a name="ln1012">//---------------------------------------------------------</a>
<a name="ln1013"> </a>
<a name="ln1014">QList&lt;System*&gt; Score::searchSystem(const QPointF&amp; pos) const</a>
<a name="ln1015">      {</a>
<a name="ln1016">      QList&lt;System*&gt; systems;</a>
<a name="ln1017">      Page* page = searchPage(pos);</a>
<a name="ln1018">      if (page == 0)</a>
<a name="ln1019">            return systems;</a>
<a name="ln1020">      qreal y = pos.y() - page-&gt;pos().y();  // transform to page relative</a>
<a name="ln1021">      const QList&lt;System*&gt;* sl = &amp;page-&gt;systems();</a>
<a name="ln1022">      qreal y2;</a>
<a name="ln1023">      int n = sl-&gt;size();</a>
<a name="ln1024">      for (int i = 0; i &lt; n; ++i) {</a>
<a name="ln1025">            System* s = sl-&gt;at(i);</a>
<a name="ln1026">            System* ns = 0;               // next system row</a>
<a name="ln1027">            int ii = i + 1;</a>
<a name="ln1028">            for (; ii &lt; n; ++ii) {</a>
<a name="ln1029">                  ns = sl-&gt;at(ii);</a>
<a name="ln1030">                  if (ns-&gt;y() != s-&gt;y())</a>
<a name="ln1031">                        break;</a>
<a name="ln1032">                  }</a>
<a name="ln1033">            if ((ii == n) || (ns == 0))</a>
<a name="ln1034">                  y2 = page-&gt;height();</a>
<a name="ln1035">            else {</a>
<a name="ln1036">                  qreal sy2 = s-&gt;y() + s-&gt;bbox().height();</a>
<a name="ln1037">                  y2         = sy2 + (ns-&gt;y() - sy2) * .5;</a>
<a name="ln1038">                  }</a>
<a name="ln1039">            if (y &lt; y2) {</a>
<a name="ln1040">                  systems.append(s);</a>
<a name="ln1041">                  for (int iii = i+1; ii &lt; n; ++iii) {</a>
<a name="ln1042">                        if (sl-&gt;at(iii)-&gt;y() != s-&gt;y())</a>
<a name="ln1043">                              break;</a>
<a name="ln1044">                        systems.append(sl-&gt;at(iii));</a>
<a name="ln1045">                        }</a>
<a name="ln1046">                  return systems;</a>
<a name="ln1047">                  }</a>
<a name="ln1048">            }</a>
<a name="ln1049">      return systems;</a>
<a name="ln1050">      }</a>
<a name="ln1051"> </a>
<a name="ln1052">//---------------------------------------------------------</a>
<a name="ln1053">//   searchMeasure</a>
<a name="ln1054">//    p is in canvas coordinates</a>
<a name="ln1055">//---------------------------------------------------------</a>
<a name="ln1056"> </a>
<a name="ln1057">Measure* Score::searchMeasure(const QPointF&amp; p) const</a>
<a name="ln1058">      {</a>
<a name="ln1059">      QList&lt;System*&gt; systems = searchSystem(p);</a>
<a name="ln1060">      for (System* system : systems) {</a>
<a name="ln1061">            qreal x = p.x() - system-&gt;canvasPos().x();</a>
<a name="ln1062">            for (MeasureBase* mb : system-&gt;measures()) {</a>
<a name="ln1063">                  if (mb-&gt;isMeasure() &amp;&amp; (x &lt; (mb-&gt;x() + mb-&gt;bbox().width())))</a>
<a name="ln1064">                        return toMeasure(mb);</a>
<a name="ln1065">                  }</a>
<a name="ln1066">            }</a>
<a name="ln1067">      return 0;</a>
<a name="ln1068">      }</a>
<a name="ln1069"> </a>
<a name="ln1070">//---------------------------------------------------------</a>
<a name="ln1071">//    getNextValidInputSegment</a>
<a name="ln1072">//    - s is of type SegmentType::ChordRest</a>
<a name="ln1073">//---------------------------------------------------------</a>
<a name="ln1074"> </a>
<a name="ln1075">static Segment* getNextValidInputSegment(Segment* s, int track, int voice)</a>
<a name="ln1076">      {</a>
<a name="ln1077">      if (s == 0)</a>
<a name="ln1078">            return 0;</a>
<a name="ln1079">      Q_ASSERT(s-&gt;segmentType() == SegmentType::ChordRest);</a>
<a name="ln1080">      // Segment* s1 = s;</a>
<a name="ln1081">      ChordRest* cr1 = nullptr;</a>
<a name="ln1082">      for (Segment* s1 = s; s1; s1 = s1-&gt;prev(SegmentType::ChordRest)) {</a>
<a name="ln1083">            cr1 = toChordRest(s1-&gt;element(track + voice));</a>
<a name="ln1084">            if (cr1)</a>
<a name="ln1085">                  break;</a>
<a name="ln1086">            }</a>
<a name="ln1087">      Fraction nextTick = (cr1 == nullptr) ? s-&gt;measure()-&gt;tick() : cr1-&gt;tick() + cr1-&gt;actualTicks();</a>
<a name="ln1088"> </a>
<a name="ln1089">      static const SegmentType st { SegmentType::ChordRest };</a>
<a name="ln1090">      while (s) {</a>
<a name="ln1091">            if (s-&gt;element(track + voice))</a>
<a name="ln1092">                  break;</a>
<a name="ln1093">            if (voice &amp;&amp; s-&gt;tick() == nextTick)</a>
<a name="ln1094">                  return s;</a>
<a name="ln1095">#if 0</a>
<a name="ln1096">            int v;</a>
<a name="ln1097">            for (v = 0; v &lt; VOICES; ++v) {</a>
<a name="ln1098">                  if (s-&gt;element(track + v))</a>
<a name="ln1099">                        break;</a>
<a name="ln1100">                  }</a>
<a name="ln1101">            if ((v != VOICES) &amp;&amp; voice) {</a>
<a name="ln1102">                  int ntick;</a>
<a name="ln1103">                  bool skipChord = false;</a>
<a name="ln1104">                  bool ns        = false;</a>
<a name="ln1105">                  for (Segment* s1 = s-&gt;measure()-&gt;first(st); s1; s1 = s1-&gt;next(st)) {</a>
<a name="ln1106">                        ChordRest* cr = toChordRest(s1-&gt;element(track + voice));</a>
<a name="ln1107">                        if (cr) {</a>
<a name="ln1108">                              if (ns)</a>
<a name="ln1109">                                    return s1;</a>
<a name="ln1110">                              ntick = s1-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln1111">                              skipChord = true;</a>
<a name="ln1112">                              }</a>
<a name="ln1113">                        if (s1 == s)</a>
<a name="ln1114">                              ns = true;</a>
<a name="ln1115">                        if (skipChord) {</a>
<a name="ln1116">                              if (s-&gt;tick() &gt;= ntick)</a>
<a name="ln1117">                                    skipChord = false;</a>
<a name="ln1118">                              }</a>
<a name="ln1119">                        if (!skipChord &amp;&amp; ns)</a>
<a name="ln1120">                              return s1;</a>
<a name="ln1121">                        }</a>
<a name="ln1122">                  if (!skipChord)</a>
<a name="ln1123">                        return s;</a>
<a name="ln1124">                  }</a>
<a name="ln1125">#endif</a>
<a name="ln1126">            s = s-&gt;next(st);</a>
<a name="ln1127">            }</a>
<a name="ln1128">      return s;</a>
<a name="ln1129">      }</a>
<a name="ln1130"> </a>
<a name="ln1131">//---------------------------------------------------------</a>
<a name="ln1132">//   getPosition</a>
<a name="ln1133">//    return true if valid position found</a>
<a name="ln1134">//---------------------------------------------------------</a>
<a name="ln1135"> </a>
<a name="ln1136">bool Score::getPosition(Position* pos, const QPointF&amp; p, int voice) const</a>
<a name="ln1137">      {</a>
<a name="ln1138">      Measure* measure = searchMeasure(p);</a>
<a name="ln1139">      if (measure == 0)</a>
<a name="ln1140">            return false;</a>
<a name="ln1141"> </a>
<a name="ln1142">      pos-&gt;fret = FRET_NONE;</a>
<a name="ln1143">      //</a>
<a name="ln1144">      //    search staff</a>
<a name="ln1145">      //</a>
<a name="ln1146">      pos-&gt;staffIdx      = 0;</a>
<a name="ln1147">      SysStaff* sstaff   = 0;</a>
<a name="ln1148">      System* system     = measure-&gt;system();</a>
<a name="ln1149">      qreal y           = p.y() - system-&gt;pagePos().y();</a>
<a name="ln1150">      for (; pos-&gt;staffIdx &lt; nstaves(); ++pos-&gt;staffIdx) {</a>
<a name="ln1151">            Staff* st = staff(pos-&gt;staffIdx);</a>
<a name="ln1152">            if (!st-&gt;part()-&gt;show())</a>
<a name="ln1153">                  continue;</a>
<a name="ln1154">            qreal sy2;</a>
<a name="ln1155">            SysStaff* ss = system-&gt;staff(pos-&gt;staffIdx);</a>
<a name="ln1156">            if (!ss-&gt;show())</a>
<a name="ln1157">                  continue;</a>
<a name="ln1158">            SysStaff* nstaff = 0;</a>
<a name="ln1159"> </a>
<a name="ln1160">            // find next visible staff</a>
<a name="ln1161">            for (int i = pos-&gt;staffIdx + 1; i &lt; nstaves(); ++i) {</a>
<a name="ln1162">                  Staff* sti = staff(i);</a>
<a name="ln1163">                  if (!sti-&gt;part()-&gt;show())</a>
<a name="ln1164">                        continue;</a>
<a name="ln1165">                  nstaff = system-&gt;staff(i);</a>
<a name="ln1166">                  if (!nstaff-&gt;show()) {</a>
<a name="ln1167">                        nstaff = 0;</a>
<a name="ln1168">                        continue;</a>
<a name="ln1169">                        }</a>
<a name="ln1170">                  break;</a>
<a name="ln1171">                  }</a>
<a name="ln1172"> </a>
<a name="ln1173">            if (nstaff) {</a>
<a name="ln1174">                  qreal s1y2 = ss-&gt;bbox().bottom();</a>
<a name="ln1175">                  sy2        = system-&gt;page()-&gt;canvasPos().y() + s1y2 + (nstaff-&gt;bbox().y() - s1y2) * .5;</a>
<a name="ln1176">                  }</a>
<a name="ln1177">            else</a>
<a name="ln1178">                  sy2 = system-&gt;page()-&gt;canvasPos().y() + system-&gt;page()-&gt;height() - system-&gt;pagePos().y();   // system-&gt;height();</a>
<a name="ln1179">            if (y &lt; sy2) {</a>
<a name="ln1180">                  sstaff = ss;</a>
<a name="ln1181">                  break;</a>
<a name="ln1182">                  }</a>
<a name="ln1183">            }</a>
<a name="ln1184">      if (sstaff == 0)</a>
<a name="ln1185">            return false;</a>
<a name="ln1186"> </a>
<a name="ln1187">      //</a>
<a name="ln1188">      //    search segment</a>
<a name="ln1189">      //</a>
<a name="ln1190">      QPointF pppp(p - measure-&gt;canvasPos());</a>
<a name="ln1191">      qreal x         = pppp.x();</a>
<a name="ln1192">      Segment* segment = 0;</a>
<a name="ln1193">      pos-&gt;segment     = 0;</a>
<a name="ln1194"> </a>
<a name="ln1195">      // int track = pos-&gt;staffIdx * VOICES + voice;</a>
<a name="ln1196">      int track = pos-&gt;staffIdx * VOICES;</a>
<a name="ln1197"> </a>
<a name="ln1198">      for (segment = measure-&gt;first(SegmentType::ChordRest); segment;) {</a>
<a name="ln1199">            segment = getNextValidInputSegment(segment, track, voice);</a>
<a name="ln1200">            if (segment == 0)</a>
<a name="ln1201">                  break;</a>
<a name="ln1202">            Segment* ns = getNextValidInputSegment(segment-&gt;next(SegmentType::ChordRest), track, voice);</a>
<a name="ln1203"> </a>
<a name="ln1204">            qreal x1 = segment-&gt;x();</a>
<a name="ln1205">            qreal x2;</a>
<a name="ln1206">            qreal d;</a>
<a name="ln1207">            if (ns) {</a>
<a name="ln1208">                  x2    = ns-&gt;x();</a>
<a name="ln1209">                  d     = x2 - x1;</a>
<a name="ln1210">                  }</a>
<a name="ln1211">            else {</a>
<a name="ln1212">                  x2    = measure-&gt;bbox().width();</a>
<a name="ln1213">                  d     = (x2 - x1) * 2.0;</a>
<a name="ln1214">                  x     = x1;</a>
<a name="ln1215">                  pos-&gt;segment = segment;</a>
<a name="ln1216">                  break;</a>
<a name="ln1217">                  }</a>
<a name="ln1218"> </a>
<a name="ln1219">            if (x &lt; (x1 + d * .5)) {</a>
<a name="ln1220">                  x = x1;</a>
<a name="ln1221">                  pos-&gt;segment = segment;</a>
<a name="ln1222">                  break;</a>
<a name="ln1223">                  }</a>
<a name="ln1224">            segment = ns;</a>
<a name="ln1225">            }</a>
<a name="ln1226">      if (segment == 0)</a>
<a name="ln1227">            return false;</a>
<a name="ln1228">      //</a>
<a name="ln1229">      // TODO: restrict to reasonable values (pitch 0-127)</a>
<a name="ln1230">      //</a>
<a name="ln1231">      Staff* s      = staff(pos-&gt;staffIdx);</a>
<a name="ln1232">      qreal mag     = s-&gt;mag(segment-&gt;tick());</a>
<a name="ln1233">      Fraction tick = segment-&gt;tick();</a>
<a name="ln1234">      // in TABs, step from one string to another; in other staves, step on and between lines</a>
<a name="ln1235">      qreal lineDist = s-&gt;staffType(tick)-&gt;lineDistance().val() * (s-&gt;isTabStaff(measure-&gt;tick()) ? 1 : .5) * mag * spatium();</a>
<a name="ln1236"> </a>
<a name="ln1237">      pos-&gt;line  = lrint((pppp.y() - sstaff-&gt;bbox().y()) / lineDist);</a>
<a name="ln1238">      if (s-&gt;isTabStaff(measure-&gt;tick())) {</a>
<a name="ln1239">            if (pos-&gt;line &lt; -1 || pos-&gt;line &gt; s-&gt;lines(tick)+1)</a>
<a name="ln1240">                  return false;</a>
<a name="ln1241">            if (pos-&gt;line &lt; 0)</a>
<a name="ln1242">                  pos-&gt;line = 0;</a>
<a name="ln1243">            else if (pos-&gt;line &gt;= s-&gt;lines(tick))</a>
<a name="ln1244">                  pos-&gt;line = s-&gt;lines(tick) - 1;</a>
<a name="ln1245">            }</a>
<a name="ln1246">      else {</a>
<a name="ln1247">            int minLine   = absStep(0);</a>
<a name="ln1248">            ClefType clef = s-&gt;clef(pos-&gt;segment-&gt;tick());</a>
<a name="ln1249">            minLine       = relStep(minLine, clef);</a>
<a name="ln1250">            int maxLine   = absStep(127);</a>
<a name="ln1251">            maxLine       = relStep(maxLine, clef);</a>
<a name="ln1252"> </a>
<a name="ln1253">            if (pos-&gt;line &gt; minLine || pos-&gt;line &lt; maxLine)</a>
<a name="ln1254">                  return false;</a>
<a name="ln1255">            }</a>
<a name="ln1256"> </a>
<a name="ln1257">      y         = sstaff-&gt;y() + pos-&gt;line * lineDist;</a>
<a name="ln1258">      pos-&gt;pos  = QPointF(x, y) + measure-&gt;canvasPos();</a>
<a name="ln1259">      return true;</a>
<a name="ln1260">      }</a>
<a name="ln1261"> </a>
<a name="ln1262">//---------------------------------------------------------</a>
<a name="ln1263">//   checkHasMeasures</a>
<a name="ln1264">//---------------------------------------------------------</a>
<a name="ln1265"> </a>
<a name="ln1266">bool Score::checkHasMeasures() const</a>
<a name="ln1267">      {</a>
<a name="ln1268">      Page* page = pages().isEmpty() ? 0 : pages().front();</a>
<a name="ln1269">      const QList&lt;System*&gt;* sl = page ? &amp;page-&gt;systems() : 0;</a>
<a name="ln1270">      if (sl == 0 || sl-&gt;empty() || sl-&gt;front()-&gt;measures().empty()) {</a>
<a name="ln1271">            qDebug(&quot;first create measure, then repeat operation&quot;);</a>
<a name="ln1272">            return false;</a>
<a name="ln1273">            }</a>
<a name="ln1274">      return true;</a>
<a name="ln1275">      }</a>
<a name="ln1276"> </a>
<a name="ln1277">#if 0</a>
<a name="ln1278">//---------------------------------------------------------</a>
<a name="ln1279">//   moveBracket</a>
<a name="ln1280">//    columns are counted from right to left</a>
<a name="ln1281">//---------------------------------------------------------</a>
<a name="ln1282"> </a>
<a name="ln1283">void Score::moveBracket(int staffIdx, int srcCol, int dstCol)</a>
<a name="ln1284">      {</a>
<a name="ln1285">      for (System* system : systems())</a>
<a name="ln1286">            system-&gt;moveBracket(staffIdx, srcCol, dstCol);</a>
<a name="ln1287">      }</a>
<a name="ln1288">#endif</a>
<a name="ln1289"> </a>
<a name="ln1290">//---------------------------------------------------------</a>
<a name="ln1291">//   spatiumHasChanged</a>
<a name="ln1292">//---------------------------------------------------------</a>
<a name="ln1293"> </a>
<a name="ln1294">static void spatiumHasChanged(void* data, Element* e)</a>
<a name="ln1295">      {</a>
<a name="ln1296">      qreal* val = (qreal*)data;</a>
<a name="ln1297">      e-&gt;spatiumChanged(val[0], val[1]);</a>
<a name="ln1298">      }</a>
<a name="ln1299"> </a>
<a name="ln1300">//---------------------------------------------------------</a>
<a name="ln1301">//   spatiumChanged</a>
<a name="ln1302">//---------------------------------------------------------</a>
<a name="ln1303"> </a>
<a name="ln1304">void Score::spatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln1305">      {</a>
<a name="ln1306">      qreal data[2];</a>
<a name="ln1307">      data[0] = oldValue;</a>
<a name="ln1308">      data[1] = newValue;</a>
<a name="ln1309">      scanElements(data, spatiumHasChanged, true);</a>
<a name="ln1310">      for (Staff* staff : _staves)</a>
<a name="ln1311">            staff-&gt;spatiumChanged(oldValue, newValue);</a>
<a name="ln1312">      _noteHeadWidth = _scoreFont-&gt;width(SymId::noteheadBlack, newValue / SPATIUM20);</a>
<a name="ln1313">      }</a>
<a name="ln1314"> </a>
<a name="ln1315">//---------------------------------------------------------</a>
<a name="ln1316">//   updateStyle</a>
<a name="ln1317">//---------------------------------------------------------</a>
<a name="ln1318"> </a>
<a name="ln1319">static void updateStyle(void*, Element* e)</a>
<a name="ln1320">      {</a>
<a name="ln1321">      bool v = e-&gt;generated();</a>
<a name="ln1322">      e-&gt;styleChanged();</a>
<a name="ln1323">      e-&gt;setGenerated(v);</a>
<a name="ln1324">      }</a>
<a name="ln1325"> </a>
<a name="ln1326">//---------------------------------------------------------</a>
<a name="ln1327">//   styleChanged</a>
<a name="ln1328">//    must be called after every style change</a>
<a name="ln1329">//---------------------------------------------------------</a>
<a name="ln1330"> </a>
<a name="ln1331">void Score::styleChanged()</a>
<a name="ln1332">      {</a>
<a name="ln1333">      scanElements(0, updateStyle);</a>
<a name="ln1334">      if (headerText())</a>
<a name="ln1335">            headerText()-&gt;styleChanged();</a>
<a name="ln1336">      if (footerText())</a>
<a name="ln1337">            footerText()-&gt;styleChanged();</a>
<a name="ln1338">      setLayoutAll();</a>
<a name="ln1339">      }</a>
<a name="ln1340"> </a>
<a name="ln1341">//---------------------------------------------------------</a>
<a name="ln1342">//   getCreateMeasure</a>
<a name="ln1343">//    - return Measure for tick</a>
<a name="ln1344">//    - create new Measure(s) if there is no measure for</a>
<a name="ln1345">//      this tick</a>
<a name="ln1346">//---------------------------------------------------------</a>
<a name="ln1347"> </a>
<a name="ln1348">Measure* Score::getCreateMeasure(const Fraction&amp; tick)</a>
<a name="ln1349">      {</a>
<a name="ln1350">      Measure* last = lastMeasure();</a>
<a name="ln1351">      if (last == 0 || ((last-&gt;tick() + last-&gt;ticks()) &lt;= tick)) {</a>
<a name="ln1352">            Fraction lastTick  = last ? (last-&gt;tick()+last-&gt;ticks()) : Fraction(0,1);</a>
<a name="ln1353">            while (tick &gt;= lastTick) {</a>
<a name="ln1354">                  Measure* m = new Measure(this);</a>
<a name="ln1355">                  Fraction ts = sigmap()-&gt;timesig(lastTick).timesig();</a>
<a name="ln1356">                  m-&gt;setTick(lastTick);</a>
<a name="ln1357">                  m-&gt;setTimesig(ts);</a>
<a name="ln1358">                  m-&gt;setTicks(ts);</a>
<a name="ln1359">                  measures()-&gt;add(toMeasureBase(m));</a>
<a name="ln1360">                  lastTick += Fraction::fromTicks(ts.ticks());</a>
<a name="ln1361">                  }</a>
<a name="ln1362">            }</a>
<a name="ln1363">      return tick2measure(tick);</a>
<a name="ln1364">      }</a>
<a name="ln1365"> </a>
<a name="ln1366">//---------------------------------------------------------</a>
<a name="ln1367">//   addElement</a>
<a name="ln1368">//---------------------------------------------------------</a>
<a name="ln1369"> </a>
<a name="ln1370">/**</a>
<a name="ln1371"> Add \a element to its parent.</a>
<a name="ln1372"> </a>
<a name="ln1373"> Several elements (clef, keysig, timesig) need special handling, as they may cause</a>
<a name="ln1374"> changes throughout the score.</a>
<a name="ln1375">*/</a>
<a name="ln1376"> </a>
<a name="ln1377">void Score::addElement(Element* element)</a>
<a name="ln1378">      {</a>
<a name="ln1379">      Element* parent = element-&gt;parent();</a>
<a name="ln1380">      element-&gt;triggerLayout();</a>
<a name="ln1381"> </a>
<a name="ln1382">//      qDebug(&quot;Score(%p) Element(%p)(%s) parent %p(%s)&quot;,</a>
<a name="ln1383">//         this, element, element-&gt;name(), parent, parent ? parent-&gt;name() : &quot;&quot;);</a>
<a name="ln1384"> </a>
<a name="ln1385">      ElementType et = element-&gt;type();</a>
<a name="ln1386">      if (et == ElementType::MEASURE</a>
<a name="ln1387">         || (et == ElementType::HBOX &amp;&amp; !(parent &amp;&amp; parent-&gt;isVBox()))</a>
<a name="ln1388">         || et == ElementType::VBOX</a>
<a name="ln1389">         || et == ElementType::TBOX</a>
<a name="ln1390">         || et == ElementType::FBOX</a>
<a name="ln1391">         ) {</a>
<a name="ln1392">            measures()-&gt;add(toMeasureBase(element));</a>
<a name="ln1393">            element-&gt;triggerLayout();</a>
<a name="ln1394">            return;</a>
<a name="ln1395">            }</a>
<a name="ln1396"> </a>
<a name="ln1397">      if (parent)</a>
<a name="ln1398">            parent-&gt;add(element);</a>
<a name="ln1399"> </a>
<a name="ln1400">      switch (et) {</a>
<a name="ln1401">            case ElementType::BEAM:</a>
<a name="ln1402">                  {</a>
<a name="ln1403">                  Beam* b = toBeam(element);</a>
<a name="ln1404">                  int n = b-&gt;elements().size();</a>
<a name="ln1405">                  for (int i = 0; i &lt; n; ++i)</a>
<a name="ln1406">                        b-&gt;elements().at(i)-&gt;setBeam(b);</a>
<a name="ln1407">                  }</a>
<a name="ln1408">                  break;</a>
<a name="ln1409"> </a>
<a name="ln1410">            case ElementType::SLUR:</a>
<a name="ln1411">                  addLayoutFlags(LayoutFlag::PLAY_EVENTS);</a>
<a name="ln1412">                  // fall through</a>
<a name="ln1413"> </a>
<a name="ln1414">            case ElementType::VOLTA:</a>
<a name="ln1415">            case ElementType::TRILL:</a>
<a name="ln1416">            case ElementType::VIBRATO:</a>
<a name="ln1417">            case ElementType::PEDAL:</a>
<a name="ln1418">            case ElementType::TEXTLINE:</a>
<a name="ln1419">            case ElementType::HAIRPIN:</a>
<a name="ln1420">            case ElementType::LET_RING:</a>
<a name="ln1421">            case ElementType::PALM_MUTE:</a>
<a name="ln1422">                  {</a>
<a name="ln1423">                  Spanner* spanner = toSpanner(element);</a>
<a name="ln1424">                  if (et == ElementType::TEXTLINE &amp;&amp; spanner-&gt;anchor() == Spanner::Anchor::NOTE)</a>
<a name="ln1425">                        break;</a>
<a name="ln1426">                  addSpanner(spanner);</a>
<a name="ln1427">                  for (SpannerSegment* ss : spanner-&gt;spannerSegments()) {</a>
<a name="ln1428">                        if (ss-&gt;system())</a>
<a name="ln1429">                              ss-&gt;system()-&gt;add(ss);</a>
<a name="ln1430">                        }</a>
<a name="ln1431">                  }</a>
<a name="ln1432">                  break;</a>
<a name="ln1433"> </a>
<a name="ln1434">            case ElementType::OTTAVA:</a>
<a name="ln1435">                  {</a>
<a name="ln1436">                  Ottava* o = toOttava(element);</a>
<a name="ln1437">                  addSpanner(o);</a>
<a name="ln1438">                  foreach(SpannerSegment* ss, o-&gt;spannerSegments()) {</a>
<a name="ln1439">                        if (ss-&gt;system())</a>
<a name="ln1440">                              ss-&gt;system()-&gt;add(ss);</a>
<a name="ln1441">                        }</a>
<a name="ln1442">                  cmdState().layoutFlags |= LayoutFlag::FIX_PITCH_VELO;</a>
<a name="ln1443">                  o-&gt;staff()-&gt;updateOttava();</a>
<a name="ln1444">                  setPlaylistDirty();</a>
<a name="ln1445">                  }</a>
<a name="ln1446">                  break;</a>
<a name="ln1447"> </a>
<a name="ln1448">            case ElementType::DYNAMIC:</a>
<a name="ln1449">                  cmdState().layoutFlags |= LayoutFlag::FIX_PITCH_VELO;</a>
<a name="ln1450">                  setPlaylistDirty();</a>
<a name="ln1451">                  break;</a>
<a name="ln1452"> </a>
<a name="ln1453">            case ElementType::TEMPO_TEXT:</a>
<a name="ln1454">                  fixTicks(); // rebuilds tempomap</a>
<a name="ln1455">                  break;</a>
<a name="ln1456"> </a>
<a name="ln1457">            case ElementType::INSTRUMENT_CHANGE: {</a>
<a name="ln1458">                  InstrumentChange* ic = toInstrumentChange(element);</a>
<a name="ln1459">                  ic-&gt;part()-&gt;setInstrument(ic-&gt;instrument(), ic-&gt;segment()-&gt;tick());</a>
<a name="ln1460">#if 0</a>
<a name="ln1461">                  int tickStart = ic-&gt;segment()-&gt;tick();</a>
<a name="ln1462">                  auto i = ic-&gt;part()-&gt;instruments()-&gt;upper_bound(tickStart);</a>
<a name="ln1463">                  int tickEnd;</a>
<a name="ln1464">                  if (i == ic-&gt;part()-&gt;instruments()-&gt;end())</a>
<a name="ln1465">                        tickEnd = -1;</a>
<a name="ln1466">                  else</a>
<a name="ln1467">                        tickEnd = i-&gt;first;</a>
<a name="ln1468">                  Interval oldV = ic-&gt;part()-&gt;instrument(tickStart)-&gt;transpose();</a>
<a name="ln1469">                  ic-&gt;part()-&gt;setInstrument(ic-&gt;instrument(), tickStart);</a>
<a name="ln1470">                  transpositionChanged(ic-&gt;part(), oldV, tickStart, tickEnd);</a>
<a name="ln1471">#endif</a>
<a name="ln1472">                  addLayoutFlags(LayoutFlag::REBUILD_MIDI_MAPPING);</a>
<a name="ln1473">                  cmdState()._instrumentsChanged = true;</a>
<a name="ln1474">                  }</a>
<a name="ln1475">                  break;</a>
<a name="ln1476"> </a>
<a name="ln1477">            case ElementType::CHORD:</a>
<a name="ln1478">                  setPlaylistDirty();</a>
<a name="ln1479">                  // create playlist does not work here bc. tremolos may not be complete</a>
<a name="ln1480">                  // createPlayEvents(toChord(element));</a>
<a name="ln1481">                  break;</a>
<a name="ln1482"> </a>
<a name="ln1483">            case ElementType::NOTE:</a>
<a name="ln1484">            case ElementType::TREMOLO:</a>
<a name="ln1485">            case ElementType::ARTICULATION:</a>
<a name="ln1486">            case ElementType::ARPEGGIO:</a>
<a name="ln1487">                  {</a>
<a name="ln1488">                  Element* cr = parent;</a>
<a name="ln1489">                  if (cr-&gt;isChord())</a>
<a name="ln1490">                        createPlayEvents(toChord(cr));</a>
<a name="ln1491">                  }</a>
<a name="ln1492">                  break;</a>
<a name="ln1493"> </a>
<a name="ln1494">            default:</a>
<a name="ln1495">                  break;</a>
<a name="ln1496">            }</a>
<a name="ln1497">      element-&gt;triggerLayout();</a>
<a name="ln1498">      }</a>
<a name="ln1499"> </a>
<a name="ln1500">//---------------------------------------------------------</a>
<a name="ln1501">//   removeElement</a>
<a name="ln1502">///   Remove \a element from its parent.</a>
<a name="ln1503">///   Several elements (clef, keysig, timesig) need special handling, as they may cause</a>
<a name="ln1504">///   changes throughout the score.</a>
<a name="ln1505">//---------------------------------------------------------</a>
<a name="ln1506"> </a>
<a name="ln1507">void Score::removeElement(Element* element)</a>
<a name="ln1508">      {</a>
<a name="ln1509">      Element* parent = element-&gt;parent();</a>
<a name="ln1510">      element-&gt;triggerLayout();</a>
<a name="ln1511"> </a>
<a name="ln1512">//      qDebug(&quot;Score(%p) Element(%p)(%s) parent %p(%s)&quot;,</a>
<a name="ln1513">//         this, element, element-&gt;name(), parent, parent ? parent-&gt;name() : &quot;&quot;);</a>
<a name="ln1514"> </a>
<a name="ln1515">      // special for MEASURE, HBOX, VBOX</a>
<a name="ln1516">      // their parent is not static</a>
<a name="ln1517"> </a>
<a name="ln1518">      ElementType et = element-&gt;type();</a>
<a name="ln1519"> </a>
<a name="ln1520">      if (et == ElementType::MEASURE</a>
<a name="ln1521">         || (et == ElementType::HBOX &amp;&amp; !parent-&gt;isVBox())</a>
<a name="ln1522">         || et == ElementType::VBOX</a>
<a name="ln1523">         || et == ElementType::TBOX</a>
<a name="ln1524">         || et == ElementType::FBOX</a>
<a name="ln1525">            ) {</a>
<a name="ln1526">            MeasureBase* mb = toMeasureBase(element);</a>
<a name="ln1527">            measures()-&gt;remove(mb);</a>
<a name="ln1528">            System* system = mb-&gt;system();</a>
<a name="ln1529"> </a>
<a name="ln1530">            if (!system) { // vertical boxes are not shown in continuous view so no system</a>
<a name="ln1531">                  Q_ASSERT(lineMode() &amp;&amp; (element-&gt;isVBox() || element-&gt;isTBox()));</a>
<a name="ln1532">                  return;</a>
<a name="ln1533">                  }</a>
<a name="ln1534"> </a>
<a name="ln1535">            Page* page = system-&gt;page();</a>
<a name="ln1536">            if (element-&gt;isBox() &amp;&amp; system-&gt;measures().size() == 1) {</a>
<a name="ln1537">                  auto i = std::find(page-&gt;systems().begin(), page-&gt;systems().end(), system);</a>
<a name="ln1538">                  page-&gt;systems().erase(i);</a>
<a name="ln1539">                  mb-&gt;setSystem(0);</a>
<a name="ln1540">                  if (page-&gt;systems().isEmpty()) {</a>
<a name="ln1541">                        // Remove this page, since it is now empty.</a>
<a name="ln1542">                        // This involves renumbering and repositioning all subsequent pages.</a>
<a name="ln1543">                        QPointF pos = page-&gt;pos();</a>
<a name="ln1544">                        auto ii = std::find(pages().begin(), pages().end(), page);</a>
<a name="ln1545">                        pages().erase(ii);</a>
<a name="ln1546">                        while (ii != pages().end()) {</a>
<a name="ln1547">                              page = *ii;</a>
<a name="ln1548">                              page-&gt;setNo(page-&gt;no() - 1);</a>
<a name="ln1549">                              QPointF p = page-&gt;pos();</a>
<a name="ln1550">                              page-&gt;setPos(pos);</a>
<a name="ln1551">                              pos = p;</a>
<a name="ln1552">                              ii++;</a>
<a name="ln1553">                              }</a>
<a name="ln1554">                        }</a>
<a name="ln1555">                  }</a>
<a name="ln1556">//            setLayout(mb-&gt;tick());</a>
<a name="ln1557">            return;</a>
<a name="ln1558">            }</a>
<a name="ln1559"> </a>
<a name="ln1560">      if (et == ElementType::BEAM) {          // beam parent does not survive layout</a>
<a name="ln1561">            element-&gt;setParent(0);</a>
<a name="ln1562">            parent = 0;</a>
<a name="ln1563">            }</a>
<a name="ln1564"> </a>
<a name="ln1565">      if (parent)</a>
<a name="ln1566">            parent-&gt;remove(element);</a>
<a name="ln1567"> </a>
<a name="ln1568">      switch (et) {</a>
<a name="ln1569">            case ElementType::BEAM:</a>
<a name="ln1570">                  for (ChordRest* cr : toBeam(element)-&gt;elements())</a>
<a name="ln1571">                        cr-&gt;setBeam(0);</a>
<a name="ln1572">                  break;</a>
<a name="ln1573"> </a>
<a name="ln1574">            case ElementType::SLUR:</a>
<a name="ln1575">                  addLayoutFlags(LayoutFlag::PLAY_EVENTS);</a>
<a name="ln1576">                  // fall through</a>
<a name="ln1577"> </a>
<a name="ln1578">            case ElementType::VOLTA:</a>
<a name="ln1579">            case ElementType::TRILL:</a>
<a name="ln1580">            case ElementType::VIBRATO:</a>
<a name="ln1581">            case ElementType::PEDAL:</a>
<a name="ln1582">            case ElementType::LET_RING:</a>
<a name="ln1583">            case ElementType::PALM_MUTE:</a>
<a name="ln1584">            case ElementType::TEXTLINE:</a>
<a name="ln1585">            case ElementType::HAIRPIN:</a>
<a name="ln1586">                  {</a>
<a name="ln1587">                  Spanner* spanner = toSpanner(element);</a>
<a name="ln1588">                  if (et == ElementType::TEXTLINE &amp;&amp; spanner-&gt;anchor() == Spanner::Anchor::NOTE)</a>
<a name="ln1589">                        break;</a>
<a name="ln1590">                  spanner-&gt;triggerLayout();</a>
<a name="ln1591">                  removeSpanner(spanner);</a>
<a name="ln1592">                  }</a>
<a name="ln1593">                  break;</a>
<a name="ln1594"> </a>
<a name="ln1595">            case ElementType::OTTAVA:</a>
<a name="ln1596">                  {</a>
<a name="ln1597">                  Ottava* o = toOttava(element);</a>
<a name="ln1598">                  o-&gt;triggerLayout();</a>
<a name="ln1599">                  removeSpanner(o);</a>
<a name="ln1600">                  o-&gt;staff()-&gt;updateOttava();</a>
<a name="ln1601">                  cmdState().layoutFlags |= LayoutFlag::FIX_PITCH_VELO;</a>
<a name="ln1602">                  setPlaylistDirty();</a>
<a name="ln1603">                  }</a>
<a name="ln1604">                  break;</a>
<a name="ln1605"> </a>
<a name="ln1606">            case ElementType::DYNAMIC:</a>
<a name="ln1607">                  cmdState().layoutFlags |= LayoutFlag::FIX_PITCH_VELO;</a>
<a name="ln1608">                  setPlaylistDirty();</a>
<a name="ln1609">                  break;</a>
<a name="ln1610"> </a>
<a name="ln1611">            case ElementType::CHORD:</a>
<a name="ln1612">            case ElementType::REST:</a>
<a name="ln1613">                  {</a>
<a name="ln1614">                  ChordRest* cr = toChordRest(element);</a>
<a name="ln1615">                  if (cr-&gt;beam())</a>
<a name="ln1616">                        cr-&gt;beam()-&gt;remove(cr);</a>
<a name="ln1617">                  for (Lyrics* lyr : cr-&gt;lyrics())</a>
<a name="ln1618">                        lyr-&gt;removeFromScore();</a>
<a name="ln1619">                  // TODO: check for tuplet?</a>
<a name="ln1620">                  }</a>
<a name="ln1621">                  break;</a>
<a name="ln1622">            case ElementType::TEMPO_TEXT:</a>
<a name="ln1623">                  fixTicks(); // rebuilds tempomap</a>
<a name="ln1624">                  break;</a>
<a name="ln1625">            case ElementType::INSTRUMENT_CHANGE: {</a>
<a name="ln1626">                  InstrumentChange* ic = toInstrumentChange(element);</a>
<a name="ln1627">                  ic-&gt;part()-&gt;removeInstrument(ic-&gt;segment()-&gt;tick());</a>
<a name="ln1628">#if 0</a>
<a name="ln1629">                  int tickStart = ic-&gt;segment()-&gt;tick();</a>
<a name="ln1630">                  auto i = ic-&gt;part()-&gt;instruments()-&gt;upper_bound(tickStart);</a>
<a name="ln1631">                  int tickEnd;</a>
<a name="ln1632">                  if (i == ic-&gt;part()-&gt;instruments()-&gt;end())</a>
<a name="ln1633">                        tickEnd = -1;</a>
<a name="ln1634">                  else</a>
<a name="ln1635">                        tickEnd = i-&gt;first;</a>
<a name="ln1636">                  Interval oldV = ic-&gt;part()-&gt;instrument(tickStart)-&gt;transpose();</a>
<a name="ln1637">                  ic-&gt;part()-&gt;removeInstrument(tickStart);</a>
<a name="ln1638">                  transpositionChanged(ic-&gt;part(), oldV, tickStart, tickEnd);</a>
<a name="ln1639">#endif</a>
<a name="ln1640">                  addLayoutFlags(LayoutFlag::REBUILD_MIDI_MAPPING);</a>
<a name="ln1641">                  cmdState()._instrumentsChanged = true;</a>
<a name="ln1642">                  }</a>
<a name="ln1643">                  break;</a>
<a name="ln1644"> </a>
<a name="ln1645">            case ElementType::TREMOLO:</a>
<a name="ln1646">            case ElementType::ARTICULATION:</a>
<a name="ln1647">            case ElementType::ARPEGGIO:</a>
<a name="ln1648">                  {</a>
<a name="ln1649">                  Element* cr = element-&gt;parent();</a>
<a name="ln1650">                  if (cr-&gt;isChord())</a>
<a name="ln1651">                        createPlayEvents(toChord(cr));</a>
<a name="ln1652">                  }</a>
<a name="ln1653">                  break;</a>
<a name="ln1654"> </a>
<a name="ln1655">            default:</a>
<a name="ln1656">                  break;</a>
<a name="ln1657">            }</a>
<a name="ln1658">      }</a>
<a name="ln1659"> </a>
<a name="ln1660">//---------------------------------------------------------</a>
<a name="ln1661">//   firstMeasure</a>
<a name="ln1662">//---------------------------------------------------------</a>
<a name="ln1663"> </a>
<a name="ln1664">Measure* Score::firstMeasure() const</a>
<a name="ln1665">      {</a>
<a name="ln1666">      MeasureBase* mb = _measures.first();</a>
<a name="ln1667">      while (mb &amp;&amp; mb-&gt;type() != ElementType::MEASURE)</a>
<a name="ln1668">            mb = mb-&gt;next();</a>
<a name="ln1669"> </a>
<a name="ln1670">      return toMeasure(mb);</a>
<a name="ln1671">      }</a>
<a name="ln1672"> </a>
<a name="ln1673">//---------------------------------------------------------</a>
<a name="ln1674">//   firstMeasureMM</a>
<a name="ln1675">//---------------------------------------------------------</a>
<a name="ln1676"> </a>
<a name="ln1677">Measure* Score::firstMeasureMM() const</a>
<a name="ln1678">      {</a>
<a name="ln1679">      Measure* m = firstMeasure();</a>
<a name="ln1680">      if (m &amp;&amp; styleB(Sid::createMultiMeasureRests) &amp;&amp; m-&gt;hasMMRest())</a>
<a name="ln1681">            return m-&gt;mmRest();</a>
<a name="ln1682">      return m;</a>
<a name="ln1683">      }</a>
<a name="ln1684"> </a>
<a name="ln1685">//---------------------------------------------------------</a>
<a name="ln1686">//   firstMM</a>
<a name="ln1687">//---------------------------------------------------------</a>
<a name="ln1688"> </a>
<a name="ln1689">MeasureBase* Score::firstMM() const</a>
<a name="ln1690">      {</a>
<a name="ln1691">      MeasureBase* m = _measures.first();</a>
<a name="ln1692">      if (m</a>
<a name="ln1693">         &amp;&amp; m-&gt;type() == ElementType::MEASURE</a>
<a name="ln1694">         &amp;&amp; styleB(Sid::createMultiMeasureRests)</a>
<a name="ln1695">         &amp;&amp; toMeasure(m)-&gt;hasMMRest()) {</a>
<a name="ln1696">            return toMeasure(m)-&gt;mmRest();</a>
<a name="ln1697">            }</a>
<a name="ln1698">      return m;</a>
<a name="ln1699">      }</a>
<a name="ln1700"> </a>
<a name="ln1701">//---------------------------------------------------------</a>
<a name="ln1702">//   measure</a>
<a name="ln1703">//---------------------------------------------------------</a>
<a name="ln1704"> </a>
<a name="ln1705">MeasureBase* Score::measure(int idx) const</a>
<a name="ln1706">      {</a>
<a name="ln1707">      MeasureBase* mb = _measures.first();</a>
<a name="ln1708">      for (int i = 0; i &lt; idx; ++i) {</a>
<a name="ln1709">            mb = mb-&gt;next();</a>
<a name="ln1710">            if (mb == 0)</a>
<a name="ln1711">                  return 0;</a>
<a name="ln1712">            }</a>
<a name="ln1713">      return mb;</a>
<a name="ln1714">      }</a>
<a name="ln1715"> </a>
<a name="ln1716">//---------------------------------------------------------</a>
<a name="ln1717">//   crMeasure</a>
<a name="ln1718">//    Returns a measure containing chords an rests</a>
<a name="ln1719">//    by its index skipping other MeasureBase descendants</a>
<a name="ln1720">//---------------------------------------------------------</a>
<a name="ln1721"> </a>
<a name="ln1722">Measure* Score::crMeasure(int idx) const</a>
<a name="ln1723">      {</a>
<a name="ln1724">      int i = -1;</a>
<a name="ln1725">      for (MeasureBase* mb = _measures.first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln1726">            if (mb-&gt;isMeasure())</a>
<a name="ln1727">                  ++i;</a>
<a name="ln1728">            if (i == idx)</a>
<a name="ln1729">                  return toMeasure(mb);</a>
<a name="ln1730">            }</a>
<a name="ln1731">      return nullptr;</a>
<a name="ln1732">      }</a>
<a name="ln1733"> </a>
<a name="ln1734">//---------------------------------------------------------</a>
<a name="ln1735">//   lastMeasure</a>
<a name="ln1736">//---------------------------------------------------------</a>
<a name="ln1737"> </a>
<a name="ln1738">Measure* Score::lastMeasure() const</a>
<a name="ln1739">      {</a>
<a name="ln1740">      MeasureBase* mb = _measures.last();</a>
<a name="ln1741">      while (mb &amp;&amp; mb-&gt;type() != ElementType::MEASURE)</a>
<a name="ln1742">            mb = mb-&gt;prev();</a>
<a name="ln1743">      return toMeasure(mb);</a>
<a name="ln1744">      }</a>
<a name="ln1745"> </a>
<a name="ln1746">//---------------------------------------------------------</a>
<a name="ln1747">//   lastMeasureMM</a>
<a name="ln1748">//---------------------------------------------------------</a>
<a name="ln1749"> </a>
<a name="ln1750">Measure* Score::lastMeasureMM() const</a>
<a name="ln1751">      {</a>
<a name="ln1752">      Measure* m = lastMeasure();</a>
<a name="ln1753">      if (m &amp;&amp; styleB(Sid::createMultiMeasureRests)) {</a>
<a name="ln1754">            Measure* m1 = const_cast&lt;Measure*&gt;(toMeasure(m-&gt;mmRest1()));</a>
<a name="ln1755">            if (m1)</a>
<a name="ln1756">                  return m1;</a>
<a name="ln1757">            }</a>
<a name="ln1758">      return m;</a>
<a name="ln1759">      }</a>
<a name="ln1760"> </a>
<a name="ln1761">//---------------------------------------------------------</a>
<a name="ln1762">//   endTick</a>
<a name="ln1763">//---------------------------------------------------------</a>
<a name="ln1764"> </a>
<a name="ln1765">Fraction Score::endTick() const</a>
<a name="ln1766">      {</a>
<a name="ln1767">      Measure* m = lastMeasure();</a>
<a name="ln1768">      return m ? m-&gt;endTick() : Fraction(0,1);</a>
<a name="ln1769">      }</a>
<a name="ln1770"> </a>
<a name="ln1771">//---------------------------------------------------------</a>
<a name="ln1772">//   firstSegment</a>
<a name="ln1773">//---------------------------------------------------------</a>
<a name="ln1774"> </a>
<a name="ln1775">Segment* Score::firstSegment(SegmentType segType) const</a>
<a name="ln1776">      {</a>
<a name="ln1777">      Segment* seg;</a>
<a name="ln1778">      Measure* m = firstMeasure();</a>
<a name="ln1779">      if (!m)</a>
<a name="ln1780">            seg = 0;</a>
<a name="ln1781">      else {</a>
<a name="ln1782">            seg = m-&gt;first();</a>
<a name="ln1783">            if (seg &amp;&amp; !(seg-&gt;segmentType() &amp; segType))</a>
<a name="ln1784">                  seg = seg-&gt;next1(segType);</a>
<a name="ln1785">            }</a>
<a name="ln1786"> </a>
<a name="ln1787">#ifdef SCRIPT_INTERFACE</a>
<a name="ln1788">      // if called from QML/JS, tell QML engine not to garbage collect this object</a>
<a name="ln1789">//      if (seg)</a>
<a name="ln1790">//            QQmlEngine::setObjectOwnership(seg, QQmlEngine::CppOwnership);</a>
<a name="ln1791">#endif</a>
<a name="ln1792">      return seg;</a>
<a name="ln1793">      }</a>
<a name="ln1794"> </a>
<a name="ln1795">//---------------------------------------------------------</a>
<a name="ln1796">//   firstSegmentMM</a>
<a name="ln1797">//---------------------------------------------------------</a>
<a name="ln1798"> </a>
<a name="ln1799">Segment* Score::firstSegmentMM(SegmentType segType) const</a>
<a name="ln1800">      {</a>
<a name="ln1801">      Measure* m = firstMeasureMM();</a>
<a name="ln1802">      return m ? m-&gt;first(segType) : 0;</a>
<a name="ln1803">      }</a>
<a name="ln1804"> </a>
<a name="ln1805">//---------------------------------------------------------</a>
<a name="ln1806">//   lastSegment</a>
<a name="ln1807">//---------------------------------------------------------</a>
<a name="ln1808"> </a>
<a name="ln1809">Segment* Score::lastSegment() const</a>
<a name="ln1810">      {</a>
<a name="ln1811">      Measure* m = lastMeasure();</a>
<a name="ln1812">      return m ? m-&gt;last() : 0;</a>
<a name="ln1813">      }</a>
<a name="ln1814"> </a>
<a name="ln1815">//---------------------------------------------------------</a>
<a name="ln1816">//   lastSegmentMM</a>
<a name="ln1817">//---------------------------------------------------------</a>
<a name="ln1818"> </a>
<a name="ln1819">Segment* Score::lastSegmentMM() const</a>
<a name="ln1820">      {</a>
<a name="ln1821">      Measure* m = lastMeasureMM();</a>
<a name="ln1822">      return m ? m-&gt;last() : 0;</a>
<a name="ln1823">      }</a>
<a name="ln1824"> </a>
<a name="ln1825">//---------------------------------------------------------</a>
<a name="ln1826">//   utick2utime</a>
<a name="ln1827">//---------------------------------------------------------</a>
<a name="ln1828"> </a>
<a name="ln1829">qreal Score::utick2utime(int tick) const</a>
<a name="ln1830">      {</a>
<a name="ln1831">      return repeatList().utick2utime(tick);</a>
<a name="ln1832">      }</a>
<a name="ln1833"> </a>
<a name="ln1834">//---------------------------------------------------------</a>
<a name="ln1835">//   utime2utick</a>
<a name="ln1836">//---------------------------------------------------------</a>
<a name="ln1837"> </a>
<a name="ln1838">int Score::utime2utick(qreal utime) const</a>
<a name="ln1839">      {</a>
<a name="ln1840">      return repeatList().utime2utick(utime);</a>
<a name="ln1841">      }</a>
<a name="ln1842"> </a>
<a name="ln1843">//---------------------------------------------------------</a>
<a name="ln1844">//   setExpandRepeats</a>
<a name="ln1845">//---------------------------------------------------------</a>
<a name="ln1846"> </a>
<a name="ln1847">void MasterScore::setExpandRepeats(bool expand)</a>
<a name="ln1848">      {</a>
<a name="ln1849">      if (_expandRepeats == expand)</a>
<a name="ln1850">            return;</a>
<a name="ln1851">      _expandRepeats = expand;</a>
<a name="ln1852">      setPlaylistDirty();</a>
<a name="ln1853">      }</a>
<a name="ln1854"> </a>
<a name="ln1855">//---------------------------------------------------------</a>
<a name="ln1856">//   updateRepeatListTempo</a>
<a name="ln1857">///   needed for usage in Seq::processMessages</a>
<a name="ln1858">//---------------------------------------------------------</a>
<a name="ln1859"> </a>
<a name="ln1860">void MasterScore::updateRepeatListTempo()</a>
<a name="ln1861">      {</a>
<a name="ln1862">      _repeatList-&gt;updateTempo();</a>
<a name="ln1863">      }</a>
<a name="ln1864"> </a>
<a name="ln1865">//---------------------------------------------------------</a>
<a name="ln1866">//   repeatList</a>
<a name="ln1867">//---------------------------------------------------------</a>
<a name="ln1868"> </a>
<a name="ln1869">const RepeatList&amp; MasterScore::repeatList() const</a>
<a name="ln1870">      {</a>
<a name="ln1871">      _repeatList-&gt;update(_expandRepeats);</a>
<a name="ln1872">      return *_repeatList;</a>
<a name="ln1873">      }</a>
<a name="ln1874"> </a>
<a name="ln1875">//---------------------------------------------------------</a>
<a name="ln1876">//   inputPos</a>
<a name="ln1877">//---------------------------------------------------------</a>
<a name="ln1878"> </a>
<a name="ln1879">Fraction Score::inputPos() const</a>
<a name="ln1880">      {</a>
<a name="ln1881">      return _is.tick();</a>
<a name="ln1882">      }</a>
<a name="ln1883"> </a>
<a name="ln1884">//---------------------------------------------------------</a>
<a name="ln1885">//   scanElements</a>
<a name="ln1886">//    scan all elements</a>
<a name="ln1887">//---------------------------------------------------------</a>
<a name="ln1888"> </a>
<a name="ln1889">void Score::scanElements(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln1890">      {</a>
<a name="ln1891">      for (MeasureBase* mb = first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln1892">            mb-&gt;scanElements(data, func, all);</a>
<a name="ln1893">            if (mb-&gt;type() == ElementType::MEASURE) {</a>
<a name="ln1894">                  Measure* m = toMeasure(mb);</a>
<a name="ln1895">                  Measure* mmr = m-&gt;mmRest();</a>
<a name="ln1896">                  if (mmr)</a>
<a name="ln1897">                        mmr-&gt;scanElements(data, func, all);</a>
<a name="ln1898">                  }</a>
<a name="ln1899">            }</a>
<a name="ln1900">      for (Page* page : pages()) {</a>
<a name="ln1901">            for (System* s :page-&gt;systems())</a>
<a name="ln1902">                  s-&gt;scanElements(data, func, all);</a>
<a name="ln1903">            func(data, page);</a>
<a name="ln1904">            }</a>
<a name="ln1905">      }</a>
<a name="ln1906"> </a>
<a name="ln1907">//---------------------------------------------------------</a>
<a name="ln1908">//   scanElementsInRange</a>
<a name="ln1909">//---------------------------------------------------------</a>
<a name="ln1910"> </a>
<a name="ln1911">void Score::scanElementsInRange(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln1912">      {</a>
<a name="ln1913">      Segment* startSeg = _selection.startSegment();</a>
<a name="ln1914">      for (Segment* s = startSeg; s &amp;&amp; s !=_selection.endSegment(); s = s-&gt;next1()) {</a>
<a name="ln1915">            s-&gt;scanElements(data, func, all);</a>
<a name="ln1916">            Measure* m = s-&gt;measure();</a>
<a name="ln1917">            if (m &amp;&amp; s == m-&gt;first()) {</a>
<a name="ln1918">                  Measure* mmr = m-&gt;mmRest();</a>
<a name="ln1919">                  if (mmr)</a>
<a name="ln1920">                        mmr-&gt;scanElements(data, func, all);</a>
<a name="ln1921">                  }</a>
<a name="ln1922">            }</a>
<a name="ln1923">      for (Element* e : _selection.elements()) {</a>
<a name="ln1924">            if (e-&gt;isSpanner()) {</a>
<a name="ln1925">                  Spanner* spanner = toSpanner(e);</a>
<a name="ln1926">                  for (SpannerSegment* ss : spanner-&gt;spannerSegments()) {</a>
<a name="ln1927">                        ss-&gt;scanElements(data, func, all);</a>
<a name="ln1928">                        }</a>
<a name="ln1929">                  }</a>
<a name="ln1930">            }</a>
<a name="ln1931">      }</a>
<a name="ln1932"> </a>
<a name="ln1933">//---------------------------------------------------------</a>
<a name="ln1934">//   setSelection</a>
<a name="ln1935">//---------------------------------------------------------</a>
<a name="ln1936"> </a>
<a name="ln1937">void Score::setSelection(const Selection&amp; s)</a>
<a name="ln1938">      {</a>
<a name="ln1939">      deselectAll();</a>
<a name="ln1940">      _selection = s;</a>
<a name="ln1941"> </a>
<a name="ln1942">      foreach(Element* e, _selection.elements())</a>
<a name="ln1943">            e-&gt;setSelected(true);</a>
<a name="ln1944">      }</a>
<a name="ln1945"> </a>
<a name="ln1946">//---------------------------------------------------------</a>
<a name="ln1947">//   getText</a>
<a name="ln1948">//---------------------------------------------------------</a>
<a name="ln1949"> </a>
<a name="ln1950">Text* Score::getText(Tid tid)</a>
<a name="ln1951">      {</a>
<a name="ln1952">      MeasureBase* m = first();</a>
<a name="ln1953">      if (m &amp;&amp; m-&gt;isVBox()) {</a>
<a name="ln1954">            for (Element* e : m-&gt;el()) {</a>
<a name="ln1955">                  if (e-&gt;isText() &amp;&amp; toText(e)-&gt;tid() == tid)</a>
<a name="ln1956">                        return toText(e);</a>
<a name="ln1957">                  }</a>
<a name="ln1958">            }</a>
<a name="ln1959">      return 0;</a>
<a name="ln1960">      }</a>
<a name="ln1961"> </a>
<a name="ln1962">//---------------------------------------------------------</a>
<a name="ln1963">//   metaTag</a>
<a name="ln1964">//---------------------------------------------------------</a>
<a name="ln1965"> </a>
<a name="ln1966">QString Score::metaTag(const QString&amp; s) const</a>
<a name="ln1967">      {</a>
<a name="ln1968">      if (_metaTags.contains(s))</a>
<a name="ln1969">            return _metaTags.value(s);</a>
<a name="ln1970">      return _masterScore-&gt;_metaTags.value(s);</a>
<a name="ln1971">      }</a>
<a name="ln1972"> </a>
<a name="ln1973">//---------------------------------------------------------</a>
<a name="ln1974">//   setMetaTag</a>
<a name="ln1975">//---------------------------------------------------------</a>
<a name="ln1976"> </a>
<a name="ln1977">void Score::setMetaTag(const QString&amp; tag, const QString&amp; val)</a>
<a name="ln1978">      {</a>
<a name="ln1979">      _metaTags.insert(tag, val);</a>
<a name="ln1980">      }</a>
<a name="ln1981"> </a>
<a name="ln1982">//---------------------------------------------------------</a>
<a name="ln1983">//   addExcerpt</a>
<a name="ln1984">//---------------------------------------------------------</a>
<a name="ln1985"> </a>
<a name="ln1986">void MasterScore::addExcerpt(Excerpt* ex)</a>
<a name="ln1987">      {</a>
<a name="ln1988">      Score* score = ex-&gt;partScore();</a>
<a name="ln1989"> </a>
<a name="ln1990">      for (Staff* s : score-&gt;staves()) {</a>
<a name="ln1991">            const LinkedElements* ls = s-&gt;links();</a>
<a name="ln1992">            if (ls == 0)</a>
<a name="ln1993">                  continue;</a>
<a name="ln1994">            for (auto le : *ls) {</a>
<a name="ln1995">                  Staff* ps = toStaff(le);</a>
<a name="ln1996">                  if (ps-&gt;score() == this) {</a>
<a name="ln1997">                        ex-&gt;parts().append(ps-&gt;part());</a>
<a name="ln1998">                        break;</a>
<a name="ln1999">                        }</a>
<a name="ln2000">                  }</a>
<a name="ln2001">            }</a>
<a name="ln2002">      if (ex-&gt;tracks().isEmpty()) {                         // SHOULDN'T HAPPEN, protected in the UI</a>
<a name="ln2003">            QMultiMap&lt;int, int&gt; tracks;</a>
<a name="ln2004">            for (Staff* s : score-&gt;staves()) {</a>
<a name="ln2005">                  const LinkedElements* ls = s-&gt;links();</a>
<a name="ln2006">                  if (ls == 0)</a>
<a name="ln2007">                        continue;</a>
<a name="ln2008">                  for (auto le : *ls) {</a>
<a name="ln2009">                        Staff* ps = toStaff(le);</a>
<a name="ln2010">                        if (ps-&gt;primaryStaff()) {</a>
<a name="ln2011">                              for (int i = 0; i &lt; VOICES; i++)</a>
<a name="ln2012">                                    tracks.insert(ps-&gt;idx() * VOICES + i % VOICES, s-&gt;idx() * VOICES + i % VOICES);</a>
<a name="ln2013">                              break;</a>
<a name="ln2014">                              }</a>
<a name="ln2015">                        }</a>
<a name="ln2016">                  }</a>
<a name="ln2017">            ex-&gt;setTracks(tracks);</a>
<a name="ln2018">            }</a>
<a name="ln2019">      excerpts().append(ex);</a>
<a name="ln2020">      setExcerptsChanged(true);</a>
<a name="ln2021">      }</a>
<a name="ln2022"> </a>
<a name="ln2023">//---------------------------------------------------------</a>
<a name="ln2024">//   removeExcerpt</a>
<a name="ln2025">//---------------------------------------------------------</a>
<a name="ln2026"> </a>
<a name="ln2027">void MasterScore::removeExcerpt(Excerpt* ex)</a>
<a name="ln2028">      {</a>
<a name="ln2029">      if (excerpts().removeOne(ex)) {</a>
<a name="ln2030">            setExcerptsChanged(true);</a>
<a name="ln2031">            // delete ex;</a>
<a name="ln2032">            }</a>
<a name="ln2033">      else</a>
<a name="ln2034">            qDebug(&quot;removeExcerpt:: ex not found&quot;);</a>
<a name="ln2035">      }</a>
<a name="ln2036"> </a>
<a name="ln2037">//---------------------------------------------------------</a>
<a name="ln2038">//   clone</a>
<a name="ln2039">//---------------------------------------------------------</a>
<a name="ln2040"> </a>
<a name="ln2041">MasterScore* MasterScore::clone()</a>
<a name="ln2042">      {</a>
<a name="ln2043">      QBuffer buffer;</a>
<a name="ln2044">      buffer.open(QIODevice::WriteOnly);</a>
<a name="ln2045">      XmlWriter xml(this, &amp;buffer);</a>
<a name="ln2046">      xml.header();</a>
<a name="ln2047"> </a>
<a name="ln2048">      xml.stag(&quot;museScore version=\&quot;&quot; MSC_VERSION &quot;\&quot;&quot;);</a>
<a name="ln2049">      write(xml, false);</a>
<a name="ln2050">      xml.etag();</a>
<a name="ln2051"> </a>
<a name="ln2052">      buffer.close();</a>
<a name="ln2053"> </a>
<a name="ln2054">      XmlReader r(buffer.buffer());</a>
<a name="ln2055">      MasterScore* score = new MasterScore(style());</a>
<a name="ln2056">      score-&gt;read1(r, true);</a>
<a name="ln2057"> </a>
<a name="ln2058">      score-&gt;addLayoutFlags(LayoutFlag::FIX_PITCH_VELO);</a>
<a name="ln2059">      score-&gt;doLayout();</a>
<a name="ln2060">      return score;</a>
<a name="ln2061">      }</a>
<a name="ln2062"> </a>
<a name="ln2063">//---------------------------------------------------------</a>
<a name="ln2064">//   setSynthesizerState</a>
<a name="ln2065">//---------------------------------------------------------</a>
<a name="ln2066"> </a>
<a name="ln2067">void Score::setSynthesizerState(const SynthesizerState&amp; s)</a>
<a name="ln2068">      {</a>
<a name="ln2069">      // TODO: make undoable</a>
<a name="ln2070">      _synthesizerState = s;</a>
<a name="ln2071">      }</a>
<a name="ln2072"> </a>
<a name="ln2073">//---------------------------------------------------------</a>
<a name="ln2074">//   removeAudio</a>
<a name="ln2075">//---------------------------------------------------------</a>
<a name="ln2076"> </a>
<a name="ln2077">void Score::removeAudio()</a>
<a name="ln2078">      {</a>
<a name="ln2079">      delete _audio;</a>
<a name="ln2080">      _audio = 0;</a>
<a name="ln2081">      }</a>
<a name="ln2082"> </a>
<a name="ln2083">//---------------------------------------------------------</a>
<a name="ln2084">//   appendScore</a>
<a name="ln2085">//---------------------------------------------------------</a>
<a name="ln2086"> </a>
<a name="ln2087">bool Score::appendScore(Score* score, bool addPageBreak, bool addSectionBreak)</a>
<a name="ln2088">      {</a>
<a name="ln2089">      if (parts().size() &lt; score-&gt;parts().size() || staves().size() &lt; score-&gt;staves().size()) {</a>
<a name="ln2090">            qDebug(&quot;Score to append has %d parts and %d staves, but this score only has %d parts and %d staves.&quot;, score-&gt;parts().size(), score-&gt;staves().size(), parts().size(), staves().size());</a>
<a name="ln2091">            return false;</a>
<a name="ln2092">            }</a>
<a name="ln2093"> </a>
<a name="ln2094">      if (!last()) {</a>
<a name="ln2095">            qDebug(&quot;This score doesn't have any MeasureBase objects.&quot;);</a>
<a name="ln2096">            return false;</a>
<a name="ln2097">            }</a>
<a name="ln2098"> </a>
<a name="ln2099">      // apply Page/Section Breaks if desired</a>
<a name="ln2100">      if (addPageBreak) {</a>
<a name="ln2101">            if (!last()-&gt;pageBreak()) {</a>
<a name="ln2102">                  last()-&gt;undoSetBreak(false, LayoutBreak::Type::LINE); // remove line break if exists</a>
<a name="ln2103">                  last()-&gt;undoSetBreak(true, LayoutBreak::Type::PAGE);  // apply page break</a>
<a name="ln2104">                  }</a>
<a name="ln2105">            }</a>
<a name="ln2106">      else if (!last()-&gt;lineBreak() &amp;&amp; !last()-&gt;pageBreak()) {</a>
<a name="ln2107">            last()-&gt;undoSetBreak(true, LayoutBreak::Type::LINE);</a>
<a name="ln2108">            }</a>
<a name="ln2109"> </a>
<a name="ln2110">      if (addSectionBreak &amp;&amp; !last()-&gt;sectionBreak())</a>
<a name="ln2111">            last()-&gt;undoSetBreak(true, LayoutBreak::Type::SECTION);</a>
<a name="ln2112"> </a>
<a name="ln2113">      // match concert pitch states</a>
<a name="ln2114">      if (styleB(Sid::concertPitch) != score-&gt;styleB(Sid::concertPitch))</a>
<a name="ln2115">            score-&gt;cmdConcertPitchChanged(styleB(Sid::concertPitch), true);</a>
<a name="ln2116"> </a>
<a name="ln2117">      // clone the measures</a>
<a name="ln2118">      appendMeasuresFromScore(score, Fraction(0, 1), score-&gt;last()-&gt;endTick());</a>
<a name="ln2119"> </a>
<a name="ln2120">      setLayoutAll();</a>
<a name="ln2121">      return true;</a>
<a name="ln2122">      }</a>
<a name="ln2123"> </a>
<a name="ln2124">//---------------------------------------------------------</a>
<a name="ln2125">//   appendMeasuresFromScore</a>
<a name="ln2126">//     clone measures from another score to the end of this</a>
<a name="ln2127">//---------------------------------------------------------</a>
<a name="ln2128"> </a>
<a name="ln2129">bool Score::appendMeasuresFromScore(Score* score, const Fraction&amp; startTick, const Fraction&amp; endTick)</a>
<a name="ln2130">      {</a>
<a name="ln2131">      Fraction tickOfAppend = last()-&gt;endTick();</a>
<a name="ln2132">      MeasureBase* pmb = last();</a>
<a name="ln2133">      TieMap tieMap;</a>
<a name="ln2134"> </a>
<a name="ln2135">      MeasureBase* fmb = score-&gt;tick2measureBase(startTick);</a>
<a name="ln2136">      MeasureBase* emb = score-&gt;tick2measureBase(endTick);</a>
<a name="ln2137">      Fraction curTick = tickOfAppend;</a>
<a name="ln2138">      for (MeasureBase* cmb = fmb; cmb != emb; cmb = cmb-&gt;next()) {</a>
<a name="ln2139">            MeasureBase* nmb;</a>
<a name="ln2140">            if (cmb-&gt;isMeasure()) {</a>
<a name="ln2141">                  Measure* nm = toMeasure(cmb)-&gt;cloneMeasure(this, curTick, &amp;tieMap);</a>
<a name="ln2142">                  curTick += nm-&gt;ticks();</a>
<a name="ln2143">                  nmb = toMeasureBase(nm);</a>
<a name="ln2144">                  }</a>
<a name="ln2145">            else {</a>
<a name="ln2146">                  nmb = cmb-&gt;clone();</a>
<a name="ln2147">                  }</a>
<a name="ln2148"> </a>
<a name="ln2149">            addMeasure(nmb, 0);</a>
<a name="ln2150">            nmb-&gt;setNext(0);</a>
<a name="ln2151">            nmb-&gt;setPrev(pmb);</a>
<a name="ln2152">            nmb-&gt;setScore(this);</a>
<a name="ln2153"> </a>
<a name="ln2154">            pmb-&gt;setNext(nmb);</a>
<a name="ln2155">            pmb = nmb;</a>
<a name="ln2156">            }</a>
<a name="ln2157"> </a>
<a name="ln2158">      Measure* firstAppendedMeasure = tick2measure(tickOfAppend);</a>
<a name="ln2159"> </a>
<a name="ln2160">      // if the appended score has less staves,</a>
<a name="ln2161">      // make sure the measures have full measure rest</a>
<a name="ln2162">      for (Measure* m = firstAppendedMeasure; m; m = m-&gt;nextMeasure())</a>
<a name="ln2163">            for (int staffIdx = 0; staffIdx &lt; nstaves(); ++staffIdx) {</a>
<a name="ln2164">                  Fraction f;</a>
<a name="ln2165">                  for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next(SegmentType::ChordRest))</a>
<a name="ln2166">                        for (int v = 0; v &lt; VOICES; ++v) {</a>
<a name="ln2167">                              ChordRest* cr = toChordRest(s-&gt;element(staffIdx * VOICES + v));</a>
<a name="ln2168">                              if (cr == 0) continue;</a>
<a name="ln2169">                              f += cr-&gt;actualTicks();</a>
<a name="ln2170">                              }</a>
<a name="ln2171">                  if (f.isZero())</a>
<a name="ln2172">                        addRest(m-&gt;tick(), staffIdx*VOICES, TDuration(TDuration::DurationType::V_MEASURE), 0);</a>
<a name="ln2173">                  }</a>
<a name="ln2174"> </a>
<a name="ln2175">      // at first added measure, check if we need to add Clef/Key/TimeSig</a>
<a name="ln2176">      //  this is needed if it was changed and needs to be changed back</a>
<a name="ln2177">      int n = nstaves();</a>
<a name="ln2178">      Fraction otick = fmb-&gt;tick(), ctick = tickOfAppend;</a>
<a name="ln2179">      for (int staffIdx = 0; staffIdx &lt; n; ++staffIdx) { // iterate over all staves</a>
<a name="ln2180">            int trackIdx = staff2track(staffIdx); // idx of irst track on the staff</a>
<a name="ln2181">            Staff* staff = this-&gt;staff(staffIdx);</a>
<a name="ln2182">            Staff* ostaff = score-&gt;staff(staffIdx);</a>
<a name="ln2183"> </a>
<a name="ln2184">            // check if key signature needs to be changed</a>
<a name="ln2185">            if (ostaff-&gt;key(otick) != staff-&gt;key(ctick)) {</a>
<a name="ln2186">                  Segment* ns = firstAppendedMeasure-&gt;undoGetSegment(SegmentType::KeySig, ctick);</a>
<a name="ln2187">                  KeySigEvent nkse = KeySigEvent(ostaff-&gt;keySigEvent(otick));</a>
<a name="ln2188">                  KeySig* nks = new KeySig(this);</a>
<a name="ln2189">                  nks-&gt;setScore(this);</a>
<a name="ln2190">                  nks-&gt;setTrack(trackIdx);</a>
<a name="ln2191"> </a>
<a name="ln2192">                  nks-&gt;setKeySigEvent(nkse);</a>
<a name="ln2193">                  staff-&gt;setKey(ctick, nkse);</a>
<a name="ln2194">                  ns-&gt;add(nks);</a>
<a name="ln2195">                  }</a>
<a name="ln2196">            // check if a key signature is present but is spurious (i.e. no actual change)</a>
<a name="ln2197">            else if (staff-&gt;currentKeyTick(ctick) == ctick &amp;&amp;</a>
<a name="ln2198">                     staff-&gt;key(ctick - Fraction::fromTicks(1)) == ostaff-&gt;key(otick)) {</a>
<a name="ln2199">                        Segment* ns = firstAppendedMeasure-&gt;first(SegmentType::KeySig);</a>
<a name="ln2200">                        if (ns)</a>
<a name="ln2201">                              ns-&gt;remove(ns-&gt;element(trackIdx));</a>
<a name="ln2202">                  }</a>
<a name="ln2203"> </a>
<a name="ln2204">            // check if time signature needs to be changed</a>
<a name="ln2205">            TimeSig* ots = ostaff-&gt;timeSig(otick), * cts = staff-&gt;timeSig(ctick);</a>
<a name="ln2206">            TimeSig* pts = staff-&gt;timeSig(ctick - Fraction::fromTicks(1));</a>
<a name="ln2207">            if (ots &amp;&amp; cts &amp;&amp; *ots != *cts) {</a>
<a name="ln2208">                  Segment* ns = firstAppendedMeasure-&gt;undoGetSegment(SegmentType::TimeSig, ctick);</a>
<a name="ln2209">                  TimeSig* nsig = new TimeSig(*ots);</a>
<a name="ln2210"> </a>
<a name="ln2211">                  nsig-&gt;setScore(this);</a>
<a name="ln2212">                  nsig-&gt;setTrack(trackIdx);</a>
<a name="ln2213">                  ns-&gt;add(nsig);</a>
<a name="ln2214">                  }</a>
<a name="ln2215">            // check if a time signature is present but is spurious (i.e. no actual change)</a>
<a name="ln2216">            else if (staff-&gt;currentTimeSigTick(ctick) == ctick &amp;&amp;</a>
<a name="ln2217">                     ots &amp;&amp; pts &amp;&amp; *pts == *ots) {</a>
<a name="ln2218">                        Segment* ns = firstAppendedMeasure-&gt;first(SegmentType::TimeSig);</a>
<a name="ln2219">                        if (ns)</a>
<a name="ln2220">                              ns-&gt;remove(ns-&gt;element(trackIdx));</a>
<a name="ln2221">                  }</a>
<a name="ln2222"> </a>
<a name="ln2223">            // check if clef signature needs to be changed</a>
<a name="ln2224">            if (ostaff-&gt;clef(otick) != staff-&gt;clef(ctick)) {</a>
<a name="ln2225">                  undoChangeClef(staff, firstAppendedMeasure, ostaff-&gt;clef(otick));</a>
<a name="ln2226">                  }</a>
<a name="ln2227">            // check if a clef change is present but is spurious (i.e. no actual change)</a>
<a name="ln2228">            else if (staff-&gt;currentClefTick(ctick) == ctick &amp;&amp;</a>
<a name="ln2229">                     staff-&gt;clef(ctick - Fraction::fromTicks(1)) == ostaff-&gt;clef(otick)) {</a>
<a name="ln2230">                        Segment* ns = firstAppendedMeasure-&gt;first(SegmentType::Clef);</a>
<a name="ln2231">                        if (!ns)</a>
<a name="ln2232">                              ns = firstAppendedMeasure-&gt;first(SegmentType::HeaderClef);</a>
<a name="ln2233">                        if (ns)</a>
<a name="ln2234">                              ns-&gt;remove(ns-&gt;element(trackIdx));</a>
<a name="ln2235">                  }</a>
<a name="ln2236">            }</a>
<a name="ln2237"> </a>
<a name="ln2238">      // check if section starts with a pick-up measure to be merged with end of previous section</a>
<a name="ln2239">      Measure* cm = firstAppendedMeasure, * pm = cm-&gt;prevMeasure();</a>
<a name="ln2240">      if (pm-&gt;timesig() == cm-&gt;timesig() &amp;&amp; pm-&gt;ticks() + cm-&gt;ticks() == cm-&gt;timesig())</a>
<a name="ln2241">            cmdJoinMeasure(pm, cm);</a>
<a name="ln2242"> </a>
<a name="ln2243">      // clone the spanners (only in the range currently copied)</a>
<a name="ln2244">      auto ospans = score-&gt;spanner();</a>
<a name="ln2245">      auto lb = ospans.lower_bound(startTick.ticks()), ub = ospans.upper_bound(endTick.ticks());</a>
<a name="ln2246">      for (auto sp = lb; sp != ub; sp++) {</a>
<a name="ln2247">            Spanner* spanner = sp-&gt;second;</a>
<a name="ln2248"> </a>
<a name="ln2249">            if (spanner-&gt;tick2() &gt; endTick) continue; // map is by tick() so this can still happen in theory...</a>
<a name="ln2250"> </a>
<a name="ln2251">            Spanner* ns = toSpanner(spanner-&gt;clone());</a>
<a name="ln2252">            ns-&gt;setScore(this);</a>
<a name="ln2253">            ns-&gt;setParent(0);</a>
<a name="ln2254">            ns-&gt;setTick(spanner-&gt;tick() - startTick + tickOfAppend);</a>
<a name="ln2255">            ns-&gt;setTick2(spanner-&gt;tick2() - startTick + tickOfAppend);</a>
<a name="ln2256">            ns-&gt;computeStartElement();</a>
<a name="ln2257">            ns-&gt;computeEndElement();</a>
<a name="ln2258">            addElement(ns);</a>
<a name="ln2259">            }</a>
<a name="ln2260"> </a>
<a name="ln2261">      return true;</a>
<a name="ln2262">      }</a>
<a name="ln2263"> </a>
<a name="ln2264">//---------------------------------------------------------</a>
<a name="ln2265">//   splitStaff</a>
<a name="ln2266">//---------------------------------------------------------</a>
<a name="ln2267"> </a>
<a name="ln2268">void Score::splitStaff(int staffIdx, int splitPoint)</a>
<a name="ln2269">      {</a>
<a name="ln2270">//      qDebug(&quot;split staff %d point %d&quot;, staffIdx, splitPoint);</a>
<a name="ln2271"> </a>
<a name="ln2272">      //</a>
<a name="ln2273">      // create second staff</a>
<a name="ln2274">      //</a>
<a name="ln2275">      Staff* st = staff(staffIdx);</a>
<a name="ln2276">      Part*  p  = st-&gt;part();</a>
<a name="ln2277">      Staff* ns = new Staff(this);</a>
<a name="ln2278">      ns-&gt;init(st);</a>
<a name="ln2279">      ns-&gt;setPart(p);</a>
<a name="ln2280">      // convert staffIdx from score-relative to part-relative</a>
<a name="ln2281">      int staffIdxPart = staffIdx - p-&gt;staff(0)-&gt;idx();</a>
<a name="ln2282">      undoInsertStaff(ns, staffIdxPart + 1, false);</a>
<a name="ln2283"> </a>
<a name="ln2284">      Clef* clef = new Clef(this);</a>
<a name="ln2285">      clef-&gt;setClefType(ClefType::F);</a>
<a name="ln2286">      clef-&gt;setTrack((staffIdx+1) * VOICES);</a>
<a name="ln2287">      Segment* seg = firstMeasure()-&gt;getSegment(SegmentType::HeaderClef, Fraction(0, 1));</a>
<a name="ln2288">      clef-&gt;setParent(seg);</a>
<a name="ln2289">      undoAddElement(clef);</a>
<a name="ln2290">      clef-&gt;layout();</a>
<a name="ln2291"> </a>
<a name="ln2292">      undoChangeKeySig(ns, Fraction(0, 1), st-&gt;keySigEvent(Fraction(0, 1)));</a>
<a name="ln2293"> </a>
<a name="ln2294">      masterScore()-&gt;rebuildMidiMapping();</a>
<a name="ln2295">      cmdState()._instrumentsChanged = true;</a>
<a name="ln2296">      doLayout();</a>
<a name="ln2297"> </a>
<a name="ln2298">      //</a>
<a name="ln2299">      // move notes</a>
<a name="ln2300">      //</a>
<a name="ln2301">      select(0, SelectType::SINGLE, 0);</a>
<a name="ln2302">      int strack = staffIdx * VOICES;</a>
<a name="ln2303">      int dtrack = (staffIdx + 1) * VOICES;</a>
<a name="ln2304"> </a>
<a name="ln2305">      for (Segment* s = firstSegment(SegmentType::ChordRest); s; s = s-&gt;next1(SegmentType::ChordRest)) {</a>
<a name="ln2306">            for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln2307">                  Element* e = s-&gt;element(strack + voice);</a>
<a name="ln2308">                  if (!(e &amp;&amp; e-&gt;isChord()))</a>
<a name="ln2309">                        continue;</a>
<a name="ln2310">                  Chord* c = toChord(e);</a>
<a name="ln2311">                  QList&lt;Note*&gt; removeNotes;</a>
<a name="ln2312">                  foreach(Note* note, c-&gt;notes()) {</a>
<a name="ln2313">                        if (note-&gt;pitch() &gt;= splitPoint)</a>
<a name="ln2314">                              continue;</a>
<a name="ln2315">                        Chord* chord = toChord(s-&gt;element(dtrack + voice));</a>
<a name="ln2316">                        Q_ASSERT(!chord || (chord-&gt;isChord()));</a>
<a name="ln2317">                        if (chord == 0) {</a>
<a name="ln2318">                              chord = new Chord(*c);</a>
<a name="ln2319">                              qDeleteAll(chord-&gt;notes());</a>
<a name="ln2320">                              chord-&gt;notes().clear();</a>
<a name="ln2321">                              chord-&gt;setTrack(dtrack + voice);</a>
<a name="ln2322">                              undoAddElement(chord);</a>
<a name="ln2323">                              }</a>
<a name="ln2324">                        Note* nnote = new Note(*note);</a>
<a name="ln2325">                        nnote-&gt;setTrack(dtrack + voice);</a>
<a name="ln2326">                        chord-&gt;add(nnote);</a>
<a name="ln2327">                        nnote-&gt;updateLine();</a>
<a name="ln2328">                        removeNotes.append(note);</a>
<a name="ln2329">                        }</a>
<a name="ln2330">                  c-&gt;sortNotes();</a>
<a name="ln2331">                  for (Note* note : removeNotes) {</a>
<a name="ln2332">                        undoRemoveElement(note);</a>
<a name="ln2333">                        Chord* chord = note-&gt;chord();</a>
<a name="ln2334">                        if (chord-&gt;notes().empty()) {</a>
<a name="ln2335">                              for (auto sp : spanner()) {</a>
<a name="ln2336">                                    Slur* slur = toSlur(sp.second);</a>
<a name="ln2337">                                    if (slur-&gt;type() != ElementType::SLUR)</a>
<a name="ln2338">                                          continue;</a>
<a name="ln2339">                                    if (slur-&gt;startCR() == chord) {</a>
<a name="ln2340">                                          slur-&gt;undoChangeProperty(Pid::TRACK, slur-&gt;track()+VOICES);</a>
<a name="ln2341">                                          for (ScoreElement* ee : slur-&gt;linkList()) {</a>
<a name="ln2342">                                                Slur* lslur = toSlur(ee);</a>
<a name="ln2343">                                                lslur-&gt;setStartElement(0);</a>
<a name="ln2344">                                                }</a>
<a name="ln2345">                                          }</a>
<a name="ln2346">                                    if (slur-&gt;endCR() == chord) {</a>
<a name="ln2347">                                          slur-&gt;undoChangeProperty(Pid::SPANNER_TRACK2, slur-&gt;track2()+VOICES);</a>
<a name="ln2348">                                          for (ScoreElement* ee : slur-&gt;linkList()) {</a>
<a name="ln2349">                                                Slur* lslur = toSlur(ee);</a>
<a name="ln2350">                                                lslur-&gt;setEndElement(0);</a>
<a name="ln2351">                                                }</a>
<a name="ln2352">                                          }</a>
<a name="ln2353">                                    }</a>
<a name="ln2354">                              undoRemoveElement(chord);</a>
<a name="ln2355">                              }</a>
<a name="ln2356">                        }</a>
<a name="ln2357">                  }</a>
<a name="ln2358">            }</a>
<a name="ln2359">      //</a>
<a name="ln2360">      // make sure that the timeline for dtrack</a>
<a name="ln2361">      // has no gaps</a>
<a name="ln2362">      //</a>
<a name="ln2363">      Fraction ctick  = Fraction(0,1);</a>
<a name="ln2364">      for (Measure* m = firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln2365">            for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next1(SegmentType::ChordRest)) {</a>
<a name="ln2366">                  ChordRest* cr = toChordRest(s-&gt;element(dtrack));</a>
<a name="ln2367">                  if (cr == 0)</a>
<a name="ln2368">                        continue;</a>
<a name="ln2369">                  Fraction rest = s-&gt;tick() - ctick;</a>
<a name="ln2370">                  if (rest.isNotZero()) {</a>
<a name="ln2371">                        // insert Rest</a>
<a name="ln2372">                        Segment* s1 = tick2segment(ctick);</a>
<a name="ln2373">                        if (s1 == 0) {</a>
<a name="ln2374">                              qDebug(&quot;no segment at %d&quot;, ctick.ticks());</a>
<a name="ln2375">                              continue;</a>
<a name="ln2376">                              }</a>
<a name="ln2377">                        setRest(ctick, dtrack, rest, false, 0);</a>
<a name="ln2378">                        }</a>
<a name="ln2379">                  ctick = s-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln2380">                  }</a>
<a name="ln2381">            Fraction rest = m-&gt;tick() + m-&gt;ticks() - ctick;</a>
<a name="ln2382">            if (rest.isNotZero()) {</a>
<a name="ln2383">                  setRest(ctick, dtrack, rest, false, 0);</a>
<a name="ln2384">                  ctick += rest;</a>
<a name="ln2385">                  }</a>
<a name="ln2386">            }</a>
<a name="ln2387">      //</a>
<a name="ln2388">      // same for strack</a>
<a name="ln2389">      //</a>
<a name="ln2390">      ctick  = Fraction(0,1);</a>
<a name="ln2391">      for (Measure* m = firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln2392">            for (Segment* s = m-&gt;first(SegmentType::ChordRest); s; s = s-&gt;next1(SegmentType::ChordRest)) {</a>
<a name="ln2393">                  ChordRest* cr = toChordRest(s-&gt;element(strack));</a>
<a name="ln2394">                  if (cr == 0)</a>
<a name="ln2395">                        continue;</a>
<a name="ln2396">                  Fraction rest = s-&gt;tick() - ctick;</a>
<a name="ln2397">                  if (rest.isNotZero()) {</a>
<a name="ln2398">                        // insert Rest</a>
<a name="ln2399">                        Segment* s1 = tick2segment(ctick);</a>
<a name="ln2400">                        if (s1 == 0) {</a>
<a name="ln2401">                              qDebug(&quot;no segment at %d&quot;, ctick.ticks());</a>
<a name="ln2402">                              continue;</a>
<a name="ln2403">                              }</a>
<a name="ln2404">                        setRest(ctick, strack, rest, false, 0);</a>
<a name="ln2405">                        }</a>
<a name="ln2406">                  ctick = s-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln2407">                  }</a>
<a name="ln2408">            Fraction rest = m-&gt;tick() + m-&gt;ticks() - ctick;</a>
<a name="ln2409">            if (rest.isNotZero()) {</a>
<a name="ln2410">                  setRest(ctick, strack, rest, false, 0);</a>
<a name="ln2411">                  ctick += rest;</a>
<a name="ln2412">                  }</a>
<a name="ln2413">            }</a>
<a name="ln2414">      }</a>
<a name="ln2415"> </a>
<a name="ln2416">//---------------------------------------------------------</a>
<a name="ln2417">//   cmdRemovePart</a>
<a name="ln2418">//---------------------------------------------------------</a>
<a name="ln2419"> </a>
<a name="ln2420">void Score::cmdRemovePart(Part* part)</a>
<a name="ln2421">      {</a>
<a name="ln2422">      int sidx   = staffIdx(part);</a>
<a name="ln2423">      int n      = part-&gt;nstaves();</a>
<a name="ln2424"> </a>
<a name="ln2425">      for (int i = 0; i &lt; n; ++i)</a>
<a name="ln2426">            cmdRemoveStaff(sidx);</a>
<a name="ln2427"> </a>
<a name="ln2428">      undoRemovePart(part, sidx);</a>
<a name="ln2429">      }</a>
<a name="ln2430"> </a>
<a name="ln2431">//---------------------------------------------------------</a>
<a name="ln2432">//   insertPart</a>
<a name="ln2433">//---------------------------------------------------------</a>
<a name="ln2434"> </a>
<a name="ln2435">void Score::insertPart(Part* part, int idx)</a>
<a name="ln2436">      {</a>
<a name="ln2437">      bool inserted = false;</a>
<a name="ln2438">      int staff = 0;</a>
<a name="ln2439">      for (QList&lt;Part*&gt;::iterator i = _parts.begin(); i != _parts.end(); ++i) {</a>
<a name="ln2440">            if (staff &gt;= idx) {</a>
<a name="ln2441">                  _parts.insert(i, part);</a>
<a name="ln2442">                  inserted = true;</a>
<a name="ln2443">                  break;</a>
<a name="ln2444">                  }</a>
<a name="ln2445">            staff += (*i)-&gt;nstaves();</a>
<a name="ln2446">            }</a>
<a name="ln2447">      if (!inserted)</a>
<a name="ln2448">            _parts.push_back(part);</a>
<a name="ln2449">      masterScore()-&gt;rebuildMidiMapping();</a>
<a name="ln2450">      setInstrumentsChanged(true);</a>
<a name="ln2451">      }</a>
<a name="ln2452"> </a>
<a name="ln2453">//---------------------------------------------------------</a>
<a name="ln2454">//   removePart</a>
<a name="ln2455">//---------------------------------------------------------</a>
<a name="ln2456"> </a>
<a name="ln2457">void Score::removePart(Part* part)</a>
<a name="ln2458">      {</a>
<a name="ln2459">      _parts.removeAt(_parts.indexOf(part));</a>
<a name="ln2460">      masterScore()-&gt;rebuildMidiMapping();</a>
<a name="ln2461">      setInstrumentsChanged(true);</a>
<a name="ln2462">      }</a>
<a name="ln2463"> </a>
<a name="ln2464">//---------------------------------------------------------</a>
<a name="ln2465">//   insertStaff</a>
<a name="ln2466">//---------------------------------------------------------</a>
<a name="ln2467"> </a>
<a name="ln2468">void Score::insertStaff(Staff* staff, int ridx)</a>
<a name="ln2469">      {</a>
<a name="ln2470">      staff-&gt;part()-&gt;insertStaff(staff, ridx);</a>
<a name="ln2471"> </a>
<a name="ln2472">      int idx = staffIdx(staff-&gt;part()) + ridx;</a>
<a name="ln2473">      _staves.insert(idx, staff);</a>
<a name="ln2474"> </a>
<a name="ln2475">      for (auto i = staff-&gt;score()-&gt;spanner().cbegin(); i != staff-&gt;score()-&gt;spanner().cend(); ++i) {</a>
<a name="ln2476">            Spanner* s = i-&gt;second;</a>
<a name="ln2477">            if (s-&gt;systemFlag())</a>
<a name="ln2478">                  continue;</a>
<a name="ln2479">            if (s-&gt;staffIdx() &gt;= idx) {</a>
<a name="ln2480">                  int t = s-&gt;track() + VOICES;</a>
<a name="ln2481">                  if (t &gt;= ntracks())</a>
<a name="ln2482">                        t = ntracks() - 1;</a>
<a name="ln2483">                  s-&gt;setTrack(t);</a>
<a name="ln2484">                  for (SpannerSegment* ss : s-&gt;spannerSegments())</a>
<a name="ln2485">                        ss-&gt;setTrack(t);</a>
<a name="ln2486">                  if (s-&gt;track2() != -1) {</a>
<a name="ln2487">                        t = s-&gt;track2() + VOICES;</a>
<a name="ln2488">                        s-&gt;setTrack2(t &lt; ntracks() ? t : s-&gt;track());</a>
<a name="ln2489">                        }</a>
<a name="ln2490">                  }</a>
<a name="ln2491">            }</a>
<a name="ln2492">#if 0</a>
<a name="ln2493">      for (Spanner* s : staff-&gt;score()-&gt;unmanagedSpanners()) {</a>
<a name="ln2494">            if (s-&gt;systemFlag())</a>
<a name="ln2495">                  continue;</a>
<a name="ln2496">            if (s-&gt;staffIdx() &gt;= idx) {</a>
<a name="ln2497">                  int t = s-&gt;track() + VOICES;</a>
<a name="ln2498">                  s-&gt;setTrack(t &lt; ntracks() ? t : ntracks() - 1);</a>
<a name="ln2499">                  if (s-&gt;track2() != -1) {</a>
<a name="ln2500">                        t = s-&gt;track2() + VOICES;</a>
<a name="ln2501">                        s-&gt;setTrack2(t &lt; ntracks() ? t : s-&gt;track());</a>
<a name="ln2502">                        }</a>
<a name="ln2503">                  }</a>
<a name="ln2504">            }</a>
<a name="ln2505">#endif</a>
<a name="ln2506">      }</a>
<a name="ln2507"> </a>
<a name="ln2508">//---------------------------------------------------------</a>
<a name="ln2509">//   removeStaff</a>
<a name="ln2510">//---------------------------------------------------------</a>
<a name="ln2511"> </a>
<a name="ln2512">void Score::removeStaff(Staff* staff)</a>
<a name="ln2513">      {</a>
<a name="ln2514">      int idx = staff-&gt;idx();</a>
<a name="ln2515">      for (auto i = staff-&gt;score()-&gt;spanner().cbegin(); i != staff-&gt;score()-&gt;spanner().cend(); ++i) {</a>
<a name="ln2516">            Spanner* s = i-&gt;second;</a>
<a name="ln2517">            if (s-&gt;staffIdx() &gt; idx) {</a>
<a name="ln2518">                  int t = s-&gt;track() - VOICES;</a>
<a name="ln2519">                  if (t &lt; 0)</a>
<a name="ln2520">                        t = 0;</a>
<a name="ln2521">                  s-&gt;setTrack(t);</a>
<a name="ln2522">                  for (SpannerSegment* ss : s-&gt;spannerSegments())</a>
<a name="ln2523">                        ss-&gt;setTrack(t);</a>
<a name="ln2524">                  if (s-&gt;track2() != -1) {</a>
<a name="ln2525">                        t = s-&gt;track2() - VOICES;</a>
<a name="ln2526">                        s-&gt;setTrack2(t &gt;= 0 ? t : s-&gt;track());</a>
<a name="ln2527">                        }</a>
<a name="ln2528">                  }</a>
<a name="ln2529">            }</a>
<a name="ln2530">#if 0</a>
<a name="ln2531">      for (Spanner* s : staff-&gt;score()-&gt;unmanagedSpanners()) {</a>
<a name="ln2532">            if (s-&gt;staffIdx() &gt; idx) {</a>
<a name="ln2533">                  int t = s-&gt;track() - VOICES;</a>
<a name="ln2534">                  s-&gt;setTrack(t &gt;= 0 ? t : 0);</a>
<a name="ln2535">                  if (s-&gt;track2() != -1) {</a>
<a name="ln2536">                        t = s-&gt;track2() - VOICES;</a>
<a name="ln2537">                        s-&gt;setTrack2(t &gt;= 0 ? t : s-&gt;track());</a>
<a name="ln2538">                        }</a>
<a name="ln2539">                  }</a>
<a name="ln2540">            }</a>
<a name="ln2541">#endif</a>
<a name="ln2542">      _staves.removeAll(staff);</a>
<a name="ln2543">      staff-&gt;part()-&gt;removeStaff(staff);</a>
<a name="ln2544">      }</a>
<a name="ln2545"> </a>
<a name="ln2546">//---------------------------------------------------------</a>
<a name="ln2547">//   adjustBracketsDel</a>
<a name="ln2548">//---------------------------------------------------------</a>
<a name="ln2549"> </a>
<a name="ln2550">void Score::adjustBracketsDel(int sidx, int eidx)</a>
<a name="ln2551">      {</a>
<a name="ln2552">      for (int staffIdx = 0; staffIdx &lt; _staves.size(); ++staffIdx) {</a>
<a name="ln2553">            Staff* staff = _staves[staffIdx];</a>
<a name="ln2554">            for (BracketItem* bi : staff-&gt;brackets()) {</a>
<a name="ln2555">                  int span = bi-&gt;bracketSpan();</a>
<a name="ln2556">                  if ((span == 0) || ((staffIdx + span) &lt; sidx) || (staffIdx &gt; eidx))</a>
<a name="ln2557">                        continue;</a>
<a name="ln2558">                  if ((sidx &gt;= staffIdx) &amp;&amp; (eidx &lt;= (staffIdx + span)))</a>
<a name="ln2559">                        bi-&gt;undoChangeProperty(Pid::BRACKET_SPAN, span - (eidx-sidx));</a>
<a name="ln2560">                  }</a>
<a name="ln2561">#if 0 // TODO</a>
<a name="ln2562">            int span = staff-&gt;barLineSpan();</a>
<a name="ln2563">            if ((sidx &gt;= staffIdx) &amp;&amp; (eidx &lt;= (staffIdx + span))) {</a>
<a name="ln2564">                  int newSpan = span - (eidx-sidx) + 1;</a>
<a name="ln2565">                  int lastSpannedStaffIdx = staffIdx + newSpan - 1;</a>
<a name="ln2566">                  int tick = 0;</a>
<a name="ln2567">                  undoChangeBarLineSpan(staff, newSpan, 0, (_staves[lastSpannedStaffIdx]-&gt;lines(0)-1)*2);</a>
<a name="ln2568">                  }</a>
<a name="ln2569">#endif</a>
<a name="ln2570">            }</a>
<a name="ln2571">      }</a>
<a name="ln2572"> </a>
<a name="ln2573">//---------------------------------------------------------</a>
<a name="ln2574">//   adjustBracketsIns</a>
<a name="ln2575">//---------------------------------------------------------</a>
<a name="ln2576"> </a>
<a name="ln2577">void Score::adjustBracketsIns(int sidx, int eidx)</a>
<a name="ln2578">      {</a>
<a name="ln2579">      for (int staffIdx = 0; staffIdx &lt; _staves.size(); ++staffIdx) {</a>
<a name="ln2580">            Staff* staff = _staves[staffIdx];</a>
<a name="ln2581">            for (BracketItem* bi : staff-&gt;brackets()) {</a>
<a name="ln2582">                  int span = bi-&gt;bracketSpan();</a>
<a name="ln2583">                  if ((span == 0) || ((staffIdx + span) &lt; sidx) || (staffIdx &gt; eidx))</a>
<a name="ln2584">                        continue;</a>
<a name="ln2585">                  if ((sidx &gt;= staffIdx) &amp;&amp; (eidx &lt; (staffIdx + span)))</a>
<a name="ln2586">                        bi-&gt;undoChangeProperty(Pid::BRACKET_SPAN, span + (eidx-sidx));</a>
<a name="ln2587">                  }</a>
<a name="ln2588">#if 0 // TODO</a>
<a name="ln2589">            int span = staff-&gt;barLineSpan();</a>
<a name="ln2590">            if ((sidx &gt;= staffIdx) &amp;&amp; (eidx &lt; (staffIdx + span))) {</a>
<a name="ln2591">                  int idx = staffIdx + span - 1;</a>
<a name="ln2592">                  if (idx &gt;= _staves.size())</a>
<a name="ln2593">                        idx = _staves.size() - 1;</a>
<a name="ln2594">                  undoChangeBarLineSpan(staff, span, 0, (_staves[idx]-&gt;lines()-1)*2);</a>
<a name="ln2595">                  }</a>
<a name="ln2596">#endif</a>
<a name="ln2597">            }</a>
<a name="ln2598">      }</a>
<a name="ln2599"> </a>
<a name="ln2600">//---------------------------------------------------------</a>
<a name="ln2601">//   adjustKeySigs</a>
<a name="ln2602">//---------------------------------------------------------</a>
<a name="ln2603"> </a>
<a name="ln2604">void Score::adjustKeySigs(int sidx, int eidx, KeyList km)</a>
<a name="ln2605">      {</a>
<a name="ln2606">      for (int staffIdx = sidx; staffIdx &lt; eidx; ++staffIdx) {</a>
<a name="ln2607">            Staff* staff = _staves[staffIdx];</a>
<a name="ln2608">            for (auto i = km.begin(); i != km.end(); ++i) {</a>
<a name="ln2609">                  Fraction tick = Fraction::fromTicks(i-&gt;first);</a>
<a name="ln2610">                  Measure* measure = tick2measure(tick);</a>
<a name="ln2611">                  if (!measure)</a>
<a name="ln2612">                        continue;</a>
<a name="ln2613">                  if (staff-&gt;isDrumStaff(tick))</a>
<a name="ln2614">                        continue;</a>
<a name="ln2615">                  KeySigEvent oKey = i-&gt;second;</a>
<a name="ln2616">                  KeySigEvent nKey = oKey;</a>
<a name="ln2617">                  int diff = -staff-&gt;part()-&gt;instrument(tick)-&gt;transpose().chromatic;</a>
<a name="ln2618">                  if (diff != 0 &amp;&amp; !styleB(Sid::concertPitch) &amp;&amp; !oKey.custom() &amp;&amp; !oKey.isAtonal())</a>
<a name="ln2619">                        nKey.setKey(transposeKey(nKey.key(), diff, staff-&gt;part()-&gt;preferSharpFlat()));</a>
<a name="ln2620">                  staff-&gt;setKey(tick, nKey);</a>
<a name="ln2621">                  KeySig* keysig = new KeySig(this);</a>
<a name="ln2622">                  keysig-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln2623">                  keysig-&gt;setKeySigEvent(nKey);</a>
<a name="ln2624">                  Segment* s = measure-&gt;getSegment(SegmentType::KeySig, tick);</a>
<a name="ln2625">                  s-&gt;add(keysig);</a>
<a name="ln2626">                  }</a>
<a name="ln2627">            }</a>
<a name="ln2628">      }</a>
<a name="ln2629"> </a>
<a name="ln2630">//---------------------------------------------------------</a>
<a name="ln2631">//   cmdRemoveStaff</a>
<a name="ln2632">//---------------------------------------------------------</a>
<a name="ln2633"> </a>
<a name="ln2634">void Score::cmdRemoveStaff(int staffIdx)</a>
<a name="ln2635">      {</a>
<a name="ln2636">      Staff* s = staff(staffIdx);</a>
<a name="ln2637">      adjustBracketsDel(staffIdx, staffIdx+1);</a>
<a name="ln2638"> </a>
<a name="ln2639">      undoRemoveStaff(s);</a>
<a name="ln2640"> </a>
<a name="ln2641">      // remove linked staff and measures in linked staves in excerpts</a>
<a name="ln2642">      // unlink staff in the same score</a>
<a name="ln2643"> </a>
<a name="ln2644">      if (s-&gt;links()) {</a>
<a name="ln2645">            Staff* sameScoreLinkedStaff = 0;</a>
<a name="ln2646">            auto staves = s-&gt;links();</a>
<a name="ln2647">            for (auto le : *staves) {</a>
<a name="ln2648">                  Staff* staff = toStaff(le);</a>
<a name="ln2649">                  if (staff == s)</a>
<a name="ln2650">                        continue;</a>
<a name="ln2651">                  Score* lscore = staff-&gt;score();</a>
<a name="ln2652">                  if (lscore != this) {</a>
<a name="ln2653">                        lscore-&gt;undoRemoveStaff(staff);</a>
<a name="ln2654">                        s-&gt;score()-&gt;undo(new Unlink(staff));</a>
<a name="ln2655">                        if (staff-&gt;part()-&gt;nstaves() == 0) {</a>
<a name="ln2656">                              int pIndex    = lscore-&gt;staffIdx(staff-&gt;part());</a>
<a name="ln2657">                              lscore-&gt;undoRemovePart(staff-&gt;part(), pIndex);</a>
<a name="ln2658">                              }</a>
<a name="ln2659">                        }</a>
<a name="ln2660">                  else // linked staff in the same score</a>
<a name="ln2661">                       sameScoreLinkedStaff = staff;</a>
<a name="ln2662">                  }</a>
<a name="ln2663">            if (sameScoreLinkedStaff)</a>
<a name="ln2664">//                  s-&gt;score()-&gt;undo(new Unlink(sameScoreLinkedStaff)); // once should be enough</a>
<a name="ln2665">                  s-&gt;score()-&gt;undo(new Unlink(s)); // once should be enough</a>
<a name="ln2666">            }</a>
<a name="ln2667">      }</a>
<a name="ln2668"> </a>
<a name="ln2669">//---------------------------------------------------------</a>
<a name="ln2670">//   sortStaves</a>
<a name="ln2671">//---------------------------------------------------------</a>
<a name="ln2672"> </a>
<a name="ln2673">void Score::sortStaves(QList&lt;int&gt;&amp; dst)</a>
<a name="ln2674">      {</a>
<a name="ln2675">      qDeleteAll(systems());</a>
<a name="ln2676">      systems().clear();  //??</a>
<a name="ln2677">      _parts.clear();</a>
<a name="ln2678">      Part* curPart = 0;</a>
<a name="ln2679">      QList&lt;Staff*&gt; dl;</a>
<a name="ln2680">      foreach (int idx, dst) {</a>
<a name="ln2681">            Staff* staff = _staves[idx];</a>
<a name="ln2682">            if (staff-&gt;part() != curPart) {</a>
<a name="ln2683">                  curPart = staff-&gt;part();</a>
<a name="ln2684">                  curPart-&gt;staves()-&gt;clear();</a>
<a name="ln2685">                  _parts.push_back(curPart);</a>
<a name="ln2686">                  }</a>
<a name="ln2687">            curPart-&gt;staves()-&gt;push_back(staff);</a>
<a name="ln2688">            dl.push_back(staff);</a>
<a name="ln2689">            }</a>
<a name="ln2690">      _staves = dl;</a>
<a name="ln2691"> </a>
<a name="ln2692">      for (Measure* m = firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln2693">            m-&gt;sortStaves(dst);</a>
<a name="ln2694">            if (m-&gt;hasMMRest())</a>
<a name="ln2695">                  m-&gt;mmRest()-&gt;sortStaves(dst);</a>
<a name="ln2696">            }</a>
<a name="ln2697">      for (auto i : _spanner.map()) {</a>
<a name="ln2698">            Spanner* sp = i.second;</a>
<a name="ln2699">            if (sp-&gt;systemFlag())</a>
<a name="ln2700">                  continue;</a>
<a name="ln2701">            int voice    = sp-&gt;voice();</a>
<a name="ln2702">            int staffIdx = sp-&gt;staffIdx();</a>
<a name="ln2703">            int idx = dst.indexOf(staffIdx);</a>
<a name="ln2704">            if (idx &gt;=0) {</a>
<a name="ln2705">                  sp-&gt;setTrack(idx * VOICES + voice);</a>
<a name="ln2706">                  if (sp-&gt;track2() != -1)</a>
<a name="ln2707">                        sp-&gt;setTrack2(idx * VOICES +(sp-&gt;track2() % VOICES)); // at least keep the voice...</a>
<a name="ln2708">                  }</a>
<a name="ln2709">            }</a>
<a name="ln2710">      setLayoutAll();</a>
<a name="ln2711">      }</a>
<a name="ln2712"> </a>
<a name="ln2713">//---------------------------------------------------------</a>
<a name="ln2714">//   cmdConcertPitchChanged</a>
<a name="ln2715">//---------------------------------------------------------</a>
<a name="ln2716"> </a>
<a name="ln2717">void Score::cmdConcertPitchChanged(bool flag, bool /*useDoubleSharpsFlats*/)</a>
<a name="ln2718">      {</a>
<a name="ln2719">      undoChangeStyleVal(Sid::concertPitch, flag);       // change style flag</a>
<a name="ln2720"> </a>
<a name="ln2721">      for (Staff* staff : _staves) {</a>
<a name="ln2722">            if (staff-&gt;staffType(Fraction(0,1))-&gt;group() == StaffGroup::PERCUSSION)       // TODO</a>
<a name="ln2723">                  continue;</a>
<a name="ln2724">            // if this staff has no transposition, and no instrument changes, we can skip it</a>
<a name="ln2725">            Interval interval = staff-&gt;part()-&gt;instrument()-&gt;transpose();</a>
<a name="ln2726">            if (interval.isZero() &amp;&amp; staff-&gt;part()-&gt;instruments()-&gt;size() == 1)</a>
<a name="ln2727">                  continue;</a>
<a name="ln2728">            if (!flag)</a>
<a name="ln2729">                  interval.flip();</a>
<a name="ln2730"> </a>
<a name="ln2731">            int staffIdx   = staff-&gt;idx();</a>
<a name="ln2732">            int startTrack = staffIdx * VOICES;</a>
<a name="ln2733">            int endTrack   = startTrack + VOICES;</a>
<a name="ln2734"> </a>
<a name="ln2735">            transposeKeys(staffIdx, staffIdx + 1, Fraction(0,1), lastSegment()-&gt;tick(), interval, true, !flag);</a>
<a name="ln2736"> </a>
<a name="ln2737">            for (Segment* segment = firstSegment(SegmentType::ChordRest); segment; segment = segment-&gt;next1(SegmentType::ChordRest)) {</a>
<a name="ln2738">                  interval = staff-&gt;part()-&gt;instrument(segment-&gt;tick())-&gt;transpose();</a>
<a name="ln2739">                  if (!flag)</a>
<a name="ln2740">                        interval.flip();</a>
<a name="ln2741">                  for (Element* e : segment-&gt;annotations()) {</a>
<a name="ln2742">                        if (!e-&gt;isHarmony() || (e-&gt;track() &lt; startTrack) || (e-&gt;track() &gt;= endTrack))</a>
<a name="ln2743">                              continue;</a>
<a name="ln2744">                        Harmony* h  = toHarmony(e);</a>
<a name="ln2745">                        int rootTpc = transposeTpc(h-&gt;rootTpc(), interval, true);</a>
<a name="ln2746">                        int baseTpc = transposeTpc(h-&gt;baseTpc(), interval, true);</a>
<a name="ln2747">                        for (ScoreElement* se : h-&gt;linkList()) {</a>
<a name="ln2748">                              // don't transpose all links</a>
<a name="ln2749">                              // just ones resulting from mmrests</a>
<a name="ln2750">                              Harmony* he = toHarmony(se);    // toHarmony() does not work as e is an ScoreElement</a>
<a name="ln2751">                              if (he-&gt;staff() == h-&gt;staff())</a>
<a name="ln2752">                                    undoTransposeHarmony(he, rootTpc, baseTpc);</a>
<a name="ln2753">                              }</a>
<a name="ln2754">                        }</a>
<a name="ln2755">                  }</a>
<a name="ln2756">            }</a>
<a name="ln2757">      }</a>
<a name="ln2758"> </a>
<a name="ln2759">//---------------------------------------------------------</a>
<a name="ln2760">//   addAudioTrack</a>
<a name="ln2761">//---------------------------------------------------------</a>
<a name="ln2762"> </a>
<a name="ln2763">void Score::addAudioTrack()</a>
<a name="ln2764">      {</a>
<a name="ln2765">      // TODO</a>
<a name="ln2766">      }</a>
<a name="ln2767"> </a>
<a name="ln2768">//---------------------------------------------------------</a>
<a name="ln2769">//   padToggle</a>
<a name="ln2770">//---------------------------------------------------------</a>
<a name="ln2771"> </a>
<a name="ln2772">void Score::padToggle(Pad n, const EditData&amp; ed)</a>
<a name="ln2773">      {</a>
<a name="ln2774">      int oldDots = _is.duration().dots();</a>
<a name="ln2775">      switch (n) {</a>
<a name="ln2776">            case Pad::NOTE00:</a>
<a name="ln2777">                  _is.setDuration(TDuration::DurationType::V_LONG);</a>
<a name="ln2778">                  break;</a>
<a name="ln2779">            case Pad::NOTE0:</a>
<a name="ln2780">                  _is.setDuration(TDuration::DurationType::V_BREVE);</a>
<a name="ln2781">                  break;</a>
<a name="ln2782">            case Pad::NOTE1:</a>
<a name="ln2783">                  _is.setDuration(TDuration::DurationType::V_WHOLE);</a>
<a name="ln2784">                  break;</a>
<a name="ln2785">            case Pad::NOTE2:</a>
<a name="ln2786">                  _is.setDuration(TDuration::DurationType::V_HALF);</a>
<a name="ln2787">                  break;</a>
<a name="ln2788">            case Pad::NOTE4:</a>
<a name="ln2789">                  _is.setDuration(TDuration::DurationType::V_QUARTER);</a>
<a name="ln2790">                  break;</a>
<a name="ln2791">            case Pad::NOTE8:</a>
<a name="ln2792">                  _is.setDuration(TDuration::DurationType::V_EIGHTH);</a>
<a name="ln2793">                  break;</a>
<a name="ln2794">            case Pad::NOTE16:</a>
<a name="ln2795">                  _is.setDuration(TDuration::DurationType::V_16TH);</a>
<a name="ln2796">                  break;</a>
<a name="ln2797">            case Pad::NOTE32:</a>
<a name="ln2798">                  _is.setDuration(TDuration::DurationType::V_32ND);</a>
<a name="ln2799">                  break;</a>
<a name="ln2800">            case Pad::NOTE64:</a>
<a name="ln2801">                  _is.setDuration(TDuration::DurationType::V_64TH);</a>
<a name="ln2802">                  break;</a>
<a name="ln2803">            case Pad::NOTE128:</a>
<a name="ln2804">                  _is.setDuration(TDuration::DurationType::V_128TH);</a>
<a name="ln2805">                  break;</a>
<a name="ln2806">            case Pad::REST:</a>
<a name="ln2807">                  if (noteEntryMode()) {</a>
<a name="ln2808">                        _is.setRest(!_is.rest());</a>
<a name="ln2809">                        _is.setAccidentalType(AccidentalType::NONE);</a>
<a name="ln2810">                        }</a>
<a name="ln2811">                  else if (selection().isNone()) {</a>
<a name="ln2812">                        ed.view-&gt;startNoteEntryMode();</a>
<a name="ln2813">                        _is.setDuration(TDuration::DurationType::V_QUARTER);</a>
<a name="ln2814">                        _is.setRest(true);</a>
<a name="ln2815">                        }</a>
<a name="ln2816">                  else {</a>
<a name="ln2817">                        for (ChordRest* cr : getSelectedChordRests()) {</a>
<a name="ln2818">                              if (!cr-&gt;isRest())</a>
<a name="ln2819">                                    setNoteRest(cr-&gt;segment(), cr-&gt;track(), NoteVal(), cr-&gt;durationTypeTicks());</a>
<a name="ln2820">                              }</a>
<a name="ln2821">                        }</a>
<a name="ln2822">                  break;</a>
<a name="ln2823">            case Pad::DOT:</a>
<a name="ln2824">                  if ((_is.duration().dots() == 1) || (_is.duration() == TDuration::DurationType::V_1024TH))</a>
<a name="ln2825">                        _is.setDots(0);</a>
<a name="ln2826">                  else</a>
<a name="ln2827">                        _is.setDots(1);</a>
<a name="ln2828">                  break;</a>
<a name="ln2829">            case Pad::DOTDOT:</a>
<a name="ln2830">                  if ((_is.duration().dots() == 2)</a>
<a name="ln2831">                     || (_is.duration() == TDuration::DurationType::V_512TH)</a>
<a name="ln2832">                     || (_is.duration() == TDuration::DurationType::V_1024TH))</a>
<a name="ln2833">                        _is.setDots(0);</a>
<a name="ln2834">                  else</a>
<a name="ln2835">                        _is.setDots(2);</a>
<a name="ln2836">                  break;</a>
<a name="ln2837">            case Pad::DOT3:</a>
<a name="ln2838">                  if ((_is.duration().dots() == 3)</a>
<a name="ln2839">                     || (_is.duration() == TDuration::DurationType::V_256TH)</a>
<a name="ln2840">                     || (_is.duration() == TDuration::DurationType::V_512TH)</a>
<a name="ln2841">                     || (_is.duration() == TDuration::DurationType::V_1024TH))</a>
<a name="ln2842">                        _is.setDots(0);</a>
<a name="ln2843">                  else</a>
<a name="ln2844">                        _is.setDots(3);</a>
<a name="ln2845">                  break;</a>
<a name="ln2846">            case Pad::DOT4:</a>
<a name="ln2847">                  if ((_is.duration().dots() == 4)</a>
<a name="ln2848">                     || (_is.duration() == TDuration::DurationType::V_128TH)</a>
<a name="ln2849">                     || (_is.duration() == TDuration::DurationType::V_256TH)</a>
<a name="ln2850">                     || (_is.duration() == TDuration::DurationType::V_512TH)</a>
<a name="ln2851">                     || (_is.duration() == TDuration::DurationType::V_1024TH))</a>
<a name="ln2852">                        _is.setDots(0);</a>
<a name="ln2853">                  else</a>
<a name="ln2854">                        _is.setDots(4);</a>
<a name="ln2855">                  break;</a>
<a name="ln2856">            }</a>
<a name="ln2857">      if (n &gt;= Pad::NOTE00 &amp;&amp; n &lt;= Pad::NOTE128) {</a>
<a name="ln2858">            _is.setDots(0);</a>
<a name="ln2859">            //</a>
<a name="ln2860">            // if in &quot;note enter&quot; mode, reset</a>
<a name="ln2861">            // rest flag</a>
<a name="ln2862">            //</a>
<a name="ln2863">            if (noteEntryMode()) {</a>
<a name="ln2864">                  if (usingNoteEntryMethod(NoteEntryMethod::RHYTHM)) {</a>
<a name="ln2865">                        switch (oldDots) {</a>
<a name="ln2866">                              case 1:</a>
<a name="ln2867">                                    padToggle(Pad::DOT, ed);</a>
<a name="ln2868">                                    break;</a>
<a name="ln2869">                              case 2:</a>
<a name="ln2870">                                    padToggle(Pad::DOTDOT, ed);</a>
<a name="ln2871">                                    break;</a>
<a name="ln2872">                              }</a>
<a name="ln2873">                        NoteVal nval;</a>
<a name="ln2874">                        if (_is.rest()) {</a>
<a name="ln2875">                              // Enter a rest</a>
<a name="ln2876">                              nval = NoteVal();</a>
<a name="ln2877">                              }</a>
<a name="ln2878">                        else {</a>
<a name="ln2879">                              // Enter a note on the middle staff line</a>
<a name="ln2880">                              Staff* s = staff(_is.track() / VOICES);</a>
<a name="ln2881">                              Fraction tick = _is.tick();</a>
<a name="ln2882">                              ClefType clef = s-&gt;clef(tick);</a>
<a name="ln2883">                              Key key = s-&gt;key(tick);</a>
<a name="ln2884">                              nval = NoteVal(line2pitch(4, clef, key));</a>
<a name="ln2885">                              }</a>
<a name="ln2886">                        setNoteRest(_is.segment(), _is.track(), nval, _is.duration().fraction());</a>
<a name="ln2887">                        _is.moveToNextInputPos();</a>
<a name="ln2888">                        }</a>
<a name="ln2889">                  else</a>
<a name="ln2890">                        _is.setRest(false);</a>
<a name="ln2891">                  }</a>
<a name="ln2892">            }</a>
<a name="ln2893"> </a>
<a name="ln2894">      if (noteEntryMode())</a>
<a name="ln2895">            return;</a>
<a name="ln2896"> </a>
<a name="ln2897">      std::vector&lt;ChordRest*&gt; crs;</a>
<a name="ln2898"> </a>
<a name="ln2899">      if (selection().isSingle()) {</a>
<a name="ln2900">            Element* e = selection().element();</a>
<a name="ln2901">            ChordRest* cr = InputState::chordRest(e);</a>
<a name="ln2902"> </a>
<a name="ln2903">            // do not allow to add a dot on a full measure rest</a>
<a name="ln2904">            if (cr &amp;&amp; cr-&gt;isRest()) {</a>
<a name="ln2905">                  Rest* r = toRest(cr);</a>
<a name="ln2906">                  if (r-&gt;isFullMeasureRest())</a>
<a name="ln2907">                        _is.setDots(0);</a>
<a name="ln2908">                  }</a>
<a name="ln2909"> </a>
<a name="ln2910">            // on measure rest, select the first actual rest</a>
<a name="ln2911">            if (cr &amp;&amp; cr-&gt;isRest() &amp;&amp; cr-&gt;measure()-&gt;isMMRest()) {</a>
<a name="ln2912">                  Measure* m = cr-&gt;measure()-&gt;mmRestFirst();</a>
<a name="ln2913">                  if (m)</a>
<a name="ln2914">                        cr = m-&gt;findChordRest(m-&gt;tick(), 0);</a>
<a name="ln2915">                  }</a>
<a name="ln2916"> </a>
<a name="ln2917">            if (cr) {</a>
<a name="ln2918">                  crs.push_back(cr);</a>
<a name="ln2919">                  }</a>
<a name="ln2920">            else {</a>
<a name="ln2921">                  ed.view-&gt;startNoteEntryMode();</a>
<a name="ln2922">                  deselect(e);</a>
<a name="ln2923">                  }</a>
<a name="ln2924">            }</a>
<a name="ln2925">      else if (selection().isNone() &amp;&amp; n != Pad::REST) {</a>
<a name="ln2926">            TDuration td = _is.duration();</a>
<a name="ln2927">            ed.view-&gt;startNoteEntryMode();</a>
<a name="ln2928">            _is.setDuration(td);</a>
<a name="ln2929">            _is.setAccidentalType(AccidentalType::NONE);</a>
<a name="ln2930">            }</a>
<a name="ln2931">      else {</a>
<a name="ln2932">            const auto elements = selection().uniqueElements();</a>
<a name="ln2933">            bool canAdjustLength = true;</a>
<a name="ln2934">            for (Element* e : elements) {</a>
<a name="ln2935">                  ChordRest* cr = InputState::chordRest(e);</a>
<a name="ln2936">                  if (!cr)</a>
<a name="ln2937">                        continue;</a>
<a name="ln2938">                  if (cr-&gt;isRepeatMeasure() || (cr-&gt;isRest() &amp;&amp; toRest(cr)-&gt;measure() &amp;&amp; toRest(cr)-&gt;measure()-&gt;isMMRest())) {</a>
<a name="ln2939">                        canAdjustLength = false;</a>
<a name="ln2940">                        break;</a>
<a name="ln2941">                        }</a>
<a name="ln2942">                  crs.push_back(cr);</a>
<a name="ln2943">                  }</a>
<a name="ln2944"> </a>
<a name="ln2945">            if (canAdjustLength) {</a>
<a name="ln2946">                  // Change length from last to first chord/rest</a>
<a name="ln2947">                  std::sort(crs.begin(), crs.end(), [](const ChordRest* cr1, const ChordRest* cr2) {</a>
<a name="ln2948">                        if (cr2-&gt;track() == cr1-&gt;track())</a>
<a name="ln2949">                              return cr2-&gt;isBefore(cr1);</a>
<a name="ln2950">                        return cr2-&gt;track() &lt; cr1-&gt;track();</a>
<a name="ln2951">                        });</a>
<a name="ln2952">                  // Remove duplicates from the list</a>
<a name="ln2953">                  crs.erase(std::unique(crs.begin(), crs.end()), crs.end());</a>
<a name="ln2954">                  }</a>
<a name="ln2955">            else</a>
<a name="ln2956">                  crs.clear();</a>
<a name="ln2957">            }</a>
<a name="ln2958"> </a>
<a name="ln2959">      for (ChordRest* cr : crs) {</a>
<a name="ln2960">            if (cr-&gt;isChord() &amp;&amp; (toChord(cr)-&gt;isGrace())) {</a>
<a name="ln2961">                  //</a>
<a name="ln2962">                  // handle appoggiatura and acciaccatura</a>
<a name="ln2963">                  //</a>
<a name="ln2964">                  undoChangeChordRestLen(cr, _is.duration());</a>
<a name="ln2965">                  }</a>
<a name="ln2966">            else</a>
<a name="ln2967">                  changeCRlen(cr, _is.duration());</a>
<a name="ln2968">            }</a>
<a name="ln2969">      }</a>
<a name="ln2970"> </a>
<a name="ln2971">//---------------------------------------------------------</a>
<a name="ln2972">//   deselect</a>
<a name="ln2973">//---------------------------------------------------------</a>
<a name="ln2974"> </a>
<a name="ln2975">void Score::deselect(Element* el)</a>
<a name="ln2976">      {</a>
<a name="ln2977">      addRefresh(el-&gt;abbox());</a>
<a name="ln2978">      _selection.remove(el);</a>
<a name="ln2979">      setSelectionChanged(true);</a>
<a name="ln2980">      _selection.update();</a>
<a name="ln2981">      }</a>
<a name="ln2982"> </a>
<a name="ln2983">//---------------------------------------------------------</a>
<a name="ln2984">//   select</a>
<a name="ln2985">//    staffIdx is valid, if element is of type MEASURE</a>
<a name="ln2986">//---------------------------------------------------------</a>
<a name="ln2987"> </a>
<a name="ln2988">void Score::select(Element* e, SelectType type, int staffIdx)</a>
<a name="ln2989">      {</a>
<a name="ln2990">      if (e &amp;&amp; (e-&gt;isNote() || e-&gt;isRest())) {</a>
<a name="ln2991">            Element* ee = e;</a>
<a name="ln2992">            if (ee-&gt;isNote())</a>
<a name="ln2993">                  ee = ee-&gt;parent();</a>
<a name="ln2994">            Fraction tick = toChordRest(ee)-&gt;segment()-&gt;tick();</a>
<a name="ln2995">            if (masterScore()-&gt;playPos() != tick)</a>
<a name="ln2996">                  masterScore()-&gt;setPlayPos(tick);</a>
<a name="ln2997">            }</a>
<a name="ln2998">      if (MScore::debugMode)</a>
<a name="ln2999">            qDebug(&quot;select element &lt;%s&gt; type %d(state %d) staff %d&quot;,</a>
<a name="ln3000">               e ? e-&gt;name() : &quot;&quot;, int(type), int(selection().state()), e ? e-&gt;staffIdx() : -1);</a>
<a name="ln3001"> </a>
<a name="ln3002">      switch (type) {</a>
<a name="ln3003">            case SelectType::SINGLE:</a>
<a name="ln3004">                  selectSingle(e, staffIdx);</a>
<a name="ln3005">                  break;</a>
<a name="ln3006">            case SelectType::ADD:</a>
<a name="ln3007">                  selectAdd(e);</a>
<a name="ln3008">                  break;</a>
<a name="ln3009">            case SelectType::RANGE:</a>
<a name="ln3010">                  selectRange(e, staffIdx);</a>
<a name="ln3011">                  break;</a>
<a name="ln3012">            }</a>
<a name="ln3013">      setSelectionChanged(true);</a>
<a name="ln3014">      }</a>
<a name="ln3015"> </a>
<a name="ln3016">//---------------------------------------------------------</a>
<a name="ln3017">//   selectSingle</a>
<a name="ln3018">//    staffIdx is valid, if element is of type MEASURE</a>
<a name="ln3019">//---------------------------------------------------------</a>
<a name="ln3020"> </a>
<a name="ln3021">void Score::selectSingle(Element* e, int staffIdx)</a>
<a name="ln3022">      {</a>
<a name="ln3023">      SelState selState = _selection.state();</a>
<a name="ln3024">      deselectAll();</a>
<a name="ln3025">      if (e == 0) {</a>
<a name="ln3026">            selState = SelState::NONE;</a>
<a name="ln3027">            setUpdateAll();</a>
<a name="ln3028">            }</a>
<a name="ln3029">      else {</a>
<a name="ln3030">            if (e-&gt;isMeasure()) {</a>
<a name="ln3031">                  select(e, SelectType::RANGE, staffIdx);</a>
<a name="ln3032">                  return;</a>
<a name="ln3033">                  }</a>
<a name="ln3034">            addRefresh(e-&gt;abbox());</a>
<a name="ln3035">            _selection.add(e);</a>
<a name="ln3036">            _is.setTrack(e-&gt;track());</a>
<a name="ln3037">            selState = SelState::LIST;</a>
<a name="ln3038">            if (e-&gt;type() == ElementType::NOTE) {</a>
<a name="ln3039">                  e = e-&gt;parent();</a>
<a name="ln3040">                  }</a>
<a name="ln3041">            if (e-&gt;isChordRest()) {</a>
<a name="ln3042">                  _is.setLastSegment(_is.segment());</a>
<a name="ln3043">                  _is.setSegment(toChordRest(e)-&gt;segment());</a>
<a name="ln3044">                  }</a>
<a name="ln3045">            }</a>
<a name="ln3046">      _selection.setActiveSegment(0);</a>
<a name="ln3047">      _selection.setActiveTrack(0);</a>
<a name="ln3048"> </a>
<a name="ln3049">      _selection.setState(selState);</a>
<a name="ln3050">      }</a>
<a name="ln3051"> </a>
<a name="ln3052">//---------------------------------------------------------</a>
<a name="ln3053">//   switchToPageMode</a>
<a name="ln3054">//---------------------------------------------------------</a>
<a name="ln3055"> </a>
<a name="ln3056">void Score::switchToPageMode()</a>
<a name="ln3057">      {</a>
<a name="ln3058">            if (_layoutMode != LayoutMode::PAGE) {</a>
<a name="ln3059">                  setLayoutMode(LayoutMode::PAGE);</a>
<a name="ln3060">                  doLayout();</a>
<a name="ln3061">            }</a>
<a name="ln3062">      }</a>
<a name="ln3063"> </a>
<a name="ln3064">//---------------------------------------------------------</a>
<a name="ln3065">//   selectAdd</a>
<a name="ln3066">//---------------------------------------------------------</a>
<a name="ln3067"> </a>
<a name="ln3068">void Score::selectAdd(Element* e)</a>
<a name="ln3069">      {</a>
<a name="ln3070">      SelState selState = _selection.state();</a>
<a name="ln3071"> </a>
<a name="ln3072">      if (_selection.isRange()) {</a>
<a name="ln3073">            select(0, SelectType::SINGLE, 0);</a>
<a name="ln3074">            return;</a>
<a name="ln3075">            }</a>
<a name="ln3076"> </a>
<a name="ln3077">      if (e-&gt;isMeasure()) {</a>
<a name="ln3078">            Measure* m = toMeasure(e);</a>
<a name="ln3079">            Fraction tick  = m-&gt;tick();</a>
<a name="ln3080">            if (_selection.isNone()) {</a>
<a name="ln3081">                  _selection.setRange(m-&gt;tick2segment(tick),</a>
<a name="ln3082">                                      m == lastMeasure() ? 0 : m-&gt;last(),</a>
<a name="ln3083">                                      0,</a>
<a name="ln3084">                                      nstaves());</a>
<a name="ln3085">                  setUpdateAll();</a>
<a name="ln3086">                  selState = SelState::RANGE;</a>
<a name="ln3087">                  _selection.updateSelectedElements();</a>
<a name="ln3088">                  }</a>
<a name="ln3089">            }</a>
<a name="ln3090">      else if (!_selection.elements().contains(e)) {</a>
<a name="ln3091">            addRefresh(e-&gt;abbox());</a>
<a name="ln3092">            selState = SelState::LIST;</a>
<a name="ln3093">            _selection.add(e);</a>
<a name="ln3094">            }</a>
<a name="ln3095"> </a>
<a name="ln3096">      _selection.setState(selState);</a>
<a name="ln3097">      }</a>
<a name="ln3098"> </a>
<a name="ln3099">//---------------------------------------------------------</a>
<a name="ln3100">//   selectRange</a>
<a name="ln3101">//    staffIdx is valid, if element is of type MEASURE</a>
<a name="ln3102">//---------------------------------------------------------</a>
<a name="ln3103"> </a>
<a name="ln3104">void Score::selectRange(Element* e, int staffIdx)</a>
<a name="ln3105">      {</a>
<a name="ln3106">      int activeTrack = e-&gt;track();</a>
<a name="ln3107">      // current selection is range extending to end of score?</a>
<a name="ln3108">      bool endRangeSelected = selection().isRange() &amp;&amp; selection().endSegment() == nullptr;</a>
<a name="ln3109">      if (e-&gt;isMeasure()) {</a>
<a name="ln3110">            Measure* m  = toMeasure(e);</a>
<a name="ln3111">            Fraction tick    = m-&gt;tick();</a>
<a name="ln3112">            Fraction etick   = tick + m-&gt;ticks();</a>
<a name="ln3113">            activeTrack = staffIdx * VOICES;</a>
<a name="ln3114">            Segment* s1 = m-&gt;tick2segment(tick);</a>
<a name="ln3115">            if (!s1)                      // m is corrupted!</a>
<a name="ln3116">                  s1 = m-&gt;first(SegmentType::ChordRest);</a>
<a name="ln3117">            Segment* s2 = m == lastMeasure() ? 0 : m-&gt;last();</a>
<a name="ln3118">            if (_selection.isNone() || (_selection.isList() &amp;&amp; !_selection.isSingle())) {</a>
<a name="ln3119">                  if (_selection.isList())</a>
<a name="ln3120">                        deselectAll();</a>
<a name="ln3121">                  _selection.setRange(s1, s2, staffIdx, staffIdx + 1);</a>
<a name="ln3122">                  }</a>
<a name="ln3123">            else if (_selection.isRange())</a>
<a name="ln3124">                  _selection.extendRangeSelection(s1, s2, staffIdx, tick, etick);</a>
<a name="ln3125">            else if (_selection.isSingle()) {</a>
<a name="ln3126">                  Element* oe = selection().element();</a>
<a name="ln3127">                  if (oe-&gt;isNote() || oe-&gt;isChordRest()) {</a>
<a name="ln3128">                        if (oe-&gt;isNote())</a>
<a name="ln3129">                              oe = oe-&gt;parent();</a>
<a name="ln3130">                        ChordRest* cr = toChordRest(oe);</a>
<a name="ln3131">                        Fraction oetick = cr-&gt;segment()-&gt;tick();</a>
<a name="ln3132">                        Segment* startSegment = cr-&gt;segment();</a>
<a name="ln3133">                        Segment* endSegment = m-&gt;last();</a>
<a name="ln3134">                        if (tick &lt; oetick) {</a>
<a name="ln3135">                              startSegment = m-&gt;tick2segment(tick);</a>
<a name="ln3136">                              if (etick &lt;= oetick) {</a>
<a name="ln3137">                                    SegmentType st = SegmentType::ChordRest | SegmentType::EndBarLine | SegmentType::Clef;</a>
<a name="ln3138">                                    endSegment = cr-&gt;nextSegmentAfterCR(st);</a>
<a name="ln3139">                                    }</a>
<a name="ln3140">                              }</a>
<a name="ln3141">                        int staffStart = staffIdx;</a>
<a name="ln3142">                        int endStaff = staffIdx + 1;</a>
<a name="ln3143">                        if (staffStart &gt; cr-&gt;staffIdx())</a>
<a name="ln3144">                              staffStart = cr-&gt;staffIdx();</a>
<a name="ln3145">                        else if (cr-&gt;staffIdx() &gt;= endStaff)</a>
<a name="ln3146">                              endStaff = cr-&gt;staffIdx() + 1;</a>
<a name="ln3147">                        _selection.setRange(startSegment, endSegment, staffStart, endStaff);</a>
<a name="ln3148">                        }</a>
<a name="ln3149">                  else {</a>
<a name="ln3150">                        deselectAll();</a>
<a name="ln3151">                        _selection.setRange(s1, s2, staffIdx, staffIdx + 1);</a>
<a name="ln3152">                        }</a>
<a name="ln3153">                  }</a>
<a name="ln3154">            else {</a>
<a name="ln3155">                  qDebug(&quot;SELECT_RANGE: measure: sel state %d&quot;, int(_selection.state()));</a>
<a name="ln3156">                  return;</a>
<a name="ln3157">                  }</a>
<a name="ln3158">            }</a>
<a name="ln3159">      else if (e-&gt;isNote() || e-&gt;isChordRest()) {</a>
<a name="ln3160">            if (e-&gt;isNote())</a>
<a name="ln3161">                  e = e-&gt;parent();</a>
<a name="ln3162">            ChordRest* cr = toChordRest(e);</a>
<a name="ln3163"> </a>
<a name="ln3164">            if (_selection.isNone() || (_selection.isList() &amp;&amp; !_selection.isSingle())) {</a>
<a name="ln3165">                  if (_selection.isList())</a>
<a name="ln3166">                        deselectAll();</a>
<a name="ln3167">                  SegmentType st = SegmentType::ChordRest | SegmentType::EndBarLine | SegmentType::Clef;</a>
<a name="ln3168">                  _selection.setRange(cr-&gt;segment(), cr-&gt;nextSegmentAfterCR(st), e-&gt;staffIdx(), e-&gt;staffIdx() + 1);</a>
<a name="ln3169">                  activeTrack = cr-&gt;track();</a>
<a name="ln3170">                  }</a>
<a name="ln3171">            else if (_selection.isSingle()) {</a>
<a name="ln3172">                  Element* oe = _selection.element();</a>
<a name="ln3173">                  if (oe &amp;&amp; (oe-&gt;isNote() || oe-&gt;isRest())) {</a>
<a name="ln3174">                        if (oe-&gt;isNote())</a>
<a name="ln3175">                              oe = oe-&gt;parent();</a>
<a name="ln3176">                        ChordRest* ocr = toChordRest(oe);</a>
<a name="ln3177"> </a>
<a name="ln3178">                        Segment* endSeg = tick2segmentMM(ocr-&gt;segment()-&gt;tick() + ocr-&gt;actualTicks());</a>
<a name="ln3179">                        if (!endSeg)</a>
<a name="ln3180">                              endSeg = ocr-&gt;segment()-&gt;next();</a>
<a name="ln3181"> </a>
<a name="ln3182">                        _selection.setRange(ocr-&gt;segment(), endSeg, oe-&gt;staffIdx(), oe-&gt;staffIdx() + 1);</a>
<a name="ln3183">                        _selection.extendRangeSelection(cr);</a>
<a name="ln3184">                        }</a>
<a name="ln3185">                  else {</a>
<a name="ln3186">                        select(e, SelectType::SINGLE, 0);</a>
<a name="ln3187">                        return;</a>
<a name="ln3188">                        }</a>
<a name="ln3189">                  }</a>
<a name="ln3190">            else if (_selection.isRange()) {</a>
<a name="ln3191">                  _selection.extendRangeSelection(cr);</a>
<a name="ln3192">                  }</a>
<a name="ln3193">            else {</a>
<a name="ln3194">                  qDebug(&quot;sel state %d&quot;, int(_selection.state()));</a>
<a name="ln3195">                  return;</a>
<a name="ln3196">                  }</a>
<a name="ln3197">            if (!endRangeSelected &amp;&amp; !_selection.endSegment())</a>
<a name="ln3198">                  _selection.setEndSegment(cr-&gt;segment()-&gt;nextCR());</a>
<a name="ln3199">            if (!_selection.startSegment())</a>
<a name="ln3200">                  _selection.setStartSegment(cr-&gt;segment());</a>
<a name="ln3201">            }</a>
<a name="ln3202">      else {</a>
<a name="ln3203">            select(e, SelectType::SINGLE, staffIdx);</a>
<a name="ln3204">            return;</a>
<a name="ln3205">            }</a>
<a name="ln3206"> </a>
<a name="ln3207">      _selection.setActiveTrack(activeTrack);</a>
<a name="ln3208"> </a>
<a name="ln3209">      // doing this in note entry mode can clear selection</a>
<a name="ln3210">      if (_selection.startSegment() &amp;&amp; !noteEntryMode()) {</a>
<a name="ln3211">            Fraction tick = _selection.startSegment()-&gt;tick();</a>
<a name="ln3212">            if (masterScore()-&gt;playPos() != tick)</a>
<a name="ln3213">                  masterScore()-&gt;setPlayPos(tick);</a>
<a name="ln3214">            }</a>
<a name="ln3215"> </a>
<a name="ln3216">      _selection.updateSelectedElements();</a>
<a name="ln3217">      }</a>
<a name="ln3218"> </a>
<a name="ln3219">//---------------------------------------------------------</a>
<a name="ln3220">//   collectMatch</a>
<a name="ln3221">//---------------------------------------------------------</a>
<a name="ln3222"> </a>
<a name="ln3223">void Score::collectMatch(void* data, Element* e)</a>
<a name="ln3224">      {</a>
<a name="ln3225">      ElementPattern* p = static_cast&lt;ElementPattern*&gt;(data);</a>
<a name="ln3226">      if (p-&gt;type != int(e-&gt;type()))</a>
<a name="ln3227">            return;</a>
<a name="ln3228"> </a>
<a name="ln3229">      if (p-&gt;type == int(ElementType::NOTE)) {</a>
<a name="ln3230">            if (p-&gt;subtype &lt; 0) {</a>
<a name="ln3231">                  if (!(toNote(e)-&gt;chord()-&gt;isGrace()))</a>
<a name="ln3232">                        return;</a>
<a name="ln3233">                  }</a>
<a name="ln3234">            else if ((toNote(e)-&gt;chord()-&gt;isGrace()) || (p-&gt;subtype != e-&gt;subtype()))</a>
<a name="ln3235">                  return;</a>
<a name="ln3236">            }</a>
<a name="ln3237">      else if (p-&gt;subtypeValid &amp;&amp; p-&gt;subtype != e-&gt;subtype())</a>
<a name="ln3238">            return;</a>
<a name="ln3239"> </a>
<a name="ln3240">      if ((p-&gt;staffStart != -1)</a>
<a name="ln3241">         &amp;&amp; ((p-&gt;staffStart &gt; e-&gt;staffIdx()) || (p-&gt;staffEnd &lt;= e-&gt;staffIdx())))</a>
<a name="ln3242">            return;</a>
<a name="ln3243"> </a>
<a name="ln3244">      if (p-&gt;voice != -1 &amp;&amp; p-&gt;voice != e-&gt;voice())</a>
<a name="ln3245">            return;</a>
<a name="ln3246"> </a>
<a name="ln3247">      if (p-&gt;system) {</a>
<a name="ln3248">            Element* ee = e;</a>
<a name="ln3249">            do {</a>
<a name="ln3250">                  if (ee-&gt;type() == ElementType::SYSTEM) {</a>
<a name="ln3251">                        if (p-&gt;system != ee)</a>
<a name="ln3252">                              return;</a>
<a name="ln3253">                        break;</a>
<a name="ln3254">                        }</a>
<a name="ln3255">                  ee = ee-&gt;parent();</a>
<a name="ln3256">                  } while (ee);</a>
<a name="ln3257">            }</a>
<a name="ln3258"> </a>
<a name="ln3259">      if (e-&gt;isRest() &amp;&amp; p-&gt;durationTicks != Fraction(-1,1)) {</a>
<a name="ln3260">            const Rest* r = toRest(e);</a>
<a name="ln3261">            if (p-&gt;durationTicks != r-&gt;actualTicks())</a>
<a name="ln3262">                  return;</a>
<a name="ln3263">            }</a>
<a name="ln3264"> </a>
<a name="ln3265">      p-&gt;el.append(e);</a>
<a name="ln3266">      }</a>
<a name="ln3267"> </a>
<a name="ln3268">//---------------------------------------------------------</a>
<a name="ln3269">//   collectNoteMatch</a>
<a name="ln3270">//---------------------------------------------------------</a>
<a name="ln3271"> </a>
<a name="ln3272">void Score::collectNoteMatch(void* data, Element* e)</a>
<a name="ln3273">      {</a>
<a name="ln3274">      NotePattern* p = static_cast&lt;NotePattern*&gt;(data);</a>
<a name="ln3275">      if (!e-&gt;isNote())</a>
<a name="ln3276">            return;</a>
<a name="ln3277">      Note* n = toNote(e);</a>
<a name="ln3278">      if (p-&gt;type != NoteType::INVALID &amp;&amp; p-&gt;type != n-&gt;noteType())</a>
<a name="ln3279">            return;</a>
<a name="ln3280">      if (p-&gt;pitch != -1 &amp;&amp; p-&gt;pitch != n-&gt;pitch())</a>
<a name="ln3281">            return;</a>
<a name="ln3282">      if (p-&gt;string != STRING_NONE &amp;&amp; p-&gt;string != n-&gt;string())</a>
<a name="ln3283">            return;</a>
<a name="ln3284">      if (p-&gt;tpc != Tpc::TPC_INVALID &amp;&amp; p-&gt;tpc != n-&gt;tpc())</a>
<a name="ln3285">            return;</a>
<a name="ln3286">      if (p-&gt;notehead != NoteHead::Group::HEAD_INVALID &amp;&amp; p-&gt;notehead != n-&gt;headGroup())</a>
<a name="ln3287">            return;</a>
<a name="ln3288">      if (p-&gt;durationType.type() != TDuration::DurationType::V_INVALID &amp;&amp; p-&gt;durationType != n-&gt;chord()-&gt;actualDurationType())</a>
<a name="ln3289">            return;</a>
<a name="ln3290">      if (p-&gt;durationTicks != Fraction(-1,1) &amp;&amp; p-&gt;durationTicks != n-&gt;chord()-&gt;actualTicks())</a>
<a name="ln3291">            return;</a>
<a name="ln3292">      if ((p-&gt;staffStart != -1)</a>
<a name="ln3293">         &amp;&amp; ((p-&gt;staffStart &gt; e-&gt;staffIdx()) || (p-&gt;staffEnd &lt;= e-&gt;staffIdx())))</a>
<a name="ln3294">            return;</a>
<a name="ln3295">      if (p-&gt;voice != -1 &amp;&amp; p-&gt;voice != e-&gt;voice())</a>
<a name="ln3296">            return;</a>
<a name="ln3297">      if (p-&gt;system &amp;&amp; (p-&gt;system != n-&gt;chord()-&gt;segment()-&gt;system()))</a>
<a name="ln3298">            return;</a>
<a name="ln3299">      p-&gt;el.append(n);</a>
<a name="ln3300">      }</a>
<a name="ln3301"> </a>
<a name="ln3302"> </a>
<a name="ln3303">//---------------------------------------------------------</a>
<a name="ln3304">//   selectSimilar</a>
<a name="ln3305">//---------------------------------------------------------</a>
<a name="ln3306"> </a>
<a name="ln3307">void Score::selectSimilar(Element* e, bool sameStaff)</a>
<a name="ln3308">      {</a>
<a name="ln3309">      ElementType type = e-&gt;type();</a>
<a name="ln3310">      Score* score = e-&gt;score();</a>
<a name="ln3311"> </a>
<a name="ln3312">      ElementPattern pattern;</a>
<a name="ln3313">      pattern.type = int(type);</a>
<a name="ln3314">      pattern.subtype = 0;</a>
<a name="ln3315">      pattern.subtypeValid = false;</a>
<a name="ln3316">      if (type == ElementType::NOTE) {</a>
<a name="ln3317">            if (toNote(e)-&gt;chord()-&gt;isGrace())</a>
<a name="ln3318">                  pattern.subtype = -1; // hack</a>
<a name="ln3319">            else</a>
<a name="ln3320">                  pattern.subtype = e-&gt;subtype();</a>
<a name="ln3321">            }</a>
<a name="ln3322">      pattern.staffStart = sameStaff ? e-&gt;staffIdx() : -1;</a>
<a name="ln3323">      pattern.staffEnd = sameStaff ? e-&gt;staffIdx() + 1 : -1;</a>
<a name="ln3324">      pattern.voice   = -1;</a>
<a name="ln3325">      pattern.system  = 0;</a>
<a name="ln3326">      pattern.durationTicks = Fraction(-1,1);</a>
<a name="ln3327"> </a>
<a name="ln3328">      score-&gt;scanElements(&amp;pattern, collectMatch);</a>
<a name="ln3329"> </a>
<a name="ln3330">      score-&gt;select(0, SelectType::SINGLE, 0);</a>
<a name="ln3331">      for (Element* ee : pattern.el)</a>
<a name="ln3332">            score-&gt;select(ee, SelectType::ADD, 0);</a>
<a name="ln3333">      }</a>
<a name="ln3334"> </a>
<a name="ln3335">//---------------------------------------------------------</a>
<a name="ln3336">//   selectSimilarInRange</a>
<a name="ln3337">//---------------------------------------------------------</a>
<a name="ln3338"> </a>
<a name="ln3339">void Score::selectSimilarInRange(Element* e)</a>
<a name="ln3340">      {</a>
<a name="ln3341">      ElementType type = e-&gt;type();</a>
<a name="ln3342">      Score* score = e-&gt;score();</a>
<a name="ln3343"> </a>
<a name="ln3344">      ElementPattern pattern;</a>
<a name="ln3345">      pattern.type    = int(type);</a>
<a name="ln3346">      pattern.subtype = 0;</a>
<a name="ln3347">      pattern.subtypeValid = false;</a>
<a name="ln3348">      if (type == ElementType::NOTE) {</a>
<a name="ln3349">            if (toNote(e)-&gt;chord()-&gt;isGrace())</a>
<a name="ln3350">                  pattern.subtype = -1; //hack</a>
<a name="ln3351">            else</a>
<a name="ln3352">                  pattern.subtype = e-&gt;subtype();</a>
<a name="ln3353">            pattern.subtypeValid = true;</a>
<a name="ln3354">            }</a>
<a name="ln3355">      pattern.staffStart = selection().staffStart();</a>
<a name="ln3356">      pattern.staffEnd = selection().staffEnd();</a>
<a name="ln3357">      pattern.voice   = -1;</a>
<a name="ln3358">      pattern.system  = 0;</a>
<a name="ln3359">      pattern.durationTicks = Fraction(-1,1);</a>
<a name="ln3360"> </a>
<a name="ln3361">      score-&gt;scanElementsInRange(&amp;pattern, collectMatch);</a>
<a name="ln3362"> </a>
<a name="ln3363">      score-&gt;select(0, SelectType::SINGLE, 0);</a>
<a name="ln3364">      for (Element* ee : pattern.el)</a>
<a name="ln3365">            score-&gt;select(ee, SelectType::ADD, 0);</a>
<a name="ln3366">      }</a>
<a name="ln3367"> </a>
<a name="ln3368">//---------------------------------------------------------</a>
<a name="ln3369">//   lassoSelect</a>
<a name="ln3370">//---------------------------------------------------------</a>
<a name="ln3371"> </a>
<a name="ln3372">void Score::lassoSelect(const QRectF&amp; bbox)</a>
<a name="ln3373">      {</a>
<a name="ln3374">      select(0, SelectType::SINGLE, 0);</a>
<a name="ln3375">      QRectF fr(bbox.normalized());</a>
<a name="ln3376">      foreach(Page* page, pages()) {</a>
<a name="ln3377">            QRectF pr(page-&gt;bbox());</a>
<a name="ln3378">            QRectF frr(fr.translated(-page-&gt;pos()));</a>
<a name="ln3379">            if (pr.right() &lt; frr.left())</a>
<a name="ln3380">                  continue;</a>
<a name="ln3381">            if (pr.left() &gt; frr.right())</a>
<a name="ln3382">                  break;</a>
<a name="ln3383"> </a>
<a name="ln3384">            QList&lt;Element*&gt; el = page-&gt;items(frr);</a>
<a name="ln3385">            for (int i = 0; i &lt; el.size(); ++i) {</a>
<a name="ln3386">                  Element* e = el.at(i);</a>
<a name="ln3387">                  if (frr.contains(e-&gt;abbox())) {</a>
<a name="ln3388">                        if (e-&gt;type() != ElementType::MEASURE &amp;&amp; e-&gt;selectable())</a>
<a name="ln3389">                              select(e, SelectType::ADD, 0);</a>
<a name="ln3390">                        }</a>
<a name="ln3391">                  }</a>
<a name="ln3392">            }</a>
<a name="ln3393">      }</a>
<a name="ln3394"> </a>
<a name="ln3395">//---------------------------------------------------------</a>
<a name="ln3396">//   lassoSelectEnd</a>
<a name="ln3397">//---------------------------------------------------------</a>
<a name="ln3398"> </a>
<a name="ln3399">void Score::lassoSelectEnd()</a>
<a name="ln3400">      {</a>
<a name="ln3401">      int noteRestCount     = 0;</a>
<a name="ln3402">      Segment* startSegment = 0;</a>
<a name="ln3403">      Segment* endSegment   = 0;</a>
<a name="ln3404">      int startStaff        = 0x7fffffff;</a>
<a name="ln3405">      int endStaff          = 0;</a>
<a name="ln3406">      const ChordRest* endCR = 0;</a>
<a name="ln3407"> </a>
<a name="ln3408">      if (_selection.elements().empty()) {</a>
<a name="ln3409">            _selection.setState(SelState::NONE);</a>
<a name="ln3410">            setUpdateAll();</a>
<a name="ln3411">            return;</a>
<a name="ln3412">            }</a>
<a name="ln3413">      _selection.setState(SelState::LIST);</a>
<a name="ln3414"> </a>
<a name="ln3415">      foreach(const Element* e, _selection.elements()) {</a>
<a name="ln3416">            if (e-&gt;type() != ElementType::NOTE &amp;&amp; e-&gt;type() != ElementType::REST)</a>
<a name="ln3417">                  continue;</a>
<a name="ln3418">            ++noteRestCount;</a>
<a name="ln3419">            if (e-&gt;type() == ElementType::NOTE)</a>
<a name="ln3420">                  e = e-&gt;parent();</a>
<a name="ln3421">            Segment* seg = static_cast&lt;const ChordRest*&gt;(e)-&gt;segment();</a>
<a name="ln3422">            if ((startSegment == 0) || (*seg &lt; *startSegment))</a>
<a name="ln3423">                  startSegment = seg;</a>
<a name="ln3424">            if ((endSegment == 0) || (*seg &gt; *endSegment)) {</a>
<a name="ln3425">                  endSegment = seg;</a>
<a name="ln3426">                  endCR = static_cast&lt;const ChordRest*&gt;(e);</a>
<a name="ln3427">                  }</a>
<a name="ln3428">            int idx = e-&gt;staffIdx();</a>
<a name="ln3429">            if (idx &lt; startStaff)</a>
<a name="ln3430">                  startStaff = idx;</a>
<a name="ln3431">            if (idx &gt; endStaff)</a>
<a name="ln3432">                  endStaff = idx;</a>
<a name="ln3433">            }</a>
<a name="ln3434">      if (noteRestCount &gt; 0) {</a>
<a name="ln3435">            endSegment = endCR-&gt;nextSegmentAfterCR(SegmentType::ChordRest</a>
<a name="ln3436">               | SegmentType::EndBarLine</a>
<a name="ln3437">               | SegmentType::Clef);</a>
<a name="ln3438">            _selection.setRange(startSegment, endSegment, startStaff, endStaff+1);</a>
<a name="ln3439">            if (!_selection.isRange())</a>
<a name="ln3440">                  _selection.setState(SelState::RANGE);</a>
<a name="ln3441">            _selection.updateSelectedElements();</a>
<a name="ln3442">            }</a>
<a name="ln3443">      setUpdateAll();</a>
<a name="ln3444">      }</a>
<a name="ln3445"> </a>
<a name="ln3446">//---------------------------------------------------------</a>
<a name="ln3447">//   addLyrics</a>
<a name="ln3448">//---------------------------------------------------------</a>
<a name="ln3449"> </a>
<a name="ln3450">void Score::addLyrics(const Fraction&amp; tick, int staffIdx, const QString&amp; txt)</a>
<a name="ln3451">      {</a>
<a name="ln3452">      if (txt.trimmed().isEmpty())</a>
<a name="ln3453">            return;</a>
<a name="ln3454">      Measure* measure = tick2measure(tick);</a>
<a name="ln3455">      Segment* seg     = measure-&gt;findSegment(SegmentType::ChordRest, tick);</a>
<a name="ln3456">      if (seg == 0) {</a>
<a name="ln3457">            qDebug(&quot;no segment found for lyrics&lt;%s&gt; at tick %d&quot;,</a>
<a name="ln3458">               qPrintable(txt), tick.ticks());</a>
<a name="ln3459">            return;</a>
<a name="ln3460">            }</a>
<a name="ln3461"> </a>
<a name="ln3462">      bool lyricsAdded = false;</a>
<a name="ln3463">      for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln3464">            int track = staffIdx * VOICES + voice;</a>
<a name="ln3465">            ChordRest* cr = toChordRest(seg-&gt;element(track));</a>
<a name="ln3466">            if (cr) {</a>
<a name="ln3467">                  Lyrics* l = new Lyrics(this);</a>
<a name="ln3468">                  l-&gt;setXmlText(txt);</a>
<a name="ln3469">                  l-&gt;setTrack(track);</a>
<a name="ln3470">                  cr-&gt;add(l);</a>
<a name="ln3471">                  lyricsAdded = true;</a>
<a name="ln3472">                  break;</a>
<a name="ln3473">                  }</a>
<a name="ln3474">            }</a>
<a name="ln3475">      if (!lyricsAdded) {</a>
<a name="ln3476">            qDebug(&quot;no chord/rest for lyrics&lt;%s&gt; at tick %d, staff %d&quot;,</a>
<a name="ln3477">               qPrintable(txt), tick.ticks(), staffIdx);</a>
<a name="ln3478">            }</a>
<a name="ln3479">      }</a>
<a name="ln3480"> </a>
<a name="ln3481">//---------------------------------------------------------</a>
<a name="ln3482">//   setTempo</a>
<a name="ln3483">//    convenience function to access TempoMap</a>
<a name="ln3484">//---------------------------------------------------------</a>
<a name="ln3485"> </a>
<a name="ln3486">void Score::setTempo(Segment* segment, qreal tempo)</a>
<a name="ln3487">      {</a>
<a name="ln3488">      setTempo(segment-&gt;tick(), tempo);</a>
<a name="ln3489">      }</a>
<a name="ln3490"> </a>
<a name="ln3491">void Score::setTempo(const Fraction&amp; tick, qreal tempo)</a>
<a name="ln3492">      {</a>
<a name="ln3493">      tempomap()-&gt;setTempo(tick.ticks(), tempo);</a>
<a name="ln3494">      setPlaylistDirty();</a>
<a name="ln3495">      }</a>
<a name="ln3496"> </a>
<a name="ln3497">//---------------------------------------------------------</a>
<a name="ln3498">//   removeTempo</a>
<a name="ln3499">//---------------------------------------------------------</a>
<a name="ln3500"> </a>
<a name="ln3501">void Score::removeTempo(const Fraction&amp; tick)</a>
<a name="ln3502">      {</a>
<a name="ln3503">      tempomap()-&gt;delTempo(tick.ticks());</a>
<a name="ln3504">      setPlaylistDirty();</a>
<a name="ln3505">      }</a>
<a name="ln3506"> </a>
<a name="ln3507">//---------------------------------------------------------</a>
<a name="ln3508">//   resetTempo</a>
<a name="ln3509">//---------------------------------------------------------</a>
<a name="ln3510"> </a>
<a name="ln3511">void Score::resetTempo()</a>
<a name="ln3512">      {</a>
<a name="ln3513">      resetTempoRange(Fraction(0,1), Fraction(std::numeric_limits&lt;int&gt;::max(), 1));</a>
<a name="ln3514">      }</a>
<a name="ln3515"> </a>
<a name="ln3516">//---------------------------------------------------------</a>
<a name="ln3517">//   resetTempoRange</a>
<a name="ln3518">//    Reset tempo and timesig maps in the given range.</a>
<a name="ln3519">//    Start tick included, end tick excluded.</a>
<a name="ln3520">//---------------------------------------------------------</a>
<a name="ln3521"> </a>
<a name="ln3522">void Score::resetTempoRange(const Fraction&amp; tick1, const Fraction&amp; tick2)</a>
<a name="ln3523">      {</a>
<a name="ln3524">      const bool zeroInRange = (tick1 &lt;= Fraction(0,1) &amp;&amp; tick2 &gt; Fraction(0,1));</a>
<a name="ln3525">      tempomap()-&gt;clearRange(tick1.ticks(), tick2.ticks());</a>
<a name="ln3526">      if (zeroInRange)</a>
<a name="ln3527">            tempomap()-&gt;setTempo(0, _defaultTempo);</a>
<a name="ln3528">      sigmap()-&gt;clearRange(tick1.ticks(), tick2.ticks());</a>
<a name="ln3529">      if (zeroInRange) {</a>
<a name="ln3530">            Measure* m = firstMeasure();</a>
<a name="ln3531">            if (m)</a>
<a name="ln3532">                  sigmap()-&gt;add(0, SigEvent(m-&gt;ticks(),  m-&gt;timesig(), 0));</a>
<a name="ln3533">            }</a>
<a name="ln3534">      }</a>
<a name="ln3535"> </a>
<a name="ln3536">//---------------------------------------------------------</a>
<a name="ln3537">//   setPause</a>
<a name="ln3538">//---------------------------------------------------------</a>
<a name="ln3539"> </a>
<a name="ln3540">void Score::setPause(const Fraction&amp; tick, qreal seconds)</a>
<a name="ln3541">      {</a>
<a name="ln3542">      tempomap()-&gt;setPause(tick.ticks(), seconds);</a>
<a name="ln3543">      setPlaylistDirty();</a>
<a name="ln3544">      }</a>
<a name="ln3545"> </a>
<a name="ln3546">//---------------------------------------------------------</a>
<a name="ln3547">//   tempo</a>
<a name="ln3548">//---------------------------------------------------------</a>
<a name="ln3549"> </a>
<a name="ln3550">qreal Score::tempo(const Fraction&amp; tick) const</a>
<a name="ln3551">      {</a>
<a name="ln3552">      return tempomap()-&gt;tempo(tick.ticks());</a>
<a name="ln3553">      }</a>
<a name="ln3554"> </a>
<a name="ln3555">//---------------------------------------------------------</a>
<a name="ln3556">//   loWidth</a>
<a name="ln3557">//---------------------------------------------------------</a>
<a name="ln3558"> </a>
<a name="ln3559">qreal Score::loWidth() const</a>
<a name="ln3560">      {</a>
<a name="ln3561">      return styleD(Sid::pageWidth) * DPI;</a>
<a name="ln3562">      }</a>
<a name="ln3563"> </a>
<a name="ln3564">//---------------------------------------------------------</a>
<a name="ln3565">//   loHeight</a>
<a name="ln3566">//---------------------------------------------------------</a>
<a name="ln3567"> </a>
<a name="ln3568">qreal Score::loHeight() const</a>
<a name="ln3569">      {</a>
<a name="ln3570">      return styleD(Sid::pageHeight) * DPI;</a>
<a name="ln3571">      }</a>
<a name="ln3572"> </a>
<a name="ln3573">//---------------------------------------------------------</a>
<a name="ln3574">//   cmdSelectAll</a>
<a name="ln3575">//---------------------------------------------------------</a>
<a name="ln3576"> </a>
<a name="ln3577">void Score::cmdSelectAll()</a>
<a name="ln3578">      {</a>
<a name="ln3579">      if (_measures.size() == 0)</a>
<a name="ln3580">            return;</a>
<a name="ln3581">      deselectAll();</a>
<a name="ln3582">      Measure* first = firstMeasureMM();</a>
<a name="ln3583">      if (!first)</a>
<a name="ln3584">            return;</a>
<a name="ln3585">      Measure* last = lastMeasureMM();</a>
<a name="ln3586">      selectRange(first, 0);</a>
<a name="ln3587">      selectRange(last, nstaves() - 1);</a>
<a name="ln3588">      setUpdateAll();</a>
<a name="ln3589">      update();</a>
<a name="ln3590">      }</a>
<a name="ln3591"> </a>
<a name="ln3592">//---------------------------------------------------------</a>
<a name="ln3593">//   cmdSelectSection</a>
<a name="ln3594">//---------------------------------------------------------</a>
<a name="ln3595"> </a>
<a name="ln3596">void Score::cmdSelectSection()</a>
<a name="ln3597">      {</a>
<a name="ln3598">      Segment* s = _selection.startSegment();</a>
<a name="ln3599">      if (s == 0)</a>
<a name="ln3600">            return;</a>
<a name="ln3601">      MeasureBase* sm = s-&gt;measure();</a>
<a name="ln3602">      MeasureBase* em = sm;</a>
<a name="ln3603">      while (sm-&gt;prev()) {</a>
<a name="ln3604">            if (sm-&gt;prev()-&gt;sectionBreak())</a>
<a name="ln3605">                  break;</a>
<a name="ln3606">            sm = sm-&gt;prev();</a>
<a name="ln3607">            }</a>
<a name="ln3608">      while (em-&gt;next()) {</a>
<a name="ln3609">            if (em-&gt;sectionBreak())</a>
<a name="ln3610">                  break;</a>
<a name="ln3611">            em = em-&gt;next();</a>
<a name="ln3612">            }</a>
<a name="ln3613">      while (sm &amp;&amp; sm-&gt;type() != ElementType::MEASURE)</a>
<a name="ln3614">            sm = sm-&gt;next();</a>
<a name="ln3615">      while (em &amp;&amp; em-&gt;type() != ElementType::MEASURE)</a>
<a name="ln3616">            em = em-&gt;next();</a>
<a name="ln3617">      if (sm == 0 || em == 0)</a>
<a name="ln3618">            return;</a>
<a name="ln3619"> </a>
<a name="ln3620">      _selection.setRange(toMeasure(sm)-&gt;first(), toMeasure(em)-&gt;last(), 0, nstaves());</a>
<a name="ln3621">      }</a>
<a name="ln3622"> </a>
<a name="ln3623">//---------------------------------------------------------</a>
<a name="ln3624">//   undo</a>
<a name="ln3625">//---------------------------------------------------------</a>
<a name="ln3626"> </a>
<a name="ln3627">void Score::undo(UndoCommand* cmd, EditData* ed) const</a>
<a name="ln3628">      {</a>
<a name="ln3629">      undoStack()-&gt;push(cmd, ed);</a>
<a name="ln3630">      }</a>
<a name="ln3631"> </a>
<a name="ln3632">//---------------------------------------------------------</a>
<a name="ln3633">//   linkId</a>
<a name="ln3634">//---------------------------------------------------------</a>
<a name="ln3635"> </a>
<a name="ln3636">int Score::linkId()</a>
<a name="ln3637">      {</a>
<a name="ln3638">      return (masterScore()-&gt;_linkId)++;</a>
<a name="ln3639">      }</a>
<a name="ln3640"> </a>
<a name="ln3641">// val is a used link id</a>
<a name="ln3642">void Score::linkId(int val)</a>
<a name="ln3643">      {</a>
<a name="ln3644">      Score* s = masterScore();</a>
<a name="ln3645">      if (val &gt;= s-&gt;_linkId)</a>
<a name="ln3646">            s-&gt;_linkId = val + 1;   // update unused link id</a>
<a name="ln3647">      }</a>
<a name="ln3648"> </a>
<a name="ln3649">//---------------------------------------------------------</a>
<a name="ln3650">//   scoreList</a>
<a name="ln3651">//    return a list of scores containing the root score</a>
<a name="ln3652">//    and all part scores (if there are any)</a>
<a name="ln3653">//---------------------------------------------------------</a>
<a name="ln3654"> </a>
<a name="ln3655">QList&lt;Score*&gt; Score::scoreList()</a>
<a name="ln3656">      {</a>
<a name="ln3657">      QList&lt;Score*&gt; scores;</a>
<a name="ln3658">      Score* root = masterScore();</a>
<a name="ln3659">      scores.append(root);</a>
<a name="ln3660">      for (const Excerpt* ex : root-&gt;excerpts()) {</a>
<a name="ln3661">            if (ex-&gt;partScore())</a>
<a name="ln3662">                  scores.append(ex-&gt;partScore());</a>
<a name="ln3663">            }</a>
<a name="ln3664">      return scores;</a>
<a name="ln3665">      }</a>
<a name="ln3666"> </a>
<a name="ln3667">//---------------------------------------------------------</a>
<a name="ln3668">//   switchLayer</a>
<a name="ln3669">//---------------------------------------------------------</a>
<a name="ln3670"> </a>
<a name="ln3671">bool Score::switchLayer(const QString&amp; s)</a>
<a name="ln3672">      {</a>
<a name="ln3673">      int layerIdx = 0;</a>
<a name="ln3674">      for (const Layer&amp; l : layer()) {</a>
<a name="ln3675">            if (s == l.name) {</a>
<a name="ln3676">                  setCurrentLayer(layerIdx);</a>
<a name="ln3677">                  return true;</a>
<a name="ln3678">                  }</a>
<a name="ln3679">            ++layerIdx;</a>
<a name="ln3680">            }</a>
<a name="ln3681">      return false;</a>
<a name="ln3682">      }</a>
<a name="ln3683"> </a>
<a name="ln3684">//---------------------------------------------------------</a>
<a name="ln3685">//   appendPart</a>
<a name="ln3686">//---------------------------------------------------------</a>
<a name="ln3687"> </a>
<a name="ln3688">void Score::appendPart(const QString&amp; name)</a>
<a name="ln3689">      {</a>
<a name="ln3690">      static InstrumentTemplate defaultInstrument;</a>
<a name="ln3691">      InstrumentTemplate* t;</a>
<a name="ln3692"> </a>
<a name="ln3693">      t = searchTemplate(name);</a>
<a name="ln3694">      if (t == 0) {</a>
<a name="ln3695">            qDebug(&quot;appendPart: &lt;%s&gt; not found&quot;, qPrintable(name));</a>
<a name="ln3696">            t = &amp;defaultInstrument;</a>
<a name="ln3697">            }</a>
<a name="ln3698"> </a>
<a name="ln3699">      if (t-&gt;channel.empty()) {</a>
<a name="ln3700">            Channel a;</a>
<a name="ln3701">            a.setChorus(0);</a>
<a name="ln3702">            a.setReverb(0);</a>
<a name="ln3703">            a.setName(Channel::DEFAULT_NAME);</a>
<a name="ln3704">            a.setBank(0);</a>
<a name="ln3705">            a.setVolume(90);</a>
<a name="ln3706">            a.setPan(0);</a>
<a name="ln3707">            t-&gt;channel.append(a);</a>
<a name="ln3708">            }</a>
<a name="ln3709">      Part* part = new Part(this);</a>
<a name="ln3710">      part-&gt;initFromInstrTemplate(t);</a>
<a name="ln3711">      int n = nstaves();</a>
<a name="ln3712">      for (int i = 0; i &lt; t-&gt;nstaves(); ++i) {</a>
<a name="ln3713">            Staff* staff = new Staff(this);</a>
<a name="ln3714">            staff-&gt;setPart(part);</a>
<a name="ln3715">            staff-&gt;setLines(Fraction(0,1), t-&gt;staffLines[i]);</a>
<a name="ln3716">            staff-&gt;setSmall(Fraction(0,1), t-&gt;smallStaff[i]);</a>
<a name="ln3717">            if (i == 0) {</a>
<a name="ln3718">                  staff-&gt;setBracketType(0, t-&gt;bracket[0]);</a>
<a name="ln3719">                  staff-&gt;setBracketSpan(0, t-&gt;nstaves());</a>
<a name="ln3720">                  }</a>
<a name="ln3721">            undoInsertStaff(staff, i);</a>
<a name="ln3722">            }</a>
<a name="ln3723">      part-&gt;staves()-&gt;front()-&gt;setBarLineSpan(part-&gt;nstaves());</a>
<a name="ln3724">      undoInsertPart(part, n);</a>
<a name="ln3725">      fixTicks();</a>
<a name="ln3726">      masterScore()-&gt;rebuildMidiMapping();</a>
<a name="ln3727">      }</a>
<a name="ln3728"> </a>
<a name="ln3729">//---------------------------------------------------------</a>
<a name="ln3730">//   appendMeasures</a>
<a name="ln3731">//---------------------------------------------------------</a>
<a name="ln3732"> </a>
<a name="ln3733">void Score::appendMeasures(int n)</a>
<a name="ln3734">      {</a>
<a name="ln3735">      for (int i = 0; i &lt; n; ++i)</a>
<a name="ln3736">            insertMeasure(ElementType::MEASURE, 0, false);</a>
<a name="ln3737">      }</a>
<a name="ln3738"> </a>
<a name="ln3739">//---------------------------------------------------------</a>
<a name="ln3740">//   addSpanner</a>
<a name="ln3741">//---------------------------------------------------------</a>
<a name="ln3742"> </a>
<a name="ln3743">void Score::addSpanner(Spanner* s)</a>
<a name="ln3744">      {</a>
<a name="ln3745">      _spanner.addSpanner(s);</a>
<a name="ln3746">      }</a>
<a name="ln3747"> </a>
<a name="ln3748">//---------------------------------------------------------</a>
<a name="ln3749">//   removeSpanner</a>
<a name="ln3750">//---------------------------------------------------------</a>
<a name="ln3751"> </a>
<a name="ln3752">void Score::removeSpanner(Spanner* s)</a>
<a name="ln3753">      {</a>
<a name="ln3754">      _spanner.removeSpanner(s);</a>
<a name="ln3755">      }</a>
<a name="ln3756"> </a>
<a name="ln3757">//---------------------------------------------------------</a>
<a name="ln3758">//   isSpannerStartEnd</a>
<a name="ln3759">//    does is spanner start or end at tick position tick</a>
<a name="ln3760">//    for track ?</a>
<a name="ln3761">//---------------------------------------------------------</a>
<a name="ln3762"> </a>
<a name="ln3763">bool Score::isSpannerStartEnd(const Fraction&amp; tick, int track) const</a>
<a name="ln3764">      {</a>
<a name="ln3765">      for (auto i : _spanner.map()) {</a>
<a name="ln3766">            if (i.second-&gt;track() != track)</a>
<a name="ln3767">                  continue;</a>
<a name="ln3768">            if (i.second-&gt;tick() == tick || i.second-&gt;tick2() == tick)</a>
<a name="ln3769">                  return true;</a>
<a name="ln3770">            }</a>
<a name="ln3771">      return false;</a>
<a name="ln3772">      }</a>
<a name="ln3773"> </a>
<a name="ln3774">void Score::insertTime(const Fraction&amp; tick, const Fraction&amp; len)</a>
<a name="ln3775">      {</a>
<a name="ln3776">      for (Staff* staff : staves())</a>
<a name="ln3777">            staff-&gt;insertTime(tick, len);</a>
<a name="ln3778">      for (Part* part : parts())</a>
<a name="ln3779">            part-&gt;insertTime(tick, len);</a>
<a name="ln3780">      }</a>
<a name="ln3781"> </a>
<a name="ln3782">//---------------------------------------------------------</a>
<a name="ln3783">//   addUnmanagedSpanner</a>
<a name="ln3784">//---------------------------------------------------------</a>
<a name="ln3785"> </a>
<a name="ln3786">void Score::addUnmanagedSpanner(Spanner* s)</a>
<a name="ln3787">      {</a>
<a name="ln3788">      _unmanagedSpanner.insert(s);</a>
<a name="ln3789">      }</a>
<a name="ln3790"> </a>
<a name="ln3791">//---------------------------------------------------------</a>
<a name="ln3792">//   removeSpanner</a>
<a name="ln3793">//---------------------------------------------------------</a>
<a name="ln3794"> </a>
<a name="ln3795">void Score::removeUnmanagedSpanner(Spanner* s)</a>
<a name="ln3796">      {</a>
<a name="ln3797">      _unmanagedSpanner.erase(s);</a>
<a name="ln3798">      }</a>
<a name="ln3799"> </a>
<a name="ln3800">//---------------------------------------------------------</a>
<a name="ln3801">//   setPos</a>
<a name="ln3802">//---------------------------------------------------------</a>
<a name="ln3803"> </a>
<a name="ln3804">void MasterScore::setPos(POS pos, Fraction tick)</a>
<a name="ln3805">      {</a>
<a name="ln3806">      if (tick &lt; Fraction(0,1))</a>
<a name="ln3807">            tick = Fraction(0,1);</a>
<a name="ln3808">      Q_ASSERT(tick &lt;= lastMeasure()-&gt;endTick());</a>
<a name="ln3809"> </a>
<a name="ln3810">      _pos[int(pos)] = tick;</a>
<a name="ln3811">      // even though tick position might not have changed, layout might have</a>
<a name="ln3812">      // so we should update cursor here</a>
<a name="ln3813">      // however, we must be careful not to call setPos() again while handling posChanged, or recursion results</a>
<a name="ln3814">      for (Score* s : scoreList())</a>
<a name="ln3815">            emit s-&gt;posChanged(pos, unsigned(tick.ticks()));</a>
<a name="ln3816">      }</a>
<a name="ln3817"> </a>
<a name="ln3818">//---------------------------------------------------------</a>
<a name="ln3819">//   uniqueStaves</a>
<a name="ln3820">//---------------------------------------------------------</a>
<a name="ln3821"> </a>
<a name="ln3822">QList&lt;int&gt; Score::uniqueStaves() const</a>
<a name="ln3823">      {</a>
<a name="ln3824">      QList&lt;int&gt; sl;</a>
<a name="ln3825"> </a>
<a name="ln3826">      for (int staffIdx = 0; staffIdx &lt; nstaves(); ++staffIdx) {</a>
<a name="ln3827">            Staff* s = staff(staffIdx);</a>
<a name="ln3828">            if (s-&gt;links()) {</a>
<a name="ln3829">                  bool alreadyInList = false;</a>
<a name="ln3830">                  for (int idx : sl) {</a>
<a name="ln3831">                        if (s-&gt;links()-&gt;contains(staff(idx))) {</a>
<a name="ln3832">                              alreadyInList = true;</a>
<a name="ln3833">                              break;</a>
<a name="ln3834">                              }</a>
<a name="ln3835">                        }</a>
<a name="ln3836">                  if (alreadyInList)</a>
<a name="ln3837">                        continue;</a>
<a name="ln3838">                  }</a>
<a name="ln3839">            sl.append(staffIdx);</a>
<a name="ln3840">            }</a>
<a name="ln3841">      return sl;</a>
<a name="ln3842">      }</a>
<a name="ln3843"> </a>
<a name="ln3844">//---------------------------------------------------------</a>
<a name="ln3845">//   findCR</a>
<a name="ln3846">//    find chord/rest &lt;= tick in track</a>
<a name="ln3847">//---------------------------------------------------------</a>
<a name="ln3848"> </a>
<a name="ln3849">ChordRest* Score::findCR(Fraction tick, int track) const</a>
<a name="ln3850">      {</a>
<a name="ln3851">      Measure* m = tick2measureMM(tick);</a>
<a name="ln3852">      if (!m) {</a>
<a name="ln3853">            qDebug(&quot;findCR: no measure for tick %d&quot;, tick.ticks());</a>
<a name="ln3854">            return nullptr;</a>
<a name="ln3855">            }</a>
<a name="ln3856">      // attach to first rest all spanner when mmRest</a>
<a name="ln3857">      if (m-&gt;isMMRest())</a>
<a name="ln3858">            tick = m-&gt;tick();</a>
<a name="ln3859">      Segment* s = m-&gt;first(SegmentType::ChordRest);</a>
<a name="ln3860">      for (Segment* ns = s; ; ns = ns-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln3861">            if (ns == 0 || ns-&gt;tick() &gt; tick)</a>
<a name="ln3862">                  break;</a>
<a name="ln3863">            Element* el = ns-&gt;element(track);</a>
<a name="ln3864">            if (el &amp;&amp; el-&gt;isRest() &amp;&amp; toRest(el)-&gt;isGap())</a>
<a name="ln3865">                  continue;</a>
<a name="ln3866">            else if (el)</a>
<a name="ln3867">                  s = ns;</a>
<a name="ln3868">            }</a>
<a name="ln3869">      Element* el = s-&gt;element(track);</a>
<a name="ln3870">      if (el &amp;&amp; el-&gt;isRest() &amp;&amp; toRest(el)-&gt;isGap())</a>
<a name="ln3871">            s = 0;</a>
<a name="ln3872">      if (s)</a>
<a name="ln3873">            return toChordRest(s-&gt;element(track));</a>
<a name="ln3874">      return nullptr;</a>
<a name="ln3875">      }</a>
<a name="ln3876"> </a>
<a name="ln3877">//---------------------------------------------------------</a>
<a name="ln3878">//   findCRinStaff</a>
<a name="ln3879">//    find last chord/rest on staff that ends before tick</a>
<a name="ln3880">//---------------------------------------------------------</a>
<a name="ln3881"> </a>
<a name="ln3882">ChordRest* Score::findCRinStaff(const Fraction&amp; tick, int staffIdx) const</a>
<a name="ln3883">      {</a>
<a name="ln3884">      Fraction ptick = tick - Fraction::fromTicks(1);</a>
<a name="ln3885">      Measure* m = tick2measureMM(ptick);</a>
<a name="ln3886">      if (!m) {</a>
<a name="ln3887">            qDebug(&quot;findCRinStaff: no measure for tick %d&quot;, ptick.ticks());</a>
<a name="ln3888">            return 0;</a>
<a name="ln3889">            }</a>
<a name="ln3890">      // attach to first rest all spanner when mmRest</a>
<a name="ln3891">      if (m-&gt;isMMRest())</a>
<a name="ln3892">            ptick = m-&gt;tick();</a>
<a name="ln3893"> </a>
<a name="ln3894">      Segment* s      = m-&gt;first(SegmentType::ChordRest);</a>
<a name="ln3895">      int strack      = staffIdx * VOICES;</a>
<a name="ln3896">      int etrack      = strack + VOICES;</a>
<a name="ln3897">      int actualTrack = strack;</a>
<a name="ln3898"> </a>
<a name="ln3899">      Fraction lastTick = Fraction(-1,1);</a>
<a name="ln3900">      for (Segment* ns = s; ; ns = ns-&gt;next(SegmentType::ChordRest)) {</a>
<a name="ln3901">            if (ns == 0 || ns-&gt;tick() &gt; ptick)</a>
<a name="ln3902">                  break;</a>
<a name="ln3903">            // found a segment; now find longest cr on this staff that does not overlap tick</a>
<a name="ln3904">            for (int t = strack; t &lt; etrack; ++t) {</a>
<a name="ln3905">                  ChordRest* cr = toChordRest(ns-&gt;element(t));</a>
<a name="ln3906">                  if (cr) {</a>
<a name="ln3907">                        Fraction endTick = cr-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln3908">                        if (endTick &gt;= lastTick &amp;&amp; endTick &lt;= tick) {</a>
<a name="ln3909">                              s = ns;</a>
<a name="ln3910">                              actualTrack = t;</a>
<a name="ln3911">                              lastTick = endTick;</a>
<a name="ln3912">                              }</a>
<a name="ln3913">                        }</a>
<a name="ln3914">                  }</a>
<a name="ln3915">            }</a>
<a name="ln3916">      if (s)</a>
<a name="ln3917">            return toChordRest(s-&gt;element(actualTrack));</a>
<a name="ln3918">      return 0;</a>
<a name="ln3919">      }</a>
<a name="ln3920"> </a>
<a name="ln3921">//---------------------------------------------------------</a>
<a name="ln3922">//   setSoloMute</a>
<a name="ln3923">//   called once at opening file, adds soloMute marks</a>
<a name="ln3924">//---------------------------------------------------------</a>
<a name="ln3925"> </a>
<a name="ln3926">void MasterScore::setSoloMute()</a>
<a name="ln3927">      {</a>
<a name="ln3928">      for (unsigned i = 0; i &lt; _midiMapping.size(); i++) {</a>
<a name="ln3929">            Channel* b = _midiMapping[i].articulation();</a>
<a name="ln3930">            if (b-&gt;solo()) {</a>
<a name="ln3931">                  b-&gt;setSoloMute(false);</a>
<a name="ln3932">                  for (unsigned j = 0; j &lt; _midiMapping.size(); j++) {</a>
<a name="ln3933">                        Channel* a = _midiMapping[j].articulation();</a>
<a name="ln3934">                        bool sameMidiMapping = _midiMapping[i].port() == _midiMapping[j].port() &amp;&amp; _midiMapping[i].channel() == _midiMapping[j].channel();</a>
<a name="ln3935">                        a-&gt;setSoloMute((i != j &amp;&amp; !a-&gt;solo() &amp;&amp; !sameMidiMapping));</a>
<a name="ln3936">                        a-&gt;setSolo(i == j || a-&gt;solo() || sameMidiMapping);</a>
<a name="ln3937">                        }</a>
<a name="ln3938">                  }</a>
<a name="ln3939">            }</a>
<a name="ln3940">      }</a>
<a name="ln3941"> </a>
<a name="ln3942">//---------------------------------------------------------</a>
<a name="ln3943">//   setImportedFilePath</a>
<a name="ln3944">//---------------------------------------------------------</a>
<a name="ln3945"> </a>
<a name="ln3946">void Score::setImportedFilePath(const QString&amp; filePath)</a>
<a name="ln3947">      {</a>
<a name="ln3948">      _importedFilePath = filePath;</a>
<a name="ln3949">      }</a>
<a name="ln3950"> </a>
<a name="ln3951">//---------------------------------------------------------</a>
<a name="ln3952">//   nmeasure</a>
<a name="ln3953">//---------------------------------------------------------</a>
<a name="ln3954"> </a>
<a name="ln3955">int Score::nmeasures() const</a>
<a name="ln3956">      {</a>
<a name="ln3957">      int n = 0;</a>
<a name="ln3958">      for (const Measure* m = firstMeasure(); m; m = m-&gt;nextMeasure())</a>
<a name="ln3959">            n++;</a>
<a name="ln3960">      return n;</a>
<a name="ln3961">      }</a>
<a name="ln3962"> </a>
<a name="ln3963">//---------------------------------------------------------</a>
<a name="ln3964">//   hasLyrics</a>
<a name="ln3965">//---------------------------------------------------------</a>
<a name="ln3966"> </a>
<a name="ln3967">bool Score::hasLyrics()</a>
<a name="ln3968">      {</a>
<a name="ln3969">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln3970">      for (Segment* seg = firstMeasure()-&gt;first(st); seg; seg = seg-&gt;next1(st)) {</a>
<a name="ln3971">            for (int i = 0; i &lt; ntracks(); ++i) {</a>
<a name="ln3972">                  ChordRest* cr = toChordRest(seg-&gt;element(i));</a>
<a name="ln3973">                  if (cr &amp;&amp; !cr-&gt;lyrics().empty())</a>
<a name="ln3974">                        return true;</a>
<a name="ln3975">                  }</a>
<a name="ln3976">            }</a>
<a name="ln3977">      return false;</a>
<a name="ln3978">      }</a>
<a name="ln3979"> </a>
<a name="ln3980">//---------------------------------------------------------</a>
<a name="ln3981">//   hasHarmonies</a>
<a name="ln3982">//---------------------------------------------------------</a>
<a name="ln3983"> </a>
<a name="ln3984">bool Score::hasHarmonies()</a>
<a name="ln3985">      {</a>
<a name="ln3986">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln3987">      for (Segment* seg = firstMeasure()-&gt;first(st); seg; seg = seg-&gt;next1(st)) {</a>
<a name="ln3988">            for (Element* e : seg-&gt;annotations()) {</a>
<a name="ln3989">                  if (e-&gt;type() == ElementType::HARMONY)</a>
<a name="ln3990">                        return true;</a>
<a name="ln3991">                  }</a>
<a name="ln3992">            }</a>
<a name="ln3993">      return false;</a>
<a name="ln3994">      }</a>
<a name="ln3995"> </a>
<a name="ln3996">//---------------------------------------------------------</a>
<a name="ln3997">//   lyricCount</a>
<a name="ln3998">//---------------------------------------------------------</a>
<a name="ln3999"> </a>
<a name="ln4000">int Score::lyricCount()</a>
<a name="ln4001">      {</a>
<a name="ln4002">      size_t count = 0;</a>
<a name="ln4003">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln4004">      for (Segment* seg = firstMeasure()-&gt;first(st); seg; seg = seg-&gt;next1(st)) {</a>
<a name="ln4005">            for (int i = 0; i &lt; ntracks(); ++i) {</a>
<a name="ln4006">                  ChordRest* cr = toChordRest(seg-&gt;element(i));</a>
<a name="ln4007">                  if (cr)</a>
<a name="ln4008">                        count += cr-&gt;lyrics().size();</a>
<a name="ln4009">                  }</a>
<a name="ln4010">            }</a>
<a name="ln4011">      return int(count);</a>
<a name="ln4012">      }</a>
<a name="ln4013"> </a>
<a name="ln4014">//---------------------------------------------------------</a>
<a name="ln4015">//   harmonyCount</a>
<a name="ln4016">//---------------------------------------------------------</a>
<a name="ln4017"> </a>
<a name="ln4018">int Score::harmonyCount()</a>
<a name="ln4019">      {</a>
<a name="ln4020">      int count = 0;</a>
<a name="ln4021">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln4022">      for (Segment* seg = firstMeasure()-&gt;first(st); seg; seg = seg-&gt;next1(st)) {</a>
<a name="ln4023">            for (Element* e : seg-&gt;annotations()) {</a>
<a name="ln4024">                  if (e-&gt;type() == ElementType::HARMONY)</a>
<a name="ln4025">                        count++;</a>
<a name="ln4026">                  }</a>
<a name="ln4027">            }</a>
<a name="ln4028">      return count;</a>
<a name="ln4029">      }</a>
<a name="ln4030"> </a>
<a name="ln4031">//---------------------------------------------------------</a>
<a name="ln4032">//   extractLyrics</a>
<a name="ln4033">//---------------------------------------------------------</a>
<a name="ln4034"> </a>
<a name="ln4035">QString Score::extractLyrics()</a>
<a name="ln4036">      {</a>
<a name="ln4037">      QString result;</a>
<a name="ln4038">      masterScore()-&gt;setExpandRepeats(true);</a>
<a name="ln4039">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln4040">      for (int track = 0; track &lt; ntracks(); track += VOICES) {</a>
<a name="ln4041">            bool found = false;</a>
<a name="ln4042">            size_t maxLyrics = 1;</a>
<a name="ln4043">            const RepeatList&amp; rlist = repeatList();</a>
<a name="ln4044">            for (Measure* m = firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln4045">                  m-&gt;setPlaybackCount(0);</a>
<a name="ln4046">                  }</a>
<a name="ln4047">            // follow the repeat segments</a>
<a name="ln4048">            for (const RepeatSegment* rs : rlist) {</a>
<a name="ln4049">                  Fraction startTick  = Fraction::fromTicks(rs-&gt;tick);</a>
<a name="ln4050">                  Fraction endTick    = startTick + Fraction::fromTicks(rs-&gt;len());</a>
<a name="ln4051">                  for (Measure* m = tick2measure(startTick); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln4052">                        int playCount = m-&gt;playbackCount();</a>
<a name="ln4053">                        for (Segment* seg = m-&gt;first(st); seg; seg = seg-&gt;next(st)) {</a>
<a name="ln4054">                              // consider voice 1 only</a>
<a name="ln4055">                              ChordRest* cr = toChordRest(seg-&gt;element(track));</a>
<a name="ln4056">                              if (!cr || cr-&gt;lyrics().empty())</a>
<a name="ln4057">                                    continue;</a>
<a name="ln4058">                              if (cr-&gt;lyrics().size() &gt; maxLyrics)</a>
<a name="ln4059">                                    maxLyrics = cr-&gt;lyrics().size();</a>
<a name="ln4060">                              if (playCount &gt;= int(cr-&gt;lyrics().size()))</a>
<a name="ln4061">                                    continue;</a>
<a name="ln4062">                              Lyrics* l = cr-&gt;lyrics(playCount, Placement::BELOW);  // TODO: ABOVE</a>
<a name="ln4063">                              if (!l)</a>
<a name="ln4064">                                    continue;</a>
<a name="ln4065">                              found = true;</a>
<a name="ln4066">                              QString lyric = l-&gt;plainText().trimmed();</a>
<a name="ln4067">                              if (l-&gt;syllabic() == Lyrics::Syllabic::SINGLE || l-&gt;syllabic() == Lyrics::Syllabic::END)</a>
<a name="ln4068">                                    result += lyric + &quot; &quot;;</a>
<a name="ln4069">                              else if (l-&gt;syllabic() == Lyrics::Syllabic::BEGIN || l-&gt;syllabic() == Lyrics::Syllabic::MIDDLE)</a>
<a name="ln4070">                                    result += lyric;</a>
<a name="ln4071">                              }</a>
<a name="ln4072">                        m-&gt;setPlaybackCount(m-&gt;playbackCount() + 1);</a>
<a name="ln4073">                        if (m-&gt;endTick() &gt;= endTick)</a>
<a name="ln4074">                              break;</a>
<a name="ln4075">                        }</a>
<a name="ln4076">                  }</a>
<a name="ln4077">            // consider remaining lyrics</a>
<a name="ln4078">            for (unsigned lyricsNumber = 0; lyricsNumber &lt; maxLyrics; lyricsNumber++) {</a>
<a name="ln4079">                  for (Measure* m = firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln4080">                        unsigned playCount = m-&gt;playbackCount();</a>
<a name="ln4081">                        if (lyricsNumber &gt;= playCount) {</a>
<a name="ln4082">                              for (Segment* seg = m-&gt;first(st); seg; seg = seg-&gt;next(st)) {</a>
<a name="ln4083">                                    // consider voice 1 only</a>
<a name="ln4084">                                    ChordRest* cr = toChordRest(seg-&gt;element(track));</a>
<a name="ln4085">                                    if (!cr || cr-&gt;lyrics().empty())</a>
<a name="ln4086">                                          continue;</a>
<a name="ln4087">                                    if (cr-&gt;lyrics().size() &gt; maxLyrics)</a>
<a name="ln4088">                                          maxLyrics = cr-&gt;lyrics().size();</a>
<a name="ln4089">                                    if (lyricsNumber &gt;= cr-&gt;lyrics().size())</a>
<a name="ln4090">                                          continue;</a>
<a name="ln4091">                                    Lyrics* l = cr-&gt;lyrics(lyricsNumber, Placement::BELOW);  // TODO</a>
<a name="ln4092">                                    if (!l)</a>
<a name="ln4093">                                          continue;</a>
<a name="ln4094">                                    found = true;</a>
<a name="ln4095">                                    QString lyric = l-&gt;plainText().trimmed();</a>
<a name="ln4096">                                    if (l-&gt;syllabic() == Lyrics::Syllabic::SINGLE || l-&gt;syllabic() == Lyrics::Syllabic::END)</a>
<a name="ln4097">                                          result += lyric + &quot; &quot;;</a>
<a name="ln4098">                                    else if (l-&gt;syllabic() == Lyrics::Syllabic::BEGIN || l-&gt;syllabic() == Lyrics:: Syllabic::MIDDLE)</a>
<a name="ln4099">                                          result += lyric;</a>
<a name="ln4100">                                    }</a>
<a name="ln4101">                              }</a>
<a name="ln4102">                        }</a>
<a name="ln4103">                  }</a>
<a name="ln4104">            if (found)</a>
<a name="ln4105">                  result += &quot;\n\n&quot;;</a>
<a name="ln4106">            }</a>
<a name="ln4107">      return result.trimmed();</a>
<a name="ln4108">      }</a>
<a name="ln4109"> </a>
<a name="ln4110">//---------------------------------------------------------</a>
<a name="ln4111">//   keysig</a>
<a name="ln4112">//---------------------------------------------------------</a>
<a name="ln4113"> </a>
<a name="ln4114">int Score::keysig()</a>
<a name="ln4115">      {</a>
<a name="ln4116">      Key result = Key::C;</a>
<a name="ln4117">      for (int staffIdx = 0; staffIdx &lt; nstaves(); ++staffIdx) {</a>
<a name="ln4118">            Staff* st = staff(staffIdx);</a>
<a name="ln4119">            constexpr Fraction t(0,1);</a>
<a name="ln4120">            Key key = st-&gt;key(t);</a>
<a name="ln4121">            if (st-&gt;staffType(t)-&gt;group() == StaffGroup::PERCUSSION || st-&gt;keySigEvent(t).custom() || st-&gt;keySigEvent(t).isAtonal())       // ignore percussion and custom / atonal key</a>
<a name="ln4122">                  continue;</a>
<a name="ln4123">            result = key;</a>
<a name="ln4124">            int diff = st-&gt;part()-&gt;instrument()-&gt;transpose().chromatic;</a>
<a name="ln4125">            if (!styleB(Sid::concertPitch) &amp;&amp; diff)</a>
<a name="ln4126">                  result = transposeKey(key, diff, st-&gt;part()-&gt;preferSharpFlat());</a>
<a name="ln4127">            break;</a>
<a name="ln4128">            }</a>
<a name="ln4129">      return int(result);</a>
<a name="ln4130">      }</a>
<a name="ln4131"> </a>
<a name="ln4132">//---------------------------------------------------------</a>
<a name="ln4133">//   duration</a>
<a name="ln4134">//---------------------------------------------------------</a>
<a name="ln4135"> </a>
<a name="ln4136">int Score::duration()</a>
<a name="ln4137">      {</a>
<a name="ln4138">      masterScore()-&gt;setExpandRepeats(true);</a>
<a name="ln4139">      const RepeatList&amp; rl = repeatList();</a>
<a name="ln4140">      if (rl.empty())</a>
<a name="ln4141">            return 0;</a>
<a name="ln4142">      const RepeatSegment* rs = rl.last();</a>
<a name="ln4143">      return lrint(utick2utime(rs-&gt;utick + rs-&gt;len()));</a>
<a name="ln4144">      }</a>
<a name="ln4145"> </a>
<a name="ln4146">//---------------------------------------------------------</a>
<a name="ln4147">//   createRehearsalMarkText</a>
<a name="ln4148">//---------------------------------------------------------</a>
<a name="ln4149"> </a>
<a name="ln4150">QString Score::createRehearsalMarkText(RehearsalMark* current) const</a>
<a name="ln4151">      {</a>
<a name="ln4152">      Fraction tick = current-&gt;segment()-&gt;tick();</a>
<a name="ln4153">      RehearsalMark* before = 0;</a>
<a name="ln4154">      RehearsalMark* after = 0;</a>
<a name="ln4155">      for (Segment* s = firstSegment(SegmentType::All); s; s = s-&gt;next1()) {</a>
<a name="ln4156">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln4157">                  if (e &amp;&amp; e-&gt;type() == ElementType::REHEARSAL_MARK) {</a>
<a name="ln4158">                        if (s-&gt;tick() &lt; tick)</a>
<a name="ln4159">                              before = toRehearsalMark(e);</a>
<a name="ln4160">                        else if (s-&gt;tick() &gt; tick) {</a>
<a name="ln4161">                              after = toRehearsalMark(e);</a>
<a name="ln4162">                              break;</a>
<a name="ln4163">                              }</a>
<a name="ln4164">                        }</a>
<a name="ln4165">                  }</a>
<a name="ln4166">            if (after)</a>
<a name="ln4167">                  break;</a>
<a name="ln4168">            }</a>
<a name="ln4169">      QString s = &quot;A&quot;;</a>
<a name="ln4170">      QString s1 = before ? before-&gt;xmlText() : &quot;&quot;;</a>
<a name="ln4171">      QString s2 = after ? after-&gt;xmlText()  : &quot;&quot;;</a>
<a name="ln4172">      if (s1.isEmpty())</a>
<a name="ln4173">            return s;</a>
<a name="ln4174">      s = nextRehearsalMarkText(before, current);     // try to sequence</a>
<a name="ln4175">      if (s == current-&gt;xmlText()) {</a>
<a name="ln4176">            // no sequence detected (or current happens to be correct)</a>
<a name="ln4177">            return s;</a>
<a name="ln4178">            }</a>
<a name="ln4179">      else if (s == s2) {</a>
<a name="ln4180">            // next in sequence already present</a>
<a name="ln4181">            if (s1[0].isLetter()) {</a>
<a name="ln4182">                  if (s1.size() == 2)</a>
<a name="ln4183">                        s = s1[0] + QChar::fromLatin1(s1[1].toLatin1() + 1);  // BB, BC, CC</a>
<a name="ln4184">                  else</a>
<a name="ln4185">                        s = s1 + QChar::fromLatin1('1');                      // B, B1, C</a>
<a name="ln4186">                  }</a>
<a name="ln4187">            else {</a>
<a name="ln4188">                  s = s1 + QChar::fromLatin1('A');                            // 2, 2A, 3</a>
<a name="ln4189">                  }</a>
<a name="ln4190">            }</a>
<a name="ln4191">      return s;</a>
<a name="ln4192">      }</a>
<a name="ln4193"> </a>
<a name="ln4194">//---------------------------------------------------------</a>
<a name="ln4195">//   nextRehearsalMarkText</a>
<a name="ln4196">//    finds next rehearsal in sequence established by previous</a>
<a name="ln4197">//     Alphabetic sequences:</a>
<a name="ln4198">//      A, B, ..., Y, Z, AA, BB, ..., YY, ZZ</a>
<a name="ln4199">//      a, b, ..., y, z, aa, bb, ..., yy, zz</a>
<a name="ln4200">//     Numeric sequences:</a>
<a name="ln4201">//      1, 2, 3, ...</a>
<a name="ln4202">//      If number of previous rehearsal mark matches measure number, assume use of measure numbers throughout</a>
<a name="ln4203">//---------------------------------------------------------</a>
<a name="ln4204"> </a>
<a name="ln4205">QString Score::nextRehearsalMarkText(RehearsalMark* previous, RehearsalMark* current) const</a>
<a name="ln4206">      {</a>
<a name="ln4207">      QString previousText = previous-&gt;xmlText();</a>
<a name="ln4208">      QString fallback = current ? current-&gt;xmlText() : previousText + &quot;'&quot;;</a>
<a name="ln4209"> </a>
<a name="ln4210">      if (previousText.length() == 1 &amp;&amp; previousText[0].isLetter()) {</a>
<a name="ln4211">            // single letter sequence</a>
<a name="ln4212">            if (previousText == &quot;Z&quot;)</a>
<a name="ln4213">                  return &quot;AA&quot;;</a>
<a name="ln4214">            else if (previousText == &quot;z&quot;)</a>
<a name="ln4215">                  return &quot;aa&quot;;</a>
<a name="ln4216">            else</a>
<a name="ln4217">                  return QChar::fromLatin1(previousText[0].toLatin1() + 1);</a>
<a name="ln4218">            }</a>
<a name="ln4219">      else if (previousText.length() == 2 &amp;&amp; previousText[0].isLetter() &amp;&amp; previousText[1].isLetter()) {</a>
<a name="ln4220">            // double letter sequence</a>
<a name="ln4221">            if (previousText[0] == previousText[1]) {</a>
<a name="ln4222">                  // repeated letter sequence</a>
<a name="ln4223">                  if (previousText.toUpper() != &quot;ZZ&quot;) {</a>
<a name="ln4224">                        QString c = QChar::fromLatin1(previousText[0].toLatin1() + 1);</a>
<a name="ln4225">                        return c + c;</a>
<a name="ln4226">                        }</a>
<a name="ln4227">                  else {</a>
<a name="ln4228">                        return fallback;</a>
<a name="ln4229">                        }</a>
<a name="ln4230">                  }</a>
<a name="ln4231">            else {</a>
<a name="ln4232">                  return fallback;</a>
<a name="ln4233">                  }</a>
<a name="ln4234">            }</a>
<a name="ln4235">      else {</a>
<a name="ln4236">            // try to interpret as number</a>
<a name="ln4237">            bool ok;</a>
<a name="ln4238">            int n = previousText.toInt(&amp;ok);</a>
<a name="ln4239">            if (!ok) {</a>
<a name="ln4240">                  return fallback;</a>
<a name="ln4241">                  }</a>
<a name="ln4242">            else if (current &amp;&amp; n == previous-&gt;segment()-&gt;measure()-&gt;no() + 1) {</a>
<a name="ln4243">                  // use measure number</a>
<a name="ln4244">                  n = current-&gt;segment()-&gt;measure()-&gt;no() + 1;</a>
<a name="ln4245">                  return QString(&quot;%1&quot;).arg(n);</a>
<a name="ln4246">                  }</a>
<a name="ln4247">            else {</a>
<a name="ln4248">                  // use number sequence</a>
<a name="ln4249">                  n = previousText.toInt() + 1;</a>
<a name="ln4250">                  return QString(&quot;%1&quot;).arg(n);</a>
<a name="ln4251">                  }</a>
<a name="ln4252">            }</a>
<a name="ln4253">      }</a>
<a name="ln4254"> </a>
<a name="ln4255">//---------------------------------------------------------</a>
<a name="ln4256">//   changeVoice</a>
<a name="ln4257">//    moves selected notes into specified voice if possible</a>
<a name="ln4258">//---------------------------------------------------------</a>
<a name="ln4259"> </a>
<a name="ln4260">void Score::changeVoice(int voice)</a>
<a name="ln4261">      {</a>
<a name="ln4262">      startCmd();</a>
<a name="ln4263">      QList&lt;Element*&gt; el;</a>
<a name="ln4264">      QList&lt;Element*&gt; oel = selection().elements();     // make copy</a>
<a name="ln4265">      for (Element* e : oel) {</a>
<a name="ln4266">            if (e-&gt;type() == ElementType::NOTE) {</a>
<a name="ln4267">                  Note* note   = toNote(e);</a>
<a name="ln4268">                  Chord* chord = note-&gt;chord();</a>
<a name="ln4269"> </a>
<a name="ln4270">                  // move grace notes with main chord only</a>
<a name="ln4271">                  if (chord-&gt;isGrace())</a>
<a name="ln4272">                        continue;</a>
<a name="ln4273"> </a>
<a name="ln4274">                  if (chord-&gt;voice() != voice) {</a>
<a name="ln4275">                        Segment* s       = chord-&gt;segment();</a>
<a name="ln4276">                        Measure* m       = s-&gt;measure();</a>
<a name="ln4277">                        size_t notes     = chord-&gt;notes().size();</a>
<a name="ln4278">                        int dstTrack     = chord-&gt;staffIdx() * VOICES + voice;</a>
<a name="ln4279">                        ChordRest* dstCR = toChordRest(s-&gt;element(dstTrack));</a>
<a name="ln4280">                        Chord* dstChord  = nullptr;</a>
<a name="ln4281"> </a>
<a name="ln4282">                        if (excerpt() &amp;&amp; excerpt()-&gt;tracks().key(dstTrack, -1) == -1)</a>
<a name="ln4283">                              break;</a>
<a name="ln4284"> </a>
<a name="ln4285">                        // set up destination chord</a>
<a name="ln4286"> </a>
<a name="ln4287">                        if (dstCR &amp;&amp; dstCR-&gt;type() == ElementType::CHORD &amp;&amp; dstCR-&gt;globalTicks() == chord-&gt;globalTicks()) {</a>
<a name="ln4288">                              // existing chord in destination with correct duration;</a>
<a name="ln4289">                              //   can simply move note in</a>
<a name="ln4290">                              dstChord = toChord(dstCR);</a>
<a name="ln4291">                              }</a>
<a name="ln4292"> </a>
<a name="ln4293">                        else if (dstCR &amp;&amp; dstCR-&gt;type() == ElementType::REST &amp;&amp; dstCR-&gt;globalTicks() == chord-&gt;globalTicks()) {</a>
<a name="ln4294">                              // existing rest in destination with correct duration;</a>
<a name="ln4295">                              //   replace with chord, then move note in</a>
<a name="ln4296">                              //   this case allows for tuplets, unlike the more general case below</a>
<a name="ln4297">                              dstChord = new Chord(this);</a>
<a name="ln4298">                              dstChord-&gt;setTrack(dstTrack);</a>
<a name="ln4299">                              dstChord-&gt;setDurationType(chord-&gt;durationType());</a>
<a name="ln4300">                              dstChord-&gt;setTicks(chord-&gt;ticks());</a>
<a name="ln4301">                              dstChord-&gt;setTuplet(dstCR-&gt;tuplet());</a>
<a name="ln4302">                              dstChord-&gt;setParent(s);</a>
<a name="ln4303">                              undoRemoveElement(dstCR);</a>
<a name="ln4304">                              }</a>
<a name="ln4305"> </a>
<a name="ln4306">                        else if (!chord-&gt;tuplet()) {</a>
<a name="ln4307">                              // rests or gap in destination</a>
<a name="ln4308">                              //   insert new chord if the rests / gap are long enough</a>
<a name="ln4309">                              //   then move note in</a>
<a name="ln4310">                              ChordRest* pcr = nullptr;</a>
<a name="ln4311">                              ChordRest* ncr = nullptr;</a>
<a name="ln4312">                              for (Segment* s2 = m-&gt;first(SegmentType::ChordRest); s2; s2 = s2-&gt;next()) {</a>
<a name="ln4313">                                    if (s2-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln4314">                                          continue;</a>
<a name="ln4315">                                    ChordRest* cr2 = toChordRest(s2-&gt;element(dstTrack));</a>
<a name="ln4316">                                    if (!cr2 || cr2-&gt;type() == ElementType::REST)</a>
<a name="ln4317">                                          continue;</a>
<a name="ln4318">                                    if (s2-&gt;tick() &lt; s-&gt;tick()) {</a>
<a name="ln4319">                                          pcr = cr2;</a>
<a name="ln4320">                                          continue;</a>
<a name="ln4321">                                          }</a>
<a name="ln4322">                                    else if (s2-&gt;tick() &gt;= s-&gt;tick()) {</a>
<a name="ln4323">                                          ncr = cr2;</a>
<a name="ln4324">                                          break;</a>
<a name="ln4325">                                          }</a>
<a name="ln4326">                                    }</a>
<a name="ln4327">                              Fraction gapStart = pcr ? pcr-&gt;tick() + pcr-&gt;actualTicks() : m-&gt;tick();</a>
<a name="ln4328">                              Fraction gapEnd   = ncr ? ncr-&gt;tick() : m-&gt;tick() + m-&gt;ticks();</a>
<a name="ln4329">                              if (gapStart &lt;= s-&gt;tick() &amp;&amp; gapEnd &gt;= s-&gt;tick() + chord-&gt;actualTicks()) {</a>
<a name="ln4330">                                    // big enough gap found</a>
<a name="ln4331">                                    dstChord = new Chord(this);</a>
<a name="ln4332">                                    dstChord-&gt;setTrack(dstTrack);</a>
<a name="ln4333">                                    dstChord-&gt;setDurationType(chord-&gt;durationType());</a>
<a name="ln4334">                                    dstChord-&gt;setTicks(chord-&gt;ticks());</a>
<a name="ln4335">                                    dstChord-&gt;setParent(s);</a>
<a name="ln4336">                                    // makeGapVoice will not back-fill an empty voice</a>
<a name="ln4337">                                    if (voice &amp;&amp; !dstCR)</a>
<a name="ln4338">                                          expandVoice(s, /*m-&gt;first(SegmentType::ChordRest,*/ dstTrack);</a>
<a name="ln4339">                                    makeGapVoice(s, dstTrack, chord-&gt;actualTicks(), s-&gt;tick());</a>
<a name="ln4340">                                    }</a>
<a name="ln4341">                              }</a>
<a name="ln4342"> </a>
<a name="ln4343">                        // move note to destination chord</a>
<a name="ln4344">                        if (dstChord) {</a>
<a name="ln4345">                              // create &amp; add new note</a>
<a name="ln4346">                              Note* newNote = new Note(*note);</a>
<a name="ln4347">                              newNote-&gt;setSelected(false);</a>
<a name="ln4348">                              newNote-&gt;setParent(dstChord);</a>
<a name="ln4349">                              undoAddElement(newNote);</a>
<a name="ln4350">                              el.append(newNote);</a>
<a name="ln4351">                              // add new chord if one was created</a>
<a name="ln4352">                              if (dstChord != dstCR)</a>
<a name="ln4353">                                    undoAddCR(dstChord, m, s-&gt;tick());</a>
<a name="ln4354">                              // reconnect the tie to this note, if any</a>
<a name="ln4355">                              Tie* tie = note-&gt;tieBack();</a>
<a name="ln4356">                              if (tie)</a>
<a name="ln4357">                                    undoChangeSpannerElements(tie, tie-&gt;startNote(), newNote);</a>
<a name="ln4358">                              // reconnect the tie from this note, if any</a>
<a name="ln4359">                              tie = note-&gt;tieFor();</a>
<a name="ln4360">                              if (tie)</a>
<a name="ln4361">                                    undoChangeSpannerElements(tie, newNote, tie-&gt;endNote());</a>
<a name="ln4362">                              // remove original note</a>
<a name="ln4363">                              if (notes &gt; 1) {</a>
<a name="ln4364">                                    undoRemoveElement(note);</a>
<a name="ln4365">                                    }</a>
<a name="ln4366">                              else if (notes == 1) {</a>
<a name="ln4367">                                    // create rest to leave behind</a>
<a name="ln4368">                                    Rest* r = new Rest(this);</a>
<a name="ln4369">                                    r-&gt;setTrack(chord-&gt;track());</a>
<a name="ln4370">                                    r-&gt;setDurationType(chord-&gt;durationType());</a>
<a name="ln4371">                                    r-&gt;setTicks(chord-&gt;ticks());</a>
<a name="ln4372">                                    r-&gt;setTuplet(chord-&gt;tuplet());</a>
<a name="ln4373">                                    r-&gt;setParent(s);</a>
<a name="ln4374">                                    // if there were grace notes, move them</a>
<a name="ln4375">                                    for (Chord* gc : chord-&gt;graceNotes()) {</a>
<a name="ln4376">                                          Chord* ngc = new Chord(*gc);</a>
<a name="ln4377">                                          undoRemoveElement(gc);</a>
<a name="ln4378">                                          ngc-&gt;setParent(dstChord);</a>
<a name="ln4379">                                          ngc-&gt;setTrack(dstChord-&gt;track());</a>
<a name="ln4380">                                          undoAddElement(ngc);</a>
<a name="ln4381">                                          }</a>
<a name="ln4382">                                    // remove chord, replace with rest</a>
<a name="ln4383">                                    undoRemoveElement(chord);</a>
<a name="ln4384">                                    undoAddCR(r, m, s-&gt;tick());</a>
<a name="ln4385">                                    }</a>
<a name="ln4386">                              }</a>
<a name="ln4387">                        }</a>
<a name="ln4388">                  }</a>
<a name="ln4389">            }</a>
<a name="ln4390"> </a>
<a name="ln4391">      if (!el.empty())</a>
<a name="ln4392">            selection().clear();</a>
<a name="ln4393">      for (Element* e : el)</a>
<a name="ln4394">            select(e, SelectType::ADD, -1);</a>
<a name="ln4395">      setLayoutAll();</a>
<a name="ln4396">      endCmd();</a>
<a name="ln4397">      }</a>
<a name="ln4398"> </a>
<a name="ln4399">#if 0</a>
<a name="ln4400">//---------------------------------------------------------</a>
<a name="ln4401">//   cropPage - crop a single page score to the content</a>
<a name="ln4402">///    margins will be applied on the 4 sides</a>
<a name="ln4403">//---------------------------------------------------------</a>
<a name="ln4404"> </a>
<a name="ln4405">void Score::cropPage(qreal margins)</a>
<a name="ln4406">      {</a>
<a name="ln4407">      if (npages() == 1) {</a>
<a name="ln4408">            Page* page = pages()[0];</a>
<a name="ln4409">            if (page) {</a>
<a name="ln4410">                  QRectF ttbox = page-&gt;tbbox();</a>
<a name="ln4411"> </a>
<a name="ln4412">                  qreal margin = margins / INCH;</a>
<a name="ln4413">                  f.setSize(QSizeF((ttbox.width() / DPI) + 2 * margin, (ttbox.height()/ DPI) + 2 * margin));</a>
<a name="ln4414"> </a>
<a name="ln4415">                  qreal offset = curFormat-&gt;oddLeftMargin() - ttbox.x() / DPI;</a>
<a name="ln4416">                  if (offset &lt; 0)</a>
<a name="ln4417">                        offset = 0.0;</a>
<a name="ln4418">                  f.setOddLeftMargin(margin + offset);</a>
<a name="ln4419">                  f.setEvenLeftMargin(margin + offset);</a>
<a name="ln4420">                  f.setOddBottomMargin(margin);</a>
<a name="ln4421">                  f.setOddTopMargin(margin);</a>
<a name="ln4422">                  f.setEvenBottomMargin(margin);</a>
<a name="ln4423">                  f.setEvenTopMargin(margin);</a>
<a name="ln4424"> </a>
<a name="ln4425">                  undoChangePageFormat(&amp;f, spatium(), pageNumberOffset());</a>
<a name="ln4426">                  }</a>
<a name="ln4427">            }</a>
<a name="ln4428">      }</a>
<a name="ln4429">#endif</a>
<a name="ln4430"> </a>
<a name="ln4431">//---------------------------------------------------------</a>
<a name="ln4432">//   getProperty</a>
<a name="ln4433">//---------------------------------------------------------</a>
<a name="ln4434"> </a>
<a name="ln4435">QVariant Score::getProperty(Pid /*id*/) const</a>
<a name="ln4436">      {</a>
<a name="ln4437">      qDebug(&quot;Score::getProperty: unhandled id&quot;);</a>
<a name="ln4438">      return QVariant();</a>
<a name="ln4439">      }</a>
<a name="ln4440"> </a>
<a name="ln4441">//---------------------------------------------------------</a>
<a name="ln4442">//   setProperty</a>
<a name="ln4443">//---------------------------------------------------------</a>
<a name="ln4444"> </a>
<a name="ln4445">bool Score::setProperty(Pid /*id*/, const QVariant&amp; /*v*/)</a>
<a name="ln4446">      {</a>
<a name="ln4447">      qDebug(&quot;Score::setProperty: unhandled id&quot;);</a>
<a name="ln4448">      setLayoutAll();</a>
<a name="ln4449">      return true;</a>
<a name="ln4450">      }</a>
<a name="ln4451"> </a>
<a name="ln4452">//---------------------------------------------------------</a>
<a name="ln4453">//   propertyDefault</a>
<a name="ln4454">//---------------------------------------------------------</a>
<a name="ln4455"> </a>
<a name="ln4456">QVariant Score::propertyDefault(Pid /*id*/) const</a>
<a name="ln4457">      {</a>
<a name="ln4458">      return QVariant();</a>
<a name="ln4459">      }</a>
<a name="ln4460"> </a>
<a name="ln4461">//---------------------------------------------------------</a>
<a name="ln4462">//   setStyle</a>
<a name="ln4463">//---------------------------------------------------------</a>
<a name="ln4464"> </a>
<a name="ln4465">void Score::setStyle(const MStyle&amp; s)</a>
<a name="ln4466">      {</a>
<a name="ln4467">      style() = s;</a>
<a name="ln4468">      }</a>
<a name="ln4469"> </a>
<a name="ln4470">//---------------------------------------------------------</a>
<a name="ln4471">//   getTextStyleUserName</a>
<a name="ln4472">//---------------------------------------------------------</a>
<a name="ln4473"> </a>
<a name="ln4474">QString Score::getTextStyleUserName(Tid tid)</a>
<a name="ln4475">      {</a>
<a name="ln4476">      QString name = &quot;&quot;;</a>
<a name="ln4477">      if (int(tid) &gt;= int(Tid::USER1) &amp;&amp; int(tid) &lt;= int(Tid::USER12)) {</a>
<a name="ln4478">            int idx = int(tid) - int(Tid::USER1);</a>
<a name="ln4479">            Sid sid[] = { Sid::user1Name, Sid::user2Name, Sid::user3Name, Sid::user4Name, Sid::user5Name, Sid::user6Name,</a>
<a name="ln4480">                          Sid::user7Name, Sid::user8Name, Sid::user9Name, Sid::user10Name, Sid::user11Name, Sid::user12Name};</a>
<a name="ln4481">            name = styleSt(sid[idx]);</a>
<a name="ln4482">            }</a>
<a name="ln4483">      if (name == &quot;&quot;)</a>
<a name="ln4484">            name = textStyleUserName(tid);</a>
<a name="ln4485">      return name;</a>
<a name="ln4486">      }</a>
<a name="ln4487"> </a>
<a name="ln4488">//---------------------------------------------------------</a>
<a name="ln4489">//   MasterScore</a>
<a name="ln4490">//---------------------------------------------------------</a>
<a name="ln4491"> </a>
<a name="ln4492">MasterScore::MasterScore()</a>
<a name="ln4493">   : Score()</a>
<a name="ln4494">      {</a>
<a name="ln4495">      _tempomap    = new TempoMap;</a>
<a name="ln4496">      _sigmap      = new TimeSigMap();</a>
<a name="ln4497">      _repeatList  = new RepeatList(this);</a>
<a name="ln4498">      _revisions   = new Revisions;</a>
<a name="ln4499">      setMasterScore(this);</a>
<a name="ln4500"> </a>
<a name="ln4501">      _pos[int(POS::CURRENT)] = Fraction(0,1);</a>
<a name="ln4502">      _pos[int(POS::LEFT)]    = Fraction(0,1);</a>
<a name="ln4503">      _pos[int(POS::RIGHT)]   = Fraction(0,1);</a>
<a name="ln4504"> </a>
<a name="ln4505">#if defined(Q_OS_WIN)</a>
<a name="ln4506">      metaTags().insert(&quot;platform&quot;, &quot;Microsoft Windows&quot;);</a>
<a name="ln4507">#elif defined(Q_OS_MAC)</a>
<a name="ln4508">      metaTags().insert(&quot;platform&quot;, &quot;Apple Macintosh&quot;);</a>
<a name="ln4509">#elif defined(Q_OS_LINUX)</a>
<a name="ln4510">      metaTags().insert(&quot;platform&quot;, &quot;Linux&quot;);</a>
<a name="ln4511">#else</a>
<a name="ln4512">      metaTags().insert(&quot;platform&quot;, &quot;Unknown&quot;);</a>
<a name="ln4513">#endif</a>
<a name="ln4514">      metaTags().insert(&quot;movementNumber&quot;, &quot;&quot;);</a>
<a name="ln4515">      metaTags().insert(&quot;movementTitle&quot;, &quot;&quot;);</a>
<a name="ln4516">      metaTags().insert(&quot;workNumber&quot;, &quot;&quot;);</a>
<a name="ln4517">      metaTags().insert(&quot;workTitle&quot;, &quot;&quot;);</a>
<a name="ln4518">      metaTags().insert(&quot;arranger&quot;, &quot;&quot;);</a>
<a name="ln4519">      metaTags().insert(&quot;composer&quot;, &quot;&quot;);</a>
<a name="ln4520">      metaTags().insert(&quot;lyricist&quot;, &quot;&quot;);</a>
<a name="ln4521">      metaTags().insert(&quot;poet&quot;, &quot;&quot;);</a>
<a name="ln4522">      metaTags().insert(&quot;translator&quot;, &quot;&quot;);</a>
<a name="ln4523">      metaTags().insert(&quot;source&quot;, &quot;&quot;);</a>
<a name="ln4524">      metaTags().insert(&quot;copyright&quot;, &quot;&quot;);</a>
<a name="ln4525">      metaTags().insert(&quot;creationDate&quot;, QDate::currentDate().toString(Qt::ISODate));</a>
<a name="ln4526">      }</a>
<a name="ln4527"> </a>
<a name="ln4528">MasterScore::MasterScore(const MStyle&amp; s)</a>
<a name="ln4529">   : MasterScore{}</a>
<a name="ln4530">      {</a>
<a name="ln4531">      _movements = new Movements;</a>
<a name="ln4532">      _movements-&gt;push_back(this);</a>
<a name="ln4533">      setStyle(s);</a>
<a name="ln4534">      }</a>
<a name="ln4535"> </a>
<a name="ln4536">MasterScore::~MasterScore()</a>
<a name="ln4537">      {</a>
<a name="ln4538">      delete _revisions;</a>
<a name="ln4539">      delete _repeatList;</a>
<a name="ln4540">      delete _sigmap;</a>
<a name="ln4541">      delete _tempomap;</a>
<a name="ln4542">      qDeleteAll(_excerpts);</a>
<a name="ln4543">      }</a>
<a name="ln4544"> </a>
<a name="ln4545">//---------------------------------------------------------</a>
<a name="ln4546">//   setMovements</a>
<a name="ln4547">//---------------------------------------------------------</a>
<a name="ln4548"> </a>
<a name="ln4549">void MasterScore::setMovements(Movements* m)</a>
<a name="ln4550">      {</a>
<a name="ln4551">      _movements = m;</a>
<a name="ln4552">      if (_movements)</a>
<a name="ln4553">            _movements-&gt;push_back(this);</a>
<a name="ln4554">      }</a>
<a name="ln4555"> </a>
<a name="ln4556">//---------------------------------------------------------</a>
<a name="ln4557">//   isSavable</a>
<a name="ln4558">//---------------------------------------------------------</a>
<a name="ln4559"> </a>
<a name="ln4560">bool MasterScore::isSavable() const</a>
<a name="ln4561">      {</a>
<a name="ln4562">      // TODO: check if file can be created if it does not exist</a>
<a name="ln4563">      return fileInfo()-&gt;isWritable() || !fileInfo()-&gt;exists();</a>
<a name="ln4564">      }</a>
<a name="ln4565"> </a>
<a name="ln4566">//---------------------------------------------------------</a>
<a name="ln4567">//   setTempomap</a>
<a name="ln4568">//---------------------------------------------------------</a>
<a name="ln4569"> </a>
<a name="ln4570">void MasterScore::setTempomap(TempoMap* tm)</a>
<a name="ln4571">      {</a>
<a name="ln4572">      delete _tempomap;</a>
<a name="ln4573">      _tempomap = tm;</a>
<a name="ln4574">      }</a>
<a name="ln4575"> </a>
<a name="ln4576">//---------------------------------------------------------</a>
<a name="ln4577">//   removeOmr</a>
<a name="ln4578">//---------------------------------------------------------</a>
<a name="ln4579"> </a>
<a name="ln4580">void MasterScore::removeOmr()</a>
<a name="ln4581">      {</a>
<a name="ln4582">      _showOmr = false;</a>
<a name="ln4583">#ifdef OMR</a>
<a name="ln4584">      delete _omr;</a>
<a name="ln4585">#endif</a>
<a name="ln4586">      _omr = 0;</a>
<a name="ln4587">      }</a>
<a name="ln4588"> </a>
<a name="ln4589">//---------------------------------------------------------</a>
<a name="ln4590">//   setName</a>
<a name="ln4591">//---------------------------------------------------------</a>
<a name="ln4592"> </a>
<a name="ln4593">void MasterScore::setName(const QString&amp; ss)</a>
<a name="ln4594">      {</a>
<a name="ln4595">      QString s(ss);</a>
<a name="ln4596">      s.replace('/', '_');    // for sanity</a>
<a name="ln4597">      if (!(s.endsWith(&quot;.mscz&quot;) || s.endsWith(&quot;.mscx&quot;)))</a>
<a name="ln4598">            s += &quot;.mscz&quot;;</a>
<a name="ln4599">      info.setFile(s);</a>
<a name="ln4600">      }</a>
<a name="ln4601"> </a>
<a name="ln4602">//---------------------------------------------------------</a>
<a name="ln4603">//   title</a>
<a name="ln4604">//---------------------------------------------------------</a>
<a name="ln4605"> </a>
<a name="ln4606">QString MasterScore::title() const</a>
<a name="ln4607">      {</a>
<a name="ln4608">      return fileInfo()-&gt;completeBaseName();</a>
<a name="ln4609">      }</a>
<a name="ln4610"> </a>
<a name="ln4611">QString Score::title() const</a>
<a name="ln4612">      {</a>
<a name="ln4613">      return _excerpt-&gt;title();</a>
<a name="ln4614">      }</a>
<a name="ln4615"> </a>
<a name="ln4616">//---------------------------------------------------------</a>
<a name="ln4617">//   addRefresh</a>
<a name="ln4618">//---------------------------------------------------------</a>
<a name="ln4619"> </a>
<a name="ln4620">void Score::addRefresh(const QRectF&amp; r)</a>
<a name="ln4621">      {</a>
<a name="ln4622">      _updateState.refresh |= r;</a>
<a name="ln4623">      cmdState().setUpdateMode(UpdateMode::Update);</a>
<a name="ln4624">      }</a>
<a name="ln4625"> </a>
<a name="ln4626">//---------------------------------------------------------</a>
<a name="ln4627">//   staffIdx</a>
<a name="ln4628">//</a>
<a name="ln4629">///  Return index for the first staff of \a part.</a>
<a name="ln4630">//---------------------------------------------------------</a>
<a name="ln4631"> </a>
<a name="ln4632">int Score::staffIdx(const Part* part) const</a>
<a name="ln4633">      {</a>
<a name="ln4634">      int idx = 0;</a>
<a name="ln4635">      for (Part* p : _parts) {</a>
<a name="ln4636">            if (p == part)</a>
<a name="ln4637">                  break;</a>
<a name="ln4638">            idx += p-&gt;nstaves();</a>
<a name="ln4639">            }</a>
<a name="ln4640">      return idx;</a>
<a name="ln4641">      }</a>
<a name="ln4642"> </a>
<a name="ln4643">//---------------------------------------------------------</a>
<a name="ln4644">//   setUpdateAll</a>
<a name="ln4645">//---------------------------------------------------------</a>
<a name="ln4646"> </a>
<a name="ln4647">void MasterScore::setUpdateAll()</a>
<a name="ln4648">      {</a>
<a name="ln4649">      _cmdState.setUpdateMode(UpdateMode::UpdateAll);</a>
<a name="ln4650">      }</a>
<a name="ln4651"> </a>
<a name="ln4652">//---------------------------------------------------------</a>
<a name="ln4653">//   setLayoutAll</a>
<a name="ln4654">//---------------------------------------------------------</a>
<a name="ln4655"> </a>
<a name="ln4656">void MasterScore::setLayoutAll(int staff, const Element* e)</a>
<a name="ln4657">      {</a>
<a name="ln4658">      _cmdState.setTick(Fraction(0,1));</a>
<a name="ln4659">      _cmdState.setTick(measures()-&gt;last() ? measures()-&gt;last()-&gt;endTick() : Fraction(0,1));</a>
<a name="ln4660"> </a>
<a name="ln4661">      if (e &amp;&amp; e-&gt;score() == this) {</a>
<a name="ln4662">            // TODO: map staff number properly</a>
<a name="ln4663">            const int startStaff = staff == -1 ? 0 : staff;</a>
<a name="ln4664">            const int endStaff = staff == -1 ? (nstaves() - 1) : staff;</a>
<a name="ln4665">            _cmdState.setStaff(startStaff);</a>
<a name="ln4666">            _cmdState.setStaff(endStaff);</a>
<a name="ln4667"> </a>
<a name="ln4668">            _cmdState.setElement(e);</a>
<a name="ln4669">            }</a>
<a name="ln4670">      }</a>
<a name="ln4671"> </a>
<a name="ln4672">//---------------------------------------------------------</a>
<a name="ln4673">//   setLayout</a>
<a name="ln4674">//---------------------------------------------------------</a>
<a name="ln4675"> </a>
<a name="ln4676">void MasterScore::setLayout(const Fraction&amp; t, int staff, const Element* e)</a>
<a name="ln4677">      {</a>
<a name="ln4678">      if (t &gt;= Fraction(0,1))</a>
<a name="ln4679">            _cmdState.setTick(t);</a>
<a name="ln4680"> </a>
<a name="ln4681">      if (e &amp;&amp; e-&gt;score() == this) {</a>
<a name="ln4682">            // TODO: map staff number properly</a>
<a name="ln4683">            _cmdState.setStaff(staff);</a>
<a name="ln4684">            _cmdState.setElement(e);</a>
<a name="ln4685">            }</a>
<a name="ln4686">      }</a>
<a name="ln4687"> </a>
<a name="ln4688">void MasterScore::setLayout(const Fraction&amp; tick1, const Fraction&amp; tick2, int staff1, int staff2, const Element* e)</a>
<a name="ln4689">      {</a>
<a name="ln4690">      if (tick1 &gt;= Fraction(0,1))</a>
<a name="ln4691">            _cmdState.setTick(tick1);</a>
<a name="ln4692">      if (tick2 &gt;= Fraction(0,1))</a>
<a name="ln4693">            _cmdState.setTick(tick2);</a>
<a name="ln4694"> </a>
<a name="ln4695">      if (e &amp;&amp; e-&gt;score() == this) {</a>
<a name="ln4696">            // TODO: map staff number properly</a>
<a name="ln4697">            _cmdState.setStaff(staff1);</a>
<a name="ln4698">            _cmdState.setStaff(staff2);</a>
<a name="ln4699"> </a>
<a name="ln4700">            _cmdState.setElement(e);</a>
<a name="ln4701">            }</a>
<a name="ln4702">      }</a>
<a name="ln4703"> </a>
<a name="ln4704">//---------------------------------------------------------</a>
<a name="ln4705">//   setPlaybackScore</a>
<a name="ln4706">//---------------------------------------------------------</a>
<a name="ln4707"> </a>
<a name="ln4708">void MasterScore::setPlaybackScore(Score* score)</a>
<a name="ln4709">      {</a>
<a name="ln4710">      if (_playbackScore == score)</a>
<a name="ln4711">            return;</a>
<a name="ln4712"> </a>
<a name="ln4713">      _playbackScore = score;</a>
<a name="ln4714">      _playbackSettingsLinks.clear();</a>
<a name="ln4715"> </a>
<a name="ln4716">      if (!_playbackScore)</a>
<a name="ln4717">            return;</a>
<a name="ln4718"> </a>
<a name="ln4719">      for (MidiMapping&amp; mm : _midiMapping)</a>
<a name="ln4720">            mm.articulation()-&gt;setSoloMute(true);</a>
<a name="ln4721">      for (Part* part : score-&gt;parts()) {</a>
<a name="ln4722">            for (auto&amp; i : *part-&gt;instruments()) {</a>
<a name="ln4723">                  Instrument* instr = i.second;</a>
<a name="ln4724">                  for (Channel* ch : instr-&gt;channel()) {</a>
<a name="ln4725">                        Channel* pChannel = playbackChannel(ch);</a>
<a name="ln4726">                        Q_ASSERT(pChannel);</a>
<a name="ln4727">                        if (!pChannel)</a>
<a name="ln4728">                              continue;</a>
<a name="ln4729">                        _playbackSettingsLinks.emplace_back(pChannel, ch, /* excerpt */ true);</a>
<a name="ln4730">                        }</a>
<a name="ln4731">                  }</a>
<a name="ln4732">            }</a>
<a name="ln4733">      }</a>
<a name="ln4734"> </a>
<a name="ln4735">//---------------------------------------------------------</a>
<a name="ln4736">//   updateExpressive</a>
<a name="ln4737">//    change patches to their expressive equivalent or vica versa, if possible</a>
<a name="ln4738">//    This works only with MuseScore general soundfont</a>
<a name="ln4739">//</a>
<a name="ln4740">//    The first version of the function decides whether to make patches expressive</a>
<a name="ln4741">//    or not, based on the synth settings. The second will switch patches based on</a>
<a name="ln4742">//    the value of the expressive parameter.</a>
<a name="ln4743">//---------------------------------------------------------</a>
<a name="ln4744"> </a>
<a name="ln4745">void MasterScore::updateExpressive(Synthesizer* synth)</a>
<a name="ln4746">      {</a>
<a name="ln4747">      SynthesizerState s = synthesizerState();</a>
<a name="ln4748">      SynthesizerGroup g = s.group(&quot;master&quot;);</a>
<a name="ln4749"> </a>
<a name="ln4750">      int method = 1;</a>
<a name="ln4751">      for (IdValue idVal : g) {</a>
<a name="ln4752">            if (idVal.id == 4) {</a>
<a name="ln4753">                  method = idVal.data.toInt();</a>
<a name="ln4754">                  break;</a>
<a name="ln4755">                  }</a>
<a name="ln4756">            }</a>
<a name="ln4757"> </a>
<a name="ln4758">      updateExpressive(synth, (method != 0));</a>
<a name="ln4759">      }</a>
<a name="ln4760"> </a>
<a name="ln4761"> </a>
<a name="ln4762">void MasterScore::updateExpressive(Synthesizer* synth, bool expressive, bool force /* = false */)</a>
<a name="ln4763">      {</a>
<a name="ln4764">      if (!synth)</a>
<a name="ln4765">            return;</a>
<a name="ln4766"> </a>
<a name="ln4767">      if (!force) {</a>
<a name="ln4768">            SynthesizerState s = synthesizerState();</a>
<a name="ln4769">            SynthesizerGroup g = s.group(&quot;master&quot;);</a>
<a name="ln4770"> </a>
<a name="ln4771">            for (IdValue idVal : g) {</a>
<a name="ln4772">                  if (idVal.id == 4) {</a>
<a name="ln4773">                        int method = idVal.data.toInt();</a>
<a name="ln4774">                        if (expressive == (method == 0))</a>
<a name="ln4775">                              return; // method and expression change don't match, so don't switch}</a>
<a name="ln4776">                        }</a>
<a name="ln4777">                  }</a>
<a name="ln4778">            }</a>
<a name="ln4779"> </a>
<a name="ln4780">      for (Part* p : parts()) {</a>
<a name="ln4781">            const InstrumentList* il = p-&gt;instruments();</a>
<a name="ln4782">            for (auto it = il-&gt;begin(); it != il-&gt;end(); it++) {</a>
<a name="ln4783">                  Instrument* i = it-&gt;second;</a>
<a name="ln4784">                  i-&gt;switchExpressive(this, synth, expressive, force);</a>
<a name="ln4785">                  }</a>
<a name="ln4786">            }</a>
<a name="ln4787"> </a>
<a name="ln4788">      }</a>
<a name="ln4789"> </a>
<a name="ln4790">//---------------------------------------------------------</a>
<a name="ln4791">//   rebuildAndUpdateExpressive</a>
<a name="ln4792">//    implicitly rebuild midi mappings as well. Should be preferred over</a>
<a name="ln4793">//    just updateExpressive, in most cases.</a>
<a name="ln4794">//---------------------------------------------------------</a>
<a name="ln4795"> </a>
<a name="ln4796">void MasterScore::rebuildAndUpdateExpressive(Synthesizer* synth)</a>
<a name="ln4797">      {</a>
<a name="ln4798">      // Rebuild midi mappings to make sure we have playback channels</a>
<a name="ln4799">      rebuildMidiMapping();</a>
<a name="ln4800"> </a>
<a name="ln4801">      updateExpressive(synth);</a>
<a name="ln4802"> </a>
<a name="ln4803">      // Rebuild midi mappings again to be safe</a>
<a name="ln4804">      rebuildMidiMapping();</a>
<a name="ln4805">      }</a>
<a name="ln4806"> </a>
<a name="ln4807">//---------------------------------------------------------</a>
<a name="ln4808">//   isTopScore</a>
<a name="ln4809">//---------------------------------------------------------</a>
<a name="ln4810"> </a>
<a name="ln4811">bool Score::isTopScore() const</a>
<a name="ln4812">      {</a>
<a name="ln4813">      return !(isMaster() &amp;&amp; static_cast&lt;const MasterScore*&gt;(this)-&gt;prev());</a>
<a name="ln4814">      }</a>
<a name="ln4815"> </a>
<a name="ln4816">//---------------------------------------------------------</a>
<a name="ln4817">//   Movements</a>
<a name="ln4818">//---------------------------------------------------------</a>
<a name="ln4819"> </a>
<a name="ln4820">Movements::Movements()</a>
<a name="ln4821">   : std::vector&lt;MasterScore*&gt;()</a>
<a name="ln4822">      {</a>
<a name="ln4823">      _undo = new UndoStack();</a>
<a name="ln4824">      }</a>
<a name="ln4825"> </a>
<a name="ln4826">Movements::~Movements()</a>
<a name="ln4827">      {</a>
<a name="ln4828">      qDeleteAll(_pages);</a>
<a name="ln4829">      delete _undo;</a>
<a name="ln4830">      }</a>
<a name="ln4831"> </a>
<a name="ln4832">//---------------------------------------------------------</a>
<a name="ln4833">//   ScoreLoad::_loading</a>
<a name="ln4834">//    If the _loading &gt; 0 then pushes and pops to</a>
<a name="ln4835">//    the undo stack do not emit a warning.</a>
<a name="ln4836">//    Usually pushes and pops to the undo stack are only</a>
<a name="ln4837">//    valid inside a startCmd() - endCmd(). Exceptions</a>
<a name="ln4838">//    occurred during score loading.</a>
<a name="ln4839">//---------------------------------------------------------</a>
<a name="ln4840"> </a>
<a name="ln4841">int ScoreLoad::_loading = 0;</a>
<a name="ln4842"> </a>
<a name="ln4843">}</a>
<a name="ln4844"> </a>

</code></pre>
<div class="balloon" rel="725"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The '* seg' variable was assigned the same value.</p></div>
<div class="balloon" rel="3695"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
