
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>tie.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2013 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;measure.h&quot;</a>
<a name="ln14">#include &quot;score.h&quot;</a>
<a name="ln15">#include &quot;system.h&quot;</a>
<a name="ln16">#include &quot;undo.h&quot;</a>
<a name="ln17">#include &quot;chord.h&quot;</a>
<a name="ln18">#include &quot;tie.h&quot;</a>
<a name="ln19"> </a>
<a name="ln20">namespace Ms {</a>
<a name="ln21"> </a>
<a name="ln22">Note* Tie::editStartNote;</a>
<a name="ln23">Note* Tie::editEndNote;</a>
<a name="ln24"> </a>
<a name="ln25">//---------------------------------------------------------</a>
<a name="ln26">//   draw</a>
<a name="ln27">//---------------------------------------------------------</a>
<a name="ln28"> </a>
<a name="ln29">void TieSegment::draw(QPainter* painter) const</a>
<a name="ln30">      {</a>
<a name="ln31">      // hide tie toward the second chord of a cross-measure value</a>
<a name="ln32">      if (tie()-&gt;endNote() &amp;&amp; tie()-&gt;endNote()-&gt;chord()-&gt;crossMeasure() == CrossMeasure::SECOND)</a>
<a name="ln33">            return;</a>
<a name="ln34"> </a>
<a name="ln35">      QPen pen(curColor());</a>
<a name="ln36">      qreal mag = staff() ? staff()-&gt;mag(tie()-&gt;tick()) : 1.0;</a>
<a name="ln37">      switch (slurTie()-&gt;lineType()) {</a>
<a name="ln38">            case 0:</a>
<a name="ln39">                  painter-&gt;setBrush(QBrush(pen.color()));</a>
<a name="ln40">                  pen.setCapStyle(Qt::RoundCap);</a>
<a name="ln41">                  pen.setJoinStyle(Qt::RoundJoin);</a>
<a name="ln42">                  pen.setWidthF(score()-&gt;styleP(Sid::SlurEndWidth) * mag);</a>
<a name="ln43">                  break;</a>
<a name="ln44">            case 1:</a>
<a name="ln45">                  painter-&gt;setBrush(Qt::NoBrush);</a>
<a name="ln46">                  pen.setWidthF(score()-&gt;styleP(Sid::SlurDottedWidth) * mag);</a>
<a name="ln47">                  pen.setStyle(Qt::DotLine);</a>
<a name="ln48">                  break;</a>
<a name="ln49">            case 2:</a>
<a name="ln50">                  painter-&gt;setBrush(Qt::NoBrush);</a>
<a name="ln51">                  pen.setWidthF(score()-&gt;styleP(Sid::SlurDottedWidth) * mag);</a>
<a name="ln52">                  pen.setStyle(Qt::DashLine);</a>
<a name="ln53">                  break;</a>
<a name="ln54">            case 3:</a>
<a name="ln55">                  painter-&gt;setBrush(Qt::NoBrush);</a>
<a name="ln56">                  pen.setWidthF(score()-&gt;styleP(Sid::SlurDottedWidth) * mag);</a>
<a name="ln57">                  pen.setStyle(Qt::CustomDashLine);</a>
<a name="ln58">                  QVector&lt;qreal&gt; dashes { 5.0, 5.0 };</a>
<a name="ln59">                  pen.setDashPattern(dashes);</a>
<a name="ln60">                  break;</a>
<a name="ln61">            }</a>
<a name="ln62">      painter-&gt;setPen(pen);</a>
<a name="ln63">      painter-&gt;drawPath(path);</a>
<a name="ln64">      }</a>
<a name="ln65"> </a>
<a name="ln66">//---------------------------------------------------------</a>
<a name="ln67">//   edit</a>
<a name="ln68">//    return true if event is accepted</a>
<a name="ln69">//---------------------------------------------------------</a>
<a name="ln70"> </a>
<a name="ln71">bool TieSegment::edit(EditData&amp; ed)</a>
<a name="ln72">      {</a>
<a name="ln73">      SlurTie* sl = tie();</a>
<a name="ln74"> </a>
<a name="ln75">      if (ed.key == Qt::Key_X) {</a>
<a name="ln76">            sl-&gt;setSlurDirection(sl-&gt;up() ? Direction::DOWN : Direction::UP);</a>
<a name="ln77">            sl-&gt;layout();</a>
<a name="ln78">            return true;</a>
<a name="ln79">            }</a>
<a name="ln80">      if (ed.key == Qt::Key_Home) {</a>
<a name="ln81">            ups(ed.curGrip).off = QPointF();</a>
<a name="ln82">            sl-&gt;layout();</a>
<a name="ln83">            return true;</a>
<a name="ln84">            }</a>
<a name="ln85">      return false;</a>
<a name="ln86">      }</a>
<a name="ln87"> </a>
<a name="ln88">//---------------------------------------------------------</a>
<a name="ln89">//   changeAnchor</a>
<a name="ln90">//---------------------------------------------------------</a>
<a name="ln91"> </a>
<a name="ln92">void TieSegment::changeAnchor(EditData&amp; ed, Element* element)</a>
<a name="ln93">      {</a>
<a name="ln94">      if (ed.curGrip == Grip::START) {</a>
<a name="ln95">            spanner()-&gt;setStartElement(element);</a>
<a name="ln96">            Note* note = toNote(element);</a>
<a name="ln97">            if (note-&gt;chord()-&gt;tick() &lt;= tie()-&gt;endNote()-&gt;chord()-&gt;tick()) {</a>
<a name="ln98">                  tie()-&gt;startNote()-&gt;setTieFor(0);</a>
<a name="ln99">                  tie()-&gt;setStartNote(note);</a>
<a name="ln100">                  note-&gt;setTieFor(tie());</a>
<a name="ln101">                  }</a>
<a name="ln102">            }</a>
<a name="ln103">      else {</a>
<a name="ln104">            spanner()-&gt;setEndElement(element);</a>
<a name="ln105">            Note* note = toNote(element);</a>
<a name="ln106">            // do not allow backward ties</a>
<a name="ln107">            if (note-&gt;chord()-&gt;tick() &gt;= tie()-&gt;startNote()-&gt;chord()-&gt;tick()) {</a>
<a name="ln108">                  tie()-&gt;endNote()-&gt;setTieBack(0);</a>
<a name="ln109">                  tie()-&gt;setEndNote(note);</a>
<a name="ln110">                  note-&gt;setTieBack(tie());</a>
<a name="ln111">                  }</a>
<a name="ln112">            }</a>
<a name="ln113"> </a>
<a name="ln114">      const size_t segments  = spanner()-&gt;spannerSegments().size();</a>
<a name="ln115">      ups(ed.curGrip).off = QPointF();</a>
<a name="ln116">      spanner()-&gt;layout();</a>
<a name="ln117">      if (spanner()-&gt;spannerSegments().size() != segments) {</a>
<a name="ln118">            const std::vector&lt;SpannerSegment*&gt;&amp; ss = spanner()-&gt;spannerSegments();</a>
<a name="ln119"> </a>
<a name="ln120">            TieSegment* newSegment = toTieSegment(ed.curGrip == Grip::END ? ss.back() : ss.front());</a>
<a name="ln121">            score()-&gt;endCmd();</a>
<a name="ln122">            score()-&gt;startCmd();</a>
<a name="ln123">            ed.view-&gt;startEdit(newSegment, ed.curGrip);</a>
<a name="ln124">            triggerLayoutAll();</a>
<a name="ln125">            }</a>
<a name="ln126">      }</a>
<a name="ln127"> </a>
<a name="ln128">//---------------------------------------------------------</a>
<a name="ln129">//   editDrag</a>
<a name="ln130">//---------------------------------------------------------</a>
<a name="ln131"> </a>
<a name="ln132">void TieSegment::editDrag(EditData&amp; ed)</a>
<a name="ln133">      {</a>
<a name="ln134">      Grip g = ed.curGrip;</a>
<a name="ln135">      ups(g).off += ed.delta;</a>
<a name="ln136"> </a>
<a name="ln137">      if (g == Grip::START || g == Grip::END) {</a>
<a name="ln138">            computeBezier();</a>
<a name="ln139">            //</a>
<a name="ln140">            // move anchor for slurs/ties</a>
<a name="ln141">            //</a>
<a name="ln142">            if ((g == Grip::START &amp;&amp; isSingleBeginType()) || (g == Grip::END &amp;&amp; isSingleEndType())) {</a>
<a name="ln143">                  Spanner* spanner = tie();</a>
<a name="ln144">                  Element* e = ed.view-&gt;elementNear(ed.pos);</a>
<a name="ln145">                  Note* note = (e &amp;&amp; e-&gt;isNote()) ? toNote(e) : nullptr;</a>
<a name="ln146">                  if (note &amp;&amp; ((g == Grip::END &amp;&amp; note-&gt;tick() &gt; tie()-&gt;tick()) || (g == Grip::START &amp;&amp; note-&gt;tick() &lt; tie()-&gt;tick2()))) {</a>
<a name="ln147">                        if (g == Grip::END) {</a>
<a name="ln148">                              Tie* tie = toTie(spanner);</a>
<a name="ln149">                              if (tie-&gt;startNote()-&gt;pitch() == note-&gt;pitch()</a>
<a name="ln150">                                 &amp;&amp; tie-&gt;startNote()-&gt;chord()-&gt;tick() &lt; note-&gt;chord()-&gt;tick()) {</a>
<a name="ln151">                                    ed.view-&gt;setDropTarget(note);</a>
<a name="ln152">                                    if (note != tie-&gt;endNote()) {</a>
<a name="ln153">                                          changeAnchor(ed, note);</a>
<a name="ln154">                                          return;</a>
<a name="ln155">                                          }</a>
<a name="ln156">                                    }</a>
<a name="ln157">                              }</a>
<a name="ln158">                        }</a>
<a name="ln159">                  else</a>
<a name="ln160">                        ed.view-&gt;setDropTarget(0);</a>
<a name="ln161">                  }</a>
<a name="ln162">            }</a>
<a name="ln163">      else if (g == Grip::BEZIER1 || g == Grip::BEZIER2)</a>
<a name="ln164">            computeBezier();</a>
<a name="ln165">      else if (g == Grip::SHOULDER) {</a>
<a name="ln166">            ups(g).off = QPointF();</a>
<a name="ln167">            computeBezier(ed.delta);</a>
<a name="ln168">            }</a>
<a name="ln169">      else if (g == Grip::DRAG) {</a>
<a name="ln170">            ups(Grip::DRAG).off = QPointF();</a>
<a name="ln171">            roffset() += ed.delta;</a>
<a name="ln172">            }</a>
<a name="ln173"> </a>
<a name="ln174">      // if this SlurSegment was automatically adjusted to avoid collision</a>
<a name="ln175">      // lock this edit by resetting SlurSegment to default position</a>
<a name="ln176">      // and incorporating previous adjustment into user offset</a>
<a name="ln177">      QPointF offset = getAutoAdjust();</a>
<a name="ln178">      if (!offset.isNull()) {</a>
<a name="ln179">            setAutoAdjust(0.0, 0.0);</a>
<a name="ln180">            roffset() += offset;</a>
<a name="ln181">            }</a>
<a name="ln182">      }</a>
<a name="ln183"> </a>
<a name="ln184">//---------------------------------------------------------</a>
<a name="ln185">//   computeBezier</a>
<a name="ln186">//    compute help points of slur bezier segment</a>
<a name="ln187">//---------------------------------------------------------</a>
<a name="ln188"> </a>
<a name="ln189">void TieSegment::computeBezier(QPointF p6o)</a>
<a name="ln190">      {</a>
<a name="ln191">      qreal _spatium  = spatium();</a>
<a name="ln192">      qreal shoulderW;              // height as fraction of slur-length</a>
<a name="ln193">      qreal shoulderH;</a>
<a name="ln194"> </a>
<a name="ln195">      //</a>
<a name="ln196">      // pp1      start of slur</a>
<a name="ln197">      // pp2      end of slur</a>
<a name="ln198">      // pp3      bezier 1</a>
<a name="ln199">      // pp4      bezier 2</a>
<a name="ln200">      // pp5      drag</a>
<a name="ln201">      // pp6      shoulder</a>
<a name="ln202">      //</a>
<a name="ln203">      QPointF pp1 = ups(Grip::START).p + ups(Grip::START).off;</a>
<a name="ln204">      QPointF pp2 = ups(Grip::END).p   + ups(Grip::END).off;</a>
<a name="ln205"> </a>
<a name="ln206">      QPointF p2 = pp2 - pp1;       // normalize to zero</a>
<a name="ln207">      if (p2.x() == 0.0) {</a>
<a name="ln208">            qDebug(&quot;zero tie&quot;);</a>
<a name="ln209">            return;</a>
<a name="ln210">            }</a>
<a name="ln211"> </a>
<a name="ln212">      qreal sinb = atan(p2.y() / p2.x());</a>
<a name="ln213">      QTransform t;</a>
<a name="ln214">      t.rotateRadians(-sinb);</a>
<a name="ln215">      p2  = t.map(p2);</a>
<a name="ln216">      p6o = t.map(p6o);</a>
<a name="ln217"> </a>
<a name="ln218">      double smallH = 0.38;</a>
<a name="ln219">      qreal d   = p2.x() / _spatium;</a>
<a name="ln220">      shoulderH = d * 0.4 * smallH;</a>
<a name="ln221">      shoulderH = qBound(0.4, shoulderH, 1.3);</a>
<a name="ln222">      shoulderH *= _spatium;</a>
<a name="ln223">      shoulderW = .6;</a>
<a name="ln224"> </a>
<a name="ln225">      shoulderH -= p6o.y();</a>
<a name="ln226"> </a>
<a name="ln227">      if (!tie()-&gt;up())</a>
<a name="ln228">            shoulderH = -shoulderH;</a>
<a name="ln229"> </a>
<a name="ln230">      qreal c    = p2.x();</a>
<a name="ln231">      qreal c1   = (c - c * shoulderW) * .5 + p6o.x();</a>
<a name="ln232">      qreal c2   = c1 + c * shoulderW       + p6o.x();</a>
<a name="ln233"> </a>
<a name="ln234">      QPointF p5 = QPointF(c * .5, 0.0);</a>
<a name="ln235"> </a>
<a name="ln236">      QPointF p3(c1, -shoulderH);</a>
<a name="ln237">      QPointF p4(c2, -shoulderH);</a>
<a name="ln238"> </a>
<a name="ln239">      qreal w = score()-&gt;styleP(Sid::SlurMidWidth) - score()-&gt;styleP(Sid::SlurEndWidth);</a>
<a name="ln240">      if (staff())</a>
<a name="ln241">            w *= staff()-&gt;mag(tie()-&gt;tick());</a>
<a name="ln242">      QPointF th(0.0, w);    // thickness of slur</a>
<a name="ln243"> </a>
<a name="ln244">      QPointF p3o = p6o + t.map(ups(Grip::BEZIER1).off);</a>
<a name="ln245">      QPointF p4o = p6o + t.map(ups(Grip::BEZIER2).off);</a>
<a name="ln246"> </a>
<a name="ln247">      if(!p6o.isNull()) {</a>
<a name="ln248">            QPointF p6i = t.inverted().map(p6o);</a>
<a name="ln249">            ups(Grip::BEZIER1).off += p6i ;</a>
<a name="ln250">            ups(Grip::BEZIER2).off += p6i;</a>
<a name="ln251">            }</a>
<a name="ln252"> </a>
<a name="ln253">      //-----------------------------------calculate p6</a>
<a name="ln254">      QPointF pp3  = p3 + p3o;</a>
<a name="ln255">      QPointF pp4  = p4 + p4o;</a>
<a name="ln256">      QPointF ppp4 = pp4 - pp3;</a>
<a name="ln257"> </a>
<a name="ln258">      qreal r2 = atan(ppp4.y() / ppp4.x());</a>
<a name="ln259">      t.reset();</a>
<a name="ln260">      t.rotateRadians(-r2);</a>
<a name="ln261">      QPointF p6  = QPointF(t.map(ppp4).x() * .5, 0.0);</a>
<a name="ln262"> </a>
<a name="ln263">      t.rotateRadians(2 * r2);</a>
<a name="ln264">      p6 = t.map(p6) + pp3 - p6o;</a>
<a name="ln265">      //-----------------------------------</a>
<a name="ln266"> </a>
<a name="ln267">      path = QPainterPath();</a>
<a name="ln268">      path.moveTo(QPointF());</a>
<a name="ln269">      path.cubicTo(p3 + p3o - th, p4 + p4o - th, p2);</a>
<a name="ln270">      if (tie()-&gt;lineType() == 0)</a>
<a name="ln271">            path.cubicTo(p4 +p4o + th, p3 + p3o + th, QPointF());</a>
<a name="ln272"> </a>
<a name="ln273">      th = QPointF(0.0, 3.0 * w);</a>
<a name="ln274">      shapePath = QPainterPath();</a>
<a name="ln275">      shapePath.moveTo(QPointF());</a>
<a name="ln276">      shapePath.cubicTo(p3 + p3o - th, p4 + p4o - th, p2);</a>
<a name="ln277">      shapePath.cubicTo(p4 +p4o + th, p3 + p3o + th, QPointF());</a>
<a name="ln278"> </a>
<a name="ln279">      // translate back</a>
<a name="ln280">      double y = pp1.y();</a>
<a name="ln281">      const double offsetFactor = 0.2;</a>
<a name="ln282">      if (staff()-&gt;isTabStaff(slurTie()-&gt;tick()))</a>
<a name="ln283">          y += (_spatium * (slurTie()-&gt;up() ? -offsetFactor : offsetFactor));</a>
<a name="ln284">      t.reset();</a>
<a name="ln285">      t.translate(pp1.x(), y);</a>
<a name="ln286">      t.rotateRadians(sinb);</a>
<a name="ln287">      path                  = t.map(path);</a>
<a name="ln288">      shapePath             = t.map(shapePath);</a>
<a name="ln289">      ups(Grip::BEZIER1).p  = t.map(p3);</a>
<a name="ln290">      ups(Grip::BEZIER2).p  = t.map(p4);</a>
<a name="ln291">      ups(Grip::END).p      = t.map(p2) - ups(Grip::END).off;</a>
<a name="ln292">      ups(Grip::DRAG).p     = t.map(p5);</a>
<a name="ln293">      ups(Grip::SHOULDER).p = t.map(p6);</a>
<a name="ln294"> </a>
<a name="ln295">//      QPointF staffOffset;</a>
<a name="ln296">//      if (system() &amp;&amp; track() &gt;= 0)</a>
<a name="ln297">//            staffOffset = QPointF(0.0, -system()-&gt;staff(staffIdx())-&gt;y());</a>
<a name="ln298"> </a>
<a name="ln299">//      path.translate(staffOffset);</a>
<a name="ln300">//      shapePath.translate(staffOffset);</a>
<a name="ln301"> </a>
<a name="ln302">      _shape.clear();</a>
<a name="ln303">      QPointF start;</a>
<a name="ln304">      start = t.map(start);</a>
<a name="ln305"> </a>
<a name="ln306">      qreal minH = qAbs(3.0 * w);</a>
<a name="ln307">      int nbShapes = 15;</a>
<a name="ln308">      const CubicBezier b(pp1, ups(Grip::BEZIER1).pos(), ups(Grip::BEZIER2).pos(), ups(Grip::END).pos());</a>
<a name="ln309">      for (int i = 1; i &lt;= nbShapes; i++) {</a>
<a name="ln310">            const QPointF point = b.pointAtPercent(i/float(nbShapes));</a>
<a name="ln311">            QRectF re = QRectF(start, point).normalized();</a>
<a name="ln312">            if (re.height() &lt; minH) {</a>
<a name="ln313">                  d = (minH - re.height()) * .5;</a>
<a name="ln314">                  re.adjust(0.0, -d, 0.0, d);</a>
<a name="ln315">                  }</a>
<a name="ln316">            _shape.add(re);</a>
<a name="ln317">            start = point;</a>
<a name="ln318">            }</a>
<a name="ln319">      }</a>
<a name="ln320"> </a>
<a name="ln321">//---------------------------------------------------------</a>
<a name="ln322">//   layout</a>
<a name="ln323">//    p1, p2  are in System coordinates</a>
<a name="ln324">//---------------------------------------------------------</a>
<a name="ln325"> </a>
<a name="ln326">void TieSegment::layoutSegment(const QPointF&amp; p1, const QPointF&amp; p2)</a>
<a name="ln327">      {</a>
<a name="ln328">      setPos(QPointF());</a>
<a name="ln329">      ups(Grip::START).p = p1;</a>
<a name="ln330">      ups(Grip::END).p   = p2;</a>
<a name="ln331">      computeBezier();</a>
<a name="ln332"> </a>
<a name="ln333">      QRectF bbox = path.boundingRect();</a>
<a name="ln334"> </a>
<a name="ln335">      // adjust position to avoid staff line if necessary</a>
<a name="ln336">      Staff* st          = staff();</a>
<a name="ln337">      bool reverseAdjust = false;</a>
<a name="ln338"> </a>
<a name="ln339">      if (slurTie()-&gt;isTie() &amp;&amp; st &amp;&amp; !st-&gt;isTabStaff(slurTie()-&gt;tick())) {</a>
<a name="ln340">            // multinote chords with ties need special handling</a>
<a name="ln341">            // otherwise, adjusted tie might crowd an unadjusted tie unnecessarily</a>
<a name="ln342">            Tie* t    = toTie(slurTie());</a>
<a name="ln343">            Note* sn  = t-&gt;startNote();</a>
<a name="ln344">            Chord* sc = sn ? sn-&gt;chord() : 0;</a>
<a name="ln345"> </a>
<a name="ln346">            // normally, the adjustment moves ties according to their direction (eg, up if tie is up)</a>
<a name="ln347">            // but we will reverse this for notes within chords when appropriate</a>
<a name="ln348">            // for two-note chords, it looks better to have notes on spaces tied outside the lines</a>
<a name="ln349"> </a>
<a name="ln350">            if (sc) {</a>
<a name="ln351">                  size_t notes = sc-&gt;notes().size();</a>
<a name="ln352">                  bool onLine = !(sn-&gt;line() &amp; 1);</a>
<a name="ln353">                  if ((onLine &amp;&amp; notes &gt; 1) || (!onLine &amp;&amp; notes &gt; 2))</a>
<a name="ln354">                        reverseAdjust = true;</a>
<a name="ln355">                  }</a>
<a name="ln356">            }</a>
<a name="ln357">      qreal sp          = spatium();</a>
<a name="ln358">      qreal minDistance = 0.5;</a>
<a name="ln359">      autoAdjustOffset  = QPointF();</a>
<a name="ln360">      if (bbox.height() &lt; minDistance * 2 * sp &amp;&amp; st &amp;&amp; !st-&gt;isTabStaff(slurTie()-&gt;tick())) {</a>
<a name="ln361">            // slur/tie is fairly flat</a>
<a name="ln362">            bool up       = slurTie()-&gt;up();</a>
<a name="ln363">            qreal ld      = st-&gt;lineDistance(tick()) * sp;</a>
<a name="ln364">            qreal topY    = bbox.top() / ld;</a>
<a name="ln365">            qreal bottomY = bbox.bottom() / ld;</a>
<a name="ln366">            int lineY     = up ? qRound(topY) : qRound(bottomY);</a>
<a name="ln367">            if (lineY &gt;= 0 &amp;&amp; lineY &lt; st-&gt;lines(tick()) * st-&gt;lineDistance(tick())) {</a>
<a name="ln368">                  // on staff</a>
<a name="ln369">                  if (qAbs(topY - lineY) &lt; minDistance &amp;&amp; qAbs(bottomY - lineY) &lt; minDistance) {</a>
<a name="ln370">                        // too close to line</a>
<a name="ln371">                        if (!isNudged() &amp;&amp; !isEdited()) {</a>
<a name="ln372">                              // user has not nudged or edited</a>
<a name="ln373">                              qreal offY;</a>
<a name="ln374">                              if (up != reverseAdjust)      // exclusive or</a>
<a name="ln375">                                    offY = (lineY - minDistance) - topY;</a>
<a name="ln376">                              else</a>
<a name="ln377">                                    offY = (lineY + minDistance) - bottomY;</a>
<a name="ln378">                              setAutoAdjust(0.0, offY * sp);</a>
<a name="ln379">                              }</a>
<a name="ln380">                        }</a>
<a name="ln381">                  }</a>
<a name="ln382">            }</a>
<a name="ln383">      setbbox(path.boundingRect());</a>
<a name="ln384">      }</a>
<a name="ln385"> </a>
<a name="ln386">//---------------------------------------------------------</a>
<a name="ln387">//   setAutoAdjust</a>
<a name="ln388">//---------------------------------------------------------</a>
<a name="ln389"> </a>
<a name="ln390">void TieSegment::setAutoAdjust(const QPointF&amp; offset)</a>
<a name="ln391">      {</a>
<a name="ln392">      QPointF diff = offset - autoAdjustOffset;</a>
<a name="ln393">      if (!diff.isNull()) {</a>
<a name="ln394">            path.translate(diff);</a>
<a name="ln395">            shapePath.translate(diff);</a>
<a name="ln396">            _shape.translate(diff);</a>
<a name="ln397">            for (int i = 0; i &lt; int(Grip::GRIPS); ++i)</a>
<a name="ln398">                  _ups[i].p += diff;</a>
<a name="ln399">            autoAdjustOffset = offset;</a>
<a name="ln400">            }</a>
<a name="ln401">      }</a>
<a name="ln402"> </a>
<a name="ln403">//---------------------------------------------------------</a>
<a name="ln404">//   isEdited</a>
<a name="ln405">//---------------------------------------------------------</a>
<a name="ln406"> </a>
<a name="ln407">bool TieSegment::isEdited() const</a>
<a name="ln408">      {</a>
<a name="ln409">      for (int i = 0; i &lt; int(Grip::GRIPS); ++i) {</a>
<a name="ln410">            if (!_ups[i].off.isNull())</a>
<a name="ln411">                  return true;</a>
<a name="ln412">            }</a>
<a name="ln413">      return false;</a>
<a name="ln414">      }</a>
<a name="ln415"> </a>
<a name="ln416">//---------------------------------------------------------</a>
<a name="ln417">//   slurPos</a>
<a name="ln418">//    Calculate position of start- and endpoint of slur</a>
<a name="ln419">//    relative to System() position.</a>
<a name="ln420">//---------------------------------------------------------</a>
<a name="ln421"> </a>
<a name="ln422">void Tie::slurPos(SlurPos* sp)</a>
<a name="ln423">      {</a>
<a name="ln424">      bool useTablature = staff() &amp;&amp; staff()-&gt;isTabStaff(tick());</a>
<a name="ln425">      const StaffType* stt = useTablature ? staff()-&gt;staffType(tick()) : 0;</a>
<a name="ln426">      qreal _spatium    = spatium();</a>
<a name="ln427">      qreal hw          = startNote()-&gt;tabHeadWidth(stt);   // if stt == 0, defaults to headWidth()</a>
<a name="ln428">      qreal __up        = _up ? -1.0 : 1.0;</a>
<a name="ln429">      // y offset for ties inside chord margins (typically multi-note chords): lined up with note top or bottom margin</a>
<a name="ln430">      //    or outside (typically single-note chord): overlaps note and is above/below it</a>
<a name="ln431">      // Outside: Tab: uses font size and may be asymmetric placed above/below line (frets ON or ABOVE line)</a>
<a name="ln432">      //          Std: assumes notehead is 1 sp high, 1/2 sp above and 1/2 below line; add 1/4 sp to it</a>
<a name="ln433">      // Inside:  Tab: 1/2 of Outside offset</a>
<a name="ln434">      //          Std: use a fixed percentage of note width</a>
<a name="ln435">      qreal yOffOutside = useTablature</a>
<a name="ln436">            ? (_up ? stt-&gt;fretBoxY() : stt-&gt;fretBoxY() + stt-&gt;fretBoxH()) * magS()</a>
<a name="ln437">            : 0.75 * _spatium * __up;</a>
<a name="ln438">      qreal yOffInside  = useTablature ? yOffOutside * 0.5 : hw * .3 * __up;</a>
<a name="ln439"> </a>
<a name="ln440">      Chord* sc   = startNote()-&gt;chord();</a>
<a name="ln441">      sp-&gt;system1 = sc-&gt;measure()-&gt;system();</a>
<a name="ln442">      if (!sp-&gt;system1) {</a>
<a name="ln443">            Measure* m = sc-&gt;measure();</a>
<a name="ln444">            qDebug(&quot;No system: measure is %d has %d count %d&quot;, m-&gt;isMMRest(), m-&gt;hasMMRest(), m-&gt;mmRestCount());</a>
<a name="ln445">            }</a>
<a name="ln446"> </a>
<a name="ln447">      qreal xo;</a>
<a name="ln448">      qreal yo;</a>
<a name="ln449">      bool shortStart = false;</a>
<a name="ln450"> </a>
<a name="ln451">      // determine attachment points</a>
<a name="ln452">      // similar code is used in Chord::layoutPitched()</a>
<a name="ln453">      // to allocate extra space to enforce minTieLength</a>
<a name="ln454">      // so keep these in sync</a>
<a name="ln455"> </a>
<a name="ln456">      sp-&gt;p1    = sc-&gt;pos() + sc-&gt;segment()-&gt;pos() + sc-&gt;measure()-&gt;pos();</a>
<a name="ln457"> </a>
<a name="ln458">      //------p1</a>
<a name="ln459">      if ((sc-&gt;notes().size() &gt; 1) || (sc-&gt;stem() &amp;&amp; (sc-&gt;up() == _up))) {</a>
<a name="ln460">            xo = startNote()-&gt;x() + hw * 1.12;</a>
<a name="ln461">            yo = startNote()-&gt;pos().y() + yOffInside;</a>
<a name="ln462">            shortStart = true;</a>
<a name="ln463">            }</a>
<a name="ln464">      else {</a>
<a name="ln465">            xo = startNote()-&gt;x() + hw * 0.65;</a>
<a name="ln466">            yo = startNote()-&gt;pos().y() + yOffOutside;</a>
<a name="ln467">            }</a>
<a name="ln468">      sp-&gt;p1 += QPointF(xo, yo);</a>
<a name="ln469"> </a>
<a name="ln470">      //------p2</a>
<a name="ln471">      if (endNote() == 0) {</a>
<a name="ln472">            sp-&gt;p2 = sp-&gt;p1 + QPointF(_spatium * 3, 0.0);</a>
<a name="ln473">            sp-&gt;system2 = sp-&gt;system1;</a>
<a name="ln474">            return;</a>
<a name="ln475">            }</a>
<a name="ln476">      Chord* ec = endNote()-&gt;chord();</a>
<a name="ln477">      sp-&gt;p2    = ec-&gt;pos() + ec-&gt;segment()-&gt;pos() + ec-&gt;measure()-&gt;pos();</a>
<a name="ln478">      sp-&gt;system2 = ec-&gt;measure()-&gt;system();</a>
<a name="ln479"> </a>
<a name="ln480">      // force tie to be horizontal except for cross-staff or if there is a difference of line (tpc, clef, tpc)</a>
<a name="ln481">      bool horizontal = startNote()-&gt;line() == endNote()-&gt;line() &amp;&amp; sc-&gt;vStaffIdx() == ec-&gt;vStaffIdx();</a>
<a name="ln482"> </a>
<a name="ln483">      hw = endNote()-&gt;tabHeadWidth(stt);</a>
<a name="ln484">      if ((ec-&gt;notes().size() &gt; 1) || (ec-&gt;stem() &amp;&amp; !ec-&gt;up() &amp;&amp; !_up)) {</a>
<a name="ln485">            xo = endNote()-&gt;x() - hw * 0.12;</a>
<a name="ln486">            if (!horizontal)</a>
<a name="ln487">                  yo = endNote()-&gt;pos().y() + yOffInside;</a>
<a name="ln488">            }</a>
<a name="ln489">      else if (shortStart) {</a>
<a name="ln490">            xo = endNote()-&gt;x() + hw * 0.15;</a>
<a name="ln491">            if (!horizontal)</a>
<a name="ln492">                  yo = endNote()-&gt;pos().y() + yOffOutside;</a>
<a name="ln493">            }</a>
<a name="ln494">      else {</a>
<a name="ln495">            xo = endNote()-&gt;x() + hw * 0.35;</a>
<a name="ln496">            if (!horizontal)</a>
<a name="ln497">                  yo = endNote()-&gt;pos().y() + yOffOutside;</a>
<a name="ln498">            }</a>
<a name="ln499">      sp-&gt;p2 += QPointF(xo, yo);</a>
<a name="ln500"> </a>
<a name="ln501">      // adjust for cross-staff</a>
<a name="ln502">      if (sc-&gt;vStaffIdx() != vStaffIdx() &amp;&amp; sp-&gt;system1) {</a>
<a name="ln503">            qreal diff = sp-&gt;system1-&gt;staff(sc-&gt;vStaffIdx())-&gt;y() - sp-&gt;system1-&gt;staff(vStaffIdx())-&gt;y();</a>
<a name="ln504">            sp-&gt;p1.ry() += diff;</a>
<a name="ln505">            }</a>
<a name="ln506">      if (ec-&gt;vStaffIdx() != vStaffIdx() &amp;&amp; sp-&gt;system2) {</a>
<a name="ln507">            qreal diff = sp-&gt;system2-&gt;staff(ec-&gt;vStaffIdx())-&gt;y() - sp-&gt;system2-&gt;staff(vStaffIdx())-&gt;y();</a>
<a name="ln508">            sp-&gt;p2.ry() += diff;</a>
<a name="ln509">            }</a>
<a name="ln510">      }</a>
<a name="ln511"> </a>
<a name="ln512">//---------------------------------------------------------</a>
<a name="ln513">//   Tie</a>
<a name="ln514">//---------------------------------------------------------</a>
<a name="ln515"> </a>
<a name="ln516">Tie::Tie(Score* s)</a>
<a name="ln517">   : SlurTie(s)</a>
<a name="ln518">      {</a>
<a name="ln519">      setAnchor(Anchor::NOTE);</a>
<a name="ln520">      }</a>
<a name="ln521"> </a>
<a name="ln522">//---------------------------------------------------------</a>
<a name="ln523">//   write</a>
<a name="ln524">//---------------------------------------------------------</a>
<a name="ln525"> </a>
<a name="ln526">void Tie::write(XmlWriter&amp; xml) const</a>
<a name="ln527">      {</a>
<a name="ln528">      xml.stag(this);</a>
<a name="ln529">      SlurTie::writeProperties(xml);</a>
<a name="ln530">      xml.etag();</a>
<a name="ln531">      }</a>
<a name="ln532"> </a>
<a name="ln533">//---------------------------------------------------------</a>
<a name="ln534">//   calculateDirection</a>
<a name="ln535">//---------------------------------------------------------</a>
<a name="ln536"> </a>
<a name="ln537">void Tie::calculateDirection()</a>
<a name="ln538">      {</a>
<a name="ln539">      Chord* c1   = startNote()-&gt;chord();</a>
<a name="ln540">      Chord* c2   = endNote()-&gt;chord();</a>
<a name="ln541">      Measure* m1 = c1-&gt;measure();</a>
<a name="ln542">      Measure* m2 = c2-&gt;measure();</a>
<a name="ln543"> </a>
<a name="ln544">      if (_slurDirection == Direction::AUTO) {</a>
<a name="ln545">            std::vector&lt;Note*&gt; notes = c1-&gt;notes();</a>
<a name="ln546">            size_t n = notes.size();</a>
<a name="ln547">            if (m1-&gt;hasVoices(c1-&gt;staffIdx()) || m2-&gt;hasVoices(c2-&gt;staffIdx())) {</a>
<a name="ln548">                  // in polyphonic passage, ties go on the stem side</a>
<a name="ln549">                  _up = c1-&gt;up();</a>
<a name="ln550">                  }</a>
<a name="ln551">            else if (n == 1) {</a>
<a name="ln552">                  //</a>
<a name="ln553">                  // single note</a>
<a name="ln554">                  //</a>
<a name="ln555">                  if (c1-&gt;up() != c2-&gt;up()) {</a>
<a name="ln556">                        // if stem direction is mixed, always up</a>
<a name="ln557">                        _up = true;</a>
<a name="ln558">                        }</a>
<a name="ln559">                  else</a>
<a name="ln560">                        _up = !c1-&gt;up();</a>
<a name="ln561">                  }</a>
<a name="ln562">            else {</a>
<a name="ln563">                  //</a>
<a name="ln564">                  // chords</a>
<a name="ln565">                  //</a>
<a name="ln566">                  QList&lt;int&gt; ties;</a>
<a name="ln567">                  int idx = 0;</a>
<a name="ln568">                  int noteIdx = -1;</a>
<a name="ln569">                  for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln570">                        if (notes[i]-&gt;tieFor()) {</a>
<a name="ln571">                              ties.append(notes[i]-&gt;line());</a>
<a name="ln572">                              if (notes[i] == startNote()) {</a>
<a name="ln573">                                    idx = ties.size() - 1;</a>
<a name="ln574">                                    noteIdx = int(i);</a>
<a name="ln575">                                    }</a>
<a name="ln576">                              }</a>
<a name="ln577">                        }</a>
<a name="ln578">                  if (idx == 0) {</a>
<a name="ln579">                        if (ties.size() == 1)         // if just one tie</a>
<a name="ln580">                              _up = noteIdx != 0;     // it is up if not the bottom note of the chord</a>
<a name="ln581">                        else                          // if several ties and this is the bottom one (idx == 0)</a>
<a name="ln582">                              _up = false;            // it is down</a>
<a name="ln583">                        }</a>
<a name="ln584">                  else if (idx == ties.size() - 1)</a>
<a name="ln585">                        _up = true;</a>
<a name="ln586">                  else {</a>
<a name="ln587">                        if (ties[idx] &lt;= 4)</a>
<a name="ln588">                              _up = ((ties[idx-1] - ties[idx]) &lt;= 1) || ((ties[idx] - ties[idx+1]) &gt; 1);</a>
<a name="ln589">                        else</a>
<a name="ln590">                              _up = ((ties[idx-1] - ties[idx]) &lt;= 1) &amp;&amp; ((ties[idx] - ties[idx+1]) &gt; 1);</a>
<a name="ln591">                        }</a>
<a name="ln592">                  }</a>
<a name="ln593">            }</a>
<a name="ln594">      else</a>
<a name="ln595">            _up = _slurDirection == Direction::UP ? true : false;</a>
<a name="ln596">      }</a>
<a name="ln597"> </a>
<a name="ln598">//---------------------------------------------------------</a>
<a name="ln599">//   layoutFor</a>
<a name="ln600">//    layout the first SpannerSegment of a slur</a>
<a name="ln601">//---------------------------------------------------------</a>
<a name="ln602"> </a>
<a name="ln603">TieSegment* Tie::layoutFor(System* system)</a>
<a name="ln604">      {</a>
<a name="ln605">      // do not layout ties in tablature if not showing back-tied fret marks</a>
<a name="ln606">      StaffType* st = staff()-&gt;staffType(startNote() ? startNote()-&gt;tick() : Fraction(0, 1));</a>
<a name="ln607">      if (st &amp;&amp; st-&gt;isTabStaff() &amp;&amp; !st-&gt;showBackTied()) {</a>
<a name="ln608">            if (!segmentsEmpty())</a>
<a name="ln609">                  eraseSpannerSegments();</a>
<a name="ln610">            return nullptr;</a>
<a name="ln611">            }</a>
<a name="ln612">      //</a>
<a name="ln613">      //    show short bow</a>
<a name="ln614">      //</a>
<a name="ln615">      if (startNote() == 0 || endNote() == 0) {</a>
<a name="ln616">            if (startNote() == 0) {</a>
<a name="ln617">                  qDebug(&quot;no start note&quot;);</a>
<a name="ln618">                  return 0;</a>
<a name="ln619">                  }</a>
<a name="ln620">            Chord* c1 = startNote()-&gt;chord();</a>
<a name="ln621">            if (_slurDirection == Direction::AUTO) {</a>
<a name="ln622">                  if (c1-&gt;measure()-&gt;hasVoices(c1-&gt;staffIdx())) {</a>
<a name="ln623">                        // in polyphonic passage, ties go on the stem side</a>
<a name="ln624">                        _up = c1-&gt;up();</a>
<a name="ln625">                        }</a>
<a name="ln626">                  else</a>
<a name="ln627">                        _up = !c1-&gt;up();</a>
<a name="ln628">                  }</a>
<a name="ln629">            else</a>
<a name="ln630">                  _up = _slurDirection == Direction::UP ? true : false;</a>
<a name="ln631">            fixupSegments(1);</a>
<a name="ln632">            TieSegment* segment = segmentAt(0);</a>
<a name="ln633">            segment-&gt;setSpannerSegmentType(SpannerSegmentType::SINGLE);</a>
<a name="ln634">            segment-&gt;setSystem(startNote()-&gt;chord()-&gt;segment()-&gt;measure()-&gt;system());</a>
<a name="ln635">            SlurPos sPos;</a>
<a name="ln636">            slurPos(&amp;sPos);</a>
<a name="ln637">            segment-&gt;layoutSegment(sPos.p1, sPos.p2);</a>
<a name="ln638">            return segment;</a>
<a name="ln639">            }</a>
<a name="ln640">      calculateDirection();</a>
<a name="ln641"> </a>
<a name="ln642">      SlurPos sPos;</a>
<a name="ln643">      slurPos(&amp;sPos);</a>
<a name="ln644"> </a>
<a name="ln645">      setPos(0, 0);</a>
<a name="ln646"> </a>
<a name="ln647">      int n;</a>
<a name="ln648">      if (sPos.system1 != sPos.system2) {</a>
<a name="ln649">            n = 2;</a>
<a name="ln650">            sPos.p2 = QPointF(system-&gt;width(), sPos.p1.y());</a>
<a name="ln651">            }</a>
<a name="ln652">      else</a>
<a name="ln653">            n = 1;</a>
<a name="ln654"> </a>
<a name="ln655">      fixupSegments(n);</a>
<a name="ln656">      TieSegment* segment = segmentAt(0);</a>
<a name="ln657">      segment-&gt;setSystem(system); // Needed to populate System.spannerSegments</a>
<a name="ln658">      segment-&gt;layoutSegment(sPos.p1, sPos.p2);</a>
<a name="ln659">      segment-&gt;setSpannerSegmentType(sPos.system1 != sPos.system2 ? SpannerSegmentType::BEGIN : SpannerSegmentType::SINGLE);</a>
<a name="ln660">      return segment;</a>
<a name="ln661">      }</a>
<a name="ln662"> </a>
<a name="ln663">//---------------------------------------------------------</a>
<a name="ln664">//   layoutBack</a>
<a name="ln665">//    layout the second SpannerSegment of a split slur</a>
<a name="ln666">//---------------------------------------------------------</a>
<a name="ln667"> </a>
<a name="ln668">TieSegment* Tie::layoutBack(System* system)</a>
<a name="ln669">      {</a>
<a name="ln670">      // do not layout ties in tablature if not showing back-tied fret marks</a>
<a name="ln671">      StaffType* st = staff()-&gt;staffType(startNote() ? startNote()-&gt;tick() : Fraction(0, 1));</a>
<a name="ln672">      if (st-&gt;isTabStaff() &amp;&amp; !st-&gt;showBackTied()) {</a>
<a name="ln673">            if (!segmentsEmpty())</a>
<a name="ln674">                  eraseSpannerSegments();</a>
<a name="ln675">            return nullptr;</a>
<a name="ln676">            }</a>
<a name="ln677"> </a>
<a name="ln678">      SlurPos sPos;</a>
<a name="ln679">      slurPos(&amp;sPos);</a>
<a name="ln680"> </a>
<a name="ln681">      fixupSegments(2);</a>
<a name="ln682">      TieSegment* segment = segmentAt(1);</a>
<a name="ln683">      segment-&gt;setSystem(system);</a>
<a name="ln684"> </a>
<a name="ln685">      qreal x;</a>
<a name="ln686">      Segment* seg = endNote()-&gt;chord()-&gt;segment()-&gt;prevActive();</a>
<a name="ln687">      if (seg) {</a>
<a name="ln688">            // find maximum width</a>
<a name="ln689">            qreal width = 0.0;</a>
<a name="ln690">            int n = score()-&gt;nstaves();</a>
<a name="ln691">            for (int i = 0; i &lt; n; ++i) {</a>
<a name="ln692">                  if (!system-&gt;staff(i)-&gt;show())</a>
<a name="ln693">                        continue;</a>
<a name="ln694">                  Element* e = seg-&gt;element(i * VOICES);</a>
<a name="ln695">                  if (e &amp;&amp; e-&gt;addToSkyline())</a>
<a name="ln696">                        width = qMax(width, e-&gt;pos().x() + e-&gt;bbox().right());</a>
<a name="ln697">                  }</a>
<a name="ln698">            x = seg-&gt;measure()-&gt;pos().x() + seg-&gt;pos().x() + width;</a>
<a name="ln699">            }</a>
<a name="ln700">      else</a>
<a name="ln701">            x = 0.0;</a>
<a name="ln702"> </a>
<a name="ln703">      segment-&gt;layoutSegment(QPointF(x, sPos.p2.y()), sPos.p2);</a>
<a name="ln704">      segment-&gt;setSpannerSegmentType(SpannerSegmentType::END);</a>
<a name="ln705">      return segment;</a>
<a name="ln706">      }</a>
<a name="ln707"> </a>
<a name="ln708">#if 0</a>
<a name="ln709">//---------------------------------------------------------</a>
<a name="ln710">//   startEdit</a>
<a name="ln711">//---------------------------------------------------------</a>
<a name="ln712"> </a>
<a name="ln713">void Tie::startEdit(EditData&amp; ed)</a>
<a name="ln714">      {</a>
<a name="ln715">printf(&quot;tie start edit %p %p\n&quot;, editStartNote, editEndNote);</a>
<a name="ln716">      editStartNote = startNote();</a>
<a name="ln717">      editEndNote   = endNote();</a>
<a name="ln718">      SlurTie::startEdit(ed);</a>
<a name="ln719">      }</a>
<a name="ln720"> </a>
<a name="ln721">//---------------------------------------------------------</a>
<a name="ln722">//   endEdit</a>
<a name="ln723">//---------------------------------------------------------</a>
<a name="ln724"> </a>
<a name="ln725">void Tie::endEdit(EditData&amp; ed)</a>
<a name="ln726">      {</a>
<a name="ln727">//printf(&quot;tie::endEdit\n&quot;);</a>
<a name="ln728">//      if (editStartNote != startNote() || editEndNote != endNote()) {</a>
<a name="ln729">//            score()-&gt;undoStack()-&gt;push1(new ChangeSpannerElements(this, editStartNote, editEndNote));</a>
<a name="ln730">//            }</a>
<a name="ln731">      SlurTie::endEdit(ed);</a>
<a name="ln732">      }</a>
<a name="ln733">#endif</a>
<a name="ln734"> </a>
<a name="ln735">//---------------------------------------------------------</a>
<a name="ln736">//   setStartNote</a>
<a name="ln737">//---------------------------------------------------------</a>
<a name="ln738"> </a>
<a name="ln739">void Tie::setStartNote(Note* note)</a>
<a name="ln740">      {</a>
<a name="ln741">      setStartElement(note);</a>
<a name="ln742">      setParent(note);</a>
<a name="ln743">      }</a>
<a name="ln744"> </a>
<a name="ln745">//---------------------------------------------------------</a>
<a name="ln746">//   startNote</a>
<a name="ln747">//---------------------------------------------------------</a>
<a name="ln748"> </a>
<a name="ln749">Note* Tie::startNote() const</a>
<a name="ln750">      {</a>
<a name="ln751">      Q_ASSERT(!startElement() || startElement()-&gt;type() == ElementType::NOTE);</a>
<a name="ln752">      return toNote(startElement());</a>
<a name="ln753">      }</a>
<a name="ln754"> </a>
<a name="ln755">//---------------------------------------------------------</a>
<a name="ln756">//   endNote</a>
<a name="ln757">//---------------------------------------------------------</a>
<a name="ln758"> </a>
<a name="ln759">Note* Tie::endNote() const</a>
<a name="ln760">      {</a>
<a name="ln761">      return toNote(endElement());</a>
<a name="ln762">      }</a>
<a name="ln763">}</a>
<a name="ln764"> </a>

</code></pre>
<div class="balloon" rel="282"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'staff()' pointer was used unsafely after it was verified against nullptr. Check lines: 240, 282.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
