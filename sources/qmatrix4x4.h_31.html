
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qmatrix4x4.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2016 The Qt Company Ltd.</a>
<a name="ln4">** Contact: https://www.qt.io/licensing/</a>
<a name="ln5">**</a>
<a name="ln6">** This file is part of the QtGui module of the Qt Toolkit.</a>
<a name="ln7">**</a>
<a name="ln8">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln9">** Commercial License Usage</a>
<a name="ln10">** Licensees holding valid commercial Qt licenses may use this file in</a>
<a name="ln11">** accordance with the commercial license agreement provided with the</a>
<a name="ln12">** Software or, alternatively, in accordance with the terms contained in</a>
<a name="ln13">** a written agreement between you and The Qt Company. For licensing terms</a>
<a name="ln14">** and conditions see https://www.qt.io/terms-conditions. For further</a>
<a name="ln15">** information use the contact form at https://www.qt.io/contact-us.</a>
<a name="ln16">**</a>
<a name="ln17">** GNU Lesser General Public License Usage</a>
<a name="ln18">** Alternatively, this file may be used under the terms of the GNU Lesser</a>
<a name="ln19">** General Public License version 3 as published by the Free Software</a>
<a name="ln20">** Foundation and appearing in the file LICENSE.LGPL3 included in the</a>
<a name="ln21">** packaging of this file. Please review the following information to</a>
<a name="ln22">** ensure the GNU Lesser General Public License version 3 requirements</a>
<a name="ln23">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</a>
<a name="ln24">**</a>
<a name="ln25">** GNU General Public License Usage</a>
<a name="ln26">** Alternatively, this file may be used under the terms of the GNU</a>
<a name="ln27">** General Public License version 2.0 or (at your option) the GNU General</a>
<a name="ln28">** Public license version 3 or any later version approved by the KDE Free</a>
<a name="ln29">** Qt Foundation. The licenses are as published by the Free Software</a>
<a name="ln30">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</a>
<a name="ln31">** included in the packaging of this file. Please review the following</a>
<a name="ln32">** information to ensure the GNU General Public License requirements will</a>
<a name="ln33">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</a>
<a name="ln34">** https://www.gnu.org/licenses/gpl-3.0.html.</a>
<a name="ln35">**</a>
<a name="ln36">** $QT_END_LICENSE$</a>
<a name="ln37">**</a>
<a name="ln38">****************************************************************************/</a>
<a name="ln39"> </a>
<a name="ln40">#ifndef QMATRIX4X4_H</a>
<a name="ln41">#define QMATRIX4X4_H</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;QtGui/qtguiglobal.h&gt;</a>
<a name="ln44">#include &lt;QtGui/qvector3d.h&gt;</a>
<a name="ln45">#include &lt;QtGui/qvector4d.h&gt;</a>
<a name="ln46">#include &lt;QtGui/qquaternion.h&gt;</a>
<a name="ln47">#include &lt;QtGui/qgenericmatrix.h&gt;</a>
<a name="ln48">#include &lt;QtCore/qrect.h&gt;</a>
<a name="ln49"> </a>
<a name="ln50">QT_BEGIN_NAMESPACE</a>
<a name="ln51"> </a>
<a name="ln52"> </a>
<a name="ln53">#ifndef QT_NO_MATRIX4X4</a>
<a name="ln54"> </a>
<a name="ln55">class QMatrix;</a>
<a name="ln56">class QTransform;</a>
<a name="ln57">class QVariant;</a>
<a name="ln58"> </a>
<a name="ln59">class Q_GUI_EXPORT QMatrix4x4</a>
<a name="ln60">{</a>
<a name="ln61">public:</a>
<a name="ln62">    inline QMatrix4x4() { setToIdentity(); }</a>
<a name="ln63">    explicit QMatrix4x4(Qt::Initialization) : flagBits(General) {}</a>
<a name="ln64">    explicit QMatrix4x4(const float *values);</a>
<a name="ln65">    inline QMatrix4x4(float m11, float m12, float m13, float m14,</a>
<a name="ln66">                      float m21, float m22, float m23, float m24,</a>
<a name="ln67">                      float m31, float m32, float m33, float m34,</a>
<a name="ln68">                      float m41, float m42, float m43, float m44);</a>
<a name="ln69"> </a>
<a name="ln70">    template &lt;int N, int M&gt;</a>
<a name="ln71">    explicit QMatrix4x4(const QGenericMatrix&lt;N, M, float&gt;&amp; matrix);</a>
<a name="ln72"> </a>
<a name="ln73">    QMatrix4x4(const float *values, int cols, int rows);</a>
<a name="ln74">    QMatrix4x4(const QTransform&amp; transform);</a>
<a name="ln75">    QMatrix4x4(const QMatrix&amp; matrix);</a>
<a name="ln76"> </a>
<a name="ln77">    inline const float&amp; operator()(int row, int column) const;</a>
<a name="ln78">    inline float&amp; operator()(int row, int column);</a>
<a name="ln79"> </a>
<a name="ln80">#ifndef QT_NO_VECTOR4D</a>
<a name="ln81">    inline QVector4D column(int index) const;</a>
<a name="ln82">    inline void setColumn(int index, const QVector4D&amp; value);</a>
<a name="ln83"> </a>
<a name="ln84">    inline QVector4D row(int index) const;</a>
<a name="ln85">    inline void setRow(int index, const QVector4D&amp; value);</a>
<a name="ln86">#endif</a>
<a name="ln87"> </a>
<a name="ln88">    inline bool isAffine() const;</a>
<a name="ln89"> </a>
<a name="ln90">    inline bool isIdentity() const;</a>
<a name="ln91">    inline void setToIdentity();</a>
<a name="ln92"> </a>
<a name="ln93">    inline void fill(float value);</a>
<a name="ln94"> </a>
<a name="ln95">    double determinant() const;</a>
<a name="ln96">    QMatrix4x4 inverted(bool *invertible = nullptr) const;</a>
<a name="ln97">    QMatrix4x4 transposed() const;</a>
<a name="ln98">    QMatrix3x3 normalMatrix() const;</a>
<a name="ln99"> </a>
<a name="ln100">    inline QMatrix4x4&amp; operator+=(const QMatrix4x4&amp; other);</a>
<a name="ln101">    inline QMatrix4x4&amp; operator-=(const QMatrix4x4&amp; other);</a>
<a name="ln102">    inline QMatrix4x4&amp; operator*=(const QMatrix4x4&amp; other);</a>
<a name="ln103">    inline QMatrix4x4&amp; operator*=(float factor);</a>
<a name="ln104">    QMatrix4x4&amp; operator/=(float divisor);</a>
<a name="ln105">    inline bool operator==(const QMatrix4x4&amp; other) const;</a>
<a name="ln106">    inline bool operator!=(const QMatrix4x4&amp; other) const;</a>
<a name="ln107"> </a>
<a name="ln108">    friend QMatrix4x4 operator+(const QMatrix4x4&amp; m1, const QMatrix4x4&amp; m2);</a>
<a name="ln109">    friend QMatrix4x4 operator-(const QMatrix4x4&amp; m1, const QMatrix4x4&amp; m2);</a>
<a name="ln110">    friend QMatrix4x4 operator*(const QMatrix4x4&amp; m1, const QMatrix4x4&amp; m2);</a>
<a name="ln111">#ifndef QT_NO_VECTOR3D</a>
<a name="ln112">    friend QVector3D operator*(const QMatrix4x4&amp; matrix, const QVector3D&amp; vector);</a>
<a name="ln113">    friend QVector3D operator*(const QVector3D&amp; vector, const QMatrix4x4&amp; matrix);</a>
<a name="ln114">#endif</a>
<a name="ln115">#ifndef QT_NO_VECTOR4D</a>
<a name="ln116">    friend QVector4D operator*(const QVector4D&amp; vector, const QMatrix4x4&amp; matrix);</a>
<a name="ln117">    friend QVector4D operator*(const QMatrix4x4&amp; matrix, const QVector4D&amp; vector);</a>
<a name="ln118">#endif</a>
<a name="ln119">    friend QPoint operator*(const QPoint&amp; point, const QMatrix4x4&amp; matrix);</a>
<a name="ln120">    friend QPointF operator*(const QPointF&amp; point, const QMatrix4x4&amp; matrix);</a>
<a name="ln121">    friend QMatrix4x4 operator-(const QMatrix4x4&amp; matrix);</a>
<a name="ln122">    friend QPoint operator*(const QMatrix4x4&amp; matrix, const QPoint&amp; point);</a>
<a name="ln123">    friend QPointF operator*(const QMatrix4x4&amp; matrix, const QPointF&amp; point);</a>
<a name="ln124">    friend QMatrix4x4 operator*(float factor, const QMatrix4x4&amp; matrix);</a>
<a name="ln125">    friend QMatrix4x4 operator*(const QMatrix4x4&amp; matrix, float factor);</a>
<a name="ln126">    friend Q_GUI_EXPORT QMatrix4x4 operator/(const QMatrix4x4&amp; matrix, float divisor);</a>
<a name="ln127"> </a>
<a name="ln128">    friend inline bool qFuzzyCompare(const QMatrix4x4&amp; m1, const QMatrix4x4&amp; m2);</a>
<a name="ln129"> </a>
<a name="ln130">#ifndef QT_NO_VECTOR3D</a>
<a name="ln131">    void scale(const QVector3D&amp; vector);</a>
<a name="ln132">    void translate(const QVector3D&amp; vector);</a>
<a name="ln133">    void rotate(float angle, const QVector3D&amp; vector);</a>
<a name="ln134">#endif</a>
<a name="ln135">    void scale(float x, float y);</a>
<a name="ln136">    void scale(float x, float y, float z);</a>
<a name="ln137">    void scale(float factor);</a>
<a name="ln138">    void translate(float x, float y);</a>
<a name="ln139">    void translate(float x, float y, float z);</a>
<a name="ln140">    void rotate(float angle, float x, float y, float z = 0.0f);</a>
<a name="ln141">#ifndef QT_NO_QUATERNION</a>
<a name="ln142">    void rotate(const QQuaternion&amp; quaternion);</a>
<a name="ln143">#endif</a>
<a name="ln144"> </a>
<a name="ln145">    void ortho(const QRect&amp; rect);</a>
<a name="ln146">    void ortho(const QRectF&amp; rect);</a>
<a name="ln147">    void ortho(float left, float right, float bottom, float top, float nearPlane, float farPlane);</a>
<a name="ln148">    void frustum(float left, float right, float bottom, float top, float nearPlane, float farPlane);</a>
<a name="ln149">    void perspective(float verticalAngle, float aspectRatio, float nearPlane, float farPlane);</a>
<a name="ln150">#ifndef QT_NO_VECTOR3D</a>
<a name="ln151">    void lookAt(const QVector3D&amp; eye, const QVector3D&amp; center, const QVector3D&amp; up);</a>
<a name="ln152">#endif</a>
<a name="ln153">    void viewport(const QRectF &amp;rect);</a>
<a name="ln154">    void viewport(float left, float bottom, float width, float height, float nearPlane = 0.0f, float farPlane = 1.0f);</a>
<a name="ln155">    void flipCoordinates();</a>
<a name="ln156"> </a>
<a name="ln157">    void copyDataTo(float *values) const;</a>
<a name="ln158"> </a>
<a name="ln159">    QMatrix toAffine() const;</a>
<a name="ln160">    QTransform toTransform() const;</a>
<a name="ln161">    QTransform toTransform(float distanceToPlane) const;</a>
<a name="ln162"> </a>
<a name="ln163">    QPoint map(const QPoint&amp; point) const;</a>
<a name="ln164">    QPointF map(const QPointF&amp; point) const;</a>
<a name="ln165">#ifndef QT_NO_VECTOR3D</a>
<a name="ln166">    QVector3D map(const QVector3D&amp; point) const;</a>
<a name="ln167">    QVector3D mapVector(const QVector3D&amp; vector) const;</a>
<a name="ln168">#endif</a>
<a name="ln169">#ifndef QT_NO_VECTOR4D</a>
<a name="ln170">    QVector4D map(const QVector4D&amp; point) const;</a>
<a name="ln171">#endif</a>
<a name="ln172">    QRect mapRect(const QRect&amp; rect) const;</a>
<a name="ln173">    QRectF mapRect(const QRectF&amp; rect) const;</a>
<a name="ln174"> </a>
<a name="ln175">    template &lt;int N, int M&gt;</a>
<a name="ln176">    QGenericMatrix&lt;N, M, float&gt; toGenericMatrix() const;</a>
<a name="ln177"> </a>
<a name="ln178">    inline float *data();</a>
<a name="ln179">    inline const float *data() const { return *m; }</a>
<a name="ln180">    inline const float *constData() const { return *m; }</a>
<a name="ln181"> </a>
<a name="ln182">    void optimize();</a>
<a name="ln183"> </a>
<a name="ln184">    operator QVariant() const;</a>
<a name="ln185"> </a>
<a name="ln186">#ifndef QT_NO_DEBUG_STREAM</a>
<a name="ln187">    friend Q_GUI_EXPORT QDebug operator&lt;&lt;(QDebug dbg, const QMatrix4x4 &amp;m);</a>
<a name="ln188">#endif</a>
<a name="ln189"> </a>
<a name="ln190">private:</a>
<a name="ln191">    float m[4][4];          // Column-major order to match OpenGL.</a>
<a name="ln192">    int flagBits;           // Flag bits from the enum below.</a>
<a name="ln193"> </a>
<a name="ln194">    // When matrices are multiplied, the flag bits are or-ed together.</a>
<a name="ln195">    enum {</a>
<a name="ln196">        Identity        = 0x0000, // Identity matrix</a>
<a name="ln197">        Translation     = 0x0001, // Contains a translation</a>
<a name="ln198">        Scale           = 0x0002, // Contains a scale</a>
<a name="ln199">        Rotation2D      = 0x0004, // Contains a rotation about the Z axis</a>
<a name="ln200">        Rotation        = 0x0008, // Contains an arbitrary rotation</a>
<a name="ln201">        Perspective     = 0x0010, // Last row is different from (0, 0, 0, 1)</a>
<a name="ln202">        General         = 0x001f  // General matrix, unknown contents</a>
<a name="ln203">    };</a>
<a name="ln204"> </a>
<a name="ln205">    // Construct without initializing identity matrix.</a>
<a name="ln206">    explicit QMatrix4x4(int) { }</a>
<a name="ln207"> </a>
<a name="ln208">    QMatrix4x4 orthonormalInverse() const;</a>
<a name="ln209"> </a>
<a name="ln210">    void projectedRotate(float angle, float x, float y, float z);</a>
<a name="ln211"> </a>
<a name="ln212">    friend class QGraphicsRotation;</a>
<a name="ln213">};</a>
<a name="ln214"> </a>
<a name="ln215">QT_WARNING_PUSH</a>
<a name="ln216">QT_WARNING_DISABLE_CLANG(&quot;-Wfloat-equal&quot;)</a>
<a name="ln217">QT_WARNING_DISABLE_GCC(&quot;-Wfloat-equal&quot;)</a>
<a name="ln218">Q_DECLARE_TYPEINFO(QMatrix4x4, Q_MOVABLE_TYPE);</a>
<a name="ln219"> </a>
<a name="ln220">inline QMatrix4x4::QMatrix4x4</a>
<a name="ln221">        (float m11, float m12, float m13, float m14,</a>
<a name="ln222">         float m21, float m22, float m23, float m24,</a>
<a name="ln223">         float m31, float m32, float m33, float m34,</a>
<a name="ln224">         float m41, float m42, float m43, float m44)</a>
<a name="ln225">{</a>
<a name="ln226">    m[0][0] = m11; m[0][1] = m21; m[0][2] = m31; m[0][3] = m41;</a>
<a name="ln227">    m[1][0] = m12; m[1][1] = m22; m[1][2] = m32; m[1][3] = m42;</a>
<a name="ln228">    m[2][0] = m13; m[2][1] = m23; m[2][2] = m33; m[2][3] = m43;</a>
<a name="ln229">    m[3][0] = m14; m[3][1] = m24; m[3][2] = m34; m[3][3] = m44;</a>
<a name="ln230">    flagBits = General;</a>
<a name="ln231">}</a>
<a name="ln232"> </a>
<a name="ln233">template &lt;int N, int M&gt;</a>
<a name="ln234">Q_INLINE_TEMPLATE QMatrix4x4::QMatrix4x4</a>
<a name="ln235">    (const QGenericMatrix&lt;N, M, float&gt;&amp; matrix)</a>
<a name="ln236">{</a>
<a name="ln237">    const float *values = matrix.constData();</a>
<a name="ln238">    for (int matrixCol = 0; matrixCol &lt; 4; ++matrixCol) {</a>
<a name="ln239">        for (int matrixRow = 0; matrixRow &lt; 4; ++matrixRow) {</a>
<a name="ln240">            if (matrixCol &lt; N &amp;&amp; matrixRow &lt; M)</a>
<a name="ln241">                m[matrixCol][matrixRow] = values[matrixCol * M + matrixRow];</a>
<a name="ln242">            else if (matrixCol == matrixRow)</a>
<a name="ln243">                m[matrixCol][matrixRow] = 1.0f;</a>
<a name="ln244">            else</a>
<a name="ln245">                m[matrixCol][matrixRow] = 0.0f;</a>
<a name="ln246">        }</a>
<a name="ln247">    }</a>
<a name="ln248">    flagBits = General;</a>
<a name="ln249">}</a>
<a name="ln250"> </a>
<a name="ln251">template &lt;int N, int M&gt;</a>
<a name="ln252">QGenericMatrix&lt;N, M, float&gt; QMatrix4x4::toGenericMatrix() const</a>
<a name="ln253">{</a>
<a name="ln254">    QGenericMatrix&lt;N, M, float&gt; result;</a>
<a name="ln255">    float *values = result.data();</a>
<a name="ln256">    for (int matrixCol = 0; matrixCol &lt; N; ++matrixCol) {</a>
<a name="ln257">        for (int matrixRow = 0; matrixRow &lt; M; ++matrixRow) {</a>
<a name="ln258">            if (matrixCol &lt; 4 &amp;&amp; matrixRow &lt; 4)</a>
<a name="ln259">                values[matrixCol * M + matrixRow] = m[matrixCol][matrixRow];</a>
<a name="ln260">            else if (matrixCol == matrixRow)</a>
<a name="ln261">                values[matrixCol * M + matrixRow] = 1.0f;</a>
<a name="ln262">            else</a>
<a name="ln263">                values[matrixCol * M + matrixRow] = 0.0f;</a>
<a name="ln264">        }</a>
<a name="ln265">    }</a>
<a name="ln266">    return result;</a>
<a name="ln267">}</a>
<a name="ln268"> </a>
<a name="ln269">inline const float&amp; QMatrix4x4::operator()(int aRow, int aColumn) const</a>
<a name="ln270">{</a>
<a name="ln271">    Q_ASSERT(aRow &gt;= 0 &amp;&amp; aRow &lt; 4 &amp;&amp; aColumn &gt;= 0 &amp;&amp; aColumn &lt; 4);</a>
<a name="ln272">    return m[aColumn][aRow];</a>
<a name="ln273">}</a>
<a name="ln274"> </a>
<a name="ln275">inline float&amp; QMatrix4x4::operator()(int aRow, int aColumn)</a>
<a name="ln276">{</a>
<a name="ln277">    Q_ASSERT(aRow &gt;= 0 &amp;&amp; aRow &lt; 4 &amp;&amp; aColumn &gt;= 0 &amp;&amp; aColumn &lt; 4);</a>
<a name="ln278">    flagBits = General;</a>
<a name="ln279">    return m[aColumn][aRow];</a>
<a name="ln280">}</a>
<a name="ln281"> </a>
<a name="ln282">#ifndef QT_NO_VECTOR4D</a>
<a name="ln283">inline QVector4D QMatrix4x4::column(int index) const</a>
<a name="ln284">{</a>
<a name="ln285">    Q_ASSERT(index &gt;= 0 &amp;&amp; index &lt; 4);</a>
<a name="ln286">    return QVector4D(m[index][0], m[index][1], m[index][2], m[index][3]);</a>
<a name="ln287">}</a>
<a name="ln288"> </a>
<a name="ln289">inline void QMatrix4x4::setColumn(int index, const QVector4D&amp; value)</a>
<a name="ln290">{</a>
<a name="ln291">    Q_ASSERT(index &gt;= 0 &amp;&amp; index &lt; 4);</a>
<a name="ln292">    m[index][0] = value.x();</a>
<a name="ln293">    m[index][1] = value.y();</a>
<a name="ln294">    m[index][2] = value.z();</a>
<a name="ln295">    m[index][3] = value.w();</a>
<a name="ln296">    flagBits = General;</a>
<a name="ln297">}</a>
<a name="ln298"> </a>
<a name="ln299">inline QVector4D QMatrix4x4::row(int index) const</a>
<a name="ln300">{</a>
<a name="ln301">    Q_ASSERT(index &gt;= 0 &amp;&amp; index &lt; 4);</a>
<a name="ln302">    return QVector4D(m[0][index], m[1][index], m[2][index], m[3][index]);</a>
<a name="ln303">}</a>
<a name="ln304"> </a>
<a name="ln305">inline void QMatrix4x4::setRow(int index, const QVector4D&amp; value)</a>
<a name="ln306">{</a>
<a name="ln307">    Q_ASSERT(index &gt;= 0 &amp;&amp; index &lt; 4);</a>
<a name="ln308">    m[0][index] = value.x();</a>
<a name="ln309">    m[1][index] = value.y();</a>
<a name="ln310">    m[2][index] = value.z();</a>
<a name="ln311">    m[3][index] = value.w();</a>
<a name="ln312">    flagBits = General;</a>
<a name="ln313">}</a>
<a name="ln314">#endif</a>
<a name="ln315"> </a>
<a name="ln316">Q_GUI_EXPORT QMatrix4x4 operator/(const QMatrix4x4&amp; matrix, float divisor);</a>
<a name="ln317"> </a>
<a name="ln318">inline bool QMatrix4x4::isAffine() const</a>
<a name="ln319">{</a>
<a name="ln320">    return m[0][3] == 0.0f &amp;&amp; m[1][3] == 0.0f &amp;&amp; m[2][3] == 0.0f &amp;&amp; m[3][3] == 1.0f;</a>
<a name="ln321">}</a>
<a name="ln322"> </a>
<a name="ln323">inline bool QMatrix4x4::isIdentity() const</a>
<a name="ln324">{</a>
<a name="ln325">    if (flagBits == Identity)</a>
<a name="ln326">        return true;</a>
<a name="ln327">    if (m[0][0] != 1.0f || m[0][1] != 0.0f || m[0][2] != 0.0f)</a>
<a name="ln328">        return false;</a>
<a name="ln329">    if (m[0][3] != 0.0f || m[1][0] != 0.0f || m[1][1] != 1.0f)</a>
<a name="ln330">        return false;</a>
<a name="ln331">    if (m[1][2] != 0.0f || m[1][3] != 0.0f || m[2][0] != 0.0f)</a>
<a name="ln332">        return false;</a>
<a name="ln333">    if (m[2][1] != 0.0f || m[2][2] != 1.0f || m[2][3] != 0.0f)</a>
<a name="ln334">        return false;</a>
<a name="ln335">    if (m[3][0] != 0.0f || m[3][1] != 0.0f || m[3][2] != 0.0f)</a>
<a name="ln336">        return false;</a>
<a name="ln337">    return (m[3][3] == 1.0f);</a>
<a name="ln338">}</a>
<a name="ln339"> </a>
<a name="ln340">inline void QMatrix4x4::setToIdentity()</a>
<a name="ln341">{</a>
<a name="ln342">    m[0][0] = 1.0f;</a>
<a name="ln343">    m[0][1] = 0.0f;</a>
<a name="ln344">    m[0][2] = 0.0f;</a>
<a name="ln345">    m[0][3] = 0.0f;</a>
<a name="ln346">    m[1][0] = 0.0f;</a>
<a name="ln347">    m[1][1] = 1.0f;</a>
<a name="ln348">    m[1][2] = 0.0f;</a>
<a name="ln349">    m[1][3] = 0.0f;</a>
<a name="ln350">    m[2][0] = 0.0f;</a>
<a name="ln351">    m[2][1] = 0.0f;</a>
<a name="ln352">    m[2][2] = 1.0f;</a>
<a name="ln353">    m[2][3] = 0.0f;</a>
<a name="ln354">    m[3][0] = 0.0f;</a>
<a name="ln355">    m[3][1] = 0.0f;</a>
<a name="ln356">    m[3][2] = 0.0f;</a>
<a name="ln357">    m[3][3] = 1.0f;</a>
<a name="ln358">    flagBits = Identity;</a>
<a name="ln359">}</a>
<a name="ln360"> </a>
<a name="ln361">inline void QMatrix4x4::fill(float value)</a>
<a name="ln362">{</a>
<a name="ln363">    m[0][0] = value;</a>
<a name="ln364">    m[0][1] = value;</a>
<a name="ln365">    m[0][2] = value;</a>
<a name="ln366">    m[0][3] = value;</a>
<a name="ln367">    m[1][0] = value;</a>
<a name="ln368">    m[1][1] = value;</a>
<a name="ln369">    m[1][2] = value;</a>
<a name="ln370">    m[1][3] = value;</a>
<a name="ln371">    m[2][0] = value;</a>
<a name="ln372">    m[2][1] = value;</a>
<a name="ln373">    m[2][2] = value;</a>
<a name="ln374">    m[2][3] = value;</a>
<a name="ln375">    m[3][0] = value;</a>
<a name="ln376">    m[3][1] = value;</a>
<a name="ln377">    m[3][2] = value;</a>
<a name="ln378">    m[3][3] = value;</a>
<a name="ln379">    flagBits = General;</a>
<a name="ln380">}</a>
<a name="ln381"> </a>
<a name="ln382">inline QMatrix4x4&amp; QMatrix4x4::operator+=(const QMatrix4x4&amp; other)</a>
<a name="ln383">{</a>
<a name="ln384">    m[0][0] += other.m[0][0];</a>
<a name="ln385">    m[0][1] += other.m[0][1];</a>
<a name="ln386">    m[0][2] += other.m[0][2];</a>
<a name="ln387">    m[0][3] += other.m[0][3];</a>
<a name="ln388">    m[1][0] += other.m[1][0];</a>
<a name="ln389">    m[1][1] += other.m[1][1];</a>
<a name="ln390">    m[1][2] += other.m[1][2];</a>
<a name="ln391">    m[1][3] += other.m[1][3];</a>
<a name="ln392">    m[2][0] += other.m[2][0];</a>
<a name="ln393">    m[2][1] += other.m[2][1];</a>
<a name="ln394">    m[2][2] += other.m[2][2];</a>
<a name="ln395">    m[2][3] += other.m[2][3];</a>
<a name="ln396">    m[3][0] += other.m[3][0];</a>
<a name="ln397">    m[3][1] += other.m[3][1];</a>
<a name="ln398">    m[3][2] += other.m[3][2];</a>
<a name="ln399">    m[3][3] += other.m[3][3];</a>
<a name="ln400">    flagBits = General;</a>
<a name="ln401">    return *this;</a>
<a name="ln402">}</a>
<a name="ln403"> </a>
<a name="ln404">inline QMatrix4x4&amp; QMatrix4x4::operator-=(const QMatrix4x4&amp; other)</a>
<a name="ln405">{</a>
<a name="ln406">    m[0][0] -= other.m[0][0];</a>
<a name="ln407">    m[0][1] -= other.m[0][1];</a>
<a name="ln408">    m[0][2] -= other.m[0][2];</a>
<a name="ln409">    m[0][3] -= other.m[0][3];</a>
<a name="ln410">    m[1][0] -= other.m[1][0];</a>
<a name="ln411">    m[1][1] -= other.m[1][1];</a>
<a name="ln412">    m[1][2] -= other.m[1][2];</a>
<a name="ln413">    m[1][3] -= other.m[1][3];</a>
<a name="ln414">    m[2][0] -= other.m[2][0];</a>
<a name="ln415">    m[2][1] -= other.m[2][1];</a>
<a name="ln416">    m[2][2] -= other.m[2][2];</a>
<a name="ln417">    m[2][3] -= other.m[2][3];</a>
<a name="ln418">    m[3][0] -= other.m[3][0];</a>
<a name="ln419">    m[3][1] -= other.m[3][1];</a>
<a name="ln420">    m[3][2] -= other.m[3][2];</a>
<a name="ln421">    m[3][3] -= other.m[3][3];</a>
<a name="ln422">    flagBits = General;</a>
<a name="ln423">    return *this;</a>
<a name="ln424">}</a>
<a name="ln425"> </a>
<a name="ln426">inline QMatrix4x4&amp; QMatrix4x4::operator*=(const QMatrix4x4&amp; o)</a>
<a name="ln427">{</a>
<a name="ln428">    const QMatrix4x4 other = o; // prevent aliasing when &amp;o == this ### Qt 6: take o by value</a>
<a name="ln429">    flagBits |= other.flagBits;</a>
<a name="ln430"> </a>
<a name="ln431">    if (flagBits &lt; Rotation2D) {</a>
<a name="ln432">        m[3][0] += m[0][0] * other.m[3][0];</a>
<a name="ln433">        m[3][1] += m[1][1] * other.m[3][1];</a>
<a name="ln434">        m[3][2] += m[2][2] * other.m[3][2];</a>
<a name="ln435"> </a>
<a name="ln436">        m[0][0] *= other.m[0][0];</a>
<a name="ln437">        m[1][1] *= other.m[1][1];</a>
<a name="ln438">        m[2][2] *= other.m[2][2];</a>
<a name="ln439">        return *this;</a>
<a name="ln440">    }</a>
<a name="ln441"> </a>
<a name="ln442">    float m0, m1, m2;</a>
<a name="ln443">    m0 = m[0][0] * other.m[0][0]</a>
<a name="ln444">            + m[1][0] * other.m[0][1]</a>
<a name="ln445">            + m[2][0] * other.m[0][2]</a>
<a name="ln446">            + m[3][0] * other.m[0][3];</a>
<a name="ln447">    m1 = m[0][0] * other.m[1][0]</a>
<a name="ln448">            + m[1][0] * other.m[1][1]</a>
<a name="ln449">            + m[2][0] * other.m[1][2]</a>
<a name="ln450">            + m[3][0] * other.m[1][3];</a>
<a name="ln451">    m2 = m[0][0] * other.m[2][0]</a>
<a name="ln452">            + m[1][0] * other.m[2][1]</a>
<a name="ln453">            + m[2][0] * other.m[2][2]</a>
<a name="ln454">            + m[3][0] * other.m[2][3];</a>
<a name="ln455">    m[3][0] = m[0][0] * other.m[3][0]</a>
<a name="ln456">            + m[1][0] * other.m[3][1]</a>
<a name="ln457">            + m[2][0] * other.m[3][2]</a>
<a name="ln458">            + m[3][0] * other.m[3][3];</a>
<a name="ln459">    m[0][0] = m0;</a>
<a name="ln460">    m[1][0] = m1;</a>
<a name="ln461">    m[2][0] = m2;</a>
<a name="ln462"> </a>
<a name="ln463">    m0 = m[0][1] * other.m[0][0]</a>
<a name="ln464">            + m[1][1] * other.m[0][1]</a>
<a name="ln465">            + m[2][1] * other.m[0][2]</a>
<a name="ln466">            + m[3][1] * other.m[0][3];</a>
<a name="ln467">    m1 = m[0][1] * other.m[1][0]</a>
<a name="ln468">            + m[1][1] * other.m[1][1]</a>
<a name="ln469">            + m[2][1] * other.m[1][2]</a>
<a name="ln470">            + m[3][1] * other.m[1][3];</a>
<a name="ln471">    m2 = m[0][1] * other.m[2][0]</a>
<a name="ln472">            + m[1][1] * other.m[2][1]</a>
<a name="ln473">            + m[2][1] * other.m[2][2]</a>
<a name="ln474">            + m[3][1] * other.m[2][3];</a>
<a name="ln475">    m[3][1] = m[0][1] * other.m[3][0]</a>
<a name="ln476">            + m[1][1] * other.m[3][1]</a>
<a name="ln477">            + m[2][1] * other.m[3][2]</a>
<a name="ln478">            + m[3][1] * other.m[3][3];</a>
<a name="ln479">    m[0][1] = m0;</a>
<a name="ln480">    m[1][1] = m1;</a>
<a name="ln481">    m[2][1] = m2;</a>
<a name="ln482"> </a>
<a name="ln483">    m0 = m[0][2] * other.m[0][0]</a>
<a name="ln484">            + m[1][2] * other.m[0][1]</a>
<a name="ln485">            + m[2][2] * other.m[0][2]</a>
<a name="ln486">            + m[3][2] * other.m[0][3];</a>
<a name="ln487">    m1 = m[0][2] * other.m[1][0]</a>
<a name="ln488">            + m[1][2] * other.m[1][1]</a>
<a name="ln489">            + m[2][2] * other.m[1][2]</a>
<a name="ln490">            + m[3][2] * other.m[1][3];</a>
<a name="ln491">    m2 = m[0][2] * other.m[2][0]</a>
<a name="ln492">            + m[1][2] * other.m[2][1]</a>
<a name="ln493">            + m[2][2] * other.m[2][2]</a>
<a name="ln494">            + m[3][2] * other.m[2][3];</a>
<a name="ln495">    m[3][2] = m[0][2] * other.m[3][0]</a>
<a name="ln496">            + m[1][2] * other.m[3][1]</a>
<a name="ln497">            + m[2][2] * other.m[3][2]</a>
<a name="ln498">            + m[3][2] * other.m[3][3];</a>
<a name="ln499">    m[0][2] = m0;</a>
<a name="ln500">    m[1][2] = m1;</a>
<a name="ln501">    m[2][2] = m2;</a>
<a name="ln502"> </a>
<a name="ln503">    m0 = m[0][3] * other.m[0][0]</a>
<a name="ln504">            + m[1][3] * other.m[0][1]</a>
<a name="ln505">            + m[2][3] * other.m[0][2]</a>
<a name="ln506">            + m[3][3] * other.m[0][3];</a>
<a name="ln507">    m1 = m[0][3] * other.m[1][0]</a>
<a name="ln508">            + m[1][3] * other.m[1][1]</a>
<a name="ln509">            + m[2][3] * other.m[1][2]</a>
<a name="ln510">            + m[3][3] * other.m[1][3];</a>
<a name="ln511">    m2 = m[0][3] * other.m[2][0]</a>
<a name="ln512">            + m[1][3] * other.m[2][1]</a>
<a name="ln513">            + m[2][3] * other.m[2][2]</a>
<a name="ln514">            + m[3][3] * other.m[2][3];</a>
<a name="ln515">    m[3][3] = m[0][3] * other.m[3][0]</a>
<a name="ln516">            + m[1][3] * other.m[3][1]</a>
<a name="ln517">            + m[2][3] * other.m[3][2]</a>
<a name="ln518">            + m[3][3] * other.m[3][3];</a>
<a name="ln519">    m[0][3] = m0;</a>
<a name="ln520">    m[1][3] = m1;</a>
<a name="ln521">    m[2][3] = m2;</a>
<a name="ln522">    return *this;</a>
<a name="ln523">}</a>
<a name="ln524"> </a>
<a name="ln525">inline QMatrix4x4&amp; QMatrix4x4::operator*=(float factor)</a>
<a name="ln526">{</a>
<a name="ln527">    m[0][0] *= factor;</a>
<a name="ln528">    m[0][1] *= factor;</a>
<a name="ln529">    m[0][2] *= factor;</a>
<a name="ln530">    m[0][3] *= factor;</a>
<a name="ln531">    m[1][0] *= factor;</a>
<a name="ln532">    m[1][1] *= factor;</a>
<a name="ln533">    m[1][2] *= factor;</a>
<a name="ln534">    m[1][3] *= factor;</a>
<a name="ln535">    m[2][0] *= factor;</a>
<a name="ln536">    m[2][1] *= factor;</a>
<a name="ln537">    m[2][2] *= factor;</a>
<a name="ln538">    m[2][3] *= factor;</a>
<a name="ln539">    m[3][0] *= factor;</a>
<a name="ln540">    m[3][1] *= factor;</a>
<a name="ln541">    m[3][2] *= factor;</a>
<a name="ln542">    m[3][3] *= factor;</a>
<a name="ln543">    flagBits = General;</a>
<a name="ln544">    return *this;</a>
<a name="ln545">}</a>
<a name="ln546"> </a>
<a name="ln547">inline bool QMatrix4x4::operator==(const QMatrix4x4&amp; other) const</a>
<a name="ln548">{</a>
<a name="ln549">    return m[0][0] == other.m[0][0] &amp;&amp;</a>
<a name="ln550">           m[0][1] == other.m[0][1] &amp;&amp;</a>
<a name="ln551">           m[0][2] == other.m[0][2] &amp;&amp;</a>
<a name="ln552">           m[0][3] == other.m[0][3] &amp;&amp;</a>
<a name="ln553">           m[1][0] == other.m[1][0] &amp;&amp;</a>
<a name="ln554">           m[1][1] == other.m[1][1] &amp;&amp;</a>
<a name="ln555">           m[1][2] == other.m[1][2] &amp;&amp;</a>
<a name="ln556">           m[1][3] == other.m[1][3] &amp;&amp;</a>
<a name="ln557">           m[2][0] == other.m[2][0] &amp;&amp;</a>
<a name="ln558">           m[2][1] == other.m[2][1] &amp;&amp;</a>
<a name="ln559">           m[2][2] == other.m[2][2] &amp;&amp;</a>
<a name="ln560">           m[2][3] == other.m[2][3] &amp;&amp;</a>
<a name="ln561">           m[3][0] == other.m[3][0] &amp;&amp;</a>
<a name="ln562">           m[3][1] == other.m[3][1] &amp;&amp;</a>
<a name="ln563">           m[3][2] == other.m[3][2] &amp;&amp;</a>
<a name="ln564">           m[3][3] == other.m[3][3];</a>
<a name="ln565">}</a>
<a name="ln566"> </a>
<a name="ln567">inline bool QMatrix4x4::operator!=(const QMatrix4x4&amp; other) const</a>
<a name="ln568">{</a>
<a name="ln569">    return m[0][0] != other.m[0][0] ||</a>
<a name="ln570">           m[0][1] != other.m[0][1] ||</a>
<a name="ln571">           m[0][2] != other.m[0][2] ||</a>
<a name="ln572">           m[0][3] != other.m[0][3] ||</a>
<a name="ln573">           m[1][0] != other.m[1][0] ||</a>
<a name="ln574">           m[1][1] != other.m[1][1] ||</a>
<a name="ln575">           m[1][2] != other.m[1][2] ||</a>
<a name="ln576">           m[1][3] != other.m[1][3] ||</a>
<a name="ln577">           m[2][0] != other.m[2][0] ||</a>
<a name="ln578">           m[2][1] != other.m[2][1] ||</a>
<a name="ln579">           m[2][2] != other.m[2][2] ||</a>
<a name="ln580">           m[2][3] != other.m[2][3] ||</a>
<a name="ln581">           m[3][0] != other.m[3][0] ||</a>
<a name="ln582">           m[3][1] != other.m[3][1] ||</a>
<a name="ln583">           m[3][2] != other.m[3][2] ||</a>
<a name="ln584">           m[3][3] != other.m[3][3];</a>
<a name="ln585">}</a>
<a name="ln586"> </a>
<a name="ln587">inline QMatrix4x4 operator+(const QMatrix4x4&amp; m1, const QMatrix4x4&amp; m2)</a>
<a name="ln588">{</a>
<a name="ln589">    QMatrix4x4 m(1);</a>
<a name="ln590">    m.m[0][0] = m1.m[0][0] + m2.m[0][0];</a>
<a name="ln591">    m.m[0][1] = m1.m[0][1] + m2.m[0][1];</a>
<a name="ln592">    m.m[0][2] = m1.m[0][2] + m2.m[0][2];</a>
<a name="ln593">    m.m[0][3] = m1.m[0][3] + m2.m[0][3];</a>
<a name="ln594">    m.m[1][0] = m1.m[1][0] + m2.m[1][0];</a>
<a name="ln595">    m.m[1][1] = m1.m[1][1] + m2.m[1][1];</a>
<a name="ln596">    m.m[1][2] = m1.m[1][2] + m2.m[1][2];</a>
<a name="ln597">    m.m[1][3] = m1.m[1][3] + m2.m[1][3];</a>
<a name="ln598">    m.m[2][0] = m1.m[2][0] + m2.m[2][0];</a>
<a name="ln599">    m.m[2][1] = m1.m[2][1] + m2.m[2][1];</a>
<a name="ln600">    m.m[2][2] = m1.m[2][2] + m2.m[2][2];</a>
<a name="ln601">    m.m[2][3] = m1.m[2][3] + m2.m[2][3];</a>
<a name="ln602">    m.m[3][0] = m1.m[3][0] + m2.m[3][0];</a>
<a name="ln603">    m.m[3][1] = m1.m[3][1] + m2.m[3][1];</a>
<a name="ln604">    m.m[3][2] = m1.m[3][2] + m2.m[3][2];</a>
<a name="ln605">    m.m[3][3] = m1.m[3][3] + m2.m[3][3];</a>
<a name="ln606">    m.flagBits = QMatrix4x4::General;</a>
<a name="ln607">    return m;</a>
<a name="ln608">}</a>
<a name="ln609"> </a>
<a name="ln610">inline QMatrix4x4 operator-(const QMatrix4x4&amp; m1, const QMatrix4x4&amp; m2)</a>
<a name="ln611">{</a>
<a name="ln612">    QMatrix4x4 m(1);</a>
<a name="ln613">    m.m[0][0] = m1.m[0][0] - m2.m[0][0];</a>
<a name="ln614">    m.m[0][1] = m1.m[0][1] - m2.m[0][1];</a>
<a name="ln615">    m.m[0][2] = m1.m[0][2] - m2.m[0][2];</a>
<a name="ln616">    m.m[0][3] = m1.m[0][3] - m2.m[0][3];</a>
<a name="ln617">    m.m[1][0] = m1.m[1][0] - m2.m[1][0];</a>
<a name="ln618">    m.m[1][1] = m1.m[1][1] - m2.m[1][1];</a>
<a name="ln619">    m.m[1][2] = m1.m[1][2] - m2.m[1][2];</a>
<a name="ln620">    m.m[1][3] = m1.m[1][3] - m2.m[1][3];</a>
<a name="ln621">    m.m[2][0] = m1.m[2][0] - m2.m[2][0];</a>
<a name="ln622">    m.m[2][1] = m1.m[2][1] - m2.m[2][1];</a>
<a name="ln623">    m.m[2][2] = m1.m[2][2] - m2.m[2][2];</a>
<a name="ln624">    m.m[2][3] = m1.m[2][3] - m2.m[2][3];</a>
<a name="ln625">    m.m[3][0] = m1.m[3][0] - m2.m[3][0];</a>
<a name="ln626">    m.m[3][1] = m1.m[3][1] - m2.m[3][1];</a>
<a name="ln627">    m.m[3][2] = m1.m[3][2] - m2.m[3][2];</a>
<a name="ln628">    m.m[3][3] = m1.m[3][3] - m2.m[3][3];</a>
<a name="ln629">    m.flagBits = QMatrix4x4::General;</a>
<a name="ln630">    return m;</a>
<a name="ln631">}</a>
<a name="ln632"> </a>
<a name="ln633">inline QMatrix4x4 operator*(const QMatrix4x4&amp; m1, const QMatrix4x4&amp; m2)</a>
<a name="ln634">{</a>
<a name="ln635">    int flagBits = m1.flagBits | m2.flagBits;</a>
<a name="ln636">    if (flagBits &lt; QMatrix4x4::Rotation2D) {</a>
<a name="ln637">        QMatrix4x4 m = m1;</a>
<a name="ln638">        m.m[3][0] += m.m[0][0] * m2.m[3][0];</a>
<a name="ln639">        m.m[3][1] += m.m[1][1] * m2.m[3][1];</a>
<a name="ln640">        m.m[3][2] += m.m[2][2] * m2.m[3][2];</a>
<a name="ln641"> </a>
<a name="ln642">        m.m[0][0] *= m2.m[0][0];</a>
<a name="ln643">        m.m[1][1] *= m2.m[1][1];</a>
<a name="ln644">        m.m[2][2] *= m2.m[2][2];</a>
<a name="ln645">        m.flagBits = flagBits;</a>
<a name="ln646">        return m;</a>
<a name="ln647">    }</a>
<a name="ln648"> </a>
<a name="ln649">    QMatrix4x4 m(1);</a>
<a name="ln650">    m.m[0][0] = m1.m[0][0] * m2.m[0][0]</a>
<a name="ln651">              + m1.m[1][0] * m2.m[0][1]</a>
<a name="ln652">              + m1.m[2][0] * m2.m[0][2]</a>
<a name="ln653">              + m1.m[3][0] * m2.m[0][3];</a>
<a name="ln654">    m.m[0][1] = m1.m[0][1] * m2.m[0][0]</a>
<a name="ln655">              + m1.m[1][1] * m2.m[0][1]</a>
<a name="ln656">              + m1.m[2][1] * m2.m[0][2]</a>
<a name="ln657">              + m1.m[3][1] * m2.m[0][3];</a>
<a name="ln658">    m.m[0][2] = m1.m[0][2] * m2.m[0][0]</a>
<a name="ln659">              + m1.m[1][2] * m2.m[0][1]</a>
<a name="ln660">              + m1.m[2][2] * m2.m[0][2]</a>
<a name="ln661">              + m1.m[3][2] * m2.m[0][3];</a>
<a name="ln662">    m.m[0][3] = m1.m[0][3] * m2.m[0][0]</a>
<a name="ln663">              + m1.m[1][3] * m2.m[0][1]</a>
<a name="ln664">              + m1.m[2][3] * m2.m[0][2]</a>
<a name="ln665">              + m1.m[3][3] * m2.m[0][3];</a>
<a name="ln666"> </a>
<a name="ln667">    m.m[1][0] = m1.m[0][0] * m2.m[1][0]</a>
<a name="ln668">              + m1.m[1][0] * m2.m[1][1]</a>
<a name="ln669">              + m1.m[2][0] * m2.m[1][2]</a>
<a name="ln670">              + m1.m[3][0] * m2.m[1][3];</a>
<a name="ln671">    m.m[1][1] = m1.m[0][1] * m2.m[1][0]</a>
<a name="ln672">              + m1.m[1][1] * m2.m[1][1]</a>
<a name="ln673">              + m1.m[2][1] * m2.m[1][2]</a>
<a name="ln674">              + m1.m[3][1] * m2.m[1][3];</a>
<a name="ln675">    m.m[1][2] = m1.m[0][2] * m2.m[1][0]</a>
<a name="ln676">              + m1.m[1][2] * m2.m[1][1]</a>
<a name="ln677">              + m1.m[2][2] * m2.m[1][2]</a>
<a name="ln678">              + m1.m[3][2] * m2.m[1][3];</a>
<a name="ln679">    m.m[1][3] = m1.m[0][3] * m2.m[1][0]</a>
<a name="ln680">              + m1.m[1][3] * m2.m[1][1]</a>
<a name="ln681">              + m1.m[2][3] * m2.m[1][2]</a>
<a name="ln682">              + m1.m[3][3] * m2.m[1][3];</a>
<a name="ln683"> </a>
<a name="ln684">    m.m[2][0] = m1.m[0][0] * m2.m[2][0]</a>
<a name="ln685">              + m1.m[1][0] * m2.m[2][1]</a>
<a name="ln686">              + m1.m[2][0] * m2.m[2][2]</a>
<a name="ln687">              + m1.m[3][0] * m2.m[2][3];</a>
<a name="ln688">    m.m[2][1] = m1.m[0][1] * m2.m[2][0]</a>
<a name="ln689">              + m1.m[1][1] * m2.m[2][1]</a>
<a name="ln690">              + m1.m[2][1] * m2.m[2][2]</a>
<a name="ln691">              + m1.m[3][1] * m2.m[2][3];</a>
<a name="ln692">    m.m[2][2] = m1.m[0][2] * m2.m[2][0]</a>
<a name="ln693">              + m1.m[1][2] * m2.m[2][1]</a>
<a name="ln694">              + m1.m[2][2] * m2.m[2][2]</a>
<a name="ln695">              + m1.m[3][2] * m2.m[2][3];</a>
<a name="ln696">    m.m[2][3] = m1.m[0][3] * m2.m[2][0]</a>
<a name="ln697">              + m1.m[1][3] * m2.m[2][1]</a>
<a name="ln698">              + m1.m[2][3] * m2.m[2][2]</a>
<a name="ln699">              + m1.m[3][3] * m2.m[2][3];</a>
<a name="ln700"> </a>
<a name="ln701">    m.m[3][0] = m1.m[0][0] * m2.m[3][0]</a>
<a name="ln702">              + m1.m[1][0] * m2.m[3][1]</a>
<a name="ln703">              + m1.m[2][0] * m2.m[3][2]</a>
<a name="ln704">              + m1.m[3][0] * m2.m[3][3];</a>
<a name="ln705">    m.m[3][1] = m1.m[0][1] * m2.m[3][0]</a>
<a name="ln706">              + m1.m[1][1] * m2.m[3][1]</a>
<a name="ln707">              + m1.m[2][1] * m2.m[3][2]</a>
<a name="ln708">              + m1.m[3][1] * m2.m[3][3];</a>
<a name="ln709">    m.m[3][2] = m1.m[0][2] * m2.m[3][0]</a>
<a name="ln710">              + m1.m[1][2] * m2.m[3][1]</a>
<a name="ln711">              + m1.m[2][2] * m2.m[3][2]</a>
<a name="ln712">              + m1.m[3][2] * m2.m[3][3];</a>
<a name="ln713">    m.m[3][3] = m1.m[0][3] * m2.m[3][0]</a>
<a name="ln714">              + m1.m[1][3] * m2.m[3][1]</a>
<a name="ln715">              + m1.m[2][3] * m2.m[3][2]</a>
<a name="ln716">              + m1.m[3][3] * m2.m[3][3];</a>
<a name="ln717">    m.flagBits = flagBits;</a>
<a name="ln718">    return m;</a>
<a name="ln719">}</a>
<a name="ln720"> </a>
<a name="ln721">#ifndef QT_NO_VECTOR3D</a>
<a name="ln722"> </a>
<a name="ln723">inline QVector3D operator*(const QVector3D&amp; vector, const QMatrix4x4&amp; matrix)</a>
<a name="ln724">{</a>
<a name="ln725">    float x, y, z, w;</a>
<a name="ln726">    x = vector.x() * matrix.m[0][0] +</a>
<a name="ln727">        vector.y() * matrix.m[0][1] +</a>
<a name="ln728">        vector.z() * matrix.m[0][2] +</a>
<a name="ln729">        matrix.m[0][3];</a>
<a name="ln730">    y = vector.x() * matrix.m[1][0] +</a>
<a name="ln731">        vector.y() * matrix.m[1][1] +</a>
<a name="ln732">        vector.z() * matrix.m[1][2] +</a>
<a name="ln733">        matrix.m[1][3];</a>
<a name="ln734">    z = vector.x() * matrix.m[2][0] +</a>
<a name="ln735">        vector.y() * matrix.m[2][1] +</a>
<a name="ln736">        vector.z() * matrix.m[2][2] +</a>
<a name="ln737">        matrix.m[2][3];</a>
<a name="ln738">    w = vector.x() * matrix.m[3][0] +</a>
<a name="ln739">        vector.y() * matrix.m[3][1] +</a>
<a name="ln740">        vector.z() * matrix.m[3][2] +</a>
<a name="ln741">        matrix.m[3][3];</a>
<a name="ln742">    if (w == 1.0f)</a>
<a name="ln743">        return QVector3D(x, y, z);</a>
<a name="ln744">    else</a>
<a name="ln745">        return QVector3D(x / w, y / w, z / w);</a>
<a name="ln746">}</a>
<a name="ln747"> </a>
<a name="ln748">inline QVector3D operator*(const QMatrix4x4&amp; matrix, const QVector3D&amp; vector)</a>
<a name="ln749">{</a>
<a name="ln750">    float x, y, z, w;</a>
<a name="ln751">    if (matrix.flagBits == QMatrix4x4::Identity) {</a>
<a name="ln752">        return vector;</a>
<a name="ln753">    } else if (matrix.flagBits &lt; QMatrix4x4::Rotation2D) {</a>
<a name="ln754">        // Translation | Scale</a>
<a name="ln755">        return QVector3D(vector.x() * matrix.m[0][0] + matrix.m[3][0],</a>
<a name="ln756">                         vector.y() * matrix.m[1][1] + matrix.m[3][1],</a>
<a name="ln757">                         vector.z() * matrix.m[2][2] + matrix.m[3][2]);</a>
<a name="ln758">    } else if (matrix.flagBits &lt; QMatrix4x4::Rotation) {</a>
<a name="ln759">        // Translation | Scale | Rotation2D</a>
<a name="ln760">        return QVector3D(vector.x() * matrix.m[0][0] + vector.y() * matrix.m[1][0] + matrix.m[3][0],</a>
<a name="ln761">                         vector.x() * matrix.m[0][1] + vector.y() * matrix.m[1][1] + matrix.m[3][1],</a>
<a name="ln762">                         vector.z() * matrix.m[2][2] + matrix.m[3][2]);</a>
<a name="ln763">    } else {</a>
<a name="ln764">        x = vector.x() * matrix.m[0][0] +</a>
<a name="ln765">            vector.y() * matrix.m[1][0] +</a>
<a name="ln766">            vector.z() * matrix.m[2][0] +</a>
<a name="ln767">            matrix.m[3][0];</a>
<a name="ln768">        y = vector.x() * matrix.m[0][1] +</a>
<a name="ln769">            vector.y() * matrix.m[1][1] +</a>
<a name="ln770">            vector.z() * matrix.m[2][1] +</a>
<a name="ln771">            matrix.m[3][1];</a>
<a name="ln772">        z = vector.x() * matrix.m[0][2] +</a>
<a name="ln773">            vector.y() * matrix.m[1][2] +</a>
<a name="ln774">            vector.z() * matrix.m[2][2] +</a>
<a name="ln775">            matrix.m[3][2];</a>
<a name="ln776">        w = vector.x() * matrix.m[0][3] +</a>
<a name="ln777">            vector.y() * matrix.m[1][3] +</a>
<a name="ln778">            vector.z() * matrix.m[2][3] +</a>
<a name="ln779">            matrix.m[3][3];</a>
<a name="ln780">        if (w == 1.0f)</a>
<a name="ln781">            return QVector3D(x, y, z);</a>
<a name="ln782">        else</a>
<a name="ln783">            return QVector3D(x / w, y / w, z / w);</a>
<a name="ln784">    }</a>
<a name="ln785">}</a>
<a name="ln786"> </a>
<a name="ln787">#endif</a>
<a name="ln788"> </a>
<a name="ln789">#ifndef QT_NO_VECTOR4D</a>
<a name="ln790"> </a>
<a name="ln791">inline QVector4D operator*(const QVector4D&amp; vector, const QMatrix4x4&amp; matrix)</a>
<a name="ln792">{</a>
<a name="ln793">    float x, y, z, w;</a>
<a name="ln794">    x = vector.x() * matrix.m[0][0] +</a>
<a name="ln795">        vector.y() * matrix.m[0][1] +</a>
<a name="ln796">        vector.z() * matrix.m[0][2] +</a>
<a name="ln797">        vector.w() * matrix.m[0][3];</a>
<a name="ln798">    y = vector.x() * matrix.m[1][0] +</a>
<a name="ln799">        vector.y() * matrix.m[1][1] +</a>
<a name="ln800">        vector.z() * matrix.m[1][2] +</a>
<a name="ln801">        vector.w() * matrix.m[1][3];</a>
<a name="ln802">    z = vector.x() * matrix.m[2][0] +</a>
<a name="ln803">        vector.y() * matrix.m[2][1] +</a>
<a name="ln804">        vector.z() * matrix.m[2][2] +</a>
<a name="ln805">        vector.w() * matrix.m[2][3];</a>
<a name="ln806">    w = vector.x() * matrix.m[3][0] +</a>
<a name="ln807">        vector.y() * matrix.m[3][1] +</a>
<a name="ln808">        vector.z() * matrix.m[3][2] +</a>
<a name="ln809">        vector.w() * matrix.m[3][3];</a>
<a name="ln810">    return QVector4D(x, y, z, w);</a>
<a name="ln811">}</a>
<a name="ln812"> </a>
<a name="ln813">inline QVector4D operator*(const QMatrix4x4&amp; matrix, const QVector4D&amp; vector)</a>
<a name="ln814">{</a>
<a name="ln815">    float x, y, z, w;</a>
<a name="ln816">    x = vector.x() * matrix.m[0][0] +</a>
<a name="ln817">        vector.y() * matrix.m[1][0] +</a>
<a name="ln818">        vector.z() * matrix.m[2][0] +</a>
<a name="ln819">        vector.w() * matrix.m[3][0];</a>
<a name="ln820">    y = vector.x() * matrix.m[0][1] +</a>
<a name="ln821">        vector.y() * matrix.m[1][1] +</a>
<a name="ln822">        vector.z() * matrix.m[2][1] +</a>
<a name="ln823">        vector.w() * matrix.m[3][1];</a>
<a name="ln824">    z = vector.x() * matrix.m[0][2] +</a>
<a name="ln825">        vector.y() * matrix.m[1][2] +</a>
<a name="ln826">        vector.z() * matrix.m[2][2] +</a>
<a name="ln827">        vector.w() * matrix.m[3][2];</a>
<a name="ln828">    w = vector.x() * matrix.m[0][3] +</a>
<a name="ln829">        vector.y() * matrix.m[1][3] +</a>
<a name="ln830">        vector.z() * matrix.m[2][3] +</a>
<a name="ln831">        vector.w() * matrix.m[3][3];</a>
<a name="ln832">    return QVector4D(x, y, z, w);</a>
<a name="ln833">}</a>
<a name="ln834"> </a>
<a name="ln835">#endif</a>
<a name="ln836"> </a>
<a name="ln837">inline QPoint operator*(const QPoint&amp; point, const QMatrix4x4&amp; matrix)</a>
<a name="ln838">{</a>
<a name="ln839">    float xin, yin;</a>
<a name="ln840">    float x, y, w;</a>
<a name="ln841">    xin = point.x();</a>
<a name="ln842">    yin = point.y();</a>
<a name="ln843">    x = xin * matrix.m[0][0] +</a>
<a name="ln844">        yin * matrix.m[0][1] +</a>
<a name="ln845">        matrix.m[0][3];</a>
<a name="ln846">    y = xin * matrix.m[1][0] +</a>
<a name="ln847">        yin * matrix.m[1][1] +</a>
<a name="ln848">        matrix.m[1][3];</a>
<a name="ln849">    w = xin * matrix.m[3][0] +</a>
<a name="ln850">        yin * matrix.m[3][1] +</a>
<a name="ln851">        matrix.m[3][3];</a>
<a name="ln852">    if (w == 1.0f)</a>
<a name="ln853">        return QPoint(qRound(x), qRound(y));</a>
<a name="ln854">    else</a>
<a name="ln855">        return QPoint(qRound(x / w), qRound(y / w));</a>
<a name="ln856">}</a>
<a name="ln857"> </a>
<a name="ln858">inline QPointF operator*(const QPointF&amp; point, const QMatrix4x4&amp; matrix)</a>
<a name="ln859">{</a>
<a name="ln860">    float xin, yin;</a>
<a name="ln861">    float x, y, w;</a>
<a name="ln862">    xin = float(point.x());</a>
<a name="ln863">    yin = float(point.y());</a>
<a name="ln864">    x = xin * matrix.m[0][0] +</a>
<a name="ln865">        yin * matrix.m[0][1] +</a>
<a name="ln866">        matrix.m[0][3];</a>
<a name="ln867">    y = xin * matrix.m[1][0] +</a>
<a name="ln868">        yin * matrix.m[1][1] +</a>
<a name="ln869">        matrix.m[1][3];</a>
<a name="ln870">    w = xin * matrix.m[3][0] +</a>
<a name="ln871">        yin * matrix.m[3][1] +</a>
<a name="ln872">        matrix.m[3][3];</a>
<a name="ln873">    if (w == 1.0f) {</a>
<a name="ln874">        return QPointF(qreal(x), qreal(y));</a>
<a name="ln875">    } else {</a>
<a name="ln876">        return QPointF(qreal(x / w), qreal(y / w));</a>
<a name="ln877">    }</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">inline QPoint operator*(const QMatrix4x4&amp; matrix, const QPoint&amp; point)</a>
<a name="ln881">{</a>
<a name="ln882">    float xin, yin;</a>
<a name="ln883">    float x, y, w;</a>
<a name="ln884">    xin = point.x();</a>
<a name="ln885">    yin = point.y();</a>
<a name="ln886">    if (matrix.flagBits == QMatrix4x4::Identity) {</a>
<a name="ln887">        return point;</a>
<a name="ln888">    } else if (matrix.flagBits &lt; QMatrix4x4::Rotation2D) {</a>
<a name="ln889">        // Translation | Scale</a>
<a name="ln890">        return QPoint(qRound(xin * matrix.m[0][0] + matrix.m[3][0]),</a>
<a name="ln891">                      qRound(yin * matrix.m[1][1] + matrix.m[3][1]));</a>
<a name="ln892">    } else if (matrix.flagBits &lt; QMatrix4x4::Perspective) {</a>
<a name="ln893">        return QPoint(qRound(xin * matrix.m[0][0] + yin * matrix.m[1][0] + matrix.m[3][0]),</a>
<a name="ln894">                      qRound(xin * matrix.m[0][1] + yin * matrix.m[1][1] + matrix.m[3][1]));</a>
<a name="ln895">    } else {</a>
<a name="ln896">        x = xin * matrix.m[0][0] +</a>
<a name="ln897">            yin * matrix.m[1][0] +</a>
<a name="ln898">            matrix.m[3][0];</a>
<a name="ln899">        y = xin * matrix.m[0][1] +</a>
<a name="ln900">            yin * matrix.m[1][1] +</a>
<a name="ln901">            matrix.m[3][1];</a>
<a name="ln902">        w = xin * matrix.m[0][3] +</a>
<a name="ln903">            yin * matrix.m[1][3] +</a>
<a name="ln904">            matrix.m[3][3];</a>
<a name="ln905">        if (w == 1.0f)</a>
<a name="ln906">            return QPoint(qRound(x), qRound(y));</a>
<a name="ln907">        else</a>
<a name="ln908">            return QPoint(qRound(x / w), qRound(y / w));</a>
<a name="ln909">    }</a>
<a name="ln910">}</a>
<a name="ln911"> </a>
<a name="ln912">inline QPointF operator*(const QMatrix4x4&amp; matrix, const QPointF&amp; point)</a>
<a name="ln913">{</a>
<a name="ln914">    qreal xin, yin;</a>
<a name="ln915">    qreal x, y, w;</a>
<a name="ln916">    xin = point.x();</a>
<a name="ln917">    yin = point.y();</a>
<a name="ln918">    if (matrix.flagBits == QMatrix4x4::Identity) {</a>
<a name="ln919">        return point;</a>
<a name="ln920">    } else if (matrix.flagBits &lt; QMatrix4x4::Rotation2D) {</a>
<a name="ln921">        // Translation | Scale</a>
<a name="ln922">        return QPointF(xin * qreal(matrix.m[0][0]) + qreal(matrix.m[3][0]),</a>
<a name="ln923">                       yin * qreal(matrix.m[1][1]) + qreal(matrix.m[3][1]));</a>
<a name="ln924">    } else if (matrix.flagBits &lt; QMatrix4x4::Perspective) {</a>
<a name="ln925">        return QPointF(xin * qreal(matrix.m[0][0]) + yin * qreal(matrix.m[1][0]) +</a>
<a name="ln926">                       qreal(matrix.m[3][0]),</a>
<a name="ln927">                       xin * qreal(matrix.m[0][1]) + yin * qreal(matrix.m[1][1]) +</a>
<a name="ln928">                       qreal(matrix.m[3][1]));</a>
<a name="ln929">    } else {</a>
<a name="ln930">        x = xin * qreal(matrix.m[0][0]) +</a>
<a name="ln931">            yin * qreal(matrix.m[1][0]) +</a>
<a name="ln932">            qreal(matrix.m[3][0]);</a>
<a name="ln933">        y = xin * qreal(matrix.m[0][1]) +</a>
<a name="ln934">            yin * qreal(matrix.m[1][1]) +</a>
<a name="ln935">            qreal(matrix.m[3][1]);</a>
<a name="ln936">        w = xin * qreal(matrix.m[0][3]) +</a>
<a name="ln937">            yin * qreal(matrix.m[1][3]) +</a>
<a name="ln938">            qreal(matrix.m[3][3]);</a>
<a name="ln939">        if (w == 1.0) {</a>
<a name="ln940">            return QPointF(qreal(x), qreal(y));</a>
<a name="ln941">        } else {</a>
<a name="ln942">            return QPointF(qreal(x / w), qreal(y / w));</a>
<a name="ln943">        }</a>
<a name="ln944">    }</a>
<a name="ln945">}</a>
<a name="ln946"> </a>
<a name="ln947">inline QMatrix4x4 operator-(const QMatrix4x4&amp; matrix)</a>
<a name="ln948">{</a>
<a name="ln949">    QMatrix4x4 m(1);</a>
<a name="ln950">    m.m[0][0] = -matrix.m[0][0];</a>
<a name="ln951">    m.m[0][1] = -matrix.m[0][1];</a>
<a name="ln952">    m.m[0][2] = -matrix.m[0][2];</a>
<a name="ln953">    m.m[0][3] = -matrix.m[0][3];</a>
<a name="ln954">    m.m[1][0] = -matrix.m[1][0];</a>
<a name="ln955">    m.m[1][1] = -matrix.m[1][1];</a>
<a name="ln956">    m.m[1][2] = -matrix.m[1][2];</a>
<a name="ln957">    m.m[1][3] = -matrix.m[1][3];</a>
<a name="ln958">    m.m[2][0] = -matrix.m[2][0];</a>
<a name="ln959">    m.m[2][1] = -matrix.m[2][1];</a>
<a name="ln960">    m.m[2][2] = -matrix.m[2][2];</a>
<a name="ln961">    m.m[2][3] = -matrix.m[2][3];</a>
<a name="ln962">    m.m[3][0] = -matrix.m[3][0];</a>
<a name="ln963">    m.m[3][1] = -matrix.m[3][1];</a>
<a name="ln964">    m.m[3][2] = -matrix.m[3][2];</a>
<a name="ln965">    m.m[3][3] = -matrix.m[3][3];</a>
<a name="ln966">    m.flagBits = QMatrix4x4::General;</a>
<a name="ln967">    return m;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">inline QMatrix4x4 operator*(float factor, const QMatrix4x4&amp; matrix)</a>
<a name="ln971">{</a>
<a name="ln972">    QMatrix4x4 m(1);</a>
<a name="ln973">    m.m[0][0] = matrix.m[0][0] * factor;</a>
<a name="ln974">    m.m[0][1] = matrix.m[0][1] * factor;</a>
<a name="ln975">    m.m[0][2] = matrix.m[0][2] * factor;</a>
<a name="ln976">    m.m[0][3] = matrix.m[0][3] * factor;</a>
<a name="ln977">    m.m[1][0] = matrix.m[1][0] * factor;</a>
<a name="ln978">    m.m[1][1] = matrix.m[1][1] * factor;</a>
<a name="ln979">    m.m[1][2] = matrix.m[1][2] * factor;</a>
<a name="ln980">    m.m[1][3] = matrix.m[1][3] * factor;</a>
<a name="ln981">    m.m[2][0] = matrix.m[2][0] * factor;</a>
<a name="ln982">    m.m[2][1] = matrix.m[2][1] * factor;</a>
<a name="ln983">    m.m[2][2] = matrix.m[2][2] * factor;</a>
<a name="ln984">    m.m[2][3] = matrix.m[2][3] * factor;</a>
<a name="ln985">    m.m[3][0] = matrix.m[3][0] * factor;</a>
<a name="ln986">    m.m[3][1] = matrix.m[3][1] * factor;</a>
<a name="ln987">    m.m[3][2] = matrix.m[3][2] * factor;</a>
<a name="ln988">    m.m[3][3] = matrix.m[3][3] * factor;</a>
<a name="ln989">    m.flagBits = QMatrix4x4::General;</a>
<a name="ln990">    return m;</a>
<a name="ln991">}</a>
<a name="ln992"> </a>
<a name="ln993">inline QMatrix4x4 operator*(const QMatrix4x4&amp; matrix, float factor)</a>
<a name="ln994">{</a>
<a name="ln995">    QMatrix4x4 m(1);</a>
<a name="ln996">    m.m[0][0] = matrix.m[0][0] * factor;</a>
<a name="ln997">    m.m[0][1] = matrix.m[0][1] * factor;</a>
<a name="ln998">    m.m[0][2] = matrix.m[0][2] * factor;</a>
<a name="ln999">    m.m[0][3] = matrix.m[0][3] * factor;</a>
<a name="ln1000">    m.m[1][0] = matrix.m[1][0] * factor;</a>
<a name="ln1001">    m.m[1][1] = matrix.m[1][1] * factor;</a>
<a name="ln1002">    m.m[1][2] = matrix.m[1][2] * factor;</a>
<a name="ln1003">    m.m[1][3] = matrix.m[1][3] * factor;</a>
<a name="ln1004">    m.m[2][0] = matrix.m[2][0] * factor;</a>
<a name="ln1005">    m.m[2][1] = matrix.m[2][1] * factor;</a>
<a name="ln1006">    m.m[2][2] = matrix.m[2][2] * factor;</a>
<a name="ln1007">    m.m[2][3] = matrix.m[2][3] * factor;</a>
<a name="ln1008">    m.m[3][0] = matrix.m[3][0] * factor;</a>
<a name="ln1009">    m.m[3][1] = matrix.m[3][1] * factor;</a>
<a name="ln1010">    m.m[3][2] = matrix.m[3][2] * factor;</a>
<a name="ln1011">    m.m[3][3] = matrix.m[3][3] * factor;</a>
<a name="ln1012">    m.flagBits = QMatrix4x4::General;</a>
<a name="ln1013">    return m;</a>
<a name="ln1014">}</a>
<a name="ln1015"> </a>
<a name="ln1016">inline bool qFuzzyCompare(const QMatrix4x4&amp; m1, const QMatrix4x4&amp; m2)</a>
<a name="ln1017">{</a>
<a name="ln1018">    return qFuzzyCompare(m1.m[0][0], m2.m[0][0]) &amp;&amp;</a>
<a name="ln1019">           qFuzzyCompare(m1.m[0][1], m2.m[0][1]) &amp;&amp;</a>
<a name="ln1020">           qFuzzyCompare(m1.m[0][2], m2.m[0][2]) &amp;&amp;</a>
<a name="ln1021">           qFuzzyCompare(m1.m[0][3], m2.m[0][3]) &amp;&amp;</a>
<a name="ln1022">           qFuzzyCompare(m1.m[1][0], m2.m[1][0]) &amp;&amp;</a>
<a name="ln1023">           qFuzzyCompare(m1.m[1][1], m2.m[1][1]) &amp;&amp;</a>
<a name="ln1024">           qFuzzyCompare(m1.m[1][2], m2.m[1][2]) &amp;&amp;</a>
<a name="ln1025">           qFuzzyCompare(m1.m[1][3], m2.m[1][3]) &amp;&amp;</a>
<a name="ln1026">           qFuzzyCompare(m1.m[2][0], m2.m[2][0]) &amp;&amp;</a>
<a name="ln1027">           qFuzzyCompare(m1.m[2][1], m2.m[2][1]) &amp;&amp;</a>
<a name="ln1028">           qFuzzyCompare(m1.m[2][2], m2.m[2][2]) &amp;&amp;</a>
<a name="ln1029">           qFuzzyCompare(m1.m[2][3], m2.m[2][3]) &amp;&amp;</a>
<a name="ln1030">           qFuzzyCompare(m1.m[3][0], m2.m[3][0]) &amp;&amp;</a>
<a name="ln1031">           qFuzzyCompare(m1.m[3][1], m2.m[3][1]) &amp;&amp;</a>
<a name="ln1032">           qFuzzyCompare(m1.m[3][2], m2.m[3][2]) &amp;&amp;</a>
<a name="ln1033">           qFuzzyCompare(m1.m[3][3], m2.m[3][3]);</a>
<a name="ln1034">}</a>
<a name="ln1035"> </a>
<a name="ln1036">inline QPoint QMatrix4x4::map(const QPoint&amp; point) const</a>
<a name="ln1037">{</a>
<a name="ln1038">    return *this * point;</a>
<a name="ln1039">}</a>
<a name="ln1040"> </a>
<a name="ln1041">inline QPointF QMatrix4x4::map(const QPointF&amp; point) const</a>
<a name="ln1042">{</a>
<a name="ln1043">    return *this * point;</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">#ifndef QT_NO_VECTOR3D</a>
<a name="ln1047"> </a>
<a name="ln1048">inline QVector3D QMatrix4x4::map(const QVector3D&amp; point) const</a>
<a name="ln1049">{</a>
<a name="ln1050">    return *this * point;</a>
<a name="ln1051">}</a>
<a name="ln1052"> </a>
<a name="ln1053">inline QVector3D QMatrix4x4::mapVector(const QVector3D&amp; vector) const</a>
<a name="ln1054">{</a>
<a name="ln1055">    if (flagBits &lt; Scale) {</a>
<a name="ln1056">        // Translation</a>
<a name="ln1057">        return vector;</a>
<a name="ln1058">    } else if (flagBits &lt; Rotation2D) {</a>
<a name="ln1059">        // Translation | Scale</a>
<a name="ln1060">        return QVector3D(vector.x() * m[0][0],</a>
<a name="ln1061">                         vector.y() * m[1][1],</a>
<a name="ln1062">                         vector.z() * m[2][2]);</a>
<a name="ln1063">    } else {</a>
<a name="ln1064">        return QVector3D(vector.x() * m[0][0] +</a>
<a name="ln1065">                         vector.y() * m[1][0] +</a>
<a name="ln1066">                         vector.z() * m[2][0],</a>
<a name="ln1067">                         vector.x() * m[0][1] +</a>
<a name="ln1068">                         vector.y() * m[1][1] +</a>
<a name="ln1069">                         vector.z() * m[2][1],</a>
<a name="ln1070">                         vector.x() * m[0][2] +</a>
<a name="ln1071">                         vector.y() * m[1][2] +</a>
<a name="ln1072">                         vector.z() * m[2][2]);</a>
<a name="ln1073">    }</a>
<a name="ln1074">}</a>
<a name="ln1075"> </a>
<a name="ln1076">#endif</a>
<a name="ln1077"> </a>
<a name="ln1078">#ifndef QT_NO_VECTOR4D</a>
<a name="ln1079"> </a>
<a name="ln1080">inline QVector4D QMatrix4x4::map(const QVector4D&amp; point) const</a>
<a name="ln1081">{</a>
<a name="ln1082">    return *this * point;</a>
<a name="ln1083">}</a>
<a name="ln1084"> </a>
<a name="ln1085">#endif</a>
<a name="ln1086"> </a>
<a name="ln1087">inline float *QMatrix4x4::data()</a>
<a name="ln1088">{</a>
<a name="ln1089">    // We have to assume that the caller will modify the matrix elements,</a>
<a name="ln1090">    // so we flip it over to &quot;General&quot; mode.</a>
<a name="ln1091">    flagBits = General;</a>
<a name="ln1092">    return *m;</a>
<a name="ln1093">}</a>
<a name="ln1094"> </a>
<a name="ln1095">inline void QMatrix4x4::viewport(const QRectF &amp;rect)</a>
<a name="ln1096">{</a>
<a name="ln1097">    viewport(float(rect.x()), float(rect.y()), float(rect.width()), float(rect.height()));</a>
<a name="ln1098">}</a>
<a name="ln1099"> </a>
<a name="ln1100">QT_WARNING_POP</a>
<a name="ln1101"> </a>
<a name="ln1102">#ifndef QT_NO_DEBUG_STREAM</a>
<a name="ln1103">Q_GUI_EXPORT QDebug operator&lt;&lt;(QDebug dbg, const QMatrix4x4 &amp;m);</a>
<a name="ln1104">#endif</a>
<a name="ln1105"> </a>
<a name="ln1106">#ifndef QT_NO_DATASTREAM</a>
<a name="ln1107">Q_GUI_EXPORT QDataStream &amp;operator&lt;&lt;(QDataStream &amp;, const QMatrix4x4 &amp;);</a>
<a name="ln1108">Q_GUI_EXPORT QDataStream &amp;operator&gt;&gt;(QDataStream &amp;, QMatrix4x4 &amp;);</a>
<a name="ln1109">#endif</a>
<a name="ln1110"> </a>
<a name="ln1111">#if QT_DEPRECATED_SINCE(5, 0)</a>
<a name="ln1112">template &lt;int N, int M&gt;</a>
<a name="ln1113">QT_DEPRECATED QMatrix4x4 qGenericMatrixToMatrix4x4(const QGenericMatrix&lt;N, M, float&gt;&amp; matrix)</a>
<a name="ln1114">{</a>
<a name="ln1115">    return QMatrix4x4(matrix.constData(), N, M);</a>
<a name="ln1116">}</a>
<a name="ln1117"> </a>
<a name="ln1118">template &lt;int N, int M&gt;</a>
<a name="ln1119">QT_DEPRECATED QGenericMatrix&lt;N, M, float&gt; qGenericMatrixFromMatrix4x4(const QMatrix4x4&amp; matrix)</a>
<a name="ln1120">{</a>
<a name="ln1121">    QGenericMatrix&lt;N, M, float&gt; result;</a>
<a name="ln1122">    const float *m = matrix.constData();</a>
<a name="ln1123">    float *values = result.data();</a>
<a name="ln1124">    for (int col = 0; col &lt; N; ++col) {</a>
<a name="ln1125">        for (int row = 0; row &lt; M; ++row) {</a>
<a name="ln1126">            if (col &lt; 4 &amp;&amp; row &lt; 4)</a>
<a name="ln1127">                values[col * M + row] = m[col * 4 + row];</a>
<a name="ln1128">            else if (col == row)</a>
<a name="ln1129">                values[col * M + row] = 1.0f;</a>
<a name="ln1130">            else</a>
<a name="ln1131">                values[col * M + row] = 0.0f;</a>
<a name="ln1132">        }</a>
<a name="ln1133">    }</a>
<a name="ln1134">    return result;</a>
<a name="ln1135">}</a>
<a name="ln1136">#endif</a>
<a name="ln1137"> </a>
<a name="ln1138">#endif</a>
<a name="ln1139"> </a>
<a name="ln1140">QT_END_NAMESPACE</a>
<a name="ln1141"> </a>
<a name="ln1142">#endif</a>

</code></pre>
<div class="balloon" rel="63"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: m.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
