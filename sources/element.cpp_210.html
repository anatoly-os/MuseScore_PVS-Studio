
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>element.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">/**</a>
<a name="ln14"> \file</a>
<a name="ln15"> Implementation of Element, ElementList</a>
<a name="ln16">*/</a>
<a name="ln17"> </a>
<a name="ln18">#include &quot;element.h&quot;</a>
<a name="ln19">#include &quot;accidental.h&quot;</a>
<a name="ln20">#include &quot;ambitus.h&quot;</a>
<a name="ln21">#include &quot;arpeggio.h&quot;</a>
<a name="ln22">#include &quot;articulation.h&quot;</a>
<a name="ln23">#include &quot;bagpembell.h&quot;</a>
<a name="ln24">#include &quot;barline.h&quot;</a>
<a name="ln25">#include &quot;bend.h&quot;</a>
<a name="ln26">#include &quot;box.h&quot;</a>
<a name="ln27">#include &quot;bracket.h&quot;</a>
<a name="ln28">#include &quot;breath.h&quot;</a>
<a name="ln29">#include &quot;chord.h&quot;</a>
<a name="ln30">#include &quot;chordline.h&quot;</a>
<a name="ln31">#include &quot;chordrest.h&quot;</a>
<a name="ln32">#include &quot;clef.h&quot;</a>
<a name="ln33">#include &quot;connector.h&quot;</a>
<a name="ln34">#include &quot;dynamic.h&quot;</a>
<a name="ln35">#include &quot;figuredbass.h&quot;</a>
<a name="ln36">#include &quot;fingering.h&quot;</a>
<a name="ln37">#include &quot;fret.h&quot;</a>
<a name="ln38">#include &quot;glissando.h&quot;</a>
<a name="ln39">#include &quot;hairpin.h&quot;</a>
<a name="ln40">#include &quot;harmony.h&quot;</a>
<a name="ln41">#include &quot;icon.h&quot;</a>
<a name="ln42">#include &quot;image.h&quot;</a>
<a name="ln43">#include &quot;iname.h&quot;</a>
<a name="ln44">#include &quot;instrchange.h&quot;</a>
<a name="ln45">#include &quot;jump.h&quot;</a>
<a name="ln46">#include &quot;keysig.h&quot;</a>
<a name="ln47">#include &quot;layoutbreak.h&quot;</a>
<a name="ln48">#include &quot;lyrics.h&quot;</a>
<a name="ln49">#include &quot;marker.h&quot;</a>
<a name="ln50">#include &quot;measure.h&quot;</a>
<a name="ln51">#include &quot;mscore.h&quot;</a>
<a name="ln52">#include &quot;notedot.h&quot;</a>
<a name="ln53">#include &quot;note.h&quot;</a>
<a name="ln54">#include &quot;noteline.h&quot;</a>
<a name="ln55">#include &quot;ossia.h&quot;</a>
<a name="ln56">#include &quot;ottava.h&quot;</a>
<a name="ln57">#include &quot;page.h&quot;</a>
<a name="ln58">#include &quot;pedal.h&quot;</a>
<a name="ln59">#include &quot;rehearsalmark.h&quot;</a>
<a name="ln60">#include &quot;repeat.h&quot;</a>
<a name="ln61">#include &quot;rest.h&quot;</a>
<a name="ln62">#include &quot;score.h&quot;</a>
<a name="ln63">#include &quot;segment.h&quot;</a>
<a name="ln64">#include &quot;slur.h&quot;</a>
<a name="ln65">#include &quot;spacer.h&quot;</a>
<a name="ln66">#include &quot;staff.h&quot;</a>
<a name="ln67">#include &quot;staffstate.h&quot;</a>
<a name="ln68">#include &quot;stafftext.h&quot;</a>
<a name="ln69">#include &quot;systemtext.h&quot;</a>
<a name="ln70">#include &quot;stafftype.h&quot;</a>
<a name="ln71">#include &quot;stem.h&quot;</a>
<a name="ln72">#include &quot;sticking.h&quot;</a>
<a name="ln73">#include &quot;style.h&quot;</a>
<a name="ln74">#include &quot;symbol.h&quot;</a>
<a name="ln75">#include &quot;sym.h&quot;</a>
<a name="ln76">#include &quot;system.h&quot;</a>
<a name="ln77">#include &quot;tempotext.h&quot;</a>
<a name="ln78">#include &quot;textframe.h&quot;</a>
<a name="ln79">#include &quot;text.h&quot;</a>
<a name="ln80">#include &quot;measurenumber.h&quot;</a>
<a name="ln81">#include &quot;textline.h&quot;</a>
<a name="ln82">#include &quot;tie.h&quot;</a>
<a name="ln83">#include &quot;timesig.h&quot;</a>
<a name="ln84">#include &quot;tremolobar.h&quot;</a>
<a name="ln85">#include &quot;tremolo.h&quot;</a>
<a name="ln86">#include &quot;trill.h&quot;</a>
<a name="ln87">#include &quot;undo.h&quot;</a>
<a name="ln88">#include &quot;utils.h&quot;</a>
<a name="ln89">#include &quot;volta.h&quot;</a>
<a name="ln90">#include &quot;xml.h&quot;</a>
<a name="ln91">#include &quot;systemdivider.h&quot;</a>
<a name="ln92">#include &quot;stafftypechange.h&quot;</a>
<a name="ln93">#include &quot;stafflines.h&quot;</a>
<a name="ln94">#include &quot;letring.h&quot;</a>
<a name="ln95">#include &quot;vibrato.h&quot;</a>
<a name="ln96">#include &quot;palmmute.h&quot;</a>
<a name="ln97">#include &quot;fermata.h&quot;</a>
<a name="ln98">#include &quot;shape.h&quot;</a>
<a name="ln99">//#include &quot;musescoreCore.h&quot;</a>
<a name="ln100"> </a>
<a name="ln101">namespace Ms {</a>
<a name="ln102"> </a>
<a name="ln103">// extern bool showInvisible;</a>
<a name="ln104"> </a>
<a name="ln105">//---------------------------------------------------------</a>
<a name="ln106">//   spatiumChanged</a>
<a name="ln107">//---------------------------------------------------------</a>
<a name="ln108"> </a>
<a name="ln109">void Element::spatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln110">      {</a>
<a name="ln111">      if (sizeIsSpatiumDependent())</a>
<a name="ln112">            _offset *= (newValue / oldValue);</a>
<a name="ln113">      }</a>
<a name="ln114"> </a>
<a name="ln115">//---------------------------------------------------------</a>
<a name="ln116">//   localSpatiumChanged</a>
<a name="ln117">//    the scale of a staff changed</a>
<a name="ln118">//---------------------------------------------------------</a>
<a name="ln119"> </a>
<a name="ln120">void Element::localSpatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln121">      {</a>
<a name="ln122">      if (sizeIsSpatiumDependent())</a>
<a name="ln123">            _offset *= (newValue / oldValue);</a>
<a name="ln124">      }</a>
<a name="ln125"> </a>
<a name="ln126">//---------------------------------------------------------</a>
<a name="ln127">//   spatium</a>
<a name="ln128">//---------------------------------------------------------</a>
<a name="ln129"> </a>
<a name="ln130">qreal Element::spatium() const</a>
<a name="ln131">      {</a>
<a name="ln132">      if (systemFlag() || (parent() &amp;&amp; parent()-&gt;systemFlag())) {</a>
<a name="ln133">            return score()-&gt;spatium();</a>
<a name="ln134">            }</a>
<a name="ln135">      else {</a>
<a name="ln136">            Staff* s = staff();</a>
<a name="ln137">            return s ? s-&gt;spatium(tick()) : score()-&gt;spatium();</a>
<a name="ln138">            }</a>
<a name="ln139">      }</a>
<a name="ln140"> </a>
<a name="ln141">//---------------------------------------------------------</a>
<a name="ln142">//   magS</a>
<a name="ln143">//---------------------------------------------------------</a>
<a name="ln144"> </a>
<a name="ln145">qreal Element::magS() const</a>
<a name="ln146">      {</a>
<a name="ln147">      return mag() * (score()-&gt;spatium() / SPATIUM20);</a>
<a name="ln148">      }</a>
<a name="ln149"> </a>
<a name="ln150">//---------------------------------------------------------</a>
<a name="ln151">//   name</a>
<a name="ln152">//---------------------------------------------------------</a>
<a name="ln153"> </a>
<a name="ln154">QString Element::subtypeName() const</a>
<a name="ln155">      {</a>
<a name="ln156">      return &quot;&quot;;</a>
<a name="ln157">      }</a>
<a name="ln158"> </a>
<a name="ln159">//---------------------------------------------------------</a>
<a name="ln160">//   Element</a>
<a name="ln161">//---------------------------------------------------------</a>
<a name="ln162"> </a>
<a name="ln163">Element::Element(Score* s, ElementFlags f)</a>
<a name="ln164">   : ScoreElement(s)</a>
<a name="ln165">      {</a>
<a name="ln166">      _flags         = f;</a>
<a name="ln167">      _track         = -1;</a>
<a name="ln168">      _color         = MScore::defaultColor;</a>
<a name="ln169">      _mag           = 1.0;</a>
<a name="ln170">      _tag           = 1;</a>
<a name="ln171">      _z             = -1;</a>
<a name="ln172">      _offsetChanged = OffsetChange::NONE;</a>
<a name="ln173">      _minDistance   = Spatium(0.0);</a>
<a name="ln174">      }</a>
<a name="ln175"> </a>
<a name="ln176">Element::Element(const Element&amp; e)</a>
<a name="ln177">   : ScoreElement(e)</a>
<a name="ln178">      {</a>
<a name="ln179">      _parent     = e._parent;</a>
<a name="ln180">      _bbox       = e._bbox;</a>
<a name="ln181">      _mag        = e._mag;</a>
<a name="ln182">      _pos        = e._pos;</a>
<a name="ln183">      _offset     = e._offset;</a>
<a name="ln184">      _track      = e._track;</a>
<a name="ln185">      _flags      = e._flags;</a>
<a name="ln186">      setFlag(ElementFlag::SELECTED, false);</a>
<a name="ln187">      _tag        = e._tag;</a>
<a name="ln188">      _z          = e._z;</a>
<a name="ln189">      _color      = e._color;</a>
<a name="ln190">      _offsetChanged = e._offsetChanged;</a>
<a name="ln191">      _minDistance   = e._minDistance;</a>
<a name="ln192">      itemDiscovered = false;</a>
<a name="ln193">      }</a>
<a name="ln194"> </a>
<a name="ln195">//---------------------------------------------------------</a>
<a name="ln196">//   ~Element</a>
<a name="ln197">//---------------------------------------------------------</a>
<a name="ln198"> </a>
<a name="ln199">Element::~Element()</a>
<a name="ln200">      {</a>
<a name="ln201">      Score::onElementDestruction(this);</a>
<a name="ln202">      }</a>
<a name="ln203"> </a>
<a name="ln204">//---------------------------------------------------------</a>
<a name="ln205">//   linkedClone</a>
<a name="ln206">//---------------------------------------------------------</a>
<a name="ln207"> </a>
<a name="ln208">Element* Element::linkedClone()</a>
<a name="ln209">      {</a>
<a name="ln210">      Element* e = clone();</a>
<a name="ln211">      e-&gt;setAutoplace(true);</a>
<a name="ln212">      score()-&gt;undo(new Link(e, this));</a>
<a name="ln213">      return e;</a>
<a name="ln214">      }</a>
<a name="ln215"> </a>
<a name="ln216">//---------------------------------------------------------</a>
<a name="ln217">//   scanElements</a>
<a name="ln218">//---------------------------------------------------------</a>
<a name="ln219"> </a>
<a name="ln220">void Element::scanElements(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln221">      {</a>
<a name="ln222">      if (all || visible() || score()-&gt;showInvisible())</a>
<a name="ln223">            func(data, this);</a>
<a name="ln224">      }</a>
<a name="ln225"> </a>
<a name="ln226">//---------------------------------------------------------</a>
<a name="ln227">//   reset</a>
<a name="ln228">//---------------------------------------------------------</a>
<a name="ln229"> </a>
<a name="ln230">void Element::reset()</a>
<a name="ln231">      {</a>
<a name="ln232">      undoResetProperty(Pid::AUTOPLACE);</a>
<a name="ln233">      undoResetProperty(Pid::PLACEMENT);</a>
<a name="ln234">      undoResetProperty(Pid::MIN_DISTANCE);</a>
<a name="ln235">      undoResetProperty(Pid::OFFSET);</a>
<a name="ln236">      setOffsetChanged(false);</a>
<a name="ln237">      ScoreElement::reset();</a>
<a name="ln238">      }</a>
<a name="ln239"> </a>
<a name="ln240">//---------------------------------------------------------</a>
<a name="ln241">//   change</a>
<a name="ln242">//---------------------------------------------------------</a>
<a name="ln243"> </a>
<a name="ln244">void Element::change(Element* o, Element* n)</a>
<a name="ln245">      {</a>
<a name="ln246">      remove(o);</a>
<a name="ln247">      add(n);</a>
<a name="ln248">      }</a>
<a name="ln249"> </a>
<a name="ln250">//---------------------------------------------------------</a>
<a name="ln251">//   staff</a>
<a name="ln252">//---------------------------------------------------------</a>
<a name="ln253"> </a>
<a name="ln254">Staff* Element::staff() const</a>
<a name="ln255">      {</a>
<a name="ln256">      if (_track == -1 || score()-&gt;staves().empty())</a>
<a name="ln257">            return 0;</a>
<a name="ln258"> </a>
<a name="ln259">      return score()-&gt;staff(_track &gt;&gt; 2);</a>
<a name="ln260">      }</a>
<a name="ln261"> </a>
<a name="ln262">//---------------------------------------------------------</a>
<a name="ln263">//   staffType</a>
<a name="ln264">//---------------------------------------------------------</a>
<a name="ln265"> </a>
<a name="ln266">StaffType* Element::staffType() const</a>
<a name="ln267">      {</a>
<a name="ln268">      Staff* s = staff();</a>
<a name="ln269">      return s ? s-&gt;staffType(tick()) : 0;</a>
<a name="ln270">      }</a>
<a name="ln271"> </a>
<a name="ln272">//---------------------------------------------------------</a>
<a name="ln273">//   z</a>
<a name="ln274">//---------------------------------------------------------</a>
<a name="ln275"> </a>
<a name="ln276">int Element::z() const</a>
<a name="ln277">      {</a>
<a name="ln278">      if (_z == -1)</a>
<a name="ln279">            _z = int(type()) * 100;</a>
<a name="ln280">      return _z;</a>
<a name="ln281">      }</a>
<a name="ln282"> </a>
<a name="ln283">//---------------------------------------------------------</a>
<a name="ln284">//   tick</a>
<a name="ln285">//---------------------------------------------------------</a>
<a name="ln286"> </a>
<a name="ln287">Fraction Element::tick() const</a>
<a name="ln288">      {</a>
<a name="ln289">      const Element* e = this;</a>
<a name="ln290">      while (e-&gt;parent()) {</a>
<a name="ln291">            if (e-&gt;parent()-&gt;isSegment())</a>
<a name="ln292">                  return toSegment(e-&gt;parent())-&gt;tick();</a>
<a name="ln293">            else if (e-&gt;parent()-&gt;isMeasureBase())</a>
<a name="ln294">                  return toMeasureBase(e-&gt;parent())-&gt;tick();</a>
<a name="ln295">            e = e-&gt;parent();</a>
<a name="ln296">            }</a>
<a name="ln297">      return Fraction(0, 1);</a>
<a name="ln298">      }</a>
<a name="ln299"> </a>
<a name="ln300">//---------------------------------------------------------</a>
<a name="ln301">//   rtick</a>
<a name="ln302">//---------------------------------------------------------</a>
<a name="ln303"> </a>
<a name="ln304">Fraction Element::rtick() const</a>
<a name="ln305">      {</a>
<a name="ln306">      const Element* e = this;</a>
<a name="ln307">      while (e-&gt;parent()) {</a>
<a name="ln308">            if (e-&gt;parent()-&gt;isSegment())</a>
<a name="ln309">                  return toSegment(e-&gt;parent())-&gt;rtick();</a>
<a name="ln310">            e = e-&gt;parent();</a>
<a name="ln311">            }</a>
<a name="ln312">      return Fraction(0, 1);</a>
<a name="ln313">      }</a>
<a name="ln314"> </a>
<a name="ln315">//---------------------------------------------------------</a>
<a name="ln316">//   part</a>
<a name="ln317">//---------------------------------------------------------</a>
<a name="ln318"> </a>
<a name="ln319">Part* Element::part() const</a>
<a name="ln320">      {</a>
<a name="ln321">      Staff* s = staff();</a>
<a name="ln322">      return s ? s-&gt;part() : 0;</a>
<a name="ln323">      }</a>
<a name="ln324"> </a>
<a name="ln325">//---------------------------------------------------------</a>
<a name="ln326">//   curColor</a>
<a name="ln327">//---------------------------------------------------------</a>
<a name="ln328"> </a>
<a name="ln329">QColor Element::curColor() const</a>
<a name="ln330">      {</a>
<a name="ln331">      return curColor(visible());</a>
<a name="ln332">      }</a>
<a name="ln333"> </a>
<a name="ln334">//---------------------------------------------------------</a>
<a name="ln335">//   curColor</a>
<a name="ln336">//---------------------------------------------------------</a>
<a name="ln337"> </a>
<a name="ln338">QColor Element::curColor(bool isVisible) const</a>
<a name="ln339">      {</a>
<a name="ln340">      return curColor(isVisible, color());</a>
<a name="ln341">      }</a>
<a name="ln342"> </a>
<a name="ln343">QColor Element::curColor(bool isVisible, QColor normalColor) const</a>
<a name="ln344">      {</a>
<a name="ln345">      // the default element color is always interpreted as black in</a>
<a name="ln346">      // printing</a>
<a name="ln347">      if (score() &amp;&amp; score()-&gt;printing())</a>
<a name="ln348">            return (normalColor == MScore::defaultColor) ? Qt::black : normalColor;</a>
<a name="ln349"> </a>
<a name="ln350">      if (flag(ElementFlag::DROP_TARGET))</a>
<a name="ln351">            return MScore::dropColor;</a>
<a name="ln352">      bool marked = false;</a>
<a name="ln353">      if (isNote()) {</a>
<a name="ln354">            //const Note* note = static_cast&lt;const Note*&gt;(this);</a>
<a name="ln355">            marked = toNote(this)-&gt;mark();</a>
<a name="ln356">            }</a>
<a name="ln357">      if (selected() || marked ) {</a>
<a name="ln358">            QColor originalColor;</a>
<a name="ln359">            if (track() == -1)</a>
<a name="ln360">                  originalColor = MScore::selectColor[0];</a>
<a name="ln361">            else</a>
<a name="ln362">                  originalColor = MScore::selectColor[voice()];</a>
<a name="ln363">            if (isVisible)</a>
<a name="ln364">                  return originalColor;</a>
<a name="ln365">            else {</a>
<a name="ln366">                  int red = originalColor.red();</a>
<a name="ln367">                  int green = originalColor.green();</a>
<a name="ln368">                  int blue = originalColor.blue();</a>
<a name="ln369">                  float tint = .6f;  // Between 0 and 1. Higher means lighter, lower means darker</a>
<a name="ln370">                  return QColor(red + tint * (255 - red), green + tint * (255 - green), blue + tint * (255 - blue));</a>
<a name="ln371">                  }</a>
<a name="ln372">            }</a>
<a name="ln373">      if (!isVisible)</a>
<a name="ln374">            return Qt::gray;</a>
<a name="ln375">      return normalColor;</a>
<a name="ln376">      }</a>
<a name="ln377"> </a>
<a name="ln378">//---------------------------------------------------------</a>
<a name="ln379">//   pagePos</a>
<a name="ln380">//    return position in canvas coordinates</a>
<a name="ln381">//---------------------------------------------------------</a>
<a name="ln382"> </a>
<a name="ln383">QPointF Element::pagePos() const</a>
<a name="ln384">      {</a>
<a name="ln385">      QPointF p(pos());</a>
<a name="ln386">      if (parent() == 0)</a>
<a name="ln387">            return p;</a>
<a name="ln388"> </a>
<a name="ln389">      if (_flags &amp; ElementFlag::ON_STAFF) {</a>
<a name="ln390">            System* system = 0;</a>
<a name="ln391">            Measure* measure = 0;</a>
<a name="ln392">            if (parent()-&gt;isSegment())</a>
<a name="ln393">                  measure = toSegment(parent())-&gt;measure();</a>
<a name="ln394">            else if (parent()-&gt;isMeasure())           // used in measure number</a>
<a name="ln395">                  measure = toMeasure(parent());</a>
<a name="ln396">            else if (parent()-&gt;isSystem())</a>
<a name="ln397">                  system = toSystem(parent());</a>
<a name="ln398">            else if (parent()-&gt;isFretDiagram())</a>
<a name="ln399">                  return p + parent()-&gt;pagePos();</a>
<a name="ln400">            else</a>
<a name="ln401">                  qFatal(&quot;this %s parent %s\n&quot;, name(), parent()-&gt;name());</a>
<a name="ln402">            if (measure) {</a>
<a name="ln403">                  system = measure-&gt;system();</a>
<a name="ln404">                  p.ry() += measure-&gt;staffLines(vStaffIdx())-&gt;y();</a>
<a name="ln405">                  }</a>
<a name="ln406">            if (system) {</a>
<a name="ln407">                  if (system-&gt;staves()-&gt;size() &lt;= vStaffIdx()) {</a>
<a name="ln408">                        qDebug(&quot;staffIdx out of bounds: %s&quot;, name());</a>
<a name="ln409">                        }</a>
<a name="ln410">                  p.ry() += system-&gt;staffYpage(vStaffIdx());</a>
<a name="ln411">                  }</a>
<a name="ln412">            p.rx() = pageX();</a>
<a name="ln413">            }</a>
<a name="ln414">      else {</a>
<a name="ln415">            if (parent()-&gt;parent())</a>
<a name="ln416">                  p += parent()-&gt;pagePos();</a>
<a name="ln417">            }</a>
<a name="ln418">      return p;</a>
<a name="ln419">      }</a>
<a name="ln420"> </a>
<a name="ln421"> </a>
<a name="ln422">//---------------------------------------------------------</a>
<a name="ln423">//   canvasPos</a>
<a name="ln424">//---------------------------------------------------------</a>
<a name="ln425"> </a>
<a name="ln426">QPointF Element::canvasPos() const</a>
<a name="ln427">      {</a>
<a name="ln428">      QPointF p(pos());</a>
<a name="ln429">      if (parent() == nullptr)</a>
<a name="ln430">            return p;</a>
<a name="ln431"> </a>
<a name="ln432">      if (_flags &amp; ElementFlag::ON_STAFF) {</a>
<a name="ln433">            System* system = nullptr;</a>
<a name="ln434">            Measure* measure = nullptr;</a>
<a name="ln435">            if (parent()-&gt;isSegment())</a>
<a name="ln436">                  measure = toSegment(parent())-&gt;measure();</a>
<a name="ln437">            else if (parent()-&gt;isMeasure())     // used in measure number</a>
<a name="ln438">                  measure = toMeasure(parent());</a>
<a name="ln439">                  // system = toMeasure(parent())-&gt;system();</a>
<a name="ln440">            else if (parent()-&gt;isSystem())</a>
<a name="ln441">                  system = toSystem(parent());</a>
<a name="ln442">            else if (parent()-&gt;isChord())       // grace chord</a>
<a name="ln443">                  measure = toSegment(parent()-&gt;parent())-&gt;measure();</a>
<a name="ln444">            else if (parent()-&gt;isFretDiagram())</a>
<a name="ln445">                  return p + parent()-&gt;canvasPos();</a>
<a name="ln446">            else</a>
<a name="ln447">                  qFatal(&quot;this %s parent %s\n&quot;, name(), parent()-&gt;name());</a>
<a name="ln448">            if (measure) {</a>
<a name="ln449">                  p.ry() += measure-&gt;staffLines(vStaffIdx())-&gt;y();</a>
<a name="ln450">                  system = measure-&gt;system();</a>
<a name="ln451">                  if (system) {</a>
<a name="ln452">                        Page* page = system-&gt;page();</a>
<a name="ln453">                        if (page)</a>
<a name="ln454">                              p.ry() += page-&gt;y();</a>
<a name="ln455">                        }</a>
<a name="ln456">                  }</a>
<a name="ln457">            if (system)</a>
<a name="ln458">                  p.ry() += system-&gt;staffYpage(vStaffIdx());</a>
<a name="ln459">            p.rx() = canvasX();</a>
<a name="ln460">            }</a>
<a name="ln461">      else</a>
<a name="ln462">            p += parent()-&gt;canvasPos();</a>
<a name="ln463">      return p;</a>
<a name="ln464">      }</a>
<a name="ln465"> </a>
<a name="ln466">//---------------------------------------------------------</a>
<a name="ln467">//   pageX</a>
<a name="ln468">//---------------------------------------------------------</a>
<a name="ln469"> </a>
<a name="ln470">qreal Element::pageX() const</a>
<a name="ln471">      {</a>
<a name="ln472">      qreal xp = x();</a>
<a name="ln473">      for (Element* e = parent(); e &amp;&amp; e-&gt;parent(); e = e-&gt;parent())</a>
<a name="ln474">            xp += e-&gt;x();</a>
<a name="ln475">      return xp;</a>
<a name="ln476">      }</a>
<a name="ln477"> </a>
<a name="ln478">//---------------------------------------------------------</a>
<a name="ln479">//    canvasX</a>
<a name="ln480">//---------------------------------------------------------</a>
<a name="ln481"> </a>
<a name="ln482">qreal Element::canvasX() const</a>
<a name="ln483">      {</a>
<a name="ln484">      qreal xp = x();</a>
<a name="ln485">      for (Element* e = parent(); e; e = e-&gt;parent())</a>
<a name="ln486">            xp += e-&gt;x();</a>
<a name="ln487">      return xp;</a>
<a name="ln488">      }</a>
<a name="ln489"> </a>
<a name="ln490">//---------------------------------------------------------</a>
<a name="ln491">//   contains</a>
<a name="ln492">//    Return true if p is inside the shape of the object.</a>
<a name="ln493">//    Note: p is in page coordinates</a>
<a name="ln494">//---------------------------------------------------------</a>
<a name="ln495"> </a>
<a name="ln496">bool Element::contains(const QPointF&amp; p) const</a>
<a name="ln497">      {</a>
<a name="ln498">      return shape().contains(p - pagePos());</a>
<a name="ln499">      }</a>
<a name="ln500"> </a>
<a name="ln501">//---------------------------------------------------------</a>
<a name="ln502">//  intersects</a>
<a name="ln503">//    Return true if \a rr intersects bounding box of object.</a>
<a name="ln504">//    Note: \a rr is in page coordinates</a>
<a name="ln505">//---------------------------------------------------------</a>
<a name="ln506"> </a>
<a name="ln507">bool Element::intersects(const QRectF&amp; rr) const</a>
<a name="ln508">      {</a>
<a name="ln509">      return shape().intersects(rr.translated(-pagePos()));</a>
<a name="ln510">      }</a>
<a name="ln511"> </a>
<a name="ln512">//---------------------------------------------------------</a>
<a name="ln513">//   writeProperties</a>
<a name="ln514">//---------------------------------------------------------</a>
<a name="ln515"> </a>
<a name="ln516">void Element::writeProperties(XmlWriter&amp; xml) const</a>
<a name="ln517">      {</a>
<a name="ln518">      bool autoplaceEnabled = score()-&gt;styleB(Sid::autoplaceEnabled);</a>
<a name="ln519">      if (!autoplaceEnabled) {</a>
<a name="ln520">            score()-&gt;setStyleValue(Sid::autoplaceEnabled, true);</a>
<a name="ln521">            writeProperty(xml, Pid::AUTOPLACE);</a>
<a name="ln522">            score()-&gt;setStyleValue(Sid::autoplaceEnabled, autoplaceEnabled);</a>
<a name="ln523">            }</a>
<a name="ln524">      else {</a>
<a name="ln525">            writeProperty(xml, Pid::AUTOPLACE);</a>
<a name="ln526">            }</a>
<a name="ln527"> </a>
<a name="ln528">      // copy paste should not keep links</a>
<a name="ln529">      if (_links &amp;&amp; (_links-&gt;size() &gt; 1) &amp;&amp; !xml.clipboardmode()) {</a>
<a name="ln530">            if (MScore::debugMode)</a>
<a name="ln531">                  xml.tag(&quot;lid&quot;, _links-&gt;lid());</a>
<a name="ln532">            Element* me = static_cast&lt;Element*&gt;(_links-&gt;mainElement());</a>
<a name="ln533">            Q_ASSERT(type() == me-&gt;type());</a>
<a name="ln534">            Staff* s = staff();</a>
<a name="ln535">            if (!s) {</a>
<a name="ln536">                  s = score()-&gt;staff(xml.curTrack() / VOICES);</a>
<a name="ln537">                  if (!s)</a>
<a name="ln538">                        qWarning(&quot;Element::writeProperties: linked element's staff not found (%s)&quot;, name());</a>
<a name="ln539">                  }</a>
<a name="ln540">            Location loc = Location::positionForElement(this);</a>
<a name="ln541">            if (me == this) {</a>
<a name="ln542">                  xml.tagE(&quot;linkedMain&quot;);</a>
<a name="ln543">                  xml.setLidLocalIndex(_links-&gt;lid(), xml.assignLocalIndex(loc));</a>
<a name="ln544">                  }</a>
<a name="ln545">            else {</a>
<a name="ln546">                  if (s-&gt;links()) {</a>
<a name="ln547">                        Staff* linkedStaff = toStaff(s-&gt;links()-&gt;mainElement());</a>
<a name="ln548">                        loc.setStaff(linkedStaff-&gt;idx());</a>
<a name="ln549">                        }</a>
<a name="ln550">                  xml.stag(&quot;linked&quot;);</a>
<a name="ln551">                  if (!me-&gt;score()-&gt;isMaster()) {</a>
<a name="ln552">                        if (me-&gt;score() == score()) {</a>
<a name="ln553">                              xml.tag(&quot;score&quot;, &quot;same&quot;);</a>
<a name="ln554">                              }</a>
<a name="ln555">                        else {</a>
<a name="ln556">                              qWarning(&quot;Element::writeProperties: linked elements belong to different scores but none of them is master score: (%s lid=%d)&quot;, name(), _links-&gt;lid());</a>
<a name="ln557">                              }</a>
<a name="ln558">                        }</a>
<a name="ln559">                  Location mainLoc = Location::positionForElement(me);</a>
<a name="ln560">                  const int guessedLocalIndex = xml.assignLocalIndex(mainLoc);</a>
<a name="ln561">                  if (loc != mainLoc) {</a>
<a name="ln562">                        mainLoc.toRelative(loc);</a>
<a name="ln563">                        mainLoc.write(xml);</a>
<a name="ln564">                        }</a>
<a name="ln565">                  const int indexDiff = xml.lidLocalIndex(_links-&gt;lid()) - guessedLocalIndex;</a>
<a name="ln566">                  xml.tag(&quot;indexDiff&quot;, indexDiff, 0);</a>
<a name="ln567">                  xml.etag(); // &lt;/linked&gt;</a>
<a name="ln568">                  }</a>
<a name="ln569">            }</a>
<a name="ln570">      if ((xml.writeTrack() || track() != xml.curTrack())</a>
<a name="ln571">         &amp;&amp; (track() != -1) &amp;&amp; !isBeam()) {</a>
<a name="ln572">            // Writing track number for beams is redundant as it is calculated</a>
<a name="ln573">            // during layout.</a>
<a name="ln574">            int t = track() + xml.trackDiff();</a>
<a name="ln575">            xml.tag(&quot;track&quot;, t);</a>
<a name="ln576">            }</a>
<a name="ln577">      if (xml.writePosition())</a>
<a name="ln578">            xml.tag(Pid::POSITION, rtick());</a>
<a name="ln579">      if (_tag != 0x1) {</a>
<a name="ln580">            for (int i = 1; i &lt; MAX_TAGS; i++) {</a>
<a name="ln581">                  if (_tag == ((unsigned)1 &lt;&lt; i)) {</a>
<a name="ln582">                        xml.tag(&quot;tag&quot;, score()-&gt;layerTags()[i]);</a>
<a name="ln583">                        break;</a>
<a name="ln584">                        }</a>
<a name="ln585">                  }</a>
<a name="ln586">            }</a>
<a name="ln587">      for (Pid pid : { Pid::OFFSET, Pid::COLOR, Pid::VISIBLE, Pid::Z, Pid::PLACEMENT}) {</a>
<a name="ln588">            if (propertyFlags(pid) == PropertyFlags::NOSTYLE)</a>
<a name="ln589">                  writeProperty(xml, pid);</a>
<a name="ln590">            }</a>
<a name="ln591">      }</a>
<a name="ln592"> </a>
<a name="ln593">//---------------------------------------------------------</a>
<a name="ln594">//   readProperties</a>
<a name="ln595">//---------------------------------------------------------</a>
<a name="ln596"> </a>
<a name="ln597">bool Element::readProperties(XmlReader&amp; e)</a>
<a name="ln598">      {</a>
<a name="ln599">      const QStringRef&amp; tag(e.name());</a>
<a name="ln600"> </a>
<a name="ln601">      if (readProperty(tag, e, Pid::SIZE_SPATIUM_DEPENDENT))</a>
<a name="ln602">            ;</a>
<a name="ln603">      else if (readProperty(tag, e, Pid::OFFSET))</a>
<a name="ln604">            ;</a>
<a name="ln605">      else if (readProperty(tag, e, Pid::MIN_DISTANCE))</a>
<a name="ln606">            ;</a>
<a name="ln607">      else if (readProperty(tag, e, Pid::AUTOPLACE))</a>
<a name="ln608">            ;</a>
<a name="ln609">      else if (tag == &quot;track&quot;)</a>
<a name="ln610">            setTrack(e.readInt() + e.trackOffset());</a>
<a name="ln611">      else if (tag == &quot;color&quot;)</a>
<a name="ln612">            setColor(e.readColor());</a>
<a name="ln613">      else if (tag == &quot;visible&quot;)</a>
<a name="ln614">            setVisible(e.readInt());</a>
<a name="ln615">      else if (tag == &quot;selected&quot;) // obsolete</a>
<a name="ln616">            e.readInt();</a>
<a name="ln617">      else if ((tag == &quot;linked&quot;) || (tag == &quot;linkedMain&quot;)) {</a>
<a name="ln618">            Staff* s = staff();</a>
<a name="ln619">            if (!s) {</a>
<a name="ln620">                  s = score()-&gt;staff(e.track() / VOICES);</a>
<a name="ln621">                  if (!s) {</a>
<a name="ln622">                        qWarning(&quot;Element::readProperties: linked element's staff not found (%s)&quot;, name());</a>
<a name="ln623">                        e.skipCurrentElement();</a>
<a name="ln624">                        return true;</a>
<a name="ln625">                        }</a>
<a name="ln626">                  }</a>
<a name="ln627">            if (tag == &quot;linkedMain&quot;) {</a>
<a name="ln628">                  _links = new LinkedElements(score());</a>
<a name="ln629">                  _links-&gt;push_back(this);</a>
<a name="ln630">                  e.addLink(s, _links);</a>
<a name="ln631">                  e.readNext();</a>
<a name="ln632">                  }</a>
<a name="ln633">            else {</a>
<a name="ln634">                  Staff* ls = s-&gt;links() ? toStaff(s-&gt;links()-&gt;mainElement()) : nullptr;</a>
<a name="ln635">                  bool linkedIsMaster = ls ? ls-&gt;score()-&gt;isMaster() : false;</a>
<a name="ln636">                  Location loc = e.location(true);</a>
<a name="ln637">                  if (ls)</a>
<a name="ln638">                        loc.setStaff(ls-&gt;idx());</a>
<a name="ln639">                  Location mainLoc = Location::relative();</a>
<a name="ln640">                  bool locationRead = false;</a>
<a name="ln641">                  int localIndexDiff = 0;</a>
<a name="ln642">                  while (e.readNextStartElement()) {</a>
<a name="ln643">                        const QStringRef&amp; ntag(e.name());</a>
<a name="ln644"> </a>
<a name="ln645">                        if (ntag == &quot;score&quot;) {</a>
<a name="ln646">                              QString val(e.readElementText());</a>
<a name="ln647">                              if (val == &quot;same&quot;)</a>
<a name="ln648">                                    linkedIsMaster = score()-&gt;isMaster();</a>
<a name="ln649">                              }</a>
<a name="ln650">                        else if (ntag == &quot;location&quot;) {</a>
<a name="ln651">                              mainLoc.read(e);</a>
<a name="ln652">                              mainLoc.toAbsolute(loc);</a>
<a name="ln653">                              locationRead = true;</a>
<a name="ln654">                              }</a>
<a name="ln655">                        else if (ntag == &quot;indexDiff&quot;)</a>
<a name="ln656">                              localIndexDiff = e.readInt();</a>
<a name="ln657">                        else</a>
<a name="ln658">                              e.unknown();</a>
<a name="ln659">                        }</a>
<a name="ln660">                  if (!locationRead)</a>
<a name="ln661">                        mainLoc = loc;</a>
<a name="ln662">                  LinkedElements* link = e.getLink(linkedIsMaster, mainLoc, localIndexDiff);</a>
<a name="ln663">                  if (link) {</a>
<a name="ln664">                        ScoreElement* linked = link-&gt;mainElement();</a>
<a name="ln665">                        if (linked-&gt;type() == type())</a>
<a name="ln666">                              linkTo(linked);</a>
<a name="ln667">                        else</a>
<a name="ln668">                              qWarning(&quot;Element::readProperties: linked elements have different types: %s, %s. Input file corrupted?&quot;, name(), linked-&gt;name());</a>
<a name="ln669">                        }</a>
<a name="ln670">                  if (!_links)</a>
<a name="ln671">                        qWarning(&quot;Element::readProperties: could not link %s at staff %d&quot;, name(), mainLoc.staff() + 1);</a>
<a name="ln672">                  }</a>
<a name="ln673">            }</a>
<a name="ln674">      else if (tag == &quot;lid&quot;) {</a>
<a name="ln675">            if (score()-&gt;mscVersion() &gt;= 301) {</a>
<a name="ln676">                  e.skipCurrentElement();</a>
<a name="ln677">                  return true;</a>
<a name="ln678">                  }</a>
<a name="ln679">            int id = e.readInt();</a>
<a name="ln680">            _links = e.linkIds().value(id);</a>
<a name="ln681">            if (!_links) {</a>
<a name="ln682">                  if (!score()-&gt;isMaster())   // DEBUG</a>
<a name="ln683">                        qDebug(&quot;---link %d not found (%d)&quot;, id, e.linkIds().size());</a>
<a name="ln684">                  _links = new LinkedElements(score(), id);</a>
<a name="ln685">                  e.linkIds().insert(id, _links);</a>
<a name="ln686">                  }</a>
<a name="ln687">#ifndef NDEBUG</a>
<a name="ln688">            else {</a>
<a name="ln689">                  for (ScoreElement* eee : *_links) {</a>
<a name="ln690">                        Element* ee = static_cast&lt;Element*&gt;(eee);</a>
<a name="ln691">                        if (ee-&gt;type() != type()) {</a>
<a name="ln692">                              qFatal(&quot;link %s(%d) type mismatch %s linked to %s&quot;,</a>
<a name="ln693">                                 ee-&gt;name(), id, ee-&gt;name(), name());</a>
<a name="ln694">                              }</a>
<a name="ln695">                        }</a>
<a name="ln696">                  }</a>
<a name="ln697">#endif</a>
<a name="ln698">            Q_ASSERT(!_links-&gt;contains(this));</a>
<a name="ln699">            _links-&gt;append(this);</a>
<a name="ln700">            }</a>
<a name="ln701">      else if (tag == &quot;tick&quot;) {</a>
<a name="ln702">            int val = e.readInt();</a>
<a name="ln703">            if (val &gt;= 0)</a>
<a name="ln704">                  e.setTick(Fraction::fromTicks(score()-&gt;fileDivision(val)));       // obsolete</a>
<a name="ln705">            }</a>
<a name="ln706">      else if (tag == &quot;pos&quot;)             // obsolete</a>
<a name="ln707">            readProperty(e, Pid::OFFSET);</a>
<a name="ln708">      else if (tag == &quot;voice&quot;)</a>
<a name="ln709">            setTrack((_track/VOICES)*VOICES + e.readInt());</a>
<a name="ln710">      else if (tag == &quot;tag&quot;) {</a>
<a name="ln711">            QString val(e.readElementText());</a>
<a name="ln712">            for (int i = 1; i &lt; MAX_TAGS; i++) {</a>
<a name="ln713">                  if (score()-&gt;layerTags()[i] == val) {</a>
<a name="ln714">                        _tag = 1 &lt;&lt; i;</a>
<a name="ln715">                        break;</a>
<a name="ln716">                        }</a>
<a name="ln717">                  }</a>
<a name="ln718">            }</a>
<a name="ln719">      else if (readProperty(tag, e, Pid::PLACEMENT))</a>
<a name="ln720">            ;</a>
<a name="ln721">      else if (tag == &quot;z&quot;)</a>
<a name="ln722">            setZ(e.readInt());</a>
<a name="ln723">      else</a>
<a name="ln724">            return false;</a>
<a name="ln725">      return true;</a>
<a name="ln726">      }</a>
<a name="ln727"> </a>
<a name="ln728">//---------------------------------------------------------</a>
<a name="ln729">//   write</a>
<a name="ln730">//---------------------------------------------------------</a>
<a name="ln731"> </a>
<a name="ln732">void Element::write(XmlWriter&amp; xml) const</a>
<a name="ln733">      {</a>
<a name="ln734">      xml.stag(this);</a>
<a name="ln735">      writeProperties(xml);</a>
<a name="ln736">      xml.etag();</a>
<a name="ln737">      }</a>
<a name="ln738"> </a>
<a name="ln739">//---------------------------------------------------------</a>
<a name="ln740">//   read</a>
<a name="ln741">//---------------------------------------------------------</a>
<a name="ln742"> </a>
<a name="ln743">void Element::read(XmlReader&amp; e)</a>
<a name="ln744">      {</a>
<a name="ln745">      while (e.readNextStartElement()) {</a>
<a name="ln746">            if (!readProperties(e))</a>
<a name="ln747">                  e.unknown();</a>
<a name="ln748">            }</a>
<a name="ln749">      }</a>
<a name="ln750"> </a>
<a name="ln751">//---------------------------------------------------------</a>
<a name="ln752">//   remove</a>
<a name="ln753">///   Remove \a el from the list. Return true on success.</a>
<a name="ln754">//---------------------------------------------------------</a>
<a name="ln755"> </a>
<a name="ln756">bool ElementList::remove(Element* el)</a>
<a name="ln757">      {</a>
<a name="ln758">      auto i = find(begin(), end(), el);</a>
<a name="ln759">      if (i == end())</a>
<a name="ln760">            return false;</a>
<a name="ln761">      erase(i);</a>
<a name="ln762">      return true;</a>
<a name="ln763">      }</a>
<a name="ln764"> </a>
<a name="ln765">//---------------------------------------------------------</a>
<a name="ln766">//   replace</a>
<a name="ln767">//---------------------------------------------------------</a>
<a name="ln768"> </a>
<a name="ln769">void ElementList::replace(Element* o, Element* n)</a>
<a name="ln770">      {</a>
<a name="ln771">      auto i = find(begin(), end(), o);</a>
<a name="ln772">      if (i == end()) {</a>
<a name="ln773">            qDebug(&quot;ElementList::replace: element not found&quot;);</a>
<a name="ln774">            return;</a>
<a name="ln775">            }</a>
<a name="ln776">      *i = n;</a>
<a name="ln777">      }</a>
<a name="ln778"> </a>
<a name="ln779">//---------------------------------------------------------</a>
<a name="ln780">//   write</a>
<a name="ln781">//---------------------------------------------------------</a>
<a name="ln782"> </a>
<a name="ln783">void ElementList::write(XmlWriter&amp; xml) const</a>
<a name="ln784">      {</a>
<a name="ln785">      for (const Element* e : *this)</a>
<a name="ln786">            e-&gt;write(xml);</a>
<a name="ln787">      }</a>
<a name="ln788"> </a>
<a name="ln789">//---------------------------------------------------------</a>
<a name="ln790">//   Compound</a>
<a name="ln791">//---------------------------------------------------------</a>
<a name="ln792"> </a>
<a name="ln793">Compound::Compound(Score* s)</a>
<a name="ln794">   : Element(s)</a>
<a name="ln795">      {</a>
<a name="ln796">      }</a>
<a name="ln797"> </a>
<a name="ln798">Compound::Compound(const Compound&amp; c)</a>
<a name="ln799">   : Element(c)</a>
<a name="ln800">      {</a>
<a name="ln801">      elements.clear();</a>
<a name="ln802">      foreach(Element* e, c.elements)</a>
<a name="ln803">            elements.append(e-&gt;clone());</a>
<a name="ln804">      }</a>
<a name="ln805"> </a>
<a name="ln806">//---------------------------------------------------------</a>
<a name="ln807">//   draw</a>
<a name="ln808">//---------------------------------------------------------</a>
<a name="ln809"> </a>
<a name="ln810">void Compound::draw(QPainter* painter) const</a>
<a name="ln811">      {</a>
<a name="ln812">      foreach(Element* e, elements) {</a>
<a name="ln813">            QPointF pt(e-&gt;pos());</a>
<a name="ln814">            painter-&gt;translate(pt);</a>
<a name="ln815">            e-&gt;draw(painter);</a>
<a name="ln816">            painter-&gt;translate(-pt);</a>
<a name="ln817">            }</a>
<a name="ln818">      }</a>
<a name="ln819"> </a>
<a name="ln820">//---------------------------------------------------------</a>
<a name="ln821">//   addElement</a>
<a name="ln822">//---------------------------------------------------------</a>
<a name="ln823"> </a>
<a name="ln824">/**</a>
<a name="ln825"> offset \a x and \a y are in Point units</a>
<a name="ln826">*/</a>
<a name="ln827"> </a>
<a name="ln828">void Compound::addElement(Element* e, qreal x, qreal y)</a>
<a name="ln829">      {</a>
<a name="ln830">      e-&gt;setPos(x, y);</a>
<a name="ln831">      e-&gt;setParent(this);</a>
<a name="ln832">      elements.push_back(e);</a>
<a name="ln833">      }</a>
<a name="ln834"> </a>
<a name="ln835">//---------------------------------------------------------</a>
<a name="ln836">//   layout</a>
<a name="ln837">//---------------------------------------------------------</a>
<a name="ln838"> </a>
<a name="ln839">void Compound::layout()</a>
<a name="ln840">      {</a>
<a name="ln841">      setbbox(QRectF());</a>
<a name="ln842">      for (auto i = elements.begin(); i != elements.end(); ++i) {</a>
<a name="ln843">            Element* e = *i;</a>
<a name="ln844">            e-&gt;layout();</a>
<a name="ln845">            addbbox(e-&gt;bbox().translated(e-&gt;pos()));</a>
<a name="ln846">            }</a>
<a name="ln847">      }</a>
<a name="ln848"> </a>
<a name="ln849">//---------------------------------------------------------</a>
<a name="ln850">//   setSelected</a>
<a name="ln851">//---------------------------------------------------------</a>
<a name="ln852"> </a>
<a name="ln853">void Compound::setSelected(bool f)</a>
<a name="ln854">      {</a>
<a name="ln855">      Element::setSelected(f);</a>
<a name="ln856">      for (auto i = elements.begin(); i != elements.end(); ++i)</a>
<a name="ln857">            (*i)-&gt;setSelected(f);</a>
<a name="ln858">      }</a>
<a name="ln859"> </a>
<a name="ln860">//---------------------------------------------------------</a>
<a name="ln861">//   setVisible</a>
<a name="ln862">//---------------------------------------------------------</a>
<a name="ln863"> </a>
<a name="ln864">void Compound::setVisible(bool f)</a>
<a name="ln865">      {</a>
<a name="ln866">      Element::setVisible(f);</a>
<a name="ln867">      for (auto i = elements.begin(); i != elements.end(); ++i)</a>
<a name="ln868">            (*i)-&gt;setVisible(f);</a>
<a name="ln869">      }</a>
<a name="ln870"> </a>
<a name="ln871">//---------------------------------------------------------</a>
<a name="ln872">//   clear</a>
<a name="ln873">//---------------------------------------------------------</a>
<a name="ln874"> </a>
<a name="ln875">void Compound::clear()</a>
<a name="ln876">      {</a>
<a name="ln877">      foreach(Element* e, elements) {</a>
<a name="ln878">            if (e-&gt;selected())</a>
<a name="ln879">                  score()-&gt;deselect(e);</a>
<a name="ln880">            delete e;</a>
<a name="ln881">            }</a>
<a name="ln882">      elements.clear();</a>
<a name="ln883">      }</a>
<a name="ln884"> </a>
<a name="ln885">//---------------------------------------------------------</a>
<a name="ln886">//   dump</a>
<a name="ln887">//---------------------------------------------------------</a>
<a name="ln888"> </a>
<a name="ln889">void Element::dump() const</a>
<a name="ln890">      {</a>
<a name="ln891">      qDebug(&quot;---Element: %s, pos(%4.2f,%4.2f)&quot;</a>
<a name="ln892">         &quot;\n   bbox(%g,%g,%g,%g)&quot;</a>
<a name="ln893">         &quot;\n   abox(%g,%g,%g,%g)&quot;</a>
<a name="ln894">         &quot;\n  parent: %p&quot;,</a>
<a name="ln895">         name(), ipos().x(), ipos().y(),</a>
<a name="ln896">         _bbox.x(), _bbox.y(), _bbox.width(), _bbox.height(),</a>
<a name="ln897">         abbox().x(), abbox().y(), abbox().width(), abbox().height(),</a>
<a name="ln898">         parent());</a>
<a name="ln899">      }</a>
<a name="ln900"> </a>
<a name="ln901">//---------------------------------------------------------</a>
<a name="ln902">//   mimeData</a>
<a name="ln903">//---------------------------------------------------------</a>
<a name="ln904"> </a>
<a name="ln905">QByteArray Element::mimeData(const QPointF&amp; dragOffset) const</a>
<a name="ln906">      {</a>
<a name="ln907">      QBuffer buffer;</a>
<a name="ln908">      buffer.open(QIODevice::WriteOnly);</a>
<a name="ln909">      XmlWriter xml(score(), &amp;buffer);</a>
<a name="ln910">      xml.setClipboardmode(true);</a>
<a name="ln911">      xml.stag(&quot;Element&quot;);</a>
<a name="ln912">      if (isNote())</a>
<a name="ln913">            xml.tag(&quot;duration&quot;, toNote(this)-&gt;chord()-&gt;ticks());</a>
<a name="ln914">      if (!dragOffset.isNull())</a>
<a name="ln915">            xml.tag(&quot;dragOffset&quot;, dragOffset);</a>
<a name="ln916">      write(xml);</a>
<a name="ln917">      xml.etag();</a>
<a name="ln918">      buffer.close();</a>
<a name="ln919">      return buffer.buffer();</a>
<a name="ln920">      }</a>
<a name="ln921"> </a>
<a name="ln922">//---------------------------------------------------------</a>
<a name="ln923">//   readType</a>
<a name="ln924">//    return new position of QDomElement in e</a>
<a name="ln925">//---------------------------------------------------------</a>
<a name="ln926"> </a>
<a name="ln927">ElementType Element::readType(XmlReader&amp; e, QPointF* dragOffset,</a>
<a name="ln928">   Fraction* duration)</a>
<a name="ln929">      {</a>
<a name="ln930">      while (e.readNextStartElement()) {</a>
<a name="ln931">            if (e.name() == &quot;Element&quot;)</a>
<a name="ln932">                  while (e.readNextStartElement()) {</a>
<a name="ln933">                        const QStringRef&amp; tag = e.name();</a>
<a name="ln934">                        if (tag == &quot;dragOffset&quot;)</a>
<a name="ln935">                              *dragOffset = e.readPoint();</a>
<a name="ln936">                        else if (tag == &quot;duration&quot;)</a>
<a name="ln937">                              *duration = e.readFraction();</a>
<a name="ln938">                        else {</a>
<a name="ln939">                              ElementType type = name2type(tag);</a>
<a name="ln940">                              if (type == ElementType::INVALID)</a>
<a name="ln941">                                    break;</a>
<a name="ln942">                              return type;</a>
<a name="ln943">                        }</a>
<a name="ln944">                  }</a>
<a name="ln945">            else</a>
<a name="ln946">                  e.unknown();</a>
<a name="ln947">            }</a>
<a name="ln948">      return ElementType::INVALID;</a>
<a name="ln949">      }</a>
<a name="ln950"> </a>
<a name="ln951">//---------------------------------------------------------</a>
<a name="ln952">//   readMimeData</a>
<a name="ln953">//---------------------------------------------------------</a>
<a name="ln954"> </a>
<a name="ln955">Element* Element::readMimeData(Score* score, const QByteArray&amp; data, QPointF* dragOffset, Fraction* duration)</a>
<a name="ln956">      {</a>
<a name="ln957">      XmlReader e(data);</a>
<a name="ln958">      const ElementType type = Element::readType(e, dragOffset, duration);</a>
<a name="ln959">      e.setPasteMode(true);</a>
<a name="ln960"> </a>
<a name="ln961">      if (type == ElementType::INVALID) {</a>
<a name="ln962">            qDebug(&quot;cannot read type&quot;);</a>
<a name="ln963">            return nullptr;</a>
<a name="ln964">            }</a>
<a name="ln965"> </a>
<a name="ln966">      Element* el = Element::create(type, score);</a>
<a name="ln967">      if (el)</a>
<a name="ln968">            el-&gt;read(e);</a>
<a name="ln969"> </a>
<a name="ln970">      return el;</a>
<a name="ln971">      }</a>
<a name="ln972"> </a>
<a name="ln973">//---------------------------------------------------------</a>
<a name="ln974">//   add</a>
<a name="ln975">//---------------------------------------------------------</a>
<a name="ln976"> </a>
<a name="ln977">void Element::add(Element* e)</a>
<a name="ln978">      {</a>
<a name="ln979">      qDebug(&quot;Element: cannot add %s to %s&quot;, e-&gt;name(), name());</a>
<a name="ln980">      }</a>
<a name="ln981"> </a>
<a name="ln982">//---------------------------------------------------------</a>
<a name="ln983">//   remove</a>
<a name="ln984">//---------------------------------------------------------</a>
<a name="ln985"> </a>
<a name="ln986">void Element::remove(Element* e)</a>
<a name="ln987">      {</a>
<a name="ln988">      qFatal(&quot;Element: cannot remove %s from %s&quot;, e-&gt;name(), name());</a>
<a name="ln989">      }</a>
<a name="ln990"> </a>
<a name="ln991">//---------------------------------------------------------</a>
<a name="ln992">//   create</a>
<a name="ln993">//    Element factory</a>
<a name="ln994">//---------------------------------------------------------</a>
<a name="ln995"> </a>
<a name="ln996">Element* Element::create(ElementType type, Score* score)</a>
<a name="ln997">      {</a>
<a name="ln998">      switch (type) {</a>
<a name="ln999">            case ElementType::VOLTA:             return new Volta(score);</a>
<a name="ln1000">            case ElementType::OTTAVA:            return new Ottava(score);</a>
<a name="ln1001">            case ElementType::TEXTLINE:          return new TextLine(score);</a>
<a name="ln1002">            case ElementType::NOTELINE:          return new NoteLine(score);</a>
<a name="ln1003">            case ElementType::TRILL:             return new Trill(score);</a>
<a name="ln1004">            case ElementType::LET_RING:          return new LetRing(score);</a>
<a name="ln1005">            case ElementType::VIBRATO:           return new Vibrato(score);</a>
<a name="ln1006">            case ElementType::PALM_MUTE:         return new PalmMute(score);</a>
<a name="ln1007">            case ElementType::PEDAL:             return new Pedal(score);</a>
<a name="ln1008">            case ElementType::HAIRPIN:           return new Hairpin(score);</a>
<a name="ln1009">            case ElementType::CLEF:              return new Clef(score);</a>
<a name="ln1010">            case ElementType::KEYSIG:            return new KeySig(score);</a>
<a name="ln1011">            case ElementType::TIMESIG:           return new TimeSig(score);</a>
<a name="ln1012">            case ElementType::BAR_LINE:          return new BarLine(score);</a>
<a name="ln1013">            case ElementType::SYSTEM_DIVIDER:    return new SystemDivider(score);</a>
<a name="ln1014">            case ElementType::ARPEGGIO:          return new Arpeggio(score);</a>
<a name="ln1015">            case ElementType::BREATH:            return new Breath(score);</a>
<a name="ln1016">            case ElementType::GLISSANDO:         return new Glissando(score);</a>
<a name="ln1017">            case ElementType::BRACKET:           return new Bracket(score);</a>
<a name="ln1018">            case ElementType::ARTICULATION:      return new Articulation(score);</a>
<a name="ln1019">            case ElementType::FERMATA:           return new Fermata(score);</a>
<a name="ln1020">            case ElementType::CHORDLINE:         return new ChordLine(score);</a>
<a name="ln1021">            case ElementType::ACCIDENTAL:        return new Accidental(score);</a>
<a name="ln1022">            case ElementType::DYNAMIC:           return new Dynamic(score);</a>
<a name="ln1023">            case ElementType::TEXT:              return new Text(score);</a>
<a name="ln1024">            case ElementType::MEASURE_NUMBER:    return new MeasureNumber(score);</a>
<a name="ln1025">            case ElementType::INSTRUMENT_NAME:   return new InstrumentName(score);</a>
<a name="ln1026">            case ElementType::STAFF_TEXT:        return new StaffText(score);</a>
<a name="ln1027">            case ElementType::SYSTEM_TEXT:       return new SystemText(score);</a>
<a name="ln1028">            case ElementType::REHEARSAL_MARK:    return new RehearsalMark(score);</a>
<a name="ln1029">            case ElementType::INSTRUMENT_CHANGE: return new InstrumentChange(score);</a>
<a name="ln1030">            case ElementType::STAFFTYPE_CHANGE:  return new StaffTypeChange(score);</a>
<a name="ln1031">            case ElementType::NOTEHEAD:          return new NoteHead(score);</a>
<a name="ln1032">            case ElementType::NOTEDOT:           return new NoteDot(score);</a>
<a name="ln1033">            case ElementType::TREMOLO:           return new Tremolo(score);</a>
<a name="ln1034">            case ElementType::LAYOUT_BREAK:      return new LayoutBreak(score);</a>
<a name="ln1035">            case ElementType::MARKER:            return new Marker(score);</a>
<a name="ln1036">            case ElementType::JUMP:              return new Jump(score);</a>
<a name="ln1037">            case ElementType::REPEAT_MEASURE:    return new RepeatMeasure(score);</a>
<a name="ln1038">            case ElementType::ICON:              return new Icon(score);</a>
<a name="ln1039">            case ElementType::NOTE:              return new Note(score);</a>
<a name="ln1040">            case ElementType::SYMBOL:            return new Symbol(score);</a>
<a name="ln1041">            case ElementType::FSYMBOL:           return new FSymbol(score);</a>
<a name="ln1042">            case ElementType::CHORD:             return new Chord(score);</a>
<a name="ln1043">            case ElementType::REST:              return new Rest(score);</a>
<a name="ln1044">            case ElementType::SPACER:            return new Spacer(score);</a>
<a name="ln1045">            case ElementType::STAFF_STATE:       return new StaffState(score);</a>
<a name="ln1046">            case ElementType::TEMPO_TEXT:        return new TempoText(score);</a>
<a name="ln1047">            case ElementType::HARMONY:           return new Harmony(score);</a>
<a name="ln1048">            case ElementType::FRET_DIAGRAM:      return new FretDiagram(score);</a>
<a name="ln1049">            case ElementType::BEND:              return new Bend(score);</a>
<a name="ln1050">            case ElementType::TREMOLOBAR:        return new TremoloBar(score);</a>
<a name="ln1051">            case ElementType::LYRICS:            return new Lyrics(score);</a>
<a name="ln1052">            case ElementType::FIGURED_BASS:      return new FiguredBass(score);</a>
<a name="ln1053">            case ElementType::STEM:              return new Stem(score);</a>
<a name="ln1054">            case ElementType::SLUR:              return new Slur(score);</a>
<a name="ln1055">            case ElementType::TIE:               return new Tie(score);</a>
<a name="ln1056">            case ElementType::FINGERING:          return new Fingering(score);</a>
<a name="ln1057">            case ElementType::HBOX:              return new HBox(score);</a>
<a name="ln1058">            case ElementType::VBOX:              return new VBox(score);</a>
<a name="ln1059">            case ElementType::TBOX:              return new TBox(score);</a>
<a name="ln1060">            case ElementType::FBOX:              return new FBox(score);</a>
<a name="ln1061">            case ElementType::MEASURE:           return new Measure(score);</a>
<a name="ln1062">            case ElementType::TAB_DURATION_SYMBOL: return new TabDurationSymbol(score);</a>
<a name="ln1063">            case ElementType::OSSIA:               return new Ossia(score);</a>
<a name="ln1064">            case ElementType::IMAGE:             return new Image(score);</a>
<a name="ln1065">            case ElementType::BAGPIPE_EMBELLISHMENT: return new BagpipeEmbellishment(score);</a>
<a name="ln1066">            case ElementType::AMBITUS:           return new Ambitus(score);</a>
<a name="ln1067">            case ElementType::STICKING:          return new Sticking(score);</a>
<a name="ln1068"> </a>
<a name="ln1069">            case ElementType::LYRICSLINE:</a>
<a name="ln1070">            case ElementType::TEXTLINE_BASE:</a>
<a name="ln1071">            case ElementType::TEXTLINE_SEGMENT:</a>
<a name="ln1072">            case ElementType::GLISSANDO_SEGMENT:</a>
<a name="ln1073">            case ElementType::SLUR_SEGMENT:</a>
<a name="ln1074">            case ElementType::TIE_SEGMENT:</a>
<a name="ln1075">            case ElementType::STEM_SLASH:</a>
<a name="ln1076">            case ElementType::PAGE:</a>
<a name="ln1077">            case ElementType::BEAM:</a>
<a name="ln1078">            case ElementType::HOOK:</a>
<a name="ln1079">            case ElementType::TUPLET:</a>
<a name="ln1080">            case ElementType::HAIRPIN_SEGMENT:</a>
<a name="ln1081">            case ElementType::OTTAVA_SEGMENT:</a>
<a name="ln1082">            case ElementType::TRILL_SEGMENT:</a>
<a name="ln1083">            case ElementType::LET_RING_SEGMENT:</a>
<a name="ln1084">            case ElementType::VIBRATO_SEGMENT:</a>
<a name="ln1085">            case ElementType::PALM_MUTE_SEGMENT:</a>
<a name="ln1086">            case ElementType::VOLTA_SEGMENT:</a>
<a name="ln1087">            case ElementType::PEDAL_SEGMENT:</a>
<a name="ln1088">            case ElementType::LYRICSLINE_SEGMENT:</a>
<a name="ln1089">            case ElementType::LEDGER_LINE:</a>
<a name="ln1090">            case ElementType::STAFF_LINES:</a>
<a name="ln1091">            case ElementType::SELECTION:</a>
<a name="ln1092">            case ElementType::LASSO:</a>
<a name="ln1093">            case ElementType::SHADOW_NOTE:</a>
<a name="ln1094">            case ElementType::SEGMENT:</a>
<a name="ln1095">            case ElementType::SYSTEM:</a>
<a name="ln1096">            case ElementType::COMPOUND:</a>
<a name="ln1097">            case ElementType::ELEMENT:</a>
<a name="ln1098">            case ElementType::ELEMENT_LIST:</a>
<a name="ln1099">            case ElementType::STAFF_LIST:</a>
<a name="ln1100">            case ElementType::MEASURE_LIST:</a>
<a name="ln1101">            case ElementType::MAXTYPE:</a>
<a name="ln1102">            case ElementType::INVALID:</a>
<a name="ln1103">            case ElementType::PART:</a>
<a name="ln1104">            case ElementType::STAFF:</a>
<a name="ln1105">            case ElementType::SCORE:</a>
<a name="ln1106">            case ElementType::BRACKET_ITEM:</a>
<a name="ln1107">                  break;</a>
<a name="ln1108">            }</a>
<a name="ln1109">      qDebug(&quot;cannot create type %d &lt;%s&gt;&quot;, int(type), Element::name(type));</a>
<a name="ln1110">      return 0;</a>
<a name="ln1111">      }</a>
<a name="ln1112"> </a>
<a name="ln1113">//---------------------------------------------------------</a>
<a name="ln1114">//   name2Element</a>
<a name="ln1115">//---------------------------------------------------------</a>
<a name="ln1116"> </a>
<a name="ln1117">Element* Element::name2Element(const QStringRef&amp; s, Score* sc)</a>
<a name="ln1118">      {</a>
<a name="ln1119">      ElementType type = Element::name2type(s);</a>
<a name="ln1120">      if (type == ElementType::INVALID) {</a>
<a name="ln1121">            qDebug(&quot;invalid &lt;%s&gt;\n&quot;, qPrintable(s.toString()));</a>
<a name="ln1122">            return 0;</a>
<a name="ln1123">            }</a>
<a name="ln1124">      return Element::create(type, sc);</a>
<a name="ln1125">      }</a>
<a name="ln1126"> </a>
<a name="ln1127">//---------------------------------------------------------</a>
<a name="ln1128">//   elementLessThan</a>
<a name="ln1129">//---------------------------------------------------------</a>
<a name="ln1130"> </a>
<a name="ln1131">bool elementLessThan(const Element* const e1, const Element* const e2)</a>
<a name="ln1132">      {</a>
<a name="ln1133">      if (e1-&gt;z() == e2-&gt;z()) {</a>
<a name="ln1134">            if (e1-&gt;selected())</a>
<a name="ln1135">                  return false;</a>
<a name="ln1136">            else if (e2-&gt;selected())</a>
<a name="ln1137">                  return true;</a>
<a name="ln1138">            else if (!e1-&gt;visible())</a>
<a name="ln1139">                  return true;</a>
<a name="ln1140">            else if (!e2-&gt;visible())</a>
<a name="ln1141">                  return false;</a>
<a name="ln1142">            else</a>
<a name="ln1143">                  return e1-&gt;track() &gt; e2-&gt;track();</a>
<a name="ln1144">            }</a>
<a name="ln1145">      return e1-&gt;z() &lt;= e2-&gt;z();</a>
<a name="ln1146">      }</a>
<a name="ln1147"> </a>
<a name="ln1148">//---------------------------------------------------------</a>
<a name="ln1149">//   collectElements</a>
<a name="ln1150">//---------------------------------------------------------</a>
<a name="ln1151"> </a>
<a name="ln1152">void collectElements(void* data, Element* e)</a>
<a name="ln1153">      {</a>
<a name="ln1154">      QList&lt;Element*&gt;* el = static_cast&lt;QList&lt;Element*&gt;*&gt;(data);</a>
<a name="ln1155">      el-&gt;append(e);</a>
<a name="ln1156">      }</a>
<a name="ln1157"> </a>
<a name="ln1158">//---------------------------------------------------------</a>
<a name="ln1159">//   autoplace</a>
<a name="ln1160">//---------------------------------------------------------</a>
<a name="ln1161"> </a>
<a name="ln1162">bool Element::autoplace() const</a>
<a name="ln1163">      {</a>
<a name="ln1164">      if (!score() || !score()-&gt;styleB(Sid::autoplaceEnabled))</a>
<a name="ln1165">          return false;</a>
<a name="ln1166">      return !flag(ElementFlag::NO_AUTOPLACE);</a>
<a name="ln1167">      }</a>
<a name="ln1168"> </a>
<a name="ln1169">//---------------------------------------------------------</a>
<a name="ln1170">//   getProperty</a>
<a name="ln1171">//---------------------------------------------------------</a>
<a name="ln1172"> </a>
<a name="ln1173">QVariant Element::getProperty(Pid propertyId) const</a>
<a name="ln1174">      {</a>
<a name="ln1175">      switch (propertyId) {</a>
<a name="ln1176">            case Pid::TICK:</a>
<a name="ln1177">                  return tick();</a>
<a name="ln1178">            case Pid::TRACK:</a>
<a name="ln1179">                  return track();</a>
<a name="ln1180">            case Pid::VOICE:</a>
<a name="ln1181">                  return voice();</a>
<a name="ln1182">            case Pid::POSITION:</a>
<a name="ln1183">                  return rtick();</a>
<a name="ln1184">            case Pid::GENERATED:</a>
<a name="ln1185">                  return generated();</a>
<a name="ln1186">            case Pid::COLOR:</a>
<a name="ln1187">                  return color();</a>
<a name="ln1188">            case Pid::VISIBLE:</a>
<a name="ln1189">                  return visible();</a>
<a name="ln1190">            case Pid::SELECTED:</a>
<a name="ln1191">                  return selected();</a>
<a name="ln1192">            case Pid::OFFSET:</a>
<a name="ln1193">                  return _offset;</a>
<a name="ln1194">            case Pid::MIN_DISTANCE:</a>
<a name="ln1195">                  return _minDistance;</a>
<a name="ln1196">            case Pid::PLACEMENT:</a>
<a name="ln1197">                  return int(placement());</a>
<a name="ln1198">            case Pid::AUTOPLACE:</a>
<a name="ln1199">                  return autoplace();</a>
<a name="ln1200">            case Pid::Z:</a>
<a name="ln1201">                  return z();</a>
<a name="ln1202">            case Pid::SYSTEM_FLAG:</a>
<a name="ln1203">                  return systemFlag();</a>
<a name="ln1204">            case Pid::SIZE_SPATIUM_DEPENDENT:</a>
<a name="ln1205">                  return sizeIsSpatiumDependent();</a>
<a name="ln1206">            default:</a>
<a name="ln1207">                  return QVariant();</a>
<a name="ln1208">            }</a>
<a name="ln1209">      }</a>
<a name="ln1210"> </a>
<a name="ln1211">//---------------------------------------------------------</a>
<a name="ln1212">//   setProperty</a>
<a name="ln1213">//---------------------------------------------------------</a>
<a name="ln1214"> </a>
<a name="ln1215">bool Element::setProperty(Pid propertyId, const QVariant&amp; v)</a>
<a name="ln1216">      {</a>
<a name="ln1217">      switch (propertyId) {</a>
<a name="ln1218">            case Pid::TRACK:</a>
<a name="ln1219">                  setTrack(v.toInt());</a>
<a name="ln1220">                  break;</a>
<a name="ln1221">            case Pid::VOICE:</a>
<a name="ln1222">                  setVoice(v.toInt());</a>
<a name="ln1223">                  break;</a>
<a name="ln1224">            case Pid::GENERATED:</a>
<a name="ln1225">                  setGenerated(v.toBool());</a>
<a name="ln1226">                  break;</a>
<a name="ln1227">            case Pid::COLOR:</a>
<a name="ln1228">                  setColor(v.value&lt;QColor&gt;());</a>
<a name="ln1229">                  break;</a>
<a name="ln1230">            case Pid::VISIBLE:</a>
<a name="ln1231">                  setVisible(v.toBool());</a>
<a name="ln1232">                  break;</a>
<a name="ln1233">            case Pid::SELECTED:</a>
<a name="ln1234">                  setSelected(v.toBool());</a>
<a name="ln1235">                  break;</a>
<a name="ln1236">            case Pid::OFFSET:</a>
<a name="ln1237">                  _offset = v.toPointF();</a>
<a name="ln1238">                  break;</a>
<a name="ln1239">            case Pid::MIN_DISTANCE:</a>
<a name="ln1240">                  setMinDistance(v.value&lt;Spatium&gt;());</a>
<a name="ln1241">                  break;</a>
<a name="ln1242">            case Pid::PLACEMENT:</a>
<a name="ln1243">                  setPlacement(Placement(v.toInt()));</a>
<a name="ln1244">                  break;</a>
<a name="ln1245">            case Pid::AUTOPLACE:</a>
<a name="ln1246">                  setAutoplace(v.toBool());</a>
<a name="ln1247">                  break;</a>
<a name="ln1248">            case Pid::Z:</a>
<a name="ln1249">                  setZ(v.toInt());</a>
<a name="ln1250">                  break;</a>
<a name="ln1251">            case Pid::SYSTEM_FLAG:</a>
<a name="ln1252">                  setSystemFlag(v.toBool());</a>
<a name="ln1253">                  break;</a>
<a name="ln1254">            case Pid::SIZE_SPATIUM_DEPENDENT:</a>
<a name="ln1255">                  setSizeIsSpatiumDependent(v.toBool());</a>
<a name="ln1256">                  break;</a>
<a name="ln1257">            default:</a>
<a name="ln1258">                  qDebug(&quot;%s unknown &lt;%s&gt;(%d), data &lt;%s&gt;&quot;, name(), propertyName(propertyId), int(propertyId), qPrintable(v.toString()));</a>
<a name="ln1259">                  return false;</a>
<a name="ln1260">            }</a>
<a name="ln1261">      triggerLayout();</a>
<a name="ln1262">      return true;</a>
<a name="ln1263">      }</a>
<a name="ln1264"> </a>
<a name="ln1265">//---------------------------------------------------------</a>
<a name="ln1266">//   undoChangeProperty</a>
<a name="ln1267">//---------------------------------------------------------</a>
<a name="ln1268"> </a>
<a name="ln1269">void Element::undoChangeProperty(Pid pid, const QVariant&amp; val, PropertyFlags ps)</a>
<a name="ln1270">      {</a>
<a name="ln1271">      if (pid == Pid::AUTOPLACE &amp;&amp; (val.toBool() == true &amp;&amp; !autoplace())) {</a>
<a name="ln1272">            // Switching autoplacement on. Save user-defined</a>
<a name="ln1273">            // placement properties to undo stack.</a>
<a name="ln1274">            undoPushProperty(Pid::PLACEMENT);</a>
<a name="ln1275">            undoPushProperty(Pid::OFFSET);</a>
<a name="ln1276">            }</a>
<a name="ln1277">      ScoreElement::undoChangeProperty(pid, val, ps);</a>
<a name="ln1278">      }</a>
<a name="ln1279"> </a>
<a name="ln1280">//---------------------------------------------------------</a>
<a name="ln1281">//   propertyDefault</a>
<a name="ln1282">//---------------------------------------------------------</a>
<a name="ln1283"> </a>
<a name="ln1284">QVariant Element::propertyDefault(Pid pid) const</a>
<a name="ln1285">      {</a>
<a name="ln1286">      switch (pid) {</a>
<a name="ln1287">            case Pid::GENERATED:</a>
<a name="ln1288">                  return false;</a>
<a name="ln1289">            case Pid::VISIBLE:</a>
<a name="ln1290">                  return true;</a>
<a name="ln1291">            case Pid::COLOR:</a>
<a name="ln1292">                  return MScore::defaultColor;</a>
<a name="ln1293">            case Pid::PLACEMENT: {</a>
<a name="ln1294">                  QVariant v = ScoreElement::propertyDefault(pid);</a>
<a name="ln1295">                  if (v.isValid())        // if it's a styled property</a>
<a name="ln1296">                        return v;</a>
<a name="ln1297">                  return int(Placement::BELOW);</a>
<a name="ln1298">                  }</a>
<a name="ln1299">            case Pid::SELECTED:</a>
<a name="ln1300">                  return false;</a>
<a name="ln1301">            case Pid::OFFSET: {</a>
<a name="ln1302">                  QVariant v = ScoreElement::propertyDefault(pid);</a>
<a name="ln1303">                  if (v.isValid())        // if it's a styled property</a>
<a name="ln1304">                        return v;</a>
<a name="ln1305">                  return QPointF();</a>
<a name="ln1306">                  }</a>
<a name="ln1307">            case Pid::MIN_DISTANCE: {</a>
<a name="ln1308">                  QVariant v = ScoreElement::propertyDefault(pid);</a>
<a name="ln1309">                  if (v.isValid())</a>
<a name="ln1310">                        return v;</a>
<a name="ln1311">                  return 0.0;</a>
<a name="ln1312">                  }</a>
<a name="ln1313">            case Pid::AUTOPLACE:</a>
<a name="ln1314">                  return true;</a>
<a name="ln1315">            case Pid::Z:</a>
<a name="ln1316">                  return int(type()) * 100;</a>
<a name="ln1317">            default:</a>
<a name="ln1318">                  return ScoreElement::propertyDefault(pid);</a>
<a name="ln1319">            }</a>
<a name="ln1320">      }</a>
<a name="ln1321"> </a>
<a name="ln1322">//---------------------------------------------------------</a>
<a name="ln1323">//   propertyId</a>
<a name="ln1324">//---------------------------------------------------------</a>
<a name="ln1325"> </a>
<a name="ln1326">Pid Element::propertyId(const QStringRef&amp; name) const</a>
<a name="ln1327">      {</a>
<a name="ln1328">      if (name == &quot;pos&quot; || name == &quot;offset&quot;)</a>
<a name="ln1329">            return Pid::OFFSET;</a>
<a name="ln1330">      return ScoreElement::propertyId(name);</a>
<a name="ln1331">      }</a>
<a name="ln1332"> </a>
<a name="ln1333">//---------------------------------------------------------</a>
<a name="ln1334">//   propertyUserValue</a>
<a name="ln1335">//---------------------------------------------------------</a>
<a name="ln1336"> </a>
<a name="ln1337">QString Element::propertyUserValue(Pid pid) const</a>
<a name="ln1338">      {</a>
<a name="ln1339">      switch(pid) {</a>
<a name="ln1340">            case Pid::SUBTYPE:</a>
<a name="ln1341">                  return subtypeName();</a>
<a name="ln1342">            default:</a>
<a name="ln1343">                  return ScoreElement::propertyUserValue(pid);</a>
<a name="ln1344">            }</a>
<a name="ln1345">      }</a>
<a name="ln1346"> </a>
<a name="ln1347">//---------------------------------------------------------</a>
<a name="ln1348">//   custom</a>
<a name="ln1349">//    check if property is != default</a>
<a name="ln1350">//---------------------------------------------------------</a>
<a name="ln1351"> </a>
<a name="ln1352">bool Element::custom(Pid id) const</a>
<a name="ln1353">      {</a>
<a name="ln1354">      return propertyDefault(id) != getProperty(id);</a>
<a name="ln1355">      }</a>
<a name="ln1356"> </a>
<a name="ln1357">//---------------------------------------------------------</a>
<a name="ln1358">//   isPrintable</a>
<a name="ln1359">//---------------------------------------------------------</a>
<a name="ln1360"> </a>
<a name="ln1361">bool Element::isPrintable() const</a>
<a name="ln1362">      {</a>
<a name="ln1363">      switch (type()) {</a>
<a name="ln1364">            case ElementType::PAGE:</a>
<a name="ln1365">            case ElementType::SYSTEM:</a>
<a name="ln1366">            case ElementType::MEASURE:</a>
<a name="ln1367">            case ElementType::SEGMENT:</a>
<a name="ln1368">            case ElementType::VBOX:</a>
<a name="ln1369">            case ElementType::HBOX:</a>
<a name="ln1370">            case ElementType::TBOX:</a>
<a name="ln1371">            case ElementType::FBOX:</a>
<a name="ln1372">            case ElementType::SPACER:</a>
<a name="ln1373">            case ElementType::SHADOW_NOTE:</a>
<a name="ln1374">            case ElementType::LASSO:</a>
<a name="ln1375">            case ElementType::ELEMENT_LIST:</a>
<a name="ln1376">            case ElementType::STAFF_LIST:</a>
<a name="ln1377">            case ElementType::MEASURE_LIST:</a>
<a name="ln1378">            case ElementType::SELECTION:</a>
<a name="ln1379">                  return false;</a>
<a name="ln1380">            default:</a>
<a name="ln1381">                  return true;</a>
<a name="ln1382">            }</a>
<a name="ln1383">      }</a>
<a name="ln1384"> </a>
<a name="ln1385">//---------------------------------------------------------</a>
<a name="ln1386">//   findMeasure</a>
<a name="ln1387">//---------------------------------------------------------</a>
<a name="ln1388"> </a>
<a name="ln1389">Measure* Element::findMeasure()</a>
<a name="ln1390">      {</a>
<a name="ln1391">      if (isMeasure())</a>
<a name="ln1392">            return toMeasure(this);</a>
<a name="ln1393">      else if (_parent)</a>
<a name="ln1394">            return _parent-&gt;findMeasure();</a>
<a name="ln1395">      else</a>
<a name="ln1396">            return 0;</a>
<a name="ln1397">      }</a>
<a name="ln1398"> </a>
<a name="ln1399">//---------------------------------------------------------</a>
<a name="ln1400">//   findMeasure</a>
<a name="ln1401">//---------------------------------------------------------</a>
<a name="ln1402"> </a>
<a name="ln1403">const Measure* Element::findMeasure() const</a>
<a name="ln1404">      {</a>
<a name="ln1405">      Element* e = const_cast&lt;Element*&gt;(this);</a>
<a name="ln1406">      return e-&gt;findMeasure();</a>
<a name="ln1407">      }</a>
<a name="ln1408"> </a>
<a name="ln1409">//---------------------------------------------------------</a>
<a name="ln1410">//   findMeasureBase</a>
<a name="ln1411">//---------------------------------------------------------</a>
<a name="ln1412"> </a>
<a name="ln1413">MeasureBase* Element::findMeasureBase()</a>
<a name="ln1414">      {</a>
<a name="ln1415">      if (isMeasureBase())</a>
<a name="ln1416">            return toMeasureBase(this);</a>
<a name="ln1417">      else if (_parent)</a>
<a name="ln1418">            return _parent-&gt;findMeasureBase();</a>
<a name="ln1419">      else</a>
<a name="ln1420">            return 0;</a>
<a name="ln1421">      }</a>
<a name="ln1422"> </a>
<a name="ln1423">//---------------------------------------------------------</a>
<a name="ln1424">//   findMeasureBase</a>
<a name="ln1425">//---------------------------------------------------------</a>
<a name="ln1426"> </a>
<a name="ln1427">const MeasureBase* Element::findMeasureBase() const</a>
<a name="ln1428">      {</a>
<a name="ln1429">      Element* e = const_cast&lt;Element*&gt;(this);</a>
<a name="ln1430">      return e-&gt;findMeasureBase();</a>
<a name="ln1431">      }</a>
<a name="ln1432"> </a>
<a name="ln1433">//---------------------------------------------------------</a>
<a name="ln1434">//   undoSetColor</a>
<a name="ln1435">//---------------------------------------------------------</a>
<a name="ln1436"> </a>
<a name="ln1437">void Element::undoSetColor(const QColor&amp; c)</a>
<a name="ln1438">      {</a>
<a name="ln1439">      undoChangeProperty(Pid::COLOR, c);</a>
<a name="ln1440">      }</a>
<a name="ln1441"> </a>
<a name="ln1442">//---------------------------------------------------------</a>
<a name="ln1443">//   undoSetVisible</a>
<a name="ln1444">//---------------------------------------------------------</a>
<a name="ln1445"> </a>
<a name="ln1446">void Element::undoSetVisible(bool v)</a>
<a name="ln1447">      {</a>
<a name="ln1448">      undoChangeProperty(Pid::VISIBLE, v);</a>
<a name="ln1449">      }</a>
<a name="ln1450"> </a>
<a name="ln1451">//---------------------------------------------------------</a>
<a name="ln1452">//   drawSymbol</a>
<a name="ln1453">//---------------------------------------------------------</a>
<a name="ln1454"> </a>
<a name="ln1455">void Element::drawSymbol(SymId id, QPainter* p, const QPointF&amp; o, qreal scale) const</a>
<a name="ln1456">      {</a>
<a name="ln1457">      score()-&gt;scoreFont()-&gt;draw(id, p, magS() * scale, o);</a>
<a name="ln1458">      }</a>
<a name="ln1459"> </a>
<a name="ln1460">void Element::drawSymbol(SymId id, QPainter* p, const QPointF&amp; o, int n) const</a>
<a name="ln1461">      {</a>
<a name="ln1462">      score()-&gt;scoreFont()-&gt;draw(id, p, magS(), o, n);</a>
<a name="ln1463">      }</a>
<a name="ln1464"> </a>
<a name="ln1465">void Element::drawSymbols(const std::vector&lt;SymId&gt;&amp; s, QPainter* p, const QPointF&amp; o, qreal scale) const</a>
<a name="ln1466">      {</a>
<a name="ln1467">      score()-&gt;scoreFont()-&gt;draw(s, p, magS() * scale, o);</a>
<a name="ln1468">      }</a>
<a name="ln1469"> </a>
<a name="ln1470">void Element::drawSymbols(const std::vector&lt;SymId&gt;&amp; s, QPainter* p, const QPointF&amp; o, const QSizeF&amp; scale) const</a>
<a name="ln1471">      {</a>
<a name="ln1472">      score()-&gt;scoreFont()-&gt;draw(s, p, magS() * scale, o);</a>
<a name="ln1473">      }</a>
<a name="ln1474"> </a>
<a name="ln1475">//---------------------------------------------------------</a>
<a name="ln1476">//   symHeight</a>
<a name="ln1477">//---------------------------------------------------------</a>
<a name="ln1478"> </a>
<a name="ln1479">qreal Element::symHeight(SymId id) const</a>
<a name="ln1480">      {</a>
<a name="ln1481">      return score()-&gt;scoreFont()-&gt;height(id, magS());</a>
<a name="ln1482">      }</a>
<a name="ln1483"> </a>
<a name="ln1484">//---------------------------------------------------------</a>
<a name="ln1485">//   symWidth</a>
<a name="ln1486">//---------------------------------------------------------</a>
<a name="ln1487"> </a>
<a name="ln1488">qreal Element::symWidth(SymId id) const</a>
<a name="ln1489">      {</a>
<a name="ln1490">      return score()-&gt;scoreFont()-&gt;width(id, magS());</a>
<a name="ln1491">      }</a>
<a name="ln1492">qreal Element::symWidth(const std::vector&lt;SymId&gt;&amp; s) const</a>
<a name="ln1493">      {</a>
<a name="ln1494">      return score()-&gt;scoreFont()-&gt;width(s, magS());</a>
<a name="ln1495">      }</a>
<a name="ln1496"> </a>
<a name="ln1497">//---------------------------------------------------------</a>
<a name="ln1498">//   symAdvance</a>
<a name="ln1499">//---------------------------------------------------------</a>
<a name="ln1500"> </a>
<a name="ln1501">qreal Element::symAdvance(SymId id) const</a>
<a name="ln1502">      {</a>
<a name="ln1503">      return score()-&gt;scoreFont()-&gt;advance(id, magS());</a>
<a name="ln1504">      }</a>
<a name="ln1505"> </a>
<a name="ln1506">//---------------------------------------------------------</a>
<a name="ln1507">//   symBbox</a>
<a name="ln1508">//---------------------------------------------------------</a>
<a name="ln1509"> </a>
<a name="ln1510">QRectF Element::symBbox(SymId id) const</a>
<a name="ln1511">      {</a>
<a name="ln1512">      return score()-&gt;scoreFont()-&gt;bbox(id, magS());</a>
<a name="ln1513">      }</a>
<a name="ln1514"> </a>
<a name="ln1515">QRectF Element::symBbox(const std::vector&lt;SymId&gt;&amp; s) const</a>
<a name="ln1516">      {</a>
<a name="ln1517">      return score()-&gt;scoreFont()-&gt;bbox(s, magS());</a>
<a name="ln1518">      }</a>
<a name="ln1519"> </a>
<a name="ln1520">//---------------------------------------------------------</a>
<a name="ln1521">//   symStemDownNW</a>
<a name="ln1522">//---------------------------------------------------------</a>
<a name="ln1523"> </a>
<a name="ln1524">QPointF Element::symStemDownNW(SymId id) const</a>
<a name="ln1525">      {</a>
<a name="ln1526">      return score()-&gt;scoreFont()-&gt;stemDownNW(id, magS());</a>
<a name="ln1527">      }</a>
<a name="ln1528"> </a>
<a name="ln1529">//---------------------------------------------------------</a>
<a name="ln1530">//   symStemUpSE</a>
<a name="ln1531">//---------------------------------------------------------</a>
<a name="ln1532"> </a>
<a name="ln1533">QPointF Element::symStemUpSE(SymId id) const</a>
<a name="ln1534">      {</a>
<a name="ln1535">      return score()-&gt;scoreFont()-&gt;stemUpSE(id, magS());</a>
<a name="ln1536">      }</a>
<a name="ln1537"> </a>
<a name="ln1538">//---------------------------------------------------------</a>
<a name="ln1539">//   symCutOutNE / symCutOutNW / symCutOutSE / symCutOutNW</a>
<a name="ln1540">//---------------------------------------------------------</a>
<a name="ln1541"> </a>
<a name="ln1542">QPointF Element::symCutOutNE(SymId id) const</a>
<a name="ln1543">      {</a>
<a name="ln1544">      return score()-&gt;scoreFont()-&gt;cutOutNE(id, magS());</a>
<a name="ln1545">      }</a>
<a name="ln1546"> </a>
<a name="ln1547">QPointF Element::symCutOutNW(SymId id) const</a>
<a name="ln1548">      {</a>
<a name="ln1549">      return score()-&gt;scoreFont()-&gt;cutOutNW(id, magS());</a>
<a name="ln1550">      }</a>
<a name="ln1551"> </a>
<a name="ln1552">QPointF Element::symCutOutSE(SymId id) const</a>
<a name="ln1553">      {</a>
<a name="ln1554">      return score()-&gt;scoreFont()-&gt;cutOutSE(id, magS());</a>
<a name="ln1555">      }</a>
<a name="ln1556"> </a>
<a name="ln1557">QPointF Element::symCutOutSW(SymId id) const</a>
<a name="ln1558">      {</a>
<a name="ln1559">      return score()-&gt;scoreFont()-&gt;cutOutSW(id, magS());</a>
<a name="ln1560">      }</a>
<a name="ln1561"> </a>
<a name="ln1562">//---------------------------------------------------------</a>
<a name="ln1563">//   symIsValid</a>
<a name="ln1564">//---------------------------------------------------------</a>
<a name="ln1565"> </a>
<a name="ln1566">bool Element::symIsValid(SymId id) const</a>
<a name="ln1567">      {</a>
<a name="ln1568">      return score()-&gt;scoreFont()-&gt;isValid(id);</a>
<a name="ln1569">      }</a>
<a name="ln1570"> </a>
<a name="ln1571">//---------------------------------------------------------</a>
<a name="ln1572">//   concertPitch</a>
<a name="ln1573">//---------------------------------------------------------</a>
<a name="ln1574"> </a>
<a name="ln1575">bool Element::concertPitch() const</a>
<a name="ln1576">      {</a>
<a name="ln1577">      return score()-&gt;styleB(Sid::concertPitch);</a>
<a name="ln1578">      }</a>
<a name="ln1579">//---------------------------------------------------------</a>
<a name="ln1580">//   nextElement</a>
<a name="ln1581">//   selects the next score element</a>
<a name="ln1582">//---------------------------------------------------------</a>
<a name="ln1583"> </a>
<a name="ln1584">Element* Element::nextElement()</a>
<a name="ln1585">      {</a>
<a name="ln1586">      Element* e = score()-&gt;selection().element();</a>
<a name="ln1587">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty())</a>
<a name="ln1588">            e = score()-&gt;selection().elements().first();</a>
<a name="ln1589">      if (e) {</a>
<a name="ln1590">            switch (e-&gt;type()) {</a>
<a name="ln1591">                  case ElementType::SEGMENT: {</a>
<a name="ln1592">                        Segment* s = toSegment(e);</a>
<a name="ln1593">                        return s-&gt;nextElement(staffIdx());</a>
<a name="ln1594">                        }</a>
<a name="ln1595">                  case ElementType::MEASURE: {</a>
<a name="ln1596">                        Measure* m = toMeasure(e);</a>
<a name="ln1597">                        return m-&gt;nextElementStaff(staffIdx());</a>
<a name="ln1598">                        }</a>
<a name="ln1599">                  case ElementType::CLEF:</a>
<a name="ln1600">                  case ElementType::KEYSIG:</a>
<a name="ln1601">                  case ElementType::TIMESIG:</a>
<a name="ln1602">                  case ElementType::BAR_LINE:</a>
<a name="ln1603">                        return nextSegmentElement();</a>
<a name="ln1604">                  default: {</a>
<a name="ln1605">                        return e-&gt;parent()-&gt;nextElement();</a>
<a name="ln1606">                        }</a>
<a name="ln1607">                  }</a>
<a name="ln1608">            }</a>
<a name="ln1609">      return nullptr;</a>
<a name="ln1610">      }</a>
<a name="ln1611"> </a>
<a name="ln1612"> </a>
<a name="ln1613">//---------------------------------------------------------</a>
<a name="ln1614">//   prevElement</a>
<a name="ln1615">//   selects the previous score element</a>
<a name="ln1616">//---------------------------------------------------------</a>
<a name="ln1617"> </a>
<a name="ln1618">Element* Element::prevElement()</a>
<a name="ln1619">      {</a>
<a name="ln1620">      Element* e = score()-&gt;selection().element();</a>
<a name="ln1621">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty() )</a>
<a name="ln1622">            e = score()-&gt;selection().elements().last();</a>
<a name="ln1623">      if (e) {</a>
<a name="ln1624">            switch(e-&gt;type()) {</a>
<a name="ln1625">                  case ElementType::SEGMENT: {</a>
<a name="ln1626">                        Segment* s = toSegment(e);</a>
<a name="ln1627">                        return s-&gt;prevElement(staffIdx());</a>
<a name="ln1628">                        }</a>
<a name="ln1629">                  case ElementType::MEASURE: {</a>
<a name="ln1630">                        Measure* m = toMeasure(e);</a>
<a name="ln1631">                        return m-&gt;prevElementStaff(staffIdx());</a>
<a name="ln1632">                        }</a>
<a name="ln1633">                  case ElementType::CLEF:</a>
<a name="ln1634">                  case ElementType::KEYSIG:</a>
<a name="ln1635">                  case ElementType::TIMESIG:</a>
<a name="ln1636">                  case ElementType::BAR_LINE:</a>
<a name="ln1637">                        return prevSegmentElement();</a>
<a name="ln1638">                  default: {</a>
<a name="ln1639">                        return e-&gt;parent()-&gt;prevElement();</a>
<a name="ln1640">                        }</a>
<a name="ln1641">                  }</a>
<a name="ln1642">            }</a>
<a name="ln1643">      return nullptr;</a>
<a name="ln1644">      }</a>
<a name="ln1645"> </a>
<a name="ln1646"> </a>
<a name="ln1647">//------------------------------------------------------------------------------------------</a>
<a name="ln1648">//   nextSegmentElement</a>
<a name="ln1649">//   This function is used in for the next-element command to navigate between main elements</a>
<a name="ln1650">//   of segments. (Note, Rest, Clef, Time Signature, Key Signature, Barline, Ambitus, Breath, etc.)</a>
<a name="ln1651">//   The default implementation is to look for the first such element. After it is found each</a>
<a name="ln1652">//   element knows how to find the next one and overrides this method</a>
<a name="ln1653">//------------------------------------------------------------------------------------------</a>
<a name="ln1654"> </a>
<a name="ln1655">Element* Element::nextSegmentElement()</a>
<a name="ln1656">      {</a>
<a name="ln1657">      Element* p = this;</a>
<a name="ln1658">      while (p) {</a>
<a name="ln1659">            switch (p-&gt;type()) {</a>
<a name="ln1660">                  case ElementType::NOTE:</a>
<a name="ln1661">                        if (toNote(p)-&gt;chord()-&gt;isGrace())</a>
<a name="ln1662">                              break;</a>
<a name="ln1663">                        return p;</a>
<a name="ln1664">                  case ElementType::REST:</a>
<a name="ln1665">                        return p;</a>
<a name="ln1666">                  case ElementType::CHORD: {</a>
<a name="ln1667">                        Chord* c = toChord(p);</a>
<a name="ln1668">                        if (!c-&gt;isGrace())</a>
<a name="ln1669">                              return c-&gt;notes().back();</a>
<a name="ln1670">                        }</a>
<a name="ln1671">                        break;</a>
<a name="ln1672">                  case ElementType::SEGMENT: {</a>
<a name="ln1673">                        Segment* s = toSegment(p);</a>
<a name="ln1674">                        return s-&gt;firstElement(staffIdx());</a>
<a name="ln1675">                        }</a>
<a name="ln1676">                  case ElementType::MEASURE: {</a>
<a name="ln1677">                        Measure* m = toMeasure(p);</a>
<a name="ln1678">                        return m-&gt;nextElementStaff(staffIdx());</a>
<a name="ln1679">                        }</a>
<a name="ln1680">                  case ElementType::SYSTEM: {</a>
<a name="ln1681">                        System* sys = toSystem(p);</a>
<a name="ln1682">                        return sys-&gt;nextSegmentElement();</a>
<a name="ln1683">                        }</a>
<a name="ln1684">                  default:</a>
<a name="ln1685">                        break;</a>
<a name="ln1686">                  }</a>
<a name="ln1687">            p = p-&gt;parent();</a>
<a name="ln1688">            }</a>
<a name="ln1689">      return score()-&gt;firstElement();</a>
<a name="ln1690">      }</a>
<a name="ln1691"> </a>
<a name="ln1692">//------------------------------------------------------------------------------------------</a>
<a name="ln1693">//   prevSegmentElement</a>
<a name="ln1694">//   This function is used in for the prev-element command to navigate between main elements</a>
<a name="ln1695">//   of segments. (Note, Rest, Clef, Time Signature, Key Signature, Barline, Ambitus, Breath, etc.)</a>
<a name="ln1696">//   The default implementation is to look for the first such element. After it is found each</a>
<a name="ln1697">//   element knows how to find the previous one and overrides this method</a>
<a name="ln1698">//------------------------------------------------------------------------------------------</a>
<a name="ln1699"> </a>
<a name="ln1700">Element* Element::prevSegmentElement()</a>
<a name="ln1701">      {</a>
<a name="ln1702">      Element* p = this;</a>
<a name="ln1703">      while (p) {</a>
<a name="ln1704">            switch (p-&gt;type()) {</a>
<a name="ln1705">                  case ElementType::NOTE:</a>
<a name="ln1706">                        if (toNote(p)-&gt;chord()-&gt;isGrace())</a>
<a name="ln1707">                              break;</a>
<a name="ln1708">                        return p;</a>
<a name="ln1709">                  case ElementType::REST:</a>
<a name="ln1710">                        return p;</a>
<a name="ln1711">                  case ElementType::CHORD: {</a>
<a name="ln1712">                        Chord* c = toChord(p);</a>
<a name="ln1713">                        if (!c-&gt;isGrace())</a>
<a name="ln1714">                              return c-&gt;notes().front();</a>
<a name="ln1715">                        }</a>
<a name="ln1716">                        break;</a>
<a name="ln1717">                  case ElementType::SEGMENT: {</a>
<a name="ln1718">                        Segment* s = toSegment(p);</a>
<a name="ln1719">                        return s-&gt;lastElement(staffIdx());</a>
<a name="ln1720">                        }</a>
<a name="ln1721">                  case ElementType::MEASURE: {</a>
<a name="ln1722">                        Measure* m = toMeasure(p);</a>
<a name="ln1723">                        return m-&gt;prevElementStaff(staffIdx());</a>
<a name="ln1724">                        }</a>
<a name="ln1725">                  case ElementType::SYSTEM: {</a>
<a name="ln1726">                        System* sys = toSystem(p);</a>
<a name="ln1727">                        return sys-&gt;prevSegmentElement();</a>
<a name="ln1728">                        }</a>
<a name="ln1729">                  default:</a>
<a name="ln1730">                        break;</a>
<a name="ln1731">                  }</a>
<a name="ln1732">            p = p-&gt;parent();</a>
<a name="ln1733">            }</a>
<a name="ln1734">      return score()-&gt;firstElement();</a>
<a name="ln1735">      }</a>
<a name="ln1736"> </a>
<a name="ln1737">//---------------------------------------------------------</a>
<a name="ln1738">//   accessibleInfo</a>
<a name="ln1739">//---------------------------------------------------------</a>
<a name="ln1740"> </a>
<a name="ln1741">QString Element::accessibleInfo() const</a>
<a name="ln1742">      {</a>
<a name="ln1743">      return Element::userName();</a>
<a name="ln1744">      }</a>
<a name="ln1745"> </a>
<a name="ln1746">//---------------------------------------------------------</a>
<a name="ln1747">//   nextGrip</a>
<a name="ln1748">//---------------------------------------------------------</a>
<a name="ln1749"> </a>
<a name="ln1750">bool Element::nextGrip(EditData&amp; ed) const</a>
<a name="ln1751">      {</a>
<a name="ln1752">      int i = int(ed.curGrip) + 1;</a>
<a name="ln1753">      if (i &gt;= ed.grips) {</a>
<a name="ln1754">            ed.curGrip = Grip(0);</a>
<a name="ln1755">            return false;</a>
<a name="ln1756">            }</a>
<a name="ln1757">      ed.curGrip = Grip(i);</a>
<a name="ln1758">      return true;</a>
<a name="ln1759">      }</a>
<a name="ln1760"> </a>
<a name="ln1761">//---------------------------------------------------------</a>
<a name="ln1762">//   prevGrip</a>
<a name="ln1763">//---------------------------------------------------------</a>
<a name="ln1764"> </a>
<a name="ln1765">bool Element::prevGrip(EditData&amp; ed) const</a>
<a name="ln1766">      {</a>
<a name="ln1767">      int i = int(ed.curGrip) - 1;</a>
<a name="ln1768">      if (i &lt; 0) {</a>
<a name="ln1769">            ed.curGrip = Grip(ed.grips - 1);</a>
<a name="ln1770">            return false;</a>
<a name="ln1771">            }</a>
<a name="ln1772">      ed.curGrip = Grip(i);</a>
<a name="ln1773">      return true;</a>
<a name="ln1774">      }</a>
<a name="ln1775"> </a>
<a name="ln1776">//---------------------------------------------------------</a>
<a name="ln1777">//   isUserModified</a>
<a name="ln1778">//    Check if this element was modified by user and</a>
<a name="ln1779">//    therefore must be saved.</a>
<a name="ln1780">//---------------------------------------------------------</a>
<a name="ln1781"> </a>
<a name="ln1782">bool Element::isUserModified() const</a>
<a name="ln1783">      {</a>
<a name="ln1784">      for (const StyledProperty&amp; spp : *styledProperties()) {</a>
<a name="ln1785">            Pid pid               = spp.pid;</a>
<a name="ln1786">            QVariant val          = getProperty(pid);</a>
<a name="ln1787">            QVariant defaultValue = propertyDefault(pid);</a>
<a name="ln1788"> </a>
<a name="ln1789">            if (propertyType(pid) == P_TYPE::SP_REAL) {</a>
<a name="ln1790">                  if (qAbs(val.toReal() - defaultValue.toReal()) &gt; 0.0001)    // we dont care spatium diffs that small</a>
<a name="ln1791">                        return true;</a>
<a name="ln1792">                  }</a>
<a name="ln1793">            else  {</a>
<a name="ln1794">                  if (getProperty(pid) != propertyDefault(pid))</a>
<a name="ln1795">                        return true;</a>
<a name="ln1796">                  }</a>
<a name="ln1797">            }</a>
<a name="ln1798">      for (Pid p : {Pid::VISIBLE, Pid::OFFSET, Pid::COLOR, Pid::Z, Pid::AUTOPLACE}) {</a>
<a name="ln1799">            if (getProperty(p) != propertyDefault(p))</a>
<a name="ln1800">                  return true;</a>
<a name="ln1801">            }</a>
<a name="ln1802">      return false;</a>
<a name="ln1803">      }</a>
<a name="ln1804"> </a>
<a name="ln1805">//---------------------------------------------------------</a>
<a name="ln1806">//   triggerLayout</a>
<a name="ln1807">//---------------------------------------------------------</a>
<a name="ln1808"> </a>
<a name="ln1809">void Element::triggerLayout() const</a>
<a name="ln1810">      {</a>
<a name="ln1811">      if (parent())</a>
<a name="ln1812">            score()-&gt;setLayout(tick(), staffIdx(), this);</a>
<a name="ln1813">      }</a>
<a name="ln1814"> </a>
<a name="ln1815">//---------------------------------------------------------</a>
<a name="ln1816">//   triggerLayoutAll</a>
<a name="ln1817">//---------------------------------------------------------</a>
<a name="ln1818"> </a>
<a name="ln1819">void Element::triggerLayoutAll() const</a>
<a name="ln1820">      {</a>
<a name="ln1821">      if (parent())</a>
<a name="ln1822">            score()-&gt;setLayoutAll(staffIdx(), this);</a>
<a name="ln1823">      }</a>
<a name="ln1824"> </a>
<a name="ln1825">//---------------------------------------------------------</a>
<a name="ln1826">//   control</a>
<a name="ln1827">//---------------------------------------------------------</a>
<a name="ln1828"> </a>
<a name="ln1829">bool EditData::control(bool textEditing) const</a>
<a name="ln1830">      {</a>
<a name="ln1831">      if (textEditing)</a>
<a name="ln1832">            return modifiers &amp; CONTROL_MODIFIER;</a>
<a name="ln1833">      else</a>
<a name="ln1834">            return modifiers &amp; Qt::ControlModifier;</a>
<a name="ln1835">      }</a>
<a name="ln1836"> </a>
<a name="ln1837">//---------------------------------------------------------</a>
<a name="ln1838">//   clearData</a>
<a name="ln1839">//---------------------------------------------------------</a>
<a name="ln1840"> </a>
<a name="ln1841">void EditData::clearData()</a>
<a name="ln1842">      {</a>
<a name="ln1843">      qDeleteAll(data);</a>
<a name="ln1844">      data.clear();</a>
<a name="ln1845">      }</a>
<a name="ln1846"> </a>
<a name="ln1847">//---------------------------------------------------------</a>
<a name="ln1848">//   getData</a>
<a name="ln1849">//---------------------------------------------------------</a>
<a name="ln1850"> </a>
<a name="ln1851">ElementEditData* EditData::getData(const Element* e) const</a>
<a name="ln1852">      {</a>
<a name="ln1853">      for (ElementEditData* ed : data) {</a>
<a name="ln1854">            if (ed-&gt;e == e)</a>
<a name="ln1855">                  return ed;</a>
<a name="ln1856">            }</a>
<a name="ln1857">      return 0;</a>
<a name="ln1858">      }</a>
<a name="ln1859"> </a>
<a name="ln1860">//---------------------------------------------------------</a>
<a name="ln1861">//   addData</a>
<a name="ln1862">//---------------------------------------------------------</a>
<a name="ln1863"> </a>
<a name="ln1864">void EditData::addData(ElementEditData* ed)</a>
<a name="ln1865">      {</a>
<a name="ln1866">      data.push_back(ed);</a>
<a name="ln1867">      }</a>
<a name="ln1868"> </a>
<a name="ln1869">//---------------------------------------------------------</a>
<a name="ln1870">//   drawEditMode</a>
<a name="ln1871">//---------------------------------------------------------</a>
<a name="ln1872"> </a>
<a name="ln1873">void Element::drawEditMode(QPainter* p, EditData&amp; ed)</a>
<a name="ln1874">      {</a>
<a name="ln1875">      QPen pen(MScore::defaultColor, 0.0);</a>
<a name="ln1876">      p-&gt;setPen(pen);</a>
<a name="ln1877">      for (int i = 0; i &lt; ed.grips; ++i) {</a>
<a name="ln1878">            if (Grip(i) == ed.curGrip)</a>
<a name="ln1879">                  p-&gt;setBrush(MScore::frameMarginColor);</a>
<a name="ln1880">            else</a>
<a name="ln1881">                  p-&gt;setBrush(Qt::NoBrush);</a>
<a name="ln1882">            p-&gt;drawRect(ed.grip[i]);</a>
<a name="ln1883">            }</a>
<a name="ln1884">      }</a>
<a name="ln1885"> </a>
<a name="ln1886">//---------------------------------------------------------</a>
<a name="ln1887">//   startDrag</a>
<a name="ln1888">//---------------------------------------------------------</a>
<a name="ln1889"> </a>
<a name="ln1890">void Element::startDrag(EditData&amp; ed)</a>
<a name="ln1891">      {</a>
<a name="ln1892">      if (!isMovable())</a>
<a name="ln1893">            return;</a>
<a name="ln1894">      ElementEditData* eed = new ElementEditData();</a>
<a name="ln1895">      eed-&gt;e = this;</a>
<a name="ln1896">      eed-&gt;pushProperty(Pid::OFFSET);</a>
<a name="ln1897">      eed-&gt;pushProperty(Pid::AUTOPLACE);</a>
<a name="ln1898">      ed.addData(eed);</a>
<a name="ln1899">      if (ed.modifiers &amp; Qt::AltModifier)</a>
<a name="ln1900">            setAutoplace(false);</a>
<a name="ln1901">      }</a>
<a name="ln1902"> </a>
<a name="ln1903">//---------------------------------------------------------</a>
<a name="ln1904">//   drag</a>
<a name="ln1905">///   Return update Rect relative to canvas.</a>
<a name="ln1906">//---------------------------------------------------------</a>
<a name="ln1907"> </a>
<a name="ln1908">QRectF Element::drag(EditData&amp; ed)</a>
<a name="ln1909">      {</a>
<a name="ln1910">      if (!isMovable())</a>
<a name="ln1911">            return QRectF();</a>
<a name="ln1912"> </a>
<a name="ln1913">      const QRectF r0(canvasBoundingRect());</a>
<a name="ln1914"> </a>
<a name="ln1915">      qreal x = ed.delta.x();</a>
<a name="ln1916">      qreal y = ed.delta.y();</a>
<a name="ln1917"> </a>
<a name="ln1918">      qreal _spatium = spatium();</a>
<a name="ln1919">      if (ed.hRaster) {</a>
<a name="ln1920">            qreal hRaster = _spatium / MScore::hRaster();</a>
<a name="ln1921">            int n = lrint(x / hRaster);</a>
<a name="ln1922">            x = hRaster * n;</a>
<a name="ln1923">            }</a>
<a name="ln1924">      if (ed.vRaster) {</a>
<a name="ln1925">            qreal vRaster = _spatium / MScore::vRaster();</a>
<a name="ln1926">            int n = lrint(y / vRaster);</a>
<a name="ln1927">            y = vRaster * n;</a>
<a name="ln1928">            }</a>
<a name="ln1929"> </a>
<a name="ln1930">      setOffset(QPointF(x, y));</a>
<a name="ln1931">      setOffsetChanged(true);</a>
<a name="ln1932">//      setGenerated(false);</a>
<a name="ln1933"> </a>
<a name="ln1934">      if (isTextBase()) {         // TODO: check for other types</a>
<a name="ln1935">            //</a>
<a name="ln1936">            // restrict move to page boundaries</a>
<a name="ln1937">            //</a>
<a name="ln1938">            const QRectF r(canvasBoundingRect());</a>
<a name="ln1939">            Page* p = 0;</a>
<a name="ln1940">            Element* e = this;</a>
<a name="ln1941">            while (e) {</a>
<a name="ln1942">                  if (e-&gt;isPage()) {</a>
<a name="ln1943">                        p = toPage(e);</a>
<a name="ln1944">                        break;</a>
<a name="ln1945">                        }</a>
<a name="ln1946">                  e = e-&gt;parent();</a>
<a name="ln1947">                  }</a>
<a name="ln1948">            if (p) {</a>
<a name="ln1949">                  bool move = false;</a>
<a name="ln1950">                  QRectF pr(p-&gt;canvasBoundingRect());</a>
<a name="ln1951">                  if (r.right() &gt; pr.right()) {</a>
<a name="ln1952">                        x -= r.right() - pr.right();</a>
<a name="ln1953">                        move = true;</a>
<a name="ln1954">                        }</a>
<a name="ln1955">                  else if (r.left() &lt; pr.left()) {</a>
<a name="ln1956">                        x += pr.left() - r.left();</a>
<a name="ln1957">                        move = true;</a>
<a name="ln1958">                        }</a>
<a name="ln1959">                  if (r.bottom() &gt; pr.bottom()) {</a>
<a name="ln1960">                        y -= r.bottom() - pr.bottom();</a>
<a name="ln1961">                        move = true;</a>
<a name="ln1962">                        }</a>
<a name="ln1963">                  else if (r.top() &lt; pr.top()) {</a>
<a name="ln1964">                        y += pr.top() - r.top();</a>
<a name="ln1965">                        move = true;</a>
<a name="ln1966">                        }</a>
<a name="ln1967">                  if (move)</a>
<a name="ln1968">                        setOffset(QPointF(x, y));</a>
<a name="ln1969">                  }</a>
<a name="ln1970">            }</a>
<a name="ln1971">      return canvasBoundingRect() | r0;</a>
<a name="ln1972">      }</a>
<a name="ln1973"> </a>
<a name="ln1974">//---------------------------------------------------------</a>
<a name="ln1975">//   endDrag</a>
<a name="ln1976">//---------------------------------------------------------</a>
<a name="ln1977"> </a>
<a name="ln1978">void Element::endDrag(EditData&amp; ed)</a>
<a name="ln1979">      {</a>
<a name="ln1980">      if (!isMovable())</a>
<a name="ln1981">            return;</a>
<a name="ln1982">      ElementEditData* eed = ed.getData(this);</a>
<a name="ln1983">      if (!eed)</a>
<a name="ln1984">            return;</a>
<a name="ln1985">      for (PropertyData pd : eed-&gt;propertyData) {</a>
<a name="ln1986">            setPropertyFlags(pd.id, pd.f); // reset initial property flags state</a>
<a name="ln1987">            PropertyFlags f = pd.f;</a>
<a name="ln1988">            if (f == PropertyFlags::STYLED)</a>
<a name="ln1989">                  f = PropertyFlags::UNSTYLED;</a>
<a name="ln1990">            score()-&gt;undoPropertyChanged(this, pd.id, pd.data, f);</a>
<a name="ln1991">            setGenerated(false);</a>
<a name="ln1992">            }</a>
<a name="ln1993">      }</a>
<a name="ln1994"> </a>
<a name="ln1995">//---------------------------------------------------------</a>
<a name="ln1996">//   updateGrips</a>
<a name="ln1997">//---------------------------------------------------------</a>
<a name="ln1998"> </a>
<a name="ln1999">void Element::updateGrips(EditData&amp; ed) const</a>
<a name="ln2000">      {</a>
<a name="ln2001">      const auto positions(gripsPositions(ed));</a>
<a name="ln2002">      const size_t ngrips = positions.size();</a>
<a name="ln2003">      for (int i = 0; i &lt; int(ngrips); ++i)</a>
<a name="ln2004">            ed.grip[i].translate(positions[i]);</a>
<a name="ln2005">      }</a>
<a name="ln2006"> </a>
<a name="ln2007">//---------------------------------------------------------</a>
<a name="ln2008">//   startEdit</a>
<a name="ln2009">//---------------------------------------------------------</a>
<a name="ln2010"> </a>
<a name="ln2011">void Element::startEdit(EditData&amp; ed)</a>
<a name="ln2012">      {</a>
<a name="ln2013">      ElementEditData* elementData = new ElementEditData();</a>
<a name="ln2014">      elementData-&gt;e = this;</a>
<a name="ln2015">      ed.addData(elementData);</a>
<a name="ln2016">      }</a>
<a name="ln2017"> </a>
<a name="ln2018">//---------------------------------------------------------</a>
<a name="ln2019">//   edit</a>
<a name="ln2020">//    return true if event is accepted</a>
<a name="ln2021">//---------------------------------------------------------</a>
<a name="ln2022"> </a>
<a name="ln2023">bool Element::edit(EditData&amp; ed)</a>
<a name="ln2024">      {</a>
<a name="ln2025">      if (ed.key ==  Qt::Key_Home) {</a>
<a name="ln2026">            setOffset(QPoint());</a>
<a name="ln2027">            return true;</a>
<a name="ln2028">            }</a>
<a name="ln2029">      return false;</a>
<a name="ln2030">      }</a>
<a name="ln2031"> </a>
<a name="ln2032">//---------------------------------------------------------</a>
<a name="ln2033">//   startEditDrag</a>
<a name="ln2034">//---------------------------------------------------------</a>
<a name="ln2035"> </a>
<a name="ln2036">void Element::startEditDrag(EditData&amp; ed)</a>
<a name="ln2037">      {</a>
<a name="ln2038">      ElementEditData* eed = ed.getData(this);</a>
<a name="ln2039">      if (!eed) {</a>
<a name="ln2040">            eed = new ElementEditData();</a>
<a name="ln2041">            eed-&gt;e = this;</a>
<a name="ln2042">            ed.addData(eed);</a>
<a name="ln2043">            }</a>
<a name="ln2044">      eed-&gt;pushProperty(Pid::OFFSET);</a>
<a name="ln2045">      eed-&gt;pushProperty(Pid::AUTOPLACE);</a>
<a name="ln2046">      if (ed.modifiers &amp; Qt::AltModifier)</a>
<a name="ln2047">            setAutoplace(false);</a>
<a name="ln2048">      }</a>
<a name="ln2049"> </a>
<a name="ln2050">//---------------------------------------------------------</a>
<a name="ln2051">//   editDrag</a>
<a name="ln2052">//---------------------------------------------------------</a>
<a name="ln2053"> </a>
<a name="ln2054">void Element::editDrag(EditData&amp; ed)</a>
<a name="ln2055">      {</a>
<a name="ln2056">      score()-&gt;addRefresh(canvasBoundingRect());</a>
<a name="ln2057">      setOffset(offset() + ed.delta);</a>
<a name="ln2058">      setOffsetChanged(true);</a>
<a name="ln2059">      score()-&gt;addRefresh(canvasBoundingRect());</a>
<a name="ln2060">      }</a>
<a name="ln2061"> </a>
<a name="ln2062">//---------------------------------------------------------</a>
<a name="ln2063">//   endEditDrag</a>
<a name="ln2064">//---------------------------------------------------------</a>
<a name="ln2065"> </a>
<a name="ln2066">void Element::endEditDrag(EditData&amp; ed)</a>
<a name="ln2067">      {</a>
<a name="ln2068">      ElementEditData* eed = ed.getData(this);</a>
<a name="ln2069">      bool changed = false;</a>
<a name="ln2070">      if (eed) {</a>
<a name="ln2071">            for (PropertyData pd : eed-&gt;propertyData) {</a>
<a name="ln2072">                  setPropertyFlags(pd.id, pd.f); // reset initial property flags state</a>
<a name="ln2073">                  if (score()-&gt;undoPropertyChanged(this, pd.id, pd.data))</a>
<a name="ln2074">                        changed = true;</a>
<a name="ln2075">                  }</a>
<a name="ln2076">            eed-&gt;propertyData.clear();</a>
<a name="ln2077">            }</a>
<a name="ln2078">      if (changed) {</a>
<a name="ln2079">            undoChangeProperty(Pid::GENERATED, false);</a>
<a name="ln2080">            }</a>
<a name="ln2081">      }</a>
<a name="ln2082"> </a>
<a name="ln2083">//---------------------------------------------------------</a>
<a name="ln2084">//   endEdit</a>
<a name="ln2085">//---------------------------------------------------------</a>
<a name="ln2086"> </a>
<a name="ln2087">void Element::endEdit(EditData&amp;)</a>
<a name="ln2088">      {</a>
<a name="ln2089">      }</a>
<a name="ln2090"> </a>
<a name="ln2091">//---------------------------------------------------------</a>
<a name="ln2092">//   styleP</a>
<a name="ln2093">//---------------------------------------------------------</a>
<a name="ln2094"> </a>
<a name="ln2095">qreal Element::styleP(Sid idx) const</a>
<a name="ln2096">      {</a>
<a name="ln2097">      return score()-&gt;styleP(idx);</a>
<a name="ln2098">      }</a>
<a name="ln2099"> </a>
<a name="ln2100">//---------------------------------------------------------</a>
<a name="ln2101">//   autoplaceSegmentElement</a>
<a name="ln2102">//---------------------------------------------------------</a>
<a name="ln2103"> </a>
<a name="ln2104">#if 0</a>
<a name="ln2105">void Element::autoplaceSegmentElement(qreal minDistance)</a>
<a name="ln2106">      {</a>
<a name="ln2107">      if (visible() &amp;&amp; autoplace() &amp;&amp; parent()) {</a>
<a name="ln2108">            setOffset(QPointF());</a>
<a name="ln2109">            Segment* s        = toSegment(parent());</a>
<a name="ln2110">            Measure* m        = s-&gt;measure();</a>
<a name="ln2111">            int si            = staffIdx();</a>
<a name="ln2112">            Shape s1          = m-&gt;staffShape(si);</a>
<a name="ln2113">            Shape s2          = shape().translated(s-&gt;pos() + pos());</a>
<a name="ln2114"> </a>
<a name="ln2115">            if (isTextBase()) {</a>
<a name="ln2116">                  // look for collisions in next measures</a>
<a name="ln2117">                  qreal totalWidth = m-&gt;width();</a>
<a name="ln2118">                  for (Measure* nm = m-&gt;nextMeasure(); nm; nm = nm-&gt;nextMeasure()) {</a>
<a name="ln2119">                        if (s2.right() &gt; totalWidth) {</a>
<a name="ln2120">                              s1.add(nm-&gt;staffShape(si).translated(QPointF(totalWidth, 0.0)));</a>
<a name="ln2121">                              totalWidth += nm-&gt;width();</a>
<a name="ln2122">                              }</a>
<a name="ln2123">                        else</a>
<a name="ln2124">                              break;</a>
<a name="ln2125">                        }</a>
<a name="ln2126"> </a>
<a name="ln2127">                  // look for collisions in previous measures</a>
<a name="ln2128">                  totalWidth = 0;</a>
<a name="ln2129">                  for (Measure* pm = m-&gt;prevMeasure(); pm; pm = pm-&gt;prevMeasure()) {</a>
<a name="ln2130">                        if (s2.left() &gt; totalWidth) {</a>
<a name="ln2131">                              s1.add(pm-&gt;staffShape(si).translated(QPointF(-(totalWidth + pm-&gt;width()), 0.0)));</a>
<a name="ln2132">                              totalWidth += pm-&gt;width();</a>
<a name="ln2133">                              }</a>
<a name="ln2134">                        else</a>
<a name="ln2135">                              break;</a>
<a name="ln2136">                        }</a>
<a name="ln2137"> </a>
<a name="ln2138">                  // actually check for collisions</a>
<a name="ln2139">                  bool intersection = true;</a>
<a name="ln2140">                  qreal totalYOff = 0;</a>
<a name="ln2141">                  while (intersection) {</a>
<a name="ln2142">                        intersection = false;</a>
<a name="ln2143">                        for (ShapeElement se : s1) {</a>
<a name="ln2144">                              if (s2.intersects(se)){</a>
<a name="ln2145">                                    intersection = true;</a>
<a name="ln2146">                                    break;</a>
<a name="ln2147">                                    }</a>
<a name="ln2148">                              }</a>
<a name="ln2149">                        if (! intersection)</a>
<a name="ln2150">                              break;</a>
<a name="ln2151">                        else {</a>
<a name="ln2152">                              qreal yd = -1;</a>
<a name="ln2153">                              if (placeAbove())</a>
<a name="ln2154">                                    yd = 1;</a>
<a name="ln2155">                              totalYOff -= yd;</a>
<a name="ln2156">                              s2.translateY(-yd);</a>
<a name="ln2157">                              }</a>
<a name="ln2158">                        }</a>
<a name="ln2159"> </a>
<a name="ln2160">                  // margin of 5 to stop slight overlap, hardcoded for now</a>
<a name="ln2161">                  qreal textMarginBottom = 5;</a>
<a name="ln2162">                  s2.translateY(-textMarginBottom);</a>
<a name="ln2163">                  rUserYoffset() = totalYOff - textMarginBottom;</a>
<a name="ln2164"> </a>
<a name="ln2165">                  m-&gt;staffShape(si).add(s2);</a>
<a name="ln2166"> </a>
<a name="ln2167">                  Shape s3 = s2.translated(QPointF()); // make a copy of s2</a>
<a name="ln2168">                  totalWidth = m-&gt;width();</a>
<a name="ln2169">                  for (Measure* nm = m-&gt;nextMeasure(); nm; nm = nm-&gt;nextMeasure()) {</a>
<a name="ln2170">                        if (s2.right() &gt; totalWidth) {</a>
<a name="ln2171">                              s3.translateX(-totalWidth);</a>
<a name="ln2172">                              nm-&gt;staffShape(staffIdx()).add(s3);</a>
<a name="ln2173">                              totalWidth += nm-&gt;width();</a>
<a name="ln2174">                              s3 = s2.translated(QPointF()); // reset translation</a>
<a name="ln2175">                              }</a>
<a name="ln2176">                        else</a>
<a name="ln2177">                              break;</a>
<a name="ln2178">                        }</a>
<a name="ln2179"> </a>
<a name="ln2180">                  s3 = s2.translated(QPointF());</a>
<a name="ln2181">                  totalWidth = 0;</a>
<a name="ln2182">                  for (Measure* pm = m-&gt;prevMeasure(); pm; pm = pm-&gt;prevMeasure()) {</a>
<a name="ln2183">                        if (s2.left() &gt; totalWidth) {</a>
<a name="ln2184">                              s3.translateX(totalWidth+pm-&gt;width());</a>
<a name="ln2185">                              pm-&gt;staffShape(staffIdx()).add(s3);</a>
<a name="ln2186">                              totalWidth += pm-&gt;width();</a>
<a name="ln2187">                              s3 = s2.translated(QPointF()); // reset translation</a>
<a name="ln2188">                              }</a>
<a name="ln2189">                        else</a>
<a name="ln2190">                              break;</a>
<a name="ln2191">                        }</a>
<a name="ln2192"> </a>
<a name="ln2193">                  }</a>
<a name="ln2194">            else {</a>
<a name="ln2195">                  // look for collisions in the next measure</a>
<a name="ln2196">                  // if necessary</a>
<a name="ln2197">                  bool cnm = (s2.right() &gt; m-&gt;width()) &amp;&amp; m-&gt;nextMeasure() &amp;&amp; m-&gt;nextMeasure()-&gt;system() == m-&gt;system();</a>
<a name="ln2198">                  if (cnm) {</a>
<a name="ln2199">                        Measure* nm = m-&gt;nextMeasure();</a>
<a name="ln2200">                        s1.add(nm-&gt;staffShape(si).translated(QPointF(m-&gt;width(), 0.0)));</a>
<a name="ln2201">                        }</a>
<a name="ln2202">                  qreal d = placeAbove() ? s2.minVerticalDistance(s1) : s1.minVerticalDistance(s2);</a>
<a name="ln2203">                  if (d &gt; -minDistance) {</a>
<a name="ln2204">                        qreal yd = d + minDistance;</a>
<a name="ln2205">                        if (placeAbove())</a>
<a name="ln2206">                              yd *= -1.0;</a>
<a name="ln2207">                        rUserYoffset() = yd;</a>
<a name="ln2208">                        s2.translateY(yd);</a>
<a name="ln2209">                        }</a>
<a name="ln2210">                  m-&gt;staffShape(si).add(s2);</a>
<a name="ln2211">                  if (cnm) {</a>
<a name="ln2212">                        Measure* nm = m-&gt;nextMeasure();</a>
<a name="ln2213">                        s2.translateX(-m-&gt;width());</a>
<a name="ln2214">                        nm-&gt;staffShape(staffIdx()).add(s2);</a>
<a name="ln2215">                        }</a>
<a name="ln2216">                  }</a>
<a name="ln2217">            }</a>
<a name="ln2218">      }</a>
<a name="ln2219">#endif</a>
<a name="ln2220"> </a>
<a name="ln2221">//---------------------------------------------------------</a>
<a name="ln2222">//   setOffsetChanged</a>
<a name="ln2223">//---------------------------------------------------------</a>
<a name="ln2224"> </a>
<a name="ln2225">void Element::setOffsetChanged(bool v, bool absolute, const QPointF&amp; diff)</a>
<a name="ln2226">      {</a>
<a name="ln2227">      if (v)</a>
<a name="ln2228">            _offsetChanged = absolute ? OffsetChange::ABSOLUTE_OFFSET : OffsetChange::RELATIVE_OFFSET;</a>
<a name="ln2229">      else</a>
<a name="ln2230">            _offsetChanged = OffsetChange::NONE;</a>
<a name="ln2231">      _changedPos = pos() + diff;</a>
<a name="ln2232">      }</a>
<a name="ln2233"> </a>
<a name="ln2234">//---------------------------------------------------------</a>
<a name="ln2235">//   rebaseOffset</a>
<a name="ln2236">//    calculates new offset for moved elements</a>
<a name="ln2237">//    for drag &amp; other actions that result in absolute position, apply the new offset</a>
<a name="ln2238">//    for nudge &amp; other actions that result in relative adjustment, return the vertical difference</a>
<a name="ln2239">//---------------------------------------------------------</a>
<a name="ln2240"> </a>
<a name="ln2241">qreal Element::rebaseOffset(bool nox)</a>
<a name="ln2242">      {</a>
<a name="ln2243">      QPointF off = offset();</a>
<a name="ln2244">      QPointF p = _changedPos - pos();</a>
<a name="ln2245">      if (nox)</a>
<a name="ln2246">            p.rx() = 0.0;</a>
<a name="ln2247">      //OffsetChange saveChangedValue = _offsetChanged;</a>
<a name="ln2248"> </a>
<a name="ln2249">      bool staffRelative = staff() &amp;&amp; parent() &amp;&amp; !(parent()-&gt;isNote() || parent()-&gt;isRest());</a>
<a name="ln2250">      if (staffRelative &amp;&amp; propertyFlags(Pid::PLACEMENT) != PropertyFlags::NOSTYLE) {</a>
<a name="ln2251">            // check if flipped</a>
<a name="ln2252">            // TODO: elements that support PLACEMENT but not as a styled property (add supportsPlacement() method?)</a>
<a name="ln2253">            // TODO: refactor to take advantage of existing cmdFlip() algorithms</a>
<a name="ln2254">            // TODO: adjustPlacement() (from read206.cpp) on read for 3.0 as well</a>
<a name="ln2255">            QRectF r = bbox().translated(_changedPos);</a>
<a name="ln2256">            qreal staffHeight = staff()-&gt;height();</a>
<a name="ln2257">            Element* e = isSpannerSegment() ? toSpannerSegment(this)-&gt;spanner() : this;</a>
<a name="ln2258">            bool multi = e-&gt;isSpanner() &amp;&amp; toSpanner(e)-&gt;spannerSegments().size() &gt; 1;</a>
<a name="ln2259">            bool above = e-&gt;placeAbove();</a>
<a name="ln2260">            bool flipped = above ? r.top() &gt; staffHeight : r.bottom() &lt; 0.0;</a>
<a name="ln2261">            if (flipped &amp;&amp; !multi) {</a>
<a name="ln2262">                  off.ry() += above ? -staffHeight : staffHeight;</a>
<a name="ln2263">                  undoChangeProperty(Pid::OFFSET, off + p);</a>
<a name="ln2264">                  _offsetChanged = OffsetChange::ABSOLUTE_OFFSET;       //saveChangedValue;</a>
<a name="ln2265">                  rypos() += above ? staffHeight : -staffHeight;</a>
<a name="ln2266">                  PropertyFlags pf = e-&gt;propertyFlags(Pid::PLACEMENT);</a>
<a name="ln2267">                  if (pf == PropertyFlags::STYLED)</a>
<a name="ln2268">                        pf = PropertyFlags::UNSTYLED;</a>
<a name="ln2269">                  Placement place = above ? Placement::BELOW : Placement::ABOVE;</a>
<a name="ln2270">                  e-&gt;undoChangeProperty(Pid::PLACEMENT, int(place), pf);</a>
<a name="ln2271">                  undoResetProperty(Pid::MIN_DISTANCE);</a>
<a name="ln2272">                  // TODO</a>
<a name="ln2273">                  //MuseScoreCore::mscoreCore-&gt;updateInspector();</a>
<a name="ln2274">                  return 0.0;</a>
<a name="ln2275">                  }</a>
<a name="ln2276">            }</a>
<a name="ln2277"> </a>
<a name="ln2278">      if (offsetChanged() == OffsetChange::ABSOLUTE_OFFSET) {</a>
<a name="ln2279">            undoChangeProperty(Pid::OFFSET, off + p);</a>
<a name="ln2280">            _offsetChanged = OffsetChange::ABSOLUTE_OFFSET;             //saveChangedValue;</a>
<a name="ln2281">            // allow autoplace to manage min distance even when not needed</a>
<a name="ln2282">            undoResetProperty(Pid::MIN_DISTANCE);</a>
<a name="ln2283">            return 0.0;</a>
<a name="ln2284">            }</a>
<a name="ln2285"> </a>
<a name="ln2286">      // allow autoplace to manage min distance even when not needed</a>
<a name="ln2287">      undoResetProperty(Pid::MIN_DISTANCE);</a>
<a name="ln2288">      return p.y();</a>
<a name="ln2289">      }</a>
<a name="ln2290"> </a>
<a name="ln2291">//---------------------------------------------------------</a>
<a name="ln2292">//   rebaseMinDistance</a>
<a name="ln2293">//    calculates new minDistance for moved elements</a>
<a name="ln2294">//    if necessary, also rebases offset</a>
<a name="ln2295">//    updates md, yd</a>
<a name="ln2296">//    returns true if shape needs to be rebased</a>
<a name="ln2297">//---------------------------------------------------------</a>
<a name="ln2298"> </a>
<a name="ln2299">bool Element::rebaseMinDistance(qreal&amp; md, qreal&amp; yd, qreal sp, qreal rebase, bool above, bool fix)</a>
<a name="ln2300">      {</a>
<a name="ln2301">      bool rc = false;</a>
<a name="ln2302">      PropertyFlags pf = propertyFlags(Pid::MIN_DISTANCE);</a>
<a name="ln2303">      if (pf == PropertyFlags::STYLED)</a>
<a name="ln2304">            pf = PropertyFlags::UNSTYLED;</a>
<a name="ln2305">      qreal adjustedY = pos().y() + yd;</a>
<a name="ln2306">      qreal diff = _changedPos.y() - adjustedY;</a>
<a name="ln2307">      if (fix) {</a>
<a name="ln2308">            undoChangeProperty(Pid::MIN_DISTANCE, -999.0, pf);</a>
<a name="ln2309">            yd = 0.0;</a>
<a name="ln2310">            }</a>
<a name="ln2311">      else if (!isStyled(Pid::MIN_DISTANCE)) {</a>
<a name="ln2312">            md = (above ? md + yd : md - yd) / sp;</a>
<a name="ln2313">            undoChangeProperty(Pid::MIN_DISTANCE, md, pf);</a>
<a name="ln2314">            yd += diff;</a>
<a name="ln2315">            }</a>
<a name="ln2316">      else {</a>
<a name="ln2317">            // min distance still styled</a>
<a name="ln2318">            // user apparently moved element into skyline</a>
<a name="ln2319">            // but perhaps not really, if performing a relative adjustment</a>
<a name="ln2320">            if (_offsetChanged == OffsetChange::RELATIVE_OFFSET) {</a>
<a name="ln2321">                  // relative movement (cursor): fix only if moving vertically into direction of skyline</a>
<a name="ln2322">                  if ((above &amp;&amp; diff &gt; 0.0) || (!above &amp;&amp; diff &lt; 0.0)) {</a>
<a name="ln2323">                        // rebase offset</a>
<a name="ln2324">                        QPointF p = offset();</a>
<a name="ln2325">                        p.ry() += rebase;</a>
<a name="ln2326">                        undoChangeProperty(Pid::OFFSET, p);</a>
<a name="ln2327">                        md = (above ? md - diff : md + diff) / sp;</a>
<a name="ln2328">                        undoChangeProperty(Pid::MIN_DISTANCE, md, pf);</a>
<a name="ln2329">                        rc = true;</a>
<a name="ln2330">                        yd = 0.0;</a>
<a name="ln2331">                        }</a>
<a name="ln2332">                  }</a>
<a name="ln2333">            else {</a>
<a name="ln2334">                  // absolute movement (drag): fix unconditionally</a>
<a name="ln2335">                  md = (above ? md + yd : md - yd) / sp;</a>
<a name="ln2336">                  undoChangeProperty(Pid::MIN_DISTANCE, md, pf);</a>
<a name="ln2337">                  yd = 0.0;</a>
<a name="ln2338">                  }</a>
<a name="ln2339">            }</a>
<a name="ln2340">      // TODO</a>
<a name="ln2341">      //MuseScoreCore::mscoreCore-&gt;updateInspector();</a>
<a name="ln2342">      return rc;</a>
<a name="ln2343">      }</a>
<a name="ln2344"> </a>
<a name="ln2345">//---------------------------------------------------------</a>
<a name="ln2346">//   autoplaceSegmentElement</a>
<a name="ln2347">//---------------------------------------------------------</a>
<a name="ln2348"> </a>
<a name="ln2349">void Element::autoplaceSegmentElement(bool above, bool add)</a>
<a name="ln2350">      {</a>
<a name="ln2351">      // rebase vertical offset on drag</a>
<a name="ln2352">      qreal rebase = 0.0;</a>
<a name="ln2353">      if (offsetChanged() != OffsetChange::NONE)</a>
<a name="ln2354">            rebase = rebaseOffset();</a>
<a name="ln2355"> </a>
<a name="ln2356">      if (autoplace() &amp;&amp; parent()) {</a>
<a name="ln2357">            Segment* s = toSegment(parent());</a>
<a name="ln2358">            Measure* m = s-&gt;measure();</a>
<a name="ln2359"> </a>
<a name="ln2360">            qreal sp = score()-&gt;spatium();</a>
<a name="ln2361">            int si = staffIdx();</a>
<a name="ln2362">            if (systemFlag()) {</a>
<a name="ln2363">                  const int firstVis = m-&gt;system()-&gt;firstVisibleStaff();</a>
<a name="ln2364">                  if (firstVis &lt; score()-&gt;nstaves())</a>
<a name="ln2365">                        si = firstVis;</a>
<a name="ln2366">                  }</a>
<a name="ln2367">            else {</a>
<a name="ln2368">                  qreal mag = staff()-&gt;mag(tick());</a>
<a name="ln2369">                  sp *= mag;</a>
<a name="ln2370">                  }</a>
<a name="ln2371">            qreal minDistance = _minDistance.val() * sp;</a>
<a name="ln2372"> </a>
<a name="ln2373">            SysStaff* ss = m-&gt;system()-&gt;staff(si);</a>
<a name="ln2374">            QRectF r = bbox().translated(m-&gt;pos() + s-&gt;pos() + pos());</a>
<a name="ln2375"> </a>
<a name="ln2376">            SkylineLine sk(!above);</a>
<a name="ln2377">            qreal d;</a>
<a name="ln2378">            if (above) {</a>
<a name="ln2379">                  sk.add(r.x(), r.bottom(), r.width());</a>
<a name="ln2380">                  d = sk.minDistance(ss-&gt;skyline().north());</a>
<a name="ln2381">                  }</a>
<a name="ln2382">            else {</a>
<a name="ln2383">                  sk.add(r.x(), r.top(), r.width());</a>
<a name="ln2384">                  d = ss-&gt;skyline().south().minDistance(sk);</a>
<a name="ln2385">                  }</a>
<a name="ln2386"> </a>
<a name="ln2387">            if (d &gt; -minDistance) {</a>
<a name="ln2388">                  qreal yd = d + minDistance;</a>
<a name="ln2389">                  if (above)</a>
<a name="ln2390">                        yd *= -1.0;</a>
<a name="ln2391">                  if (offsetChanged() != OffsetChange::NONE) {</a>
<a name="ln2392">                        // user moved element within the skyline</a>
<a name="ln2393">                        // we may need to adjust minDistance, yd, and/or offset</a>
<a name="ln2394">                        bool inStaff = above ? r.bottom() + rebase &gt; 0.0 : r.top() + rebase &lt; staff()-&gt;height();</a>
<a name="ln2395">                        if (rebaseMinDistance(minDistance, yd, sp, rebase, above, inStaff))</a>
<a name="ln2396">                              r.translate(0.0, rebase);</a>
<a name="ln2397">                        }</a>
<a name="ln2398">                  rypos() += yd;</a>
<a name="ln2399">                  r.translate(QPointF(0.0, yd));</a>
<a name="ln2400">                  }</a>
<a name="ln2401">            if (add &amp;&amp; addToSkyline())</a>
<a name="ln2402">                  ss-&gt;skyline().add(r);</a>
<a name="ln2403">            }</a>
<a name="ln2404">      setOffsetChanged(false);</a>
<a name="ln2405">      }</a>
<a name="ln2406"> </a>
<a name="ln2407">//---------------------------------------------------------</a>
<a name="ln2408">//   autoplaceMeasureElement</a>
<a name="ln2409">//---------------------------------------------------------</a>
<a name="ln2410"> </a>
<a name="ln2411">void Element::autoplaceMeasureElement(bool above, bool add)</a>
<a name="ln2412">      {</a>
<a name="ln2413">      // rebase vertical offset on drag</a>
<a name="ln2414">      qreal rebase = 0.0;</a>
<a name="ln2415">      if (offsetChanged() != OffsetChange::NONE)</a>
<a name="ln2416">            rebase = rebaseOffset();</a>
<a name="ln2417"> </a>
<a name="ln2418">      if (autoplace() &amp;&amp; parent()) {</a>
<a name="ln2419">            Measure* m = toMeasure(parent());</a>
<a name="ln2420">            int si     = staffIdx();</a>
<a name="ln2421"> </a>
<a name="ln2422">            qreal sp = score()-&gt;spatium();</a>
<a name="ln2423">            qreal minDistance = _minDistance.val() * sp;</a>
<a name="ln2424"> </a>
<a name="ln2425">            SysStaff* ss = m-&gt;system()-&gt;staff(si);</a>
<a name="ln2426">            // shape rather than bbox is good for tuplets especially</a>
<a name="ln2427">            Shape sh = shape().translated(m-&gt;pos() + pos());</a>
<a name="ln2428"> </a>
<a name="ln2429">            SkylineLine sk(!above);</a>
<a name="ln2430">            qreal d;</a>
<a name="ln2431">            if (above) {</a>
<a name="ln2432">                  sk.add(sh);</a>
<a name="ln2433">                  d = sk.minDistance(ss-&gt;skyline().north());</a>
<a name="ln2434">                  }</a>
<a name="ln2435">            else {</a>
<a name="ln2436">                  sk.add(sh);</a>
<a name="ln2437">                  d = ss-&gt;skyline().south().minDistance(sk);</a>
<a name="ln2438">                  }</a>
<a name="ln2439">            if (d &gt; -minDistance) {</a>
<a name="ln2440">                  qreal yd = d + minDistance;</a>
<a name="ln2441">                  if (above)</a>
<a name="ln2442">                        yd *= -1.0;</a>
<a name="ln2443">                  if (offsetChanged() != OffsetChange::NONE) {</a>
<a name="ln2444">                        // user moved element within the skyline</a>
<a name="ln2445">                        // we may need to adjust minDistance, yd, and/or offset</a>
<a name="ln2446">                        bool inStaff = above ? sh.bottom() + rebase &gt; 0.0 : sh.top() + rebase &lt; staff()-&gt;height();</a>
<a name="ln2447">                        if (rebaseMinDistance(minDistance, yd, sp, rebase, above, inStaff))</a>
<a name="ln2448">                              sh.translateY(rebase);</a>
<a name="ln2449">                        }</a>
<a name="ln2450">                  rypos() += yd;</a>
<a name="ln2451">                  sh.translateY(yd);</a>
<a name="ln2452">                  }</a>
<a name="ln2453">            if (add &amp;&amp; addToSkyline())</a>
<a name="ln2454">                  ss-&gt;skyline().add(sh);</a>
<a name="ln2455">            }</a>
<a name="ln2456">      setOffsetChanged(false);</a>
<a name="ln2457">      }</a>
<a name="ln2458"> </a>
<a name="ln2459">}</a>

</code></pre>
<div class="balloon" rel="408"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="415"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'parent()->parent()' is always true.</p></div>
<div class="balloon" rel="538"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'warning' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="622"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'warning' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1121"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
