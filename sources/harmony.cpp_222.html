
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>harmony.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2008-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;harmony.h&quot;</a>
<a name="ln14">#include &quot;pitchspelling.h&quot;</a>
<a name="ln15">#include &quot;score.h&quot;</a>
<a name="ln16">#include &quot;system.h&quot;</a>
<a name="ln17">#include &quot;measure.h&quot;</a>
<a name="ln18">#include &quot;segment.h&quot;</a>
<a name="ln19">#include &quot;chordlist.h&quot;</a>
<a name="ln20">#include &quot;mscore.h&quot;</a>
<a name="ln21">#include &quot;fret.h&quot;</a>
<a name="ln22">#include &quot;staff.h&quot;</a>
<a name="ln23">#include &quot;part.h&quot;</a>
<a name="ln24">#include &quot;utils.h&quot;</a>
<a name="ln25">#include &quot;sym.h&quot;</a>
<a name="ln26">#include &quot;xml.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28">namespace Ms {</a>
<a name="ln29"> </a>
<a name="ln30">//---------------------------------------------------------</a>
<a name="ln31">//   harmonyName</a>
<a name="ln32">//---------------------------------------------------------</a>
<a name="ln33"> </a>
<a name="ln34">QString Harmony::harmonyName() const</a>
<a name="ln35">      {</a>
<a name="ln36">      // Hack:</a>
<a name="ln37">      const_cast&lt;Harmony*&gt;(this)-&gt;determineRootBaseSpelling();</a>
<a name="ln38"> </a>
<a name="ln39">      HChord hc = descr() ? descr()-&gt;chord : HChord();</a>
<a name="ln40">      QString s, r, e, b;</a>
<a name="ln41"> </a>
<a name="ln42">      if (_leftParen)</a>
<a name="ln43">            s = &quot;(&quot;;</a>
<a name="ln44"> </a>
<a name="ln45">      if (_rootTpc != Tpc::TPC_INVALID)</a>
<a name="ln46">            r = tpc2name(_rootTpc, _rootSpelling, _rootCase);</a>
<a name="ln47">      else if (_harmonyType != HarmonyType::STANDARD)</a>
<a name="ln48">            r = _function;</a>
<a name="ln49"> </a>
<a name="ln50">      if (_textName != &quot;&quot;) {</a>
<a name="ln51">            e = _textName;</a>
<a name="ln52">            if (_harmonyType != HarmonyType::ROMAN)</a>
<a name="ln53">                  e.remove('=');</a>
<a name="ln54">            }</a>
<a name="ln55">      else if (!_degreeList.empty()) {</a>
<a name="ln56">            hc.add(_degreeList);</a>
<a name="ln57">            // try to find the chord in chordList</a>
<a name="ln58">            const ChordDescription* newExtension = 0;</a>
<a name="ln59">            const ChordList* cl = score()-&gt;style().chordList();</a>
<a name="ln60">            for (const ChordDescription&amp; cd : *cl) {</a>
<a name="ln61">                  if (cd.chord == hc &amp;&amp; !cd.names.empty()) {</a>
<a name="ln62">                        newExtension = &amp;cd;</a>
<a name="ln63">                        break;</a>
<a name="ln64">                        }</a>
<a name="ln65">                  }</a>
<a name="ln66">            // now determine the chord name</a>
<a name="ln67">            if (newExtension)</a>
<a name="ln68">                  e = newExtension-&gt;names.front();</a>
<a name="ln69">            else {</a>
<a name="ln70">                  // not in table, fallback to using HChord.name()</a>
<a name="ln71">                  r = hc.name(_rootTpc);</a>
<a name="ln72">                  e = &quot;&quot;;</a>
<a name="ln73">                  }</a>
<a name="ln74">            }</a>
<a name="ln75"> </a>
<a name="ln76">      if (_baseTpc != Tpc::TPC_INVALID)</a>
<a name="ln77">            b = &quot;/&quot; + tpc2name(_baseTpc, _baseSpelling, _baseCase);</a>
<a name="ln78"> </a>
<a name="ln79">      s += r + e + b;</a>
<a name="ln80"> </a>
<a name="ln81">      if (_rightParen)</a>
<a name="ln82">            s += &quot;)&quot;;</a>
<a name="ln83"> </a>
<a name="ln84">      return s;</a>
<a name="ln85">      }</a>
<a name="ln86"> </a>
<a name="ln87">//---------------------------------------------------------</a>
<a name="ln88">//   rootName</a>
<a name="ln89">//---------------------------------------------------------</a>
<a name="ln90"> </a>
<a name="ln91">QString Harmony::rootName()</a>
<a name="ln92">      {</a>
<a name="ln93">      determineRootBaseSpelling();</a>
<a name="ln94">      return tpc2name(_rootTpc, _rootSpelling, _rootCase);</a>
<a name="ln95">      }</a>
<a name="ln96"> </a>
<a name="ln97">//---------------------------------------------------------</a>
<a name="ln98">//   baseName</a>
<a name="ln99">//---------------------------------------------------------</a>
<a name="ln100"> </a>
<a name="ln101">QString Harmony::baseName()</a>
<a name="ln102">      {</a>
<a name="ln103">      determineRootBaseSpelling();</a>
<a name="ln104">      return tpc2name(_baseTpc, _baseSpelling, _baseCase);</a>
<a name="ln105">      }</a>
<a name="ln106"> </a>
<a name="ln107">//---------------------------------------------------------</a>
<a name="ln108">//   resolveDegreeList</a>
<a name="ln109">//    try to detect chord number and to eliminate degree</a>
<a name="ln110">//    list</a>
<a name="ln111">//---------------------------------------------------------</a>
<a name="ln112"> </a>
<a name="ln113">void Harmony::resolveDegreeList()</a>
<a name="ln114">      {</a>
<a name="ln115">      if (_degreeList.empty())</a>
<a name="ln116">            return;</a>
<a name="ln117"> </a>
<a name="ln118">      HChord hc = descr() ? descr()-&gt;chord : HChord();</a>
<a name="ln119"> </a>
<a name="ln120">      hc.add(_degreeList);</a>
<a name="ln121"> </a>
<a name="ln122">// qDebug(&quot;resolveDegreeList: &lt;%s&gt; &lt;%s-%s&gt;: &quot;, _descr-&gt;name, _descr-&gt;xmlKind, _descr-&gt;xmlDegrees);</a>
<a name="ln123">// hc.print();</a>
<a name="ln124">// _descr-&gt;chord.print();</a>
<a name="ln125"> </a>
<a name="ln126">      // try to find the chord in chordList</a>
<a name="ln127">      const ChordList* cl = score()-&gt;style().chordList();</a>
<a name="ln128">      foreach(const ChordDescription&amp; cd, *cl) {</a>
<a name="ln129">            if ((cd.chord == hc) &amp;&amp; !cd.names.empty()) {</a>
<a name="ln130">qDebug(&quot;ResolveDegreeList: found in table as %s&quot;, qPrintable(cd.names.front()));</a>
<a name="ln131">                  _id = cd.id;</a>
<a name="ln132">                  _degreeList.clear();</a>
<a name="ln133">                  return;</a>
<a name="ln134">                  }</a>
<a name="ln135">            }</a>
<a name="ln136">qDebug(&quot;ResolveDegreeList: not found in table&quot;);</a>
<a name="ln137">      }</a>
<a name="ln138"> </a>
<a name="ln139">//---------------------------------------------------------</a>
<a name="ln140">//   chordSymbolStyle</a>
<a name="ln141">//---------------------------------------------------------</a>
<a name="ln142"> </a>
<a name="ln143">const ElementStyle chordSymbolStyle {</a>
<a name="ln144">      { Sid::harmonyPlacement, Pid::PLACEMENT  },</a>
<a name="ln145">      { Sid::minHarmonyDistance, Pid::MIN_DISTANCE },</a>
<a name="ln146">      };</a>
<a name="ln147"> </a>
<a name="ln148">//---------------------------------------------------------</a>
<a name="ln149">//   Harmony</a>
<a name="ln150">//---------------------------------------------------------</a>
<a name="ln151"> </a>
<a name="ln152">Harmony::Harmony(Score* s)</a>
<a name="ln153">   : TextBase(s, Tid::HARMONY_A, ElementFlag::MOVABLE | ElementFlag::ON_STAFF)</a>
<a name="ln154">      {</a>
<a name="ln155">      _rootTpc    = Tpc::TPC_INVALID;</a>
<a name="ln156">      _baseTpc    = Tpc::TPC_INVALID;</a>
<a name="ln157">      _rootCase   = NoteCaseType::CAPITAL;</a>
<a name="ln158">      _baseCase   = NoteCaseType::CAPITAL;</a>
<a name="ln159">      _id         = -1;</a>
<a name="ln160">      _parsedForm = 0;</a>
<a name="ln161">      _harmonyType = HarmonyType::STANDARD;</a>
<a name="ln162">      _leftParen  = false;</a>
<a name="ln163">      _rightParen = false;</a>
<a name="ln164">      initElementStyle(&amp;chordSymbolStyle);</a>
<a name="ln165">      }</a>
<a name="ln166"> </a>
<a name="ln167">Harmony::Harmony(const Harmony&amp; h)</a>
<a name="ln168">   : TextBase(h)</a>
<a name="ln169">      {</a>
<a name="ln170">      _rootTpc    = h._rootTpc;</a>
<a name="ln171">      _baseTpc    = h._baseTpc;</a>
<a name="ln172">      _rootCase   = h._rootCase;</a>
<a name="ln173">      _baseCase   = h._baseCase;</a>
<a name="ln174">      _id         = h._id;</a>
<a name="ln175">      _leftParen  = h._leftParen;</a>
<a name="ln176">      _rightParen = h._rightParen;</a>
<a name="ln177">      _degreeList = h._degreeList;</a>
<a name="ln178">      _parsedForm = h._parsedForm ? new ParsedChord(*h._parsedForm) : 0;</a>
<a name="ln179">      _harmonyType = h._harmonyType;</a>
<a name="ln180">      _textName   = h._textName;</a>
<a name="ln181">      _userName   = h._userName;</a>
<a name="ln182">      _function   = h._function;</a>
<a name="ln183">      for (const TextSegment* s : h.textList) {</a>
<a name="ln184">            TextSegment* ns = new TextSegment();</a>
<a name="ln185">            ns-&gt;set(s-&gt;text, s-&gt;font, s-&gt;x, s-&gt;y);</a>
<a name="ln186">            textList.append(ns);</a>
<a name="ln187">            }</a>
<a name="ln188">      }</a>
<a name="ln189"> </a>
<a name="ln190">//---------------------------------------------------------</a>
<a name="ln191">//   ~Harmony</a>
<a name="ln192">//---------------------------------------------------------</a>
<a name="ln193"> </a>
<a name="ln194">Harmony::~Harmony()</a>
<a name="ln195">      {</a>
<a name="ln196">      foreach(const TextSegment* ts, textList)</a>
<a name="ln197">            delete ts;</a>
<a name="ln198">      if (_parsedForm)</a>
<a name="ln199">            delete _parsedForm;</a>
<a name="ln200">      }</a>
<a name="ln201"> </a>
<a name="ln202">//---------------------------------------------------------</a>
<a name="ln203">//   write</a>
<a name="ln204">//---------------------------------------------------------</a>
<a name="ln205"> </a>
<a name="ln206">void Harmony::write(XmlWriter&amp; xml) const</a>
<a name="ln207">      {</a>
<a name="ln208">      if (!xml.canWrite(this))</a>
<a name="ln209">            return;</a>
<a name="ln210">      xml.stag(this);</a>
<a name="ln211">      writeProperty(xml, Pid::HARMONY_TYPE);</a>
<a name="ln212">      if (_leftParen)</a>
<a name="ln213">            xml.tagE(&quot;leftParen&quot;);</a>
<a name="ln214">      if (_rootTpc != Tpc::TPC_INVALID || _baseTpc != Tpc::TPC_INVALID) {</a>
<a name="ln215">            int rRootTpc = _rootTpc;</a>
<a name="ln216">            int rBaseTpc = _baseTpc;</a>
<a name="ln217">            if (staff()) {</a>
<a name="ln218">                  // parent can be a fret diagram</a>
<a name="ln219">                  Segment* segment = parent()-&gt;isSegment() ? toSegment(parent()) : toSegment(parent()-&gt;parent());</a>
<a name="ln220">                  Fraction tick = segment ? segment-&gt;tick() : Fraction(-1,1);</a>
<a name="ln221">                  const Interval&amp; interval = part()-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln222">                  if (xml.clipboardmode() &amp;&amp; !score()-&gt;styleB(Sid::concertPitch) &amp;&amp; interval.chromatic) {</a>
<a name="ln223">                        rRootTpc = transposeTpc(_rootTpc, interval, true);</a>
<a name="ln224">                        rBaseTpc = transposeTpc(_baseTpc, interval, true);</a>
<a name="ln225">                        }</a>
<a name="ln226">                  }</a>
<a name="ln227">            if (rRootTpc != Tpc::TPC_INVALID) {</a>
<a name="ln228">                  xml.tag(&quot;root&quot;, rRootTpc);</a>
<a name="ln229">                  if (_rootCase != NoteCaseType::CAPITAL)</a>
<a name="ln230">                        xml.tag(&quot;rootCase&quot;, static_cast&lt;int&gt;(_rootCase));</a>
<a name="ln231">                  }</a>
<a name="ln232">            if (_id &gt; 0)</a>
<a name="ln233">                  xml.tag(&quot;extension&quot;, _id);</a>
<a name="ln234">            // parser uses leading &quot;=&quot; as a hidden specifier for minor</a>
<a name="ln235">            // this may or may not currently be incorporated into _textName</a>
<a name="ln236">            QString writeName = _textName;</a>
<a name="ln237">            if (_parsedForm &amp;&amp; _parsedForm-&gt;name().startsWith(&quot;=&quot;) &amp;&amp; !writeName.startsWith(&quot;=&quot;))</a>
<a name="ln238">                  writeName = &quot;=&quot; + writeName;</a>
<a name="ln239">            if (!writeName.isEmpty())</a>
<a name="ln240">                  xml.tag(&quot;name&quot;, writeName);</a>
<a name="ln241"> </a>
<a name="ln242">            if (rBaseTpc != Tpc::TPC_INVALID) {</a>
<a name="ln243">                  xml.tag(&quot;base&quot;, rBaseTpc);</a>
<a name="ln244">                  if (_baseCase != NoteCaseType::CAPITAL)</a>
<a name="ln245">                        xml.tag(&quot;baseCase&quot;, static_cast&lt;int&gt;(_baseCase));</a>
<a name="ln246">                  }</a>
<a name="ln247">            for (const HDegree&amp; hd : _degreeList) {</a>
<a name="ln248">                  HDegreeType tp = hd.type();</a>
<a name="ln249">                  if (tp == HDegreeType::ADD || tp == HDegreeType::ALTER || tp == HDegreeType::SUBTRACT) {</a>
<a name="ln250">                        xml.stag(&quot;degree&quot;);</a>
<a name="ln251">                        xml.tag(&quot;degree-value&quot;, hd.value());</a>
<a name="ln252">                        xml.tag(&quot;degree-alter&quot;, hd.alter());</a>
<a name="ln253">                        switch (tp) {</a>
<a name="ln254">                              case HDegreeType::ADD:</a>
<a name="ln255">                                    xml.tag(&quot;degree-type&quot;, &quot;add&quot;);</a>
<a name="ln256">                                    break;</a>
<a name="ln257">                              case HDegreeType::ALTER:</a>
<a name="ln258">                                    xml.tag(&quot;degree-type&quot;, &quot;alter&quot;);</a>
<a name="ln259">                                    break;</a>
<a name="ln260">                              case HDegreeType::SUBTRACT:</a>
<a name="ln261">                                    xml.tag(&quot;degree-type&quot;, &quot;subtract&quot;);</a>
<a name="ln262">                                    break;</a>
<a name="ln263">                              default:</a>
<a name="ln264">                                    break;</a>
<a name="ln265">                              }</a>
<a name="ln266">                        xml.etag();</a>
<a name="ln267">                        }</a>
<a name="ln268">                  }</a>
<a name="ln269">            }</a>
<a name="ln270">      else</a>
<a name="ln271">            xml.tag(&quot;name&quot;, _textName);</a>
<a name="ln272">      if (!_function.isEmpty())</a>
<a name="ln273">            xml.tag(&quot;function&quot;, _function);</a>
<a name="ln274">      TextBase::writeProperties(xml, false, true);</a>
<a name="ln275">      if (_rightParen)</a>
<a name="ln276">            xml.tagE(&quot;rightParen&quot;);</a>
<a name="ln277">      xml.etag();</a>
<a name="ln278">      }</a>
<a name="ln279"> </a>
<a name="ln280">//---------------------------------------------------------</a>
<a name="ln281">//   read</a>
<a name="ln282">//---------------------------------------------------------</a>
<a name="ln283"> </a>
<a name="ln284">void Harmony::read(XmlReader&amp; e)</a>
<a name="ln285">      {</a>
<a name="ln286">      while (e.readNextStartElement()) {</a>
<a name="ln287">            const QStringRef&amp; tag(e.name());</a>
<a name="ln288">            if (tag == &quot;base&quot;)</a>
<a name="ln289">                  setBaseTpc(e.readInt());</a>
<a name="ln290">            else if (tag == &quot;baseCase&quot;)</a>
<a name="ln291">                  _baseCase = static_cast&lt;NoteCaseType&gt;(e.readInt());</a>
<a name="ln292">            else if (tag == &quot;extension&quot;)</a>
<a name="ln293">                  setId(e.readInt());</a>
<a name="ln294">            else if (tag == &quot;name&quot;)</a>
<a name="ln295">                  _textName = e.readElementText();</a>
<a name="ln296">            else if (tag == &quot;root&quot;)</a>
<a name="ln297">                  setRootTpc(e.readInt());</a>
<a name="ln298">            else if (tag == &quot;rootCase&quot;)</a>
<a name="ln299">                  _rootCase = static_cast&lt;NoteCaseType&gt;(e.readInt());</a>
<a name="ln300">            else if (tag == &quot;function&quot;)</a>
<a name="ln301">                  _function = e.readElementText();</a>
<a name="ln302">            else if (tag == &quot;degree&quot;) {</a>
<a name="ln303">                  int degreeValue = 0;</a>
<a name="ln304">                  int degreeAlter = 0;</a>
<a name="ln305">                  QString degreeType = &quot;&quot;;</a>
<a name="ln306">                  while (e.readNextStartElement()) {</a>
<a name="ln307">                        const QStringRef&amp; t(e.name());</a>
<a name="ln308">                        if (t == &quot;degree-value&quot;)</a>
<a name="ln309">                              degreeValue = e.readInt();</a>
<a name="ln310">                        else if (t == &quot;degree-alter&quot;)</a>
<a name="ln311">                              degreeAlter = e.readInt();</a>
<a name="ln312">                        else if (t == &quot;degree-type&quot;)</a>
<a name="ln313">                              degreeType = e.readElementText();</a>
<a name="ln314">                        else</a>
<a name="ln315">                              e.unknown();</a>
<a name="ln316">                        }</a>
<a name="ln317">                  if (degreeValue &lt;= 0 || degreeValue &gt; 13</a>
<a name="ln318">                      || degreeAlter &lt; -2 || degreeAlter &gt; 2</a>
<a name="ln319">                      || (degreeType != &quot;add&quot; &amp;&amp; degreeType != &quot;alter&quot; &amp;&amp; degreeType != &quot;subtract&quot;)) {</a>
<a name="ln320">                        qDebug(&quot;incorrect degree: degreeValue=%d degreeAlter=%d degreeType=%s&quot;,</a>
<a name="ln321">                               degreeValue, degreeAlter, qPrintable(degreeType));</a>
<a name="ln322">                        }</a>
<a name="ln323">                  else {</a>
<a name="ln324">                        if (degreeType == &quot;add&quot;)</a>
<a name="ln325">                              addDegree(HDegree(degreeValue, degreeAlter, HDegreeType::ADD));</a>
<a name="ln326">                        else if (degreeType == &quot;alter&quot;)</a>
<a name="ln327">                              addDegree(HDegree(degreeValue, degreeAlter, HDegreeType::ALTER));</a>
<a name="ln328">                        else if (degreeType == &quot;subtract&quot;)</a>
<a name="ln329">                              addDegree(HDegree(degreeValue, degreeAlter, HDegreeType::SUBTRACT));</a>
<a name="ln330">                        }</a>
<a name="ln331">                  }</a>
<a name="ln332">            else if (tag == &quot;leftParen&quot;) {</a>
<a name="ln333">                  _leftParen = true;</a>
<a name="ln334">                  e.readNext();</a>
<a name="ln335">                  }</a>
<a name="ln336">            else if (tag == &quot;rightParen&quot;) {</a>
<a name="ln337">                  _rightParen = true;</a>
<a name="ln338">                  e.readNext();</a>
<a name="ln339">                  }</a>
<a name="ln340">            else if (readProperty(tag, e, Pid::POS_ABOVE))</a>
<a name="ln341">                  ;</a>
<a name="ln342">            else if (readProperty(tag, e, Pid::HARMONY_TYPE))</a>
<a name="ln343">                  ;</a>
<a name="ln344">            else if (!TextBase::readProperties(e))</a>
<a name="ln345">                  e.unknown();</a>
<a name="ln346">            }</a>
<a name="ln347"> </a>
<a name="ln348">      // TODO: now that we can render arbitrary chords,</a>
<a name="ln349">      // we could try to construct a full representation from a degree list.</a>
<a name="ln350">      // These will typically only exist for chords imported from MusicXML prior to MuseScore 2.0</a>
<a name="ln351">      // or constructed in the Chord Symbol Properties dialog.</a>
<a name="ln352"> </a>
<a name="ln353">      if (_rootTpc != Tpc::TPC_INVALID) {</a>
<a name="ln354">            if (_id &gt; 0) {</a>
<a name="ln355">                  // positive id will happen only for scores that were created with explicit chord lists</a>
<a name="ln356">                  // lookup id in chord list and generate new description if necessary</a>
<a name="ln357">                  getDescription();</a>
<a name="ln358">                  }</a>
<a name="ln359">            else</a>
<a name="ln360">                  {</a>
<a name="ln361">                  // default case: look up by name</a>
<a name="ln362">                  // description will be found for any chord already read in this score</a>
<a name="ln363">                  // and we will generate a new one if necessary</a>
<a name="ln364">                  getDescription(_textName);</a>
<a name="ln365">                  }</a>
<a name="ln366">            }</a>
<a name="ln367">      else if (_textName == &quot;&quot;) {</a>
<a name="ln368">            // unrecognized chords prior to 2.0 were stored as text with markup</a>
<a name="ln369">            // we need to strip away the markup</a>
<a name="ln370">            // this removes any user-applied formatting,</a>
<a name="ln371">            // but we no longer support user-applied formatting for chord symbols anyhow</a>
<a name="ln372">            // with any luck, the resulting text will be parseable now, so give it a shot</a>
<a name="ln373">            createLayout();</a>
<a name="ln374">            QString s = plainText();</a>
<a name="ln375">            if (!s.isEmpty()) {</a>
<a name="ln376">                  setHarmony(s);</a>
<a name="ln377">                  return;</a>
<a name="ln378">                  }</a>
<a name="ln379">            // empty text could also indicate a root-less slash chord (&quot;/E&quot;)</a>
<a name="ln380">            // we'll fall through and render it normally</a>
<a name="ln381">            }</a>
<a name="ln382"> </a>
<a name="ln383">      // render chord from description (or _textName)</a>
<a name="ln384">      render();</a>
<a name="ln385">      setPlainText(harmonyName());</a>
<a name="ln386">      }</a>
<a name="ln387"> </a>
<a name="ln388">//---------------------------------------------------------</a>
<a name="ln389">//   determineRootBaseSpelling</a>
<a name="ln390">//---------------------------------------------------------</a>
<a name="ln391"> </a>
<a name="ln392">void Harmony::determineRootBaseSpelling(NoteSpellingType&amp; rootSpelling, NoteCaseType&amp; rootCase,</a>
<a name="ln393">   NoteSpellingType&amp; baseSpelling, NoteCaseType&amp; baseCase)</a>
<a name="ln394">      {</a>
<a name="ln395">      // spelling</a>
<a name="ln396">      if (score()-&gt;styleB(Sid::useStandardNoteNames))</a>
<a name="ln397">            rootSpelling = NoteSpellingType::STANDARD;</a>
<a name="ln398">      else if (score()-&gt;styleB(Sid::useGermanNoteNames))</a>
<a name="ln399">            rootSpelling = NoteSpellingType::GERMAN;</a>
<a name="ln400">      else if (score()-&gt;styleB(Sid::useFullGermanNoteNames))</a>
<a name="ln401">            rootSpelling = NoteSpellingType::GERMAN_PURE;</a>
<a name="ln402">      else if (score()-&gt;styleB(Sid::useSolfeggioNoteNames))</a>
<a name="ln403">            rootSpelling = NoteSpellingType::SOLFEGGIO;</a>
<a name="ln404">      else if (score()-&gt;styleB(Sid::useFrenchNoteNames))</a>
<a name="ln405">            rootSpelling = NoteSpellingType::FRENCH;</a>
<a name="ln406">      baseSpelling = rootSpelling;</a>
<a name="ln407"> </a>
<a name="ln408">      // case</a>
<a name="ln409"> </a>
<a name="ln410">      // always use case as typed if automatic capitalization is off</a>
<a name="ln411">      if (!score()-&gt;styleB(Sid::automaticCapitalization)) {</a>
<a name="ln412">            rootCase = _rootCase;</a>
<a name="ln413">            baseCase = _baseCase;</a>
<a name="ln414">            return;</a>
<a name="ln415">            }</a>
<a name="ln416"> </a>
<a name="ln417">      // set default</a>
<a name="ln418">      if (score()-&gt;styleB(Sid::allCapsNoteNames)) {</a>
<a name="ln419">            rootCase = NoteCaseType::UPPER;</a>
<a name="ln420">            baseCase = NoteCaseType::UPPER;</a>
<a name="ln421">            }</a>
<a name="ln422">      else {</a>
<a name="ln423">            rootCase = NoteCaseType::CAPITAL;</a>
<a name="ln424">            baseCase = NoteCaseType::CAPITAL;</a>
<a name="ln425">            }</a>
<a name="ln426"> </a>
<a name="ln427">      // override for bass note</a>
<a name="ln428">      if (score()-&gt;styleB(Sid::lowerCaseBassNotes))</a>
<a name="ln429">            baseCase = NoteCaseType::LOWER;</a>
<a name="ln430"> </a>
<a name="ln431">      // override for minor chords</a>
<a name="ln432">      if (score()-&gt;styleB(Sid::lowerCaseMinorChords)) {</a>
<a name="ln433">            const ChordDescription* cd = descr();</a>
<a name="ln434">            QString quality;</a>
<a name="ln435">            if (cd) {</a>
<a name="ln436">                  // use chord description if possible</a>
<a name="ln437">                  // this is the usual case</a>
<a name="ln438">                  quality = cd-&gt;quality();</a>
<a name="ln439">                  }</a>
<a name="ln440">            else if (_parsedForm) {</a>
<a name="ln441">                  // this happens on load of new chord list</a>
<a name="ln442">                  // for chord symbols that were added/edited since the score was loaded</a>
<a name="ln443">                  // or read aloud with screenreader</a>
<a name="ln444">                  // parsed form is usable even if out of date with respect to chord list</a>
<a name="ln445">                  quality = _parsedForm-&gt;quality();</a>
<a name="ln446">                  }</a>
<a name="ln447">            else {</a>
<a name="ln448">                  // this happens on load of new chord list</a>
<a name="ln449">                  // for chord symbols that have not been edited since the score was loaded</a>
<a name="ln450">                  // we need to parse this chord for now to determine quality</a>
<a name="ln451">                  // but don't keep the parsed form around as we're not ready for it yet</a>
<a name="ln452">                  quality = parsedForm()-&gt;quality();</a>
<a name="ln453">                  delete _parsedForm;</a>
<a name="ln454">                  _parsedForm = 0;</a>
<a name="ln455">                  }</a>
<a name="ln456">            if (quality == &quot;minor&quot; || quality == &quot;diminished&quot; || quality == &quot;half-diminished&quot;)</a>
<a name="ln457">                  rootCase = NoteCaseType::LOWER;</a>
<a name="ln458">            }</a>
<a name="ln459">      }</a>
<a name="ln460"> </a>
<a name="ln461">//---------------------------------------------------------</a>
<a name="ln462">//   determineRootBaseSpelling</a>
<a name="ln463">//---------------------------------------------------------</a>
<a name="ln464"> </a>
<a name="ln465">void Harmony::determineRootBaseSpelling()</a>
<a name="ln466">      {</a>
<a name="ln467">      determineRootBaseSpelling(_rootSpelling, _rootRenderCase,</a>
<a name="ln468">        _baseSpelling, _baseRenderCase);</a>
<a name="ln469">      }</a>
<a name="ln470"> </a>
<a name="ln471">//---------------------------------------------------------</a>
<a name="ln472">//   convertNote</a>
<a name="ln473">//    convert something like &quot;C#&quot; into tpc 21</a>
<a name="ln474">//---------------------------------------------------------</a>
<a name="ln475"> </a>
<a name="ln476">static int convertNote(const QString&amp; s, NoteSpellingType noteSpelling, NoteCaseType&amp; noteCase, int&amp; idx)</a>
<a name="ln477">      {</a>
<a name="ln478">      bool useGerman = false;</a>
<a name="ln479">      bool useSolfeggio = false;</a>
<a name="ln480">      static const int spellings[] = {</a>
<a name="ln481">         // bb  b   -   #  ##</a>
<a name="ln482">            0,  7, 14, 21, 28,  // C</a>
<a name="ln483">            2,  9, 16, 23, 30,  // D</a>
<a name="ln484">            4, 11, 18, 25, 32,  // E</a>
<a name="ln485">           -1,  6, 13, 20, 27,  // F</a>
<a name="ln486">            1,  8, 15, 22, 29,  // G</a>
<a name="ln487">            3, 10, 17, 24, 31,  // A</a>
<a name="ln488">            5, 12, 19, 26, 33,  // B</a>
<a name="ln489">            };</a>
<a name="ln490">      if (s == &quot;&quot;)</a>
<a name="ln491">            return Tpc::TPC_INVALID;</a>
<a name="ln492">      noteCase = s[0].isLower() ? NoteCaseType::LOWER : NoteCaseType::CAPITAL;</a>
<a name="ln493">      int acci;</a>
<a name="ln494">      switch (noteSpelling) {</a>
<a name="ln495">            case NoteSpellingType::SOLFEGGIO:</a>
<a name="ln496">            case NoteSpellingType::FRENCH:</a>
<a name="ln497">                  useSolfeggio = true;</a>
<a name="ln498">                  if (s.toLower().startsWith(&quot;sol&quot;))</a>
<a name="ln499">                        acci = 3;</a>
<a name="ln500">                  else</a>
<a name="ln501">                        acci = 2;</a>
<a name="ln502">                  break;</a>
<a name="ln503">            case NoteSpellingType::GERMAN:</a>
<a name="ln504">            case NoteSpellingType::GERMAN_PURE:</a>
<a name="ln505">                  useGerman = true;</a>
<a name="ln506">                  // fall through</a>
<a name="ln507">            default:</a>
<a name="ln508">                  acci = 1;</a>
<a name="ln509">            }</a>
<a name="ln510">      idx = acci;</a>
<a name="ln511">      int alter = 0;</a>
<a name="ln512">      int n = s.size();</a>
<a name="ln513">      QString acc = s.right(n-acci);</a>
<a name="ln514">      if (acc != &quot;&quot;) {</a>
<a name="ln515">            if (acc.startsWith(&quot;bb&quot;)) {</a>
<a name="ln516">                  alter = -2;</a>
<a name="ln517">                  idx += 2;</a>
<a name="ln518">                  }</a>
<a name="ln519">            else if (acc.startsWith(&quot;b&quot;)) {</a>
<a name="ln520">                  alter = -1;</a>
<a name="ln521">                  idx += 1;</a>
<a name="ln522">                  }</a>
<a name="ln523">            else if (useGerman &amp;&amp; acc.startsWith(&quot;eses&quot;)) {</a>
<a name="ln524">                  alter = -2;</a>
<a name="ln525">                  idx += 4;</a>
<a name="ln526">                  }</a>
<a name="ln527">            else if (useGerman &amp;&amp; (acc.startsWith(&quot;ses&quot;) || acc.startsWith(&quot;sas&quot;))) {</a>
<a name="ln528">                  alter = -2;</a>
<a name="ln529">                  idx += 3;</a>
<a name="ln530">                  }</a>
<a name="ln531">            else if (useGerman &amp;&amp; acc.startsWith(&quot;es&quot;)) {</a>
<a name="ln532">                  alter = -1;</a>
<a name="ln533">                  idx += 2;</a>
<a name="ln534">                  }</a>
<a name="ln535">            else if (useGerman &amp;&amp; acc.startsWith(&quot;s&quot;) &amp;&amp; !acc.startsWith(&quot;su&quot;)) {</a>
<a name="ln536">                  alter = -1;</a>
<a name="ln537">                  idx += 1;</a>
<a name="ln538">                  }</a>
<a name="ln539">            else if (acc.startsWith(&quot;##&quot;)) {</a>
<a name="ln540">                  alter = 2;</a>
<a name="ln541">                  idx += 2;</a>
<a name="ln542">                  }</a>
<a name="ln543">            else if (acc.startsWith(&quot;x&quot;)) {</a>
<a name="ln544">                  alter = 2;</a>
<a name="ln545">                  idx += 1;</a>
<a name="ln546">                  }</a>
<a name="ln547">            else if (acc.startsWith(&quot;#&quot;)) {</a>
<a name="ln548">                  alter = 1;</a>
<a name="ln549">                  idx += 1;</a>
<a name="ln550">                  }</a>
<a name="ln551">            else if (useGerman &amp;&amp; acc.startsWith(&quot;isis&quot;)) {</a>
<a name="ln552">                  alter = 2;</a>
<a name="ln553">                  idx += 4;</a>
<a name="ln554">                  }</a>
<a name="ln555">            else if (useGerman &amp;&amp; acc.startsWith(&quot;is&quot;)) {</a>
<a name="ln556">                  alter = 1;</a>
<a name="ln557">                  idx += 2;</a>
<a name="ln558">                  }</a>
<a name="ln559">            }</a>
<a name="ln560">      int r;</a>
<a name="ln561">      if (useGerman) {</a>
<a name="ln562">            switch(s[0].toLower().toLatin1()) {</a>
<a name="ln563">                  case 'c':   r = 0; break;</a>
<a name="ln564">                  case 'd':   r = 1; break;</a>
<a name="ln565">                  case 'e':   r = 2; break;</a>
<a name="ln566">                  case 'f':   r = 3; break;</a>
<a name="ln567">                  case 'g':   r = 4; break;</a>
<a name="ln568">                  case 'a':   r = 5; break;</a>
<a name="ln569">                  case 'h':   r = 6; break;</a>
<a name="ln570">                  case 'b':</a>
<a name="ln571">                        if (alter &amp;&amp; alter != -1)</a>
<a name="ln572">                              return Tpc::TPC_INVALID;</a>
<a name="ln573">                        r = 6;</a>
<a name="ln574">                        alter = -1;</a>
<a name="ln575">                        break;</a>
<a name="ln576">                  default:</a>
<a name="ln577">                        return Tpc::TPC_INVALID;</a>
<a name="ln578">                  }</a>
<a name="ln579">            }</a>
<a name="ln580">      else if (useSolfeggio) {</a>
<a name="ln581">            if (s.length() &lt; 2)</a>
<a name="ln582">                  return Tpc::TPC_INVALID;</a>
<a name="ln583">            if (s[1].isUpper())</a>
<a name="ln584">                  noteCase = NoteCaseType::UPPER;</a>
<a name="ln585">            QString ss = s.toLower().left(2);</a>
<a name="ln586">            if (ss == &quot;do&quot;)</a>
<a name="ln587">                  r = 0;</a>
<a name="ln588">            else if (ss == &quot;re&quot; || ss == &quot;ré&quot;)</a>
<a name="ln589">                  r = 1;</a>
<a name="ln590">            else if (ss == &quot;mi&quot;)</a>
<a name="ln591">                  r = 2;</a>
<a name="ln592">            else if (ss == &quot;fa&quot;)</a>
<a name="ln593">                  r = 3;</a>
<a name="ln594">            else if (ss == &quot;so&quot;)    // sol, but only check first 2 characters</a>
<a name="ln595">                  r = 4;</a>
<a name="ln596">            else if (ss == &quot;la&quot;)</a>
<a name="ln597">                  r = 5;</a>
<a name="ln598">            else if (ss == &quot;si&quot;)</a>
<a name="ln599">                  r = 6;</a>
<a name="ln600">            else</a>
<a name="ln601">                  return Tpc::TPC_INVALID;</a>
<a name="ln602">            }</a>
<a name="ln603">      else {</a>
<a name="ln604">            switch(s[0].toLower().toLatin1()) {</a>
<a name="ln605">                  case 'c':   r = 0; break;</a>
<a name="ln606">                  case 'd':   r = 1; break;</a>
<a name="ln607">                  case 'e':   r = 2; break;</a>
<a name="ln608">                  case 'f':   r = 3; break;</a>
<a name="ln609">                  case 'g':   r = 4; break;</a>
<a name="ln610">                  case 'a':   r = 5; break;</a>
<a name="ln611">                  case 'b':   r = 6; break;</a>
<a name="ln612">                  default:    return Tpc::TPC_INVALID;</a>
<a name="ln613">                  }</a>
<a name="ln614">            }</a>
<a name="ln615">      r = spellings[r * 5 + alter + 2];</a>
<a name="ln616">      return r;</a>
<a name="ln617">      }</a>
<a name="ln618"> </a>
<a name="ln619">//---------------------------------------------------------</a>
<a name="ln620">//   parseHarmony</a>
<a name="ln621">//    determine root and bass tpc &amp; case</a>
<a name="ln622">//    compare body of chordname against chord list</a>
<a name="ln623">//    return true if chord is recognized</a>
<a name="ln624">//---------------------------------------------------------</a>
<a name="ln625"> </a>
<a name="ln626">const ChordDescription* Harmony::parseHarmony(const QString&amp; ss, int* root, int* base, bool syntaxOnly)</a>
<a name="ln627">      {</a>
<a name="ln628">      _id = -1;</a>
<a name="ln629">      if (_parsedForm) {</a>
<a name="ln630">            delete _parsedForm;</a>
<a name="ln631">            _parsedForm = 0;</a>
<a name="ln632">            }</a>
<a name="ln633">      _textName.clear();</a>
<a name="ln634">      bool useLiteral = false;</a>
<a name="ln635">      if (ss.endsWith(' '))</a>
<a name="ln636">            useLiteral = true;</a>
<a name="ln637"> </a>
<a name="ln638">      if (_harmonyType == HarmonyType::ROMAN) {</a>
<a name="ln639">            _userName = ss;</a>
<a name="ln640">            _textName = ss;</a>
<a name="ln641">            *root = Tpc::TPC_INVALID;</a>
<a name="ln642">            *base = Tpc::TPC_INVALID;</a>
<a name="ln643">            return 0;</a>
<a name="ln644">            }</a>
<a name="ln645"> </a>
<a name="ln646">      // pre-process for parentheses</a>
<a name="ln647">      QString s = ss.simplified();</a>
<a name="ln648">      if ((_leftParen = s.startsWith('(')))</a>
<a name="ln649">            s.remove(0,1);</a>
<a name="ln650">      if ((_rightParen = (s.endsWith(')') &amp;&amp; s.count('(') &lt; s.count(')'))))</a>
<a name="ln651">            s.remove(s.size()-1,1);</a>
<a name="ln652">      if (_leftParen || _rightParen)</a>
<a name="ln653">            s = s.simplified();     // in case of spaces inside parentheses</a>
<a name="ln654">      if (s.isEmpty())</a>
<a name="ln655">            return 0;</a>
<a name="ln656"> </a>
<a name="ln657">      // pre-process for lower case minor chords</a>
<a name="ln658">      bool preferMinor;</a>
<a name="ln659">      if (score()-&gt;styleB(Sid::lowerCaseMinorChords) &amp;&amp; s[0].isLower())</a>
<a name="ln660">            preferMinor = true;</a>
<a name="ln661">      else</a>
<a name="ln662">            preferMinor = false;</a>
<a name="ln663"> </a>
<a name="ln664">      if (_harmonyType == HarmonyType::NASHVILLE) {</a>
<a name="ln665">            int n = 0;</a>
<a name="ln666">            if (s[0].isDigit())</a>
<a name="ln667">                  n = 1;</a>
<a name="ln668">            else if (s[1].isDigit())</a>
<a name="ln669">                  n = 2;</a>
<a name="ln670">            _function = s.mid(0, n);</a>
<a name="ln671">            s = s.mid(n);</a>
<a name="ln672">            *root = Tpc::TPC_INVALID;</a>
<a name="ln673">            *base = Tpc::TPC_INVALID;</a>
<a name="ln674">            }</a>
<a name="ln675">      else {</a>
<a name="ln676">            determineRootBaseSpelling();</a>
<a name="ln677">            int idx;</a>
<a name="ln678">            int r = convertNote(s, _rootSpelling, _rootCase, idx);</a>
<a name="ln679">            if (r == Tpc::TPC_INVALID) {</a>
<a name="ln680">                  if (s[0] == '/')</a>
<a name="ln681">                        idx = 0;</a>
<a name="ln682">                  else {</a>
<a name="ln683">                        qDebug(&quot;failed &lt;%s&gt;&quot;, qPrintable(ss));</a>
<a name="ln684">                        _userName = s;</a>
<a name="ln685">                        _textName = s;</a>
<a name="ln686">                        return 0;</a>
<a name="ln687">                        }</a>
<a name="ln688">                  }</a>
<a name="ln689">            *root = r;</a>
<a name="ln690">            *base = Tpc::TPC_INVALID;</a>
<a name="ln691">            int slash = s.lastIndexOf('/');</a>
<a name="ln692">            if (slash != -1) {</a>
<a name="ln693">                  QString bs = s.mid(slash + 1).simplified();</a>
<a name="ln694">                  s = s.mid(idx, slash - idx).simplified();</a>
<a name="ln695">                  int idx2;</a>
<a name="ln696">                  *base = convertNote(bs, _baseSpelling, _baseCase, idx2);</a>
<a name="ln697">                  if (idx2 != bs.size())</a>
<a name="ln698">                        *base = Tpc::TPC_INVALID;</a>
<a name="ln699">                  if (*base == Tpc::TPC_INVALID) {</a>
<a name="ln700">                        // if what follows after slash is not (just) a TPC</a>
<a name="ln701">                        // then reassemble chord and try to parse with the slash</a>
<a name="ln702">                        s = s + &quot;/&quot; + bs;</a>
<a name="ln703">                        }</a>
<a name="ln704">                  }</a>
<a name="ln705">            else</a>
<a name="ln706">                  s = s.mid(idx);   // don't simplify; keep leading space before extension if present</a>
<a name="ln707">            }</a>
<a name="ln708"> </a>
<a name="ln709">      _userName = s;</a>
<a name="ln710">      const ChordList* cl = score()-&gt;style().chordList();</a>
<a name="ln711">      const ChordDescription* cd = 0;</a>
<a name="ln712">      if (useLiteral)</a>
<a name="ln713">            cd = descr(s);</a>
<a name="ln714">      else {</a>
<a name="ln715">            _parsedForm = new ParsedChord();</a>
<a name="ln716">            _parsedForm-&gt;parse(s, cl, syntaxOnly, preferMinor);</a>
<a name="ln717">            // parser prepends &quot;=&quot; to name of implied minor chords</a>
<a name="ln718">            // use this here as well</a>
<a name="ln719">            if (preferMinor)</a>
<a name="ln720">                  s = _parsedForm-&gt;name();</a>
<a name="ln721">            // look up to see if we already have a descriptor (chord has been used before)</a>
<a name="ln722">            cd = descr(s, _parsedForm);</a>
<a name="ln723">            }</a>
<a name="ln724">      if (cd) {</a>
<a name="ln725">            // descriptor found; use its information</a>
<a name="ln726">            _id = cd-&gt;id;</a>
<a name="ln727">            if (!cd-&gt;names.empty())</a>
<a name="ln728">                  _textName = cd-&gt;names.front();</a>
<a name="ln729">            }</a>
<a name="ln730">      else {</a>
<a name="ln731">            // no descriptor yet; just set textname</a>
<a name="ln732">            // we will generate descriptor later if necessary (when we are done editing this chord)</a>
<a name="ln733">            _textName = s;</a>
<a name="ln734">            }</a>
<a name="ln735">      return cd;</a>
<a name="ln736">      }</a>
<a name="ln737"> </a>
<a name="ln738">//---------------------------------------------------------</a>
<a name="ln739">//   startEdit</a>
<a name="ln740">//---------------------------------------------------------</a>
<a name="ln741"> </a>
<a name="ln742">void Harmony::startEdit(EditData&amp; ed)</a>
<a name="ln743">      {</a>
<a name="ln744">      if (!textList.empty()) {</a>
<a name="ln745">            // convert chord symbol to plain text</a>
<a name="ln746">            setPlainText(harmonyName());</a>
<a name="ln747">            // clear rendering</a>
<a name="ln748">            for (const TextSegment* t : textList)</a>
<a name="ln749">                  delete t;</a>
<a name="ln750">            textList.clear();</a>
<a name="ln751">            }</a>
<a name="ln752"> </a>
<a name="ln753">      // layout as text, without position reset</a>
<a name="ln754">      TextBase::layout1();</a>
<a name="ln755">      triggerLayout();</a>
<a name="ln756"> </a>
<a name="ln757">      TextBase::startEdit(ed);</a>
<a name="ln758">      }</a>
<a name="ln759"> </a>
<a name="ln760">//---------------------------------------------------------</a>
<a name="ln761">//   edit</a>
<a name="ln762">//---------------------------------------------------------</a>
<a name="ln763"> </a>
<a name="ln764">bool Harmony::edit(EditData&amp; ed)</a>
<a name="ln765">      {</a>
<a name="ln766">      if (ed.key == Qt::Key_Return)</a>
<a name="ln767">            return true; // Harmony only single line</a>
<a name="ln768"> </a>
<a name="ln769">      bool rv = TextBase::edit(ed);</a>
<a name="ln770"> </a>
<a name="ln771">      // layout as text, without position reset</a>
<a name="ln772">      TextBase::layout1();</a>
<a name="ln773">      triggerLayout();</a>
<a name="ln774"> </a>
<a name="ln775">      // check spelling</a>
<a name="ln776">      int root = TPC_INVALID;</a>
<a name="ln777">      int base = TPC_INVALID;</a>
<a name="ln778">      QString str = xmlText();</a>
<a name="ln779">      showSpell = !str.isEmpty() &amp;&amp; !parseHarmony(str, &amp;root, &amp;base, true) &amp;&amp; root == TPC_INVALID &amp;&amp; _harmonyType == HarmonyType::STANDARD;</a>
<a name="ln780">      if (showSpell)</a>
<a name="ln781">            qDebug(&quot;bad spell&quot;);</a>
<a name="ln782"> </a>
<a name="ln783">      return rv;</a>
<a name="ln784">      }</a>
<a name="ln785"> </a>
<a name="ln786">//---------------------------------------------------------</a>
<a name="ln787">//   endEdit</a>
<a name="ln788">//---------------------------------------------------------</a>
<a name="ln789"> </a>
<a name="ln790">void Harmony::endEdit(EditData&amp; ed)</a>
<a name="ln791">      {</a>
<a name="ln792">      // complete editing: generate xml text, set Pid::TEXT, perform initial layout</a>
<a name="ln793">      // if text has changed, this also triggers setHarmony() which renders chord symbol</a>
<a name="ln794">      // but any rendering or layout performed here is tentative,</a>
<a name="ln795">      // we may still need to substitute special characters,</a>
<a name="ln796">      // and that cannot be until after editing is completed</a>
<a name="ln797">      TextBase::endEdit(ed);</a>
<a name="ln798"> </a>
<a name="ln799">      // get plain text</a>
<a name="ln800">      QString s = plainText();</a>
<a name="ln801"> </a>
<a name="ln802">      // if user explicitly added symbols to the text,</a>
<a name="ln803">      // convert them back to their respective replacement texts</a>
<a name="ln804">      if (harmonyType() != HarmonyType::ROMAN) {</a>
<a name="ln805">            s.replace(&quot;\u1d12b&quot;, &quot;bb&quot;); // double-flat</a>
<a name="ln806">            s.replace(&quot;\u266d&quot;,  &quot;b&quot;);  // flat</a>
<a name="ln807">            s.replace(&quot;\ue260&quot;,  &quot;b&quot;);  // flat</a>
<a name="ln808">            // do not replace natural sign</a>
<a name="ln809">            // (right now adding the symbol explicitly is the only way to force a natural sign to appear at all)</a>
<a name="ln810">            //s.replace(&quot;\u266e&quot;,  &quot;n&quot;);  // natural, if one day we support that too</a>
<a name="ln811">            //s.replace(&quot;\ue261&quot;,  &quot;n&quot;);  // natural, if one day we support that too</a>
<a name="ln812">            s.replace(&quot;\u266f&quot;,  &quot;#&quot;);  // sharp</a>
<a name="ln813">            s.replace(&quot;\ue262&quot;,  &quot;#&quot;);  // sharp</a>
<a name="ln814">            s.replace(&quot;\u1d12a&quot;, &quot;x&quot;);  // double-sharp</a>
<a name="ln815">            s.replace(&quot;\u0394&quot;,  &quot;^&quot;);  // &amp;Delta;</a>
<a name="ln816">            s.replace(&quot;\u00d0&quot;,  &quot;o&quot;);  // &amp;deg;</a>
<a name="ln817">            s.replace(&quot;\u00f8&quot;,  &quot;0&quot;);  // &amp;oslash;</a>
<a name="ln818">            s.replace(&quot;\u00d8&quot;,  &quot;0&quot;);  // &amp;Oslash;</a>
<a name="ln819">            }</a>
<a name="ln820">      else {</a>
<a name="ln821">            s.replace(&quot;\ue260&quot;,  &quot;\u266d&quot;);     // flat</a>
<a name="ln822">            s.replace(&quot;\ue261&quot;,  &quot;\u266e&quot;);     // natural</a>
<a name="ln823">            s.replace(&quot;\ue262&quot;,  &quot;\u266f&quot;);     // sharp</a>
<a name="ln824">            }</a>
<a name="ln825"> </a>
<a name="ln826">      // render and layout chord symbol</a>
<a name="ln827">      // (needs to be done here if text hasn't changed, or redone if replacemens were performed above)</a>
<a name="ln828">      score()-&gt;startCmd();</a>
<a name="ln829">      setHarmony(s);</a>
<a name="ln830">      layout1();</a>
<a name="ln831">      triggerLayout();</a>
<a name="ln832">      score()-&gt;endCmd();</a>
<a name="ln833"> </a>
<a name="ln834">      // disable spell check</a>
<a name="ln835">      showSpell = false;</a>
<a name="ln836"> </a>
<a name="ln837">      if (links()) {</a>
<a name="ln838">            for (ScoreElement* e : *links()) {</a>
<a name="ln839">                  if (e == this)</a>
<a name="ln840">                        continue;</a>
<a name="ln841">                  Harmony* h = toHarmony(e);</a>
<a name="ln842">                  // transpose if necessary</a>
<a name="ln843">                  // at this point chord will already have been rendered in same key as original</a>
<a name="ln844">                  // (as a result of TextBase::endEdit() calling setText() for linked elements)</a>
<a name="ln845">                  // we may now need to change the TPC's and the text, and re-render</a>
<a name="ln846">                  if (score()-&gt;styleB(Sid::concertPitch) != h-&gt;score()-&gt;styleB(Sid::concertPitch)) {</a>
<a name="ln847">                        Part* partDest = h-&gt;part();</a>
<a name="ln848">                        Segment* segment = toSegment(parent());</a>
<a name="ln849">                        Fraction tick = segment ? segment-&gt;tick() : Fraction(-1,1);</a>
<a name="ln850">                        Interval interval = partDest-&gt;instrument(tick)-&gt;transpose();</a>
<a name="ln851">                        if (!interval.isZero()) {</a>
<a name="ln852">                              if (!h-&gt;score()-&gt;styleB(Sid::concertPitch))</a>
<a name="ln853">                                    interval.flip();</a>
<a name="ln854">                              int rootTpc = transposeTpc(h-&gt;rootTpc(), interval, true);</a>
<a name="ln855">                              int baseTpc = transposeTpc(h-&gt;baseTpc(), interval, true);</a>
<a name="ln856">                              //score()-&gt;undoTransposeHarmony(h, rootTpc, baseTpc);</a>
<a name="ln857">                              h-&gt;setRootTpc(rootTpc);</a>
<a name="ln858">                              h-&gt;setBaseTpc(baseTpc);</a>
<a name="ln859">                              h-&gt;setPlainText(h-&gt;harmonyName());</a>
<a name="ln860">                              h-&gt;setHarmony(h-&gt;plainText());</a>
<a name="ln861">                              h-&gt;triggerLayout();</a>
<a name="ln862">                              }</a>
<a name="ln863">                        }</a>
<a name="ln864">                  }</a>
<a name="ln865">            }</a>
<a name="ln866">      }</a>
<a name="ln867"> </a>
<a name="ln868">//---------------------------------------------------------</a>
<a name="ln869">//   setHarmony</a>
<a name="ln870">//---------------------------------------------------------</a>
<a name="ln871"> </a>
<a name="ln872">void Harmony::setHarmony(const QString&amp; s)</a>
<a name="ln873">      {</a>
<a name="ln874">      int r, b;</a>
<a name="ln875">      const ChordDescription* cd = parseHarmony(s, &amp;r, &amp;b);</a>
<a name="ln876">      if (!cd &amp;&amp; _parsedForm &amp;&amp; _parsedForm-&gt;parseable()) {</a>
<a name="ln877">            // our first time encountering this chord</a>
<a name="ln878">            // generate a descriptor and use it</a>
<a name="ln879">            cd = generateDescription();</a>
<a name="ln880">            _id = cd-&gt;id;</a>
<a name="ln881">            }</a>
<a name="ln882">      if (cd) {</a>
<a name="ln883">            setRootTpc(r);</a>
<a name="ln884">            setBaseTpc(b);</a>
<a name="ln885">            render();</a>
<a name="ln886">            }</a>
<a name="ln887">      else {</a>
<a name="ln888">            // unparseable chord, render as plain text</a>
<a name="ln889">            for (const TextSegment* ts : textList)</a>
<a name="ln890">                  delete ts;</a>
<a name="ln891">            textList.clear();</a>
<a name="ln892">            setRootTpc(Tpc::TPC_INVALID);</a>
<a name="ln893">            setBaseTpc(Tpc::TPC_INVALID);</a>
<a name="ln894">            _id = -1;</a>
<a name="ln895">            render();</a>
<a name="ln896">            }</a>
<a name="ln897">      }</a>
<a name="ln898"> </a>
<a name="ln899">//---------------------------------------------------------</a>
<a name="ln900">//   baseLine</a>
<a name="ln901">//---------------------------------------------------------</a>
<a name="ln902"> </a>
<a name="ln903">qreal Harmony::baseLine() const</a>
<a name="ln904">      {</a>
<a name="ln905">      return (textList.empty()) ? TextBase::baseLine() : 0.0;</a>
<a name="ln906">      }</a>
<a name="ln907"> </a>
<a name="ln908">//---------------------------------------------------------</a>
<a name="ln909">//   text</a>
<a name="ln910">//---------------------------------------------------------</a>
<a name="ln911"> </a>
<a name="ln912">QString HDegree::text() const</a>
<a name="ln913">      {</a>
<a name="ln914">      if (_type == HDegreeType::UNDEF)</a>
<a name="ln915">            return QString();</a>
<a name="ln916">      const char* d = 0;</a>
<a name="ln917">      switch(_type) {</a>
<a name="ln918">            case HDegreeType::UNDEF: break;</a>
<a name="ln919">            case HDegreeType::ADD:         d= &quot;add&quot;; break;</a>
<a name="ln920">            case HDegreeType::ALTER:       d= &quot;alt&quot;; break;</a>
<a name="ln921">            case HDegreeType::SUBTRACT:    d= &quot;sub&quot;; break;</a>
<a name="ln922">            }</a>
<a name="ln923">      QString degree(d);</a>
<a name="ln924">      switch(_alter) {</a>
<a name="ln925">            case -1:          degree += &quot;b&quot;; break;</a>
<a name="ln926">            case 1:           degree += &quot;#&quot;; break;</a>
<a name="ln927">            default:          break;</a>
<a name="ln928">            }</a>
<a name="ln929">      QString s = QString(&quot;%1&quot;).arg(_value);</a>
<a name="ln930">      QString ss = degree + s;</a>
<a name="ln931">      return ss;</a>
<a name="ln932">      }</a>
<a name="ln933"> </a>
<a name="ln934">//---------------------------------------------------------</a>
<a name="ln935">//   fromXml</a>
<a name="ln936">//    lookup harmony in harmony data base</a>
<a name="ln937">//    using musicXml &quot;kind&quot; string and degree list</a>
<a name="ln938">//---------------------------------------------------------</a>
<a name="ln939"> </a>
<a name="ln940">const ChordDescription* Harmony::fromXml(const QString&amp; kind, const QList&lt;HDegree&gt;&amp; dl)</a>
<a name="ln941">      {</a>
<a name="ln942">      QStringList degrees;</a>
<a name="ln943"> </a>
<a name="ln944">      foreach(const HDegree&amp; d, dl)</a>
<a name="ln945">            degrees.append(d.text());</a>
<a name="ln946"> </a>
<a name="ln947">      QString lowerCaseKind = kind.toLower();</a>
<a name="ln948">      const ChordList* cl = score()-&gt;style().chordList();</a>
<a name="ln949">      foreach(const ChordDescription&amp; cd, *cl) {</a>
<a name="ln950">            QString k     = cd.xmlKind;</a>
<a name="ln951">            QString lowerCaseK = k.toLower(); // required for xmlKind Tristan</a>
<a name="ln952">            QStringList d = cd.xmlDegrees;</a>
<a name="ln953">            if ((lowerCaseKind == lowerCaseK) &amp;&amp; (d == degrees)) {</a>
<a name="ln954">//                  qDebug(&quot;harmony found in db: %s %s -&gt; %d&quot;, qPrintable(kind), qPrintable(degrees), cd-&gt;id);</a>
<a name="ln955">                  return &amp;cd;</a>
<a name="ln956">                  }</a>
<a name="ln957">            }</a>
<a name="ln958">      return 0;</a>
<a name="ln959">      }</a>
<a name="ln960"> </a>
<a name="ln961">//---------------------------------------------------------</a>
<a name="ln962">//   fromXml</a>
<a name="ln963">//    lookup harmony in harmony data base</a>
<a name="ln964">//    using musicXml &quot;kind&quot; string only</a>
<a name="ln965">//---------------------------------------------------------</a>
<a name="ln966"> </a>
<a name="ln967">const ChordDescription* Harmony::fromXml(const QString&amp; kind)</a>
<a name="ln968">      {</a>
<a name="ln969">      QString lowerCaseKind = kind.toLower();</a>
<a name="ln970">      const ChordList* cl = score()-&gt;style().chordList();</a>
<a name="ln971">      foreach(const ChordDescription&amp; cd, *cl) {</a>
<a name="ln972">            if (lowerCaseKind == cd.xmlKind)</a>
<a name="ln973">                  return &amp;cd;</a>
<a name="ln974">            }</a>
<a name="ln975">      return 0;</a>
<a name="ln976">      }</a>
<a name="ln977"> </a>
<a name="ln978">//---------------------------------------------------------</a>
<a name="ln979">//   fromXml</a>
<a name="ln980">//    construct harmony directly from XML</a>
<a name="ln981">//    build name first</a>
<a name="ln982">//    then generate chord description from that</a>
<a name="ln983">//---------------------------------------------------------</a>
<a name="ln984"> </a>
<a name="ln985">const ChordDescription* Harmony::fromXml(const QString&amp; kind, const QString&amp; kindText, const QString&amp; symbols, const QString&amp; parens, const QList&lt;HDegree&gt;&amp; dl)</a>
<a name="ln986">      {</a>
<a name="ln987">      ParsedChord* pc = new ParsedChord;</a>
<a name="ln988">      _textName = pc-&gt;fromXml(kind, kindText, symbols, parens, dl, score()-&gt;style().chordList());</a>
<a name="ln989">      _parsedForm = pc;</a>
<a name="ln990">      const ChordDescription* cd = getDescription(_textName,pc);</a>
<a name="ln991">      return cd;</a>
<a name="ln992">      }</a>
<a name="ln993"> </a>
<a name="ln994">//---------------------------------------------------------</a>
<a name="ln995">//   descr</a>
<a name="ln996">//    look up id in chord list</a>
<a name="ln997">//    return chord description if found, or null</a>
<a name="ln998">//---------------------------------------------------------</a>
<a name="ln999"> </a>
<a name="ln1000">const ChordDescription* Harmony::descr() const</a>
<a name="ln1001">      {</a>
<a name="ln1002">      return score()-&gt;style().chordDescription(_id);</a>
<a name="ln1003">      }</a>
<a name="ln1004"> </a>
<a name="ln1005">//---------------------------------------------------------</a>
<a name="ln1006">//   descr</a>
<a name="ln1007">//    look up name in chord list</a>
<a name="ln1008">//    optionally look up by parsed chord as fallback</a>
<a name="ln1009">//    return chord description if found, or null</a>
<a name="ln1010">//---------------------------------------------------------</a>
<a name="ln1011"> </a>
<a name="ln1012">const ChordDescription* Harmony::descr(const QString&amp; name, const ParsedChord* pc) const</a>
<a name="ln1013">      {</a>
<a name="ln1014">      const ChordList* cl = score()-&gt;style().chordList();</a>
<a name="ln1015">      const ChordDescription* match = 0;</a>
<a name="ln1016">      if (cl) {</a>
<a name="ln1017">            foreach (const ChordDescription&amp; cd, *cl) {</a>
<a name="ln1018">                  for (const QString&amp; s : cd.names) {</a>
<a name="ln1019">                        if (s == name)</a>
<a name="ln1020">                              return &amp;cd;</a>
<a name="ln1021">                        else if (pc) {</a>
<a name="ln1022">                              for (const ParsedChord&amp; sParsed : cd.parsedChords) {</a>
<a name="ln1023">                                    if (sParsed == *pc)</a>
<a name="ln1024">                                          match = &amp;cd;</a>
<a name="ln1025">                                    }</a>
<a name="ln1026">                              }</a>
<a name="ln1027">                        }</a>
<a name="ln1028">                  }</a>
<a name="ln1029">            }</a>
<a name="ln1030">      // exact match failed, so fall back on parsed match if one was found</a>
<a name="ln1031">      return match;</a>
<a name="ln1032">      }</a>
<a name="ln1033"> </a>
<a name="ln1034">//---------------------------------------------------------</a>
<a name="ln1035">//   getDescription</a>
<a name="ln1036">//    look up id in chord list</a>
<a name="ln1037">//    return chord description if found</a>
<a name="ln1038">//    if not found, and chord is parseable,</a>
<a name="ln1039">//    generate a new chord description</a>
<a name="ln1040">//    and add to chord list</a>
<a name="ln1041">//---------------------------------------------------------</a>
<a name="ln1042"> </a>
<a name="ln1043">const ChordDescription* Harmony::getDescription()</a>
<a name="ln1044">      {</a>
<a name="ln1045">      const ChordDescription* cd = descr();</a>
<a name="ln1046">      if (cd &amp;&amp; !cd-&gt;names.empty())</a>
<a name="ln1047">            _textName = cd-&gt;names.front();</a>
<a name="ln1048">      else if (_textName != &quot;&quot;) {</a>
<a name="ln1049">            cd = generateDescription();</a>
<a name="ln1050">            _id = cd-&gt;id;</a>
<a name="ln1051">            }</a>
<a name="ln1052">      return cd;</a>
<a name="ln1053">      }</a>
<a name="ln1054"> </a>
<a name="ln1055">//---------------------------------------------------------</a>
<a name="ln1056">//   getDescription</a>
<a name="ln1057">//    same but lookup by name and optionally parsed chord</a>
<a name="ln1058">//---------------------------------------------------------</a>
<a name="ln1059"> </a>
<a name="ln1060">const ChordDescription* Harmony::getDescription(const QString&amp; name, const ParsedChord* pc)</a>
<a name="ln1061">      {</a>
<a name="ln1062">      const ChordDescription* cd = descr(name, pc);</a>
<a name="ln1063">      if (cd)</a>
<a name="ln1064">            _id = cd-&gt;id;</a>
<a name="ln1065">      else {</a>
<a name="ln1066">            cd = generateDescription();</a>
<a name="ln1067">            _id = cd-&gt;id;</a>
<a name="ln1068">            }</a>
<a name="ln1069">      return cd;</a>
<a name="ln1070">      }</a>
<a name="ln1071"> </a>
<a name="ln1072">//---------------------------------------------------------</a>
<a name="ln1073">//   generateDescription</a>
<a name="ln1074">//    generate new chord description from _textName</a>
<a name="ln1075">//    add to chord list using private id</a>
<a name="ln1076">//---------------------------------------------------------</a>
<a name="ln1077"> </a>
<a name="ln1078">const ChordDescription* Harmony::generateDescription()</a>
<a name="ln1079">      {</a>
<a name="ln1080">      ChordList* cl = score()-&gt;style().chordList();</a>
<a name="ln1081">      ChordDescription cd(_textName);</a>
<a name="ln1082">      cd.complete(_parsedForm, cl);</a>
<a name="ln1083">      // remove parsed chord from description</a>
<a name="ln1084">      // so we will only match it literally in the future</a>
<a name="ln1085">      cd.parsedChords.clear();</a>
<a name="ln1086">      return &amp;*cl-&gt;insert(cd.id, cd);</a>
<a name="ln1087">      }</a>
<a name="ln1088"> </a>
<a name="ln1089">//---------------------------------------------------------</a>
<a name="ln1090">//   layout</a>
<a name="ln1091">//---------------------------------------------------------</a>
<a name="ln1092"> </a>
<a name="ln1093">void Harmony::layout()</a>
<a name="ln1094">      {</a>
<a name="ln1095">      if (!parent()) {</a>
<a name="ln1096">            setPos(0.0, 0.0);</a>
<a name="ln1097">            setOffset(0.0, 0.0);</a>
<a name="ln1098">            layout1();</a>
<a name="ln1099">            return;</a>
<a name="ln1100">            }</a>
<a name="ln1101">      //if (isStyled(Pid::OFFSET))</a>
<a name="ln1102">      //      setOffset(propertyDefault(Pid::OFFSET).toPointF());</a>
<a name="ln1103"> </a>
<a name="ln1104">      if (placeBelow())</a>
<a name="ln1105">            rypos() = staff() ? staff()-&gt;height() : 0.0;</a>
<a name="ln1106">      else</a>
<a name="ln1107">            rypos() = 0.0;</a>
<a name="ln1108">      layout1();</a>
<a name="ln1109"> </a>
<a name="ln1110">      qreal yy = ipos().y();</a>
<a name="ln1111">      qreal xx = 0.0;</a>
<a name="ln1112"> </a>
<a name="ln1113">      if (parent()-&gt;isFretDiagram()) {</a>
<a name="ln1114">            if (isStyled(Pid::ALIGN))</a>
<a name="ln1115">                  setAlign(Align::HCENTER | Align::BASELINE);</a>
<a name="ln1116">            yy = -score()-&gt;styleP(Sid::harmonyFretDist);</a>
<a name="ln1117">            }</a>
<a name="ln1118"> </a>
<a name="ln1119">      qreal hb = lineHeight() - TextBase::baseLine();</a>
<a name="ln1120">      if (align() &amp; Align::BOTTOM)</a>
<a name="ln1121">            yy -= hb;</a>
<a name="ln1122">      else if (align() &amp; Align::VCENTER) {</a>
<a name="ln1123">            yy -= hb;</a>
<a name="ln1124">            yy += (height() * .5);</a>
<a name="ln1125">            }</a>
<a name="ln1126">      else if (align() &amp; Align::BASELINE) {</a>
<a name="ln1127">            }</a>
<a name="ln1128">      else { // Align::TOP</a>
<a name="ln1129">            yy -= hb;</a>
<a name="ln1130">            yy += height();</a>
<a name="ln1131">            }</a>
<a name="ln1132"> </a>
<a name="ln1133">      qreal cw = symWidth(SymId::noteheadBlack);</a>
<a name="ln1134">      if (align() &amp; Align::RIGHT) {</a>
<a name="ln1135">            xx += cw;</a>
<a name="ln1136">            xx -= width();</a>
<a name="ln1137">            }</a>
<a name="ln1138">      else if (align() &amp; Align::HCENTER) {</a>
<a name="ln1139">            if (parent()-&gt;isFretDiagram()) {</a>
<a name="ln1140">                  FretDiagram* fd = toFretDiagram(parent());</a>
<a name="ln1141">                  xx += fd-&gt;centerX();</a>
<a name="ln1142">                  xx -= width() * .5;</a>
<a name="ln1143">                  }</a>
<a name="ln1144">            else {</a>
<a name="ln1145">                  xx += (cw * .5);</a>
<a name="ln1146">                  xx -= (width() * .5);</a>
<a name="ln1147">                  }</a>
<a name="ln1148">            }</a>
<a name="ln1149"> </a>
<a name="ln1150">      setPos(xx, yy);</a>
<a name="ln1151">      }</a>
<a name="ln1152"> </a>
<a name="ln1153">//---------------------------------------------------------</a>
<a name="ln1154">//   layout1</a>
<a name="ln1155">//---------------------------------------------------------</a>
<a name="ln1156"> </a>
<a name="ln1157">void Harmony::layout1()</a>
<a name="ln1158">      {</a>
<a name="ln1159">      if (isLayoutInvalid())</a>
<a name="ln1160">            createLayout();</a>
<a name="ln1161">      if (textBlockList().empty())</a>
<a name="ln1162">            textBlockList().append(TextBlock());</a>
<a name="ln1163">      calculateBoundingRect();    // for normal symbols this is called in layout: computeMinWidth()</a>
<a name="ln1164">      if (hasFrame())</a>
<a name="ln1165">            layoutFrame();</a>
<a name="ln1166">      score()-&gt;addRefresh(canvasBoundingRect());</a>
<a name="ln1167">      }</a>
<a name="ln1168"> </a>
<a name="ln1169">//---------------------------------------------------------</a>
<a name="ln1170">//   calculateBoundingRect</a>
<a name="ln1171">//---------------------------------------------------------</a>
<a name="ln1172"> </a>
<a name="ln1173">void Harmony::calculateBoundingRect()</a>
<a name="ln1174">      {</a>
<a name="ln1175">      if (textList.empty())</a>
<a name="ln1176">            TextBase::layout1();</a>
<a name="ln1177">      else {</a>
<a name="ln1178">            QRectF bb;</a>
<a name="ln1179">            for (const TextSegment* ts : textList)</a>
<a name="ln1180">                  bb |= ts-&gt;tightBoundingRect().translated(ts-&gt;x, ts-&gt;y);</a>
<a name="ln1181">            setbbox(bb);</a>
<a name="ln1182">            for (int i = 0; i &lt; rows(); ++i) {</a>
<a name="ln1183">                  TextBlock&amp; t = textBlockList()[i];</a>
<a name="ln1184"> </a>
<a name="ln1185">                  // when MS switch to editing Harmony MS draws text defined by textBlockList().</a>
<a name="ln1186">                  // When MS switches back to normal state it draws text from textList</a>
<a name="ln1187">                  // To correct placement of text in editing we need to layout textBlockList() elements</a>
<a name="ln1188">                  t.layout(this);</a>
<a name="ln1189">                  for (auto&amp; s : t.fragments()) {</a>
<a name="ln1190">                        s.pos = { 0, 0 };</a>
<a name="ln1191">                        }</a>
<a name="ln1192">                  }</a>
<a name="ln1193">            }</a>
<a name="ln1194">      }</a>
<a name="ln1195"> </a>
<a name="ln1196">//---------------------------------------------------------</a>
<a name="ln1197">//   draw</a>
<a name="ln1198">//---------------------------------------------------------</a>
<a name="ln1199"> </a>
<a name="ln1200">void Harmony::draw(QPainter* painter) const</a>
<a name="ln1201">      {</a>
<a name="ln1202">      // painter-&gt;setPen(curColor());</a>
<a name="ln1203">      if (textList.empty()) {</a>
<a name="ln1204">            TextBase::draw(painter);</a>
<a name="ln1205">            return;</a>
<a name="ln1206">            }</a>
<a name="ln1207">      if (hasFrame()) {</a>
<a name="ln1208">            if (frameWidth().val() != 0.0) {</a>
<a name="ln1209">                  QColor color = frameColor();</a>
<a name="ln1210">                  QPen pen(color, frameWidth().val() * spatium(), Qt::SolidLine,</a>
<a name="ln1211">                     Qt::SquareCap, Qt::MiterJoin);</a>
<a name="ln1212">                  painter-&gt;setPen(pen);</a>
<a name="ln1213">                  }</a>
<a name="ln1214">            else</a>
<a name="ln1215">                  painter-&gt;setPen(Qt::NoPen);</a>
<a name="ln1216">            QColor bg(bgColor());</a>
<a name="ln1217">            painter-&gt;setBrush(bg.alpha() ? QBrush(bg) : Qt::NoBrush);</a>
<a name="ln1218">            if (circle())</a>
<a name="ln1219">                  painter-&gt;drawArc(frame, 0, 5760);</a>
<a name="ln1220">            else {</a>
<a name="ln1221">                  int r2 = frameRound();</a>
<a name="ln1222">                  if (r2 &gt; 99)</a>
<a name="ln1223">                        r2 = 99;</a>
<a name="ln1224">                  painter-&gt;drawRoundedRect(frame, frameRound(), r2);</a>
<a name="ln1225">                  }</a>
<a name="ln1226">            }</a>
<a name="ln1227">      painter-&gt;setBrush(Qt::NoBrush);</a>
<a name="ln1228">      QColor color = textColor();</a>
<a name="ln1229">      painter-&gt;setPen(color);</a>
<a name="ln1230">      for (const TextSegment* ts : textList) {</a>
<a name="ln1231">            QFont f(ts-&gt;font);</a>
<a name="ln1232">            f.setPointSizeF(f.pointSizeF() * MScore::pixelRatio);</a>
<a name="ln1233">            painter-&gt;setFont(f);</a>
<a name="ln1234">            painter-&gt;drawText(QPointF(ts-&gt;x, ts-&gt;y), ts-&gt;text);</a>
<a name="ln1235">            }</a>
<a name="ln1236">      }</a>
<a name="ln1237"> </a>
<a name="ln1238">//---------------------------------------------------------</a>
<a name="ln1239">//   drawEditMode</a>
<a name="ln1240">//---------------------------------------------------------</a>
<a name="ln1241"> </a>
<a name="ln1242">void Harmony::drawEditMode(QPainter* p, EditData&amp; ed)</a>
<a name="ln1243">      {</a>
<a name="ln1244">      TextBase::drawEditMode(p, ed);</a>
<a name="ln1245"> </a>
<a name="ln1246">      QColor originalColor = color();</a>
<a name="ln1247">      if (showSpell) {</a>
<a name="ln1248">            setColor(QColor(Qt::red));</a>
<a name="ln1249">            setSelected(false);</a>
<a name="ln1250">            }</a>
<a name="ln1251">      QPointF pos(canvasPos());</a>
<a name="ln1252">      p-&gt;translate(pos);</a>
<a name="ln1253">      TextBase::draw(p);</a>
<a name="ln1254">      p-&gt;translate(-pos);</a>
<a name="ln1255">      if (showSpell) {</a>
<a name="ln1256">            setColor(originalColor);</a>
<a name="ln1257">            setSelected(true);</a>
<a name="ln1258">            }</a>
<a name="ln1259">      }</a>
<a name="ln1260"> </a>
<a name="ln1261">//---------------------------------------------------------</a>
<a name="ln1262">//   TextSegment</a>
<a name="ln1263">//---------------------------------------------------------</a>
<a name="ln1264"> </a>
<a name="ln1265">TextSegment::TextSegment(const QString&amp; s, const QFont&amp; f, qreal x, qreal y)</a>
<a name="ln1266">      {</a>
<a name="ln1267">      set(s, f, x, y);</a>
<a name="ln1268">      select = false;</a>
<a name="ln1269">      }</a>
<a name="ln1270"> </a>
<a name="ln1271">//---------------------------------------------------------</a>
<a name="ln1272">//   width</a>
<a name="ln1273">//---------------------------------------------------------</a>
<a name="ln1274"> </a>
<a name="ln1275">qreal TextSegment::width() const</a>
<a name="ln1276">      {</a>
<a name="ln1277">      QFontMetricsF fm(font, MScore::paintDevice());</a>
<a name="ln1278">#if 1</a>
<a name="ln1279">      return fm.width(text);</a>
<a name="ln1280">#else</a>
<a name="ln1281">      qreal w = 0.0;</a>
<a name="ln1282">      foreach(QChar c, text) {</a>
<a name="ln1283">            // if we calculate width by character, at least skip high surrogates</a>
<a name="ln1284">            if (c.isHighSurrogate())</a>
<a name="ln1285">                  continue;</a>
<a name="ln1286">            w += fm.width(c);</a>
<a name="ln1287">            }</a>
<a name="ln1288">      return w;</a>
<a name="ln1289">#endif</a>
<a name="ln1290">      }</a>
<a name="ln1291"> </a>
<a name="ln1292">//---------------------------------------------------------</a>
<a name="ln1293">//   boundingRect</a>
<a name="ln1294">//---------------------------------------------------------</a>
<a name="ln1295"> </a>
<a name="ln1296">QRectF TextSegment::boundingRect() const</a>
<a name="ln1297">      {</a>
<a name="ln1298">      QFontMetricsF fm(font, MScore::paintDevice());</a>
<a name="ln1299">      return fm.boundingRect(text);</a>
<a name="ln1300">      }</a>
<a name="ln1301"> </a>
<a name="ln1302">//---------------------------------------------------------</a>
<a name="ln1303">//   tightBoundingRect</a>
<a name="ln1304">//---------------------------------------------------------</a>
<a name="ln1305"> </a>
<a name="ln1306">QRectF TextSegment::tightBoundingRect() const</a>
<a name="ln1307">      {</a>
<a name="ln1308">      QFontMetricsF fm(font, MScore::paintDevice());</a>
<a name="ln1309">      return fm.tightBoundingRect(text);</a>
<a name="ln1310">      }</a>
<a name="ln1311"> </a>
<a name="ln1312">//---------------------------------------------------------</a>
<a name="ln1313">//   set</a>
<a name="ln1314">//---------------------------------------------------------</a>
<a name="ln1315"> </a>
<a name="ln1316">void TextSegment::set(const QString&amp; s, const QFont&amp; f, qreal _x, qreal _y)</a>
<a name="ln1317">      {</a>
<a name="ln1318">      font = f;</a>
<a name="ln1319">      x    = _x;</a>
<a name="ln1320">      y    = _y;</a>
<a name="ln1321">      setText(s);</a>
<a name="ln1322">      }</a>
<a name="ln1323"> </a>
<a name="ln1324">//---------------------------------------------------------</a>
<a name="ln1325">//   render</a>
<a name="ln1326">//---------------------------------------------------------</a>
<a name="ln1327"> </a>
<a name="ln1328">void Harmony::render(const QString&amp; s, qreal&amp; x, qreal&amp; y)</a>
<a name="ln1329">      {</a>
<a name="ln1330">      int fontIdx = 0;</a>
<a name="ln1331">      if (!s.isEmpty()) {</a>
<a name="ln1332">            QFont f = _harmonyType != HarmonyType::ROMAN ? fontList[fontIdx] : font();</a>
<a name="ln1333">            TextSegment* ts = new TextSegment(s, f, x, y);</a>
<a name="ln1334">            textList.append(ts);</a>
<a name="ln1335">            x += ts-&gt;width();</a>
<a name="ln1336">            }</a>
<a name="ln1337">      }</a>
<a name="ln1338"> </a>
<a name="ln1339">//---------------------------------------------------------</a>
<a name="ln1340">//   render</a>
<a name="ln1341">//---------------------------------------------------------</a>
<a name="ln1342"> </a>
<a name="ln1343">void Harmony::render(const QList&lt;RenderAction&gt;&amp; renderList, qreal&amp; x, qreal&amp; y, int tpc, NoteSpellingType noteSpelling, NoteCaseType noteCase)</a>
<a name="ln1344">      {</a>
<a name="ln1345">      ChordList* chordList = score()-&gt;style().chordList();</a>
<a name="ln1346">      QStack&lt;QPointF&gt; stack;</a>
<a name="ln1347">      int fontIdx    = 0;</a>
<a name="ln1348">      qreal _spatium = spatium();</a>
<a name="ln1349">      qreal mag      = magS();</a>
<a name="ln1350"> </a>
<a name="ln1351">// qDebug(&quot;===&quot;);</a>
<a name="ln1352">      for (const RenderAction&amp; a : renderList) {</a>
<a name="ln1353">// a.print();</a>
<a name="ln1354">            if (a.type == RenderAction::RenderActionType::SET) {</a>
<a name="ln1355">                  TextSegment* ts = new TextSegment(fontList[fontIdx], x, y);</a>
<a name="ln1356">                  ChordSymbol cs = chordList-&gt;symbol(a.text);</a>
<a name="ln1357">                  if (cs.isValid()) {</a>
<a name="ln1358">                        ts-&gt;font = fontList[cs.fontIdx];</a>
<a name="ln1359">                        ts-&gt;setText(cs.value);</a>
<a name="ln1360">                        }</a>
<a name="ln1361">                  else</a>
<a name="ln1362">                        ts-&gt;setText(a.text);</a>
<a name="ln1363">                  if (_harmonyType == HarmonyType::NASHVILLE) {</a>
<a name="ln1364">                        qreal nmag = chordList-&gt;nominalMag();</a>
<a name="ln1365">                        ts-&gt;font.setPointSizeF(ts-&gt;font.pointSizeF() * nmag);</a>
<a name="ln1366">                        }</a>
<a name="ln1367">                  textList.append(ts);</a>
<a name="ln1368">                  x += ts-&gt;width();</a>
<a name="ln1369">                  }</a>
<a name="ln1370">            else if (a.type == RenderAction::RenderActionType::MOVE) {</a>
<a name="ln1371">                  x += a.movex * mag * _spatium * .2;</a>
<a name="ln1372">                  y += a.movey * mag * _spatium * .2;</a>
<a name="ln1373">                  }</a>
<a name="ln1374">            else if (a.type == RenderAction::RenderActionType::PUSH)</a>
<a name="ln1375">                  stack.push(QPointF(x,y));</a>
<a name="ln1376">            else if (a.type == RenderAction::RenderActionType::POP) {</a>
<a name="ln1377">                  if (!stack.empty()) {</a>
<a name="ln1378">                        QPointF pt = stack.pop();</a>
<a name="ln1379">                        x = pt.x();</a>
<a name="ln1380">                        y = pt.y();</a>
<a name="ln1381">                        }</a>
<a name="ln1382">                  else</a>
<a name="ln1383">                        qDebug(&quot;RenderAction::RenderActionType::POP: stack empty&quot;);</a>
<a name="ln1384">                  }</a>
<a name="ln1385">            else if (a.type == RenderAction::RenderActionType::NOTE) {</a>
<a name="ln1386">                  QString c;</a>
<a name="ln1387">                  int acc;</a>
<a name="ln1388">                  if (tpcIsValid(tpc))</a>
<a name="ln1389">                        tpc2name(tpc, noteSpelling, noteCase, c, acc);</a>
<a name="ln1390">                  else if (_function.size() &gt; 0)</a>
<a name="ln1391">                        c = _function.at(_function.size() - 1);</a>
<a name="ln1392">                  TextSegment* ts = new TextSegment(fontList[fontIdx], x, y);</a>
<a name="ln1393">                  QString lookup = &quot;note&quot; + c;</a>
<a name="ln1394">                  ChordSymbol cs = chordList-&gt;symbol(lookup);</a>
<a name="ln1395">                  if (!cs.isValid())</a>
<a name="ln1396">                        cs = chordList-&gt;symbol(c);</a>
<a name="ln1397">                  if (cs.isValid()) {</a>
<a name="ln1398">                        ts-&gt;font = fontList[cs.fontIdx];</a>
<a name="ln1399">                        ts-&gt;setText(cs.value);</a>
<a name="ln1400">                        }</a>
<a name="ln1401">                  else {</a>
<a name="ln1402">                        ts-&gt;setText(c);</a>
<a name="ln1403">                        }</a>
<a name="ln1404">                  textList.append(ts);</a>
<a name="ln1405">                  x += ts-&gt;width();</a>
<a name="ln1406">                  }</a>
<a name="ln1407">            else if (a.type == RenderAction::RenderActionType::ACCIDENTAL) {</a>
<a name="ln1408">                  QString c;</a>
<a name="ln1409">                  QString acc;</a>
<a name="ln1410">                  QString context = &quot;accidental&quot;;</a>
<a name="ln1411">                  if (tpcIsValid(tpc))</a>
<a name="ln1412">                        tpc2name(tpc, noteSpelling, noteCase, c, acc);</a>
<a name="ln1413">                  else if (_function.size() &gt; 1)</a>
<a name="ln1414">                        acc = _function.at(0);</a>
<a name="ln1415">                  // German spelling - use special symbol for accidental in TPC_B_B</a>
<a name="ln1416">                  // to allow it to be rendered as either Bb or B</a>
<a name="ln1417">                  if (tpc == Tpc::TPC_B_B &amp;&amp; noteSpelling == NoteSpellingType::GERMAN)</a>
<a name="ln1418">                        context = &quot;german_B&quot;;</a>
<a name="ln1419">                  if (acc != &quot;&quot;) {</a>
<a name="ln1420">                        TextSegment* ts = new TextSegment(fontList[fontIdx], x, y);</a>
<a name="ln1421">                        QString lookup = context + acc;</a>
<a name="ln1422">                        ChordSymbol cs = chordList-&gt;symbol(lookup);</a>
<a name="ln1423">                        if (!cs.isValid())</a>
<a name="ln1424">                              cs = chordList-&gt;symbol(acc);</a>
<a name="ln1425">                        if (cs.isValid()) {</a>
<a name="ln1426">                              ts-&gt;font = fontList[cs.fontIdx];</a>
<a name="ln1427">                              ts-&gt;setText(cs.value);</a>
<a name="ln1428">                              }</a>
<a name="ln1429">                        else</a>
<a name="ln1430">                              ts-&gt;setText(acc);</a>
<a name="ln1431">                        textList.append(ts);</a>
<a name="ln1432">                        x += ts-&gt;width();</a>
<a name="ln1433">                        }</a>
<a name="ln1434">                  }</a>
<a name="ln1435">            else</a>
<a name="ln1436">                  qDebug(&quot;unknown render action %d&quot;, static_cast&lt;int&gt;(a.type));</a>
<a name="ln1437">            }</a>
<a name="ln1438">      }</a>
<a name="ln1439"> </a>
<a name="ln1440">//---------------------------------------------------------</a>
<a name="ln1441">//   render</a>
<a name="ln1442">//    construct Chord Symbol</a>
<a name="ln1443">//---------------------------------------------------------</a>
<a name="ln1444"> </a>
<a name="ln1445">void Harmony::render()</a>
<a name="ln1446">      {</a>
<a name="ln1447">      int capo = score()-&gt;styleI(Sid::capoPosition);</a>
<a name="ln1448"> </a>
<a name="ln1449">      ChordList* chordList = score()-&gt;style().chordList();</a>
<a name="ln1450"> </a>
<a name="ln1451">      fontList.clear();</a>
<a name="ln1452">      for (const ChordFont&amp; cf : chordList-&gt;fonts) {</a>
<a name="ln1453">            QFont ff(font());</a>
<a name="ln1454">            ff.setPointSizeF(ff.pointSizeF() * cf.mag);</a>
<a name="ln1455">            if (!(cf.family.isEmpty() || cf.family == &quot;default&quot;))</a>
<a name="ln1456">                  ff.setFamily(cf.family);</a>
<a name="ln1457">            fontList.append(ff);</a>
<a name="ln1458">            }</a>
<a name="ln1459">      if (fontList.empty())</a>
<a name="ln1460">            fontList.append(font());</a>
<a name="ln1461"> </a>
<a name="ln1462">      for (const TextSegment* s : textList)</a>
<a name="ln1463">            delete s;</a>
<a name="ln1464">      textList.clear();</a>
<a name="ln1465">      qreal x = 0.0, y = 0.0;</a>
<a name="ln1466"> </a>
<a name="ln1467">      determineRootBaseSpelling();</a>
<a name="ln1468"> </a>
<a name="ln1469">      if (_leftParen)</a>
<a name="ln1470">            render(&quot;( &quot;, x, y);</a>
<a name="ln1471"> </a>
<a name="ln1472">      if (_rootTpc != Tpc::TPC_INVALID) {</a>
<a name="ln1473">            // render root</a>
<a name="ln1474">            render(chordList-&gt;renderListRoot, x, y, _rootTpc, _rootSpelling, _rootRenderCase);</a>
<a name="ln1475">            // render extension</a>
<a name="ln1476">            const ChordDescription* cd = getDescription();</a>
<a name="ln1477">            if (cd)</a>
<a name="ln1478">                  render(cd-&gt;renderList, x, y, 0);</a>
<a name="ln1479">            }</a>
<a name="ln1480">      else if (_harmonyType == HarmonyType::NASHVILLE) {</a>
<a name="ln1481">            // render function</a>
<a name="ln1482">            render(chordList-&gt;renderListFunction, x, y, _rootTpc, _rootSpelling, _rootRenderCase);</a>
<a name="ln1483">            qreal adjust = chordList-&gt;nominalAdjust();</a>
<a name="ln1484">            y += adjust * magS() * spatium() * .2;</a>
<a name="ln1485">            // render extension</a>
<a name="ln1486">            const ChordDescription* cd = getDescription();</a>
<a name="ln1487">            if (cd)</a>
<a name="ln1488">                  render(cd-&gt;renderList, x, y, 0);</a>
<a name="ln1489">            }</a>
<a name="ln1490">      else {</a>
<a name="ln1491">            render(_textName, x, y);</a>
<a name="ln1492">            }</a>
<a name="ln1493"> </a>
<a name="ln1494">      // render bass</a>
<a name="ln1495">      if (_baseTpc != Tpc::TPC_INVALID)</a>
<a name="ln1496">            render(chordList-&gt;renderListBase, x, y, _baseTpc, _baseSpelling, _baseRenderCase);</a>
<a name="ln1497"> </a>
<a name="ln1498">      if (_rootTpc != Tpc::TPC_INVALID &amp;&amp; capo &gt; 0 &amp;&amp; capo &lt; 12) {</a>
<a name="ln1499">            int tpcOffset[] = { 0, 5, -2, 3, -4, 1, 6, -1, 4, -3, 2, -5 };</a>
<a name="ln1500">            int capoRootTpc = _rootTpc + tpcOffset[capo];</a>
<a name="ln1501">            int capoBassTpc = _baseTpc;</a>
<a name="ln1502"> </a>
<a name="ln1503">            if (capoBassTpc != Tpc::TPC_INVALID)</a>
<a name="ln1504">                  capoBassTpc += tpcOffset[capo];</a>
<a name="ln1505"> </a>
<a name="ln1506">            /*</a>
<a name="ln1507">             * For guitarists, avoid x and bb in Root or Bass,</a>
<a name="ln1508">             * and also avoid E#, B#, Cb and Fb in Root.</a>
<a name="ln1509">             */</a>
<a name="ln1510">            if (capoRootTpc &lt; 8 || (capoBassTpc != Tpc::TPC_INVALID &amp;&amp; capoBassTpc &lt; 6)) {</a>
<a name="ln1511">                  capoRootTpc += 12;</a>
<a name="ln1512">                  if (capoBassTpc != Tpc::TPC_INVALID)</a>
<a name="ln1513">                        capoBassTpc += 12;</a>
<a name="ln1514">                  }</a>
<a name="ln1515">            else if (capoRootTpc &gt; 24 || (capoBassTpc != Tpc::TPC_INVALID &amp;&amp; capoBassTpc &gt; 26)) {</a>
<a name="ln1516">                  capoRootTpc -= 12;</a>
<a name="ln1517">                  if (capoBassTpc != Tpc::TPC_INVALID)</a>
<a name="ln1518">                        capoBassTpc -= 12;</a>
<a name="ln1519">                  }</a>
<a name="ln1520"> </a>
<a name="ln1521">            render(&quot;(&quot;, x, y);</a>
<a name="ln1522">            render(chordList-&gt;renderListRoot, x, y, capoRootTpc, _rootSpelling, _rootRenderCase);</a>
<a name="ln1523"> </a>
<a name="ln1524">            // render extension</a>
<a name="ln1525">            const ChordDescription* cd = getDescription();</a>
<a name="ln1526">            if (cd)</a>
<a name="ln1527">                  render(cd-&gt;renderList, x, y, 0);</a>
<a name="ln1528"> </a>
<a name="ln1529">            if (capoBassTpc != Tpc::TPC_INVALID)</a>
<a name="ln1530">                  render(chordList-&gt;renderListBase, x, y, capoBassTpc, _baseSpelling, _baseRenderCase);</a>
<a name="ln1531">            render(&quot;)&quot;, x, y);</a>
<a name="ln1532">            }</a>
<a name="ln1533"> </a>
<a name="ln1534">      if (_rightParen)</a>
<a name="ln1535">            render(&quot; )&quot;, x, y);</a>
<a name="ln1536">      }</a>
<a name="ln1537"> </a>
<a name="ln1538">//---------------------------------------------------------</a>
<a name="ln1539">//   spatiumChanged</a>
<a name="ln1540">//---------------------------------------------------------</a>
<a name="ln1541"> </a>
<a name="ln1542">void Harmony::spatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln1543">      {</a>
<a name="ln1544">      TextBase::spatiumChanged(oldValue, newValue);</a>
<a name="ln1545">      render();</a>
<a name="ln1546">      }</a>
<a name="ln1547"> </a>
<a name="ln1548">//---------------------------------------------------------</a>
<a name="ln1549">//   localSpatiumChanged</a>
<a name="ln1550">//---------------------------------------------------------</a>
<a name="ln1551"> </a>
<a name="ln1552">void Harmony::localSpatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln1553">      {</a>
<a name="ln1554">      TextBase::localSpatiumChanged(oldValue, newValue);</a>
<a name="ln1555">      render();</a>
<a name="ln1556">      }</a>
<a name="ln1557"> </a>
<a name="ln1558">//---------------------------------------------------------</a>
<a name="ln1559">//   extensionName</a>
<a name="ln1560">//---------------------------------------------------------</a>
<a name="ln1561"> </a>
<a name="ln1562">const QString&amp; Harmony::extensionName() const</a>
<a name="ln1563">      {</a>
<a name="ln1564">      return _textName;</a>
<a name="ln1565">      }</a>
<a name="ln1566"> </a>
<a name="ln1567">//---------------------------------------------------------</a>
<a name="ln1568">//   xmlKind</a>
<a name="ln1569">//---------------------------------------------------------</a>
<a name="ln1570"> </a>
<a name="ln1571">QString Harmony::xmlKind() const</a>
<a name="ln1572">      {</a>
<a name="ln1573">      const ChordDescription* cd = descr();</a>
<a name="ln1574">      return cd ? cd-&gt;xmlKind : QString();</a>
<a name="ln1575">      }</a>
<a name="ln1576"> </a>
<a name="ln1577">//---------------------------------------------------------</a>
<a name="ln1578">//   musicXmlText</a>
<a name="ln1579">//---------------------------------------------------------</a>
<a name="ln1580"> </a>
<a name="ln1581">QString Harmony::musicXmlText() const</a>
<a name="ln1582">      {</a>
<a name="ln1583">      const ChordDescription* cd = descr();</a>
<a name="ln1584">      return cd ? cd-&gt;xmlText : QString();</a>
<a name="ln1585">      }</a>
<a name="ln1586"> </a>
<a name="ln1587">//---------------------------------------------------------</a>
<a name="ln1588">//   xmlSymbols</a>
<a name="ln1589">//---------------------------------------------------------</a>
<a name="ln1590"> </a>
<a name="ln1591">QString Harmony::xmlSymbols() const</a>
<a name="ln1592">      {</a>
<a name="ln1593">      const ChordDescription* cd = descr();</a>
<a name="ln1594">      return cd ? cd-&gt;xmlSymbols : QString();</a>
<a name="ln1595">      }</a>
<a name="ln1596"> </a>
<a name="ln1597">//---------------------------------------------------------</a>
<a name="ln1598">//   xmlParens</a>
<a name="ln1599">//---------------------------------------------------------</a>
<a name="ln1600"> </a>
<a name="ln1601">QString Harmony::xmlParens() const</a>
<a name="ln1602">      {</a>
<a name="ln1603">      const ChordDescription* cd = descr();</a>
<a name="ln1604">      return cd ? cd-&gt;xmlParens : QString();</a>
<a name="ln1605">      }</a>
<a name="ln1606"> </a>
<a name="ln1607">//---------------------------------------------------------</a>
<a name="ln1608">//   xmlDegrees</a>
<a name="ln1609">//---------------------------------------------------------</a>
<a name="ln1610"> </a>
<a name="ln1611">QStringList Harmony::xmlDegrees() const</a>
<a name="ln1612">      {</a>
<a name="ln1613">      const ChordDescription* cd = descr();</a>
<a name="ln1614">      return cd ? cd-&gt;xmlDegrees : QStringList();</a>
<a name="ln1615">      }</a>
<a name="ln1616"> </a>
<a name="ln1617">//---------------------------------------------------------</a>
<a name="ln1618">//   degree</a>
<a name="ln1619">//---------------------------------------------------------</a>
<a name="ln1620"> </a>
<a name="ln1621">HDegree Harmony::degree(int i) const</a>
<a name="ln1622">      {</a>
<a name="ln1623">      return _degreeList.value(i);</a>
<a name="ln1624">      }</a>
<a name="ln1625"> </a>
<a name="ln1626">//---------------------------------------------------------</a>
<a name="ln1627">//   addDegree</a>
<a name="ln1628">//---------------------------------------------------------</a>
<a name="ln1629"> </a>
<a name="ln1630">void Harmony::addDegree(const HDegree&amp; d)</a>
<a name="ln1631">      {</a>
<a name="ln1632">      _degreeList &lt;&lt; d;</a>
<a name="ln1633">      }</a>
<a name="ln1634"> </a>
<a name="ln1635">//---------------------------------------------------------</a>
<a name="ln1636">//   numberOfDegrees</a>
<a name="ln1637">//---------------------------------------------------------</a>
<a name="ln1638"> </a>
<a name="ln1639">int Harmony::numberOfDegrees() const</a>
<a name="ln1640">      {</a>
<a name="ln1641">      return _degreeList.size();</a>
<a name="ln1642">      }</a>
<a name="ln1643"> </a>
<a name="ln1644">//---------------------------------------------------------</a>
<a name="ln1645">//   clearDegrees</a>
<a name="ln1646">//---------------------------------------------------------</a>
<a name="ln1647"> </a>
<a name="ln1648">void Harmony::clearDegrees()</a>
<a name="ln1649">      {</a>
<a name="ln1650">      _degreeList.clear();</a>
<a name="ln1651">      }</a>
<a name="ln1652"> </a>
<a name="ln1653">//---------------------------------------------------------</a>
<a name="ln1654">//   degreeList</a>
<a name="ln1655">//---------------------------------------------------------</a>
<a name="ln1656"> </a>
<a name="ln1657">const QList&lt;HDegree&gt;&amp; Harmony::degreeList() const</a>
<a name="ln1658">      {</a>
<a name="ln1659">      return _degreeList;</a>
<a name="ln1660">      }</a>
<a name="ln1661"> </a>
<a name="ln1662">//---------------------------------------------------------</a>
<a name="ln1663">//   parsedForm</a>
<a name="ln1664">//---------------------------------------------------------</a>
<a name="ln1665"> </a>
<a name="ln1666">const ParsedChord* Harmony::parsedForm()</a>
<a name="ln1667">      {</a>
<a name="ln1668">      if (!_parsedForm) {</a>
<a name="ln1669">            ChordList* cl = score()-&gt;style().chordList();</a>
<a name="ln1670">            _parsedForm = new ParsedChord();</a>
<a name="ln1671">            _parsedForm-&gt;parse(_textName, cl, false);</a>
<a name="ln1672">            }</a>
<a name="ln1673">      return _parsedForm;</a>
<a name="ln1674">      }</a>
<a name="ln1675"> </a>
<a name="ln1676">//---------------------------------------------------------</a>
<a name="ln1677">//   setHarmonyType</a>
<a name="ln1678">//---------------------------------------------------------</a>
<a name="ln1679"> </a>
<a name="ln1680">void Harmony::setHarmonyType(HarmonyType val)</a>
<a name="ln1681">      {</a>
<a name="ln1682">      _harmonyType = val;</a>
<a name="ln1683">      setPlacement(Placement(propertyDefault(Pid::PLACEMENT).toInt()));</a>
<a name="ln1684">      switch (_harmonyType) {</a>
<a name="ln1685">            case HarmonyType::STANDARD:</a>
<a name="ln1686">                  initTid(Tid::HARMONY_A);</a>
<a name="ln1687">                  break;</a>
<a name="ln1688">            case HarmonyType::ROMAN:</a>
<a name="ln1689">                  initTid(Tid::HARMONY_ROMAN);</a>
<a name="ln1690">                  break;</a>
<a name="ln1691">            case HarmonyType::NASHVILLE:</a>
<a name="ln1692">                  initTid(Tid::HARMONY_NASHVILLE);</a>
<a name="ln1693">                  break;</a>
<a name="ln1694">            }</a>
<a name="ln1695">      // TODO: convert text</a>
<a name="ln1696">      }</a>
<a name="ln1697"> </a>
<a name="ln1698">//---------------------------------------------------------</a>
<a name="ln1699">//   userName</a>
<a name="ln1700">//---------------------------------------------------------</a>
<a name="ln1701"> </a>
<a name="ln1702">QString Harmony::userName() const</a>
<a name="ln1703">      {</a>
<a name="ln1704">      switch (_harmonyType) {</a>
<a name="ln1705">            case HarmonyType::ROMAN:</a>
<a name="ln1706">                  return QObject::tr(&quot;Roman numeral&quot;);</a>
<a name="ln1707">            case HarmonyType::NASHVILLE:</a>
<a name="ln1708">                  return QObject::tr(&quot;Nashville number&quot;);</a>
<a name="ln1709">            case HarmonyType::STANDARD:</a>
<a name="ln1710">                  break;</a>
<a name="ln1711">            }</a>
<a name="ln1712">      return Element::userName();</a>
<a name="ln1713">      }</a>
<a name="ln1714"> </a>
<a name="ln1715">//---------------------------------------------------------</a>
<a name="ln1716">//   accessibleInfo</a>
<a name="ln1717">//---------------------------------------------------------</a>
<a name="ln1718"> </a>
<a name="ln1719">QString Harmony::accessibleInfo() const</a>
<a name="ln1720">      {</a>
<a name="ln1721">      return QString(&quot;%1: %2&quot;).arg(userName()).arg(harmonyName());</a>
<a name="ln1722">      }</a>
<a name="ln1723"> </a>
<a name="ln1724">//---------------------------------------------------------</a>
<a name="ln1725">//   screenReaderInfo</a>
<a name="ln1726">//---------------------------------------------------------</a>
<a name="ln1727"> </a>
<a name="ln1728">QString Harmony::screenReaderInfo() const</a>
<a name="ln1729">      {</a>
<a name="ln1730">      QString rez = userName();</a>
<a name="ln1731"> </a>
<a name="ln1732">      switch (_harmonyType) {</a>
<a name="ln1733">            case HarmonyType::ROMAN: {</a>
<a name="ln1734">                  QString aux = _textName;</a>
<a name="ln1735">                  bool hasUpper = aux.contains('I') || aux.contains('V');</a>
<a name="ln1736">                  bool hasLower = aux.contains('i') || aux.contains('v');</a>
<a name="ln1737">                  if (hasLower &amp;&amp; !hasUpper)</a>
<a name="ln1738">                        rez = QString(&quot;%1 %2&quot;).arg(rez).arg(QObject::tr(&quot;lower case&quot;));</a>
<a name="ln1739">                  aux = aux.toLower();</a>
<a name="ln1740">                  static std::vector&lt;std::pair&lt;QString, QString&gt;&gt; rnaReplacements {</a>
<a name="ln1741">                        { &quot;vii&quot;, &quot;7&quot; },</a>
<a name="ln1742">                        { &quot;vi&quot;, &quot;6&quot; },</a>
<a name="ln1743">                        { &quot;iv&quot;, &quot;4&quot; },</a>
<a name="ln1744">                        { &quot;v&quot;, &quot;5&quot; },</a>
<a name="ln1745">                        { &quot;iii&quot;, &quot;3&quot; },</a>
<a name="ln1746">                        { &quot;ii&quot;, &quot;2&quot; },</a>
<a name="ln1747">                        { &quot;i&quot;, &quot;1&quot; },</a>
<a name="ln1748">                        };</a>
<a name="ln1749">                  static std::vector&lt;std::pair&lt;QString, QString&gt;&gt; symbolReplacements {</a>
<a name="ln1750">                        { &quot;b&quot;, &quot;♭&quot; },</a>
<a name="ln1751">                        { &quot;h&quot;, &quot;♮&quot; },</a>
<a name="ln1752">                        { &quot;#&quot;, &quot;♯&quot; },</a>
<a name="ln1753">                        { &quot;bb&quot;, &quot;𝄫&quot; },</a>
<a name="ln1754">                        { &quot;##&quot;, &quot;𝄪&quot; },</a>
<a name="ln1755">                        // TODO: use SMuFL glyphs and translate</a>
<a name="ln1756">                        //{ &quot;o&quot;, &quot;&quot;},</a>
<a name="ln1757">                        //{ &quot;0&quot;, &quot;&quot;},</a>
<a name="ln1758">                        //{ &quot;\+&quot;, &quot;&quot;},</a>
<a name="ln1759">                        //{ &quot;\^&quot;, &quot;&quot;},</a>
<a name="ln1760">                        };</a>
<a name="ln1761">                  for (auto const &amp;r : rnaReplacements)</a>
<a name="ln1762">                        aux.replace(r.first, r.second);</a>
<a name="ln1763">                  for (auto const &amp;r : symbolReplacements) {</a>
<a name="ln1764">                        // only replace when not preceded by backslash</a>
<a name="ln1765">                        QString s = &quot;(?&lt;!\\\\)&quot; + r.first;</a>
<a name="ln1766">                        QRegularExpression re(s);</a>
<a name="ln1767">                        aux.replace(re, r.second);</a>
<a name="ln1768">                        }</a>
<a name="ln1769">                  // construct string one character at a time</a>
<a name="ln1770">                  for (auto c : aux)</a>
<a name="ln1771">                        rez = QString(&quot;%1 %2&quot;).arg(rez).arg(c);</a>
<a name="ln1772">                  }</a>
<a name="ln1773">                  return rez;</a>
<a name="ln1774">            case HarmonyType::NASHVILLE:</a>
<a name="ln1775">                  if (!_function.isEmpty())</a>
<a name="ln1776">                        rez = QString(&quot;%1 %2&quot;).arg(rez).arg(_function);</a>
<a name="ln1777">                  break;</a>
<a name="ln1778">            case HarmonyType::STANDARD:</a>
<a name="ln1779">            default:</a>
<a name="ln1780">                  if (_rootTpc != Tpc::TPC_INVALID)</a>
<a name="ln1781">                        rez = QString(&quot;%1 %2&quot;).arg(rez).arg(tpc2name(_rootTpc, NoteSpellingType::STANDARD, NoteCaseType::AUTO, true));</a>
<a name="ln1782">            }</a>
<a name="ln1783"> </a>
<a name="ln1784">      if (const_cast&lt;Harmony*&gt;(this)-&gt;parsedForm() &amp;&amp; !hTextName().isEmpty()) {</a>
<a name="ln1785">            QString aux = const_cast&lt;Harmony*&gt;(this)-&gt;parsedForm()-&gt;handle();</a>
<a name="ln1786">            aux = aux.replace(&quot;#&quot;, QObject::tr(&quot;♯&quot;)).replace(&quot;&lt;&quot;, &quot;&quot;);</a>
<a name="ln1787">            QString extension = &quot;&quot;;</a>
<a name="ln1788"> </a>
<a name="ln1789">            foreach (QString s, aux.split(&quot;&gt;&quot;, QString::SkipEmptyParts)) {</a>
<a name="ln1790">                  if (!s.contains(&quot;blues&quot;))</a>
<a name="ln1791">                        s.replace(&quot;b&quot;, QObject::tr(&quot;♭&quot;));</a>
<a name="ln1792">                  extension += s + &quot; &quot;;</a>
<a name="ln1793">                  }</a>
<a name="ln1794">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(extension);</a>
<a name="ln1795">            }</a>
<a name="ln1796">      else {</a>
<a name="ln1797">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(hTextName());</a>
<a name="ln1798">            }</a>
<a name="ln1799"> </a>
<a name="ln1800">      if (_baseTpc != Tpc::TPC_INVALID)</a>
<a name="ln1801">            rez = QString(&quot;%1 / %2&quot;).arg(rez).arg(tpc2name(_baseTpc, NoteSpellingType::STANDARD, NoteCaseType::AUTO, true));</a>
<a name="ln1802"> </a>
<a name="ln1803">      return rez;</a>
<a name="ln1804">      }</a>
<a name="ln1805"> </a>
<a name="ln1806">//---------------------------------------------------------</a>
<a name="ln1807">//   acceptDrop</a>
<a name="ln1808">//---------------------------------------------------------</a>
<a name="ln1809"> </a>
<a name="ln1810">bool Harmony::acceptDrop(EditData&amp; data) const</a>
<a name="ln1811">      {</a>
<a name="ln1812">      Element* e = data.dropElement;</a>
<a name="ln1813">      if (e-&gt;isFretDiagram()) {</a>
<a name="ln1814">            return true;</a>
<a name="ln1815">            }</a>
<a name="ln1816">      else if (e-&gt;isSymbol() || e-&gt;isFSymbol()) {</a>
<a name="ln1817">            // symbols can be added in edit mode</a>
<a name="ln1818">            if (data.getData(this))</a>
<a name="ln1819">                  return true;</a>
<a name="ln1820">            else</a>
<a name="ln1821">                  return false;</a>
<a name="ln1822">            }</a>
<a name="ln1823">      return false;</a>
<a name="ln1824">      }</a>
<a name="ln1825"> </a>
<a name="ln1826">//---------------------------------------------------------</a>
<a name="ln1827">//   drop</a>
<a name="ln1828">//---------------------------------------------------------</a>
<a name="ln1829"> </a>
<a name="ln1830">Element* Harmony::drop(EditData&amp; data)</a>
<a name="ln1831">      {</a>
<a name="ln1832">      Element* e = data.dropElement;</a>
<a name="ln1833">      if (e-&gt;isFretDiagram()) {</a>
<a name="ln1834">            FretDiagram* fd = toFretDiagram(e);</a>
<a name="ln1835">            fd-&gt;setParent(parent());</a>
<a name="ln1836">            fd-&gt;setTrack(track());</a>
<a name="ln1837">            score()-&gt;undoAddElement(fd);</a>
<a name="ln1838">            }</a>
<a name="ln1839">      else if (e-&gt;isSymbol() || e-&gt;isFSymbol()) {</a>
<a name="ln1840">            TextBase::drop(data);</a>
<a name="ln1841">            layout1();</a>
<a name="ln1842">            e = 0;      // cannot select</a>
<a name="ln1843">            }</a>
<a name="ln1844">      else {</a>
<a name="ln1845">            qWarning(&quot;Harmony: cannot drop &lt;%s&gt;\n&quot;, e-&gt;name());</a>
<a name="ln1846">            delete e;</a>
<a name="ln1847">            e = 0;</a>
<a name="ln1848">            }</a>
<a name="ln1849">      return e;</a>
<a name="ln1850">      }</a>
<a name="ln1851"> </a>
<a name="ln1852">//---------------------------------------------------------</a>
<a name="ln1853">//   getProperty</a>
<a name="ln1854">//---------------------------------------------------------</a>
<a name="ln1855"> </a>
<a name="ln1856">QVariant Harmony::getProperty(Pid pid) const</a>
<a name="ln1857">      {</a>
<a name="ln1858">      if (pid == Pid::HARMONY_TYPE)</a>
<a name="ln1859">            return QVariant(int(_harmonyType));</a>
<a name="ln1860">      return TextBase::getProperty(pid);</a>
<a name="ln1861">      }</a>
<a name="ln1862"> </a>
<a name="ln1863">//---------------------------------------------------------</a>
<a name="ln1864">//   setProperty</a>
<a name="ln1865">//---------------------------------------------------------</a>
<a name="ln1866"> </a>
<a name="ln1867">bool Harmony::setProperty(Pid pid, const QVariant&amp; v)</a>
<a name="ln1868">      {</a>
<a name="ln1869">      if (pid == Pid::HARMONY_TYPE) {</a>
<a name="ln1870">            setHarmonyType(HarmonyType(v.toInt()));</a>
<a name="ln1871">            return true;</a>
<a name="ln1872">            }</a>
<a name="ln1873">      else if (TextBase::setProperty(pid, v)) {</a>
<a name="ln1874">            if (pid == Pid::TEXT)</a>
<a name="ln1875">                  setHarmony(plainText());</a>
<a name="ln1876">            render();</a>
<a name="ln1877">            return true;</a>
<a name="ln1878">            }</a>
<a name="ln1879">      return false;</a>
<a name="ln1880">      }</a>
<a name="ln1881"> </a>
<a name="ln1882">//---------------------------------------------------------</a>
<a name="ln1883">//   propertyDefault</a>
<a name="ln1884">//---------------------------------------------------------</a>
<a name="ln1885"> </a>
<a name="ln1886">QVariant Harmony::propertyDefault(Pid id) const</a>
<a name="ln1887">      {</a>
<a name="ln1888">      QVariant v;</a>
<a name="ln1889">      switch (id) {</a>
<a name="ln1890">            case Pid::HARMONY_TYPE:</a>
<a name="ln1891">                  v = int(HarmonyType::STANDARD);</a>
<a name="ln1892">                  break;</a>
<a name="ln1893">            case Pid::SUB_STYLE: {</a>
<a name="ln1894">                  switch (_harmonyType) {</a>
<a name="ln1895">                        case HarmonyType::STANDARD:</a>
<a name="ln1896">                              v = int(Tid::HARMONY_A);</a>
<a name="ln1897">                              break;</a>
<a name="ln1898">                        case HarmonyType::ROMAN:</a>
<a name="ln1899">                              v = int(Tid::HARMONY_ROMAN);</a>
<a name="ln1900">                              break;</a>
<a name="ln1901">                        case HarmonyType::NASHVILLE:</a>
<a name="ln1902">                              v = int(Tid::HARMONY_NASHVILLE);</a>
<a name="ln1903">                              break;</a>
<a name="ln1904">                        }</a>
<a name="ln1905">                  }</a>
<a name="ln1906">                  break;</a>
<a name="ln1907">            case Pid::OFFSET:</a>
<a name="ln1908">                  if (parent() &amp;&amp; parent()-&gt;isFretDiagram()) {</a>
<a name="ln1909">                        v = QVariant(QPointF(0.0, 0.0));</a>
<a name="ln1910">                        break;</a>
<a name="ln1911">                        }</a>
<a name="ln1912">                  // fall-through</a>
<a name="ln1913">            default:</a>
<a name="ln1914">                  v = TextBase::propertyDefault(id);</a>
<a name="ln1915">                  break;</a>
<a name="ln1916">            }</a>
<a name="ln1917">      return v;</a>
<a name="ln1918">      }</a>
<a name="ln1919"> </a>
<a name="ln1920">//---------------------------------------------------------</a>
<a name="ln1921">//   getPropertyStyle</a>
<a name="ln1922">//---------------------------------------------------------</a>
<a name="ln1923"> </a>
<a name="ln1924">Sid Harmony::getPropertyStyle(Pid pid) const</a>
<a name="ln1925">      {</a>
<a name="ln1926">      if (pid == Pid::OFFSET) {</a>
<a name="ln1927">            if (parent() &amp;&amp; parent()-&gt;isFretDiagram())</a>
<a name="ln1928">                  return Sid::NOSTYLE;</a>
<a name="ln1929">            else if (tid() == Tid::HARMONY_A)</a>
<a name="ln1930">                  return placeAbove() ? Sid::chordSymbolAPosAbove : Sid::chordSymbolAPosBelow;</a>
<a name="ln1931">            else if (tid() == Tid::HARMONY_B)</a>
<a name="ln1932">                  return placeAbove() ? Sid::chordSymbolBPosAbove : Sid::chordSymbolBPosBelow;</a>
<a name="ln1933">            else if (tid() == Tid::HARMONY_ROMAN)</a>
<a name="ln1934">                  return placeAbove() ? Sid::romanNumeralPosAbove : Sid::romanNumeralPosBelow;</a>
<a name="ln1935">            else if (tid() == Tid::HARMONY_NASHVILLE)</a>
<a name="ln1936">                  return placeAbove() ? Sid::nashvilleNumberPosAbove : Sid::nashvilleNumberPosBelow;</a>
<a name="ln1937">            }</a>
<a name="ln1938">      if (pid == Pid::PLACEMENT) {</a>
<a name="ln1939">            switch (_harmonyType) {</a>
<a name="ln1940">                  case HarmonyType::STANDARD:</a>
<a name="ln1941">                        return Sid::harmonyPlacement;</a>
<a name="ln1942">                  case HarmonyType::ROMAN:</a>
<a name="ln1943">                        return Sid::romanNumeralPlacement;</a>
<a name="ln1944">                  case HarmonyType::NASHVILLE:</a>
<a name="ln1945">                        return Sid::nashvilleNumberPlacement;</a>
<a name="ln1946">                  }</a>
<a name="ln1947">            }</a>
<a name="ln1948">      return TextBase::getPropertyStyle(pid);</a>
<a name="ln1949">      }</a>
<a name="ln1950"> </a>
<a name="ln1951">}</a>

</code></pre>
<div class="balloon" rel="130"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="683"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1016"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'cl' is always true.</p></div>
<div class="balloon" rel="1845"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'warning' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="152"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _rootSpelling, _baseSpelling, _rootRenderCase, _baseRenderCase.</p></div>
<div class="balloon" rel="167"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _rootSpelling, _baseSpelling, _rootRenderCase, _baseRenderCase.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
