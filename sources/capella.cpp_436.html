
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>capella.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Linux Music Score Editor</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2009-2013 Werner Schweer and others</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2.</a>
<a name="ln9">//</a>
<a name="ln10">//  This program is distributed in the hope that it will be useful,</a>
<a name="ln11">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">//  GNU General Public License for more details.</a>
<a name="ln14">//</a>
<a name="ln15">//  You should have received a copy of the GNU General Public License</a>
<a name="ln16">//  along with this program; if not, write to the Free Software</a>
<a name="ln17">//  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</a>
<a name="ln18">//=============================================================================</a>
<a name="ln19"> </a>
<a name="ln20">//</a>
<a name="ln21">//    Capella 2000 import filter</a>
<a name="ln22">//</a>
<a name="ln23">#include &lt;assert.h&gt;</a>
<a name="ln24">#include &quot;libmscore/mscore.h&quot;</a>
<a name="ln25">#include &quot;capella.h&quot;</a>
<a name="ln26">#include &quot;libmscore/score.h&quot;</a>
<a name="ln27">#include &quot;libmscore/part.h&quot;</a>
<a name="ln28">#include &quot;libmscore/staff.h&quot;</a>
<a name="ln29">#include &quot;libmscore/rest.h&quot;</a>
<a name="ln30">#include &quot;libmscore/chord.h&quot;</a>
<a name="ln31">#include &quot;libmscore/note.h&quot;</a>
<a name="ln32">#include &quot;libmscore/utils.h&quot;</a>
<a name="ln33">#include &quot;libmscore/lyrics.h&quot;</a>
<a name="ln34">#include &quot;libmscore/timesig.h&quot;</a>
<a name="ln35">#include &quot;libmscore/clef.h&quot;</a>
<a name="ln36">#include &quot;libmscore/pitchspelling.h&quot;</a>
<a name="ln37">#include &quot;libmscore/keysig.h&quot;</a>
<a name="ln38">#include &quot;libmscore/slur.h&quot;</a>
<a name="ln39">#include &quot;libmscore/tie.h&quot;</a>
<a name="ln40">#include &quot;libmscore/box.h&quot;</a>
<a name="ln41">#include &quot;libmscore/measure.h&quot;</a>
<a name="ln42">#include &quot;libmscore/sig.h&quot;</a>
<a name="ln43">#include &quot;libmscore/tuplet.h&quot;</a>
<a name="ln44">#include &quot;libmscore/segment.h&quot;</a>
<a name="ln45">#include &quot;libmscore/layoutbreak.h&quot;</a>
<a name="ln46">#include &quot;libmscore/dynamic.h&quot;</a>
<a name="ln47">#include &quot;libmscore/barline.h&quot;</a>
<a name="ln48">#include &quot;libmscore/volta.h&quot;</a>
<a name="ln49">#include &quot;libmscore/stafftext.h&quot;</a>
<a name="ln50">#include &quot;libmscore/trill.h&quot;</a>
<a name="ln51">#include &quot;libmscore/arpeggio.h&quot;</a>
<a name="ln52">#include &quot;libmscore/breath.h&quot;</a>
<a name="ln53">#include &quot;libmscore/hairpin.h&quot;</a>
<a name="ln54">#include &quot;libmscore/sym.h&quot;</a>
<a name="ln55">#include &quot;libmscore/articulation.h&quot;</a>
<a name="ln56"> </a>
<a name="ln57">extern QString rtf2html(const QString &amp;);</a>
<a name="ln58"> </a>
<a name="ln59">namespace Ms {</a>
<a name="ln60"> </a>
<a name="ln61">//---------------------------------------------------------</a>
<a name="ln62">//   errmsg</a>
<a name="ln63">//---------------------------------------------------------</a>
<a name="ln64"> </a>
<a name="ln65">const char* Capella::errmsg[] = {</a>
<a name="ln66">      &quot;no error&quot;,</a>
<a name="ln67">      &quot;bad file signature, no Capella file or not from version 2000 (3.0) or later?&quot;,</a>
<a name="ln68">      &quot;unexpected end of file&quot;,</a>
<a name="ln69">      &quot;bad voice signature&quot;,</a>
<a name="ln70">      &quot;bad staff signature&quot;,</a>
<a name="ln71">      &quot;bad system signature&quot;,</a>
<a name="ln72">      };</a>
<a name="ln73"> </a>
<a name="ln74">//---------------------------------------------------------</a>
<a name="ln75">//   addDynamic</a>
<a name="ln76">//---------------------------------------------------------</a>
<a name="ln77"> </a>
<a name="ln78">static void addDynamic(Score* score, Segment* s, int track, const char* name)</a>
<a name="ln79">      {</a>
<a name="ln80">      Dynamic* d = new Dynamic(score);</a>
<a name="ln81">      d-&gt;setDynamicType(name);</a>
<a name="ln82">      d-&gt;setTrack(track);</a>
<a name="ln83">      s-&gt;add(d);</a>
<a name="ln84">      }</a>
<a name="ln85"> </a>
<a name="ln86">//---------------------------------------------------------</a>
<a name="ln87">//   addArticulationText</a>
<a name="ln88">//---------------------------------------------------------</a>
<a name="ln89"> </a>
<a name="ln90">static void addArticulationText(Score* score, ChordRest* cr, int track, SymId symId)</a>
<a name="ln91">      {</a>
<a name="ln92">      Articulation* na = new Articulation(score);</a>
<a name="ln93">      na-&gt;setTrack(track);</a>
<a name="ln94">      na-&gt;setSymId(symId);</a>
<a name="ln95">      cr-&gt;add(na);</a>
<a name="ln96">      }</a>
<a name="ln97"> </a>
<a name="ln98">//---------------------------------------------------------</a>
<a name="ln99">//   SetCapGraceDuration</a>
<a name="ln100">//---------------------------------------------------------</a>
<a name="ln101"> </a>
<a name="ln102">static void SetCapGraceDuration(Chord* chord,ChordObj* o)</a>
<a name="ln103">      {</a>
<a name="ln104">      NoteType nt = NoteType::APPOGGIATURA;</a>
<a name="ln105">      if (o-&gt;nTremoloBars &gt; 0)</a>
<a name="ln106">            nt = NoteType::ACCIACCATURA;</a>
<a name="ln107">      ((Chord*)chord)-&gt;setNoteType(nt);</a>
<a name="ln108">      if (o-&gt;t == TIMESTEP::D4) {</a>
<a name="ln109">            ((Chord*)chord)-&gt;setNoteType(NoteType::GRACE4);</a>
<a name="ln110">            chord-&gt;setDurationType(TDuration::DurationType::V_QUARTER);</a>
<a name="ln111">            }</a>
<a name="ln112">      else if (o-&gt;t == TIMESTEP::D_BREVE)</a>
<a name="ln113">            ((Chord*)chord)-&gt;setDurationType(TDuration::DurationType::V_BREVE);</a>
<a name="ln114">      else if (o-&gt;t == TIMESTEP::D1)</a>
<a name="ln115">            ((Chord*)chord)-&gt;setDurationType(TDuration::DurationType::V_WHOLE);</a>
<a name="ln116">      else if (o-&gt;t == TIMESTEP::D2)</a>
<a name="ln117">            ((Chord*)chord)-&gt;setDurationType(TDuration::DurationType::V_HALF);</a>
<a name="ln118">      else if (o-&gt;t == TIMESTEP::D16) {</a>
<a name="ln119">            ((Chord*)chord)-&gt;setNoteType(NoteType::GRACE16);</a>
<a name="ln120">            chord-&gt;setDurationType(TDuration::DurationType::V_16TH);</a>
<a name="ln121">            }</a>
<a name="ln122">      else if (o-&gt;t == TIMESTEP::D32) {</a>
<a name="ln123">            ((Chord*)chord)-&gt;setNoteType(NoteType::GRACE32);</a>
<a name="ln124">            chord-&gt;setDurationType(TDuration::DurationType::V_32ND);</a>
<a name="ln125">            }</a>
<a name="ln126">      else if (o-&gt;t == TIMESTEP::D64)</a>
<a name="ln127">            ((Chord*)chord)-&gt;setDurationType(TDuration::DurationType::V_64TH);</a>
<a name="ln128">      else if (o-&gt;t == TIMESTEP::D128)</a>
<a name="ln129">            ((Chord*)chord)-&gt;setDurationType(TDuration::DurationType::V_128TH);</a>
<a name="ln130">      else if (o-&gt;t == TIMESTEP::D256)</a>
<a name="ln131">            ((Chord*)chord)-&gt;setDurationType(TDuration::DurationType::V_256TH);</a>
<a name="ln132">      else</a>
<a name="ln133">            ((Chord*)chord)-&gt;setDurationType(TDuration::DurationType::V_EIGHTH);</a>
<a name="ln134">      }</a>
<a name="ln135"> </a>
<a name="ln136">//---------------------------------------------------------</a>
<a name="ln137">//   processBasicDrawObj</a>
<a name="ln138">//---------------------------------------------------------</a>
<a name="ln139"> </a>
<a name="ln140">static void processBasicDrawObj(QList&lt;BasicDrawObj*&gt; objects, Segment* s, int track, ChordRest* cr)</a>
<a name="ln141">      {</a>
<a name="ln142">      Score* score = s-&gt;score();</a>
<a name="ln143">      foreach(BasicDrawObj* oo, objects) {</a>
<a name="ln144">            switch (oo-&gt;type) {</a>
<a name="ln145">                  case CapellaType::SIMPLE_TEXT:</a>
<a name="ln146">                        {</a>
<a name="ln147">                        SimpleTextObj* st = static_cast&lt;SimpleTextObj*&gt;(oo);</a>
<a name="ln148">                        if (st-&gt;font().family() == &quot;capella3&quot;) {</a>
<a name="ln149">                              QString text(st-&gt;text());</a>
<a name="ln150">                              if (text.size() == 1) {</a>
<a name="ln151">                                    QChar c(text[0]);</a>
<a name="ln152">                                    ushort code = c.unicode();</a>
<a name="ln153">                                    switch (code) {</a>
<a name="ln154">                                          case 'p':</a>
<a name="ln155">                                                addDynamic(score, s, track, &quot;p&quot;);</a>
<a name="ln156">                                                break;</a>
<a name="ln157">                                          case 'q':</a>
<a name="ln158">                                                addDynamic(score, s, track, &quot;pp&quot;);</a>
<a name="ln159">                                                break;</a>
<a name="ln160">                                          case 'r':</a>
<a name="ln161">                                                addDynamic(score, s, track, &quot;ppp&quot;);</a>
<a name="ln162">                                                break;</a>
<a name="ln163">                                          case 's':</a>
<a name="ln164">                                                addDynamic(score, s, track, &quot;sf&quot;);</a>
<a name="ln165">                                                break;</a>
<a name="ln166">                                          case 'f':</a>
<a name="ln167">                                                addDynamic(score, s, track, &quot;f&quot;);</a>
<a name="ln168">                                                break;</a>
<a name="ln169">                                          case 'g':</a>
<a name="ln170">                                                addDynamic(score, s, track, &quot;ff&quot;);</a>
<a name="ln171">                                                break;</a>
<a name="ln172">                                          case 'h':</a>
<a name="ln173">                                                addDynamic(score, s, track, &quot;fff&quot;);</a>
<a name="ln174">                                                break;</a>
<a name="ln175">                                          case 'i':</a>
<a name="ln176">                                                addDynamic(score, s, track, &quot;mp&quot;);</a>
<a name="ln177">                                                break;</a>
<a name="ln178">                                          case 'j':</a>
<a name="ln179">                                                addDynamic(score, s, track, &quot;mf&quot;);</a>
<a name="ln180">                                                break;</a>
<a name="ln181">                                          case 'z':   // sfz</a>
<a name="ln182">                                                addDynamic(score, s, track, &quot;sfz&quot;);</a>
<a name="ln183">                                                break;</a>
<a name="ln184">                                          case '{':</a>
<a name="ln185">                                                addDynamic(score, s, track, &quot;fz&quot;);</a>
<a name="ln186">                                                break;</a>
<a name="ln187">                                          case '|':</a>
<a name="ln188">                                                addDynamic(score, s, track, &quot;fp&quot;);</a>
<a name="ln189">                                                break;</a>
<a name="ln190">                                          case 212:   // dynamic m</a>
<a name="ln191">                                                addDynamic(score, s, track, &quot;m&quot;);</a>
<a name="ln192">                                                break;</a>
<a name="ln193">                                          case 213:   // dynamic r</a>
<a name="ln194">                                                addDynamic(score, s, track, &quot;r&quot;);</a>
<a name="ln195">                                                break;</a>
<a name="ln196">                                          case 214:   // dynamic s</a>
<a name="ln197">                                                addDynamic(score, s, track, &quot;s&quot;);</a>
<a name="ln198">                                                break;</a>
<a name="ln199">                                          case 215:   // dynamic z</a>
<a name="ln200">                                                addDynamic(score, s, track, &quot;z&quot;);</a>
<a name="ln201">                                                break;</a>
<a name="ln202">                                          case 'k':   // fermata down</a>
<a name="ln203">                                                addArticulationText(score, cr, track, SymId::fermataBelow);</a>
<a name="ln204">                                                break;</a>
<a name="ln205">                                          case 'u':   // fermata up</a>
<a name="ln206">                                                addArticulationText(score, cr, track, SymId::fermataAbove);</a>
<a name="ln207">                                                break;</a>
<a name="ln208">                                          case 'd':   // da capo D.C.</a>
<a name="ln209">                                          case 'e':   // dal segno D.S.</a>
<a name="ln210">                                          case 'n':   // segno coda</a>
<a name="ln211">                                          case 'o':   // segno coda (smaller)</a>
<a name="ln212">                                          case 'y':   // segno</a>
<a name="ln213">                                          case '$':   // segno variation</a>
<a name="ln214">                                          case 'a':   // pedal Ped.</a>
<a name="ln215">                                          case 'b':   // pedal asterisk *</a>
<a name="ln216">                                          case 'v':   // 8va</a>
<a name="ln217">                                          case 186:   // 15ma</a>
<a name="ln218">                                                qDebug(&quot;Import of Capella text articulation %x(%c) not yet implemented&quot;, code, code);</a>
<a name="ln219">                                                break;</a>
<a name="ln220">                                          case 181:   // caesura</a>
<a name="ln221">                                                {</a>
<a name="ln222">                                                Breath* b = new Breath(score);</a>
<a name="ln223">                                                b-&gt;setTrack(track);</a>
<a name="ln224">                                                b-&gt;setSymId(SymId::caesura);</a>
<a name="ln225">                                                Segment* seg = s-&gt;measure()-&gt;getSegment(SegmentType::Breath, s-&gt;tick() + (cr ? cr-&gt;actualTicks() : Fraction(0,1)));</a>
<a name="ln226">                                                seg-&gt;add(b);</a>
<a name="ln227">                                                }</a>
<a name="ln228">                                                break;</a>
<a name="ln229">                                          default:</a>
<a name="ln230">                                                break;</a>
<a name="ln231">                                          }</a>
<a name="ln232">                                    if (cr-&gt;type() == ElementType::CHORD)</a>
<a name="ln233">                                          switch (code) {</a>
<a name="ln234">#if 0 // TODO-ws</a>
<a name="ln235">                                                case 't':   //  trill</a>
<a name="ln236">                                                      addArticulationText(score, cr, track, QString(&quot;trill&quot;));</a>
<a name="ln237">                                                      break;</a>
<a name="ln238">                                                case 'l':   // (upper) prall</a>
<a name="ln239">                                                      addArticulationText(score, cr, track, QString(&quot;prall&quot;));</a>
<a name="ln240">                                                      break;</a>
<a name="ln241">                                                case 'w':   // turn</a>
<a name="ln242">                                                      addArticulationText(score, cr, track, QString(&quot;turn&quot;));</a>
<a name="ln243">                                                      break;</a>
<a name="ln244">                                                case 'x':   // (lower) mordent</a>
<a name="ln245">                                                      addArticulationText(score, cr, track, QString(&quot;mordent&quot;));</a>
<a name="ln246">                                                      break;</a>
<a name="ln247">                                                case 'Y':   // down bow</a>
<a name="ln248">                                                      addArticulationText(score, cr, track, QString(&quot;downbow&quot;));</a>
<a name="ln249">                                                      break;</a>
<a name="ln250">                                                case 'Z':   // up bow</a>
<a name="ln251">                                                      addArticulationText(score, cr, track, QString(&quot;upbow&quot;));</a>
<a name="ln252">                                                      break;</a>
<a name="ln253">                                                case 182:   // plus sign</a>
<a name="ln254">                                                      addArticulationText(score, cr, track, QString(&quot;plusstop&quot;));</a>
<a name="ln255">                                                      break;</a>
<a name="ln256">                                                case 183:   // ouvert sign</a>
<a name="ln257">                                                      addArticulationText(score, cr, track, QString(&quot;ouvert&quot;));</a>
<a name="ln258">                                                      break;</a>
<a name="ln259">                                                case 184:   // snap pizzicato</a>
<a name="ln260">                                                      addArticulationText(score, cr, track, QString(&quot;snappizzicato&quot;));</a>
<a name="ln261">                                                      break;</a>
<a name="ln262">                                                case 189:   // schleifer</a>
<a name="ln263">                                                      addArticulationText(score, cr, track, QString(&quot;schleifer&quot;));</a>
<a name="ln264">                                                      break;</a>
<a name="ln265">                                                case 190:   // line prall</a>
<a name="ln266">                                                      addArticulationText(score, cr, track, QString(&quot;lineprall&quot;));</a>
<a name="ln267">                                                      break;</a>
<a name="ln268">                                                case 191:   // prall prall</a>
<a name="ln269">                                                      addArticulationText(score, cr, track, QString(&quot;prallprall&quot;));</a>
<a name="ln270">                                                      break;</a>
<a name="ln271">                                                case 192:   // down prall</a>
<a name="ln272">                                                      addArticulationText(score, cr, track, QString(&quot;downprall&quot;));</a>
<a name="ln273">                                                      break;</a>
<a name="ln274">                                                case 193:   // up prall</a>
<a name="ln275">                                                      addArticulationText(score, cr, track, QString(&quot;upprall&quot;));</a>
<a name="ln276">                                                      break;</a>
<a name="ln277">                                                case 194:   // prall mordent ?</a>
<a name="ln278">                                                      addArticulationText(score, cr, track, QString(&quot;prallmordent&quot;));</a>
<a name="ln279">                                                      break;</a>
<a name="ln280">                                                case 209:   // reverse turn</a>
<a name="ln281">                                                case 211:   // alt. reverse turn</a>
<a name="ln282">                                                      addArticulationText(score, cr, track, QString(&quot;reverseturn&quot;));</a>
<a name="ln283">                                                      break;</a>
<a name="ln284">#endif</a>
<a name="ln285">                                                case 172:   // arpeggio (short)</a>
<a name="ln286">                                                case 173:   // arpeggio (long)</a>
<a name="ln287">                                                      {</a>
<a name="ln288">                                                      Arpeggio* a = new Arpeggio(score);</a>
<a name="ln289">                                                      a-&gt;setArpeggioType(ArpeggioType::NORMAL);</a>
<a name="ln290">                                                      if ((static_cast&lt;Chord*&gt;(cr))-&gt;arpeggio()) { // there can be only one</a>
<a name="ln291">                                                            delete a;</a>
<a name="ln292">                                                            a = 0;</a>
<a name="ln293">                                                            }</a>
<a name="ln294">                                                      else</a>
<a name="ln295">                                                            cr-&gt;add(a);</a>
<a name="ln296">                                                      }</a>
<a name="ln297">                                                      break;</a>
<a name="ln298">                                                case 187:   // arpeggio (wiggle line, arrow up)</a>
<a name="ln299">                                                      {</a>
<a name="ln300">                                                      Arpeggio* a = new Arpeggio(score);</a>
<a name="ln301">                                                      a-&gt;setArpeggioType(ArpeggioType::UP);</a>
<a name="ln302">                                                      if ((static_cast&lt;Chord*&gt;(cr))-&gt;arpeggio()) { // there can be only one</a>
<a name="ln303">                                                            delete a;</a>
<a name="ln304">                                                            a = 0;</a>
<a name="ln305">                                                            }</a>
<a name="ln306">                                                      else</a>
<a name="ln307">                                                            cr-&gt;add(a);</a>
<a name="ln308">                                                      }</a>
<a name="ln309">                                                      break;</a>
<a name="ln310">                                                case 188:   // arpeggio (wiggle line, arrow down)</a>
<a name="ln311">                                                      {</a>
<a name="ln312">                                                      Arpeggio* a = new Arpeggio(score);</a>
<a name="ln313">                                                      a-&gt;setArpeggioType(ArpeggioType::DOWN);</a>
<a name="ln314">                                                      if ((static_cast&lt;Chord*&gt;(cr))-&gt;arpeggio()) { // there can be only one</a>
<a name="ln315">                                                            delete a;</a>
<a name="ln316">                                                            a = 0;</a>
<a name="ln317">                                                            }</a>
<a name="ln318">                                                      else</a>
<a name="ln319">                                                            cr-&gt;add(a);</a>
<a name="ln320">                                                      }</a>
<a name="ln321">                                                      break;</a>
<a name="ln322">                                                default:</a>
<a name="ln323">                                                      break;</a>
<a name="ln324">                                                }</a>
<a name="ln325">                                    break;</a>
<a name="ln326">                                    }</a>
<a name="ln327">                              }</a>
<a name="ln328">                        TextBase* text = new StaffText(score);</a>
<a name="ln329">                        QFont f(st-&gt;font());</a>
<a name="ln330">                        text-&gt;setFamily(f.family());</a>
<a name="ln331">                        text-&gt;setItalic(f.italic());</a>
<a name="ln332">                        // text-&gt;setUnderline(f.underline());</a>
<a name="ln333">                        text-&gt;setBold(f.bold());</a>
<a name="ln334">                        text-&gt;setSize(f.pointSizeF());</a>
<a name="ln335"> </a>
<a name="ln336">                        text-&gt;setPlainText(st-&gt;text());</a>
<a name="ln337">                        QPointF p(st-&gt;pos());</a>
<a name="ln338">                        p = p / 32.0 * score-&gt;spatium();</a>
<a name="ln339">                        // text-&gt;setUserOff(st-&gt;pos());</a>
<a name="ln340">                        text-&gt;setAutoplace(false);</a>
<a name="ln341">                        text-&gt;setOffset(p);</a>
<a name="ln342">                        // qDebug(&quot;setText %s (%f %f)(%f %f) &lt;%s&gt;&quot;,</a>
<a name="ln343">                        //            qPrintable(st-&gt;font().family()),</a>
<a name="ln344">                        //            st-&gt;pos().x(), st-&gt;pos().y(), p.x(), p.y(), qPrintable(st-&gt;text()));</a>
<a name="ln345">                        Align textalign;</a>
<a name="ln346">                        switch (st-&gt;textalign()) {</a>
<a name="ln347">                              default:</a>
<a name="ln348">                              case 0:</a>
<a name="ln349">                                    textalign = Align::LEFT;</a>
<a name="ln350">                                    break;</a>
<a name="ln351">                              case 1:</a>
<a name="ln352">                                    textalign = Align::HCENTER;</a>
<a name="ln353">                                    break;</a>
<a name="ln354">                              case 2:</a>
<a name="ln355">                                    textalign = Align::RIGHT;</a>
<a name="ln356">                                    break;</a>
<a name="ln357">                              }</a>
<a name="ln358">                        text-&gt;setAlign(textalign | Align::BASELINE);</a>
<a name="ln359">                        text-&gt;setOffset(QPointF(0.0, 2.0));</a>
<a name="ln360">                        text-&gt;setTrack(track);</a>
<a name="ln361">                        s-&gt;add(text);</a>
<a name="ln362">                        }</a>
<a name="ln363">                        break;</a>
<a name="ln364">                  case CapellaType::TEXT:</a>
<a name="ln365">                        qDebug(&quot;======================Text:&quot;);</a>
<a name="ln366">                        break;</a>
<a name="ln367">                  default:</a>
<a name="ln368">                        break;</a>
<a name="ln369">                  }</a>
<a name="ln370">            }</a>
<a name="ln371">      }</a>
<a name="ln372"> </a>
<a name="ln373">//---------------------------------------------------------</a>
<a name="ln374">//   TupletFractionCap</a>
<a name="ln375">//---------------------------------------------------------</a>
<a name="ln376"> </a>
<a name="ln377">Fraction TupletFractionCap(int tupletCount, bool tuplettrp, bool tupletprol)</a>
<a name="ln378">      {</a>
<a name="ln379">      int dd         = 0;</a>
<a name="ln380">      int nn         = 0;</a>
<a name="ln381">      qreal exponent = 0;</a>
<a name="ln382">      qreal count    = tupletCount;</a>
<a name="ln383">      Fraction f(3,2);</a>
<a name="ln384"> </a>
<a name="ln385">      if ((count &gt; 0) &amp;&amp; (count &lt;= 15)) {</a>
<a name="ln386">            if (tuplettrp)</a>
<a name="ln387">                  exponent = qFloor(qLn(count/3.0)/qLn(2.0));</a>
<a name="ln388">            else</a>
<a name="ln389">                  exponent = qFloor(qLn(count)/qLn(2.0));</a>
<a name="ln390">            }</a>
<a name="ln391">      else {</a>
<a name="ln392">            qDebug(&quot;Unknown tuplet, count = %d&quot;,tupletCount);</a>
<a name="ln393">            return f;</a>
<a name="ln394">            }</a>
<a name="ln395">      if (tupletprol)</a>
<a name="ln396">            exponent += 1.0;</a>
<a name="ln397">      if (exponent &lt; 0.0)</a>
<a name="ln398">            exponent = 0.0;</a>
<a name="ln399">      nn = tupletCount;</a>
<a name="ln400">      dd = static_cast&lt;int&gt;(qPow(2.0, exponent));</a>
<a name="ln401">      if (tuplettrp)</a>
<a name="ln402">            dd = dd * 3;</a>
<a name="ln403">      qDebug(&quot;Tuplet Fraction: %d / %d&quot;, nn, dd);</a>
<a name="ln404">      return Fraction(nn, dd);</a>
<a name="ln405">      }</a>
<a name="ln406"> </a>
<a name="ln407">//---------------------------------------------------------</a>
<a name="ln408">//   findChordRests -- find begin and end ChordRest for BasicDrawObj o</a>
<a name="ln409">//   return true on success (both begin and end found)</a>
<a name="ln410">//---------------------------------------------------------</a>
<a name="ln411"> </a>
<a name="ln412">static bool findChordRests(BasicDrawObj const* const o, Score* score, const int track, const Fraction&amp; tick,</a>
<a name="ln413">                           ChordRest*&amp; cr1, ChordRest*&amp; cr2, NoteObj* no, QList&lt;NoteObj*&gt; objects)</a>
<a name="ln414">      {</a>
<a name="ln415">      cr1 = 0;                         // ChordRest where BasicDrawObj o begins</a>
<a name="ln416">      cr2 = 0;                         // ChordRest where BasicDrawObj o ends</a>
<a name="ln417"> </a>
<a name="ln418">      // find the ChordRests where o begins and ends</a>
<a name="ln419">      int n = o-&gt;nNotes + 1;                                // # notes in BasicDrawObj (nNotes is # notes following the first note)</a>
<a name="ln420">      int graceNumber = 0;</a>
<a name="ln421">      int graceNumber1 = 0;</a>
<a name="ln422">      bool foundcr1 = false;</a>
<a name="ln423">      Fraction tick2 = tick;</a>
<a name="ln424">      foreach(NoteObj* nobj, objects) {</a>
<a name="ln425">            BasicDurationalObj* d = 0;</a>
<a name="ln426">            if (nobj-&gt;type() == CapellaNoteObjectType::REST) {</a>
<a name="ln427">                  d = static_cast&lt;BasicDurationalObj*&gt;(static_cast&lt;RestObj*&gt;(nobj));</a>
<a name="ln428">                  graceNumber = 0;</a>
<a name="ln429">                  }</a>
<a name="ln430">            else if (nobj-&gt;type() == CapellaNoteObjectType::CHORD) {</a>
<a name="ln431">                  ChordObj* cho = static_cast&lt;ChordObj*&gt;(nobj);</a>
<a name="ln432">                  d = static_cast&lt;BasicDurationalObj*&gt;(cho);</a>
<a name="ln433">                  if (!(cho-&gt;invisible) &amp;&amp; (cho-&gt;ticks().isZero())) // grace note</a>
<a name="ln434">                        ++graceNumber;</a>
<a name="ln435">                  else</a>
<a name="ln436">                        graceNumber = 0;</a>
<a name="ln437">                  }</a>
<a name="ln438">            if (!d)</a>
<a name="ln439">                  continue;</a>
<a name="ln440">            if (nobj == no) {</a>
<a name="ln441">                  foundcr1 = true;</a>
<a name="ln442">                  graceNumber1 = graceNumber;</a>
<a name="ln443">                  }</a>
<a name="ln444">            Fraction ticks = Fraction(0,1);</a>
<a name="ln445">            if (foundcr1) {</a>
<a name="ln446">                  --n;   // found the object corresponding to cr1, count down to find the second one</a>
<a name="ln447">                  ticks = d-&gt;ticks();</a>
<a name="ln448">                  if (d-&gt;count) {</a>
<a name="ln449">                        Fraction f = TupletFractionCap(d-&gt;count, d-&gt;tripartite, d-&gt;isProlonging);</a>
<a name="ln450">                        ticks = ticks / f;</a>
<a name="ln451">                        }</a>
<a name="ln452">                  if (nobj-&gt;type() == CapellaNoteObjectType::REST) {</a>
<a name="ln453">                        RestObj* ro = static_cast&lt;RestObj*&gt;(nobj);</a>
<a name="ln454">                        if (ro-&gt;fullMeasures) {</a>
<a name="ln455">                              Measure* m  = score-&gt;getCreateMeasure(tick2);</a>
<a name="ln456">                              Fraction ft = m-&gt;ticks();</a>
<a name="ln457">                              ticks       = ft * ro-&gt;fullMeasures;</a>
<a name="ln458">                              }</a>
<a name="ln459">                        }</a>
<a name="ln460">                  if (n == 0)</a>
<a name="ln461">                        break;</a>
<a name="ln462">                  tick2 += ticks;</a>
<a name="ln463">                  }</a>
<a name="ln464">            }</a>
<a name="ln465">      // Now we have the tick (tick) and the level of grace note (graceNumber1, if &quot;no&quot; is a grace note) for the first ChordRest</a>
<a name="ln466">      // and the tick (tick2) and the level of grace note (graceNumber, if the target is a grace note) for the 2nd ChordRest</a>
<a name="ln467">      for (Segment* seg = score-&gt;tick2segment(tick); seg; seg = seg-&gt;next1()) {</a>
<a name="ln468">            if (seg-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln469">                  continue;</a>
<a name="ln470">            ChordRest* cr = static_cast&lt;ChordRest*&gt;(seg-&gt;element(track));</a>
<a name="ln471">            if (cr) {</a>
<a name="ln472">                  if (graceNumber1 &gt; 0) { // the spanner is starting from a grace note</a>
<a name="ln473">                        Chord* chord = static_cast&lt;Chord*&gt;(cr);</a>
<a name="ln474">                        foreach(Chord* cc, chord-&gt;graceNotes()) {</a>
<a name="ln475">                              --graceNumber1;</a>
<a name="ln476">                              if ((graceNumber1 == 0) &amp;&amp; (!cr1))</a>
<a name="ln477">                                    cr1 = static_cast&lt;ChordRest*&gt;(cc); // found first ChordRest</a>
<a name="ln478">                              }</a>
<a name="ln479">                        }</a>
<a name="ln480">                  if (!cr1) cr1 = cr; // found first ChordRest</a>
<a name="ln481">                  break;</a>
<a name="ln482">                  }</a>
<a name="ln483">            }</a>
<a name="ln484">      for (Segment* seg = score-&gt;tick2segment(tick2); seg; seg = seg-&gt;next1()) {</a>
<a name="ln485">            if (seg-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln486">                  continue;</a>
<a name="ln487">            ChordRest* cr = static_cast&lt;ChordRest*&gt;(seg-&gt;element(track));</a>
<a name="ln488">            if (cr) {</a>
<a name="ln489">                  if ((graceNumber &gt; 0) &amp;&amp; (cr-&gt;type() == ElementType::CHORD)) { // the spanner is ending on a grace note</a>
<a name="ln490">                        Chord* chord = static_cast&lt;Chord*&gt;(cr);</a>
<a name="ln491">                        foreach(Chord* cc, chord-&gt;graceNotes()) {</a>
<a name="ln492">                              --graceNumber;</a>
<a name="ln493">                              if ((graceNumber == 0) &amp;&amp; (!cr2))</a>
<a name="ln494">                                    cr2 = static_cast&lt;ChordRest*&gt;(cc); // found 2nd ChordRest</a>
<a name="ln495">                              }</a>
<a name="ln496">                        }</a>
<a name="ln497">                  if (!cr2) cr2 = cr; // found 2nd ChordRest</a>
<a name="ln498">                  break;</a>
<a name="ln499">                  }</a>
<a name="ln500">            }</a>
<a name="ln501">      qDebug(&quot;findChordRests o %p nNotes %d score %p track %d tick %d cr1 %p cr2 %p&quot;,</a>
<a name="ln502">         o, o-&gt;nNotes, score, track, tick.ticks(), cr1, cr2);</a>
<a name="ln503"> </a>
<a name="ln504">      if (!(cr1 &amp;&amp; cr2)) {</a>
<a name="ln505">            qDebug(&quot;first or second anchor for BasicDrawObj not found (tick %d type %d track %d first %p second %p)&quot;,</a>
<a name="ln506">                   tick.ticks(), int(o-&gt;type), track, cr1, cr2);</a>
<a name="ln507">            return false;</a>
<a name="ln508">            }</a>
<a name="ln509">      return true;</a>
<a name="ln510">      }</a>
<a name="ln511"> </a>
<a name="ln512">//---------------------------------------------------------</a>
<a name="ln513">//   createAndAddTimeSig</a>
<a name="ln514">//---------------------------------------------------------</a>
<a name="ln515"> </a>
<a name="ln516">static Segment* createAndAddTimeSig(Score* score, Measure* m, Fraction f, int track, Fraction tick)</a>
<a name="ln517">      {</a>
<a name="ln518">      TimeSig* ts = new TimeSig(score);</a>
<a name="ln519">      ts-&gt;setSig(f);</a>
<a name="ln520">      ts-&gt;setTrack(track);</a>
<a name="ln521">      auto s = m-&gt;getSegment(SegmentType::TimeSig, tick);</a>
<a name="ln522">      s-&gt;add(ts);</a>
<a name="ln523">      return s;</a>
<a name="ln524">      }</a>
<a name="ln525"> </a>
<a name="ln526">//---------------------------------------------------------</a>
<a name="ln527">//   readCapVoice</a>
<a name="ln528">//---------------------------------------------------------</a>
<a name="ln529"> </a>
<a name="ln530">static Fraction readCapVoice(Score* score, CapVoice* cvoice, int staffIdx, const Fraction&amp; t, bool capxMode)</a>
<a name="ln531">      {</a>
<a name="ln532">      Fraction tick(t);</a>
<a name="ln533">      int voice = cvoice-&gt;voiceNo;</a>
<a name="ln534">      int track = staffIdx * VOICES + voice;</a>
<a name="ln535"> </a>
<a name="ln536">      //</a>
<a name="ln537">      // pass I</a>
<a name="ln538">      //</a>
<a name="ln539">      Fraction startTick = tick;</a>
<a name="ln540"> </a>
<a name="ln541">      Tuplet* tuplet  = 0;</a>
<a name="ln542">      int tupletCount = 0;</a>
<a name="ln543">      bool tuplettrp  = false;</a>
<a name="ln544">      bool tupletprol = false;</a>
<a name="ln545">      int nTuplet     = 0;</a>
<a name="ln546">      Fraction tupletTick = Fraction(0,1);</a>
<a name="ln547"> </a>
<a name="ln548">      QList&lt;Chord*&gt; graceNotes;</a>
<a name="ln549">      foreach(NoteObj* no, cvoice-&gt;objects) {</a>
<a name="ln550">            switch (no-&gt;type()) {</a>
<a name="ln551">                  case CapellaNoteObjectType::REST:</a>
<a name="ln552">                        {</a>
<a name="ln553">                        qDebug(&quot;     &lt;Rest&gt;&quot;);</a>
<a name="ln554">                        Measure* m = score-&gt;getCreateMeasure(tick);</a>
<a name="ln555">                        RestObj* o = static_cast&lt;RestObj*&gt;(no);</a>
<a name="ln556">                        Fraction ticks  = o-&gt;ticks();</a>
<a name="ln557">                        if (o-&gt;invisible &amp;&amp; ticks.isZero())   // get rid of placeholders</a>
<a name="ln558">                              break;</a>
<a name="ln559">                        TDuration d;</a>
<a name="ln560">                        d.setVal(ticks.ticks());</a>
<a name="ln561">                        if (o-&gt;count) {</a>
<a name="ln562">                              if (tuplet == 0) {</a>
<a name="ln563">                                    tupletCount = o-&gt;count;</a>
<a name="ln564">                                    tuplettrp   = o-&gt;tripartite;</a>
<a name="ln565">                                    tupletprol  = o-&gt;isProlonging;</a>
<a name="ln566">                                    nTuplet     = 0;</a>
<a name="ln567">                                    tupletTick  = tick;</a>
<a name="ln568">                                    tuplet      = new Tuplet(score);</a>
<a name="ln569">                                    Fraction f  = TupletFractionCap(tupletCount,tuplettrp,tupletprol);</a>
<a name="ln570">                                    tuplet-&gt;setRatio(f);</a>
<a name="ln571">                                    tuplet-&gt;setBaseLen(d);</a>
<a name="ln572">                                    tuplet-&gt;setTrack(track);</a>
<a name="ln573">                                    tuplet-&gt;setTick(tick);</a>
<a name="ln574">                                    tuplet-&gt;setParent(m);</a>
<a name="ln575">                                    Fraction nn = (ticks * tupletCount) / f;</a>
<a name="ln576">                                    tuplet-&gt;setTicks(nn);</a>
<a name="ln577">                                    }</a>
<a name="ln578">                              }</a>
<a name="ln579"> </a>
<a name="ln580">                        Fraction ft = m-&gt;ticks();</a>
<a name="ln581">                        if (o-&gt;fullMeasures) {</a>
<a name="ln582">                              ticks = ft * o-&gt;fullMeasures;</a>
<a name="ln583">                              if (!o-&gt;invisible) {</a>
<a name="ln584">                                    for (unsigned i = 0; i &lt; o-&gt;fullMeasures; ++i) {</a>
<a name="ln585">                                          Measure* m1 = score-&gt;getCreateMeasure(tick + (ft * i));</a>
<a name="ln586">                                          Segment* s = m1-&gt;getSegment(SegmentType::ChordRest, tick + (ft * i));</a>
<a name="ln587">                                          Rest* rest = new Rest(score);</a>
<a name="ln588">                                          rest-&gt;setDurationType(TDuration(TDuration::DurationType::V_MEASURE));</a>
<a name="ln589">                                          rest-&gt;setTicks(m1-&gt;ticks());</a>
<a name="ln590">                                          rest-&gt;setTrack(staffIdx * VOICES + voice);</a>
<a name="ln591">                                          s-&gt;add(rest);</a>
<a name="ln592">                                          }</a>
<a name="ln593">                                    }</a>
<a name="ln594">                              }</a>
<a name="ln595">                        if (!o-&gt;invisible || voice == 0) {</a>
<a name="ln596">                              Segment* s = m-&gt;getSegment(SegmentType::ChordRest, tick);</a>
<a name="ln597">                              Rest* rest = new Rest(score);</a>
<a name="ln598">                              TDuration d1;</a>
<a name="ln599">                              if (o-&gt;fullMeasures) {</a>
<a name="ln600">                                    d1.setType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln601">                                    rest-&gt;setTicks(m-&gt;ticks());</a>
<a name="ln602">                                    }</a>
<a name="ln603">                              else {</a>
<a name="ln604">                                    d1.setVal(ticks.ticks());</a>
<a name="ln605">                                    rest-&gt;setTicks(d1.fraction());</a>
<a name="ln606">                                    }</a>
<a name="ln607">                              rest-&gt;setDurationType(d1);</a>
<a name="ln608">                              rest-&gt;setTrack(track);</a>
<a name="ln609">                              rest-&gt;setVisible(!o-&gt;invisible);</a>
<a name="ln610">                              s-&gt;add(rest);</a>
<a name="ln611">                              if (tuplet)</a>
<a name="ln612">                                    tuplet-&gt;add(rest);</a>
<a name="ln613">                              processBasicDrawObj(o-&gt;objects, s, track, rest);</a>
<a name="ln614">                              }</a>
<a name="ln615"> </a>
<a name="ln616">                        if (tuplet) {</a>
<a name="ln617">                              if (++nTuplet &gt;= tupletCount) {</a>
<a name="ln618">                                    tick = tupletTick + tuplet-&gt;actualTicks();</a>
<a name="ln619">                                    tuplet = 0;</a>
<a name="ln620">                                    }</a>
<a name="ln621">                              else {</a>
<a name="ln622">                                    tick += ticks / tuplet-&gt;ratio();</a>
<a name="ln623">                                    }</a>
<a name="ln624">                              }</a>
<a name="ln625">                        else</a>
<a name="ln626">                              tick += ticks;</a>
<a name="ln627">                        }</a>
<a name="ln628">                        break;</a>
<a name="ln629">                  case CapellaNoteObjectType::CHORD:</a>
<a name="ln630">                        {</a>
<a name="ln631">                        qDebug(&quot;     &lt;Chord&gt;&quot;);</a>
<a name="ln632">                        ChordObj* o = static_cast&lt;ChordObj*&gt;(no);</a>
<a name="ln633">                        Fraction ticks = o-&gt;ticks();</a>
<a name="ln634">                        if (o-&gt;invisible &amp;&amp; ticks.isZero()) {  // get rid of placeholders</a>
<a name="ln635">                              break;</a>
<a name="ln636">                              }</a>
<a name="ln637">                        TDuration d;</a>
<a name="ln638">                        d.setVal(ticks.ticks());</a>
<a name="ln639">                        Measure* m = score-&gt;getCreateMeasure(tick);</a>
<a name="ln640"> </a>
<a name="ln641">                        bool isgracenote = (!(o-&gt;invisible) &amp;&amp; (ticks.isZero()));</a>
<a name="ln642">                        if (o-&gt;count) {</a>
<a name="ln643">                              if (tuplet == 0) {</a>
<a name="ln644">                                    tupletCount = o-&gt;count;</a>
<a name="ln645">                                    tuplettrp   = o-&gt;tripartite;</a>
<a name="ln646">                                    tupletprol  = o-&gt;isProlonging;</a>
<a name="ln647">                                    nTuplet     = 0;</a>
<a name="ln648">                                    tupletTick  = tick;</a>
<a name="ln649">                                    tuplet      = new Tuplet(score);</a>
<a name="ln650">                                    Fraction f  = TupletFractionCap(tupletCount,tuplettrp,tupletprol);</a>
<a name="ln651">                                    tuplet-&gt;setRatio(f);</a>
<a name="ln652">                                    tuplet-&gt;setBaseLen(d);</a>
<a name="ln653">                                    tuplet-&gt;setTrack(track);</a>
<a name="ln654">                                    tuplet-&gt;setTick(tick);</a>
<a name="ln655">                                    tuplet-&gt;setParent(m);</a>
<a name="ln656">                                    Fraction nn = (ticks * tupletCount) / f;</a>
<a name="ln657">                                    tuplet-&gt;setTicks(nn);</a>
<a name="ln658">                                    }</a>
<a name="ln659">                              qDebug(&quot;Tuplet at %d: count: %d  tri: %d  prolonging: %d  ticks %d objects %d&quot;,</a>
<a name="ln660">                                     tick.ticks(), o-&gt;count, o-&gt;tripartite, o-&gt;isProlonging, ticks.ticks(),</a>
<a name="ln661">                                     o-&gt;objects.size());</a>
<a name="ln662">                              }</a>
<a name="ln663"> </a>
<a name="ln664">                        Chord* chord = new Chord(score);</a>
<a name="ln665">                        if (isgracenote) { // grace notes</a>
<a name="ln666">                              SetCapGraceDuration(chord,o);</a>
<a name="ln667">                              chord-&gt;setTicks(chord-&gt;durationType().fraction());</a>
<a name="ln668">                              }</a>
<a name="ln669">                        else { // normal notes</a>
<a name="ln670">                              chord-&gt;setDurationType(d);</a>
<a name="ln671">                              chord-&gt;setTicks(d.fraction());</a>
<a name="ln672">                              }</a>
<a name="ln673">                        chord-&gt;setTrack(track);</a>
<a name="ln674">                        switch (o-&gt;stemDir) {</a>
<a name="ln675">                              case ChordObj::StemDir::DOWN:</a>
<a name="ln676">                                    chord-&gt;setStemDirection(Direction::DOWN);</a>
<a name="ln677">                                    break;</a>
<a name="ln678">                              case ChordObj::StemDir::UP:</a>
<a name="ln679">                                    chord-&gt;setStemDirection(Direction::UP);</a>
<a name="ln680">                                    break;</a>
<a name="ln681">                              case ChordObj::StemDir::NONE:</a>
<a name="ln682">                                    chord-&gt;setNoStem(true);</a>
<a name="ln683">                                    break;</a>
<a name="ln684">                              case ChordObj::StemDir::AUTO:</a>
<a name="ln685">                              default:</a>
<a name="ln686">                                    break;</a>
<a name="ln687">                              }</a>
<a name="ln688">                        Segment* s = m-&gt;getSegment(SegmentType::ChordRest, tick);</a>
<a name="ln689">                        if (isgracenote)</a>
<a name="ln690">                              graceNotes.push_back(chord);</a>
<a name="ln691">                        else {</a>
<a name="ln692">                              s-&gt;add(chord);</a>
<a name="ln693">                              // append grace notes before</a>
<a name="ln694">                              int ii = -1;</a>
<a name="ln695">                              for (ii = graceNotes.size() - 1; ii &gt;= 0; ii--) {</a>
<a name="ln696">                                    Chord* gc = graceNotes[ii];</a>
<a name="ln697">                                    if(gc-&gt;voice() == chord-&gt;voice()){</a>
<a name="ln698">                                          chord-&gt;add(gc);</a>
<a name="ln699">                                          }</a>
<a name="ln700">                                    }</a>
<a name="ln701">                              graceNotes.clear();</a>
<a name="ln702">                              }</a>
<a name="ln703">                        if (tuplet)</a>
<a name="ln704">                              tuplet-&gt;add(chord);</a>
<a name="ln705">                        ClefType clef = score-&gt;staff(staffIdx)-&gt;clef(tick);</a>
<a name="ln706">                        Key key  = score-&gt;staff(staffIdx)-&gt;key(tick);</a>
<a name="ln707">                        int off;</a>
<a name="ln708">                        switch (clef) {</a>
<a name="ln709">                              case ClefType::G:      off = 0; break;</a>
<a name="ln710">                              case ClefType::G8_VA:  off = 7; break;</a>
<a name="ln711">                              case ClefType::G15_MA: off = 14; break;</a>
<a name="ln712">                              case ClefType::G8_VB:  off = -7; break;</a>
<a name="ln713">                              case ClefType::F:      off = -14; break;</a>
<a name="ln714">                              case ClefType::F8_VB:  off = -21; break;</a>
<a name="ln715">                              case ClefType::F15_MB: off = -28; break;</a>
<a name="ln716">                              case ClefType::F_B:    off = -14; break;</a>
<a name="ln717">                              case ClefType::F_C:    off = -14; break;</a>
<a name="ln718">                              case ClefType::C1:     off = -7; break;</a>
<a name="ln719">                              case ClefType::C2:     off = -7; break;</a>
<a name="ln720">                              case ClefType::C3:     off = -7; break;</a>
<a name="ln721">                              case ClefType::C4:     off = -7; break;</a>
<a name="ln722">                              case ClefType::C5:     off = -7; break;</a>
<a name="ln723">                              case ClefType::G_1:     off = 0; break;</a>
<a name="ln724">                              case ClefType::F_8VA:  off = -7; break;</a>
<a name="ln725">                              case ClefType::F_15MA: off = 0; break;</a>
<a name="ln726">                              default:          off = 0; qDebug(&quot;clefType %d not implemented&quot;, int(clef));</a>
<a name="ln727">                              }</a>
<a name="ln728">                        // qDebug(&quot;clef %hhd off %d&quot;, clef, off);</a>
<a name="ln729"> </a>
<a name="ln730">                        static int keyOffsets[15] = {</a>
<a name="ln731">                              /*   -7 -6 -5 -4 -3 -2 -1  0  1  2  3  4  5  6  7 */</a>
<a name="ln732">                              /* */ 7, 4, 1, 5, 2, 6, 3, 0, 4, 1, 5, 2, 6, 3, 0</a>
<a name="ln733">                              };</a>
<a name="ln734">                        off += keyOffsets[int(key) + 7];</a>
<a name="ln735"> </a>
<a name="ln736">                        for (CNote n : o-&gt;notes) {</a>
<a name="ln737">                              Note* note = new Note(score);</a>
<a name="ln738">                              int pitch = 0;</a>
<a name="ln739">                              // .cap import: pitch contains the diatonic note number relative to clef and key</a>
<a name="ln740">                              // .capx  import: pitch the MIDI note number instead</a>
<a name="ln741">                              if (capxMode) {</a>
<a name="ln742">                                    pitch = n.pitch;</a>
<a name="ln743">                                    }</a>
<a name="ln744">                              else {</a>
<a name="ln745">                                    int l = n.pitch + off + 7 * 6;</a>
<a name="ln746">                                    int octave = 0;</a>
<a name="ln747">                                    while (l &lt; 0) {</a>
<a name="ln748">                                          l += 7;</a>
<a name="ln749">                                          octave--;</a>
<a name="ln750">                                          }</a>
<a name="ln751">                                    octave += l / 7;</a>
<a name="ln752">                                    l       = l % 7;</a>
<a name="ln753"> </a>
<a name="ln754">                                    pitch = pitchKeyAdjust(l, key) + octave * 12;</a>
<a name="ln755">                                    }</a>
<a name="ln756">                              pitch += n.alteration;</a>
<a name="ln757">                              pitch += score-&gt;staff(staffIdx)-&gt;part()-&gt;instrument()-&gt;transpose().chromatic; // assume not in concert pitch</a>
<a name="ln758">                              pitch = limit(pitch, 0, 127);</a>
<a name="ln759"> </a>
<a name="ln760">                              chord-&gt;add(note);</a>
<a name="ln761">                              note-&gt;setPitch(pitch);</a>
<a name="ln762">                              // TODO: compute tpc from pitch &amp; line</a>
<a name="ln763">                              note-&gt;setTpcFromPitch();</a>
<a name="ln764">                              if (o-&gt;rightTie) {</a>
<a name="ln765">                                    Tie* tie = new Tie(score);</a>
<a name="ln766">                                    tie-&gt;setStartNote(note);</a>
<a name="ln767">                                    tie-&gt;setTrack(track);</a>
<a name="ln768">                                    note-&gt;setTieFor(tie);</a>
<a name="ln769">                                    }</a>
<a name="ln770">                              }</a>
<a name="ln771">                        for (Verse v : o-&gt;verse) {</a>
<a name="ln772">                              Lyrics* l = new Lyrics(score);</a>
<a name="ln773">                              l-&gt;setTrack(track);</a>
<a name="ln774">                              l-&gt;setPlainText(v.text);</a>
<a name="ln775">                              if (v.hyphen)</a>
<a name="ln776">                                    l-&gt;setSyllabic(Lyrics::Syllabic::BEGIN);</a>
<a name="ln777">                              l-&gt;setNo(v.num);</a>
<a name="ln778">                              chord-&gt;add(l);</a>
<a name="ln779">                              }</a>
<a name="ln780"> </a>
<a name="ln781">                        processBasicDrawObj(o-&gt;objects, s, track, chord);</a>
<a name="ln782">                        switch (o-&gt;articulation) {</a>
<a name="ln783">#if 0 // TODO-ws</a>
<a name="ln784">                              case 1:   addArticulationText(score, chord, track, QString(&quot;staccato&quot;)); break;</a>
<a name="ln785">                              case 2:   addArticulationText(score, chord, track, QString(&quot;tenuto&quot;)); break;</a>
<a name="ln786">                              case 3:   addArticulationText(score, chord, track, QString(&quot;portato&quot;)); break;</a>
<a name="ln787">                              case 4:   addArticulationText(score, chord, track, QString(&quot;staccatissimo&quot;)); break;</a>
<a name="ln788">                              case 5:   addArticulationText(score, chord, track, QString(&quot;sforzato&quot;)); break;</a>
<a name="ln789">                              case 6:   addArticulationText(score, chord, track, QString(&quot;marcato&quot;)); break;</a>
<a name="ln790">#endif</a>
<a name="ln791">                              case 7:   // &quot;weak beat&quot;</a>
<a name="ln792">                              case 8:   // &quot;strong beat&quot;</a>
<a name="ln793">                              default:  if(o-&gt;articulation) qDebug(&quot;Articulation # %d not implemented&quot;, o-&gt;articulation); break;</a>
<a name="ln794">                              }</a>
<a name="ln795"> </a>
<a name="ln796">                        if (tuplet) {</a>
<a name="ln797">                              if (++nTuplet &gt;= tupletCount) {</a>
<a name="ln798">                                    tick = tupletTick + tuplet-&gt;actualTicks();</a>
<a name="ln799">                                    tuplet = 0;</a>
<a name="ln800">                                    }</a>
<a name="ln801">                              else {</a>
<a name="ln802">                                    tick += ticks / tuplet-&gt;ratio();</a>
<a name="ln803">                                    }</a>
<a name="ln804">                              }</a>
<a name="ln805">                        else</a>
<a name="ln806">                              tick += ticks;</a>
<a name="ln807">                        }</a>
<a name="ln808">                        break;</a>
<a name="ln809">                  case CapellaNoteObjectType::CLEF:</a>
<a name="ln810">                        {</a>
<a name="ln811">                        qDebug(&quot;     &lt;Clef&gt;&quot;);</a>
<a name="ln812">                        CapClef* o = static_cast&lt;CapClef*&gt;(no);</a>
<a name="ln813">                        ClefType nclef = o-&gt;clef();</a>
<a name="ln814">                        qDebug(&quot;%d:%d &lt;Clef&gt; %s line %d oct %d clef %d&quot;,</a>
<a name="ln815">                           tick.ticks(), staffIdx, o-&gt;name(), int(o-&gt;line), int(o-&gt;oct), int(o-&gt;clef()));</a>
<a name="ln816">                        if (nclef == ClefType::INVALID)</a>
<a name="ln817">                              break;</a>
<a name="ln818">                        // staff(staffIdx)-&gt;setClef(tick, nclef);</a>
<a name="ln819">                        Clef* clef = new Clef(score);</a>
<a name="ln820">                        clef-&gt;setClefType(nclef);</a>
<a name="ln821">                        clef-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln822">                        Measure* m = score-&gt;getCreateMeasure(tick);</a>
<a name="ln823">                        Segment* s;</a>
<a name="ln824">                        if (tick == m-&gt;tick())</a>
<a name="ln825">                              s = m-&gt;getSegment(SegmentType::HeaderClef, tick);</a>
<a name="ln826">                        else</a>
<a name="ln827">                              s = m-&gt;getSegment(SegmentType::Clef, tick);</a>
<a name="ln828">                        s-&gt;add(clef);</a>
<a name="ln829">                        }</a>
<a name="ln830">                        break;</a>
<a name="ln831">                  case CapellaNoteObjectType::KEY:</a>
<a name="ln832">                        {</a>
<a name="ln833">                        qDebug(&quot;   &lt;Key&gt;&quot;);</a>
<a name="ln834">                        CapKey* o = static_cast&lt;CapKey*&gt;(no);</a>
<a name="ln835">                        KeySigEvent key = score-&gt;staff(staffIdx)-&gt;keySigEvent(tick);</a>
<a name="ln836">                        KeySigEvent okey;</a>
<a name="ln837">                        okey.setKey(Key(o-&gt;signature));</a>
<a name="ln838">                        if (!(key == okey)) {</a>
<a name="ln839">                              score-&gt;staff(staffIdx)-&gt;setKey(tick, okey);</a>
<a name="ln840">                              KeySig* ks = new KeySig(score);</a>
<a name="ln841">                              ks-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln842">                              Measure* m = score-&gt;getCreateMeasure(tick);</a>
<a name="ln843">                              Segment* s = m-&gt;getSegment(SegmentType::KeySig, tick);</a>
<a name="ln844">                              ks-&gt;setKeySigEvent(okey);</a>
<a name="ln845">                              s-&gt;add(ks);</a>
<a name="ln846">                              }</a>
<a name="ln847">                        }</a>
<a name="ln848">                        break;</a>
<a name="ln849">                  case CapellaNoteObjectType::METER:</a>
<a name="ln850">                        {</a>
<a name="ln851">                        CapMeter* o = static_cast&lt;CapMeter*&gt;(no);</a>
<a name="ln852">                        qDebug(&quot;     &lt;Meter&gt; tick %d %d/%d&quot;, tick.ticks(), o-&gt;numerator, 1 &lt;&lt; o-&gt;log2Denom);</a>
<a name="ln853">                        if (o-&gt;log2Denom &gt; 7 || o-&gt;log2Denom &lt; 0)</a>
<a name="ln854">                              qFatal(&quot;illegal fraction&quot;);</a>
<a name="ln855">                        SigEvent se = score-&gt;sigmap()-&gt;timesig(tick);</a>
<a name="ln856">                        Fraction f(o-&gt;numerator, 1 &lt;&lt; o-&gt;log2Denom);</a>
<a name="ln857">                        SigEvent ne(f);</a>
<a name="ln858">                        if (!(se == ne))</a>
<a name="ln859">                              score-&gt;sigmap()-&gt;add(tick.ticks(), ne);</a>
<a name="ln860"> </a>
<a name="ln861">                        // do not add timesig again</a>
<a name="ln862">                        Measure* m = score-&gt;getCreateMeasure(tick);</a>
<a name="ln863">                        Segment* s = m-&gt;findSegment(SegmentType::TimeSig, tick);</a>
<a name="ln864">                        if (s) {</a>
<a name="ln865">                              Element* e = s-&gt;element(trackZeroVoice(track));</a>
<a name="ln866">                              if (e &amp;&amp; static_cast&lt;TimeSig*&gt;(e)-&gt;sig() == f)</a>
<a name="ln867">                                    break;</a>
<a name="ln868">                              }</a>
<a name="ln869">                        // create timesig in current track</a>
<a name="ln870">                        s = createAndAddTimeSig(score, m, f, track, tick);</a>
<a name="ln871">                        // if not present, also create timesig in track 0</a>
<a name="ln872">                        // to prevent corrupt .msc[xz] files when first staff</a>
<a name="ln873">                        // is empty and timesig is not 4/4</a>
<a name="ln874">                        if (!(s-&gt;element(0)))</a>
<a name="ln875">                              createAndAddTimeSig(score, m, f, 0, tick);</a>
<a name="ln876">                        m-&gt;setTicks(f);</a>
<a name="ln877">                        }</a>
<a name="ln878">                        break;</a>
<a name="ln879">                  case CapellaNoteObjectType::EXPL_BARLINE:</a>
<a name="ln880">                  case CapellaNoteObjectType::IMPL_BARLINE:    // does not exist?</a>
<a name="ln881">                        {</a>
<a name="ln882">                        CapExplicitBarline* o = static_cast&lt;CapExplicitBarline*&gt;(no);</a>
<a name="ln883">                        qDebug(&quot;     &lt;Barline&gt;&quot;);</a>
<a name="ln884">                        Measure* pm = 0; // the previous measure (the one terminated by this barline)</a>
<a name="ln885">                        if (tick &gt; Fraction(0,1))</a>
<a name="ln886">                              pm = score-&gt;getCreateMeasure(tick - Fraction::fromTicks(1));</a>
<a name="ln887">                        if (pm) {</a>
<a name="ln888">                              Fraction ticks = tick - pm-&gt;tick();</a>
<a name="ln889">                              if ((ticks &gt; Fraction(0,1)) &amp;&amp; ticks != pm-&gt;ticks()) {</a>
<a name="ln890">                                    // this is a measure with different actual duration</a>
<a name="ln891">                                    Fraction f = ticks;</a>
<a name="ln892">                                    pm-&gt;setTicks(f);</a>
<a name="ln893">#if 0</a>
<a name="ln894">                                    AL::SigEvent ne(f);</a>
<a name="ln895">                                    ne.setNominal(m-&gt;timesig());</a>
<a name="ln896">                                    score-&gt;sigmap()-&gt;add(m-&gt;tick(), ne);</a>
<a name="ln897">                                    AL::SigEvent ne2(m-&gt;timesig());</a>
<a name="ln898">                                    score-&gt;sigmap()-&gt;add(m-&gt;tick() + m-&gt;ticks(), ne2);</a>
<a name="ln899">#endif</a>
<a name="ln900">                                    }</a>
<a name="ln901">                              }</a>
<a name="ln902">                        // qDebug(&quot;pm %p&quot;, pm);</a>
<a name="ln903"> </a>
<a name="ln904">                        BarLineType st = o-&gt;type();</a>
<a name="ln905">                        if (st == BarLineType::NORMAL)</a>
<a name="ln906">                              break;</a>
<a name="ln907"> </a>
<a name="ln908">//TODO                        if (pm &amp;&amp; (st == BarLineType::DOUBLE || st == BarLineType::END || st == BarLineType::BROKEN))</a>
<a name="ln909">//                              pm-&gt;setEndBarLineType(st, false, true);</a>
<a name="ln910"> </a>
<a name="ln911">                        if (st == BarLineType::START_REPEAT || st == BarLineType::END_START_REPEAT) {</a>
<a name="ln912">                              Measure* nm = 0; // the next measure (the one started by this barline)</a>
<a name="ln913">                              nm = score-&gt;getCreateMeasure(tick);</a>
<a name="ln914">                              // qDebug(&quot;nm %p&quot;, nm);</a>
<a name="ln915">                              if (nm)</a>
<a name="ln916">                                    nm-&gt;setRepeatStart(true);</a>
<a name="ln917">                              }</a>
<a name="ln918"> </a>
<a name="ln919">                        if (st == BarLineType::END_REPEAT || st == BarLineType::END_START_REPEAT) {</a>
<a name="ln920">                              if (pm)</a>
<a name="ln921">                                    pm-&gt;setRepeatEnd(true);</a>
<a name="ln922">                              }</a>
<a name="ln923">                        }</a>
<a name="ln924">                        break;</a>
<a name="ln925">                  case CapellaNoteObjectType::PAGE_BKGR:</a>
<a name="ln926">                        qDebug(&quot;     &lt;PageBreak&gt;&quot;);</a>
<a name="ln927">                        break;</a>
<a name="ln928">                  }</a>
<a name="ln929">            }</a>
<a name="ln930">      Fraction endTick = tick;</a>
<a name="ln931"> </a>
<a name="ln932">      //</a>
<a name="ln933">      // pass II</a>
<a name="ln934">      //</a>
<a name="ln935">      tick = startTick;</a>
<a name="ln936">      foreach(NoteObj* no, cvoice-&gt;objects) {</a>
<a name="ln937">            BasicDurationalObj* d = 0;</a>
<a name="ln938">            if (no-&gt;type() == CapellaNoteObjectType::REST)</a>
<a name="ln939">                  d = static_cast&lt;BasicDurationalObj*&gt;(static_cast&lt;RestObj*&gt;(no));</a>
<a name="ln940">            else if (no-&gt;type() == CapellaNoteObjectType::CHORD)</a>
<a name="ln941">                  d = static_cast&lt;BasicDurationalObj*&gt;(static_cast&lt;ChordObj*&gt;(no));</a>
<a name="ln942">            if (!d)</a>
<a name="ln943">                  continue;</a>
<a name="ln944">            for (BasicDrawObj* o : d-&gt;objects) {</a>
<a name="ln945">                  switch (o-&gt;type) {</a>
<a name="ln946">                        case CapellaType::SIMPLE_TEXT:</a>
<a name="ln947">                              // qDebug(&quot;simple text at %d&quot;, tick);</a>
<a name="ln948">                              break;</a>
<a name="ln949">                        case CapellaType::WAVY_LINE:</a>
<a name="ln950">                              break;</a>
<a name="ln951">                        case CapellaType::SLUR:</a>
<a name="ln952">                              {</a>
<a name="ln953">                              // SlurObj* so = static_cast&lt;SlurObj*&gt;(o);</a>
<a name="ln954">                              // qDebug(&quot;slur tick %d  %d-%d-%d-%d   %d-%d&quot;, tick, so-&gt;nEnd, so-&gt;nMid,</a>
<a name="ln955">                              //        so-&gt;nDotDist, so-&gt;nDotWidth, so-&gt;nRefNote, so-&gt;nNotes);</a>
<a name="ln956">                              ChordRest* cr1 = 0; // ChordRest where slur begins</a>
<a name="ln957">                              ChordRest* cr2 = 0; // ChordRest where slur ends</a>
<a name="ln958">                              bool res = findChordRests(o, score, track, tick, cr1, cr2, no, cvoice-&gt;objects);</a>
<a name="ln959"> </a>
<a name="ln960">                              if (res) {</a>
<a name="ln961">                                    if (cr1 == cr2)</a>
<a name="ln962">                                          qDebug(&quot;first and second anchor for slur identical (tick %d track %d first %p second %p)&quot;,</a>
<a name="ln963">                                             tick.ticks(), track, cr1, cr2);</a>
<a name="ln964">                                    else {</a>
<a name="ln965">                                          Slur* slur = new Slur(score);</a>
<a name="ln966">                                          qDebug(&quot;tick %d track %d cr1 %p cr2 %p -&gt; slur %p&quot;,</a>
<a name="ln967">                                             tick.ticks(), track, cr1, cr2, slur);</a>
<a name="ln968">                                          slur-&gt;setTick(cr1-&gt;tick());</a>
<a name="ln969">                                          slur-&gt;setTick2(cr2-&gt;tick());</a>
<a name="ln970">                                          slur-&gt;setStartElement(cr1);</a>
<a name="ln971">                                          slur-&gt;setEndElement(cr2);</a>
<a name="ln972">                                          slur-&gt;setTrack(cr1-&gt;track());</a>
<a name="ln973">                                          slur-&gt;setTrack2(cr2-&gt;track());</a>
<a name="ln974">                                          score-&gt;addElement(slur);</a>
<a name="ln975">                                          }</a>
<a name="ln976">                                    }</a>
<a name="ln977">                              }</a>
<a name="ln978">                              break;</a>
<a name="ln979">                        case CapellaType::TEXT: {</a>
<a name="ln980"> </a>
<a name="ln981">                              TextObj* to = static_cast&lt;TextObj*&gt;(o);</a>
<a name="ln982">                              Text* s = new Text(score, Tid::TITLE);</a>
<a name="ln983">                              QString ss = ::rtf2html(QString(to-&gt;text));</a>
<a name="ln984"> </a>
<a name="ln985">                              // qDebug(&quot;string %f:%f w %d ratio %d &lt;%s&gt;&quot;,</a>
<a name="ln986">                              //    to-&gt;relPos.x(), to-&gt;relPos.y(), to-&gt;width, to-&gt;yxRatio, qPrintable(ss));</a>
<a name="ln987">                              s-&gt;setXmlText(ss);</a>
<a name="ln988">                              MeasureBase* measure = score-&gt;measures()-&gt;first();</a>
<a name="ln989">                              if (measure-&gt;type() != ElementType::VBOX) {</a>
<a name="ln990">                                    MeasureBase* mb = new VBox(score);</a>
<a name="ln991">                                    mb-&gt;setTick(Fraction(0, 1));</a>
<a name="ln992">                                    score-&gt;addMeasure(mb, measure);</a>
<a name="ln993">                                    measure = mb;</a>
<a name="ln994">                                    }</a>
<a name="ln995">                              s-&gt;setParent(measure);</a>
<a name="ln996">                              measure-&gt;add(s);</a>
<a name="ln997">                              }</a>
<a name="ln998">                              break;</a>
<a name="ln999">                        case CapellaType::VOLTA:</a>
<a name="ln1000">                              {</a>
<a name="ln1001">                              VoltaObj* vo = static_cast&lt;VoltaObj*&gt;(o);</a>
<a name="ln1002">                              ChordRest* cr1 = 0; // ChordRest where volta begins</a>
<a name="ln1003">                              ChordRest* cr2 = 0; // ChordRest where volta ends</a>
<a name="ln1004">                              bool res = findChordRests(o, score, track, tick, cr1, cr2, no, cvoice-&gt;objects);</a>
<a name="ln1005"> </a>
<a name="ln1006">                              if (res) {</a>
<a name="ln1007">                                    Volta* volta = new Volta(score);</a>
<a name="ln1008">                                    volta-&gt;setTrack(track);</a>
<a name="ln1009">                                    volta-&gt;setTrack2(track);</a>
<a name="ln1010">                                    // TODO also support endings such as &quot;1 - 3&quot;</a>
<a name="ln1011">                                    volta-&gt;setText(QString(&quot;%1.&quot;).arg(vo-&gt;to));</a>
<a name="ln1012">                                    volta-&gt;endings().append(vo-&gt;to);</a>
<a name="ln1013">                                    if (vo-&gt;bRight)</a>
<a name="ln1014">                                          volta-&gt;setVoltaType(Volta::Type::CLOSED);</a>
<a name="ln1015">                                    else</a>
<a name="ln1016">                                          volta-&gt;setVoltaType(Volta::Type::OPEN);</a>
<a name="ln1017">                                    volta-&gt;setTick(cr1-&gt;measure()-&gt;tick());</a>
<a name="ln1018">                                    volta-&gt;setTick2(cr2-&gt;measure()-&gt;tick() + cr2-&gt;measure()-&gt;ticks());</a>
<a name="ln1019">                                    score-&gt;addElement(volta);</a>
<a name="ln1020">                                    }</a>
<a name="ln1021">                              }</a>
<a name="ln1022">                              break;</a>
<a name="ln1023">                        case CapellaType::TRILL:</a>
<a name="ln1024">                              {</a>
<a name="ln1025">                              TrillObj* tro = static_cast&lt;TrillObj*&gt;(o);</a>
<a name="ln1026">                              ChordRest* cr1 = 0; // ChordRest where trill line begins</a>
<a name="ln1027">                              ChordRest* cr2 = 0; // ChordRest where trill line ends</a>
<a name="ln1028">                              bool res = findChordRests(o, score, track, tick, cr1, cr2, no, cvoice-&gt;objects);</a>
<a name="ln1029">                              if (res) {</a>
<a name="ln1030">                                    if (cr1 == cr2)</a>
<a name="ln1031">                                          qDebug(&quot;first and second anchor for trill line identical (tick %d track %d first %p second %p)&quot;,</a>
<a name="ln1032">                                                 tick.ticks(), track, cr1, cr2);</a>
<a name="ln1033">                                    else {</a>
<a name="ln1034">                                          Trill* trill = new Trill(score);</a>
<a name="ln1035">                                          trill-&gt;setTrack(track);</a>
<a name="ln1036">                                          trill-&gt;setTrack2(track);</a>
<a name="ln1037">                                          trill-&gt;setTick(cr1-&gt;tick());</a>
<a name="ln1038">                                          trill-&gt;setTick2(cr2-&gt;tick());</a>
<a name="ln1039">                                          if (!(tro-&gt;trillSign))</a>
<a name="ln1040">                                                trill-&gt;setTrillType(&quot;prallprall&quot;);</a>
<a name="ln1041">                                          score-&gt;addElement(trill);</a>
<a name="ln1042">                                          }</a>
<a name="ln1043">                                    }</a>
<a name="ln1044">                              }</a>
<a name="ln1045">                              break;</a>
<a name="ln1046">                        case CapellaType::WEDGE:</a>
<a name="ln1047">                              {</a>
<a name="ln1048">                              WedgeObj* wdgo = static_cast&lt;WedgeObj*&gt;(o);</a>
<a name="ln1049">                              ChordRest* cr1 = 0; // ChordRest where hairpin begins</a>
<a name="ln1050">                              ChordRest* cr2 = 0; // ChordRest where hairpin ends</a>
<a name="ln1051">                              bool res = findChordRests(o, score, track, tick, cr1, cr2, no, cvoice-&gt;objects);</a>
<a name="ln1052">                              if (res) {</a>
<a name="ln1053">                                    if (cr1 == cr2)</a>
<a name="ln1054">                                          qDebug(&quot;first and second anchor for hairpin identical (tick %d track %d first %p second %p)&quot;,</a>
<a name="ln1055">                                                 tick.ticks(), track, cr1, cr2);</a>
<a name="ln1056">                                    else {</a>
<a name="ln1057">                                          Hairpin* hp = new Hairpin(score);</a>
<a name="ln1058">                                          if (wdgo-&gt;decresc)</a>
<a name="ln1059">                                                hp-&gt;setHairpinType(HairpinType::DECRESC_HAIRPIN);</a>
<a name="ln1060">                                          else</a>
<a name="ln1061">                                                hp-&gt;setHairpinType(HairpinType::CRESC_HAIRPIN);</a>
<a name="ln1062">                                          hp-&gt;setTick(cr1-&gt;tick());</a>
<a name="ln1063">                                          hp-&gt;setTick2(cr2-&gt;tick());</a>
<a name="ln1064">                                          hp-&gt;setTrack(track);</a>
<a name="ln1065">                                          hp-&gt;setTrack2(track);</a>
<a name="ln1066">                                          hp-&gt;setAnchor(Spanner::Anchor::SEGMENT);</a>
<a name="ln1067">                                          score-&gt;addSpanner(hp);</a>
<a name="ln1068">                                          score-&gt;updateHairpin(hp);</a>
<a name="ln1069">                                          }</a>
<a name="ln1070">                                    }</a>
<a name="ln1071">                              }</a>
<a name="ln1072">                              break;</a>
<a name="ln1073">                        default:</a>
<a name="ln1074">                              break;</a>
<a name="ln1075">                        }</a>
<a name="ln1076">                  }</a>
<a name="ln1077">            Fraction ticks = d-&gt;ticks();</a>
<a name="ln1078">            if (d-&gt;count) {</a>
<a name="ln1079">                  Fraction f = TupletFractionCap(d-&gt;count, d-&gt;tripartite, d-&gt;isProlonging);</a>
<a name="ln1080">                  ticks = ticks / f;</a>
<a name="ln1081">                  }</a>
<a name="ln1082">            if (no-&gt;type() == CapellaNoteObjectType::REST) {</a>
<a name="ln1083">                  RestObj* o = static_cast&lt;RestObj*&gt;(no);</a>
<a name="ln1084">                  if (o-&gt;fullMeasures) {</a>
<a name="ln1085">                        Measure* m  = score-&gt;getCreateMeasure(tick);</a>
<a name="ln1086">                        Fraction ft = m-&gt;ticks();</a>
<a name="ln1087">                        ticks       = ft * o-&gt;fullMeasures;</a>
<a name="ln1088">                        }</a>
<a name="ln1089">                  }</a>
<a name="ln1090">            tick += ticks;</a>
<a name="ln1091">            }</a>
<a name="ln1092">      return endTick;</a>
<a name="ln1093">      }</a>
<a name="ln1094"> </a>
<a name="ln1095">//---------------------------------------------------------</a>
<a name="ln1096">//   needPart -- determine if a staff needs its own part</a>
<a name="ln1097">//---------------------------------------------------------</a>
<a name="ln1098"> </a>
<a name="ln1099">// As Capella does not define parts (it only knows about staves,</a>
<a name="ln1100">// MIDI instruments numbers, brackets and braces), the following</a>
<a name="ln1101">// algorithm is used:</a>
<a name="ln1102">// - every staff is a separate part</a>
<a name="ln1103">// - unless:</a>
<a name="ln1104">//   - it is in a brace</a>
<a name="ln1105">//   - it is not the first staff in the brace</a>
<a name="ln1106">//   - it has the same MIDI instrument as the previous staff</a>
<a name="ln1107">// Common cases:</a>
<a name="ln1108">// - Keyboards: two or three staves with the same MIDI instrument and a brace</a>
<a name="ln1109">//   -&gt; create one part</a>
<a name="ln1110">// - SATB: two or four staves with the same MIDI instrument and a bracket</a>
<a name="ln1111">//   -&gt; create two or four parts</a>
<a name="ln1112"> </a>
<a name="ln1113">static bool needPart(const int prevInst, const int currInst, const int staffIdx, QList&lt;CapBracket&gt; const&amp; bracketList)</a>
<a name="ln1114">      {</a>
<a name="ln1115">      foreach(CapBracket cb, bracketList) {</a>
<a name="ln1116">            if (prevInst == currInst &amp;&amp; cb.from &lt; staffIdx &amp;&amp; staffIdx &lt;= cb.to &amp;&amp; cb.curly)</a>
<a name="ln1117">                  return false;</a>
<a name="ln1118">            }</a>
<a name="ln1119">      return true;</a>
<a name="ln1120">      }</a>
<a name="ln1121"> </a>
<a name="ln1122">//---------------------------------------------------------</a>
<a name="ln1123">//   convertCapella</a>
<a name="ln1124">//---------------------------------------------------------</a>
<a name="ln1125"> </a>
<a name="ln1126">void convertCapella(Score* score, Capella* cap, bool capxMode)</a>
<a name="ln1127">      {</a>
<a name="ln1128">      if (cap-&gt;systems.isEmpty())</a>
<a name="ln1129">            return;</a>
<a name="ln1130"> </a>
<a name="ln1131">      score-&gt;style().set(Sid::measureSpacing, 1.0);</a>
<a name="ln1132">      score-&gt;setSpatium(cap-&gt;normalLineDist * DPMM);</a>
<a name="ln1133">      score-&gt;style().set(Sid::smallStaffMag, cap-&gt;smallLineDist / cap-&gt;normalLineDist);</a>
<a name="ln1134">      score-&gt;style().set(Sid::minSystemDistance, Spatium(8));</a>
<a name="ln1135">      score-&gt;style().set(Sid::maxSystemDistance, Spatium(12));</a>
<a name="ln1136">      // score-&gt;style().set(Sid::hideEmptyStaves, true);</a>
<a name="ln1137"> </a>
<a name="ln1138">#if 1</a>
<a name="ln1139">      foreach(CapSystem* csys, cap-&gt;systems) {</a>
<a name="ln1140">            qDebug(&quot;System:&quot;);</a>
<a name="ln1141">            for (CapStaff* cstaff : csys-&gt;staves) {</a>
<a name="ln1142">                  CapStaffLayout* cl = cap-&gt;staffLayout(cstaff-&gt;iLayout);</a>
<a name="ln1143">                  qDebug(&quot;  Staff layout &lt;%s&gt;&lt;%s&gt;&lt;%s&gt;&lt;%s&gt;&lt;%s&gt; %d  barline %d-%d mode %d&quot;,</a>
<a name="ln1144">                         qPrintable(cl-&gt;descr), qPrintable(cl-&gt;name), qPrintable(cl-&gt;abbrev),</a>
<a name="ln1145">                         qPrintable(cl-&gt;intermediateName), qPrintable(cl-&gt;intermediateAbbrev),</a>
<a name="ln1146">                         cstaff-&gt;iLayout, cl-&gt;barlineFrom, cl-&gt;barlineTo, cl-&gt;barlineMode);</a>
<a name="ln1147">                  }</a>
<a name="ln1148">            }</a>
<a name="ln1149">#endif</a>
<a name="ln1150"> </a>
<a name="ln1151">      //</a>
<a name="ln1152">      // find out the maximum number of staves</a>
<a name="ln1153">      //</a>
<a name="ln1154">      int staves = 0;</a>
<a name="ln1155">      foreach(CapSystem* csys, cap-&gt;systems) {</a>
<a name="ln1156">            staves = qMax(staves, csys-&gt;staves.size());</a>
<a name="ln1157">            }</a>
<a name="ln1158">      //</a>
<a name="ln1159">      // check the assumption that every stave should be</a>
<a name="ln1160">      // associated with a CapStaffLayout</a>
<a name="ln1161">      //</a>
<a name="ln1162">      if (staves != cap-&gt;staffLayouts().size()) {</a>
<a name="ln1163">            qDebug(&quot;Capella: max number of staves != number of staff layouts (%d, %d)&quot;,</a>
<a name="ln1164">                   staves, cap-&gt;staffLayouts().size());</a>
<a name="ln1165">            staves = qMax(staves, cap-&gt;staffLayouts().size());</a>
<a name="ln1166">            }</a>
<a name="ln1167"> </a>
<a name="ln1168">      // set the initial time signature</a>
<a name="ln1169">      CapStaff* cs = cap-&gt;systems[0]-&gt;staves[0];</a>
<a name="ln1170">      if (cs-&gt;log2Denom &lt;= 7)</a>
<a name="ln1171">            score-&gt;sigmap()-&gt;add(0, Fraction(cs-&gt;numerator, 1 &lt;&lt; cs-&gt;log2Denom));</a>
<a name="ln1172"> </a>
<a name="ln1173">      // create parts and staves</a>
<a name="ln1174">      Staff* bstaff = 0;</a>
<a name="ln1175">      int span = 1;</a>
<a name="ln1176">      int midiPatch = -1; // the previous MIDI patch (instrument)</a>
<a name="ln1177">      Part* part = 0;</a>
<a name="ln1178">      for (int staffIdx = 0; staffIdx &lt; staves; ++staffIdx) {</a>
<a name="ln1179">            CapStaffLayout* cl = cap-&gt;staffLayout(staffIdx);</a>
<a name="ln1180">            // qDebug(&quot;Midi staff %d program %d&quot;, staffIdx, cl-&gt;sound);</a>
<a name="ln1181"> </a>
<a name="ln1182">            // create a new part if necessary</a>
<a name="ln1183">            if (needPart(midiPatch, cl-&gt;sound, staffIdx, cap-&gt;brackets)) {</a>
<a name="ln1184">                  part = new Part(score);</a>
<a name="ln1185">                  score-&gt;appendPart(part);</a>
<a name="ln1186">                  }</a>
<a name="ln1187">            midiPatch = cl-&gt;sound;</a>
<a name="ln1188"> </a>
<a name="ln1189">            Staff* s = new Staff(score);</a>
<a name="ln1190">            s-&gt;initFromStaffType(0);</a>
<a name="ln1191"> </a>
<a name="ln1192">            s-&gt;setPart(part);</a>
<a name="ln1193">            if (cl-&gt;bPercussion)</a>
<a name="ln1194">                  part-&gt;setMidiProgram(0, 128);</a>
<a name="ln1195">            else</a>
<a name="ln1196">                  part-&gt;setMidiProgram(cl-&gt;sound, 0);</a>
<a name="ln1197">            part-&gt;setPartName(cl-&gt;descr);</a>
<a name="ln1198">            part-&gt;setPlainLongName(cl-&gt;name);</a>
<a name="ln1199">            part-&gt;setPlainShortName(cl-&gt;abbrev);</a>
<a name="ln1200"> </a>
<a name="ln1201">            // ClefType clefType = CapClef::clefType(cl-&gt;form, cl-&gt;line, cl-&gt;oct);</a>
<a name="ln1202">            // s-&gt;setClef(0, clefType);</a>
<a name="ln1203">            s-&gt;setBarLineSpan(0);</a>
<a name="ln1204">            if (bstaff == 0) {</a>
<a name="ln1205">                  bstaff = s;</a>
<a name="ln1206">                  span = 0;</a>
<a name="ln1207">                  }</a>
<a name="ln1208">            ++span;</a>
<a name="ln1209">            if (cl-&gt;barlineMode == 1) {</a>
<a name="ln1210">                  bstaff-&gt;setBarLineSpan(span != 0);</a>
<a name="ln1211">                  bstaff = 0;</a>
<a name="ln1212">                  }</a>
<a name="ln1213"> </a>
<a name="ln1214">            s-&gt;setSmall(Fraction(0,1), cl-&gt;bSmall);</a>
<a name="ln1215">            part-&gt;insertStaff(s, -1);</a>
<a name="ln1216">            Interval interval;</a>
<a name="ln1217">            // guess diatonic transposition from chromatic transposition for the instrument</a>
<a name="ln1218">            int values[23] = {-6,-6,-5,-5,-4,-3,-3,-2,-2,-1,-1,0,1,1,2,2,3,4,4,5,5,6,6};</a>
<a name="ln1219">            interval.diatonic = values[(cl-&gt;transp % 12) + 11] + (cl-&gt;transp / 12) * 7;</a>
<a name="ln1220">            interval.chromatic = cl-&gt;transp;</a>
<a name="ln1221">            s-&gt;part()-&gt;instrument()-&gt;setTranspose(interval);</a>
<a name="ln1222">            score-&gt;staves().push_back(s);</a>
<a name="ln1223">            }</a>
<a name="ln1224">      if (bstaff)</a>
<a name="ln1225">            bstaff-&gt;setBarLineSpan(span != 0);</a>
<a name="ln1226"> </a>
<a name="ln1227">      foreach(CapBracket cb, cap-&gt;brackets) {</a>
<a name="ln1228">            qDebug(&quot;Bracket %d-%d curly %d&quot;, cb.from, cb.to, cb.curly);</a>
<a name="ln1229">            Staff* staff = score-&gt;staves().value(cb.from);</a>
<a name="ln1230">            if (staff == 0) {</a>
<a name="ln1231">                  qDebug(&quot;bad bracket 'from' value&quot;);</a>
<a name="ln1232">                  continue;</a>
<a name="ln1233">                  }</a>
<a name="ln1234">            staff-&gt;setBracketType(0, cb.curly ? BracketType::BRACE : BracketType::NORMAL);</a>
<a name="ln1235">            staff-&gt;setBracketSpan(0, cb.to - cb.from + 1);</a>
<a name="ln1236">            }</a>
<a name="ln1237">      MeasureBase* measure = nullptr;</a>
<a name="ln1238">      foreach(BasicDrawObj* o, cap-&gt;backgroundChord-&gt;objects) {</a>
<a name="ln1239">            switch (o-&gt;type) {</a>
<a name="ln1240">                  case CapellaType::SIMPLE_TEXT:</a>
<a name="ln1241">                        {</a>
<a name="ln1242">                        SimpleTextObj* to = static_cast&lt;SimpleTextObj*&gt;(o);</a>
<a name="ln1243">                        Tid tid;</a>
<a name="ln1244">                        switch (to-&gt;textalign()) {</a>
<a name="ln1245">                              case 0:   tid = Tid::POET;    break;</a>
<a name="ln1246">                              case 1:   tid = Tid::TITLE;   break;</a>
<a name="ln1247">                              case 2:   tid = Tid::COMPOSER; break;</a>
<a name="ln1248">                              default:  tid = Tid::DEFAULT; break;</a>
<a name="ln1249">                              }</a>
<a name="ln1250">                        Text* s = new Text(score, tid);</a>
<a name="ln1251">                        QFont f(to-&gt;font());</a>
<a name="ln1252">                        s-&gt;setItalic(f.italic());</a>
<a name="ln1253">                        // s-&gt;setUnderline(f.underline());</a>
<a name="ln1254">                        s-&gt;setBold(f.bold());</a>
<a name="ln1255">                        s-&gt;setSize(f.pointSizeF());</a>
<a name="ln1256"> </a>
<a name="ln1257">                        QString ss = to-&gt;text();</a>
<a name="ln1258">                        s-&gt;setPlainText(ss);</a>
<a name="ln1259">                        if (!measure) {</a>
<a name="ln1260">                              measure = new VBox(score);</a>
<a name="ln1261">                              measure-&gt;setTick(Fraction(0,1));</a>
<a name="ln1262">                              score-&gt;addMeasure(measure, score-&gt;measures()-&gt;first());</a>
<a name="ln1263">                              }</a>
<a name="ln1264">                        measure-&gt;add(s);</a>
<a name="ln1265">                        // qDebug(&quot;page background object type %d (CapellaType::SIMPLE_TEXT) text %s&quot;, o-&gt;type, qPrintable(ss));</a>
<a name="ln1266">                        }</a>
<a name="ln1267">                        break;</a>
<a name="ln1268">                  default:</a>
<a name="ln1269">                        qDebug(&quot;page background object type %d&quot;, int(o-&gt;type));</a>
<a name="ln1270">                        break;</a>
<a name="ln1271">                  }</a>
<a name="ln1272">            }</a>
<a name="ln1273"> </a>
<a name="ln1274">      if (cap-&gt;topDist) {</a>
<a name="ln1275">            VBox* mb = 0;</a>
<a name="ln1276">            MeasureBaseList* mbl = score-&gt;measures();</a>
<a name="ln1277">            if (mbl-&gt;size() &amp;&amp; mbl-&gt;first()-&gt;type() == ElementType::VBOX)</a>
<a name="ln1278">                  mb = static_cast&lt;VBox*&gt;(mbl-&gt;first());</a>
<a name="ln1279">            else {</a>
<a name="ln1280">                  VBox* vb = new VBox(score);</a>
<a name="ln1281">                  vb-&gt;setTick(Fraction(0,1));</a>
<a name="ln1282">                  score-&gt;addMeasure(vb, mb);</a>
<a name="ln1283">                  mb = vb;</a>
<a name="ln1284">                  }</a>
<a name="ln1285">            mb-&gt;setBoxHeight(Spatium(cap-&gt;topDist));</a>
<a name="ln1286">            }</a>
<a name="ln1287"> </a>
<a name="ln1288">      Fraction systemTick = Fraction(0,1);</a>
<a name="ln1289">      foreach(CapSystem* csys, cap-&gt;systems) {</a>
<a name="ln1290">            qDebug(&quot;readCapSystem&quot;);</a>
<a name="ln1291">            /*</a>
<a name="ln1292">            if (csys-&gt;explLeftIndent &gt; 0) {</a>
<a name="ln1293">                  HBox* mb = new HBox(score);</a>
<a name="ln1294">                  mb-&gt;setTick(systemTick);</a>
<a name="ln1295">                  mb-&gt;setBoxWidth(Spatium(csys-&gt;explLeftIndent));</a>
<a name="ln1296">                  score-&gt;addMeasure(mb);</a>
<a name="ln1297">                  }</a>
<a name="ln1298">            */</a>
<a name="ln1299">            Fraction mtick = Fraction(0,1);</a>
<a name="ln1300">            for (CapStaff* cstaff : csys-&gt;staves) {</a>
<a name="ln1301">                  //</a>
<a name="ln1302">                  // assumption: layout index is mscore staffIdx</a>
<a name="ln1303">                  //    which means that there is a 1:1 relation between layout/staff</a>
<a name="ln1304">                  //</a>
<a name="ln1305"> </a>
<a name="ln1306">                  qDebug(&quot;  ReadCapStaff %d/%d&quot;, cstaff-&gt;numerator, 1 &lt;&lt; cstaff-&gt;log2Denom);</a>
<a name="ln1307">                  int staffIdx = cstaff-&gt;iLayout;</a>
<a name="ln1308">                  int voice = 0;</a>
<a name="ln1309">                  for (CapVoice* cvoice : cstaff-&gt;voices) {</a>
<a name="ln1310">                        Fraction tick = readCapVoice(score, cvoice, staffIdx, systemTick, capxMode);</a>
<a name="ln1311">                        ++voice;</a>
<a name="ln1312">                        if (tick &gt; mtick)</a>
<a name="ln1313">                              mtick = tick;</a>
<a name="ln1314">                        }</a>
<a name="ln1315">                  }</a>
<a name="ln1316">            Measure* m = score-&gt;tick2measure(mtick - Fraction::fromTicks(1));</a>
<a name="ln1317">            if (m &amp;&amp; !m-&gt;lineBreak()) {</a>
<a name="ln1318">                  LayoutBreak* lb = new LayoutBreak(score);</a>
<a name="ln1319">                  lb-&gt;setLayoutBreakType(LayoutBreak::Type::LINE);</a>
<a name="ln1320">                  lb-&gt;setTrack(-1);       // this are system elements</a>
<a name="ln1321">                  m-&gt;add(lb);</a>
<a name="ln1322">                  }</a>
<a name="ln1323">            systemTick = mtick;</a>
<a name="ln1324">            }</a>
<a name="ln1325"> </a>
<a name="ln1326">      //</a>
<a name="ln1327">      // fill empty measures with rests</a>
<a name="ln1328">      //</a>
<a name="ln1329">      SegmentType st = SegmentType::ChordRest;</a>
<a name="ln1330">      for (Measure* m = score-&gt;firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln1331">            for (int staffIdx = 0; staffIdx &lt; score-&gt;staves().size(); ++staffIdx) {</a>
<a name="ln1332">                  bool empty = true;</a>
<a name="ln1333">                  for (Segment* s = m-&gt;first(st); s; s = s-&gt;next(st)) {</a>
<a name="ln1334">                        if (s-&gt;element(staffIdx * VOICES)) {</a>
<a name="ln1335">                              empty = false;</a>
<a name="ln1336">                              break;</a>
<a name="ln1337">                              }</a>
<a name="ln1338">                        }</a>
<a name="ln1339">                  if (empty) {</a>
<a name="ln1340"> </a>
<a name="ln1341">                        if ((m-&gt;ticks() == m-&gt;timesig())) {</a>
<a name="ln1342">                              Segment* s = m-&gt;getSegment(SegmentType::ChordRest, m-&gt;tick());</a>
<a name="ln1343">                              Rest* rest = new Rest(score);</a>
<a name="ln1344">                              rest-&gt;setDurationType(TDuration::DurationType::V_MEASURE);</a>
<a name="ln1345">                              rest-&gt;setTicks(m-&gt;ticks());</a>
<a name="ln1346">                              rest-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1347">                              s-&gt;add(rest);</a>
<a name="ln1348">                              }</a>
<a name="ln1349">                        else {</a>
<a name="ln1350">                              auto durList = toDurationList(m-&gt;ticks(), true);</a>
<a name="ln1351">                              int tickOffset = 0;</a>
<a name="ln1352">                              for (auto d : durList) {</a>
<a name="ln1353">                                    Segment* s = m-&gt;getSegment(SegmentType::ChordRest, m-&gt;tick() + Fraction::fromTicks(tickOffset));</a>
<a name="ln1354">                                    Rest* rest = new Rest(score);</a>
<a name="ln1355">                                    rest-&gt;setDurationType(d);</a>
<a name="ln1356">                                    rest-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln1357">                                    s-&gt;add(rest);</a>
<a name="ln1358">                                    tickOffset += d.ticks().ticks();</a>
<a name="ln1359">                                    }</a>
<a name="ln1360">                              }</a>
<a name="ln1361">                        }</a>
<a name="ln1362">                  }</a>
<a name="ln1363">            }</a>
<a name="ln1364">      // score-&gt;connectSlurs();</a>
<a name="ln1365">      score-&gt;connectTies();</a>
<a name="ln1366">      score-&gt;fixTicks();</a>
<a name="ln1367">      score-&gt;setPlaylistDirty();</a>
<a name="ln1368">      score-&gt;setLayoutAll();</a>
<a name="ln1369">      score-&gt;addLayoutFlags(LayoutFlag::FIX_PITCH_VELO);</a>
<a name="ln1370">      }</a>
<a name="ln1371"> </a>
<a name="ln1372">//---------------------------------------------------------</a>
<a name="ln1373">//   Capella</a>
<a name="ln1374">//---------------------------------------------------------</a>
<a name="ln1375"> </a>
<a name="ln1376">Capella::Capella()</a>
<a name="ln1377">      {</a>
<a name="ln1378">      author   = 0;</a>
<a name="ln1379">      keywords = 0;</a>
<a name="ln1380">      comment  = 0;</a>
<a name="ln1381">      }</a>
<a name="ln1382"> </a>
<a name="ln1383">Capella::~Capella()</a>
<a name="ln1384">      {</a>
<a name="ln1385">      delete[] author;</a>
<a name="ln1386">      delete[] keywords;</a>
<a name="ln1387">      delete[] comment;</a>
<a name="ln1388">      }</a>
<a name="ln1389"> </a>
<a name="ln1390">//---------------------------------------------------------</a>
<a name="ln1391">//   SlurObj::read</a>
<a name="ln1392">//---------------------------------------------------------</a>
<a name="ln1393"> </a>
<a name="ln1394">void SlurObj::read()</a>
<a name="ln1395">      {</a>
<a name="ln1396">      BasicDrawObj::read();</a>
<a name="ln1397">      for (int i = 0; i &lt; 4; ++i) {</a>
<a name="ln1398">            bezierPoint[i].setX(cap-&gt;readInt());</a>
<a name="ln1399">            bezierPoint[i].setY(cap-&gt;readInt());</a>
<a name="ln1400">            }</a>
<a name="ln1401">      color     = cap-&gt;readColor();</a>
<a name="ln1402">      nEnd      = cap-&gt;readByte();</a>
<a name="ln1403">      nMid      = cap-&gt;readByte();</a>
<a name="ln1404">      nDotDist  = cap-&gt;readByte();</a>
<a name="ln1405">      nDotWidth = cap-&gt;readByte();</a>
<a name="ln1406">      // qDebug(&quot;SlurObj nEnd %d nMid %d nDotDist %d nDotWidth %d&quot;,</a>
<a name="ln1407">      //        nEnd, nMid, nDotDist, nDotWidth);</a>
<a name="ln1408">      }</a>
<a name="ln1409"> </a>
<a name="ln1410">//---------------------------------------------------------</a>
<a name="ln1411">//   read</a>
<a name="ln1412">//---------------------------------------------------------</a>
<a name="ln1413"> </a>
<a name="ln1414">void TextObj::read()</a>
<a name="ln1415">      {</a>
<a name="ln1416">      BasicRectObj::read();</a>
<a name="ln1417">      unsigned size = cap-&gt;readUnsigned();</a>
<a name="ln1418">#if (!defined (_MSCVER) &amp;&amp; !defined (_MSC_VER))</a>
<a name="ln1419">      char txt[size+1];</a>
<a name="ln1420">#else</a>
<a name="ln1421">      // MSVC does not support VLA. Replace with std::vector. If profiling determines that the</a>
<a name="ln1422">      //    heap allocation is slow, an optimization might be used.</a>
<a name="ln1423">      std::vector&lt;char&gt; vtxt(size+1);</a>
<a name="ln1424">      char* txt = vtxt.data();</a>
<a name="ln1425">#endif</a>
<a name="ln1426">      cap-&gt;read(txt, size);</a>
<a name="ln1427">      txt[size] = 0;</a>
<a name="ln1428">      text = QString(txt);</a>
<a name="ln1429">      // qDebug(&quot;read textObj len %d &lt;%s&gt;&quot;, size, txt);</a>
<a name="ln1430">      }</a>
<a name="ln1431"> </a>
<a name="ln1432">//---------------------------------------------------------</a>
<a name="ln1433">//   read</a>
<a name="ln1434">//---------------------------------------------------------</a>
<a name="ln1435"> </a>
<a name="ln1436">void SimpleTextObj::read()</a>
<a name="ln1437">      {</a>
<a name="ln1438">      BasicDrawObj::read();</a>
<a name="ln1439">      relPos = cap-&gt;readPoint();</a>
<a name="ln1440">      align  = cap-&gt;readByte();</a>
<a name="ln1441">      _font  = cap-&gt;readFont();</a>
<a name="ln1442">      _text  = cap-&gt;readQString();</a>
<a name="ln1443">      // qDebug(&quot;read SimpletextObj(%f,%f) len %zd &lt;%s&gt;&quot;,</a>
<a name="ln1444">      //        relPos.x(), relPos.y(), _text.length(), qPrintable(_text));</a>
<a name="ln1445">      }</a>
<a name="ln1446"> </a>
<a name="ln1447">//---------------------------------------------------------</a>
<a name="ln1448">//   LineObj::read</a>
<a name="ln1449">//---------------------------------------------------------</a>
<a name="ln1450"> </a>
<a name="ln1451">void LineObj::read()</a>
<a name="ln1452">      {</a>
<a name="ln1453">      BasicDrawObj::read();</a>
<a name="ln1454">      pt1       = cap-&gt;readPoint();</a>
<a name="ln1455">      pt2       = cap-&gt;readPoint();</a>
<a name="ln1456">      color     = cap-&gt;readColor();</a>
<a name="ln1457">      lineWidth = cap-&gt;readByte();</a>
<a name="ln1458">      // qDebug(&quot;LineObj: %f:%f  %f:%f  width %d&quot;, pt1.x(), pt1.y(), pt2.x(), pt2.y(), lineWidth);</a>
<a name="ln1459">      }</a>
<a name="ln1460"> </a>
<a name="ln1461">//---------------------------------------------------------</a>
<a name="ln1462">//   BracketObj::read</a>
<a name="ln1463">//---------------------------------------------------------</a>
<a name="ln1464"> </a>
<a name="ln1465">void BracketObj::read()</a>
<a name="ln1466">      {</a>
<a name="ln1467">      LineObj::read();</a>
<a name="ln1468">      orientation = cap-&gt;readByte();</a>
<a name="ln1469">      number      = cap-&gt;readByte();</a>
<a name="ln1470">      }</a>
<a name="ln1471"> </a>
<a name="ln1472">//---------------------------------------------------------</a>
<a name="ln1473">//   GroupObj::read</a>
<a name="ln1474">//---------------------------------------------------------</a>
<a name="ln1475"> </a>
<a name="ln1476">void GroupObj::read()</a>
<a name="ln1477">      {</a>
<a name="ln1478">      BasicDrawObj::read();</a>
<a name="ln1479">      relPos = cap-&gt;readPoint();</a>
<a name="ln1480">      objects = cap-&gt;readDrawObjectArray();</a>
<a name="ln1481">      }</a>
<a name="ln1482"> </a>
<a name="ln1483">//---------------------------------------------------------</a>
<a name="ln1484">//   TransposableObj::read</a>
<a name="ln1485">//---------------------------------------------------------</a>
<a name="ln1486"> </a>
<a name="ln1487">void TransposableObj::read()</a>
<a name="ln1488">      {</a>
<a name="ln1489">      BasicDrawObj::read();</a>
<a name="ln1490">      relPos = cap-&gt;readPoint();</a>
<a name="ln1491">      b = cap-&gt;readByte();</a>
<a name="ln1492">      if (b != 12 &amp;&amp; b != 21)</a>
<a name="ln1493">            qDebug(&quot;TransposableObj::read: warning: unknown drawObjectArray size of %d&quot;, b);</a>
<a name="ln1494">      variants = cap-&gt;readDrawObjectArray();</a>
<a name="ln1495">      if (variants.size() != b)</a>
<a name="ln1496">            qDebug(&quot;variants.size %d, expected %d&quot;, variants.size(), b);</a>
<a name="ln1497">      Q_ASSERT(variants.size() == b);</a>
<a name="ln1498">      /*int nRefNote =*/ cap-&gt;readInt();</a>
<a name="ln1499">      }</a>
<a name="ln1500"> </a>
<a name="ln1501">//---------------------------------------------------------</a>
<a name="ln1502">//   MetafileObj::read</a>
<a name="ln1503">//---------------------------------------------------------</a>
<a name="ln1504"> </a>
<a name="ln1505">void MetafileObj::read()</a>
<a name="ln1506">      {</a>
<a name="ln1507">      BasicRectObj::read();</a>
<a name="ln1508">      unsigned size = cap-&gt;readUnsigned();</a>
<a name="ln1509">#if (!defined (_MSCVER) &amp;&amp; !defined (_MSC_VER))</a>
<a name="ln1510">      char enhMetaFileBits[size];</a>
<a name="ln1511">#else</a>
<a name="ln1512">      // MSVC does not support VLA. Replace with std::vector. If profiling determines that the</a>
<a name="ln1513">      //    heap allocation is slow, an optimization might be used.</a>
<a name="ln1514">      std::vector&lt;char&gt; vEnhMetaFileBits(size);</a>
<a name="ln1515">      char* enhMetaFileBits = vEnhMetaFileBits.data();</a>
<a name="ln1516">#endif</a>
<a name="ln1517">      cap-&gt;read(enhMetaFileBits, size);</a>
<a name="ln1518">      // qDebug(&quot;MetaFileObj::read %d bytes&quot;, size);</a>
<a name="ln1519">      }</a>
<a name="ln1520"> </a>
<a name="ln1521">//---------------------------------------------------------</a>
<a name="ln1522">//   RectEllipseObj::read</a>
<a name="ln1523">//---------------------------------------------------------</a>
<a name="ln1524"> </a>
<a name="ln1525">void RectEllipseObj::read()</a>
<a name="ln1526">      {</a>
<a name="ln1527">      LineObj::read();</a>
<a name="ln1528">      radius = cap-&gt;readInt();</a>
<a name="ln1529">      bFilled = cap-&gt;readByte();</a>
<a name="ln1530">      clrFill = cap-&gt;readColor();</a>
<a name="ln1531">      }</a>
<a name="ln1532"> </a>
<a name="ln1533">//---------------------------------------------------------</a>
<a name="ln1534">//   PolygonObj::read</a>
<a name="ln1535">//---------------------------------------------------------</a>
<a name="ln1536"> </a>
<a name="ln1537">void PolygonObj::read()</a>
<a name="ln1538">      {</a>
<a name="ln1539">      BasicDrawObj::read();</a>
<a name="ln1540"> </a>
<a name="ln1541">      unsigned nPoints = cap-&gt;readUnsigned();</a>
<a name="ln1542">      for (unsigned i = 0; i &lt; nPoints; ++i)</a>
<a name="ln1543">            cap-&gt;readPoint();</a>
<a name="ln1544"> </a>
<a name="ln1545">      bFilled = cap-&gt;readByte();</a>
<a name="ln1546">      lineWidth = cap-&gt;readByte();</a>
<a name="ln1547">      clrFill = cap-&gt;readColor();</a>
<a name="ln1548">      clrLine = cap-&gt;readColor();</a>
<a name="ln1549">      }</a>
<a name="ln1550"> </a>
<a name="ln1551">//---------------------------------------------------------</a>
<a name="ln1552">//   WavyLineObj::read</a>
<a name="ln1553">//---------------------------------------------------------</a>
<a name="ln1554"> </a>
<a name="ln1555">void WavyLineObj::read()</a>
<a name="ln1556">      {</a>
<a name="ln1557">      LineObj::read();</a>
<a name="ln1558">      waveLen = cap-&gt;readByte();</a>
<a name="ln1559">      adapt = cap-&gt;readByte();</a>
<a name="ln1560">      }</a>
<a name="ln1561"> </a>
<a name="ln1562">//---------------------------------------------------------</a>
<a name="ln1563">//   NotelinesObj::read</a>
<a name="ln1564">//---------------------------------------------------------</a>
<a name="ln1565"> </a>
<a name="ln1566">void NotelinesObj::read()</a>
<a name="ln1567">      {</a>
<a name="ln1568">      BasicDrawObj::read();</a>
<a name="ln1569"> </a>
<a name="ln1570">      x0 = cap-&gt;readInt();</a>
<a name="ln1571">      x1 = cap-&gt;readInt();</a>
<a name="ln1572">      y  = cap-&gt;readInt();</a>
<a name="ln1573">      color = cap-&gt;readColor();</a>
<a name="ln1574"> </a>
<a name="ln1575">      unsigned char b = cap-&gt;readByte();</a>
<a name="ln1576">      switch (b) {</a>
<a name="ln1577">            case 1: break; // Einlinienzeile</a>
<a name="ln1578">            case 2: break; // Standard (5 Linien)</a>
<a name="ln1579">            default: {</a>
<a name="ln1580">                  Q_ASSERT(b == 0);</a>
<a name="ln1581">                  char lines[11];</a>
<a name="ln1582">                  cap-&gt;read(lines, 11);</a>
<a name="ln1583">                  break;</a>
<a name="ln1584">                  }</a>
<a name="ln1585">            }</a>
<a name="ln1586">      }</a>
<a name="ln1587"> </a>
<a name="ln1588">//---------------------------------------------------------</a>
<a name="ln1589">//   VoltaObj::read</a>
<a name="ln1590">//---------------------------------------------------------</a>
<a name="ln1591"> </a>
<a name="ln1592">void VoltaObj::read()</a>
<a name="ln1593">      {</a>
<a name="ln1594">      BasicDrawObj::read();</a>
<a name="ln1595"> </a>
<a name="ln1596">      x0 = cap-&gt;readInt();</a>
<a name="ln1597">      x1 = cap-&gt;readInt();</a>
<a name="ln1598">      y  = cap-&gt;readInt();</a>
<a name="ln1599">      color = cap-&gt;readColor();</a>
<a name="ln1600"> </a>
<a name="ln1601">      unsigned char f = cap-&gt;readByte();</a>
<a name="ln1602">      bLeft      = (f &amp; 1) != 0; // links abgeknickt</a>
<a name="ln1603">      bRight     = (f &amp; 2) != 0; // rechts abgeknickt</a>
<a name="ln1604">      bDotted    = (f &amp; 4) != 0;</a>
<a name="ln1605">      allNumbers = (f &amp; 8) != 0;</a>
<a name="ln1606"> </a>
<a name="ln1607">      unsigned char numbers = cap-&gt;readByte();</a>
<a name="ln1608">      from = numbers &amp; 0x0F;</a>
<a name="ln1609">      to = (numbers &gt;&gt; 4) &amp; 0x0F;</a>
<a name="ln1610">      qDebug(&quot;VoltaObj::read x0 %d x1 %d y %d bLeft %d bRight %d bDotted %d allNumbers %d from %d to %d&quot;,</a>
<a name="ln1611">             x0, x1, y, bLeft, bRight, bDotted, allNumbers, from, to);</a>
<a name="ln1612">      }</a>
<a name="ln1613"> </a>
<a name="ln1614">//---------------------------------------------------------</a>
<a name="ln1615">//   GuitarObj::read</a>
<a name="ln1616">//---------------------------------------------------------</a>
<a name="ln1617"> </a>
<a name="ln1618">void GuitarObj::read()</a>
<a name="ln1619">      {</a>
<a name="ln1620">      BasicDrawObj::read();</a>
<a name="ln1621">      relPos  = cap-&gt;readPoint();</a>
<a name="ln1622">      color   = cap-&gt;readColor();</a>
<a name="ln1623">      flags   = cap-&gt;readWord();</a>
<a name="ln1624">      strings = cap-&gt;readDWord();   // 8 Saiten in 8 Halbbytes</a>
<a name="ln1625">      }</a>
<a name="ln1626"> </a>
<a name="ln1627">//---------------------------------------------------------</a>
<a name="ln1628">//   TrillObj::read</a>
<a name="ln1629">//---------------------------------------------------------</a>
<a name="ln1630"> </a>
<a name="ln1631">void TrillObj::read()</a>
<a name="ln1632">      {</a>
<a name="ln1633">      BasicDrawObj::read();</a>
<a name="ln1634">      x0 = cap-&gt;readInt();</a>
<a name="ln1635">      x1 = cap-&gt;readInt();</a>
<a name="ln1636">      y  = cap-&gt;readInt();</a>
<a name="ln1637">      color = cap-&gt;readColor();</a>
<a name="ln1638">      trillSign = cap-&gt;readByte();</a>
<a name="ln1639">      }</a>
<a name="ln1640"> </a>
<a name="ln1641">//---------------------------------------------------------</a>
<a name="ln1642">//   readDrawObjectArray</a>
<a name="ln1643">//---------------------------------------------------------</a>
<a name="ln1644"> </a>
<a name="ln1645">QList&lt;BasicDrawObj*&gt; Capella::readDrawObjectArray()</a>
<a name="ln1646">      {</a>
<a name="ln1647">      QList&lt;BasicDrawObj*&gt; ol;</a>
<a name="ln1648">      int n = readUnsigned();       // draw obj array</a>
<a name="ln1649"> </a>
<a name="ln1650">      // qDebug(&quot;readDrawObjectArray %d elements&quot;, n);</a>
<a name="ln1651">      for (int i = 0; i &lt; n; ++i) {</a>
<a name="ln1652">            CapellaType type = CapellaType(readByte());</a>
<a name="ln1653"> </a>
<a name="ln1654">            // qDebug(&quot;   readDrawObject %d of %d, type %d&quot;, i, n, type);</a>
<a name="ln1655">            switch (type) {</a>
<a name="ln1656">                  case  CapellaType::GROUP: {</a>
<a name="ln1657">                        GroupObj* o = new GroupObj(this);</a>
<a name="ln1658">                        o-&gt;read();</a>
<a name="ln1659">                        ol.append(o);</a>
<a name="ln1660">                        }</a>
<a name="ln1661">                        break;</a>
<a name="ln1662">                  case  CapellaType::TRANSPOSABLE: {</a>
<a name="ln1663">                        TransposableObj* o = new TransposableObj(this);</a>
<a name="ln1664">                        o-&gt;read();</a>
<a name="ln1665">                        ol.append(o);</a>
<a name="ln1666">                        }</a>
<a name="ln1667">                        break;</a>
<a name="ln1668">                  case  CapellaType::METAFILE: {</a>
<a name="ln1669">                        MetafileObj* o = new MetafileObj(this);</a>
<a name="ln1670">                        o-&gt;read();</a>
<a name="ln1671">                        ol.append(o);</a>
<a name="ln1672">                        }</a>
<a name="ln1673">                        break;</a>
<a name="ln1674">                  case  CapellaType::SIMPLE_TEXT: {</a>
<a name="ln1675">                        SimpleTextObj* o = new SimpleTextObj(this);</a>
<a name="ln1676">                        o-&gt;read();</a>
<a name="ln1677">                        ol.append(o);</a>
<a name="ln1678">                        }</a>
<a name="ln1679">                        break;</a>
<a name="ln1680">                  case  CapellaType::TEXT: {</a>
<a name="ln1681">                        TextObj* o = new TextObj(this);</a>
<a name="ln1682">                        o-&gt;read();</a>
<a name="ln1683">                        ol.append(o);</a>
<a name="ln1684">                        }</a>
<a name="ln1685">                        break;</a>
<a name="ln1686">                  case  CapellaType::RECT_ELLIPSE: {</a>
<a name="ln1687">                        RectEllipseObj* o = new RectEllipseObj(this);</a>
<a name="ln1688">                        o-&gt;read();</a>
<a name="ln1689">                        ol.append(o);</a>
<a name="ln1690">                        }</a>
<a name="ln1691">                        break;</a>
<a name="ln1692">                  case CapellaType::LINE: {</a>
<a name="ln1693">                        LineObj* o = new LineObj(this);</a>
<a name="ln1694">                        o-&gt;read();</a>
<a name="ln1695">                        ol.append(o);</a>
<a name="ln1696">                        }</a>
<a name="ln1697">                        break;</a>
<a name="ln1698">                  case  CapellaType::POLYGON: {</a>
<a name="ln1699">                        PolygonObj* o = new PolygonObj(this);</a>
<a name="ln1700">                        o-&gt;read();</a>
<a name="ln1701">                        ol.append(o);</a>
<a name="ln1702">                        }</a>
<a name="ln1703">                        break;</a>
<a name="ln1704">                  case  CapellaType::WAVY_LINE: {</a>
<a name="ln1705">                        WavyLineObj* o = new WavyLineObj(this);</a>
<a name="ln1706">                        o-&gt;read();</a>
<a name="ln1707">                        ol.append(o);</a>
<a name="ln1708">                        }</a>
<a name="ln1709">                        break;</a>
<a name="ln1710">                  case CapellaType::SLUR: {</a>
<a name="ln1711">                        SlurObj* o = new SlurObj(this);</a>
<a name="ln1712">                        o-&gt;read();</a>
<a name="ln1713">                        ol.append(o);</a>
<a name="ln1714">                        }</a>
<a name="ln1715">                        break;</a>
<a name="ln1716">                  case  CapellaType::NOTE_LINES: {</a>
<a name="ln1717">                        NotelinesObj* o = new NotelinesObj(this);</a>
<a name="ln1718">                        o-&gt;read();</a>
<a name="ln1719">                        ol.append(o);</a>
<a name="ln1720">                        }</a>
<a name="ln1721">                        break;</a>
<a name="ln1722">                  case CapellaType::WEDGE: {</a>
<a name="ln1723">                        WedgeObj* o = new WedgeObj(this);</a>
<a name="ln1724">                        o-&gt;read();</a>
<a name="ln1725">                        ol.append(o);</a>
<a name="ln1726">                        }</a>
<a name="ln1727">                        break;</a>
<a name="ln1728">                  case  CapellaType::VOLTA: {</a>
<a name="ln1729">                        VoltaObj* o = new VoltaObj(this);</a>
<a name="ln1730">                        o-&gt;read();</a>
<a name="ln1731">                        ol.append(o);</a>
<a name="ln1732">                        }</a>
<a name="ln1733">                        break;</a>
<a name="ln1734">                  case CapellaType::BRACKET: {</a>
<a name="ln1735">                        BracketObj* o = new BracketObj(this);</a>
<a name="ln1736">                        o-&gt;read();</a>
<a name="ln1737">                        ol.append(o);</a>
<a name="ln1738">                        }</a>
<a name="ln1739">                        break;</a>
<a name="ln1740">                  case  CapellaType::GUITAR: {</a>
<a name="ln1741">                        GuitarObj* o = new GuitarObj(this);</a>
<a name="ln1742">                        o-&gt;read();</a>
<a name="ln1743">                        ol.append(o);</a>
<a name="ln1744">                        }</a>
<a name="ln1745">                        break;</a>
<a name="ln1746">                  case  CapellaType::TRILL: {</a>
<a name="ln1747">                        TrillObj* o = new TrillObj(this);</a>
<a name="ln1748">                        o-&gt;read();</a>
<a name="ln1749">                        ol.append(o);</a>
<a name="ln1750">                        }</a>
<a name="ln1751">                        break;</a>
<a name="ln1752">                  default:</a>
<a name="ln1753">                        qFatal(&quot;readDrawObjectArray unsupported type %d&quot;, int(type));</a>
<a name="ln1754">                        break;</a>
<a name="ln1755">                  }</a>
<a name="ln1756">            }</a>
<a name="ln1757">      return ol;</a>
<a name="ln1758">      }</a>
<a name="ln1759"> </a>
<a name="ln1760">//---------------------------------------------------------</a>
<a name="ln1761">//   BasicDrawObj</a>
<a name="ln1762">//---------------------------------------------------------</a>
<a name="ln1763"> </a>
<a name="ln1764">void BasicDrawObj::read()</a>
<a name="ln1765">      {</a>
<a name="ln1766">      modeX       = cap-&gt;readByte();      // anchor mode</a>
<a name="ln1767">      modeY       = cap-&gt;readByte();</a>
<a name="ln1768">      distY       = cap-&gt;readByte();</a>
<a name="ln1769">      flags       = cap-&gt;readByte();</a>
<a name="ln1770">      nRefNote    = cap-&gt;readInt();</a>
<a name="ln1771">      short range = cap-&gt;readWord();</a>
<a name="ln1772">      nNotes      = range &amp; 0x0fff;</a>
<a name="ln1773">      background  = range &amp; 0x1000;</a>
<a name="ln1774">      pageRange   = (range &gt;&gt; 13) &amp; 0x7;</a>
<a name="ln1775">      qDebug(&quot;BasicDrawObj::read modeX %d modeY %d distY %d flags %d nRefNote %d nNotes %d background %d pageRange %d&quot;,</a>
<a name="ln1776">             modeX, modeY, distY, flags, nRefNote, nNotes, background, pageRange);</a>
<a name="ln1777">      }</a>
<a name="ln1778"> </a>
<a name="ln1779">//---------------------------------------------------------</a>
<a name="ln1780">//   BasicRectObj</a>
<a name="ln1781">//---------------------------------------------------------</a>
<a name="ln1782"> </a>
<a name="ln1783">void BasicRectObj::read()</a>
<a name="ln1784">      {</a>
<a name="ln1785">      BasicDrawObj::read();</a>
<a name="ln1786">      relPos  = cap-&gt;readPoint();</a>
<a name="ln1787">      width   = cap-&gt;readInt();</a>
<a name="ln1788">      yxRatio = cap-&gt;readInt();</a>
<a name="ln1789">      height  = (width * yxRatio) / 0x10000;</a>
<a name="ln1790">      }</a>
<a name="ln1791"> </a>
<a name="ln1792">//---------------------------------------------------------</a>
<a name="ln1793">//   read</a>
<a name="ln1794">//---------------------------------------------------------</a>
<a name="ln1795"> </a>
<a name="ln1796">void BasicDurationalObj::read()</a>
<a name="ln1797">      {</a>
<a name="ln1798">      unsigned char b = cap-&gt;readByte();</a>
<a name="ln1799">      nDots      = b &amp; 0x03;</a>
<a name="ln1800">      noDuration = b &amp; 0x04;</a>
<a name="ln1801">      postGrace  = b &amp; 0x08;</a>
<a name="ln1802">      bSmall     = b &amp; 0x10;</a>
<a name="ln1803">      invisible  = b &amp; 0x20;</a>
<a name="ln1804">      notBlack   = b &amp; 0x40;</a>
<a name="ln1805">      Q_ASSERT(!(b &amp; 0x80));</a>
<a name="ln1806"> </a>
<a name="ln1807">      color = notBlack ? cap-&gt;readColor() : Qt::black;</a>
<a name="ln1808"> </a>
<a name="ln1809">      unsigned char c = cap-&gt;readByte();</a>
<a name="ln1810">      t = TIMESTEP(c &amp; 0x0f);</a>
<a name="ln1811">      horizontalShift = (c &amp; 0x10) ? cap-&gt;readInt() : 0;</a>
<a name="ln1812">      count = 0;</a>
<a name="ln1813">      tripartite = 0;</a>
<a name="ln1814">      isProlonging = 0;</a>
<a name="ln1815">      if (c &amp; 0x20) {</a>
<a name="ln1816">            unsigned char tuplet = cap-&gt;readByte();</a>
<a name="ln1817">            count        = tuplet &amp; 0x0f;</a>
<a name="ln1818">            tripartite   = (tuplet &amp; 0x10) != 0;</a>
<a name="ln1819">            isProlonging = (tuplet &amp; 0x20) != 0;</a>
<a name="ln1820">            if (tuplet &amp; 0xc0)</a>
<a name="ln1821">                  qDebug(&quot;bad tuplet value 0x%02x&quot;, tuplet);</a>
<a name="ln1822">            }</a>
<a name="ln1823">      if (c &amp; 0x40) {</a>
<a name="ln1824">            objects = cap-&gt;readDrawObjectArray();</a>
<a name="ln1825">            }</a>
<a name="ln1826">      Q_ASSERT(!(c &amp; 0x80));</a>
<a name="ln1827">      qDebug(&quot;DurationObj ndots %d nodur %d postgr %d bsm %d inv %d notbl %d t %d hsh %d cnt %d trp %d ispro %d&quot;,</a>
<a name="ln1828">             nDots, noDuration, postGrace, bSmall, invisible, notBlack, int(t), horizontalShift, count, tripartite, isProlonging</a>
<a name="ln1829">             );</a>
<a name="ln1830">      }</a>
<a name="ln1831"> </a>
<a name="ln1832">//---------------------------------------------------------</a>
<a name="ln1833">//   RestObj</a>
<a name="ln1834">//---------------------------------------------------------</a>
<a name="ln1835"> </a>
<a name="ln1836">RestObj::RestObj(Capella* c)</a>
<a name="ln1837">      : BasicDurationalObj(c), NoteObj(CapellaNoteObjectType::REST)</a>
<a name="ln1838">      {</a>
<a name="ln1839">      cap          = c;</a>
<a name="ln1840">      fullMeasures = 0;</a>
<a name="ln1841">      vertShift    = 0;</a>
<a name="ln1842">      }</a>
<a name="ln1843"> </a>
<a name="ln1844">//---------------------------------------------------------</a>
<a name="ln1845">//   read</a>
<a name="ln1846">//---------------------------------------------------------</a>
<a name="ln1847"> </a>
<a name="ln1848">void RestObj::read()</a>
<a name="ln1849">      {</a>
<a name="ln1850">      BasicDurationalObj::read();</a>
<a name="ln1851">      unsigned char b        = cap-&gt;readByte();</a>
<a name="ln1852">      bool bMultiMeasures    = b &amp; 1;</a>
<a name="ln1853">      bVerticalCentered      = b &amp; 2;</a>
<a name="ln1854">      bool bAddVerticalShift = b &amp; 4;</a>
<a name="ln1855">      if (b &amp; 0xf8)</a>
<a name="ln1856">            qFatal(&quot;RestObj: res. bits 0x%02x&quot;, b);</a>
<a name="ln1857">      fullMeasures = bMultiMeasures ? cap-&gt;readUnsigned() : 0;</a>
<a name="ln1858">      vertShift    = bAddVerticalShift ? cap-&gt;readInt() : 0;</a>
<a name="ln1859">      }</a>
<a name="ln1860"> </a>
<a name="ln1861">//---------------------------------------------------------</a>
<a name="ln1862">//   ChordObj</a>
<a name="ln1863">//---------------------------------------------------------</a>
<a name="ln1864"> </a>
<a name="ln1865">ChordObj::ChordObj(Capella* c)</a>
<a name="ln1866">      : BasicDurationalObj(c), NoteObj(CapellaNoteObjectType::CHORD)</a>
<a name="ln1867">      {</a>
<a name="ln1868">      cap      = c;</a>
<a name="ln1869">      beamMode = BeamMode::AUTO;</a>
<a name="ln1870">      }</a>
<a name="ln1871"> </a>
<a name="ln1872">//---------------------------------------------------------</a>
<a name="ln1873">//   read</a>
<a name="ln1874">//---------------------------------------------------------</a>
<a name="ln1875"> </a>
<a name="ln1876">void ChordObj::read()</a>
<a name="ln1877">      {</a>
<a name="ln1878">      stemDir      = StemDir::AUTO;</a>
<a name="ln1879">      dStemLength  = 0;</a>
<a name="ln1880">      nTremoloBars = 0;</a>
<a name="ln1881">      articulation = 0;</a>
<a name="ln1882">      leftTie      = false;</a>
<a name="ln1883">      rightTie     = false;</a>
<a name="ln1884">      beamShift    = 0;</a>
<a name="ln1885">      beamSlope    = 0;</a>
<a name="ln1886"> </a>
<a name="ln1887">      BasicDurationalObj::read();</a>
<a name="ln1888"> </a>
<a name="ln1889">      unsigned char flags = cap-&gt;readByte();</a>
<a name="ln1890">      beamMode      = (flags &amp; 0x01) ? BeamMode(cap-&gt;readByte()) : BeamMode::AUTO;</a>
<a name="ln1891">      notationStave = (flags &amp; 0x02) ? cap-&gt;readChar() : 0;</a>
<a name="ln1892">      Q_ASSERT(notationStave &gt;= -1 &amp;&amp; notationStave &lt;= 1);</a>
<a name="ln1893"> </a>
<a name="ln1894">      if (flags &amp; 0x04) {</a>
<a name="ln1895">            stemDir     = StemDir(cap-&gt;readChar());</a>
<a name="ln1896">            dStemLength = cap-&gt;readChar();</a>
<a name="ln1897">            }</a>
<a name="ln1898">      if (flags &amp; 0x08) {</a>
<a name="ln1899">            nTremoloBars = cap-&gt;readByte();</a>
<a name="ln1900">            articulation = cap-&gt;readByte();</a>
<a name="ln1901">            }</a>
<a name="ln1902">      if (flags &amp; 0x10) {</a>
<a name="ln1903">            unsigned char b = cap-&gt;readByte();</a>
<a name="ln1904">            leftTie  = b &amp; 1;</a>
<a name="ln1905">            rightTie = b &amp; 2;</a>
<a name="ln1906">            }</a>
<a name="ln1907">      if (flags &amp; 0x20) {</a>
<a name="ln1908">            beamShift = cap-&gt;readChar();</a>
<a name="ln1909">            beamSlope = cap-&gt;readChar();</a>
<a name="ln1910">            }</a>
<a name="ln1911">      if (flags &amp; 0x40) {</a>
<a name="ln1912">            unsigned nVerses = cap-&gt;readUnsigned();</a>
<a name="ln1913">            for (unsigned int i = 0; i &lt; nVerses; ++i) {</a>
<a name="ln1914">                  bool bVerse = cap-&gt;readByte();</a>
<a name="ln1915">                  if (bVerse) {</a>
<a name="ln1916">                        Verse v;</a>
<a name="ln1917">                        unsigned char b = cap-&gt;readByte();</a>
<a name="ln1918">                        v.leftAlign = b &amp; 1;</a>
<a name="ln1919">                        v.extender  = b &amp; 2;</a>
<a name="ln1920">                        v.hyphen    = b &amp; 4;</a>
<a name="ln1921">                        v.num       = i;</a>
<a name="ln1922">                        if (b &amp; 8)</a>
<a name="ln1923">                              v.verseNumber = cap-&gt;readQString();</a>
<a name="ln1924">                        if (b &amp; 16)</a>
<a name="ln1925">                              v.text = cap-&gt;readQString();</a>
<a name="ln1926">                        verse.append(v);</a>
<a name="ln1927">                        }</a>
<a name="ln1928">                  }</a>
<a name="ln1929">            }</a>
<a name="ln1930">      unsigned nNotes = cap-&gt;readUnsigned();</a>
<a name="ln1931">      for (unsigned int i = 0; i &lt; nNotes; ++i) {</a>
<a name="ln1932">            CNote n;</a>
<a name="ln1933">            n.explAlteration = 0;</a>
<a name="ln1934">            char c           = cap-&gt;readChar();</a>
<a name="ln1935">            bool bit7        = c &amp; 0x80;</a>
<a name="ln1936">            bool bit6        = c &amp; 0x40;</a>
<a name="ln1937">            n.pitch          = (signed char) c;</a>
<a name="ln1938">            if (bit7 != bit6) {</a>
<a name="ln1939">                  n.explAlteration = 2;</a>
<a name="ln1940">                  n.pitch ^= 0x80;</a>
<a name="ln1941">                  }</a>
<a name="ln1942">            unsigned char b = cap-&gt;readByte();</a>
<a name="ln1943">            n.headType      = b &amp; 7;</a>
<a name="ln1944">            n.alteration    = ((b &gt;&gt; 3) &amp; 7) - 2;  // -2 -- +2</a>
<a name="ln1945">            if (b &amp; 0x40)</a>
<a name="ln1946">                  n.explAlteration = 1;</a>
<a name="ln1947">            n.silent = b &amp; 0x80;</a>
<a name="ln1948">            qDebug(&quot;ChordObj::read() note pitch %d explAlt %d head %d alt %d silent %d&quot;,</a>
<a name="ln1949">                   n.pitch, n.explAlteration, n.headType, n.alteration, n.silent);</a>
<a name="ln1950">            notes.append(n);</a>
<a name="ln1951">            }</a>
<a name="ln1952">      }</a>
<a name="ln1953"> </a>
<a name="ln1954">//---------------------------------------------------------</a>
<a name="ln1955">//    read</a>
<a name="ln1956">//    return false on error</a>
<a name="ln1957">//---------------------------------------------------------</a>
<a name="ln1958"> </a>
<a name="ln1959">bool Capella::read(void* p, qint64 len)</a>
<a name="ln1960">      {</a>
<a name="ln1961">      if (len == 0)</a>
<a name="ln1962">            return true;</a>
<a name="ln1963">      qint64 rv = f-&gt;read((char*)p, len);</a>
<a name="ln1964">      if (rv != len)</a>
<a name="ln1965">            return false;</a>
<a name="ln1966">      curPos += len;</a>
<a name="ln1967">      return true;</a>
<a name="ln1968">      }</a>
<a name="ln1969"> </a>
<a name="ln1970">//---------------------------------------------------------</a>
<a name="ln1971">//   readByte</a>
<a name="ln1972">//---------------------------------------------------------</a>
<a name="ln1973"> </a>
<a name="ln1974">unsigned char Capella::readByte()</a>
<a name="ln1975">      {</a>
<a name="ln1976">      unsigned char c;</a>
<a name="ln1977">      read(&amp;c, 1);</a>
<a name="ln1978">      return c;</a>
<a name="ln1979">      }</a>
<a name="ln1980"> </a>
<a name="ln1981">//---------------------------------------------------------</a>
<a name="ln1982">//   readChar</a>
<a name="ln1983">//---------------------------------------------------------</a>
<a name="ln1984"> </a>
<a name="ln1985">char Capella::readChar()</a>
<a name="ln1986">      {</a>
<a name="ln1987">      char c;</a>
<a name="ln1988">      read(&amp;c, 1);</a>
<a name="ln1989">      return c;</a>
<a name="ln1990">      }</a>
<a name="ln1991"> </a>
<a name="ln1992">//---------------------------------------------------------</a>
<a name="ln1993">//   readWord</a>
<a name="ln1994">//---------------------------------------------------------</a>
<a name="ln1995"> </a>
<a name="ln1996">short Capella::readWord()</a>
<a name="ln1997">      {</a>
<a name="ln1998">      short c;</a>
<a name="ln1999">      read(&amp;c, 2);</a>
<a name="ln2000">      return c;</a>
<a name="ln2001">      }</a>
<a name="ln2002"> </a>
<a name="ln2003">//---------------------------------------------------------</a>
<a name="ln2004">//   readDWord</a>
<a name="ln2005">//---------------------------------------------------------</a>
<a name="ln2006"> </a>
<a name="ln2007">int Capella::readDWord()</a>
<a name="ln2008">      {</a>
<a name="ln2009">      int c;</a>
<a name="ln2010">      read(&amp;c, 4);</a>
<a name="ln2011">      return c;</a>
<a name="ln2012">      }</a>
<a name="ln2013"> </a>
<a name="ln2014">//---------------------------------------------------------</a>
<a name="ln2015">//   readLong</a>
<a name="ln2016">//---------------------------------------------------------</a>
<a name="ln2017"> </a>
<a name="ln2018">int Capella::readLong()</a>
<a name="ln2019">      {</a>
<a name="ln2020">      int c;</a>
<a name="ln2021">      read(&amp;c, 4);</a>
<a name="ln2022">      return c;</a>
<a name="ln2023">      }</a>
<a name="ln2024"> </a>
<a name="ln2025">//---------------------------------------------------------</a>
<a name="ln2026">//   readUnsigned</a>
<a name="ln2027">//---------------------------------------------------------</a>
<a name="ln2028"> </a>
<a name="ln2029">unsigned Capella::readUnsigned()</a>
<a name="ln2030">      {</a>
<a name="ln2031">      unsigned char c;</a>
<a name="ln2032">      read(&amp;c, 1);</a>
<a name="ln2033">      if (c == 254) {</a>
<a name="ln2034">            unsigned short s;</a>
<a name="ln2035">            read(&amp;s, 2);</a>
<a name="ln2036">            return s;</a>
<a name="ln2037">            }</a>
<a name="ln2038">      else if (c == 255) {</a>
<a name="ln2039">            unsigned s;</a>
<a name="ln2040">            read(&amp;s, 4);</a>
<a name="ln2041">            return s;</a>
<a name="ln2042">            }</a>
<a name="ln2043">      else</a>
<a name="ln2044">            return c;</a>
<a name="ln2045">      }</a>
<a name="ln2046"> </a>
<a name="ln2047">//---------------------------------------------------------</a>
<a name="ln2048">//   readInt</a>
<a name="ln2049">//---------------------------------------------------------</a>
<a name="ln2050"> </a>
<a name="ln2051">int Capella::readInt()</a>
<a name="ln2052">      {</a>
<a name="ln2053">      signed char c;</a>
<a name="ln2054">      read(&amp;c, 1);</a>
<a name="ln2055">      if (c == -128) {</a>
<a name="ln2056">            short s;</a>
<a name="ln2057">            read(&amp;s, 2);</a>
<a name="ln2058">            return s;</a>
<a name="ln2059">            }</a>
<a name="ln2060">      else if (c == 127) {</a>
<a name="ln2061">            int s;</a>
<a name="ln2062">            read(&amp;s, 4);</a>
<a name="ln2063">            return s;</a>
<a name="ln2064">            }</a>
<a name="ln2065">      else</a>
<a name="ln2066">            return c;</a>
<a name="ln2067">      }</a>
<a name="ln2068"> </a>
<a name="ln2069">//---------------------------------------------------------</a>
<a name="ln2070">//   readString -- read Capella string into newly allocated char buffer</a>
<a name="ln2071">//   note that no carriage return / newline interpretation is done</a>
<a name="ln2072">//---------------------------------------------------------</a>
<a name="ln2073"> </a>
<a name="ln2074">char* Capella::readString()</a>
<a name="ln2075">      {</a>
<a name="ln2076">      unsigned len = readUnsigned();</a>
<a name="ln2077">      char* buffer = new char[len + 1];</a>
<a name="ln2078">      read(buffer, len);</a>
<a name="ln2079">      buffer[len] = 0;</a>
<a name="ln2080">      return buffer;</a>
<a name="ln2081">      }</a>
<a name="ln2082"> </a>
<a name="ln2083">//---------------------------------------------------------</a>
<a name="ln2084">//   readQString -- read Capella string into QString</a>
<a name="ln2085">//   strings in Capella files may contain \r\n, must remove the \r</a>
<a name="ln2086">//---------------------------------------------------------</a>
<a name="ln2087"> </a>
<a name="ln2088">QString Capella::readQString()</a>
<a name="ln2089">      {</a>
<a name="ln2090">      char* buffer = readString();               // read Capella string</a>
<a name="ln2091">      QString res = QString::fromLatin1(buffer); // and copy into QString</a>
<a name="ln2092">      res = res.remove(QChar('\r'));             // remove the \r</a>
<a name="ln2093">      delete [] buffer;                          // delete memory allocated by readString</a>
<a name="ln2094">      return res;</a>
<a name="ln2095">      }</a>
<a name="ln2096"> </a>
<a name="ln2097">//---------------------------------------------------------</a>
<a name="ln2098">//   readColor</a>
<a name="ln2099">//---------------------------------------------------------</a>
<a name="ln2100"> </a>
<a name="ln2101">QColor Capella::readColor()</a>
<a name="ln2102">      {</a>
<a name="ln2103">      static const int colors[] = {</a>
<a name="ln2104">            0x000000, // schwarz</a>
<a name="ln2105">            0x000080, // dunkelrot</a>
<a name="ln2106">            0x008000, // dunkelgrn</a>
<a name="ln2107">            0x008080, // ocker</a>
<a name="ln2108">            0x800000, // dunkelblau</a>
<a name="ln2109">            0x800080, // purpurrot</a>
<a name="ln2110">            0x808000, // blaugn</a>
<a name="ln2111">            0x808080, // grau</a>
<a name="ln2112">            0xC0C0C0, // hellgrau</a>
<a name="ln2113">            0x0000FF, // rot</a>
<a name="ln2114">            0x00FF00, // grn</a>
<a name="ln2115">            0x00FFFF, // gelb</a>
<a name="ln2116">            0xFF0000, // blau</a>
<a name="ln2117">            0xFF00FF, // lila</a>
<a name="ln2118">            0xFFFF00, // aquamarin</a>
<a name="ln2119">            0xFFFFFF  // wei</a>
<a name="ln2120">            };</a>
<a name="ln2121"> </a>
<a name="ln2122">      QColor c;</a>
<a name="ln2123">      unsigned char b = readByte();</a>
<a name="ln2124">      if (b &gt;= 16) {</a>
<a name="ln2125">            Q_ASSERT(b == 255);</a>
<a name="ln2126">            int r = readByte();</a>
<a name="ln2127">            int g = readByte();</a>
<a name="ln2128">            int bi = readByte();</a>
<a name="ln2129">            c = QColor(r, g, bi);</a>
<a name="ln2130">            }</a>
<a name="ln2131">      else {</a>
<a name="ln2132">            c = QColor(colors[b]);</a>
<a name="ln2133">            }</a>
<a name="ln2134">      return c;</a>
<a name="ln2135">      }</a>
<a name="ln2136"> </a>
<a name="ln2137">//---------------------------------------------------------</a>
<a name="ln2138">//   readFont</a>
<a name="ln2139">//---------------------------------------------------------</a>
<a name="ln2140"> </a>
<a name="ln2141">QFont Capella::readFont()</a>
<a name="ln2142">      {</a>
<a name="ln2143">      int index = readUnsigned();</a>
<a name="ln2144">      if (index == 0) {</a>
<a name="ln2145">            int lfHeight           = readLong();</a>
<a name="ln2146">            /*int lfWidth            =*/ readLong();</a>
<a name="ln2147">            /*int lfEscapement       =*/ readLong();</a>
<a name="ln2148">            /*int lfOrientation      =*/ readLong();</a>
<a name="ln2149">            int lfWeight           = readLong();</a>
<a name="ln2150">            uchar lfItalic         = readByte();</a>
<a name="ln2151">            uchar lfUnderline      = readByte();</a>
<a name="ln2152">            uchar lfStrikeOut      = readByte();</a>
<a name="ln2153">            /*uchar lfCharSet        =*/ readByte();</a>
<a name="ln2154">            /*uchar lfOutPrecision   =*/ readByte();</a>
<a name="ln2155">            /*uchar lfClipPrecision  =*/ readByte();</a>
<a name="ln2156">            /*uchar lfQuality        =*/ readByte();</a>
<a name="ln2157">            /*uchar lfPitchAndFamily =*/ readByte();</a>
<a name="ln2158">            /*QColor color           =*/ readColor();</a>
<a name="ln2159">            QString face             = readQString();</a>
<a name="ln2160"> </a>
<a name="ln2161">            qDebug(&quot;Font &lt;%s&gt; size %d, weight %d&quot;, qPrintable(face), lfHeight, lfWeight);</a>
<a name="ln2162">            QFont font(face);</a>
<a name="ln2163">            font.setPointSizeF(lfHeight / 1000.0);</a>
<a name="ln2164">            font.setItalic(lfItalic);</a>
<a name="ln2165">            font.setStrikeOut(lfStrikeOut);</a>
<a name="ln2166">            font.setUnderline(lfUnderline);</a>
<a name="ln2167"> </a>
<a name="ln2168">            switch (lfWeight) {</a>
<a name="ln2169">                  case 700:  font.setWeight(QFont::Bold); break;</a>
<a name="ln2170">                  case 400:  font.setWeight(QFont::Normal); break;</a>
<a name="ln2171">                  case 0:    font.setWeight(QFont::Light); break;</a>
<a name="ln2172">                  }</a>
<a name="ln2173">            fonts.append(font);</a>
<a name="ln2174">            return font;</a>
<a name="ln2175">            }</a>
<a name="ln2176">      index -= 1;</a>
<a name="ln2177">      if (index &gt;= fonts.size()) {</a>
<a name="ln2178">            qDebug(&quot;illegal font index %d (max %d)&quot;, index, fonts.size()-1);</a>
<a name="ln2179">            }</a>
<a name="ln2180">      return fonts[index];</a>
<a name="ln2181">      }</a>
<a name="ln2182"> </a>
<a name="ln2183">//---------------------------------------------------------</a>
<a name="ln2184">//   readStaveLayout</a>
<a name="ln2185">//---------------------------------------------------------</a>
<a name="ln2186"> </a>
<a name="ln2187">void Capella::readStaveLayout(CapStaffLayout* sl, int idx)</a>
<a name="ln2188">      {</a>
<a name="ln2189">      sl-&gt;barlineMode = readByte();</a>
<a name="ln2190">      sl-&gt;noteLines   = readByte();</a>
<a name="ln2191">      switch (sl-&gt;noteLines) {</a>
<a name="ln2192">            case 1:     break;      // one line</a>
<a name="ln2193">            case 2:     break;      // five lines</a>
<a name="ln2194">            default:</a>
<a name="ln2195">                  {</a>
<a name="ln2196">                  char lines[11];</a>
<a name="ln2197">                  f-&gt;read(lines, 11);</a>
<a name="ln2198">                  curPos += 11;</a>
<a name="ln2199">                  }</a>
<a name="ln2200">                  break;</a>
<a name="ln2201">            }</a>
<a name="ln2202">      qDebug(&quot;StaffLayout %d: barlineMode %d noteLines %d&quot;, idx, sl-&gt;barlineMode, sl-&gt;noteLines);</a>
<a name="ln2203"> </a>
<a name="ln2204">      sl-&gt;bSmall      = readByte();</a>
<a name="ln2205">      qDebug(&quot;staff size small %d&quot;, sl-&gt;bSmall);</a>
<a name="ln2206"> </a>
<a name="ln2207">      sl-&gt;topDist      = readInt();</a>
<a name="ln2208">      sl-&gt;btmDist      = readInt();</a>
<a name="ln2209">      sl-&gt;groupDist    = readInt();</a>
<a name="ln2210">      sl-&gt;barlineFrom = readByte();</a>
<a name="ln2211">      sl-&gt;barlineTo   = readByte();</a>
<a name="ln2212">      // qDebug(&quot;topDist %d btmDist %d groupDist %d barlineFrom %d barlineTo %d&quot;,</a>
<a name="ln2213">      //        sl-&gt;topDist, sl-&gt;btmDist, sl-&gt;groupDist, sl-&gt;barlineFrom, sl-&gt;barlineTo);</a>
<a name="ln2214"> </a>
<a name="ln2215">      unsigned char clef = readByte();</a>
<a name="ln2216">      sl-&gt;form = Form(clef &amp; 7);</a>
<a name="ln2217">      sl-&gt;line = ClefLine((clef &gt;&gt; 3) &amp; 7);</a>
<a name="ln2218">      sl-&gt;oct  = Oct((clef &gt;&gt; 6));</a>
<a name="ln2219">      qDebug(&quot;   clef %x  form %d, line %d, oct %d&quot;, clef, int(sl-&gt;form), int(sl-&gt;line), int(sl-&gt;oct));</a>
<a name="ln2220"> </a>
<a name="ln2221">      // Schlagzeuginformation</a>
<a name="ln2222">      unsigned char b   = readByte();</a>
<a name="ln2223">      sl-&gt;bPercussion  = b &amp; 1;    // Schlagzeugkanal verwenden</a>
<a name="ln2224">      sl-&gt;bSoundMapIn  = b &amp; 2;</a>
<a name="ln2225">      sl-&gt;bSoundMapOut = b &amp; 4;</a>
<a name="ln2226">      if (sl-&gt;bSoundMapIn) {      // Umleitungstabelle fr Eingabe vom Keyboard</a>
<a name="ln2227">            uchar iMin = readByte();</a>
<a name="ln2228">            Q_UNUSED(iMin);</a>
<a name="ln2229">            uchar n    = readByte();</a>
<a name="ln2230">            Q_ASSERT (n &gt; 0 &amp;&amp; iMin + n &lt;= 128);</a>
<a name="ln2231">            f-&gt;read(sl-&gt;soundMapIn, n);</a>
<a name="ln2232">            curPos += n;</a>
<a name="ln2233">            }</a>
<a name="ln2234">      if (sl-&gt;bSoundMapOut) {     // Umleitungstabelle fr das Vorspielen</a>
<a name="ln2235">            unsigned char iMin = readByte();</a>
<a name="ln2236">            Q_UNUSED(iMin);</a>
<a name="ln2237">            unsigned char n    = readByte();</a>
<a name="ln2238">            Q_ASSERT (n &gt; 0 &amp;&amp; iMin + n &lt;= 128);</a>
<a name="ln2239">            f-&gt;read(sl-&gt;soundMapOut, n);</a>
<a name="ln2240">            curPos += n;</a>
<a name="ln2241">            }</a>
<a name="ln2242">      sl-&gt;sound  = readInt();</a>
<a name="ln2243">      sl-&gt;volume = readInt();</a>
<a name="ln2244">      sl-&gt;transp = readInt();</a>
<a name="ln2245">      qDebug(&quot;   sound %d vol %d transp %d&quot;, sl-&gt;sound, sl-&gt;volume, sl-&gt;transp);</a>
<a name="ln2246"> </a>
<a name="ln2247">      sl-&gt;descr              = readQString();</a>
<a name="ln2248">      sl-&gt;name               = readQString();</a>
<a name="ln2249">      sl-&gt;abbrev             = readQString();</a>
<a name="ln2250">      sl-&gt;intermediateName   = readQString();</a>
<a name="ln2251">      sl-&gt;intermediateAbbrev = readQString();</a>
<a name="ln2252">      qDebug(&quot;   descr &lt;%s&gt; name &lt;%s&gt;  abbrev &lt;%s&gt; iname &lt;%s&gt; iabrev &lt;%s&gt;&quot;,</a>
<a name="ln2253">             qPrintable(sl-&gt;descr), qPrintable(sl-&gt;name), qPrintable(sl-&gt;abbrev),</a>
<a name="ln2254">             qPrintable(sl-&gt;intermediateName), qPrintable(sl-&gt;intermediateAbbrev));</a>
<a name="ln2255">      }</a>
<a name="ln2256"> </a>
<a name="ln2257">//---------------------------------------------------------</a>
<a name="ln2258">//   readLayout</a>
<a name="ln2259">//---------------------------------------------------------</a>
<a name="ln2260"> </a>
<a name="ln2261">void Capella::readLayout()</a>
<a name="ln2262">      {</a>
<a name="ln2263">      smallLineDist  = double(readInt()) / 100;</a>
<a name="ln2264">      normalLineDist = double(readInt()) / 100;</a>
<a name="ln2265">      qDebug(&quot;Capella::readLayout(): smallLineDist %g normalLineDist %g&quot;, smallLineDist, normalLineDist);</a>
<a name="ln2266"> </a>
<a name="ln2267">      topDist        = readInt();</a>
<a name="ln2268">      interDist      = readInt();</a>
<a name="ln2269">      qDebug(&quot;Capella::readLayout(): topDist %d&quot;, topDist);</a>
<a name="ln2270"> </a>
<a name="ln2271">      txtAlign   = readByte();    // Stimmenbezeichnungen 0=links, 1=zentriert, 2=rechts</a>
<a name="ln2272">      adjustVert = readByte();    // 0=nein, 1=auer letzte Seite, 3=alle Seiten</a>
<a name="ln2273"> </a>
<a name="ln2274">      unsigned char b          = readByte();</a>
<a name="ln2275">      redundantKeys    = b &amp; 1;</a>
<a name="ln2276">      modernDoubleNote = b &amp; 2;</a>
<a name="ln2277">      Q_ASSERT((b &amp; 0xFC) == 0); // bits 2...7 reserviert</a>
<a name="ln2278"> </a>
<a name="ln2279">      bSystemSeparators = readByte();</a>
<a name="ln2280">      nUnnamed           = readInt();</a>
<a name="ln2281"> </a>
<a name="ln2282">      namesFont = readFont();</a>
<a name="ln2283"> </a>
<a name="ln2284">      // Musterzeilen</a>
<a name="ln2285">      unsigned nStaveLayouts = readUnsigned();</a>
<a name="ln2286"> </a>
<a name="ln2287">      // qDebug(&quot;%d staves&quot;, nStaveLayouts);</a>
<a name="ln2288"> </a>
<a name="ln2289">      for (unsigned iStave = 0; iStave &lt; nStaveLayouts; iStave++) {</a>
<a name="ln2290">            CapStaffLayout* sl = new CapStaffLayout;</a>
<a name="ln2291">            readStaveLayout(sl, iStave);</a>
<a name="ln2292">            _staffLayouts.append(sl);</a>
<a name="ln2293">            }</a>
<a name="ln2294"> </a>
<a name="ln2295">      // system brackets:</a>
<a name="ln2296">      unsigned n = readUnsigned();  // number of brackets</a>
<a name="ln2297">      for (unsigned int i = 0; i &lt; n; i++) {</a>
<a name="ln2298">            CapBracket cb;</a>
<a name="ln2299">            cb.from   = readInt();</a>
<a name="ln2300">            cb.to     = readInt();</a>
<a name="ln2301">            cb.curly = readByte();</a>
<a name="ln2302">            // qDebug(&quot;Bracket%d %d-%d curly %d&quot;, i, b.from, b.to, b.curly);</a>
<a name="ln2303">            brackets.append(cb);</a>
<a name="ln2304">            }</a>
<a name="ln2305">      // qDebug(&quot;Capella::readLayout(): done&quot;);</a>
<a name="ln2306">      }</a>
<a name="ln2307"> </a>
<a name="ln2308">//---------------------------------------------------------</a>
<a name="ln2309">//   readExtra</a>
<a name="ln2310">//---------------------------------------------------------</a>
<a name="ln2311"> </a>
<a name="ln2312">void Capella::readExtra()</a>
<a name="ln2313">      {</a>
<a name="ln2314">      uchar n = readByte();</a>
<a name="ln2315">      if (n) {</a>
<a name="ln2316">            qDebug(&quot;Capella::readExtra(%d)&quot;, n);</a>
<a name="ln2317">            for (int i = 0; i &lt; n; ++i)</a>
<a name="ln2318">                  readByte();</a>
<a name="ln2319">            }</a>
<a name="ln2320">      }</a>
<a name="ln2321"> </a>
<a name="ln2322">//---------------------------------------------------------</a>
<a name="ln2323">//   CapClef::read</a>
<a name="ln2324">//---------------------------------------------------------</a>
<a name="ln2325"> </a>
<a name="ln2326">void CapClef::read()</a>
<a name="ln2327">      {</a>
<a name="ln2328">      unsigned char b = cap-&gt;readByte();</a>
<a name="ln2329">      form            = Form(b &amp; 7);</a>
<a name="ln2330">      line            = ClefLine((b &gt;&gt; 3) &amp; 7);</a>
<a name="ln2331">      oct             = Oct(b &gt;&gt; 6);</a>
<a name="ln2332">      qDebug(&quot;Clef::read form %d line %d oct %d&quot;, int(form), int(line), int(oct));</a>
<a name="ln2333">      }</a>
<a name="ln2334"> </a>
<a name="ln2335">//---------------------------------------------------------</a>
<a name="ln2336">//   clef</a>
<a name="ln2337">//---------------------------------------------------------</a>
<a name="ln2338"> </a>
<a name="ln2339">ClefType CapClef::clef() const</a>
<a name="ln2340">      {</a>
<a name="ln2341">      return clefType(form, line, oct);</a>
<a name="ln2342">      }</a>
<a name="ln2343"> </a>
<a name="ln2344">ClefType CapClef::clefType(Form form, ClefLine line, Oct oct)</a>
<a name="ln2345">      {</a>
<a name="ln2346">      int idx = int(form) + (int(line) &lt;&lt; 3) + (int(oct) &lt;&lt; 5);</a>
<a name="ln2347">      switch (idx) {</a>
<a name="ln2348">            case int(Form::G) + (int(ClefLine::L2) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::G;</a>
<a name="ln2349">            case int(Form::G) + (int(ClefLine::L2) &lt;&lt; 3) + (int(Oct::OCT_ALTA) &lt;&lt; 5):  return ClefType::G8_VA;</a>
<a name="ln2350">            case int(Form::G) + (int(ClefLine::L2) &lt;&lt; 3) + (int(Oct::OCT_BASSA) &lt;&lt; 5): return ClefType::G8_VB;</a>
<a name="ln2351"> </a>
<a name="ln2352">            case int(Form::C) + (int(ClefLine::L1) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::C1;</a>
<a name="ln2353">            case int(Form::C) + (int(ClefLine::L2) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::C2;</a>
<a name="ln2354">            case int(Form::C) + (int(ClefLine::L3) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::C3;</a>
<a name="ln2355">            case int(Form::C) + (int(ClefLine::L4) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::C4;</a>
<a name="ln2356">            case int(Form::C) + (int(ClefLine::L5) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::C5;</a>
<a name="ln2357"> </a>
<a name="ln2358">            case int(Form::F) + (int(ClefLine::L4) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::F;</a>
<a name="ln2359">            case int(Form::F) + (int(ClefLine::L4) &lt;&lt; 3) + (int(Oct::OCT_BASSA) &lt;&lt; 5): return ClefType::F8_VB;</a>
<a name="ln2360">            case int(Form::F) + (int(ClefLine::L3) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::F_B;</a>
<a name="ln2361">            case int(Form::F) + (int(ClefLine::L5) &lt;&lt; 3) + (int(Oct::OCT_NULL) &lt;&lt; 5):  return ClefType::F_C;</a>
<a name="ln2362"> </a>
<a name="ln2363">            default:</a>
<a name="ln2364">                  if (form == Form::FORM_NULL)</a>
<a name="ln2365">                        return ClefType::INVALID;</a>
<a name="ln2366">                  qDebug(&quot;unknown clef %d %d %d&quot;, int(form), int(line), int(oct));</a>
<a name="ln2367">                  break;</a>
<a name="ln2368">            }</a>
<a name="ln2369">      return ClefType::INVALID;</a>
<a name="ln2370">      }</a>
<a name="ln2371"> </a>
<a name="ln2372">//---------------------------------------------------------</a>
<a name="ln2373">//   CapKey::read</a>
<a name="ln2374">//---------------------------------------------------------</a>
<a name="ln2375"> </a>
<a name="ln2376">void CapKey::read()</a>
<a name="ln2377">      {</a>
<a name="ln2378">      unsigned char b = cap-&gt;readByte();</a>
<a name="ln2379">      signature = int(b) - 7;</a>
<a name="ln2380">      // qDebug(&quot;         Key %d&quot;, signature);</a>
<a name="ln2381">      }</a>
<a name="ln2382"> </a>
<a name="ln2383">//---------------------------------------------------------</a>
<a name="ln2384">//   CapMeter::read</a>
<a name="ln2385">//---------------------------------------------------------</a>
<a name="ln2386"> </a>
<a name="ln2387">void CapMeter::read()</a>
<a name="ln2388">      {</a>
<a name="ln2389">      numerator = cap-&gt;readByte();</a>
<a name="ln2390">      uchar d   = cap-&gt;readByte();</a>
<a name="ln2391">      log2Denom = (d &amp; 0x7f) - 1;</a>
<a name="ln2392">      allaBreve = d &amp; 0x80;</a>
<a name="ln2393">      qDebug(&quot;   Meter %d/%d allaBreve %d&quot;, numerator, log2Denom, allaBreve);</a>
<a name="ln2394">      if (log2Denom &gt; 7 || log2Denom &lt; 0) {</a>
<a name="ln2395">            qDebug(&quot;   illegal fraction&quot;);</a>
<a name="ln2396">            // abort();</a>
<a name="ln2397">            log2Denom = 2;</a>
<a name="ln2398">            numerator = 4;</a>
<a name="ln2399">            }</a>
<a name="ln2400">      }</a>
<a name="ln2401"> </a>
<a name="ln2402">//---------------------------------------------------------</a>
<a name="ln2403">//   read</a>
<a name="ln2404">//---------------------------------------------------------</a>
<a name="ln2405"> </a>
<a name="ln2406">void WedgeObj::read()</a>
<a name="ln2407">      {</a>
<a name="ln2408">      LineObj::read();</a>
<a name="ln2409">      char b = cap-&gt;readByte();</a>
<a name="ln2410">      height = b &amp; 0x7f;</a>
<a name="ln2411">      decresc = b &amp; 0x80;</a>
<a name="ln2412">      }</a>
<a name="ln2413"> </a>
<a name="ln2414">//---------------------------------------------------------</a>
<a name="ln2415">//   CapExplicitBarline::read</a>
<a name="ln2416">//---------------------------------------------------------</a>
<a name="ln2417"> </a>
<a name="ln2418">void CapExplicitBarline::read()</a>
<a name="ln2419">      {</a>
<a name="ln2420">      unsigned char b = cap-&gt;readByte();</a>
<a name="ln2421">      int type = b &amp; 0x0f;</a>
<a name="ln2422">      if (type == 0) _type = BarLineType::NORMAL;</a>
<a name="ln2423">      else if (type == 1) _type = BarLineType::DOUBLE;</a>
<a name="ln2424">      else if (type == 2) _type = BarLineType::END;</a>
<a name="ln2425">      else if (type == 3) _type = BarLineType::END_REPEAT;</a>
<a name="ln2426">      else if (type == 4) _type = BarLineType::START_REPEAT;</a>
<a name="ln2427">      else if (type == 5) _type = BarLineType::END_START_REPEAT;</a>
<a name="ln2428">      else if (type == 6) _type = BarLineType::BROKEN;</a>
<a name="ln2429">      else _type = BarLineType::NORMAL; // default</a>
<a name="ln2430">      _barMode = b &gt;&gt; 4;         // 0 = auto, 1 = nur Zeilen, 2 = durchgezogen</a>
<a name="ln2431">      Q_ASSERT(_barMode &lt;= 2);</a>
<a name="ln2432"> </a>
<a name="ln2433">      qDebug(&quot;         Expl.Barline type %d mode %d&quot;, int(_type), _barMode);</a>
<a name="ln2434">      }</a>
<a name="ln2435"> </a>
<a name="ln2436">//---------------------------------------------------------</a>
<a name="ln2437">//   readVoice</a>
<a name="ln2438">//---------------------------------------------------------</a>
<a name="ln2439"> </a>
<a name="ln2440">void Capella::readVoice(CapStaff* cs, int idx)</a>
<a name="ln2441">      {</a>
<a name="ln2442">      qDebug(&quot;      readVoice %d&quot;, idx);</a>
<a name="ln2443"> </a>
<a name="ln2444">      if (readChar() != 'C')</a>
<a name="ln2445">            throw Capella::Error::BAD_VOICE_SIG;</a>
<a name="ln2446"> </a>
<a name="ln2447">      CapVoice* v   = new CapVoice;</a>
<a name="ln2448">      v-&gt;voiceNo    = idx;</a>
<a name="ln2449">      v-&gt;y0Lyrics   = readByte();</a>
<a name="ln2450">      v-&gt;dyLyrics   = readByte();</a>
<a name="ln2451">      v-&gt;lyricsFont = readFont();</a>
<a name="ln2452">      v-&gt;stemDir    = readByte();</a>
<a name="ln2453">      readExtra();</a>
<a name="ln2454"> </a>
<a name="ln2455">      unsigned nNoteObjs = readUnsigned();          // Notenobjekte</a>
<a name="ln2456">      for (unsigned i = 0; i &lt; nNoteObjs; i++) {</a>
<a name="ln2457">            QColor color       = Qt::black;</a>
<a name="ln2458">            uchar type = readByte();</a>
<a name="ln2459">            // qDebug(&quot;         Voice %d read object idx %d(%d) type %d&quot;, idx,  i, nNoteObjs, type);</a>
<a name="ln2460">            readExtra();</a>
<a name="ln2461">            if ((type != uchar(CapellaNoteObjectType::REST)) &amp;&amp; (type != uchar(CapellaNoteObjectType::CHORD)) &amp;&amp; (type != uchar(CapellaNoteObjectType::PAGE_BKGR)))</a>
<a name="ln2462">                  color = readColor();</a>
<a name="ln2463"> </a>
<a name="ln2464">            // Die anderen Objekttypen haben eine komprimierte Farbcodierung</a>
<a name="ln2465">            switch (CapellaNoteObjectType(type)) {</a>
<a name="ln2466">                  case CapellaNoteObjectType::REST:</a>
<a name="ln2467">                        {</a>
<a name="ln2468">                        RestObj* rest = new RestObj(this);</a>
<a name="ln2469">                        rest-&gt;read();</a>
<a name="ln2470">                        v-&gt;objects.append(rest);</a>
<a name="ln2471">                        }</a>
<a name="ln2472">                        break;</a>
<a name="ln2473">                  case CapellaNoteObjectType::CHORD:</a>
<a name="ln2474">                  case CapellaNoteObjectType::PAGE_BKGR:</a>
<a name="ln2475">                        {</a>
<a name="ln2476">                        ChordObj* chord = new ChordObj(this);</a>
<a name="ln2477">                        chord-&gt;read();</a>
<a name="ln2478">                        v-&gt;objects.append(chord);</a>
<a name="ln2479">                        }</a>
<a name="ln2480">                        break;</a>
<a name="ln2481">                  case CapellaNoteObjectType::CLEF:</a>
<a name="ln2482">                        {</a>
<a name="ln2483">                        CapClef* clef = new CapClef(this);</a>
<a name="ln2484">                        clef-&gt;read();</a>
<a name="ln2485">                        v-&gt;objects.append(clef);</a>
<a name="ln2486">                        }</a>
<a name="ln2487">                        break;</a>
<a name="ln2488">                  case CapellaNoteObjectType::KEY:</a>
<a name="ln2489">                        {</a>
<a name="ln2490">                        CapKey* key = new CapKey(this);</a>
<a name="ln2491">                        key-&gt;read();</a>
<a name="ln2492">                        v-&gt;objects.append(key);</a>
<a name="ln2493">                        }</a>
<a name="ln2494">                        break;</a>
<a name="ln2495">                  case CapellaNoteObjectType::METER:</a>
<a name="ln2496">                        {</a>
<a name="ln2497">                        CapMeter* meter = new CapMeter(this);</a>
<a name="ln2498">                        meter-&gt;read();</a>
<a name="ln2499">                        v-&gt;objects.append(meter);</a>
<a name="ln2500">                        }</a>
<a name="ln2501">                        break;</a>
<a name="ln2502">                  case CapellaNoteObjectType::EXPL_BARLINE:</a>
<a name="ln2503">                        {</a>
<a name="ln2504">                        CapExplicitBarline* bl = new CapExplicitBarline(this);</a>
<a name="ln2505">                        bl-&gt;read();</a>
<a name="ln2506">                        qDebug(&quot;append Expl Barline==========&quot;);</a>
<a name="ln2507">                        v-&gt;objects.append(bl);</a>
<a name="ln2508">                        }</a>
<a name="ln2509">                        break;</a>
<a name="ln2510">                  default:</a>
<a name="ln2511">                        qFatal(&quot;bad voice type %d&quot;, type);</a>
<a name="ln2512">                  }</a>
<a name="ln2513">            }</a>
<a name="ln2514">      cs-&gt;voices.append(v);</a>
<a name="ln2515">      }</a>
<a name="ln2516"> </a>
<a name="ln2517">//---------------------------------------------------------</a>
<a name="ln2518">//   readStaff</a>
<a name="ln2519">//---------------------------------------------------------</a>
<a name="ln2520"> </a>
<a name="ln2521">void Capella::readStaff(CapSystem* system)</a>
<a name="ln2522">      {</a>
<a name="ln2523">      if (readChar() != 'V')</a>
<a name="ln2524">            throw Capella::Error::BAD_STAFF_SIG;</a>
<a name="ln2525"> </a>
<a name="ln2526">      CapStaff* staff = new CapStaff;</a>
<a name="ln2527">      //Meter</a>
<a name="ln2528">      staff-&gt;numerator = readByte();</a>
<a name="ln2529">      uchar d          = readByte();</a>
<a name="ln2530">      staff-&gt;log2Denom = (d &amp; 0x7f) - 1;</a>
<a name="ln2531">      staff-&gt;allaBreve = d &amp; 0x80;</a>
<a name="ln2532">      qDebug(&quot;   CapStaff meter %d/%d allaBreve %d&quot;, staff-&gt;numerator, staff-&gt;log2Denom, staff-&gt;allaBreve);</a>
<a name="ln2533">      if (staff-&gt;log2Denom &gt; 7 || staff-&gt;log2Denom &lt; 0) {</a>
<a name="ln2534">            qDebug(&quot;   illegal fraction&quot;);</a>
<a name="ln2535">            staff-&gt;log2Denom = 2;</a>
<a name="ln2536">            staff-&gt;numerator = 4;</a>
<a name="ln2537">            }</a>
<a name="ln2538"> </a>
<a name="ln2539">      staff-&gt;iLayout   = readByte();</a>
<a name="ln2540">      staff-&gt;topDistX  = readInt();</a>
<a name="ln2541">      staff-&gt;btmDistX  = readInt();</a>
<a name="ln2542">      staff-&gt;color     = readColor();</a>
<a name="ln2543">      readExtra();</a>
<a name="ln2544"> </a>
<a name="ln2545">      qDebug(&quot;      Staff iLayout %d&quot;, staff-&gt;iLayout);</a>
<a name="ln2546">      // Stimmen</a>
<a name="ln2547">      unsigned nVoices = readUnsigned();</a>
<a name="ln2548">      for (unsigned i = 0; i &lt; nVoices; i++)</a>
<a name="ln2549">            readVoice(staff, i);</a>
<a name="ln2550">      system-&gt;staves.append(staff);</a>
<a name="ln2551">      }</a>
<a name="ln2552"> </a>
<a name="ln2553">//---------------------------------------------------------</a>
<a name="ln2554">//   readSystem</a>
<a name="ln2555">//---------------------------------------------------------</a>
<a name="ln2556"> </a>
<a name="ln2557">void Capella::readSystem()</a>
<a name="ln2558">      {</a>
<a name="ln2559">      if (readChar() != 'S')</a>
<a name="ln2560">            throw Capella::Error::BAD_SYSTEM_SIG;</a>
<a name="ln2561"> </a>
<a name="ln2562">      CapSystem* s = new CapSystem;</a>
<a name="ln2563">      s-&gt;nAddBarCount   = readInt();</a>
<a name="ln2564">      s-&gt;bBarCountReset = readByte();</a>
<a name="ln2565">      s-&gt;explLeftIndent = readByte();</a>
<a name="ln2566"> </a>
<a name="ln2567">      s-&gt;beamMode = BeamMode(readByte());</a>
<a name="ln2568">      s-&gt;tempo    = readUnsigned();</a>
<a name="ln2569">      s-&gt;color    = readColor();</a>
<a name="ln2570">      readExtra();</a>
<a name="ln2571"> </a>
<a name="ln2572">      unsigned char b  = readByte();</a>
<a name="ln2573">      s-&gt;bJustified    = b &amp; 2;</a>
<a name="ln2574">      s-&gt;bPageBreak    = (b &amp; 4) != 0;</a>
<a name="ln2575">      s-&gt;instrNotation = (b &gt;&gt; 3) &amp; 7;</a>
<a name="ln2576"> </a>
<a name="ln2577">      unsigned nStaves = readUnsigned();</a>
<a name="ln2578">      for (unsigned i = 0; i &lt; nStaves; i++)</a>
<a name="ln2579">            readStaff(s);</a>
<a name="ln2580">      systems.append(s);</a>
<a name="ln2581">      }</a>
<a name="ln2582"> </a>
<a name="ln2583">//---------------------------------------------------------</a>
<a name="ln2584">//   toTicks</a>
<a name="ln2585">//---------------------------------------------------------</a>
<a name="ln2586"> </a>
<a name="ln2587">Fraction BasicDurationalObj::ticks() const</a>
<a name="ln2588">      {</a>
<a name="ln2589">      if (noDuration)</a>
<a name="ln2590">            return Fraction(0,1);</a>
<a name="ln2591">      Fraction len = {0,1};</a>
<a name="ln2592">      switch (t) {</a>
<a name="ln2593">            case TIMESTEP::D1:          len = Fraction(1,1);   break;</a>
<a name="ln2594">            case TIMESTEP::D2:          len = Fraction(1,2);   break;</a>
<a name="ln2595">            case TIMESTEP::D4:          len = Fraction(1,4);   break;</a>
<a name="ln2596">            case TIMESTEP::D8:          len = Fraction(1,8);   break;</a>
<a name="ln2597">            case TIMESTEP::D16:         len = Fraction(1,16);  break;</a>
<a name="ln2598">            case TIMESTEP::D32:         len = Fraction(1,32);  break;</a>
<a name="ln2599">            case TIMESTEP::D64:         len = Fraction(1,64);  break;</a>
<a name="ln2600">            case TIMESTEP::D128:        len = Fraction(1,128); break;</a>
<a name="ln2601">            case TIMESTEP::D256:        len = Fraction(1,256); break;</a>
<a name="ln2602">            case TIMESTEP::D_BREVE:     len = Fraction(2,2);   break;</a>
<a name="ln2603">            default:</a>
<a name="ln2604">                  qDebug(&quot;BasicDurationalObj::ticks: illegal duration value %d&quot;, int(t));</a>
<a name="ln2605">                  break;</a>
<a name="ln2606">            }</a>
<a name="ln2607">      Fraction slen = len;</a>
<a name="ln2608">      int dots = nDots;</a>
<a name="ln2609">      while (dots--) {</a>
<a name="ln2610">            slen /= Fraction(2,1);</a>
<a name="ln2611">            len += slen;</a>
<a name="ln2612">            }</a>
<a name="ln2613">      return len;</a>
<a name="ln2614">      }</a>
<a name="ln2615"> </a>
<a name="ln2616">//---------------------------------------------------------</a>
<a name="ln2617">//   readPoint</a>
<a name="ln2618">//---------------------------------------------------------</a>
<a name="ln2619"> </a>
<a name="ln2620">QPointF Capella::readPoint()</a>
<a name="ln2621">      {</a>
<a name="ln2622">      int x = readInt();</a>
<a name="ln2623">      int y = readInt();</a>
<a name="ln2624">      return QPointF(double(x), double(y));</a>
<a name="ln2625">      }</a>
<a name="ln2626"> </a>
<a name="ln2627">//---------------------------------------------------------</a>
<a name="ln2628">//   read</a>
<a name="ln2629">//---------------------------------------------------------</a>
<a name="ln2630"> </a>
<a name="ln2631">void Capella::read(QFile* fp)</a>
<a name="ln2632">      {</a>
<a name="ln2633">      f      = fp;</a>
<a name="ln2634">      curPos = 0;</a>
<a name="ln2635"> </a>
<a name="ln2636">      char signature[9];</a>
<a name="ln2637">      read(signature, 8);</a>
<a name="ln2638">      signature[8] = 0;</a>
<a name="ln2639">      if (memcmp(signature, &quot;cap3-v:&quot;, 7) != 0)</a>
<a name="ln2640">            throw Capella::Error::BAD_SIG;</a>
<a name="ln2641"> </a>
<a name="ln2642">      // qDebug(&quot;read Capella file signature &lt;%s&gt;&quot;, signature);</a>
<a name="ln2643"> </a>
<a name="ln2644">      // TODO: test for signature[7] = a-z</a>
<a name="ln2645"> </a>
<a name="ln2646">      author   = readString();</a>
<a name="ln2647">      keywords = readString();</a>
<a name="ln2648">      comment  = readString();</a>
<a name="ln2649"> </a>
<a name="ln2650">      // qDebug(&quot;author &lt;%s&gt; keywords &lt;%s&gt; comment &lt;%s&gt;&quot;, author, keywords, comment);</a>
<a name="ln2651"> </a>
<a name="ln2652">      nRel   = readUnsigned();            // 75</a>
<a name="ln2653">      nAbs   = readUnsigned();            // 16</a>
<a name="ln2654">      unsigned char b   = readByte();</a>
<a name="ln2655">      bUseRealSize      = b &amp; 1;</a>
<a name="ln2656">      bAllowCompression = b &amp; 2;</a>
<a name="ln2657">      bPrintLandscape   = b &amp; 16;</a>
<a name="ln2658"> </a>
<a name="ln2659">      // qDebug(&quot;  nRel %d  nAbs %d useRealSize %d compresseion %d&quot;, nRel, nAbs, bUseRealSize, bAllowCompression);</a>
<a name="ln2660"> </a>
<a name="ln2661">      readLayout();</a>
<a name="ln2662"> </a>
<a name="ln2663">      beamRelMin0 = readByte();        // basic setup for beam slope</a>
<a name="ln2664">      beamRelMin1 = readByte();</a>
<a name="ln2665">      beamRelMax0 = readByte();</a>
<a name="ln2666">      beamRelMax1 = readByte();</a>
<a name="ln2667"> </a>
<a name="ln2668">      readExtra();</a>
<a name="ln2669"> </a>
<a name="ln2670">      readDrawObjectArray();                // Galerie (gesammelte Grafikobjekte)</a>
<a name="ln2671"> </a>
<a name="ln2672">      unsigned n = readUnsigned();</a>
<a name="ln2673">      if (n) {</a>
<a name="ln2674">            qDebug(&quot;Gallery objects&quot;);</a>
<a name="ln2675">            }</a>
<a name="ln2676">      for (unsigned int i = 0; i &lt; n; ++i) {</a>
<a name="ln2677">            /*char* s =*/ readString();     // Namen der Galerie-Objekte</a>
<a name="ln2678">            // qDebug(&quot;Galerie: &lt;%s&gt;&quot;, s);</a>
<a name="ln2679">            }</a>
<a name="ln2680"> </a>
<a name="ln2681">      // qDebug(&quot;read backgroundChord&quot;);</a>
<a name="ln2682">      backgroundChord = new ChordObj(this);</a>
<a name="ln2683">      backgroundChord-&gt;read();              // contains graphic objects on the page background</a>
<a name="ln2684">      // qDebug(&quot;read backgroundChord done&quot;);</a>
<a name="ln2685">      bShowBarCount    = readByte();        // Taktnumerierung zeigen</a>
<a name="ln2686">      barNumberFrame   = readByte();        // 0=kein, 1=Rechteck, 2=Ellipse</a>
<a name="ln2687">      nBarDistX        = readByte();</a>
<a name="ln2688">      nBarDistY        = readByte();</a>
<a name="ln2689">      QFont barNumFont = readFont();</a>
<a name="ln2690">      nFirstPage       = readUnsigned();    // Versatz fuer Seitenzaehlung</a>
<a name="ln2691">      leftPageMargins  = readUnsigned();    // Seitenraender</a>
<a name="ln2692">      topPageMargins   = readUnsigned();</a>
<a name="ln2693">      rightPageMargins = readUnsigned();</a>
<a name="ln2694">      btmPageMargins   = readUnsigned();</a>
<a name="ln2695"> </a>
<a name="ln2696">      unsigned nSystems  = readUnsigned();</a>
<a name="ln2697">      for (unsigned i = 0; i &lt; nSystems; i++)</a>
<a name="ln2698">            readSystem();</a>
<a name="ln2699">      char esig[4];</a>
<a name="ln2700">      read(esig, 4);</a>
<a name="ln2701">      if (memcmp (esig, &quot;\0\0\0\0&quot;, 4) != 0)</a>
<a name="ln2702">            throw Capella::Error::BAD_SIG;</a>
<a name="ln2703">      }</a>
<a name="ln2704"> </a>
<a name="ln2705">//---------------------------------------------------------</a>
<a name="ln2706">//   importCapella</a>
<a name="ln2707">//---------------------------------------------------------</a>
<a name="ln2708"> </a>
<a name="ln2709">Score::FileError importCapella(MasterScore* score, const QString&amp; name)</a>
<a name="ln2710">      {</a>
<a name="ln2711">      QFile fp(name);</a>
<a name="ln2712">      if(!fp.exists())</a>
<a name="ln2713">            return Score::FileError::FILE_NOT_FOUND;</a>
<a name="ln2714">      if (!fp.open(QIODevice::ReadOnly))</a>
<a name="ln2715">            return Score::FileError::FILE_OPEN_ERROR;</a>
<a name="ln2716"> </a>
<a name="ln2717">      Capella cf;</a>
<a name="ln2718">      try {</a>
<a name="ln2719">            cf.read(&amp;fp);</a>
<a name="ln2720">            }</a>
<a name="ln2721">      catch (Capella::Error errNo) {</a>
<a name="ln2722">            if (!MScore::noGui) {</a>
<a name="ln2723">                  QMessageBox::warning(0,</a>
<a name="ln2724">                     QWidget::tr(&quot;Import Capella&quot;),</a>
<a name="ln2725">                     QWidget::tr(&quot;Load failed: %1&quot;).arg(cf.error(errNo)),</a>
<a name="ln2726">                     QString(), QWidget::tr(&quot;Quit&quot;), QString(), 0, 1);</a>
<a name="ln2727">                  }</a>
<a name="ln2728">            fp.close();</a>
<a name="ln2729">            // avoid another error message box</a>
<a name="ln2730">            return Score::FileError::FILE_NO_ERROR;</a>
<a name="ln2731">            }</a>
<a name="ln2732">      fp.close();</a>
<a name="ln2733">      convertCapella(score, &amp;cf, false);</a>
<a name="ln2734">      return Score::FileError::FILE_NO_ERROR;</a>
<a name="ln2735">      }</a>
<a name="ln2736">}</a>
<a name="ln2737"> </a>

</code></pre>
<div class="balloon" rel="619"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The 'tuplet' pointer was assigned values twice without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="799"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v773/" target="_blank">V773</a> The 'tuplet' pointer was assigned values twice without releasing the memory. A memory leak is possible.</p></div>
<div class="balloon" rel="1836"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: bVerticalCentered.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
