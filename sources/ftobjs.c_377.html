
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>ftobjs.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***************************************************************************/</a>
<a name="ln2">/*                                                                         */</a>
<a name="ln3">/*  ftobjs.c                                                               */</a>
<a name="ln4">/*                                                                         */</a>
<a name="ln5">/*    The FreeType private base classes (body).                            */</a>
<a name="ln6">/*                                                                         */</a>
<a name="ln7">/*  Copyright 1996-2015 by                                                 */</a>
<a name="ln8">/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</a>
<a name="ln9">/*                                                                         */</a>
<a name="ln10">/*  This file is part of the FreeType project, and may only be used,       */</a>
<a name="ln11">/*  modified, and distributed under the terms of the FreeType project      */</a>
<a name="ln12">/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</a>
<a name="ln13">/*  this file you indicate that you have read the license and              */</a>
<a name="ln14">/*  understand and accept it fully.                                        */</a>
<a name="ln15">/*                                                                         */</a>
<a name="ln16">/***************************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;ft2build.h&gt;</a>
<a name="ln20">#include FT_LIST_H</a>
<a name="ln21">#include FT_OUTLINE_H</a>
<a name="ln22">#include FT_INTERNAL_VALIDATE_H</a>
<a name="ln23">#include FT_INTERNAL_OBJECTS_H</a>
<a name="ln24">#include FT_INTERNAL_DEBUG_H</a>
<a name="ln25">#include FT_INTERNAL_RFORK_H</a>
<a name="ln26">#include FT_INTERNAL_STREAM_H</a>
<a name="ln27">#include FT_INTERNAL_SFNT_H    /* for SFNT_Load_Table_Func */</a>
<a name="ln28">#include FT_TRUETYPE_TABLES_H</a>
<a name="ln29">#include FT_TRUETYPE_TAGS_H</a>
<a name="ln30">#include FT_TRUETYPE_IDS_H</a>
<a name="ln31"> </a>
<a name="ln32">#include FT_SERVICE_PROPERTIES_H</a>
<a name="ln33">#include FT_SERVICE_SFNT_H</a>
<a name="ln34">#include FT_SERVICE_POSTSCRIPT_NAME_H</a>
<a name="ln35">#include FT_SERVICE_GLYPH_DICT_H</a>
<a name="ln36">#include FT_SERVICE_TT_CMAP_H</a>
<a name="ln37">#include FT_SERVICE_KERNING_H</a>
<a name="ln38">#include FT_SERVICE_TRUETYPE_ENGINE_H</a>
<a name="ln39"> </a>
<a name="ln40">#ifdef FT_CONFIG_OPTION_MAC_FONTS</a>
<a name="ln41">#include &quot;ftbase.h&quot;</a>
<a name="ln42">#endif</a>
<a name="ln43"> </a>
<a name="ln44"> </a>
<a name="ln45">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln46"> </a>
<a name="ln47">#include FT_BITMAP_H</a>
<a name="ln48"> </a>
<a name="ln49">#if defined( _MSC_VER )      /* Visual C++ (and Intel C++)   */</a>
<a name="ln50">  /* We disable the warning `conversion from XXX to YYY,     */</a>
<a name="ln51">  /* possible loss of data' in order to compile cleanly with */</a>
<a name="ln52">  /* the maximum level of warnings: `md5.c' is non-FreeType  */</a>
<a name="ln53">  /* code, and it gets used during development builds only.  */</a>
<a name="ln54">#pragma warning( push )</a>
<a name="ln55">#pragma warning( disable : 4244 )</a>
<a name="ln56">#endif /* _MSC_VER */</a>
<a name="ln57"> </a>
<a name="ln58">  /* it's easiest to include `md5.c' directly */</a>
<a name="ln59">#include &quot;md5.c&quot;</a>
<a name="ln60"> </a>
<a name="ln61">#if defined( _MSC_VER )</a>
<a name="ln62">#pragma warning( pop )</a>
<a name="ln63">#endif</a>
<a name="ln64"> </a>
<a name="ln65">#endif /* FT_DEBUG_LEVEL_TRACE */</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">#define GRID_FIT_METRICS</a>
<a name="ln69"> </a>
<a name="ln70"> </a>
<a name="ln71">  FT_BASE_DEF( FT_Pointer )</a>
<a name="ln72">  ft_service_list_lookup( FT_ServiceDesc  service_descriptors,</a>
<a name="ln73">                          const char*     service_id )</a>
<a name="ln74">  {</a>
<a name="ln75">    FT_Pointer      result = NULL;</a>
<a name="ln76">    FT_ServiceDesc  desc   = service_descriptors;</a>
<a name="ln77"> </a>
<a name="ln78"> </a>
<a name="ln79">    if ( desc &amp;&amp; service_id )</a>
<a name="ln80">    {</a>
<a name="ln81">      for ( ; desc-&gt;serv_id != NULL; desc++ )</a>
<a name="ln82">      {</a>
<a name="ln83">        if ( ft_strcmp( desc-&gt;serv_id, service_id ) == 0 )</a>
<a name="ln84">        {</a>
<a name="ln85">          result = (FT_Pointer)desc-&gt;serv_data;</a>
<a name="ln86">          break;</a>
<a name="ln87">        }</a>
<a name="ln88">      }</a>
<a name="ln89">    }</a>
<a name="ln90"> </a>
<a name="ln91">    return result;</a>
<a name="ln92">  }</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">  FT_BASE_DEF( void )</a>
<a name="ln96">  ft_validator_init( FT_Validator        valid,</a>
<a name="ln97">                     const FT_Byte*      base,</a>
<a name="ln98">                     const FT_Byte*      limit,</a>
<a name="ln99">                     FT_ValidationLevel  level )</a>
<a name="ln100">  {</a>
<a name="ln101">    valid-&gt;base  = base;</a>
<a name="ln102">    valid-&gt;limit = limit;</a>
<a name="ln103">    valid-&gt;level = level;</a>
<a name="ln104">    valid-&gt;error = FT_Err_Ok;</a>
<a name="ln105">  }</a>
<a name="ln106"> </a>
<a name="ln107"> </a>
<a name="ln108">  FT_BASE_DEF( FT_Int )</a>
<a name="ln109">  ft_validator_run( FT_Validator  valid )</a>
<a name="ln110">  {</a>
<a name="ln111">    /* This function doesn't work!  None should call it. */</a>
<a name="ln112">    FT_UNUSED( valid );</a>
<a name="ln113"> </a>
<a name="ln114">    return -1;</a>
<a name="ln115">  }</a>
<a name="ln116"> </a>
<a name="ln117"> </a>
<a name="ln118">  FT_BASE_DEF( void )</a>
<a name="ln119">  ft_validator_error( FT_Validator  valid,</a>
<a name="ln120">                      FT_Error      error )</a>
<a name="ln121">  {</a>
<a name="ln122">    /* since the cast below also disables the compiler's */</a>
<a name="ln123">    /* type check, we introduce a dummy variable, which  */</a>
<a name="ln124">    /* will be optimized away                            */</a>
<a name="ln125">    volatile ft_jmp_buf* jump_buffer = &amp;valid-&gt;jump_buffer;</a>
<a name="ln126"> </a>
<a name="ln127"> </a>
<a name="ln128">    valid-&gt;error = error;</a>
<a name="ln129"> </a>
<a name="ln130">    /* throw away volatileness; use `jump_buffer' or the  */</a>
<a name="ln131">    /* compiler may warn about an unused local variable   */</a>
<a name="ln132">    ft_longjmp( *(ft_jmp_buf*) jump_buffer, 1 );</a>
<a name="ln133">  }</a>
<a name="ln134"> </a>
<a name="ln135"> </a>
<a name="ln136">  /*************************************************************************/</a>
<a name="ln137">  /*************************************************************************/</a>
<a name="ln138">  /*************************************************************************/</a>
<a name="ln139">  /****                                                                 ****/</a>
<a name="ln140">  /****                                                                 ****/</a>
<a name="ln141">  /****                           S T R E A M                           ****/</a>
<a name="ln142">  /****                                                                 ****/</a>
<a name="ln143">  /****                                                                 ****/</a>
<a name="ln144">  /*************************************************************************/</a>
<a name="ln145">  /*************************************************************************/</a>
<a name="ln146">  /*************************************************************************/</a>
<a name="ln147"> </a>
<a name="ln148"> </a>
<a name="ln149">  /* create a new input stream from an FT_Open_Args structure */</a>
<a name="ln150">  /*                                                          */</a>
<a name="ln151">  FT_BASE_DEF( FT_Error )</a>
<a name="ln152">  FT_Stream_New( FT_Library           library,</a>
<a name="ln153">                 const FT_Open_Args*  args,</a>
<a name="ln154">                 FT_Stream           *astream )</a>
<a name="ln155">  {</a>
<a name="ln156">    FT_Error   error;</a>
<a name="ln157">    FT_Memory  memory;</a>
<a name="ln158">    FT_Stream  stream = NULL;</a>
<a name="ln159"> </a>
<a name="ln160"> </a>
<a name="ln161">    *astream = NULL;</a>
<a name="ln162"> </a>
<a name="ln163">    if ( !library )</a>
<a name="ln164">      return FT_THROW( Invalid_Library_Handle );</a>
<a name="ln165"> </a>
<a name="ln166">    if ( !args )</a>
<a name="ln167">      return FT_THROW( Invalid_Argument );</a>
<a name="ln168"> </a>
<a name="ln169">    memory = library-&gt;memory;</a>
<a name="ln170"> </a>
<a name="ln171">    if ( FT_NEW( stream ) )</a>
<a name="ln172">      goto Exit;</a>
<a name="ln173"> </a>
<a name="ln174">    stream-&gt;memory = memory;</a>
<a name="ln175"> </a>
<a name="ln176">    if ( args-&gt;flags &amp; FT_OPEN_MEMORY )</a>
<a name="ln177">    {</a>
<a name="ln178">      /* create a memory-based stream */</a>
<a name="ln179">      FT_Stream_OpenMemory( stream,</a>
<a name="ln180">                            (const FT_Byte*)args-&gt;memory_base,</a>
<a name="ln181">                            (FT_ULong)args-&gt;memory_size );</a>
<a name="ln182">    }</a>
<a name="ln183"> </a>
<a name="ln184">#ifndef FT_CONFIG_OPTION_DISABLE_STREAM_SUPPORT</a>
<a name="ln185"> </a>
<a name="ln186">    else if ( args-&gt;flags &amp; FT_OPEN_PATHNAME )</a>
<a name="ln187">    {</a>
<a name="ln188">      /* create a normal system stream */</a>
<a name="ln189">      error = FT_Stream_Open( stream, args-&gt;pathname );</a>
<a name="ln190">      stream-&gt;pathname.pointer = args-&gt;pathname;</a>
<a name="ln191">    }</a>
<a name="ln192">    else if ( ( args-&gt;flags &amp; FT_OPEN_STREAM ) &amp;&amp; args-&gt;stream )</a>
<a name="ln193">    {</a>
<a name="ln194">      /* use an existing, user-provided stream */</a>
<a name="ln195"> </a>
<a name="ln196">      /* in this case, we do not need to allocate a new stream object */</a>
<a name="ln197">      /* since the caller is responsible for closing it himself       */</a>
<a name="ln198">      FT_FREE( stream );</a>
<a name="ln199">      stream = args-&gt;stream;</a>
<a name="ln200">    }</a>
<a name="ln201"> </a>
<a name="ln202">#endif</a>
<a name="ln203"> </a>
<a name="ln204">    else</a>
<a name="ln205">      error = FT_THROW( Invalid_Argument );</a>
<a name="ln206"> </a>
<a name="ln207">    if ( error )</a>
<a name="ln208">      FT_FREE( stream );</a>
<a name="ln209">    else</a>
<a name="ln210">      stream-&gt;memory = memory;  /* just to be certain */</a>
<a name="ln211"> </a>
<a name="ln212">    *astream = stream;</a>
<a name="ln213"> </a>
<a name="ln214">  Exit:</a>
<a name="ln215">    return error;</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">  FT_BASE_DEF( void )</a>
<a name="ln220">  FT_Stream_Free( FT_Stream  stream,</a>
<a name="ln221">                  FT_Int     external )</a>
<a name="ln222">  {</a>
<a name="ln223">    if ( stream )</a>
<a name="ln224">    {</a>
<a name="ln225">      FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln226"> </a>
<a name="ln227"> </a>
<a name="ln228">      FT_Stream_Close( stream );</a>
<a name="ln229"> </a>
<a name="ln230">      if ( !external )</a>
<a name="ln231">        FT_FREE( stream );</a>
<a name="ln232">    }</a>
<a name="ln233">  }</a>
<a name="ln234"> </a>
<a name="ln235"> </a>
<a name="ln236">  /*************************************************************************/</a>
<a name="ln237">  /*                                                                       */</a>
<a name="ln238">  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</a>
<a name="ln239">  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</a>
<a name="ln240">  /* messages during execution.                                            */</a>
<a name="ln241">  /*                                                                       */</a>
<a name="ln242">#undef  FT_COMPONENT</a>
<a name="ln243">#define FT_COMPONENT  trace_objs</a>
<a name="ln244"> </a>
<a name="ln245"> </a>
<a name="ln246">  /*************************************************************************/</a>
<a name="ln247">  /*************************************************************************/</a>
<a name="ln248">  /*************************************************************************/</a>
<a name="ln249">  /****                                                                 ****/</a>
<a name="ln250">  /****                                                                 ****/</a>
<a name="ln251">  /****               FACE, SIZE &amp; GLYPH SLOT OBJECTS                   ****/</a>
<a name="ln252">  /****                                                                 ****/</a>
<a name="ln253">  /****                                                                 ****/</a>
<a name="ln254">  /*************************************************************************/</a>
<a name="ln255">  /*************************************************************************/</a>
<a name="ln256">  /*************************************************************************/</a>
<a name="ln257"> </a>
<a name="ln258"> </a>
<a name="ln259">  static FT_Error</a>
<a name="ln260">  ft_glyphslot_init( FT_GlyphSlot  slot )</a>
<a name="ln261">  {</a>
<a name="ln262">    FT_Driver         driver   = slot-&gt;face-&gt;driver;</a>
<a name="ln263">    FT_Driver_Class   clazz    = driver-&gt;clazz;</a>
<a name="ln264">    FT_Memory         memory   = driver-&gt;root.memory;</a>
<a name="ln265">    FT_Error          error    = FT_Err_Ok;</a>
<a name="ln266">    FT_Slot_Internal  internal = NULL;</a>
<a name="ln267"> </a>
<a name="ln268"> </a>
<a name="ln269">    slot-&gt;library = driver-&gt;root.library;</a>
<a name="ln270"> </a>
<a name="ln271">    if ( FT_NEW( internal ) )</a>
<a name="ln272">      goto Exit;</a>
<a name="ln273"> </a>
<a name="ln274">    slot-&gt;internal = internal;</a>
<a name="ln275"> </a>
<a name="ln276">    if ( FT_DRIVER_USES_OUTLINES( driver ) )</a>
<a name="ln277">      error = FT_GlyphLoader_New( memory, &amp;internal-&gt;loader );</a>
<a name="ln278"> </a>
<a name="ln279">    if ( !error &amp;&amp; clazz-&gt;init_slot )</a>
<a name="ln280">      error = clazz-&gt;init_slot( slot );</a>
<a name="ln281"> </a>
<a name="ln282">  Exit:</a>
<a name="ln283">    return error;</a>
<a name="ln284">  }</a>
<a name="ln285"> </a>
<a name="ln286"> </a>
<a name="ln287">  FT_BASE_DEF( void )</a>
<a name="ln288">  ft_glyphslot_free_bitmap( FT_GlyphSlot  slot )</a>
<a name="ln289">  {</a>
<a name="ln290">    if ( slot-&gt;internal &amp;&amp; ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP ) )</a>
<a name="ln291">    {</a>
<a name="ln292">      FT_Memory  memory = FT_FACE_MEMORY( slot-&gt;face );</a>
<a name="ln293"> </a>
<a name="ln294"> </a>
<a name="ln295">      FT_FREE( slot-&gt;bitmap.buffer );</a>
<a name="ln296">      slot-&gt;internal-&gt;flags &amp;= ~FT_GLYPH_OWN_BITMAP;</a>
<a name="ln297">    }</a>
<a name="ln298">    else</a>
<a name="ln299">    {</a>
<a name="ln300">      /* assume that the bitmap buffer was stolen or not */</a>
<a name="ln301">      /* allocated from the heap                         */</a>
<a name="ln302">      slot-&gt;bitmap.buffer = NULL;</a>
<a name="ln303">    }</a>
<a name="ln304">  }</a>
<a name="ln305"> </a>
<a name="ln306"> </a>
<a name="ln307">  FT_BASE_DEF( void )</a>
<a name="ln308">  ft_glyphslot_set_bitmap( FT_GlyphSlot  slot,</a>
<a name="ln309">                           FT_Byte*      buffer )</a>
<a name="ln310">  {</a>
<a name="ln311">    ft_glyphslot_free_bitmap( slot );</a>
<a name="ln312"> </a>
<a name="ln313">    slot-&gt;bitmap.buffer = buffer;</a>
<a name="ln314"> </a>
<a name="ln315">    FT_ASSERT( (slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP) == 0 );</a>
<a name="ln316">  }</a>
<a name="ln317"> </a>
<a name="ln318"> </a>
<a name="ln319">  FT_BASE_DEF( FT_Error )</a>
<a name="ln320">  ft_glyphslot_alloc_bitmap( FT_GlyphSlot  slot,</a>
<a name="ln321">                             FT_ULong      size )</a>
<a name="ln322">  {</a>
<a name="ln323">    FT_Memory  memory = FT_FACE_MEMORY( slot-&gt;face );</a>
<a name="ln324">    FT_Error   error;</a>
<a name="ln325"> </a>
<a name="ln326"> </a>
<a name="ln327">    if ( slot-&gt;internal-&gt;flags &amp; FT_GLYPH_OWN_BITMAP )</a>
<a name="ln328">      FT_FREE( slot-&gt;bitmap.buffer );</a>
<a name="ln329">    else</a>
<a name="ln330">      slot-&gt;internal-&gt;flags |= FT_GLYPH_OWN_BITMAP;</a>
<a name="ln331"> </a>
<a name="ln332">    (void)FT_ALLOC( slot-&gt;bitmap.buffer, size );</a>
<a name="ln333">    return error;</a>
<a name="ln334">  }</a>
<a name="ln335"> </a>
<a name="ln336"> </a>
<a name="ln337">  static void</a>
<a name="ln338">  ft_glyphslot_clear( FT_GlyphSlot  slot )</a>
<a name="ln339">  {</a>
<a name="ln340">    /* free bitmap if needed */</a>
<a name="ln341">    ft_glyphslot_free_bitmap( slot );</a>
<a name="ln342"> </a>
<a name="ln343">    /* clear all public fields in the glyph slot */</a>
<a name="ln344">    FT_ZERO( &amp;slot-&gt;metrics );</a>
<a name="ln345">    FT_ZERO( &amp;slot-&gt;outline );</a>
<a name="ln346"> </a>
<a name="ln347">    slot-&gt;bitmap.width      = 0;</a>
<a name="ln348">    slot-&gt;bitmap.rows       = 0;</a>
<a name="ln349">    slot-&gt;bitmap.pitch      = 0;</a>
<a name="ln350">    slot-&gt;bitmap.pixel_mode = 0;</a>
<a name="ln351">    /* `slot-&gt;bitmap.buffer' has been handled by ft_glyphslot_free_bitmap */</a>
<a name="ln352"> </a>
<a name="ln353">    slot-&gt;bitmap_left   = 0;</a>
<a name="ln354">    slot-&gt;bitmap_top    = 0;</a>
<a name="ln355">    slot-&gt;num_subglyphs = 0;</a>
<a name="ln356">    slot-&gt;subglyphs     = NULL;</a>
<a name="ln357">    slot-&gt;control_data  = NULL;</a>
<a name="ln358">    slot-&gt;control_len   = 0;</a>
<a name="ln359">    slot-&gt;other         = NULL;</a>
<a name="ln360">    slot-&gt;format        = FT_GLYPH_FORMAT_NONE;</a>
<a name="ln361"> </a>
<a name="ln362">    slot-&gt;linearHoriAdvance = 0;</a>
<a name="ln363">    slot-&gt;linearVertAdvance = 0;</a>
<a name="ln364">    slot-&gt;lsb_delta         = 0;</a>
<a name="ln365">    slot-&gt;rsb_delta         = 0;</a>
<a name="ln366">  }</a>
<a name="ln367"> </a>
<a name="ln368"> </a>
<a name="ln369">  static void</a>
<a name="ln370">  ft_glyphslot_done( FT_GlyphSlot  slot )</a>
<a name="ln371">  {</a>
<a name="ln372">    FT_Driver        driver = slot-&gt;face-&gt;driver;</a>
<a name="ln373">    FT_Driver_Class  clazz  = driver-&gt;clazz;</a>
<a name="ln374">    FT_Memory        memory = driver-&gt;root.memory;</a>
<a name="ln375"> </a>
<a name="ln376"> </a>
<a name="ln377">    if ( clazz-&gt;done_slot )</a>
<a name="ln378">      clazz-&gt;done_slot( slot );</a>
<a name="ln379"> </a>
<a name="ln380">    /* free bitmap buffer if needed */</a>
<a name="ln381">    ft_glyphslot_free_bitmap( slot );</a>
<a name="ln382"> </a>
<a name="ln383">    /* slot-&gt;internal might be NULL in out-of-memory situations */</a>
<a name="ln384">    if ( slot-&gt;internal )</a>
<a name="ln385">    {</a>
<a name="ln386">      /* free glyph loader */</a>
<a name="ln387">      if ( FT_DRIVER_USES_OUTLINES( driver ) )</a>
<a name="ln388">      {</a>
<a name="ln389">        FT_GlyphLoader_Done( slot-&gt;internal-&gt;loader );</a>
<a name="ln390">        slot-&gt;internal-&gt;loader = NULL;</a>
<a name="ln391">      }</a>
<a name="ln392"> </a>
<a name="ln393">      FT_FREE( slot-&gt;internal );</a>
<a name="ln394">    }</a>
<a name="ln395">  }</a>
<a name="ln396"> </a>
<a name="ln397"> </a>
<a name="ln398">  /* documentation is in ftobjs.h */</a>
<a name="ln399"> </a>
<a name="ln400">  FT_BASE_DEF( FT_Error )</a>
<a name="ln401">  FT_New_GlyphSlot( FT_Face        face,</a>
<a name="ln402">                    FT_GlyphSlot  *aslot )</a>
<a name="ln403">  {</a>
<a name="ln404">    FT_Error         error;</a>
<a name="ln405">    FT_Driver        driver;</a>
<a name="ln406">    FT_Driver_Class  clazz;</a>
<a name="ln407">    FT_Memory        memory;</a>
<a name="ln408">    FT_GlyphSlot     slot = NULL;</a>
<a name="ln409"> </a>
<a name="ln410"> </a>
<a name="ln411">    if ( !face )</a>
<a name="ln412">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln413"> </a>
<a name="ln414">    if ( !face-&gt;driver )</a>
<a name="ln415">      return FT_THROW( Invalid_Argument );</a>
<a name="ln416"> </a>
<a name="ln417">    driver = face-&gt;driver;</a>
<a name="ln418">    clazz  = driver-&gt;clazz;</a>
<a name="ln419">    memory = driver-&gt;root.memory;</a>
<a name="ln420"> </a>
<a name="ln421">    FT_TRACE4(( &quot;FT_New_GlyphSlot: Creating new slot object\n&quot; ));</a>
<a name="ln422">    if ( !FT_ALLOC( slot, clazz-&gt;slot_object_size ) )</a>
<a name="ln423">    {</a>
<a name="ln424">      slot-&gt;face = face;</a>
<a name="ln425"> </a>
<a name="ln426">      error = ft_glyphslot_init( slot );</a>
<a name="ln427">      if ( error )</a>
<a name="ln428">      {</a>
<a name="ln429">        ft_glyphslot_done( slot );</a>
<a name="ln430">        FT_FREE( slot );</a>
<a name="ln431">        goto Exit;</a>
<a name="ln432">      }</a>
<a name="ln433"> </a>
<a name="ln434">      slot-&gt;next  = face-&gt;glyph;</a>
<a name="ln435">      face-&gt;glyph = slot;</a>
<a name="ln436"> </a>
<a name="ln437">      if ( aslot )</a>
<a name="ln438">        *aslot = slot;</a>
<a name="ln439">    }</a>
<a name="ln440">    else if ( aslot )</a>
<a name="ln441">      *aslot = NULL;</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">  Exit:</a>
<a name="ln445">    FT_TRACE4(( &quot;FT_New_GlyphSlot: Return %d\n&quot;, error ));</a>
<a name="ln446">    return error;</a>
<a name="ln447">  }</a>
<a name="ln448"> </a>
<a name="ln449"> </a>
<a name="ln450">  /* documentation is in ftobjs.h */</a>
<a name="ln451"> </a>
<a name="ln452">  FT_BASE_DEF( void )</a>
<a name="ln453">  FT_Done_GlyphSlot( FT_GlyphSlot  slot )</a>
<a name="ln454">  {</a>
<a name="ln455">    if ( slot )</a>
<a name="ln456">    {</a>
<a name="ln457">      FT_Driver     driver = slot-&gt;face-&gt;driver;</a>
<a name="ln458">      FT_Memory     memory = driver-&gt;root.memory;</a>
<a name="ln459">      FT_GlyphSlot  prev;</a>
<a name="ln460">      FT_GlyphSlot  cur;</a>
<a name="ln461"> </a>
<a name="ln462"> </a>
<a name="ln463">      /* Remove slot from its parent face's list */</a>
<a name="ln464">      prev = NULL;</a>
<a name="ln465">      cur  = slot-&gt;face-&gt;glyph;</a>
<a name="ln466"> </a>
<a name="ln467">      while ( cur )</a>
<a name="ln468">      {</a>
<a name="ln469">        if ( cur == slot )</a>
<a name="ln470">        {</a>
<a name="ln471">          if ( !prev )</a>
<a name="ln472">            slot-&gt;face-&gt;glyph = cur-&gt;next;</a>
<a name="ln473">          else</a>
<a name="ln474">            prev-&gt;next = cur-&gt;next;</a>
<a name="ln475"> </a>
<a name="ln476">          /* finalize client-specific data */</a>
<a name="ln477">          if ( slot-&gt;generic.finalizer )</a>
<a name="ln478">            slot-&gt;generic.finalizer( slot );</a>
<a name="ln479"> </a>
<a name="ln480">          ft_glyphslot_done( slot );</a>
<a name="ln481">          FT_FREE( slot );</a>
<a name="ln482">          break;</a>
<a name="ln483">        }</a>
<a name="ln484">        prev = cur;</a>
<a name="ln485">        cur  = cur-&gt;next;</a>
<a name="ln486">      }</a>
<a name="ln487">    }</a>
<a name="ln488">  }</a>
<a name="ln489"> </a>
<a name="ln490"> </a>
<a name="ln491">  /* documentation is in freetype.h */</a>
<a name="ln492"> </a>
<a name="ln493">  FT_EXPORT_DEF( void )</a>
<a name="ln494">  FT_Set_Transform( FT_Face     face,</a>
<a name="ln495">                    FT_Matrix*  matrix,</a>
<a name="ln496">                    FT_Vector*  delta )</a>
<a name="ln497">  {</a>
<a name="ln498">    FT_Face_Internal  internal;</a>
<a name="ln499"> </a>
<a name="ln500"> </a>
<a name="ln501">    if ( !face )</a>
<a name="ln502">      return;</a>
<a name="ln503"> </a>
<a name="ln504">    internal = face-&gt;internal;</a>
<a name="ln505"> </a>
<a name="ln506">    internal-&gt;transform_flags = 0;</a>
<a name="ln507"> </a>
<a name="ln508">    if ( !matrix )</a>
<a name="ln509">    {</a>
<a name="ln510">      internal-&gt;transform_matrix.xx = 0x10000L;</a>
<a name="ln511">      internal-&gt;transform_matrix.xy = 0;</a>
<a name="ln512">      internal-&gt;transform_matrix.yx = 0;</a>
<a name="ln513">      internal-&gt;transform_matrix.yy = 0x10000L;</a>
<a name="ln514"> </a>
<a name="ln515">      matrix = &amp;internal-&gt;transform_matrix;</a>
<a name="ln516">    }</a>
<a name="ln517">    else</a>
<a name="ln518">      internal-&gt;transform_matrix = *matrix;</a>
<a name="ln519"> </a>
<a name="ln520">    /* set transform_flags bit flag 0 if `matrix' isn't the identity */</a>
<a name="ln521">    if ( ( matrix-&gt;xy | matrix-&gt;yx ) ||</a>
<a name="ln522">         matrix-&gt;xx != 0x10000L      ||</a>
<a name="ln523">         matrix-&gt;yy != 0x10000L      )</a>
<a name="ln524">      internal-&gt;transform_flags |= 1;</a>
<a name="ln525"> </a>
<a name="ln526">    if ( !delta )</a>
<a name="ln527">    {</a>
<a name="ln528">      internal-&gt;transform_delta.x = 0;</a>
<a name="ln529">      internal-&gt;transform_delta.y = 0;</a>
<a name="ln530"> </a>
<a name="ln531">      delta = &amp;internal-&gt;transform_delta;</a>
<a name="ln532">    }</a>
<a name="ln533">    else</a>
<a name="ln534">      internal-&gt;transform_delta = *delta;</a>
<a name="ln535"> </a>
<a name="ln536">    /* set transform_flags bit flag 1 if `delta' isn't the null vector */</a>
<a name="ln537">    if ( delta-&gt;x | delta-&gt;y )</a>
<a name="ln538">      internal-&gt;transform_flags |= 2;</a>
<a name="ln539">  }</a>
<a name="ln540"> </a>
<a name="ln541"> </a>
<a name="ln542">  static FT_Renderer</a>
<a name="ln543">  ft_lookup_glyph_renderer( FT_GlyphSlot  slot );</a>
<a name="ln544"> </a>
<a name="ln545"> </a>
<a name="ln546">#ifdef GRID_FIT_METRICS</a>
<a name="ln547">  static void</a>
<a name="ln548">  ft_glyphslot_grid_fit_metrics( FT_GlyphSlot  slot,</a>
<a name="ln549">                                 FT_Bool       vertical )</a>
<a name="ln550">  {</a>
<a name="ln551">    FT_Glyph_Metrics*  metrics = &amp;slot-&gt;metrics;</a>
<a name="ln552">    FT_Pos             right, bottom;</a>
<a name="ln553"> </a>
<a name="ln554"> </a>
<a name="ln555">    if ( vertical )</a>
<a name="ln556">    {</a>
<a name="ln557">      metrics-&gt;horiBearingX = FT_PIX_FLOOR( metrics-&gt;horiBearingX );</a>
<a name="ln558">      metrics-&gt;horiBearingY = FT_PIX_CEIL ( metrics-&gt;horiBearingY );</a>
<a name="ln559"> </a>
<a name="ln560">      right  = FT_PIX_CEIL( metrics-&gt;vertBearingX + metrics-&gt;width );</a>
<a name="ln561">      bottom = FT_PIX_CEIL( metrics-&gt;vertBearingY + metrics-&gt;height );</a>
<a name="ln562"> </a>
<a name="ln563">      metrics-&gt;vertBearingX = FT_PIX_FLOOR( metrics-&gt;vertBearingX );</a>
<a name="ln564">      metrics-&gt;vertBearingY = FT_PIX_FLOOR( metrics-&gt;vertBearingY );</a>
<a name="ln565"> </a>
<a name="ln566">      metrics-&gt;width  = right - metrics-&gt;vertBearingX;</a>
<a name="ln567">      metrics-&gt;height = bottom - metrics-&gt;vertBearingY;</a>
<a name="ln568">    }</a>
<a name="ln569">    else</a>
<a name="ln570">    {</a>
<a name="ln571">      metrics-&gt;vertBearingX = FT_PIX_FLOOR( metrics-&gt;vertBearingX );</a>
<a name="ln572">      metrics-&gt;vertBearingY = FT_PIX_FLOOR( metrics-&gt;vertBearingY );</a>
<a name="ln573"> </a>
<a name="ln574">      right  = FT_PIX_CEIL ( metrics-&gt;horiBearingX + metrics-&gt;width );</a>
<a name="ln575">      bottom = FT_PIX_FLOOR( metrics-&gt;horiBearingY - metrics-&gt;height );</a>
<a name="ln576"> </a>
<a name="ln577">      metrics-&gt;horiBearingX = FT_PIX_FLOOR( metrics-&gt;horiBearingX );</a>
<a name="ln578">      metrics-&gt;horiBearingY = FT_PIX_CEIL ( metrics-&gt;horiBearingY );</a>
<a name="ln579"> </a>
<a name="ln580">      metrics-&gt;width  = right - metrics-&gt;horiBearingX;</a>
<a name="ln581">      metrics-&gt;height = metrics-&gt;horiBearingY - bottom;</a>
<a name="ln582">    }</a>
<a name="ln583"> </a>
<a name="ln584">    metrics-&gt;horiAdvance = FT_PIX_ROUND( metrics-&gt;horiAdvance );</a>
<a name="ln585">    metrics-&gt;vertAdvance = FT_PIX_ROUND( metrics-&gt;vertAdvance );</a>
<a name="ln586">  }</a>
<a name="ln587">#endif /* GRID_FIT_METRICS */</a>
<a name="ln588"> </a>
<a name="ln589"> </a>
<a name="ln590">  /* documentation is in freetype.h */</a>
<a name="ln591"> </a>
<a name="ln592">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln593">  FT_Load_Glyph( FT_Face   face,</a>
<a name="ln594">                 FT_UInt   glyph_index,</a>
<a name="ln595">                 FT_Int32  load_flags )</a>
<a name="ln596">  {</a>
<a name="ln597">    FT_Error      error;</a>
<a name="ln598">    FT_Driver     driver;</a>
<a name="ln599">    FT_GlyphSlot  slot;</a>
<a name="ln600">    FT_Library    library;</a>
<a name="ln601">    FT_Bool       autohint = FALSE;</a>
<a name="ln602">    FT_Module     hinter;</a>
<a name="ln603">    TT_Face       ttface = (TT_Face)face;</a>
<a name="ln604"> </a>
<a name="ln605"> </a>
<a name="ln606">    if ( !face || !face-&gt;size || !face-&gt;glyph )</a>
<a name="ln607">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln608"> </a>
<a name="ln609">    /* The validity test for `glyph_index' is performed by the */</a>
<a name="ln610">    /* font drivers.                                           */</a>
<a name="ln611"> </a>
<a name="ln612">    slot = face-&gt;glyph;</a>
<a name="ln613">    ft_glyphslot_clear( slot );</a>
<a name="ln614"> </a>
<a name="ln615">    driver  = face-&gt;driver;</a>
<a name="ln616">    library = driver-&gt;root.library;</a>
<a name="ln617">    hinter  = library-&gt;auto_hinter;</a>
<a name="ln618"> </a>
<a name="ln619">    /* resolve load flags dependencies */</a>
<a name="ln620"> </a>
<a name="ln621">    if ( load_flags &amp; FT_LOAD_NO_RECURSE )</a>
<a name="ln622">      load_flags |= FT_LOAD_NO_SCALE         |</a>
<a name="ln623">                    FT_LOAD_IGNORE_TRANSFORM;</a>
<a name="ln624"> </a>
<a name="ln625">    if ( load_flags &amp; FT_LOAD_NO_SCALE )</a>
<a name="ln626">    {</a>
<a name="ln627">      load_flags |= FT_LOAD_NO_HINTING |</a>
<a name="ln628">                    FT_LOAD_NO_BITMAP;</a>
<a name="ln629"> </a>
<a name="ln630">      load_flags &amp;= ~FT_LOAD_RENDER;</a>
<a name="ln631">    }</a>
<a name="ln632"> </a>
<a name="ln633">    /*</a>
<a name="ln634">     * Determine whether we need to auto-hint or not.</a>
<a name="ln635">     * The general rules are:</a>
<a name="ln636">     *</a>
<a name="ln637">     * - Do only auto-hinting if we have a hinter module, a scalable font</a>
<a name="ln638">     *   format dealing with outlines, and no transforms except simple</a>
<a name="ln639">     *   slants and/or rotations by integer multiples of 90 degrees.</a>
<a name="ln640">     *</a>
<a name="ln641">     * - Then, auto-hint if FT_LOAD_FORCE_AUTOHINT is set or if we don't</a>
<a name="ln642">     *   have a native font hinter.</a>
<a name="ln643">     *</a>
<a name="ln644">     * - Otherwise, auto-hint for LIGHT hinting mode or if there isn't</a>
<a name="ln645">     *   any hinting bytecode in the TrueType/OpenType font.</a>
<a name="ln646">     *</a>
<a name="ln647">     * - Exception: The font is `tricky' and requires the native hinter to</a>
<a name="ln648">     *   load properly.</a>
<a name="ln649">     */</a>
<a name="ln650"> </a>
<a name="ln651">    if ( hinter                                           &amp;&amp;</a>
<a name="ln652">         !( load_flags &amp; FT_LOAD_NO_HINTING )             &amp;&amp;</a>
<a name="ln653">         !( load_flags &amp; FT_LOAD_NO_AUTOHINT )            &amp;&amp;</a>
<a name="ln654">         FT_DRIVER_IS_SCALABLE( driver )                  &amp;&amp;</a>
<a name="ln655">         FT_DRIVER_USES_OUTLINES( driver )                &amp;&amp;</a>
<a name="ln656">         !FT_IS_TRICKY( face )                            &amp;&amp;</a>
<a name="ln657">         ( ( load_flags &amp; FT_LOAD_IGNORE_TRANSFORM )    ||</a>
<a name="ln658">           ( face-&gt;internal-&gt;transform_matrix.yx == 0 &amp;&amp;</a>
<a name="ln659">             face-&gt;internal-&gt;transform_matrix.xx != 0 ) ||</a>
<a name="ln660">           ( face-&gt;internal-&gt;transform_matrix.xx == 0 &amp;&amp;</a>
<a name="ln661">             face-&gt;internal-&gt;transform_matrix.yx != 0 ) ) )</a>
<a name="ln662">    {</a>
<a name="ln663">      if ( ( load_flags &amp; FT_LOAD_FORCE_AUTOHINT ) ||</a>
<a name="ln664">           !FT_DRIVER_HAS_HINTER( driver )         )</a>
<a name="ln665">        autohint = TRUE;</a>
<a name="ln666">      else</a>
<a name="ln667">      {</a>
<a name="ln668">        FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );</a>
<a name="ln669"> </a>
<a name="ln670"> </a>
<a name="ln671">        /* the check for `num_locations' assures that we actually    */</a>
<a name="ln672">        /* test for instructions in a TTF and not in a CFF-based OTF */</a>
<a name="ln673">        /*                                                           */</a>
<a name="ln674">        /* since `maxSizeOfInstructions' might be unreliable, we     */</a>
<a name="ln675">        /* check the size of the `fpgm' and `prep' tables, too --    */</a>
<a name="ln676">        /* the assumption is that there don't exist real TTFs where  */</a>
<a name="ln677">        /* both `fpgm' and `prep' tables are missing                 */</a>
<a name="ln678">        if ( mode == FT_RENDER_MODE_LIGHT                       ||</a>
<a name="ln679">             face-&gt;internal-&gt;ignore_unpatented_hinter           ||</a>
<a name="ln680">             ( FT_IS_SFNT( face )                             &amp;&amp;</a>
<a name="ln681">               ttface-&gt;num_locations                          &amp;&amp;</a>
<a name="ln682">               ttface-&gt;max_profile.maxSizeOfInstructions == 0 &amp;&amp;</a>
<a name="ln683">               ttface-&gt;font_program_size == 0                 &amp;&amp;</a>
<a name="ln684">               ttface-&gt;cvt_program_size == 0                  ) )</a>
<a name="ln685">          autohint = TRUE;</a>
<a name="ln686">      }</a>
<a name="ln687">    }</a>
<a name="ln688"> </a>
<a name="ln689">    if ( autohint )</a>
<a name="ln690">    {</a>
<a name="ln691">      FT_AutoHinter_Interface  hinting;</a>
<a name="ln692"> </a>
<a name="ln693"> </a>
<a name="ln694">      /* try to load embedded bitmaps first if available            */</a>
<a name="ln695">      /*                                                            */</a>
<a name="ln696">      /* XXX: This is really a temporary hack that should disappear */</a>
<a name="ln697">      /*      promptly with FreeType 2.1!                           */</a>
<a name="ln698">      /*                                                            */</a>
<a name="ln699">      if ( FT_HAS_FIXED_SIZES( face )             &amp;&amp;</a>
<a name="ln700">          ( load_flags &amp; FT_LOAD_NO_BITMAP ) == 0 )</a>
<a name="ln701">      {</a>
<a name="ln702">        error = driver-&gt;clazz-&gt;load_glyph( slot, face-&gt;size,</a>
<a name="ln703">                                           glyph_index,</a>
<a name="ln704">                                           load_flags | FT_LOAD_SBITS_ONLY );</a>
<a name="ln705"> </a>
<a name="ln706">        if ( !error &amp;&amp; slot-&gt;format == FT_GLYPH_FORMAT_BITMAP )</a>
<a name="ln707">          goto Load_Ok;</a>
<a name="ln708">      }</a>
<a name="ln709"> </a>
<a name="ln710">      {</a>
<a name="ln711">        FT_Face_Internal  internal        = face-&gt;internal;</a>
<a name="ln712">        FT_Int            transform_flags = internal-&gt;transform_flags;</a>
<a name="ln713"> </a>
<a name="ln714"> </a>
<a name="ln715">        /* since the auto-hinter calls FT_Load_Glyph by itself, */</a>
<a name="ln716">        /* make sure that glyphs aren't transformed             */</a>
<a name="ln717">        internal-&gt;transform_flags = 0;</a>
<a name="ln718"> </a>
<a name="ln719">        /* load auto-hinted outline */</a>
<a name="ln720">        hinting = (FT_AutoHinter_Interface)hinter-&gt;clazz-&gt;module_interface;</a>
<a name="ln721"> </a>
<a name="ln722">        error   = hinting-&gt;load_glyph( (FT_AutoHinter)hinter,</a>
<a name="ln723">                                       slot, face-&gt;size,</a>
<a name="ln724">                                       glyph_index, load_flags );</a>
<a name="ln725"> </a>
<a name="ln726">        internal-&gt;transform_flags = transform_flags;</a>
<a name="ln727">      }</a>
<a name="ln728">    }</a>
<a name="ln729">    else</a>
<a name="ln730">    {</a>
<a name="ln731">      error = driver-&gt;clazz-&gt;load_glyph( slot,</a>
<a name="ln732">                                         face-&gt;size,</a>
<a name="ln733">                                         glyph_index,</a>
<a name="ln734">                                         load_flags );</a>
<a name="ln735">      if ( error )</a>
<a name="ln736">        goto Exit;</a>
<a name="ln737"> </a>
<a name="ln738">      if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )</a>
<a name="ln739">      {</a>
<a name="ln740">        /* check that the loaded outline is correct */</a>
<a name="ln741">        error = FT_Outline_Check( &amp;slot-&gt;outline );</a>
<a name="ln742">        if ( error )</a>
<a name="ln743">          goto Exit;</a>
<a name="ln744"> </a>
<a name="ln745">#ifdef GRID_FIT_METRICS</a>
<a name="ln746">        if ( !( load_flags &amp; FT_LOAD_NO_HINTING ) )</a>
<a name="ln747">          ft_glyphslot_grid_fit_metrics( slot,</a>
<a name="ln748">              FT_BOOL( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT ) );</a>
<a name="ln749">#endif</a>
<a name="ln750">      }</a>
<a name="ln751">    }</a>
<a name="ln752"> </a>
<a name="ln753">  Load_Ok:</a>
<a name="ln754">    /* compute the advance */</a>
<a name="ln755">    if ( load_flags &amp; FT_LOAD_VERTICAL_LAYOUT )</a>
<a name="ln756">    {</a>
<a name="ln757">      slot-&gt;advance.x = 0;</a>
<a name="ln758">      slot-&gt;advance.y = slot-&gt;metrics.vertAdvance;</a>
<a name="ln759">    }</a>
<a name="ln760">    else</a>
<a name="ln761">    {</a>
<a name="ln762">      slot-&gt;advance.x = slot-&gt;metrics.horiAdvance;</a>
<a name="ln763">      slot-&gt;advance.y = 0;</a>
<a name="ln764">    }</a>
<a name="ln765"> </a>
<a name="ln766">    /* compute the linear advance in 16.16 pixels */</a>
<a name="ln767">    if ( ( load_flags &amp; FT_LOAD_LINEAR_DESIGN ) == 0 &amp;&amp;</a>
<a name="ln768">         ( FT_IS_SCALABLE( face ) )                  )</a>
<a name="ln769">    {</a>
<a name="ln770">      FT_Size_Metrics*  metrics = &amp;face-&gt;size-&gt;metrics;</a>
<a name="ln771"> </a>
<a name="ln772"> </a>
<a name="ln773">      /* it's tricky! */</a>
<a name="ln774">      slot-&gt;linearHoriAdvance = FT_MulDiv( slot-&gt;linearHoriAdvance,</a>
<a name="ln775">                                           metrics-&gt;x_scale, 64 );</a>
<a name="ln776"> </a>
<a name="ln777">      slot-&gt;linearVertAdvance = FT_MulDiv( slot-&gt;linearVertAdvance,</a>
<a name="ln778">                                           metrics-&gt;y_scale, 64 );</a>
<a name="ln779">    }</a>
<a name="ln780"> </a>
<a name="ln781">    if ( ( load_flags &amp; FT_LOAD_IGNORE_TRANSFORM ) == 0 )</a>
<a name="ln782">    {</a>
<a name="ln783">      FT_Face_Internal  internal = face-&gt;internal;</a>
<a name="ln784"> </a>
<a name="ln785"> </a>
<a name="ln786">      /* now, transform the glyph image if needed */</a>
<a name="ln787">      if ( internal-&gt;transform_flags )</a>
<a name="ln788">      {</a>
<a name="ln789">        /* get renderer */</a>
<a name="ln790">        FT_Renderer  renderer = ft_lookup_glyph_renderer( slot );</a>
<a name="ln791"> </a>
<a name="ln792"> </a>
<a name="ln793">        if ( renderer )</a>
<a name="ln794">          error = renderer-&gt;clazz-&gt;transform_glyph(</a>
<a name="ln795">                                     renderer, slot,</a>
<a name="ln796">                                     &amp;internal-&gt;transform_matrix,</a>
<a name="ln797">                                     &amp;internal-&gt;transform_delta );</a>
<a name="ln798">        else if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )</a>
<a name="ln799">        {</a>
<a name="ln800">          /* apply `standard' transformation if no renderer is available */</a>
<a name="ln801">          if ( internal-&gt;transform_flags &amp; 1 )</a>
<a name="ln802">            FT_Outline_Transform( &amp;slot-&gt;outline,</a>
<a name="ln803">                                  &amp;internal-&gt;transform_matrix );</a>
<a name="ln804"> </a>
<a name="ln805">          if ( internal-&gt;transform_flags &amp; 2 )</a>
<a name="ln806">            FT_Outline_Translate( &amp;slot-&gt;outline,</a>
<a name="ln807">                                  internal-&gt;transform_delta.x,</a>
<a name="ln808">                                  internal-&gt;transform_delta.y );</a>
<a name="ln809">        }</a>
<a name="ln810"> </a>
<a name="ln811">        /* transform advance */</a>
<a name="ln812">        FT_Vector_Transform( &amp;slot-&gt;advance, &amp;internal-&gt;transform_matrix );</a>
<a name="ln813">      }</a>
<a name="ln814">    }</a>
<a name="ln815"> </a>
<a name="ln816">    FT_TRACE5(( &quot;  x advance: %d\n&quot; , slot-&gt;advance.x ));</a>
<a name="ln817">    FT_TRACE5(( &quot;  y advance: %d\n&quot; , slot-&gt;advance.y ));</a>
<a name="ln818"> </a>
<a name="ln819">    FT_TRACE5(( &quot;  linear x advance: %d\n&quot; , slot-&gt;linearHoriAdvance ));</a>
<a name="ln820">    FT_TRACE5(( &quot;  linear y advance: %d\n&quot; , slot-&gt;linearVertAdvance ));</a>
<a name="ln821"> </a>
<a name="ln822">    /* do we need to render the image now? */</a>
<a name="ln823">    if ( !error                                    &amp;&amp;</a>
<a name="ln824">         slot-&gt;format != FT_GLYPH_FORMAT_BITMAP    &amp;&amp;</a>
<a name="ln825">         slot-&gt;format != FT_GLYPH_FORMAT_COMPOSITE &amp;&amp;</a>
<a name="ln826">         load_flags &amp; FT_LOAD_RENDER )</a>
<a name="ln827">    {</a>
<a name="ln828">      FT_Render_Mode  mode = FT_LOAD_TARGET_MODE( load_flags );</a>
<a name="ln829"> </a>
<a name="ln830"> </a>
<a name="ln831">      if ( mode == FT_RENDER_MODE_NORMAL      &amp;&amp;</a>
<a name="ln832">           (load_flags &amp; FT_LOAD_MONOCHROME ) )</a>
<a name="ln833">        mode = FT_RENDER_MODE_MONO;</a>
<a name="ln834"> </a>
<a name="ln835">      error = FT_Render_Glyph( slot, mode );</a>
<a name="ln836">    }</a>
<a name="ln837"> </a>
<a name="ln838">  Exit:</a>
<a name="ln839">    return error;</a>
<a name="ln840">  }</a>
<a name="ln841"> </a>
<a name="ln842"> </a>
<a name="ln843">  /* documentation is in freetype.h */</a>
<a name="ln844"> </a>
<a name="ln845">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln846">  FT_Load_Char( FT_Face   face,</a>
<a name="ln847">                FT_ULong  char_code,</a>
<a name="ln848">                FT_Int32  load_flags )</a>
<a name="ln849">  {</a>
<a name="ln850">    FT_UInt  glyph_index;</a>
<a name="ln851"> </a>
<a name="ln852"> </a>
<a name="ln853">    if ( !face )</a>
<a name="ln854">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln855"> </a>
<a name="ln856">    glyph_index = (FT_UInt)char_code;</a>
<a name="ln857">    if ( face-&gt;charmap )</a>
<a name="ln858">      glyph_index = FT_Get_Char_Index( face, char_code );</a>
<a name="ln859"> </a>
<a name="ln860">    return FT_Load_Glyph( face, glyph_index, load_flags );</a>
<a name="ln861">  }</a>
<a name="ln862"> </a>
<a name="ln863"> </a>
<a name="ln864">  /* destructor for sizes list */</a>
<a name="ln865">  static void</a>
<a name="ln866">  destroy_size( FT_Memory  memory,</a>
<a name="ln867">                FT_Size    size,</a>
<a name="ln868">                FT_Driver  driver )</a>
<a name="ln869">  {</a>
<a name="ln870">    /* finalize client-specific data */</a>
<a name="ln871">    if ( size-&gt;generic.finalizer )</a>
<a name="ln872">      size-&gt;generic.finalizer( size );</a>
<a name="ln873"> </a>
<a name="ln874">    /* finalize format-specific stuff */</a>
<a name="ln875">    if ( driver-&gt;clazz-&gt;done_size )</a>
<a name="ln876">      driver-&gt;clazz-&gt;done_size( size );</a>
<a name="ln877"> </a>
<a name="ln878">    FT_FREE( size-&gt;internal );</a>
<a name="ln879">    FT_FREE( size );</a>
<a name="ln880">  }</a>
<a name="ln881"> </a>
<a name="ln882"> </a>
<a name="ln883">  static void</a>
<a name="ln884">  ft_cmap_done_internal( FT_CMap  cmap );</a>
<a name="ln885"> </a>
<a name="ln886"> </a>
<a name="ln887">  static void</a>
<a name="ln888">  destroy_charmaps( FT_Face    face,</a>
<a name="ln889">                    FT_Memory  memory )</a>
<a name="ln890">  {</a>
<a name="ln891">    FT_Int  n;</a>
<a name="ln892"> </a>
<a name="ln893"> </a>
<a name="ln894">    if ( !face )</a>
<a name="ln895">      return;</a>
<a name="ln896"> </a>
<a name="ln897">    for ( n = 0; n &lt; face-&gt;num_charmaps; n++ )</a>
<a name="ln898">    {</a>
<a name="ln899">      FT_CMap  cmap = FT_CMAP( face-&gt;charmaps[n] );</a>
<a name="ln900"> </a>
<a name="ln901"> </a>
<a name="ln902">      ft_cmap_done_internal( cmap );</a>
<a name="ln903"> </a>
<a name="ln904">      face-&gt;charmaps[n] = NULL;</a>
<a name="ln905">    }</a>
<a name="ln906"> </a>
<a name="ln907">    FT_FREE( face-&gt;charmaps );</a>
<a name="ln908">    face-&gt;num_charmaps = 0;</a>
<a name="ln909">  }</a>
<a name="ln910"> </a>
<a name="ln911"> </a>
<a name="ln912">  /* destructor for faces list */</a>
<a name="ln913">  static void</a>
<a name="ln914">  destroy_face( FT_Memory  memory,</a>
<a name="ln915">                FT_Face    face,</a>
<a name="ln916">                FT_Driver  driver )</a>
<a name="ln917">  {</a>
<a name="ln918">    FT_Driver_Class  clazz = driver-&gt;clazz;</a>
<a name="ln919"> </a>
<a name="ln920"> </a>
<a name="ln921">    /* discard auto-hinting data */</a>
<a name="ln922">    if ( face-&gt;autohint.finalizer )</a>
<a name="ln923">      face-&gt;autohint.finalizer( face-&gt;autohint.data );</a>
<a name="ln924"> </a>
<a name="ln925">    /* Discard glyph slots for this face.                           */</a>
<a name="ln926">    /* Beware!  FT_Done_GlyphSlot() changes the field `face-&gt;glyph' */</a>
<a name="ln927">    while ( face-&gt;glyph )</a>
<a name="ln928">      FT_Done_GlyphSlot( face-&gt;glyph );</a>
<a name="ln929"> </a>
<a name="ln930">    /* discard all sizes for this face */</a>
<a name="ln931">    FT_List_Finalize( &amp;face-&gt;sizes_list,</a>
<a name="ln932">                      (FT_List_Destructor)destroy_size,</a>
<a name="ln933">                      memory,</a>
<a name="ln934">                      driver );</a>
<a name="ln935">    face-&gt;size = NULL;</a>
<a name="ln936"> </a>
<a name="ln937">    /* now discard client data */</a>
<a name="ln938">    if ( face-&gt;generic.finalizer )</a>
<a name="ln939">      face-&gt;generic.finalizer( face );</a>
<a name="ln940"> </a>
<a name="ln941">    /* discard charmaps */</a>
<a name="ln942">    destroy_charmaps( face, memory );</a>
<a name="ln943"> </a>
<a name="ln944">    /* finalize format-specific stuff */</a>
<a name="ln945">    if ( clazz-&gt;done_face )</a>
<a name="ln946">      clazz-&gt;done_face( face );</a>
<a name="ln947"> </a>
<a name="ln948">    /* close the stream for this face if needed */</a>
<a name="ln949">    FT_Stream_Free(</a>
<a name="ln950">      face-&gt;stream,</a>
<a name="ln951">      ( face-&gt;face_flags &amp; FT_FACE_FLAG_EXTERNAL_STREAM ) != 0 );</a>
<a name="ln952"> </a>
<a name="ln953">    face-&gt;stream = NULL;</a>
<a name="ln954"> </a>
<a name="ln955">    /* get rid of it */</a>
<a name="ln956">    if ( face-&gt;internal )</a>
<a name="ln957">    {</a>
<a name="ln958">      FT_FREE( face-&gt;internal );</a>
<a name="ln959">    }</a>
<a name="ln960">    FT_FREE( face );</a>
<a name="ln961">  }</a>
<a name="ln962"> </a>
<a name="ln963"> </a>
<a name="ln964">  static void</a>
<a name="ln965">  Destroy_Driver( FT_Driver  driver )</a>
<a name="ln966">  {</a>
<a name="ln967">    FT_List_Finalize( &amp;driver-&gt;faces_list,</a>
<a name="ln968">                      (FT_List_Destructor)destroy_face,</a>
<a name="ln969">                      driver-&gt;root.memory,</a>
<a name="ln970">                      driver );</a>
<a name="ln971">  }</a>
<a name="ln972"> </a>
<a name="ln973"> </a>
<a name="ln974">  /*************************************************************************/</a>
<a name="ln975">  /*                                                                       */</a>
<a name="ln976">  /* &lt;Function&gt;                                                            */</a>
<a name="ln977">  /*    find_unicode_charmap                                               */</a>
<a name="ln978">  /*                                                                       */</a>
<a name="ln979">  /* &lt;Description&gt;                                                         */</a>
<a name="ln980">  /*    This function finds a Unicode charmap, if there is one.            */</a>
<a name="ln981">  /*    And if there is more than one, it tries to favour the more         */</a>
<a name="ln982">  /*    extensive one, i.e., one that supports UCS-4 against those which   */</a>
<a name="ln983">  /*    are limited to the BMP (said UCS-2 encoding.)                      */</a>
<a name="ln984">  /*                                                                       */</a>
<a name="ln985">  /*    This function is called from open_face() (just below), and also    */</a>
<a name="ln986">  /*    from FT_Select_Charmap( ..., FT_ENCODING_UNICODE ).                */</a>
<a name="ln987">  /*                                                                       */</a>
<a name="ln988">  static FT_Error</a>
<a name="ln989">  find_unicode_charmap( FT_Face  face )</a>
<a name="ln990">  {</a>
<a name="ln991">    FT_CharMap*  first;</a>
<a name="ln992">    FT_CharMap*  cur;</a>
<a name="ln993"> </a>
<a name="ln994"> </a>
<a name="ln995">    /* caller should have already checked that `face' is valid */</a>
<a name="ln996">    FT_ASSERT( face );</a>
<a name="ln997"> </a>
<a name="ln998">    first = face-&gt;charmaps;</a>
<a name="ln999"> </a>
<a name="ln1000">    if ( !first )</a>
<a name="ln1001">      return FT_THROW( Invalid_CharMap_Handle );</a>
<a name="ln1002"> </a>
<a name="ln1003">    /*</a>
<a name="ln1004">     *  The original TrueType specification(s) only specified charmap</a>
<a name="ln1005">     *  formats that are capable of mapping 8 or 16 bit character codes to</a>
<a name="ln1006">     *  glyph indices.</a>
<a name="ln1007">     *</a>
<a name="ln1008">     *  However, recent updates to the Apple and OpenType specifications</a>
<a name="ln1009">     *  introduced new formats that are capable of mapping 32-bit character</a>
<a name="ln1010">     *  codes as well.  And these are already used on some fonts, mainly to</a>
<a name="ln1011">     *  map non-BMP Asian ideographs as defined in Unicode.</a>
<a name="ln1012">     *</a>
<a name="ln1013">     *  For compatibility purposes, these fonts generally come with</a>
<a name="ln1014">     *  *several* Unicode charmaps:</a>
<a name="ln1015">     *</a>
<a name="ln1016">     *   - One of them in the &quot;old&quot; 16-bit format, that cannot access</a>
<a name="ln1017">     *     all glyphs in the font.</a>
<a name="ln1018">     *</a>
<a name="ln1019">     *   - Another one in the &quot;new&quot; 32-bit format, that can access all</a>
<a name="ln1020">     *     the glyphs.</a>
<a name="ln1021">     *</a>
<a name="ln1022">     *  This function has been written to always favor a 32-bit charmap</a>
<a name="ln1023">     *  when found.  Otherwise, a 16-bit one is returned when found.</a>
<a name="ln1024">     */</a>
<a name="ln1025"> </a>
<a name="ln1026">    /* Since the `interesting' table, with IDs (3,10), is normally the */</a>
<a name="ln1027">    /* last one, we loop backwards.  This loses with type1 fonts with  */</a>
<a name="ln1028">    /* non-BMP characters (&lt;.0001%), this wins with .ttf with non-BMP  */</a>
<a name="ln1029">    /* chars (.01% ?), and this is the same about 99.99% of the time!  */</a>
<a name="ln1030"> </a>
<a name="ln1031">    cur = first + face-&gt;num_charmaps;  /* points after the last one */</a>
<a name="ln1032"> </a>
<a name="ln1033">    for ( ; --cur &gt;= first; )</a>
<a name="ln1034">    {</a>
<a name="ln1035">      if ( cur[0]-&gt;encoding == FT_ENCODING_UNICODE )</a>
<a name="ln1036">      {</a>
<a name="ln1037">        /* XXX If some new encodings to represent UCS-4 are added, */</a>
<a name="ln1038">        /*     they should be added here.                          */</a>
<a name="ln1039">        if ( ( cur[0]-&gt;platform_id == TT_PLATFORM_MICROSOFT &amp;&amp;</a>
<a name="ln1040">               cur[0]-&gt;encoding_id == TT_MS_ID_UCS_4        )     ||</a>
<a name="ln1041">             ( cur[0]-&gt;platform_id == TT_PLATFORM_APPLE_UNICODE &amp;&amp;</a>
<a name="ln1042">               cur[0]-&gt;encoding_id == TT_APPLE_ID_UNICODE_32    ) )</a>
<a name="ln1043">        {</a>
<a name="ln1044">          face-&gt;charmap = cur[0];</a>
<a name="ln1045">          return FT_Err_Ok;</a>
<a name="ln1046">        }</a>
<a name="ln1047">      }</a>
<a name="ln1048">    }</a>
<a name="ln1049"> </a>
<a name="ln1050">    /* We do not have any UCS-4 charmap.                */</a>
<a name="ln1051">    /* Do the loop again and search for UCS-2 charmaps. */</a>
<a name="ln1052">    cur = first + face-&gt;num_charmaps;</a>
<a name="ln1053"> </a>
<a name="ln1054">    for ( ; --cur &gt;= first; )</a>
<a name="ln1055">    {</a>
<a name="ln1056">      if ( cur[0]-&gt;encoding == FT_ENCODING_UNICODE )</a>
<a name="ln1057">      {</a>
<a name="ln1058">        face-&gt;charmap = cur[0];</a>
<a name="ln1059">        return FT_Err_Ok;</a>
<a name="ln1060">      }</a>
<a name="ln1061">    }</a>
<a name="ln1062"> </a>
<a name="ln1063">    return FT_THROW( Invalid_CharMap_Handle );</a>
<a name="ln1064">  }</a>
<a name="ln1065"> </a>
<a name="ln1066"> </a>
<a name="ln1067">  /*************************************************************************/</a>
<a name="ln1068">  /*                                                                       */</a>
<a name="ln1069">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1070">  /*    find_variant_selector_charmap                                      */</a>
<a name="ln1071">  /*                                                                       */</a>
<a name="ln1072">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1073">  /*    This function finds the variant selector charmap, if there is one. */</a>
<a name="ln1074">  /*    There can only be one (platform=0, specific=5, format=14).         */</a>
<a name="ln1075">  /*                                                                       */</a>
<a name="ln1076">  static FT_CharMap</a>
<a name="ln1077">  find_variant_selector_charmap( FT_Face  face )</a>
<a name="ln1078">  {</a>
<a name="ln1079">    FT_CharMap*  first;</a>
<a name="ln1080">    FT_CharMap*  end;</a>
<a name="ln1081">    FT_CharMap*  cur;</a>
<a name="ln1082"> </a>
<a name="ln1083"> </a>
<a name="ln1084">    /* caller should have already checked that `face' is valid */</a>
<a name="ln1085">    FT_ASSERT( face );</a>
<a name="ln1086"> </a>
<a name="ln1087">    first = face-&gt;charmaps;</a>
<a name="ln1088"> </a>
<a name="ln1089">    if ( !first )</a>
<a name="ln1090">      return NULL;</a>
<a name="ln1091"> </a>
<a name="ln1092">    end = first + face-&gt;num_charmaps;  /* points after the last one */</a>
<a name="ln1093"> </a>
<a name="ln1094">    for ( cur = first; cur &lt; end; ++cur )</a>
<a name="ln1095">    {</a>
<a name="ln1096">      if ( cur[0]-&gt;platform_id == TT_PLATFORM_APPLE_UNICODE    &amp;&amp;</a>
<a name="ln1097">           cur[0]-&gt;encoding_id == TT_APPLE_ID_VARIANT_SELECTOR &amp;&amp;</a>
<a name="ln1098">           FT_Get_CMap_Format( cur[0] ) == 14                  )</a>
<a name="ln1099">        return cur[0];</a>
<a name="ln1100">    }</a>
<a name="ln1101"> </a>
<a name="ln1102">    return NULL;</a>
<a name="ln1103">  }</a>
<a name="ln1104"> </a>
<a name="ln1105"> </a>
<a name="ln1106">  /*************************************************************************/</a>
<a name="ln1107">  /*                                                                       */</a>
<a name="ln1108">  /* &lt;Function&gt;                                                            */</a>
<a name="ln1109">  /*    open_face                                                          */</a>
<a name="ln1110">  /*                                                                       */</a>
<a name="ln1111">  /* &lt;Description&gt;                                                         */</a>
<a name="ln1112">  /*    This function does some work for FT_Open_Face().                   */</a>
<a name="ln1113">  /*                                                                       */</a>
<a name="ln1114">  static FT_Error</a>
<a name="ln1115">  open_face( FT_Driver      driver,</a>
<a name="ln1116">             FT_Stream      *astream,</a>
<a name="ln1117">             FT_Bool        external_stream,</a>
<a name="ln1118">             FT_Long        face_index,</a>
<a name="ln1119">             FT_Int         num_params,</a>
<a name="ln1120">             FT_Parameter*  params,</a>
<a name="ln1121">             FT_Face       *aface )</a>
<a name="ln1122">  {</a>
<a name="ln1123">    FT_Memory         memory;</a>
<a name="ln1124">    FT_Driver_Class   clazz;</a>
<a name="ln1125">    FT_Face           face     = NULL;</a>
<a name="ln1126">    FT_Face_Internal  internal = NULL;</a>
<a name="ln1127"> </a>
<a name="ln1128">    FT_Error          error, error2;</a>
<a name="ln1129"> </a>
<a name="ln1130"> </a>
<a name="ln1131">    clazz  = driver-&gt;clazz;</a>
<a name="ln1132">    memory = driver-&gt;root.memory;</a>
<a name="ln1133"> </a>
<a name="ln1134">    /* allocate the face object and perform basic initialization */</a>
<a name="ln1135">    if ( FT_ALLOC( face, clazz-&gt;face_object_size ) )</a>
<a name="ln1136">      goto Fail;</a>
<a name="ln1137"> </a>
<a name="ln1138">    face-&gt;driver = driver;</a>
<a name="ln1139">    face-&gt;memory = memory;</a>
<a name="ln1140">    face-&gt;stream = *astream;</a>
<a name="ln1141"> </a>
<a name="ln1142">    /* set the FT_FACE_FLAG_EXTERNAL_STREAM bit for FT_Done_Face */</a>
<a name="ln1143">    if ( external_stream )</a>
<a name="ln1144">      face-&gt;face_flags |= FT_FACE_FLAG_EXTERNAL_STREAM;</a>
<a name="ln1145"> </a>
<a name="ln1146">    if ( FT_NEW( internal ) )</a>
<a name="ln1147">      goto Fail;</a>
<a name="ln1148"> </a>
<a name="ln1149">    face-&gt;internal = internal;</a>
<a name="ln1150"> </a>
<a name="ln1151">#ifdef FT_CONFIG_OPTION_INCREMENTAL</a>
<a name="ln1152">    {</a>
<a name="ln1153">      int  i;</a>
<a name="ln1154"> </a>
<a name="ln1155"> </a>
<a name="ln1156">      face-&gt;internal-&gt;incremental_interface = NULL;</a>
<a name="ln1157">      for ( i = 0; i &lt; num_params &amp;&amp; !face-&gt;internal-&gt;incremental_interface;</a>
<a name="ln1158">            i++ )</a>
<a name="ln1159">        if ( params[i].tag == FT_PARAM_TAG_INCREMENTAL )</a>
<a name="ln1160">          face-&gt;internal-&gt;incremental_interface =</a>
<a name="ln1161">            (FT_Incremental_Interface)params[i].data;</a>
<a name="ln1162">    }</a>
<a name="ln1163">#endif</a>
<a name="ln1164"> </a>
<a name="ln1165">    if ( clazz-&gt;init_face )</a>
<a name="ln1166">      error = clazz-&gt;init_face( *astream,</a>
<a name="ln1167">                                face,</a>
<a name="ln1168">                                (FT_Int)face_index,</a>
<a name="ln1169">                                num_params,</a>
<a name="ln1170">                                params );</a>
<a name="ln1171">    *astream = face-&gt;stream; /* Stream may have been changed. */</a>
<a name="ln1172">    if ( error )</a>
<a name="ln1173">      goto Fail;</a>
<a name="ln1174"> </a>
<a name="ln1175">    /* select Unicode charmap by default */</a>
<a name="ln1176">    error2 = find_unicode_charmap( face );</a>
<a name="ln1177"> </a>
<a name="ln1178">    /* if no Unicode charmap can be found, FT_Err_Invalid_CharMap_Handle */</a>
<a name="ln1179">    /* is returned.                                                      */</a>
<a name="ln1180"> </a>
<a name="ln1181">    /* no error should happen, but we want to play safe */</a>
<a name="ln1182">    if ( error2 &amp;&amp; FT_ERR_NEQ( error2, Invalid_CharMap_Handle ) )</a>
<a name="ln1183">    {</a>
<a name="ln1184">      error = error2;</a>
<a name="ln1185">      goto Fail;</a>
<a name="ln1186">    }</a>
<a name="ln1187"> </a>
<a name="ln1188">    *aface = face;</a>
<a name="ln1189"> </a>
<a name="ln1190">  Fail:</a>
<a name="ln1191">    if ( error )</a>
<a name="ln1192">    {</a>
<a name="ln1193">      destroy_charmaps( face, memory );</a>
<a name="ln1194">      if ( clazz-&gt;done_face )</a>
<a name="ln1195">        clazz-&gt;done_face( face );</a>
<a name="ln1196">      FT_FREE( internal );</a>
<a name="ln1197">      FT_FREE( face );</a>
<a name="ln1198">      *aface = NULL;</a>
<a name="ln1199">    }</a>
<a name="ln1200"> </a>
<a name="ln1201">    return error;</a>
<a name="ln1202">  }</a>
<a name="ln1203"> </a>
<a name="ln1204"> </a>
<a name="ln1205">  /* there's a Mac-specific extended implementation of FT_New_Face() */</a>
<a name="ln1206">  /* in src/base/ftmac.c                                             */</a>
<a name="ln1207"> </a>
<a name="ln1208">#ifndef FT_MACINTOSH</a>
<a name="ln1209"> </a>
<a name="ln1210">  /* documentation is in freetype.h */</a>
<a name="ln1211"> </a>
<a name="ln1212">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln1213">  FT_New_Face( FT_Library   library,</a>
<a name="ln1214">               const char*  pathname,</a>
<a name="ln1215">               FT_Long      face_index,</a>
<a name="ln1216">               FT_Face     *aface )</a>
<a name="ln1217">  {</a>
<a name="ln1218">    FT_Open_Args  args;</a>
<a name="ln1219"> </a>
<a name="ln1220"> </a>
<a name="ln1221">    /* test for valid `library' and `aface' delayed to `FT_Open_Face' */</a>
<a name="ln1222">    if ( !pathname )</a>
<a name="ln1223">      return FT_THROW( Invalid_Argument );</a>
<a name="ln1224"> </a>
<a name="ln1225">    args.flags    = FT_OPEN_PATHNAME;</a>
<a name="ln1226">    args.pathname = (char*)pathname;</a>
<a name="ln1227">    args.stream   = NULL;</a>
<a name="ln1228"> </a>
<a name="ln1229">    return FT_Open_Face( library, &amp;args, face_index, aface );</a>
<a name="ln1230">  }</a>
<a name="ln1231"> </a>
<a name="ln1232">#endif</a>
<a name="ln1233"> </a>
<a name="ln1234"> </a>
<a name="ln1235">  /* documentation is in freetype.h */</a>
<a name="ln1236"> </a>
<a name="ln1237">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln1238">  FT_New_Memory_Face( FT_Library      library,</a>
<a name="ln1239">                      const FT_Byte*  file_base,</a>
<a name="ln1240">                      FT_Long         file_size,</a>
<a name="ln1241">                      FT_Long         face_index,</a>
<a name="ln1242">                      FT_Face        *aface )</a>
<a name="ln1243">  {</a>
<a name="ln1244">    FT_Open_Args  args;</a>
<a name="ln1245"> </a>
<a name="ln1246"> </a>
<a name="ln1247">    /* test for valid `library' and `face' delayed to `FT_Open_Face' */</a>
<a name="ln1248">    if ( !file_base )</a>
<a name="ln1249">      return FT_THROW( Invalid_Argument );</a>
<a name="ln1250"> </a>
<a name="ln1251">    args.flags       = FT_OPEN_MEMORY;</a>
<a name="ln1252">    args.memory_base = file_base;</a>
<a name="ln1253">    args.memory_size = file_size;</a>
<a name="ln1254">    args.stream      = NULL;</a>
<a name="ln1255"> </a>
<a name="ln1256">    return FT_Open_Face( library, &amp;args, face_index, aface );</a>
<a name="ln1257">  }</a>
<a name="ln1258"> </a>
<a name="ln1259"> </a>
<a name="ln1260">#ifdef FT_CONFIG_OPTION_MAC_FONTS</a>
<a name="ln1261"> </a>
<a name="ln1262">  /* The behavior here is very similar to that in base/ftmac.c, but it     */</a>
<a name="ln1263">  /* is designed to work on non-mac systems, so no mac specific calls.     */</a>
<a name="ln1264">  /*                                                                       */</a>
<a name="ln1265">  /* We look at the file and determine if it is a mac dfont file or a mac  */</a>
<a name="ln1266">  /* resource file, or a macbinary file containing a mac resource file.    */</a>
<a name="ln1267">  /*                                                                       */</a>
<a name="ln1268">  /* Unlike ftmac I'm not going to look at a `FOND'.  I don't really see   */</a>
<a name="ln1269">  /* the point, especially since there may be multiple `FOND' resources.   */</a>
<a name="ln1270">  /* Instead I'll just look for `sfnt' and `POST' resources, ordered as    */</a>
<a name="ln1271">  /* they occur in the file.                                               */</a>
<a name="ln1272">  /*                                                                       */</a>
<a name="ln1273">  /* Note that multiple `POST' resources do not mean multiple postscript   */</a>
<a name="ln1274">  /* fonts; they all get jammed together to make what is essentially a     */</a>
<a name="ln1275">  /* pfb file.                                                             */</a>
<a name="ln1276">  /*                                                                       */</a>
<a name="ln1277">  /* We aren't interested in `NFNT' or `FONT' bitmap resources.            */</a>
<a name="ln1278">  /*                                                                       */</a>
<a name="ln1279">  /* As soon as we get an `sfnt' load it into memory and pass it off to    */</a>
<a name="ln1280">  /* FT_Open_Face.                                                         */</a>
<a name="ln1281">  /*                                                                       */</a>
<a name="ln1282">  /* If we have a (set of) `POST' resources, massage them into a (memory)  */</a>
<a name="ln1283">  /* pfb file and pass that to FT_Open_Face.  (As with ftmac.c I'm not     */</a>
<a name="ln1284">  /* going to try to save the kerning info.  After all that lives in the   */</a>
<a name="ln1285">  /* `FOND' which isn't in the file containing the `POST' resources so     */</a>
<a name="ln1286">  /* we don't really have access to it.                                    */</a>
<a name="ln1287"> </a>
<a name="ln1288"> </a>
<a name="ln1289">  /* Finalizer for a memory stream; gets called by FT_Done_Face(). */</a>
<a name="ln1290">  /* It frees the memory it uses.                                  */</a>
<a name="ln1291">  /* From ftmac.c.                                                 */</a>
<a name="ln1292">  static void</a>
<a name="ln1293">  memory_stream_close( FT_Stream  stream )</a>
<a name="ln1294">  {</a>
<a name="ln1295">    FT_Memory  memory = stream-&gt;memory;</a>
<a name="ln1296"> </a>
<a name="ln1297"> </a>
<a name="ln1298">    FT_FREE( stream-&gt;base );</a>
<a name="ln1299"> </a>
<a name="ln1300">    stream-&gt;size  = 0;</a>
<a name="ln1301">    stream-&gt;base  = NULL;</a>
<a name="ln1302">    stream-&gt;close = NULL;</a>
<a name="ln1303">  }</a>
<a name="ln1304"> </a>
<a name="ln1305"> </a>
<a name="ln1306">  /* Create a new memory stream from a buffer and a size. */</a>
<a name="ln1307">  /* From ftmac.c.                                        */</a>
<a name="ln1308">  static FT_Error</a>
<a name="ln1309">  new_memory_stream( FT_Library           library,</a>
<a name="ln1310">                     FT_Byte*             base,</a>
<a name="ln1311">                     FT_ULong             size,</a>
<a name="ln1312">                     FT_Stream_CloseFunc  close,</a>
<a name="ln1313">                     FT_Stream           *astream )</a>
<a name="ln1314">  {</a>
<a name="ln1315">    FT_Error   error;</a>
<a name="ln1316">    FT_Memory  memory;</a>
<a name="ln1317">    FT_Stream  stream = NULL;</a>
<a name="ln1318"> </a>
<a name="ln1319"> </a>
<a name="ln1320">    if ( !library )</a>
<a name="ln1321">      return FT_THROW( Invalid_Library_Handle );</a>
<a name="ln1322"> </a>
<a name="ln1323">    if ( !base )</a>
<a name="ln1324">      return FT_THROW( Invalid_Argument );</a>
<a name="ln1325"> </a>
<a name="ln1326">    *astream = NULL;</a>
<a name="ln1327">    memory = library-&gt;memory;</a>
<a name="ln1328">    if ( FT_NEW( stream ) )</a>
<a name="ln1329">      goto Exit;</a>
<a name="ln1330"> </a>
<a name="ln1331">    FT_Stream_OpenMemory( stream, base, size );</a>
<a name="ln1332"> </a>
<a name="ln1333">    stream-&gt;close = close;</a>
<a name="ln1334"> </a>
<a name="ln1335">    *astream = stream;</a>
<a name="ln1336"> </a>
<a name="ln1337">  Exit:</a>
<a name="ln1338">    return error;</a>
<a name="ln1339">  }</a>
<a name="ln1340"> </a>
<a name="ln1341"> </a>
<a name="ln1342">  /* Create a new FT_Face given a buffer and a driver name. */</a>
<a name="ln1343">  /* from ftmac.c */</a>
<a name="ln1344">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln1345">  open_face_from_buffer( FT_Library   library,</a>
<a name="ln1346">                         FT_Byte*     base,</a>
<a name="ln1347">                         FT_ULong     size,</a>
<a name="ln1348">                         FT_Long      face_index,</a>
<a name="ln1349">                         const char*  driver_name,</a>
<a name="ln1350">                         FT_Face     *aface )</a>
<a name="ln1351">  {</a>
<a name="ln1352">    FT_Open_Args  args;</a>
<a name="ln1353">    FT_Error      error;</a>
<a name="ln1354">    FT_Stream     stream = NULL;</a>
<a name="ln1355">    FT_Memory     memory = library-&gt;memory;</a>
<a name="ln1356"> </a>
<a name="ln1357"> </a>
<a name="ln1358">    error = new_memory_stream( library,</a>
<a name="ln1359">                               base,</a>
<a name="ln1360">                               size,</a>
<a name="ln1361">                               memory_stream_close,</a>
<a name="ln1362">                               &amp;stream );</a>
<a name="ln1363">    if ( error )</a>
<a name="ln1364">    {</a>
<a name="ln1365">      FT_FREE( base );</a>
<a name="ln1366">      return error;</a>
<a name="ln1367">    }</a>
<a name="ln1368"> </a>
<a name="ln1369">    args.flags = FT_OPEN_STREAM;</a>
<a name="ln1370">    args.stream = stream;</a>
<a name="ln1371">    if ( driver_name )</a>
<a name="ln1372">    {</a>
<a name="ln1373">      args.flags = args.flags | FT_OPEN_DRIVER;</a>
<a name="ln1374">      args.driver = FT_Get_Module( library, driver_name );</a>
<a name="ln1375">    }</a>
<a name="ln1376"> </a>
<a name="ln1377">#ifdef FT_MACINTOSH</a>
<a name="ln1378">    /* At this point, the face index has served its purpose;  */</a>
<a name="ln1379">    /* whoever calls this function has already used it to     */</a>
<a name="ln1380">    /* locate the correct font data.  We should not propagate */</a>
<a name="ln1381">    /* this index to FT_Open_Face() (unless it is negative).  */</a>
<a name="ln1382"> </a>
<a name="ln1383">    if ( face_index &gt; 0 )</a>
<a name="ln1384">      face_index &amp;= 0x7FFF0000L; /* retain GX data */</a>
<a name="ln1385">#endif</a>
<a name="ln1386"> </a>
<a name="ln1387">    error = FT_Open_Face( library, &amp;args, face_index, aface );</a>
<a name="ln1388"> </a>
<a name="ln1389">    if ( error == FT_Err_Ok )</a>
<a name="ln1390">      (*aface)-&gt;face_flags &amp;= ~FT_FACE_FLAG_EXTERNAL_STREAM;</a>
<a name="ln1391">    else</a>
<a name="ln1392">#ifdef FT_MACINTOSH</a>
<a name="ln1393">      FT_Stream_Free( stream, 0 );</a>
<a name="ln1394">#else</a>
<a name="ln1395">    {</a>
<a name="ln1396">      FT_Stream_Close( stream );</a>
<a name="ln1397">      FT_FREE( stream );</a>
<a name="ln1398">    }</a>
<a name="ln1399">#endif</a>
<a name="ln1400"> </a>
<a name="ln1401">    return error;</a>
<a name="ln1402">  }</a>
<a name="ln1403"> </a>
<a name="ln1404"> </a>
<a name="ln1405">  /* Look up `TYP1' or `CID ' table from sfnt table directory.       */</a>
<a name="ln1406">  /* `offset' and `length' must exclude the binary header in tables. */</a>
<a name="ln1407"> </a>
<a name="ln1408">  /* Type 1 and CID-keyed font drivers should recognize sfnt-wrapped */</a>
<a name="ln1409">  /* format too.  Here, since we can't expect that the TrueType font */</a>
<a name="ln1410">  /* driver is loaded unconditially, we must parse the font by       */</a>
<a name="ln1411">  /* ourselves.  We are only interested in the name of the table and */</a>
<a name="ln1412">  /* the offset.                                                     */</a>
<a name="ln1413"> </a>
<a name="ln1414">  static FT_Error</a>
<a name="ln1415">  ft_lookup_PS_in_sfnt_stream( FT_Stream  stream,</a>
<a name="ln1416">                               FT_Long    face_index,</a>
<a name="ln1417">                               FT_ULong*  offset,</a>
<a name="ln1418">                               FT_ULong*  length,</a>
<a name="ln1419">                               FT_Bool*   is_sfnt_cid )</a>
<a name="ln1420">  {</a>
<a name="ln1421">    FT_Error   error;</a>
<a name="ln1422">    FT_UShort  numTables;</a>
<a name="ln1423">    FT_Long    pstable_index;</a>
<a name="ln1424">    FT_ULong   tag;</a>
<a name="ln1425">    int        i;</a>
<a name="ln1426"> </a>
<a name="ln1427"> </a>
<a name="ln1428">    *offset = 0;</a>
<a name="ln1429">    *length = 0;</a>
<a name="ln1430">    *is_sfnt_cid = FALSE;</a>
<a name="ln1431"> </a>
<a name="ln1432">    /* TODO: support for sfnt-wrapped PS/CID in TTC format */</a>
<a name="ln1433"> </a>
<a name="ln1434">    /* version check for 'typ1' (should be ignored?) */</a>
<a name="ln1435">    if ( FT_READ_ULONG( tag ) )</a>
<a name="ln1436">      return error;</a>
<a name="ln1437">    if ( tag != TTAG_typ1 )</a>
<a name="ln1438">      return FT_THROW( Unknown_File_Format );</a>
<a name="ln1439"> </a>
<a name="ln1440">    if ( FT_READ_USHORT( numTables ) )</a>
<a name="ln1441">      return error;</a>
<a name="ln1442">    if ( FT_STREAM_SKIP( 2 * 3 ) ) /* skip binary search header */</a>
<a name="ln1443">      return error;</a>
<a name="ln1444"> </a>
<a name="ln1445">    pstable_index = -1;</a>
<a name="ln1446">    *is_sfnt_cid  = FALSE;</a>
<a name="ln1447"> </a>
<a name="ln1448">    for ( i = 0; i &lt; numTables; i++ )</a>
<a name="ln1449">    {</a>
<a name="ln1450">      if ( FT_READ_ULONG( tag )     || FT_STREAM_SKIP( 4 )      ||</a>
<a name="ln1451">           FT_READ_ULONG( *offset ) || FT_READ_ULONG( *length ) )</a>
<a name="ln1452">        return error;</a>
<a name="ln1453"> </a>
<a name="ln1454">      if ( tag == TTAG_CID )</a>
<a name="ln1455">      {</a>
<a name="ln1456">        pstable_index++;</a>
<a name="ln1457">        *offset += 22;</a>
<a name="ln1458">        *length -= 22;</a>
<a name="ln1459">        *is_sfnt_cid = TRUE;</a>
<a name="ln1460">        if ( face_index &lt; 0 )</a>
<a name="ln1461">          return FT_Err_Ok;</a>
<a name="ln1462">      }</a>
<a name="ln1463">      else if ( tag == TTAG_TYP1 )</a>
<a name="ln1464">      {</a>
<a name="ln1465">        pstable_index++;</a>
<a name="ln1466">        *offset += 24;</a>
<a name="ln1467">        *length -= 24;</a>
<a name="ln1468">        *is_sfnt_cid = FALSE;</a>
<a name="ln1469">        if ( face_index &lt; 0 )</a>
<a name="ln1470">          return FT_Err_Ok;</a>
<a name="ln1471">      }</a>
<a name="ln1472">      if ( face_index &gt;= 0 &amp;&amp; pstable_index == face_index )</a>
<a name="ln1473">        return FT_Err_Ok;</a>
<a name="ln1474">    }</a>
<a name="ln1475">    return FT_THROW( Table_Missing );</a>
<a name="ln1476">  }</a>
<a name="ln1477"> </a>
<a name="ln1478"> </a>
<a name="ln1479">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln1480">  open_face_PS_from_sfnt_stream( FT_Library     library,</a>
<a name="ln1481">                                 FT_Stream      stream,</a>
<a name="ln1482">                                 FT_Long        face_index,</a>
<a name="ln1483">                                 FT_Int         num_params,</a>
<a name="ln1484">                                 FT_Parameter  *params,</a>
<a name="ln1485">                                 FT_Face       *aface )</a>
<a name="ln1486">  {</a>
<a name="ln1487">    FT_Error   error;</a>
<a name="ln1488">    FT_Memory  memory = library-&gt;memory;</a>
<a name="ln1489">    FT_ULong   offset, length;</a>
<a name="ln1490">    FT_ULong   pos;</a>
<a name="ln1491">    FT_Bool    is_sfnt_cid;</a>
<a name="ln1492">    FT_Byte*   sfnt_ps = NULL;</a>
<a name="ln1493"> </a>
<a name="ln1494">    FT_UNUSED( num_params );</a>
<a name="ln1495">    FT_UNUSED( params );</a>
<a name="ln1496"> </a>
<a name="ln1497"> </a>
<a name="ln1498">    /* ignore GX stuff */</a>
<a name="ln1499">    if ( face_index &gt; 0 )</a>
<a name="ln1500">      face_index &amp;= 0xFFFFL;</a>
<a name="ln1501"> </a>
<a name="ln1502">    pos = FT_STREAM_POS();</a>
<a name="ln1503"> </a>
<a name="ln1504">    error = ft_lookup_PS_in_sfnt_stream( stream,</a>
<a name="ln1505">                                         face_index,</a>
<a name="ln1506">                                         &amp;offset,</a>
<a name="ln1507">                                         &amp;length,</a>
<a name="ln1508">                                         &amp;is_sfnt_cid );</a>
<a name="ln1509">    if ( error )</a>
<a name="ln1510">      goto Exit;</a>
<a name="ln1511"> </a>
<a name="ln1512">    if ( FT_Stream_Seek( stream, pos + offset ) )</a>
<a name="ln1513">      goto Exit;</a>
<a name="ln1514"> </a>
<a name="ln1515">    if ( FT_ALLOC( sfnt_ps, (FT_Long)length ) )</a>
<a name="ln1516">      goto Exit;</a>
<a name="ln1517"> </a>
<a name="ln1518">    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_ps, length );</a>
<a name="ln1519">    if ( error ) {</a>
<a name="ln1520">      FT_FREE( sfnt_ps );</a>
<a name="ln1521">      goto Exit;</a>
<a name="ln1522">    }</a>
<a name="ln1523"> </a>
<a name="ln1524">    error = open_face_from_buffer( library,</a>
<a name="ln1525">                                   sfnt_ps,</a>
<a name="ln1526">                                   length,</a>
<a name="ln1527">                                   FT_MIN( face_index, 0 ),</a>
<a name="ln1528">                                   is_sfnt_cid ? &quot;cid&quot; : &quot;type1&quot;,</a>
<a name="ln1529">                                   aface );</a>
<a name="ln1530">  Exit:</a>
<a name="ln1531">    {</a>
<a name="ln1532">      FT_Error  error1;</a>
<a name="ln1533"> </a>
<a name="ln1534"> </a>
<a name="ln1535">      if ( FT_ERR_EQ( error, Unknown_File_Format ) )</a>
<a name="ln1536">      {</a>
<a name="ln1537">        error1 = FT_Stream_Seek( stream, pos );</a>
<a name="ln1538">        if ( error1 )</a>
<a name="ln1539">          return error1;</a>
<a name="ln1540">      }</a>
<a name="ln1541"> </a>
<a name="ln1542">      return error;</a>
<a name="ln1543">    }</a>
<a name="ln1544">  }</a>
<a name="ln1545"> </a>
<a name="ln1546"> </a>
<a name="ln1547">#ifndef FT_MACINTOSH</a>
<a name="ln1548"> </a>
<a name="ln1549">  /* The resource header says we've got resource_cnt `POST' (type1) */</a>
<a name="ln1550">  /* resources in this file.  They all need to be coalesced into    */</a>
<a name="ln1551">  /* one lump which gets passed on to the type1 driver.             */</a>
<a name="ln1552">  /* Here can be only one PostScript font in a file so face_index   */</a>
<a name="ln1553">  /* must be 0 (or -1).                                             */</a>
<a name="ln1554">  /*                                                                */</a>
<a name="ln1555">  static FT_Error</a>
<a name="ln1556">  Mac_Read_POST_Resource( FT_Library  library,</a>
<a name="ln1557">                          FT_Stream   stream,</a>
<a name="ln1558">                          FT_Long    *offsets,</a>
<a name="ln1559">                          FT_Long     resource_cnt,</a>
<a name="ln1560">                          FT_Long     face_index,</a>
<a name="ln1561">                          FT_Face    *aface )</a>
<a name="ln1562">  {</a>
<a name="ln1563">    FT_Error   error  = FT_ERR( Cannot_Open_Resource );</a>
<a name="ln1564">    FT_Memory  memory = library-&gt;memory;</a>
<a name="ln1565">    FT_Byte*   pfb_data = NULL;</a>
<a name="ln1566">    int        i, type, flags;</a>
<a name="ln1567">    FT_ULong   len;</a>
<a name="ln1568">    FT_ULong   pfb_len, pfb_pos, pfb_lenpos;</a>
<a name="ln1569">    FT_ULong   rlen, temp;</a>
<a name="ln1570"> </a>
<a name="ln1571"> </a>
<a name="ln1572">    if ( face_index == -1 )</a>
<a name="ln1573">      face_index = 0;</a>
<a name="ln1574">    if ( face_index != 0 )</a>
<a name="ln1575">      return error;</a>
<a name="ln1576"> </a>
<a name="ln1577">    /* Find the length of all the POST resources, concatenated.  Assume */</a>
<a name="ln1578">    /* worst case (each resource in its own section).                   */</a>
<a name="ln1579">    pfb_len = 0;</a>
<a name="ln1580">    for ( i = 0; i &lt; resource_cnt; ++i )</a>
<a name="ln1581">    {</a>
<a name="ln1582">      error = FT_Stream_Seek( stream, (FT_ULong)offsets[i] );</a>
<a name="ln1583">      if ( error )</a>
<a name="ln1584">        goto Exit;</a>
<a name="ln1585">      if ( FT_READ_ULONG( temp ) )</a>
<a name="ln1586">        goto Exit;</a>
<a name="ln1587"> </a>
<a name="ln1588">      /* FT2 allocator takes signed long buffer length,</a>
<a name="ln1589">       * too large value causing overflow should be checked</a>
<a name="ln1590">       */</a>
<a name="ln1591">      FT_TRACE4(( &quot;                 POST fragment #%d: length=0x%08x&quot;</a>
<a name="ln1592">                  &quot; total pfb_len=0x%08x\n&quot;,</a>
<a name="ln1593">                  i, temp, pfb_len + temp + 6));</a>
<a name="ln1594">      if ( FT_MAC_RFORK_MAX_LEN &lt; temp               ||</a>
<a name="ln1595">           FT_MAC_RFORK_MAX_LEN - temp &lt; pfb_len + 6 )</a>
<a name="ln1596">      {</a>
<a name="ln1597">        FT_TRACE2(( &quot;             MacOS resource length cannot exceed&quot;</a>
<a name="ln1598">                    &quot; 0x%08x\n&quot;, FT_MAC_RFORK_MAX_LEN ));</a>
<a name="ln1599">        error = FT_THROW( Invalid_Offset );</a>
<a name="ln1600">        goto Exit;</a>
<a name="ln1601">      }</a>
<a name="ln1602"> </a>
<a name="ln1603">      pfb_len += temp + 6;</a>
<a name="ln1604">    }</a>
<a name="ln1605"> </a>
<a name="ln1606">    FT_TRACE2(( &quot;             total buffer size to concatenate %d&quot;</a>
<a name="ln1607">                &quot; POST fragments: 0x%08x\n&quot;,</a>
<a name="ln1608">                 resource_cnt, pfb_len + 2));</a>
<a name="ln1609">    if ( pfb_len + 2 &lt; 6 ) {</a>
<a name="ln1610">      FT_TRACE2(( &quot;             too long fragment length makes&quot;</a>
<a name="ln1611">                  &quot; pfb_len confused: pfb_len=0x%08x\n&quot;, pfb_len ));</a>
<a name="ln1612">      error = FT_THROW( Array_Too_Large );</a>
<a name="ln1613">      goto Exit;</a>
<a name="ln1614">    }</a>
<a name="ln1615">    if ( FT_ALLOC( pfb_data, (FT_Long)pfb_len + 2 ) )</a>
<a name="ln1616">      goto Exit;</a>
<a name="ln1617"> </a>
<a name="ln1618">    pfb_data[0] = 0x80;</a>
<a name="ln1619">    pfb_data[1] = 1;            /* Ascii section */</a>
<a name="ln1620">    pfb_data[2] = 0;            /* 4-byte length, fill in later */</a>
<a name="ln1621">    pfb_data[3] = 0;</a>
<a name="ln1622">    pfb_data[4] = 0;</a>
<a name="ln1623">    pfb_data[5] = 0;</a>
<a name="ln1624">    pfb_pos     = 6;</a>
<a name="ln1625">    pfb_lenpos  = 2;</a>
<a name="ln1626"> </a>
<a name="ln1627">    len = 0;</a>
<a name="ln1628">    type = 1;</a>
<a name="ln1629">    for ( i = 0; i &lt; resource_cnt; ++i )</a>
<a name="ln1630">    {</a>
<a name="ln1631">      error = FT_Stream_Seek( stream, (FT_ULong)offsets[i] );</a>
<a name="ln1632">      if ( error )</a>
<a name="ln1633">        goto Exit2;</a>
<a name="ln1634">      if ( FT_READ_ULONG( rlen ) )</a>
<a name="ln1635">        goto Exit2;</a>
<a name="ln1636"> </a>
<a name="ln1637">      /* FT2 allocator takes signed long buffer length,</a>
<a name="ln1638">       * too large fragment length causing overflow should be checked</a>
<a name="ln1639">       */</a>
<a name="ln1640">      if ( 0x7FFFFFFFUL &lt; rlen )</a>
<a name="ln1641">      {</a>
<a name="ln1642">        error = FT_THROW( Invalid_Offset );</a>
<a name="ln1643">        goto Exit2;</a>
<a name="ln1644">      }</a>
<a name="ln1645"> </a>
<a name="ln1646">      if ( FT_READ_USHORT( flags ) )</a>
<a name="ln1647">        goto Exit2;</a>
<a name="ln1648">      FT_TRACE3(( &quot;POST fragment[%d]: offsets=0x%08x, rlen=0x%08x, flags=0x%04x\n&quot;,</a>
<a name="ln1649">                   i, offsets[i], rlen, flags ));</a>
<a name="ln1650"> </a>
<a name="ln1651">      error = FT_ERR( Array_Too_Large );</a>
<a name="ln1652">      /* postpone the check of rlen longer than buffer until FT_Stream_Read() */</a>
<a name="ln1653">      if ( ( flags &gt;&gt; 8 ) == 0 )        /* Comment, should not be loaded */</a>
<a name="ln1654">      {</a>
<a name="ln1655">        FT_TRACE3(( &quot;    Skip POST fragment #%d because it is a comment\n&quot;, i ));</a>
<a name="ln1656">        continue;</a>
<a name="ln1657">      }</a>
<a name="ln1658"> </a>
<a name="ln1659">      /* the flags are part of the resource, so rlen &gt;= 2.  */</a>
<a name="ln1660">      /* but some fonts declare rlen = 0 for empty fragment */</a>
<a name="ln1661">      if ( rlen &gt; 2 )</a>
<a name="ln1662">        rlen -= 2;</a>
<a name="ln1663">      else</a>
<a name="ln1664">        rlen = 0;</a>
<a name="ln1665"> </a>
<a name="ln1666">      if ( ( flags &gt;&gt; 8 ) == type )</a>
<a name="ln1667">        len += rlen;</a>
<a name="ln1668">      else</a>
<a name="ln1669">      {</a>
<a name="ln1670">        FT_TRACE3(( &quot;    Write POST fragment #%d header (4-byte) to buffer&quot;</a>
<a name="ln1671">                    &quot; %p + 0x%08x\n&quot;, i, pfb_data, pfb_lenpos ));</a>
<a name="ln1672">        if ( pfb_lenpos + 3 &gt; pfb_len + 2 )</a>
<a name="ln1673">          goto Exit2;</a>
<a name="ln1674">        pfb_data[pfb_lenpos    ] = (FT_Byte)( len );</a>
<a name="ln1675">        pfb_data[pfb_lenpos + 1] = (FT_Byte)( len &gt;&gt; 8 );</a>
<a name="ln1676">        pfb_data[pfb_lenpos + 2] = (FT_Byte)( len &gt;&gt; 16 );</a>
<a name="ln1677">        pfb_data[pfb_lenpos + 3] = (FT_Byte)( len &gt;&gt; 24 );</a>
<a name="ln1678"> </a>
<a name="ln1679">        if ( ( flags &gt;&gt; 8 ) == 5 )      /* End of font mark */</a>
<a name="ln1680">          break;</a>
<a name="ln1681"> </a>
<a name="ln1682">        FT_TRACE3(( &quot;    Write POST fragment #%d header (6-byte) to buffer&quot;</a>
<a name="ln1683">                    &quot; %p + 0x%08x\n&quot;, i, pfb_data, pfb_pos ));</a>
<a name="ln1684">        if ( pfb_pos + 6 &gt; pfb_len + 2 )</a>
<a name="ln1685">          goto Exit2;</a>
<a name="ln1686">        pfb_data[pfb_pos++] = 0x80;</a>
<a name="ln1687"> </a>
<a name="ln1688">        type = flags &gt;&gt; 8;</a>
<a name="ln1689">        len = rlen;</a>
<a name="ln1690"> </a>
<a name="ln1691">        pfb_data[pfb_pos++] = (FT_Byte)type;</a>
<a name="ln1692">        pfb_lenpos          = pfb_pos;</a>
<a name="ln1693">        pfb_data[pfb_pos++] = 0;        /* 4-byte length, fill in later */</a>
<a name="ln1694">        pfb_data[pfb_pos++] = 0;</a>
<a name="ln1695">        pfb_data[pfb_pos++] = 0;</a>
<a name="ln1696">        pfb_data[pfb_pos++] = 0;</a>
<a name="ln1697">      }</a>
<a name="ln1698"> </a>
<a name="ln1699">      if ( pfb_pos &gt; pfb_len || pfb_pos + rlen &gt; pfb_len )</a>
<a name="ln1700">        goto Exit2;</a>
<a name="ln1701"> </a>
<a name="ln1702">      FT_TRACE3(( &quot;    Load POST fragment #%d (%d byte) to buffer&quot;</a>
<a name="ln1703">                  &quot; %p + 0x%08x\n&quot;, i, rlen, pfb_data, pfb_pos ));</a>
<a name="ln1704">      error = FT_Stream_Read( stream, (FT_Byte *)pfb_data + pfb_pos, rlen );</a>
<a name="ln1705">      if ( error )</a>
<a name="ln1706">        goto Exit2;</a>
<a name="ln1707">      pfb_pos += rlen;</a>
<a name="ln1708">    }</a>
<a name="ln1709"> </a>
<a name="ln1710">    error = FT_ERR( Array_Too_Large );</a>
<a name="ln1711">    if ( pfb_pos + 2 &gt; pfb_len + 2 )</a>
<a name="ln1712">      goto Exit2;</a>
<a name="ln1713">    pfb_data[pfb_pos++] = 0x80;</a>
<a name="ln1714">    pfb_data[pfb_pos++] = 3;</a>
<a name="ln1715"> </a>
<a name="ln1716">    if ( pfb_lenpos + 3 &gt; pfb_len + 2 )</a>
<a name="ln1717">      goto Exit2;</a>
<a name="ln1718">    pfb_data[pfb_lenpos    ] = (FT_Byte)( len );</a>
<a name="ln1719">    pfb_data[pfb_lenpos + 1] = (FT_Byte)( len &gt;&gt; 8 );</a>
<a name="ln1720">    pfb_data[pfb_lenpos + 2] = (FT_Byte)( len &gt;&gt; 16 );</a>
<a name="ln1721">    pfb_data[pfb_lenpos + 3] = (FT_Byte)( len &gt;&gt; 24 );</a>
<a name="ln1722"> </a>
<a name="ln1723">    return open_face_from_buffer( library,</a>
<a name="ln1724">                                  pfb_data,</a>
<a name="ln1725">                                  pfb_pos,</a>
<a name="ln1726">                                  face_index,</a>
<a name="ln1727">                                  &quot;type1&quot;,</a>
<a name="ln1728">                                  aface );</a>
<a name="ln1729"> </a>
<a name="ln1730">  Exit2:</a>
<a name="ln1731">    if ( error == FT_ERR( Array_Too_Large ) )</a>
<a name="ln1732">      FT_TRACE2(( &quot;  Abort due to too-short buffer to store&quot;</a>
<a name="ln1733">                  &quot; all POST fragments\n&quot; ));</a>
<a name="ln1734">    else if ( error == FT_ERR( Invalid_Offset ) )</a>
<a name="ln1735">      FT_TRACE2(( &quot;  Abort due to invalid offset in a POST fragment\n&quot; ));</a>
<a name="ln1736">    if ( error )</a>
<a name="ln1737">      error = FT_ERR( Cannot_Open_Resource );</a>
<a name="ln1738">    FT_FREE( pfb_data );</a>
<a name="ln1739"> </a>
<a name="ln1740">  Exit:</a>
<a name="ln1741">    return error;</a>
<a name="ln1742">  }</a>
<a name="ln1743"> </a>
<a name="ln1744"> </a>
<a name="ln1745">  /* The resource header says we've got resource_cnt `sfnt'      */</a>
<a name="ln1746">  /* (TrueType/OpenType) resources in this file.  Look through   */</a>
<a name="ln1747">  /* them for the one indicated by face_index, load it into mem, */</a>
<a name="ln1748">  /* pass it on to the truetype driver, and return it.           */</a>
<a name="ln1749">  /*                                                             */</a>
<a name="ln1750">  static FT_Error</a>
<a name="ln1751">  Mac_Read_sfnt_Resource( FT_Library  library,</a>
<a name="ln1752">                          FT_Stream   stream,</a>
<a name="ln1753">                          FT_Long    *offsets,</a>
<a name="ln1754">                          FT_Long     resource_cnt,</a>
<a name="ln1755">                          FT_Long     face_index,</a>
<a name="ln1756">                          FT_Face    *aface )</a>
<a name="ln1757">  {</a>
<a name="ln1758">    FT_Memory  memory = library-&gt;memory;</a>
<a name="ln1759">    FT_Byte*   sfnt_data = NULL;</a>
<a name="ln1760">    FT_Error   error;</a>
<a name="ln1761">    FT_ULong   flag_offset;</a>
<a name="ln1762">    FT_Long    rlen;</a>
<a name="ln1763">    int        is_cff;</a>
<a name="ln1764">    FT_Long    face_index_in_resource = 0;</a>
<a name="ln1765"> </a>
<a name="ln1766"> </a>
<a name="ln1767">    if ( face_index == -1 )</a>
<a name="ln1768">      face_index = 0;</a>
<a name="ln1769">    if ( face_index &gt;= resource_cnt )</a>
<a name="ln1770">      return FT_THROW( Cannot_Open_Resource );</a>
<a name="ln1771"> </a>
<a name="ln1772">    flag_offset = (FT_ULong)offsets[face_index];</a>
<a name="ln1773">    error = FT_Stream_Seek( stream, flag_offset );</a>
<a name="ln1774">    if ( error )</a>
<a name="ln1775">      goto Exit;</a>
<a name="ln1776"> </a>
<a name="ln1777">    if ( FT_READ_LONG( rlen ) )</a>
<a name="ln1778">      goto Exit;</a>
<a name="ln1779">    if ( rlen == -1 )</a>
<a name="ln1780">      return FT_THROW( Cannot_Open_Resource );</a>
<a name="ln1781">    if ( (FT_ULong)rlen &gt; FT_MAC_RFORK_MAX_LEN )</a>
<a name="ln1782">      return FT_THROW( Invalid_Offset );</a>
<a name="ln1783"> </a>
<a name="ln1784">    error = open_face_PS_from_sfnt_stream( library,</a>
<a name="ln1785">                                           stream,</a>
<a name="ln1786">                                           face_index,</a>
<a name="ln1787">                                           0, NULL,</a>
<a name="ln1788">                                           aface );</a>
<a name="ln1789">    if ( !error )</a>
<a name="ln1790">      goto Exit;</a>
<a name="ln1791"> </a>
<a name="ln1792">    /* rewind sfnt stream before open_face_PS_from_sfnt_stream() */</a>
<a name="ln1793">    if ( FT_Stream_Seek( stream, flag_offset + 4 ) )</a>
<a name="ln1794">      goto Exit;</a>
<a name="ln1795"> </a>
<a name="ln1796">    if ( FT_ALLOC( sfnt_data, rlen ) )</a>
<a name="ln1797">      return error;</a>
<a name="ln1798">    error = FT_Stream_Read( stream, (FT_Byte *)sfnt_data, (FT_ULong)rlen );</a>
<a name="ln1799">    if ( error ) {</a>
<a name="ln1800">      FT_FREE( sfnt_data );</a>
<a name="ln1801">      goto Exit;</a>
<a name="ln1802">    }</a>
<a name="ln1803"> </a>
<a name="ln1804">    is_cff = rlen &gt; 4 &amp;&amp; !ft_memcmp( sfnt_data, &quot;OTTO&quot;, 4 );</a>
<a name="ln1805">    error = open_face_from_buffer( library,</a>
<a name="ln1806">                                   sfnt_data,</a>
<a name="ln1807">                                   (FT_ULong)rlen,</a>
<a name="ln1808">                                   face_index_in_resource,</a>
<a name="ln1809">                                   is_cff ? &quot;cff&quot; : &quot;truetype&quot;,</a>
<a name="ln1810">                                   aface );</a>
<a name="ln1811"> </a>
<a name="ln1812">  Exit:</a>
<a name="ln1813">    return error;</a>
<a name="ln1814">  }</a>
<a name="ln1815"> </a>
<a name="ln1816"> </a>
<a name="ln1817">  /* Check for a valid resource fork header, or a valid dfont    */</a>
<a name="ln1818">  /* header.  In a resource fork the first 16 bytes are repeated */</a>
<a name="ln1819">  /* at the location specified by bytes 4-7.  In a dfont bytes   */</a>
<a name="ln1820">  /* 4-7 point to 16 bytes of zeroes instead.                    */</a>
<a name="ln1821">  /*                                                             */</a>
<a name="ln1822">  static FT_Error</a>
<a name="ln1823">  IsMacResource( FT_Library  library,</a>
<a name="ln1824">                 FT_Stream   stream,</a>
<a name="ln1825">                 FT_Long     resource_offset,</a>
<a name="ln1826">                 FT_Long     face_index,</a>
<a name="ln1827">                 FT_Face    *aface )</a>
<a name="ln1828">  {</a>
<a name="ln1829">    FT_Memory  memory = library-&gt;memory;</a>
<a name="ln1830">    FT_Error   error;</a>
<a name="ln1831">    FT_Long    map_offset, rdara_pos;</a>
<a name="ln1832">    FT_Long    *data_offsets;</a>
<a name="ln1833">    FT_Long    count;</a>
<a name="ln1834"> </a>
<a name="ln1835"> </a>
<a name="ln1836">    error = FT_Raccess_Get_HeaderInfo( library, stream, resource_offset,</a>
<a name="ln1837">                                       &amp;map_offset, &amp;rdara_pos );</a>
<a name="ln1838">    if ( error )</a>
<a name="ln1839">      return error;</a>
<a name="ln1840"> </a>
<a name="ln1841">    /* POST resources must be sorted to concatenate properly */</a>
<a name="ln1842">    error = FT_Raccess_Get_DataOffsets( library, stream,</a>
<a name="ln1843">                                        map_offset, rdara_pos,</a>
<a name="ln1844">                                        TTAG_POST, TRUE,</a>
<a name="ln1845">                                        &amp;data_offsets, &amp;count );</a>
<a name="ln1846">    if ( !error )</a>
<a name="ln1847">    {</a>
<a name="ln1848">      error = Mac_Read_POST_Resource( library, stream, data_offsets, count,</a>
<a name="ln1849">                                      face_index, aface );</a>
<a name="ln1850">      FT_FREE( data_offsets );</a>
<a name="ln1851">      /* POST exists in an LWFN providing a single face */</a>
<a name="ln1852">      if ( !error )</a>
<a name="ln1853">        (*aface)-&gt;num_faces = 1;</a>
<a name="ln1854">      return error;</a>
<a name="ln1855">    }</a>
<a name="ln1856"> </a>
<a name="ln1857">    /* sfnt resources should not be sorted to preserve the face order by</a>
<a name="ln1858">       QuickDraw API */</a>
<a name="ln1859">    error = FT_Raccess_Get_DataOffsets( library, stream,</a>
<a name="ln1860">                                        map_offset, rdara_pos,</a>
<a name="ln1861">                                        TTAG_sfnt, FALSE,</a>
<a name="ln1862">                                        &amp;data_offsets, &amp;count );</a>
<a name="ln1863">    if ( !error )</a>
<a name="ln1864">    {</a>
<a name="ln1865">      FT_Long  face_index_internal = face_index % count;</a>
<a name="ln1866"> </a>
<a name="ln1867"> </a>
<a name="ln1868">      error = Mac_Read_sfnt_Resource( library, stream, data_offsets, count,</a>
<a name="ln1869">                                      face_index_internal, aface );</a>
<a name="ln1870">      FT_FREE( data_offsets );</a>
<a name="ln1871">      if ( !error )</a>
<a name="ln1872">        (*aface)-&gt;num_faces = count;</a>
<a name="ln1873">    }</a>
<a name="ln1874"> </a>
<a name="ln1875">    return error;</a>
<a name="ln1876">  }</a>
<a name="ln1877"> </a>
<a name="ln1878"> </a>
<a name="ln1879">  /* Check for a valid macbinary header, and if we find one   */</a>
<a name="ln1880">  /* check that the (flattened) resource fork in it is valid. */</a>
<a name="ln1881">  /*                                                          */</a>
<a name="ln1882">  static FT_Error</a>
<a name="ln1883">  IsMacBinary( FT_Library  library,</a>
<a name="ln1884">               FT_Stream   stream,</a>
<a name="ln1885">               FT_Long     face_index,</a>
<a name="ln1886">               FT_Face    *aface )</a>
<a name="ln1887">  {</a>
<a name="ln1888">    unsigned char  header[128];</a>
<a name="ln1889">    FT_Error       error;</a>
<a name="ln1890">    FT_Long        dlen, offset;</a>
<a name="ln1891"> </a>
<a name="ln1892"> </a>
<a name="ln1893">    if ( NULL == stream )</a>
<a name="ln1894">      return FT_THROW( Invalid_Stream_Operation );</a>
<a name="ln1895"> </a>
<a name="ln1896">    error = FT_Stream_Seek( stream, 0 );</a>
<a name="ln1897">    if ( error )</a>
<a name="ln1898">      goto Exit;</a>
<a name="ln1899"> </a>
<a name="ln1900">    error = FT_Stream_Read( stream, (FT_Byte*)header, 128 );</a>
<a name="ln1901">    if ( error )</a>
<a name="ln1902">      goto Exit;</a>
<a name="ln1903"> </a>
<a name="ln1904">    if (            header[ 0] !=   0 ||</a>
<a name="ln1905">                    header[74] !=   0 ||</a>
<a name="ln1906">                    header[82] !=   0 ||</a>
<a name="ln1907">                    header[ 1] ==   0 ||</a>
<a name="ln1908">                    header[ 1] &gt;   33 ||</a>
<a name="ln1909">                    header[63] !=   0 ||</a>
<a name="ln1910">         header[2 + header[1]] !=   0 ||</a>
<a name="ln1911">                  header[0x53] &gt; 0x7F )</a>
<a name="ln1912">      return FT_THROW( Unknown_File_Format );</a>
<a name="ln1913"> </a>
<a name="ln1914">    dlen = ( header[0x53] &lt;&lt; 24 ) |</a>
<a name="ln1915">           ( header[0x54] &lt;&lt; 16 ) |</a>
<a name="ln1916">           ( header[0x55] &lt;&lt;  8 ) |</a>
<a name="ln1917">             header[0x56];</a>
<a name="ln1918">#if 0</a>
<a name="ln1919">    rlen = ( header[0x57] &lt;&lt; 24 ) |</a>
<a name="ln1920">           ( header[0x58] &lt;&lt; 16 ) |</a>
<a name="ln1921">           ( header[0x59] &lt;&lt;  8 ) |</a>
<a name="ln1922">             header[0x5A];</a>
<a name="ln1923">#endif /* 0 */</a>
<a name="ln1924">    offset = 128 + ( ( dlen + 127 ) &amp; ~127 );</a>
<a name="ln1925"> </a>
<a name="ln1926">    return IsMacResource( library, stream, offset, face_index, aface );</a>
<a name="ln1927"> </a>
<a name="ln1928">  Exit:</a>
<a name="ln1929">    return error;</a>
<a name="ln1930">  }</a>
<a name="ln1931"> </a>
<a name="ln1932"> </a>
<a name="ln1933">  static FT_Error</a>
<a name="ln1934">  load_face_in_embedded_rfork( FT_Library           library,</a>
<a name="ln1935">                               FT_Stream            stream,</a>
<a name="ln1936">                               FT_Long              face_index,</a>
<a name="ln1937">                               FT_Face             *aface,</a>
<a name="ln1938">                               const FT_Open_Args  *args )</a>
<a name="ln1939">  {</a>
<a name="ln1940"> </a>
<a name="ln1941">#undef  FT_COMPONENT</a>
<a name="ln1942">#define FT_COMPONENT  trace_raccess</a>
<a name="ln1943"> </a>
<a name="ln1944">    FT_Memory  memory = library-&gt;memory;</a>
<a name="ln1945">    FT_Error   error  = FT_ERR( Unknown_File_Format );</a>
<a name="ln1946">    FT_UInt    i;</a>
<a name="ln1947"> </a>
<a name="ln1948">    char *     file_names[FT_RACCESS_N_RULES];</a>
<a name="ln1949">    FT_Long    offsets[FT_RACCESS_N_RULES];</a>
<a name="ln1950">    FT_Error   errors[FT_RACCESS_N_RULES];</a>
<a name="ln1951">    FT_Bool    is_darwin_vfs, vfs_rfork_has_no_font = FALSE; /* not tested */</a>
<a name="ln1952"> </a>
<a name="ln1953">    FT_Open_Args  args2;</a>
<a name="ln1954">    FT_Stream     stream2 = NULL;</a>
<a name="ln1955"> </a>
<a name="ln1956"> </a>
<a name="ln1957">    FT_Raccess_Guess( library, stream,</a>
<a name="ln1958">                      args-&gt;pathname, file_names, offsets, errors );</a>
<a name="ln1959"> </a>
<a name="ln1960">    for ( i = 0; i &lt; FT_RACCESS_N_RULES; i++ )</a>
<a name="ln1961">    {</a>
<a name="ln1962">      is_darwin_vfs = ft_raccess_rule_by_darwin_vfs( library, i );</a>
<a name="ln1963">      if ( is_darwin_vfs &amp;&amp; vfs_rfork_has_no_font )</a>
<a name="ln1964">      {</a>
<a name="ln1965">        FT_TRACE3(( &quot;Skip rule %d: darwin vfs resource fork&quot;</a>
<a name="ln1966">                    &quot; is already checked and&quot;</a>
<a name="ln1967">                    &quot; no font is found\n&quot;, i ));</a>
<a name="ln1968">        continue;</a>
<a name="ln1969">      }</a>
<a name="ln1970"> </a>
<a name="ln1971">      if ( errors[i] )</a>
<a name="ln1972">      {</a>
<a name="ln1973">        FT_TRACE3(( &quot;Error[%d] has occurred in rule %d\n&quot;, errors[i], i ));</a>
<a name="ln1974">        continue;</a>
<a name="ln1975">      }</a>
<a name="ln1976"> </a>
<a name="ln1977">      args2.flags    = FT_OPEN_PATHNAME;</a>
<a name="ln1978">      args2.pathname = file_names[i] ? file_names[i] : args-&gt;pathname;</a>
<a name="ln1979"> </a>
<a name="ln1980">      FT_TRACE3(( &quot;Try rule %d: %s (offset=%d) ...&quot;,</a>
<a name="ln1981">                  i, args2.pathname, offsets[i] ));</a>
<a name="ln1982"> </a>
<a name="ln1983">      error = FT_Stream_New( library, &amp;args2, &amp;stream2 );</a>
<a name="ln1984">      if ( is_darwin_vfs &amp;&amp; FT_ERR_EQ( error, Cannot_Open_Stream ) )</a>
<a name="ln1985">        vfs_rfork_has_no_font = TRUE;</a>
<a name="ln1986"> </a>
<a name="ln1987">      if ( error )</a>
<a name="ln1988">      {</a>
<a name="ln1989">        FT_TRACE3(( &quot;failed\n&quot; ));</a>
<a name="ln1990">        continue;</a>
<a name="ln1991">      }</a>
<a name="ln1992"> </a>
<a name="ln1993">      error = IsMacResource( library, stream2, offsets[i],</a>
<a name="ln1994">                             face_index, aface );</a>
<a name="ln1995">      FT_Stream_Free( stream2, 0 );</a>
<a name="ln1996"> </a>
<a name="ln1997">      FT_TRACE3(( &quot;%s\n&quot;, error ? &quot;failed&quot;: &quot;successful&quot; ));</a>
<a name="ln1998"> </a>
<a name="ln1999">      if ( !error )</a>
<a name="ln2000">          break;</a>
<a name="ln2001">      else if ( is_darwin_vfs )</a>
<a name="ln2002">          vfs_rfork_has_no_font = TRUE;</a>
<a name="ln2003">    }</a>
<a name="ln2004"> </a>
<a name="ln2005">    for (i = 0; i &lt; FT_RACCESS_N_RULES; i++)</a>
<a name="ln2006">    {</a>
<a name="ln2007">      if ( file_names[i] )</a>
<a name="ln2008">        FT_FREE( file_names[i] );</a>
<a name="ln2009">    }</a>
<a name="ln2010"> </a>
<a name="ln2011">    /* Caller (load_mac_face) requires FT_Err_Unknown_File_Format. */</a>
<a name="ln2012">    if ( error )</a>
<a name="ln2013">      error = FT_ERR( Unknown_File_Format );</a>
<a name="ln2014"> </a>
<a name="ln2015">    return error;</a>
<a name="ln2016"> </a>
<a name="ln2017">#undef  FT_COMPONENT</a>
<a name="ln2018">#define FT_COMPONENT  trace_objs</a>
<a name="ln2019"> </a>
<a name="ln2020">  }</a>
<a name="ln2021"> </a>
<a name="ln2022"> </a>
<a name="ln2023">  /* Check for some macintosh formats without Carbon framework.    */</a>
<a name="ln2024">  /* Is this a macbinary file?  If so look at the resource fork.   */</a>
<a name="ln2025">  /* Is this a mac dfont file?                                     */</a>
<a name="ln2026">  /* Is this an old style resource fork? (in data)                 */</a>
<a name="ln2027">  /* Else call load_face_in_embedded_rfork to try extra rules      */</a>
<a name="ln2028">  /* (defined in `ftrfork.c').                                     */</a>
<a name="ln2029">  /*                                                               */</a>
<a name="ln2030">  static FT_Error</a>
<a name="ln2031">  load_mac_face( FT_Library           library,</a>
<a name="ln2032">                 FT_Stream            stream,</a>
<a name="ln2033">                 FT_Long              face_index,</a>
<a name="ln2034">                 FT_Face             *aface,</a>
<a name="ln2035">                 const FT_Open_Args  *args )</a>
<a name="ln2036">  {</a>
<a name="ln2037">    FT_Error error;</a>
<a name="ln2038">    FT_UNUSED( args );</a>
<a name="ln2039"> </a>
<a name="ln2040"> </a>
<a name="ln2041">    error = IsMacBinary( library, stream, face_index, aface );</a>
<a name="ln2042">    if ( FT_ERR_EQ( error, Unknown_File_Format ) )</a>
<a name="ln2043">    {</a>
<a name="ln2044"> </a>
<a name="ln2045">#undef  FT_COMPONENT</a>
<a name="ln2046">#define FT_COMPONENT  trace_raccess</a>
<a name="ln2047"> </a>
<a name="ln2048">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2049">      FT_TRACE3(( &quot;Try as dfont: &quot; ));</a>
<a name="ln2050">      if ( !( args-&gt;flags &amp; FT_OPEN_MEMORY ) )</a>
<a name="ln2051">        FT_TRACE3(( &quot;%s ...&quot;, args-&gt;pathname ));</a>
<a name="ln2052">#endif</a>
<a name="ln2053"> </a>
<a name="ln2054">      error = IsMacResource( library, stream, 0, face_index, aface );</a>
<a name="ln2055"> </a>
<a name="ln2056">      FT_TRACE3(( &quot;%s\n&quot;, error ? &quot;failed&quot; : &quot;successful&quot; ));</a>
<a name="ln2057"> </a>
<a name="ln2058">#undef  FT_COMPONENT</a>
<a name="ln2059">#define FT_COMPONENT  trace_objs</a>
<a name="ln2060"> </a>
<a name="ln2061">    }</a>
<a name="ln2062"> </a>
<a name="ln2063">    if ( ( FT_ERR_EQ( error, Unknown_File_Format )      ||</a>
<a name="ln2064">           FT_ERR_EQ( error, Invalid_Stream_Operation ) ) &amp;&amp;</a>
<a name="ln2065">         ( args-&gt;flags &amp; FT_OPEN_PATHNAME )               )</a>
<a name="ln2066">      error = load_face_in_embedded_rfork( library, stream,</a>
<a name="ln2067">                                           face_index, aface, args );</a>
<a name="ln2068">    return error;</a>
<a name="ln2069">  }</a>
<a name="ln2070">#endif</a>
<a name="ln2071"> </a>
<a name="ln2072">#endif  /* !FT_MACINTOSH &amp;&amp; FT_CONFIG_OPTION_MAC_FONTS */</a>
<a name="ln2073"> </a>
<a name="ln2074"> </a>
<a name="ln2075">  /* documentation is in freetype.h */</a>
<a name="ln2076"> </a>
<a name="ln2077">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2078">  FT_Open_Face( FT_Library           library,</a>
<a name="ln2079">                const FT_Open_Args*  args,</a>
<a name="ln2080">                FT_Long              face_index,</a>
<a name="ln2081">                FT_Face             *aface )</a>
<a name="ln2082">  {</a>
<a name="ln2083">    FT_Error     error;</a>
<a name="ln2084">    FT_Driver    driver = NULL;</a>
<a name="ln2085">    FT_Memory    memory = NULL;</a>
<a name="ln2086">    FT_Stream    stream = NULL;</a>
<a name="ln2087">    FT_Face      face   = NULL;</a>
<a name="ln2088">    FT_ListNode  node   = NULL;</a>
<a name="ln2089">    FT_Bool      external_stream;</a>
<a name="ln2090">    FT_Module*   cur;</a>
<a name="ln2091">    FT_Module*   limit;</a>
<a name="ln2092"> </a>
<a name="ln2093"> </a>
<a name="ln2094">    /* test for valid `library' delayed to `FT_Stream_New' */</a>
<a name="ln2095"> </a>
<a name="ln2096">    if ( ( !aface &amp;&amp; face_index &gt;= 0 ) || !args )</a>
<a name="ln2097">      return FT_THROW( Invalid_Argument );</a>
<a name="ln2098"> </a>
<a name="ln2099">    external_stream = FT_BOOL( ( args-&gt;flags &amp; FT_OPEN_STREAM ) &amp;&amp;</a>
<a name="ln2100">                               args-&gt;stream                     );</a>
<a name="ln2101"> </a>
<a name="ln2102">    /* create input stream */</a>
<a name="ln2103">    error = FT_Stream_New( library, args, &amp;stream );</a>
<a name="ln2104">    if ( error )</a>
<a name="ln2105">      goto Fail3;</a>
<a name="ln2106"> </a>
<a name="ln2107">    memory = library-&gt;memory;</a>
<a name="ln2108"> </a>
<a name="ln2109">    /* If the font driver is specified in the `args' structure, use */</a>
<a name="ln2110">    /* it.  Otherwise, we scan the list of registered drivers.      */</a>
<a name="ln2111">    if ( ( args-&gt;flags &amp; FT_OPEN_DRIVER ) &amp;&amp; args-&gt;driver )</a>
<a name="ln2112">    {</a>
<a name="ln2113">      driver = FT_DRIVER( args-&gt;driver );</a>
<a name="ln2114"> </a>
<a name="ln2115">      /* not all modules are drivers, so check... */</a>
<a name="ln2116">      if ( FT_MODULE_IS_DRIVER( driver ) )</a>
<a name="ln2117">      {</a>
<a name="ln2118">        FT_Int         num_params = 0;</a>
<a name="ln2119">        FT_Parameter*  params     = NULL;</a>
<a name="ln2120"> </a>
<a name="ln2121"> </a>
<a name="ln2122">        if ( args-&gt;flags &amp; FT_OPEN_PARAMS )</a>
<a name="ln2123">        {</a>
<a name="ln2124">          num_params = args-&gt;num_params;</a>
<a name="ln2125">          params     = args-&gt;params;</a>
<a name="ln2126">        }</a>
<a name="ln2127"> </a>
<a name="ln2128">        error = open_face( driver, &amp;stream, external_stream, face_index,</a>
<a name="ln2129">                           num_params, params, &amp;face );</a>
<a name="ln2130">        if ( !error )</a>
<a name="ln2131">          goto Success;</a>
<a name="ln2132">      }</a>
<a name="ln2133">      else</a>
<a name="ln2134">        error = FT_THROW( Invalid_Handle );</a>
<a name="ln2135"> </a>
<a name="ln2136">      FT_Stream_Free( stream, external_stream );</a>
<a name="ln2137">      goto Fail;</a>
<a name="ln2138">    }</a>
<a name="ln2139">    else</a>
<a name="ln2140">    {</a>
<a name="ln2141">      error = FT_ERR( Missing_Module );</a>
<a name="ln2142"> </a>
<a name="ln2143">      /* check each font driver for an appropriate format */</a>
<a name="ln2144">      cur   = library-&gt;modules;</a>
<a name="ln2145">      limit = cur + library-&gt;num_modules;</a>
<a name="ln2146"> </a>
<a name="ln2147">      for ( ; cur &lt; limit; cur++ )</a>
<a name="ln2148">      {</a>
<a name="ln2149">        /* not all modules are font drivers, so check... */</a>
<a name="ln2150">        if ( FT_MODULE_IS_DRIVER( cur[0] ) )</a>
<a name="ln2151">        {</a>
<a name="ln2152">          FT_Int         num_params = 0;</a>
<a name="ln2153">          FT_Parameter*  params     = NULL;</a>
<a name="ln2154"> </a>
<a name="ln2155"> </a>
<a name="ln2156">          driver = FT_DRIVER( cur[0] );</a>
<a name="ln2157"> </a>
<a name="ln2158">          if ( args-&gt;flags &amp; FT_OPEN_PARAMS )</a>
<a name="ln2159">          {</a>
<a name="ln2160">            num_params = args-&gt;num_params;</a>
<a name="ln2161">            params     = args-&gt;params;</a>
<a name="ln2162">          }</a>
<a name="ln2163"> </a>
<a name="ln2164">          error = open_face( driver, &amp;stream, external_stream, face_index,</a>
<a name="ln2165">                             num_params, params, &amp;face );</a>
<a name="ln2166">          if ( !error )</a>
<a name="ln2167">            goto Success;</a>
<a name="ln2168"> </a>
<a name="ln2169">#ifdef FT_CONFIG_OPTION_MAC_FONTS</a>
<a name="ln2170">          if ( ft_strcmp( cur[0]-&gt;clazz-&gt;module_name, &quot;truetype&quot; ) == 0 &amp;&amp;</a>
<a name="ln2171">               FT_ERR_EQ( error, Table_Missing )                        )</a>
<a name="ln2172">          {</a>
<a name="ln2173">            /* TrueType but essential tables are missing */</a>
<a name="ln2174">            if ( FT_Stream_Seek( stream, 0 ) )</a>
<a name="ln2175">              break;</a>
<a name="ln2176"> </a>
<a name="ln2177">            error = open_face_PS_from_sfnt_stream( library,</a>
<a name="ln2178">                                                   stream,</a>
<a name="ln2179">                                                   face_index,</a>
<a name="ln2180">                                                   num_params,</a>
<a name="ln2181">                                                   params,</a>
<a name="ln2182">                                                   aface );</a>
<a name="ln2183">            if ( !error )</a>
<a name="ln2184">            {</a>
<a name="ln2185">              FT_Stream_Free( stream, external_stream );</a>
<a name="ln2186">              return error;</a>
<a name="ln2187">            }</a>
<a name="ln2188">          }</a>
<a name="ln2189">#endif</a>
<a name="ln2190"> </a>
<a name="ln2191">          if ( FT_ERR_NEQ( error, Unknown_File_Format ) )</a>
<a name="ln2192">            goto Fail3;</a>
<a name="ln2193">        }</a>
<a name="ln2194">      }</a>
<a name="ln2195"> </a>
<a name="ln2196">    Fail3:</a>
<a name="ln2197">      /* If we are on the mac, and we get an                          */</a>
<a name="ln2198">      /* FT_Err_Invalid_Stream_Operation it may be because we have an */</a>
<a name="ln2199">      /* empty data fork, so we need to check the resource fork.      */</a>
<a name="ln2200">      if ( FT_ERR_NEQ( error, Cannot_Open_Stream )       &amp;&amp;</a>
<a name="ln2201">           FT_ERR_NEQ( error, Unknown_File_Format )      &amp;&amp;</a>
<a name="ln2202">           FT_ERR_NEQ( error, Invalid_Stream_Operation ) )</a>
<a name="ln2203">        goto Fail2;</a>
<a name="ln2204"> </a>
<a name="ln2205">#if !defined( FT_MACINTOSH ) &amp;&amp; defined( FT_CONFIG_OPTION_MAC_FONTS )</a>
<a name="ln2206">      error = load_mac_face( library, stream, face_index, aface, args );</a>
<a name="ln2207">      if ( !error )</a>
<a name="ln2208">      {</a>
<a name="ln2209">        /* We don't want to go to Success here.  We've already done that. */</a>
<a name="ln2210">        /* On the other hand, if we succeeded we still need to close this */</a>
<a name="ln2211">        /* stream (we opened a different stream which extracted the       */</a>
<a name="ln2212">        /* interesting information out of this stream here.  That stream  */</a>
<a name="ln2213">        /* will still be open and the face will point to it).             */</a>
<a name="ln2214">        FT_Stream_Free( stream, external_stream );</a>
<a name="ln2215">        return error;</a>
<a name="ln2216">      }</a>
<a name="ln2217"> </a>
<a name="ln2218">      if ( FT_ERR_NEQ( error, Unknown_File_Format ) )</a>
<a name="ln2219">        goto Fail2;</a>
<a name="ln2220">#endif  /* !FT_MACINTOSH &amp;&amp; FT_CONFIG_OPTION_MAC_FONTS */</a>
<a name="ln2221"> </a>
<a name="ln2222">      /* no driver is able to handle this format */</a>
<a name="ln2223">      error = FT_THROW( Unknown_File_Format );</a>
<a name="ln2224"> </a>
<a name="ln2225">  Fail2:</a>
<a name="ln2226">      FT_Stream_Free( stream, external_stream );</a>
<a name="ln2227">      goto Fail;</a>
<a name="ln2228">    }</a>
<a name="ln2229"> </a>
<a name="ln2230">  Success:</a>
<a name="ln2231">    FT_TRACE4(( &quot;FT_Open_Face: New face object, adding to list\n&quot; ));</a>
<a name="ln2232"> </a>
<a name="ln2233">    /* add the face object to its driver's list */</a>
<a name="ln2234">    if ( FT_NEW( node ) )</a>
<a name="ln2235">      goto Fail;</a>
<a name="ln2236"> </a>
<a name="ln2237">    node-&gt;data = face;</a>
<a name="ln2238">    /* don't assume driver is the same as face-&gt;driver, so use */</a>
<a name="ln2239">    /* face-&gt;driver instead.                                   */</a>
<a name="ln2240">    FT_List_Add( &amp;face-&gt;driver-&gt;faces_list, node );</a>
<a name="ln2241"> </a>
<a name="ln2242">    /* now allocate a glyph slot object for the face */</a>
<a name="ln2243">    FT_TRACE4(( &quot;FT_Open_Face: Creating glyph slot\n&quot; ));</a>
<a name="ln2244"> </a>
<a name="ln2245">    if ( face_index &gt;= 0 )</a>
<a name="ln2246">    {</a>
<a name="ln2247">      error = FT_New_GlyphSlot( face, NULL );</a>
<a name="ln2248">      if ( error )</a>
<a name="ln2249">        goto Fail;</a>
<a name="ln2250"> </a>
<a name="ln2251">      /* finally, allocate a size object for the face */</a>
<a name="ln2252">      {</a>
<a name="ln2253">        FT_Size  size;</a>
<a name="ln2254"> </a>
<a name="ln2255"> </a>
<a name="ln2256">        FT_TRACE4(( &quot;FT_Open_Face: Creating size object\n&quot; ));</a>
<a name="ln2257"> </a>
<a name="ln2258">        error = FT_New_Size( face, &amp;size );</a>
<a name="ln2259">        if ( error )</a>
<a name="ln2260">          goto Fail;</a>
<a name="ln2261"> </a>
<a name="ln2262">        face-&gt;size = size;</a>
<a name="ln2263">      }</a>
<a name="ln2264">    }</a>
<a name="ln2265"> </a>
<a name="ln2266">    /* some checks */</a>
<a name="ln2267"> </a>
<a name="ln2268">    if ( FT_IS_SCALABLE( face ) )</a>
<a name="ln2269">    {</a>
<a name="ln2270">      if ( face-&gt;height &lt; 0 )</a>
<a name="ln2271">        face-&gt;height = (FT_Short)-face-&gt;height;</a>
<a name="ln2272"> </a>
<a name="ln2273">      if ( !FT_HAS_VERTICAL( face ) )</a>
<a name="ln2274">        face-&gt;max_advance_height = (FT_Short)face-&gt;height;</a>
<a name="ln2275">    }</a>
<a name="ln2276"> </a>
<a name="ln2277">    if ( FT_HAS_FIXED_SIZES( face ) )</a>
<a name="ln2278">    {</a>
<a name="ln2279">      FT_Int  i;</a>
<a name="ln2280"> </a>
<a name="ln2281"> </a>
<a name="ln2282">      for ( i = 0; i &lt; face-&gt;num_fixed_sizes; i++ )</a>
<a name="ln2283">      {</a>
<a name="ln2284">        FT_Bitmap_Size*  bsize = face-&gt;available_sizes + i;</a>
<a name="ln2285"> </a>
<a name="ln2286"> </a>
<a name="ln2287">        if ( bsize-&gt;height &lt; 0 )</a>
<a name="ln2288">          bsize-&gt;height = (FT_Short)-bsize-&gt;height;</a>
<a name="ln2289">        if ( bsize-&gt;x_ppem &lt; 0 )</a>
<a name="ln2290">          bsize-&gt;x_ppem = (FT_Short)-bsize-&gt;x_ppem;</a>
<a name="ln2291">        if ( bsize-&gt;y_ppem &lt; 0 )</a>
<a name="ln2292">          bsize-&gt;y_ppem = -bsize-&gt;y_ppem;</a>
<a name="ln2293">      }</a>
<a name="ln2294">    }</a>
<a name="ln2295"> </a>
<a name="ln2296">    /* initialize internal face data */</a>
<a name="ln2297">    {</a>
<a name="ln2298">      FT_Face_Internal  internal = face-&gt;internal;</a>
<a name="ln2299"> </a>
<a name="ln2300"> </a>
<a name="ln2301">      internal-&gt;transform_matrix.xx = 0x10000L;</a>
<a name="ln2302">      internal-&gt;transform_matrix.xy = 0;</a>
<a name="ln2303">      internal-&gt;transform_matrix.yx = 0;</a>
<a name="ln2304">      internal-&gt;transform_matrix.yy = 0x10000L;</a>
<a name="ln2305"> </a>
<a name="ln2306">      internal-&gt;transform_delta.x = 0;</a>
<a name="ln2307">      internal-&gt;transform_delta.y = 0;</a>
<a name="ln2308"> </a>
<a name="ln2309">      internal-&gt;refcount = 1;</a>
<a name="ln2310">    }</a>
<a name="ln2311"> </a>
<a name="ln2312">    if ( aface )</a>
<a name="ln2313">      *aface = face;</a>
<a name="ln2314">    else</a>
<a name="ln2315">      FT_Done_Face( face );</a>
<a name="ln2316"> </a>
<a name="ln2317">    goto Exit;</a>
<a name="ln2318"> </a>
<a name="ln2319">  Fail:</a>
<a name="ln2320">    if ( node )</a>
<a name="ln2321">      FT_Done_Face( face );    /* face must be in the driver's list */</a>
<a name="ln2322">    else if ( face )</a>
<a name="ln2323">      destroy_face( memory, face, driver );</a>
<a name="ln2324"> </a>
<a name="ln2325">  Exit:</a>
<a name="ln2326">    FT_TRACE4(( &quot;FT_Open_Face: Return %d\n&quot;, error ));</a>
<a name="ln2327"> </a>
<a name="ln2328">    return error;</a>
<a name="ln2329">  }</a>
<a name="ln2330"> </a>
<a name="ln2331"> </a>
<a name="ln2332">  /* documentation is in freetype.h */</a>
<a name="ln2333"> </a>
<a name="ln2334">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2335">  FT_Attach_File( FT_Face      face,</a>
<a name="ln2336">                  const char*  filepathname )</a>
<a name="ln2337">  {</a>
<a name="ln2338">    FT_Open_Args  open;</a>
<a name="ln2339"> </a>
<a name="ln2340"> </a>
<a name="ln2341">    /* test for valid `face' delayed to `FT_Attach_Stream' */</a>
<a name="ln2342"> </a>
<a name="ln2343">    if ( !filepathname )</a>
<a name="ln2344">      return FT_THROW( Invalid_Argument );</a>
<a name="ln2345"> </a>
<a name="ln2346">    open.stream   = NULL;</a>
<a name="ln2347">    open.flags    = FT_OPEN_PATHNAME;</a>
<a name="ln2348">    open.pathname = (char*)filepathname;</a>
<a name="ln2349"> </a>
<a name="ln2350">    return FT_Attach_Stream( face, &amp;open );</a>
<a name="ln2351">  }</a>
<a name="ln2352"> </a>
<a name="ln2353"> </a>
<a name="ln2354">  /* documentation is in freetype.h */</a>
<a name="ln2355"> </a>
<a name="ln2356">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2357">  FT_Attach_Stream( FT_Face        face,</a>
<a name="ln2358">                    FT_Open_Args*  parameters )</a>
<a name="ln2359">  {</a>
<a name="ln2360">    FT_Stream  stream;</a>
<a name="ln2361">    FT_Error   error;</a>
<a name="ln2362">    FT_Driver  driver;</a>
<a name="ln2363"> </a>
<a name="ln2364">    FT_Driver_Class  clazz;</a>
<a name="ln2365"> </a>
<a name="ln2366"> </a>
<a name="ln2367">    /* test for valid `parameters' delayed to `FT_Stream_New' */</a>
<a name="ln2368"> </a>
<a name="ln2369">    if ( !face )</a>
<a name="ln2370">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln2371"> </a>
<a name="ln2372">    driver = face-&gt;driver;</a>
<a name="ln2373">    if ( !driver )</a>
<a name="ln2374">      return FT_THROW( Invalid_Driver_Handle );</a>
<a name="ln2375"> </a>
<a name="ln2376">    error = FT_Stream_New( driver-&gt;root.library, parameters, &amp;stream );</a>
<a name="ln2377">    if ( error )</a>
<a name="ln2378">      goto Exit;</a>
<a name="ln2379"> </a>
<a name="ln2380">    /* we implement FT_Attach_Stream in each driver through the */</a>
<a name="ln2381">    /* `attach_file' interface                                  */</a>
<a name="ln2382"> </a>
<a name="ln2383">    error = FT_ERR( Unimplemented_Feature );</a>
<a name="ln2384">    clazz = driver-&gt;clazz;</a>
<a name="ln2385">    if ( clazz-&gt;attach_file )</a>
<a name="ln2386">      error = clazz-&gt;attach_file( face, stream );</a>
<a name="ln2387"> </a>
<a name="ln2388">    /* close the attached stream */</a>
<a name="ln2389">    FT_Stream_Free( stream,</a>
<a name="ln2390">                    (FT_Bool)( parameters-&gt;stream &amp;&amp;</a>
<a name="ln2391">                               ( parameters-&gt;flags &amp; FT_OPEN_STREAM ) ) );</a>
<a name="ln2392"> </a>
<a name="ln2393">  Exit:</a>
<a name="ln2394">    return error;</a>
<a name="ln2395">  }</a>
<a name="ln2396"> </a>
<a name="ln2397"> </a>
<a name="ln2398">  /* documentation is in freetype.h */</a>
<a name="ln2399"> </a>
<a name="ln2400">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2401">  FT_Reference_Face( FT_Face  face )</a>
<a name="ln2402">  {</a>
<a name="ln2403">    if ( !face )</a>
<a name="ln2404">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln2405"> </a>
<a name="ln2406">    face-&gt;internal-&gt;refcount++;</a>
<a name="ln2407"> </a>
<a name="ln2408">    return FT_Err_Ok;</a>
<a name="ln2409">  }</a>
<a name="ln2410"> </a>
<a name="ln2411"> </a>
<a name="ln2412">  /* documentation is in freetype.h */</a>
<a name="ln2413"> </a>
<a name="ln2414">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2415">  FT_Done_Face( FT_Face  face )</a>
<a name="ln2416">  {</a>
<a name="ln2417">    FT_Error     error;</a>
<a name="ln2418">    FT_Driver    driver;</a>
<a name="ln2419">    FT_Memory    memory;</a>
<a name="ln2420">    FT_ListNode  node;</a>
<a name="ln2421"> </a>
<a name="ln2422"> </a>
<a name="ln2423">    error = FT_ERR( Invalid_Face_Handle );</a>
<a name="ln2424">    if ( face &amp;&amp; face-&gt;driver )</a>
<a name="ln2425">    {</a>
<a name="ln2426">      face-&gt;internal-&gt;refcount--;</a>
<a name="ln2427">      if ( face-&gt;internal-&gt;refcount &gt; 0 )</a>
<a name="ln2428">        error = FT_Err_Ok;</a>
<a name="ln2429">      else</a>
<a name="ln2430">      {</a>
<a name="ln2431">        driver = face-&gt;driver;</a>
<a name="ln2432">        memory = driver-&gt;root.memory;</a>
<a name="ln2433"> </a>
<a name="ln2434">        /* find face in driver's list */</a>
<a name="ln2435">        node = FT_List_Find( &amp;driver-&gt;faces_list, face );</a>
<a name="ln2436">        if ( node )</a>
<a name="ln2437">        {</a>
<a name="ln2438">          /* remove face object from the driver's list */</a>
<a name="ln2439">          FT_List_Remove( &amp;driver-&gt;faces_list, node );</a>
<a name="ln2440">          FT_FREE( node );</a>
<a name="ln2441"> </a>
<a name="ln2442">          /* now destroy the object proper */</a>
<a name="ln2443">          destroy_face( memory, face, driver );</a>
<a name="ln2444">          error = FT_Err_Ok;</a>
<a name="ln2445">        }</a>
<a name="ln2446">      }</a>
<a name="ln2447">    }</a>
<a name="ln2448"> </a>
<a name="ln2449">    return error;</a>
<a name="ln2450">  }</a>
<a name="ln2451"> </a>
<a name="ln2452"> </a>
<a name="ln2453">  /* documentation is in ftobjs.h */</a>
<a name="ln2454"> </a>
<a name="ln2455">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2456">  FT_New_Size( FT_Face   face,</a>
<a name="ln2457">               FT_Size  *asize )</a>
<a name="ln2458">  {</a>
<a name="ln2459">    FT_Error         error;</a>
<a name="ln2460">    FT_Memory        memory;</a>
<a name="ln2461">    FT_Driver        driver;</a>
<a name="ln2462">    FT_Driver_Class  clazz;</a>
<a name="ln2463"> </a>
<a name="ln2464">    FT_Size          size = NULL;</a>
<a name="ln2465">    FT_ListNode      node = NULL;</a>
<a name="ln2466"> </a>
<a name="ln2467"> </a>
<a name="ln2468">    if ( !face )</a>
<a name="ln2469">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln2470"> </a>
<a name="ln2471">    if ( !asize )</a>
<a name="ln2472">      return FT_THROW( Invalid_Argument );</a>
<a name="ln2473"> </a>
<a name="ln2474">    if ( !face-&gt;driver )</a>
<a name="ln2475">      return FT_THROW( Invalid_Driver_Handle );</a>
<a name="ln2476"> </a>
<a name="ln2477">    *asize = NULL;</a>
<a name="ln2478"> </a>
<a name="ln2479">    driver = face-&gt;driver;</a>
<a name="ln2480">    clazz  = driver-&gt;clazz;</a>
<a name="ln2481">    memory = face-&gt;memory;</a>
<a name="ln2482"> </a>
<a name="ln2483">    /* Allocate new size object and perform basic initialisation */</a>
<a name="ln2484">    if ( FT_ALLOC( size, clazz-&gt;size_object_size ) || FT_NEW( node ) )</a>
<a name="ln2485">      goto Exit;</a>
<a name="ln2486"> </a>
<a name="ln2487">    size-&gt;face = face;</a>
<a name="ln2488"> </a>
<a name="ln2489">    /* for now, do not use any internal fields in size objects */</a>
<a name="ln2490">    size-&gt;internal = NULL;</a>
<a name="ln2491"> </a>
<a name="ln2492">    if ( clazz-&gt;init_size )</a>
<a name="ln2493">      error = clazz-&gt;init_size( size );</a>
<a name="ln2494"> </a>
<a name="ln2495">    /* in case of success, add to the face's list */</a>
<a name="ln2496">    if ( !error )</a>
<a name="ln2497">    {</a>
<a name="ln2498">      *asize     = size;</a>
<a name="ln2499">      node-&gt;data = size;</a>
<a name="ln2500">      FT_List_Add( &amp;face-&gt;sizes_list, node );</a>
<a name="ln2501">    }</a>
<a name="ln2502"> </a>
<a name="ln2503">  Exit:</a>
<a name="ln2504">    if ( error )</a>
<a name="ln2505">    {</a>
<a name="ln2506">      FT_FREE( node );</a>
<a name="ln2507">      FT_FREE( size );</a>
<a name="ln2508">    }</a>
<a name="ln2509"> </a>
<a name="ln2510">    return error;</a>
<a name="ln2511">  }</a>
<a name="ln2512"> </a>
<a name="ln2513"> </a>
<a name="ln2514">  /* documentation is in ftobjs.h */</a>
<a name="ln2515"> </a>
<a name="ln2516">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2517">  FT_Done_Size( FT_Size  size )</a>
<a name="ln2518">  {</a>
<a name="ln2519">    FT_Error     error;</a>
<a name="ln2520">    FT_Driver    driver;</a>
<a name="ln2521">    FT_Memory    memory;</a>
<a name="ln2522">    FT_Face      face;</a>
<a name="ln2523">    FT_ListNode  node;</a>
<a name="ln2524"> </a>
<a name="ln2525"> </a>
<a name="ln2526">    if ( !size )</a>
<a name="ln2527">      return FT_THROW( Invalid_Size_Handle );</a>
<a name="ln2528"> </a>
<a name="ln2529">    face = size-&gt;face;</a>
<a name="ln2530">    if ( !face )</a>
<a name="ln2531">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln2532"> </a>
<a name="ln2533">    driver = face-&gt;driver;</a>
<a name="ln2534">    if ( !driver )</a>
<a name="ln2535">      return FT_THROW( Invalid_Driver_Handle );</a>
<a name="ln2536"> </a>
<a name="ln2537">    memory = driver-&gt;root.memory;</a>
<a name="ln2538"> </a>
<a name="ln2539">    error = FT_Err_Ok;</a>
<a name="ln2540">    node  = FT_List_Find( &amp;face-&gt;sizes_list, size );</a>
<a name="ln2541">    if ( node )</a>
<a name="ln2542">    {</a>
<a name="ln2543">      FT_List_Remove( &amp;face-&gt;sizes_list, node );</a>
<a name="ln2544">      FT_FREE( node );</a>
<a name="ln2545"> </a>
<a name="ln2546">      if ( face-&gt;size == size )</a>
<a name="ln2547">      {</a>
<a name="ln2548">        face-&gt;size = NULL;</a>
<a name="ln2549">        if ( face-&gt;sizes_list.head )</a>
<a name="ln2550">          face-&gt;size = (FT_Size)(face-&gt;sizes_list.head-&gt;data);</a>
<a name="ln2551">      }</a>
<a name="ln2552"> </a>
<a name="ln2553">      destroy_size( memory, size, driver );</a>
<a name="ln2554">    }</a>
<a name="ln2555">    else</a>
<a name="ln2556">      error = FT_THROW( Invalid_Size_Handle );</a>
<a name="ln2557"> </a>
<a name="ln2558">    return error;</a>
<a name="ln2559">  }</a>
<a name="ln2560"> </a>
<a name="ln2561"> </a>
<a name="ln2562">  /* documentation is in ftobjs.h */</a>
<a name="ln2563"> </a>
<a name="ln2564">  FT_BASE_DEF( FT_Error )</a>
<a name="ln2565">  FT_Match_Size( FT_Face          face,</a>
<a name="ln2566">                 FT_Size_Request  req,</a>
<a name="ln2567">                 FT_Bool          ignore_width,</a>
<a name="ln2568">                 FT_ULong*        size_index )</a>
<a name="ln2569">  {</a>
<a name="ln2570">    FT_Int   i;</a>
<a name="ln2571">    FT_Long  w, h;</a>
<a name="ln2572"> </a>
<a name="ln2573"> </a>
<a name="ln2574">    if ( !FT_HAS_FIXED_SIZES( face ) )</a>
<a name="ln2575">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln2576"> </a>
<a name="ln2577">    /* FT_Bitmap_Size doesn't provide enough info... */</a>
<a name="ln2578">    if ( req-&gt;type != FT_SIZE_REQUEST_TYPE_NOMINAL )</a>
<a name="ln2579">      return FT_THROW( Unimplemented_Feature );</a>
<a name="ln2580"> </a>
<a name="ln2581">    w = FT_REQUEST_WIDTH ( req );</a>
<a name="ln2582">    h = FT_REQUEST_HEIGHT( req );</a>
<a name="ln2583"> </a>
<a name="ln2584">    if ( req-&gt;width &amp;&amp; !req-&gt;height )</a>
<a name="ln2585">      h = w;</a>
<a name="ln2586">    else if ( !req-&gt;width &amp;&amp; req-&gt;height )</a>
<a name="ln2587">      w = h;</a>
<a name="ln2588"> </a>
<a name="ln2589">    w = FT_PIX_ROUND( w );</a>
<a name="ln2590">    h = FT_PIX_ROUND( h );</a>
<a name="ln2591"> </a>
<a name="ln2592">    for ( i = 0; i &lt; face-&gt;num_fixed_sizes; i++ )</a>
<a name="ln2593">    {</a>
<a name="ln2594">      FT_Bitmap_Size*  bsize = face-&gt;available_sizes + i;</a>
<a name="ln2595"> </a>
<a name="ln2596"> </a>
<a name="ln2597">      if ( h != FT_PIX_ROUND( bsize-&gt;y_ppem ) )</a>
<a name="ln2598">        continue;</a>
<a name="ln2599"> </a>
<a name="ln2600">      if ( w == FT_PIX_ROUND( bsize-&gt;x_ppem ) || ignore_width )</a>
<a name="ln2601">      {</a>
<a name="ln2602">        FT_TRACE3(( &quot;FT_Match_Size: bitmap strike %d matches\n&quot;, i ));</a>
<a name="ln2603"> </a>
<a name="ln2604">        if ( size_index )</a>
<a name="ln2605">          *size_index = (FT_ULong)i;</a>
<a name="ln2606"> </a>
<a name="ln2607">        return FT_Err_Ok;</a>
<a name="ln2608">      }</a>
<a name="ln2609">    }</a>
<a name="ln2610"> </a>
<a name="ln2611">    return FT_THROW( Invalid_Pixel_Size );</a>
<a name="ln2612">  }</a>
<a name="ln2613"> </a>
<a name="ln2614"> </a>
<a name="ln2615">  /* documentation is in ftobjs.h */</a>
<a name="ln2616"> </a>
<a name="ln2617">  FT_BASE_DEF( void )</a>
<a name="ln2618">  ft_synthesize_vertical_metrics( FT_Glyph_Metrics*  metrics,</a>
<a name="ln2619">                                  FT_Pos             advance )</a>
<a name="ln2620">  {</a>
<a name="ln2621">    FT_Pos  height = metrics-&gt;height;</a>
<a name="ln2622"> </a>
<a name="ln2623"> </a>
<a name="ln2624">    /* compensate for glyph with bbox above/below the baseline */</a>
<a name="ln2625">    if ( metrics-&gt;horiBearingY &lt; 0 )</a>
<a name="ln2626">    {</a>
<a name="ln2627">      if ( height &lt; metrics-&gt;horiBearingY )</a>
<a name="ln2628">        height = metrics-&gt;horiBearingY;</a>
<a name="ln2629">    }</a>
<a name="ln2630">    else if ( metrics-&gt;horiBearingY &gt; 0 )</a>
<a name="ln2631">      height -= metrics-&gt;horiBearingY;</a>
<a name="ln2632"> </a>
<a name="ln2633">    /* the factor 1.2 is a heuristical value */</a>
<a name="ln2634">    if ( !advance )</a>
<a name="ln2635">      advance = height * 12 / 10;</a>
<a name="ln2636"> </a>
<a name="ln2637">    metrics-&gt;vertBearingX = metrics-&gt;horiBearingX - metrics-&gt;horiAdvance / 2;</a>
<a name="ln2638">    metrics-&gt;vertBearingY = ( advance - height ) / 2;</a>
<a name="ln2639">    metrics-&gt;vertAdvance  = advance;</a>
<a name="ln2640">  }</a>
<a name="ln2641"> </a>
<a name="ln2642"> </a>
<a name="ln2643">  static void</a>
<a name="ln2644">  ft_recompute_scaled_metrics( FT_Face           face,</a>
<a name="ln2645">                               FT_Size_Metrics*  metrics )</a>
<a name="ln2646">  {</a>
<a name="ln2647">    /* Compute root ascender, descender, test height, and max_advance */</a>
<a name="ln2648"> </a>
<a name="ln2649">#ifdef GRID_FIT_METRICS</a>
<a name="ln2650">    metrics-&gt;ascender    = FT_PIX_CEIL( FT_MulFix( face-&gt;ascender,</a>
<a name="ln2651">                                                   metrics-&gt;y_scale ) );</a>
<a name="ln2652"> </a>
<a name="ln2653">    metrics-&gt;descender   = FT_PIX_FLOOR( FT_MulFix( face-&gt;descender,</a>
<a name="ln2654">                                                    metrics-&gt;y_scale ) );</a>
<a name="ln2655"> </a>
<a name="ln2656">    metrics-&gt;height      = FT_PIX_ROUND( FT_MulFix( face-&gt;height,</a>
<a name="ln2657">                                                    metrics-&gt;y_scale ) );</a>
<a name="ln2658"> </a>
<a name="ln2659">    metrics-&gt;max_advance = FT_PIX_ROUND( FT_MulFix( face-&gt;max_advance_width,</a>
<a name="ln2660">                                                    metrics-&gt;x_scale ) );</a>
<a name="ln2661">#else /* !GRID_FIT_METRICS */</a>
<a name="ln2662">    metrics-&gt;ascender    = FT_MulFix( face-&gt;ascender,</a>
<a name="ln2663">                                      metrics-&gt;y_scale );</a>
<a name="ln2664"> </a>
<a name="ln2665">    metrics-&gt;descender   = FT_MulFix( face-&gt;descender,</a>
<a name="ln2666">                                      metrics-&gt;y_scale );</a>
<a name="ln2667"> </a>
<a name="ln2668">    metrics-&gt;height      = FT_MulFix( face-&gt;height,</a>
<a name="ln2669">                                      metrics-&gt;y_scale );</a>
<a name="ln2670"> </a>
<a name="ln2671">    metrics-&gt;max_advance = FT_MulFix( face-&gt;max_advance_width,</a>
<a name="ln2672">                                      metrics-&gt;x_scale );</a>
<a name="ln2673">#endif /* !GRID_FIT_METRICS */</a>
<a name="ln2674">  }</a>
<a name="ln2675"> </a>
<a name="ln2676"> </a>
<a name="ln2677">  FT_BASE_DEF( void )</a>
<a name="ln2678">  FT_Select_Metrics( FT_Face   face,</a>
<a name="ln2679">                     FT_ULong  strike_index )</a>
<a name="ln2680">  {</a>
<a name="ln2681">    FT_Size_Metrics*  metrics;</a>
<a name="ln2682">    FT_Bitmap_Size*   bsize;</a>
<a name="ln2683"> </a>
<a name="ln2684"> </a>
<a name="ln2685">    metrics = &amp;face-&gt;size-&gt;metrics;</a>
<a name="ln2686">    bsize   = face-&gt;available_sizes + strike_index;</a>
<a name="ln2687"> </a>
<a name="ln2688">    metrics-&gt;x_ppem = (FT_UShort)( ( bsize-&gt;x_ppem + 32 ) &gt;&gt; 6 );</a>
<a name="ln2689">    metrics-&gt;y_ppem = (FT_UShort)( ( bsize-&gt;y_ppem + 32 ) &gt;&gt; 6 );</a>
<a name="ln2690"> </a>
<a name="ln2691">    if ( FT_IS_SCALABLE( face ) )</a>
<a name="ln2692">    {</a>
<a name="ln2693">      metrics-&gt;x_scale = FT_DivFix( bsize-&gt;x_ppem,</a>
<a name="ln2694">                                    face-&gt;units_per_EM );</a>
<a name="ln2695">      metrics-&gt;y_scale = FT_DivFix( bsize-&gt;y_ppem,</a>
<a name="ln2696">                                    face-&gt;units_per_EM );</a>
<a name="ln2697"> </a>
<a name="ln2698">      ft_recompute_scaled_metrics( face, metrics );</a>
<a name="ln2699">    }</a>
<a name="ln2700">    else</a>
<a name="ln2701">    {</a>
<a name="ln2702">      metrics-&gt;x_scale     = 1L &lt;&lt; 16;</a>
<a name="ln2703">      metrics-&gt;y_scale     = 1L &lt;&lt; 16;</a>
<a name="ln2704">      metrics-&gt;ascender    = bsize-&gt;y_ppem;</a>
<a name="ln2705">      metrics-&gt;descender   = 0;</a>
<a name="ln2706">      metrics-&gt;height      = bsize-&gt;height &lt;&lt; 6;</a>
<a name="ln2707">      metrics-&gt;max_advance = bsize-&gt;x_ppem;</a>
<a name="ln2708">    }</a>
<a name="ln2709"> </a>
<a name="ln2710">    FT_TRACE5(( &quot;FT_Select_Metrics:\n&quot; ));</a>
<a name="ln2711">    FT_TRACE5(( &quot;  x scale: %d (%f)\n&quot;,</a>
<a name="ln2712">                metrics-&gt;x_scale, metrics-&gt;x_scale / 65536.0 ));</a>
<a name="ln2713">    FT_TRACE5(( &quot;  y scale: %d (%f)\n&quot;,</a>
<a name="ln2714">                metrics-&gt;y_scale, metrics-&gt;y_scale / 65536.0 ));</a>
<a name="ln2715">    FT_TRACE5(( &quot;  ascender: %f\n&quot;,    metrics-&gt;ascender / 64.0 ));</a>
<a name="ln2716">    FT_TRACE5(( &quot;  descender: %f\n&quot;,   metrics-&gt;descender / 64.0 ));</a>
<a name="ln2717">    FT_TRACE5(( &quot;  height: %f\n&quot;,      metrics-&gt;height / 64.0 ));</a>
<a name="ln2718">    FT_TRACE5(( &quot;  max advance: %f\n&quot;, metrics-&gt;max_advance / 64.0 ));</a>
<a name="ln2719">    FT_TRACE5(( &quot;  x ppem: %d\n&quot;,      metrics-&gt;x_ppem ));</a>
<a name="ln2720">    FT_TRACE5(( &quot;  y ppem: %d\n&quot;,      metrics-&gt;y_ppem ));</a>
<a name="ln2721">  }</a>
<a name="ln2722"> </a>
<a name="ln2723"> </a>
<a name="ln2724">  FT_BASE_DEF( void )</a>
<a name="ln2725">  FT_Request_Metrics( FT_Face          face,</a>
<a name="ln2726">                      FT_Size_Request  req )</a>
<a name="ln2727">  {</a>
<a name="ln2728">    FT_Size_Metrics*  metrics;</a>
<a name="ln2729"> </a>
<a name="ln2730"> </a>
<a name="ln2731">    metrics = &amp;face-&gt;size-&gt;metrics;</a>
<a name="ln2732"> </a>
<a name="ln2733">    if ( FT_IS_SCALABLE( face ) )</a>
<a name="ln2734">    {</a>
<a name="ln2735">      FT_Long  w = 0, h = 0, scaled_w = 0, scaled_h = 0;</a>
<a name="ln2736"> </a>
<a name="ln2737"> </a>
<a name="ln2738">      switch ( req-&gt;type )</a>
<a name="ln2739">      {</a>
<a name="ln2740">      case FT_SIZE_REQUEST_TYPE_NOMINAL:</a>
<a name="ln2741">        w = h = face-&gt;units_per_EM;</a>
<a name="ln2742">        break;</a>
<a name="ln2743"> </a>
<a name="ln2744">      case FT_SIZE_REQUEST_TYPE_REAL_DIM:</a>
<a name="ln2745">        w = h = face-&gt;ascender - face-&gt;descender;</a>
<a name="ln2746">        break;</a>
<a name="ln2747"> </a>
<a name="ln2748">      case FT_SIZE_REQUEST_TYPE_BBOX:</a>
<a name="ln2749">        w = face-&gt;bbox.xMax - face-&gt;bbox.xMin;</a>
<a name="ln2750">        h = face-&gt;bbox.yMax - face-&gt;bbox.yMin;</a>
<a name="ln2751">        break;</a>
<a name="ln2752"> </a>
<a name="ln2753">      case FT_SIZE_REQUEST_TYPE_CELL:</a>
<a name="ln2754">        w = face-&gt;max_advance_width;</a>
<a name="ln2755">        h = face-&gt;ascender - face-&gt;descender;</a>
<a name="ln2756">        break;</a>
<a name="ln2757"> </a>
<a name="ln2758">      case FT_SIZE_REQUEST_TYPE_SCALES:</a>
<a name="ln2759">        metrics-&gt;x_scale = (FT_Fixed)req-&gt;width;</a>
<a name="ln2760">        metrics-&gt;y_scale = (FT_Fixed)req-&gt;height;</a>
<a name="ln2761">        if ( !metrics-&gt;x_scale )</a>
<a name="ln2762">          metrics-&gt;x_scale = metrics-&gt;y_scale;</a>
<a name="ln2763">        else if ( !metrics-&gt;y_scale )</a>
<a name="ln2764">          metrics-&gt;y_scale = metrics-&gt;x_scale;</a>
<a name="ln2765">        goto Calculate_Ppem;</a>
<a name="ln2766"> </a>
<a name="ln2767">      case FT_SIZE_REQUEST_TYPE_MAX:</a>
<a name="ln2768">        break;</a>
<a name="ln2769">      }</a>
<a name="ln2770"> </a>
<a name="ln2771">      /* to be on the safe side */</a>
<a name="ln2772">      if ( w &lt; 0 )</a>
<a name="ln2773">        w = -w;</a>
<a name="ln2774"> </a>
<a name="ln2775">      if ( h &lt; 0 )</a>
<a name="ln2776">        h = -h;</a>
<a name="ln2777"> </a>
<a name="ln2778">      scaled_w = FT_REQUEST_WIDTH ( req );</a>
<a name="ln2779">      scaled_h = FT_REQUEST_HEIGHT( req );</a>
<a name="ln2780"> </a>
<a name="ln2781">      /* determine scales */</a>
<a name="ln2782">      if ( req-&gt;width )</a>
<a name="ln2783">      {</a>
<a name="ln2784">        metrics-&gt;x_scale = FT_DivFix( scaled_w, w );</a>
<a name="ln2785"> </a>
<a name="ln2786">        if ( req-&gt;height )</a>
<a name="ln2787">        {</a>
<a name="ln2788">          metrics-&gt;y_scale = FT_DivFix( scaled_h, h );</a>
<a name="ln2789"> </a>
<a name="ln2790">          if ( req-&gt;type == FT_SIZE_REQUEST_TYPE_CELL )</a>
<a name="ln2791">          {</a>
<a name="ln2792">            if ( metrics-&gt;y_scale &gt; metrics-&gt;x_scale )</a>
<a name="ln2793">              metrics-&gt;y_scale = metrics-&gt;x_scale;</a>
<a name="ln2794">            else</a>
<a name="ln2795">              metrics-&gt;x_scale = metrics-&gt;y_scale;</a>
<a name="ln2796">          }</a>
<a name="ln2797">        }</a>
<a name="ln2798">        else</a>
<a name="ln2799">        {</a>
<a name="ln2800">          metrics-&gt;y_scale = metrics-&gt;x_scale;</a>
<a name="ln2801">          scaled_h = FT_MulDiv( scaled_w, h, w );</a>
<a name="ln2802">        }</a>
<a name="ln2803">      }</a>
<a name="ln2804">      else</a>
<a name="ln2805">      {</a>
<a name="ln2806">        metrics-&gt;x_scale = metrics-&gt;y_scale = FT_DivFix( scaled_h, h );</a>
<a name="ln2807">        scaled_w = FT_MulDiv( scaled_h, w, h );</a>
<a name="ln2808">      }</a>
<a name="ln2809"> </a>
<a name="ln2810">  Calculate_Ppem:</a>
<a name="ln2811">      /* calculate the ppems */</a>
<a name="ln2812">      if ( req-&gt;type != FT_SIZE_REQUEST_TYPE_NOMINAL )</a>
<a name="ln2813">      {</a>
<a name="ln2814">        scaled_w = FT_MulFix( face-&gt;units_per_EM, metrics-&gt;x_scale );</a>
<a name="ln2815">        scaled_h = FT_MulFix( face-&gt;units_per_EM, metrics-&gt;y_scale );</a>
<a name="ln2816">      }</a>
<a name="ln2817"> </a>
<a name="ln2818">      metrics-&gt;x_ppem = (FT_UShort)( ( scaled_w + 32 ) &gt;&gt; 6 );</a>
<a name="ln2819">      metrics-&gt;y_ppem = (FT_UShort)( ( scaled_h + 32 ) &gt;&gt; 6 );</a>
<a name="ln2820"> </a>
<a name="ln2821">      ft_recompute_scaled_metrics( face, metrics );</a>
<a name="ln2822">    }</a>
<a name="ln2823">    else</a>
<a name="ln2824">    {</a>
<a name="ln2825">      FT_ZERO( metrics );</a>
<a name="ln2826">      metrics-&gt;x_scale = 1L &lt;&lt; 16;</a>
<a name="ln2827">      metrics-&gt;y_scale = 1L &lt;&lt; 16;</a>
<a name="ln2828">    }</a>
<a name="ln2829"> </a>
<a name="ln2830">    FT_TRACE5(( &quot;FT_Request_Metrics:\n&quot; ));</a>
<a name="ln2831">    FT_TRACE5(( &quot;  x scale: %d (%f)\n&quot;,</a>
<a name="ln2832">                metrics-&gt;x_scale, metrics-&gt;x_scale / 65536.0 ));</a>
<a name="ln2833">    FT_TRACE5(( &quot;  y scale: %d (%f)\n&quot;,</a>
<a name="ln2834">                metrics-&gt;y_scale, metrics-&gt;y_scale / 65536.0 ));</a>
<a name="ln2835">    FT_TRACE5(( &quot;  ascender: %f\n&quot;,    metrics-&gt;ascender / 64.0 ));</a>
<a name="ln2836">    FT_TRACE5(( &quot;  descender: %f\n&quot;,   metrics-&gt;descender / 64.0 ));</a>
<a name="ln2837">    FT_TRACE5(( &quot;  height: %f\n&quot;,      metrics-&gt;height / 64.0 ));</a>
<a name="ln2838">    FT_TRACE5(( &quot;  max advance: %f\n&quot;, metrics-&gt;max_advance / 64.0 ));</a>
<a name="ln2839">    FT_TRACE5(( &quot;  x ppem: %d\n&quot;,      metrics-&gt;x_ppem ));</a>
<a name="ln2840">    FT_TRACE5(( &quot;  y ppem: %d\n&quot;,      metrics-&gt;y_ppem ));</a>
<a name="ln2841">  }</a>
<a name="ln2842"> </a>
<a name="ln2843"> </a>
<a name="ln2844">  /* documentation is in freetype.h */</a>
<a name="ln2845"> </a>
<a name="ln2846">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2847">  FT_Select_Size( FT_Face  face,</a>
<a name="ln2848">                  FT_Int   strike_index )</a>
<a name="ln2849">  {</a>
<a name="ln2850">    FT_Driver_Class  clazz;</a>
<a name="ln2851"> </a>
<a name="ln2852"> </a>
<a name="ln2853">    if ( !face || !FT_HAS_FIXED_SIZES( face ) )</a>
<a name="ln2854">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln2855"> </a>
<a name="ln2856">    if ( strike_index &lt; 0 || strike_index &gt;= face-&gt;num_fixed_sizes )</a>
<a name="ln2857">      return FT_THROW( Invalid_Argument );</a>
<a name="ln2858"> </a>
<a name="ln2859">    clazz = face-&gt;driver-&gt;clazz;</a>
<a name="ln2860"> </a>
<a name="ln2861">    if ( clazz-&gt;select_size )</a>
<a name="ln2862">    {</a>
<a name="ln2863">      FT_Error  error;</a>
<a name="ln2864"> </a>
<a name="ln2865"> </a>
<a name="ln2866">      error = clazz-&gt;select_size( face-&gt;size, (FT_ULong)strike_index );</a>
<a name="ln2867"> </a>
<a name="ln2868">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2869">      {</a>
<a name="ln2870">        FT_Size_Metrics*  metrics = &amp;face-&gt;size-&gt;metrics;</a>
<a name="ln2871"> </a>
<a name="ln2872"> </a>
<a name="ln2873">        FT_TRACE5(( &quot;FT_Select_Size (font driver's `select_size'):\n&quot; ));</a>
<a name="ln2874">        FT_TRACE5(( &quot;  x scale: %d (%f)\n&quot;,</a>
<a name="ln2875">                    metrics-&gt;x_scale, metrics-&gt;x_scale / 65536.0 ));</a>
<a name="ln2876">        FT_TRACE5(( &quot;  y scale: %d (%f)\n&quot;,</a>
<a name="ln2877">                    metrics-&gt;y_scale, metrics-&gt;y_scale / 65536.0 ));</a>
<a name="ln2878">        FT_TRACE5(( &quot;  ascender: %f\n&quot;,    metrics-&gt;ascender / 64.0 ));</a>
<a name="ln2879">        FT_TRACE5(( &quot;  descender: %f\n&quot;,   metrics-&gt;descender / 64.0 ));</a>
<a name="ln2880">        FT_TRACE5(( &quot;  height: %f\n&quot;,      metrics-&gt;height / 64.0 ));</a>
<a name="ln2881">        FT_TRACE5(( &quot;  max advance: %f\n&quot;, metrics-&gt;max_advance / 64.0 ));</a>
<a name="ln2882">        FT_TRACE5(( &quot;  x ppem: %d\n&quot;,      metrics-&gt;x_ppem ));</a>
<a name="ln2883">        FT_TRACE5(( &quot;  y ppem: %d\n&quot;,      metrics-&gt;y_ppem ));</a>
<a name="ln2884">      }</a>
<a name="ln2885">#endif</a>
<a name="ln2886"> </a>
<a name="ln2887">      return error;</a>
<a name="ln2888">    }</a>
<a name="ln2889"> </a>
<a name="ln2890">    FT_Select_Metrics( face, (FT_ULong)strike_index );</a>
<a name="ln2891"> </a>
<a name="ln2892">    return FT_Err_Ok;</a>
<a name="ln2893">  }</a>
<a name="ln2894"> </a>
<a name="ln2895"> </a>
<a name="ln2896">  /* documentation is in freetype.h */</a>
<a name="ln2897"> </a>
<a name="ln2898">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2899">  FT_Request_Size( FT_Face          face,</a>
<a name="ln2900">                   FT_Size_Request  req )</a>
<a name="ln2901">  {</a>
<a name="ln2902">    FT_Driver_Class  clazz;</a>
<a name="ln2903">    FT_ULong         strike_index;</a>
<a name="ln2904"> </a>
<a name="ln2905"> </a>
<a name="ln2906">    if ( !face )</a>
<a name="ln2907">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln2908"> </a>
<a name="ln2909">    if ( !req || req-&gt;width &lt; 0 || req-&gt;height &lt; 0 ||</a>
<a name="ln2910">         req-&gt;type &gt;= FT_SIZE_REQUEST_TYPE_MAX )</a>
<a name="ln2911">      return FT_THROW( Invalid_Argument );</a>
<a name="ln2912"> </a>
<a name="ln2913">    clazz = face-&gt;driver-&gt;clazz;</a>
<a name="ln2914"> </a>
<a name="ln2915">    if ( clazz-&gt;request_size )</a>
<a name="ln2916">    {</a>
<a name="ln2917">      FT_Error  error;</a>
<a name="ln2918"> </a>
<a name="ln2919"> </a>
<a name="ln2920">      error = clazz-&gt;request_size( face-&gt;size, req );</a>
<a name="ln2921"> </a>
<a name="ln2922">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2923">      {</a>
<a name="ln2924">        FT_Size_Metrics*  metrics = &amp;face-&gt;size-&gt;metrics;</a>
<a name="ln2925"> </a>
<a name="ln2926"> </a>
<a name="ln2927">        FT_TRACE5(( &quot;FT_Request_Size (font driver's `request_size'):\n&quot; ));</a>
<a name="ln2928">        FT_TRACE5(( &quot;  x scale: %d (%f)\n&quot;,</a>
<a name="ln2929">                    metrics-&gt;x_scale, metrics-&gt;x_scale / 65536.0 ));</a>
<a name="ln2930">        FT_TRACE5(( &quot;  y scale: %d (%f)\n&quot;,</a>
<a name="ln2931">                    metrics-&gt;y_scale, metrics-&gt;y_scale / 65536.0 ));</a>
<a name="ln2932">        FT_TRACE5(( &quot;  ascender: %f\n&quot;,    metrics-&gt;ascender / 64.0 ));</a>
<a name="ln2933">        FT_TRACE5(( &quot;  descender: %f\n&quot;,   metrics-&gt;descender / 64.0 ));</a>
<a name="ln2934">        FT_TRACE5(( &quot;  height: %f\n&quot;,      metrics-&gt;height / 64.0 ));</a>
<a name="ln2935">        FT_TRACE5(( &quot;  max advance: %f\n&quot;, metrics-&gt;max_advance / 64.0 ));</a>
<a name="ln2936">        FT_TRACE5(( &quot;  x ppem: %d\n&quot;,      metrics-&gt;x_ppem ));</a>
<a name="ln2937">        FT_TRACE5(( &quot;  y ppem: %d\n&quot;,      metrics-&gt;y_ppem ));</a>
<a name="ln2938">      }</a>
<a name="ln2939">#endif</a>
<a name="ln2940"> </a>
<a name="ln2941">      return error;</a>
<a name="ln2942">    }</a>
<a name="ln2943"> </a>
<a name="ln2944">    /*</a>
<a name="ln2945">     * The reason that a driver doesn't have `request_size' defined is</a>
<a name="ln2946">     * either that the scaling here suffices or that the supported formats</a>
<a name="ln2947">     * are bitmap-only and size matching is not implemented.</a>
<a name="ln2948">     *</a>
<a name="ln2949">     * In the latter case, a simple size matching is done.</a>
<a name="ln2950">     */</a>
<a name="ln2951">    if ( !FT_IS_SCALABLE( face ) &amp;&amp; FT_HAS_FIXED_SIZES( face ) )</a>
<a name="ln2952">    {</a>
<a name="ln2953">      FT_Error  error;</a>
<a name="ln2954"> </a>
<a name="ln2955"> </a>
<a name="ln2956">      error = FT_Match_Size( face, req, 0, &amp;strike_index );</a>
<a name="ln2957">      if ( error )</a>
<a name="ln2958">        return error;</a>
<a name="ln2959"> </a>
<a name="ln2960">      return FT_Select_Size( face, (FT_Int)strike_index );</a>
<a name="ln2961">    }</a>
<a name="ln2962"> </a>
<a name="ln2963">    FT_Request_Metrics( face, req );</a>
<a name="ln2964"> </a>
<a name="ln2965">    return FT_Err_Ok;</a>
<a name="ln2966">  }</a>
<a name="ln2967"> </a>
<a name="ln2968"> </a>
<a name="ln2969">  /* documentation is in freetype.h */</a>
<a name="ln2970"> </a>
<a name="ln2971">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln2972">  FT_Set_Char_Size( FT_Face     face,</a>
<a name="ln2973">                    FT_F26Dot6  char_width,</a>
<a name="ln2974">                    FT_F26Dot6  char_height,</a>
<a name="ln2975">                    FT_UInt     horz_resolution,</a>
<a name="ln2976">                    FT_UInt     vert_resolution )</a>
<a name="ln2977">  {</a>
<a name="ln2978">    FT_Size_RequestRec  req;</a>
<a name="ln2979"> </a>
<a name="ln2980"> </a>
<a name="ln2981">    /* check of `face' delayed to `FT_Request_Size' */</a>
<a name="ln2982"> </a>
<a name="ln2983">    if ( !char_width )</a>
<a name="ln2984">      char_width = char_height;</a>
<a name="ln2985">    else if ( !char_height )</a>
<a name="ln2986">      char_height = char_width;</a>
<a name="ln2987"> </a>
<a name="ln2988">    if ( !horz_resolution )</a>
<a name="ln2989">      horz_resolution = vert_resolution;</a>
<a name="ln2990">    else if ( !vert_resolution )</a>
<a name="ln2991">      vert_resolution = horz_resolution;</a>
<a name="ln2992"> </a>
<a name="ln2993">    if ( char_width  &lt; 1 * 64 )</a>
<a name="ln2994">      char_width  = 1 * 64;</a>
<a name="ln2995">    if ( char_height &lt; 1 * 64 )</a>
<a name="ln2996">      char_height = 1 * 64;</a>
<a name="ln2997"> </a>
<a name="ln2998">    if ( !horz_resolution )</a>
<a name="ln2999">      horz_resolution = vert_resolution = 72;</a>
<a name="ln3000"> </a>
<a name="ln3001">    req.type           = FT_SIZE_REQUEST_TYPE_NOMINAL;</a>
<a name="ln3002">    req.width          = char_width;</a>
<a name="ln3003">    req.height         = char_height;</a>
<a name="ln3004">    req.horiResolution = horz_resolution;</a>
<a name="ln3005">    req.vertResolution = vert_resolution;</a>
<a name="ln3006"> </a>
<a name="ln3007">    return FT_Request_Size( face, &amp;req );</a>
<a name="ln3008">  }</a>
<a name="ln3009"> </a>
<a name="ln3010"> </a>
<a name="ln3011">  /* documentation is in freetype.h */</a>
<a name="ln3012"> </a>
<a name="ln3013">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3014">  FT_Set_Pixel_Sizes( FT_Face  face,</a>
<a name="ln3015">                      FT_UInt  pixel_width,</a>
<a name="ln3016">                      FT_UInt  pixel_height )</a>
<a name="ln3017">  {</a>
<a name="ln3018">    FT_Size_RequestRec  req;</a>
<a name="ln3019"> </a>
<a name="ln3020"> </a>
<a name="ln3021">    /* check of `face' delayed to `FT_Request_Size' */</a>
<a name="ln3022"> </a>
<a name="ln3023">    if ( pixel_width == 0 )</a>
<a name="ln3024">      pixel_width = pixel_height;</a>
<a name="ln3025">    else if ( pixel_height == 0 )</a>
<a name="ln3026">      pixel_height = pixel_width;</a>
<a name="ln3027"> </a>
<a name="ln3028">    if ( pixel_width  &lt; 1 )</a>
<a name="ln3029">      pixel_width  = 1;</a>
<a name="ln3030">    if ( pixel_height &lt; 1 )</a>
<a name="ln3031">      pixel_height = 1;</a>
<a name="ln3032"> </a>
<a name="ln3033">    /* use `&gt;=' to avoid potential compiler warning on 16bit platforms */</a>
<a name="ln3034">    if ( pixel_width &gt;= 0xFFFFU )</a>
<a name="ln3035">      pixel_width = 0xFFFFU;</a>
<a name="ln3036">    if ( pixel_height &gt;= 0xFFFFU )</a>
<a name="ln3037">      pixel_height = 0xFFFFU;</a>
<a name="ln3038"> </a>
<a name="ln3039">    req.type           = FT_SIZE_REQUEST_TYPE_NOMINAL;</a>
<a name="ln3040">    req.width          = (FT_Long)( pixel_width &lt;&lt; 6 );</a>
<a name="ln3041">    req.height         = (FT_Long)( pixel_height &lt;&lt; 6 );</a>
<a name="ln3042">    req.horiResolution = 0;</a>
<a name="ln3043">    req.vertResolution = 0;</a>
<a name="ln3044"> </a>
<a name="ln3045">    return FT_Request_Size( face, &amp;req );</a>
<a name="ln3046">  }</a>
<a name="ln3047"> </a>
<a name="ln3048"> </a>
<a name="ln3049">  /* documentation is in freetype.h */</a>
<a name="ln3050"> </a>
<a name="ln3051">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3052">  FT_Get_Kerning( FT_Face     face,</a>
<a name="ln3053">                  FT_UInt     left_glyph,</a>
<a name="ln3054">                  FT_UInt     right_glyph,</a>
<a name="ln3055">                  FT_UInt     kern_mode,</a>
<a name="ln3056">                  FT_Vector  *akerning )</a>
<a name="ln3057">  {</a>
<a name="ln3058">    FT_Error   error = FT_Err_Ok;</a>
<a name="ln3059">    FT_Driver  driver;</a>
<a name="ln3060"> </a>
<a name="ln3061"> </a>
<a name="ln3062">    if ( !face )</a>
<a name="ln3063">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln3064"> </a>
<a name="ln3065">    if ( !akerning )</a>
<a name="ln3066">      return FT_THROW( Invalid_Argument );</a>
<a name="ln3067"> </a>
<a name="ln3068">    driver = face-&gt;driver;</a>
<a name="ln3069"> </a>
<a name="ln3070">    akerning-&gt;x = 0;</a>
<a name="ln3071">    akerning-&gt;y = 0;</a>
<a name="ln3072"> </a>
<a name="ln3073">    if ( driver-&gt;clazz-&gt;get_kerning )</a>
<a name="ln3074">    {</a>
<a name="ln3075">      error = driver-&gt;clazz-&gt;get_kerning( face,</a>
<a name="ln3076">                                          left_glyph,</a>
<a name="ln3077">                                          right_glyph,</a>
<a name="ln3078">                                          akerning );</a>
<a name="ln3079">      if ( !error )</a>
<a name="ln3080">      {</a>
<a name="ln3081">        if ( kern_mode != FT_KERNING_UNSCALED )</a>
<a name="ln3082">        {</a>
<a name="ln3083">          akerning-&gt;x = FT_MulFix( akerning-&gt;x, face-&gt;size-&gt;metrics.x_scale );</a>
<a name="ln3084">          akerning-&gt;y = FT_MulFix( akerning-&gt;y, face-&gt;size-&gt;metrics.y_scale );</a>
<a name="ln3085"> </a>
<a name="ln3086">          if ( kern_mode != FT_KERNING_UNFITTED )</a>
<a name="ln3087">          {</a>
<a name="ln3088">            FT_Pos  orig_x = akerning-&gt;x;</a>
<a name="ln3089">            FT_Pos  orig_y = akerning-&gt;y;</a>
<a name="ln3090"> </a>
<a name="ln3091"> </a>
<a name="ln3092">            /* we scale down kerning values for small ppem values */</a>
<a name="ln3093">            /* to avoid that rounding makes them too big.         */</a>
<a name="ln3094">            /* `25' has been determined heuristically.            */</a>
<a name="ln3095">            if ( face-&gt;size-&gt;metrics.x_ppem &lt; 25 )</a>
<a name="ln3096">              akerning-&gt;x = FT_MulDiv( orig_x,</a>
<a name="ln3097">                                       face-&gt;size-&gt;metrics.x_ppem, 25 );</a>
<a name="ln3098">            if ( face-&gt;size-&gt;metrics.y_ppem &lt; 25 )</a>
<a name="ln3099">              akerning-&gt;y = FT_MulDiv( orig_y,</a>
<a name="ln3100">                                       face-&gt;size-&gt;metrics.y_ppem, 25 );</a>
<a name="ln3101"> </a>
<a name="ln3102">            akerning-&gt;x = FT_PIX_ROUND( akerning-&gt;x );</a>
<a name="ln3103">            akerning-&gt;y = FT_PIX_ROUND( akerning-&gt;y );</a>
<a name="ln3104"> </a>
<a name="ln3105">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln3106">            {</a>
<a name="ln3107">              FT_Pos  orig_x_rounded = FT_PIX_ROUND( orig_x );</a>
<a name="ln3108">              FT_Pos  orig_y_rounded = FT_PIX_ROUND( orig_y );</a>
<a name="ln3109"> </a>
<a name="ln3110"> </a>
<a name="ln3111">              if ( akerning-&gt;x != orig_x_rounded ||</a>
<a name="ln3112">                   akerning-&gt;y != orig_y_rounded )</a>
<a name="ln3113">                FT_TRACE5(( &quot;FT_Get_Kerning: horizontal kerning&quot;</a>
<a name="ln3114">                            &quot; (%d, %d) scaled down to (%d, %d) pixels\n&quot;,</a>
<a name="ln3115">                            orig_x_rounded / 64, orig_y_rounded / 64,</a>
<a name="ln3116">                            akerning-&gt;x / 64, akerning-&gt;y / 64 ));</a>
<a name="ln3117">            }</a>
<a name="ln3118">#endif</a>
<a name="ln3119">          }</a>
<a name="ln3120">        }</a>
<a name="ln3121">      }</a>
<a name="ln3122">    }</a>
<a name="ln3123"> </a>
<a name="ln3124">    return error;</a>
<a name="ln3125">  }</a>
<a name="ln3126"> </a>
<a name="ln3127"> </a>
<a name="ln3128">  /* documentation is in freetype.h */</a>
<a name="ln3129"> </a>
<a name="ln3130">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3131">  FT_Get_Track_Kerning( FT_Face    face,</a>
<a name="ln3132">                        FT_Fixed   point_size,</a>
<a name="ln3133">                        FT_Int     degree,</a>
<a name="ln3134">                        FT_Fixed*  akerning )</a>
<a name="ln3135">  {</a>
<a name="ln3136">    FT_Service_Kerning  service;</a>
<a name="ln3137">    FT_Error            error = FT_Err_Ok;</a>
<a name="ln3138"> </a>
<a name="ln3139"> </a>
<a name="ln3140">    if ( !face )</a>
<a name="ln3141">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln3142"> </a>
<a name="ln3143">    if ( !akerning )</a>
<a name="ln3144">      return FT_THROW( Invalid_Argument );</a>
<a name="ln3145"> </a>
<a name="ln3146">    FT_FACE_FIND_SERVICE( face, service, KERNING );</a>
<a name="ln3147">    if ( !service )</a>
<a name="ln3148">      return FT_THROW( Unimplemented_Feature );</a>
<a name="ln3149"> </a>
<a name="ln3150">    error = service-&gt;get_track( face,</a>
<a name="ln3151">                                point_size,</a>
<a name="ln3152">                                degree,</a>
<a name="ln3153">                                akerning );</a>
<a name="ln3154"> </a>
<a name="ln3155">    return error;</a>
<a name="ln3156">  }</a>
<a name="ln3157"> </a>
<a name="ln3158"> </a>
<a name="ln3159">  /* documentation is in freetype.h */</a>
<a name="ln3160"> </a>
<a name="ln3161">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3162">  FT_Select_Charmap( FT_Face      face,</a>
<a name="ln3163">                     FT_Encoding  encoding )</a>
<a name="ln3164">  {</a>
<a name="ln3165">    FT_CharMap*  cur;</a>
<a name="ln3166">    FT_CharMap*  limit;</a>
<a name="ln3167"> </a>
<a name="ln3168"> </a>
<a name="ln3169">    if ( !face )</a>
<a name="ln3170">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln3171"> </a>
<a name="ln3172">    if ( encoding == FT_ENCODING_NONE )</a>
<a name="ln3173">      return FT_THROW( Invalid_Argument );</a>
<a name="ln3174"> </a>
<a name="ln3175">    /* FT_ENCODING_UNICODE is special.  We try to find the `best' Unicode */</a>
<a name="ln3176">    /* charmap available, i.e., one with UCS-4 characters, if possible.   */</a>
<a name="ln3177">    /*                                                                    */</a>
<a name="ln3178">    /* This is done by find_unicode_charmap() above, to share code.       */</a>
<a name="ln3179">    if ( encoding == FT_ENCODING_UNICODE )</a>
<a name="ln3180">      return find_unicode_charmap( face );</a>
<a name="ln3181"> </a>
<a name="ln3182">    cur = face-&gt;charmaps;</a>
<a name="ln3183">    if ( !cur )</a>
<a name="ln3184">      return FT_THROW( Invalid_CharMap_Handle );</a>
<a name="ln3185"> </a>
<a name="ln3186">    limit = cur + face-&gt;num_charmaps;</a>
<a name="ln3187"> </a>
<a name="ln3188">    for ( ; cur &lt; limit; cur++ )</a>
<a name="ln3189">    {</a>
<a name="ln3190">      if ( cur[0]-&gt;encoding == encoding )</a>
<a name="ln3191">      {</a>
<a name="ln3192">        face-&gt;charmap = cur[0];</a>
<a name="ln3193">        return 0;</a>
<a name="ln3194">      }</a>
<a name="ln3195">    }</a>
<a name="ln3196"> </a>
<a name="ln3197">    return FT_THROW( Invalid_Argument );</a>
<a name="ln3198">  }</a>
<a name="ln3199"> </a>
<a name="ln3200"> </a>
<a name="ln3201">  /* documentation is in freetype.h */</a>
<a name="ln3202"> </a>
<a name="ln3203">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3204">  FT_Set_Charmap( FT_Face     face,</a>
<a name="ln3205">                  FT_CharMap  charmap )</a>
<a name="ln3206">  {</a>
<a name="ln3207">    FT_CharMap*  cur;</a>
<a name="ln3208">    FT_CharMap*  limit;</a>
<a name="ln3209"> </a>
<a name="ln3210"> </a>
<a name="ln3211">    if ( !face )</a>
<a name="ln3212">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln3213"> </a>
<a name="ln3214">    cur = face-&gt;charmaps;</a>
<a name="ln3215">    if ( !cur || !charmap )</a>
<a name="ln3216">      return FT_THROW( Invalid_CharMap_Handle );</a>
<a name="ln3217"> </a>
<a name="ln3218">    if ( FT_Get_CMap_Format( charmap ) == 14 )</a>
<a name="ln3219">      return FT_THROW( Invalid_Argument );</a>
<a name="ln3220"> </a>
<a name="ln3221">    limit = cur + face-&gt;num_charmaps;</a>
<a name="ln3222"> </a>
<a name="ln3223">    for ( ; cur &lt; limit; cur++ )</a>
<a name="ln3224">    {</a>
<a name="ln3225">      if ( cur[0] == charmap )</a>
<a name="ln3226">      {</a>
<a name="ln3227">        face-&gt;charmap = cur[0];</a>
<a name="ln3228">        return FT_Err_Ok;</a>
<a name="ln3229">      }</a>
<a name="ln3230">    }</a>
<a name="ln3231"> </a>
<a name="ln3232">    return FT_THROW( Invalid_Argument );</a>
<a name="ln3233">  }</a>
<a name="ln3234"> </a>
<a name="ln3235"> </a>
<a name="ln3236">  /* documentation is in freetype.h */</a>
<a name="ln3237"> </a>
<a name="ln3238">  FT_EXPORT_DEF( FT_Int )</a>
<a name="ln3239">  FT_Get_Charmap_Index( FT_CharMap  charmap )</a>
<a name="ln3240">  {</a>
<a name="ln3241">    FT_Int  i;</a>
<a name="ln3242"> </a>
<a name="ln3243"> </a>
<a name="ln3244">    if ( !charmap || !charmap-&gt;face )</a>
<a name="ln3245">      return -1;</a>
<a name="ln3246"> </a>
<a name="ln3247">    for ( i = 0; i &lt; charmap-&gt;face-&gt;num_charmaps; i++ )</a>
<a name="ln3248">      if ( charmap-&gt;face-&gt;charmaps[i] == charmap )</a>
<a name="ln3249">        break;</a>
<a name="ln3250"> </a>
<a name="ln3251">    FT_ASSERT( i &lt; charmap-&gt;face-&gt;num_charmaps );</a>
<a name="ln3252"> </a>
<a name="ln3253">    return i;</a>
<a name="ln3254">  }</a>
<a name="ln3255"> </a>
<a name="ln3256"> </a>
<a name="ln3257">  static void</a>
<a name="ln3258">  ft_cmap_done_internal( FT_CMap  cmap )</a>
<a name="ln3259">  {</a>
<a name="ln3260">    FT_CMap_Class  clazz  = cmap-&gt;clazz;</a>
<a name="ln3261">    FT_Face        face   = cmap-&gt;charmap.face;</a>
<a name="ln3262">    FT_Memory      memory = FT_FACE_MEMORY( face );</a>
<a name="ln3263"> </a>
<a name="ln3264"> </a>
<a name="ln3265">    if ( clazz-&gt;done )</a>
<a name="ln3266">      clazz-&gt;done( cmap );</a>
<a name="ln3267"> </a>
<a name="ln3268">    FT_FREE( cmap );</a>
<a name="ln3269">  }</a>
<a name="ln3270"> </a>
<a name="ln3271"> </a>
<a name="ln3272">  FT_BASE_DEF( void )</a>
<a name="ln3273">  FT_CMap_Done( FT_CMap  cmap )</a>
<a name="ln3274">  {</a>
<a name="ln3275">    if ( cmap )</a>
<a name="ln3276">    {</a>
<a name="ln3277">      FT_Face    face   = cmap-&gt;charmap.face;</a>
<a name="ln3278">      FT_Memory  memory = FT_FACE_MEMORY( face );</a>
<a name="ln3279">      FT_Error   error;</a>
<a name="ln3280">      FT_Int     i, j;</a>
<a name="ln3281"> </a>
<a name="ln3282"> </a>
<a name="ln3283">      for ( i = 0; i &lt; face-&gt;num_charmaps; i++ )</a>
<a name="ln3284">      {</a>
<a name="ln3285">        if ( (FT_CMap)face-&gt;charmaps[i] == cmap )</a>
<a name="ln3286">        {</a>
<a name="ln3287">          FT_CharMap  last_charmap = face-&gt;charmaps[face-&gt;num_charmaps - 1];</a>
<a name="ln3288"> </a>
<a name="ln3289"> </a>
<a name="ln3290">          if ( FT_RENEW_ARRAY( face-&gt;charmaps,</a>
<a name="ln3291">                               face-&gt;num_charmaps,</a>
<a name="ln3292">                               face-&gt;num_charmaps - 1 ) )</a>
<a name="ln3293">            return;</a>
<a name="ln3294"> </a>
<a name="ln3295">          /* remove it from our list of charmaps */</a>
<a name="ln3296">          for ( j = i + 1; j &lt; face-&gt;num_charmaps; j++ )</a>
<a name="ln3297">          {</a>
<a name="ln3298">            if ( j == face-&gt;num_charmaps - 1 )</a>
<a name="ln3299">              face-&gt;charmaps[j - 1] = last_charmap;</a>
<a name="ln3300">            else</a>
<a name="ln3301">              face-&gt;charmaps[j - 1] = face-&gt;charmaps[j];</a>
<a name="ln3302">          }</a>
<a name="ln3303"> </a>
<a name="ln3304">          face-&gt;num_charmaps--;</a>
<a name="ln3305"> </a>
<a name="ln3306">          if ( (FT_CMap)face-&gt;charmap == cmap )</a>
<a name="ln3307">            face-&gt;charmap = NULL;</a>
<a name="ln3308"> </a>
<a name="ln3309">          ft_cmap_done_internal( cmap );</a>
<a name="ln3310"> </a>
<a name="ln3311">          break;</a>
<a name="ln3312">        }</a>
<a name="ln3313">      }</a>
<a name="ln3314">    }</a>
<a name="ln3315">  }</a>
<a name="ln3316"> </a>
<a name="ln3317"> </a>
<a name="ln3318">  FT_BASE_DEF( FT_Error )</a>
<a name="ln3319">  FT_CMap_New( FT_CMap_Class  clazz,</a>
<a name="ln3320">               FT_Pointer     init_data,</a>
<a name="ln3321">               FT_CharMap     charmap,</a>
<a name="ln3322">               FT_CMap       *acmap )</a>
<a name="ln3323">  {</a>
<a name="ln3324">    FT_Error   error = FT_Err_Ok;</a>
<a name="ln3325">    FT_Face    face;</a>
<a name="ln3326">    FT_Memory  memory;</a>
<a name="ln3327">    FT_CMap    cmap = NULL;</a>
<a name="ln3328"> </a>
<a name="ln3329"> </a>
<a name="ln3330">    if ( clazz == NULL || charmap == NULL || charmap-&gt;face == NULL )</a>
<a name="ln3331">      return FT_THROW( Invalid_Argument );</a>
<a name="ln3332"> </a>
<a name="ln3333">    face   = charmap-&gt;face;</a>
<a name="ln3334">    memory = FT_FACE_MEMORY( face );</a>
<a name="ln3335"> </a>
<a name="ln3336">    if ( !FT_ALLOC( cmap, clazz-&gt;size ) )</a>
<a name="ln3337">    {</a>
<a name="ln3338">      cmap-&gt;charmap = *charmap;</a>
<a name="ln3339">      cmap-&gt;clazz   = clazz;</a>
<a name="ln3340"> </a>
<a name="ln3341">      if ( clazz-&gt;init )</a>
<a name="ln3342">      {</a>
<a name="ln3343">        error = clazz-&gt;init( cmap, init_data );</a>
<a name="ln3344">        if ( error )</a>
<a name="ln3345">          goto Fail;</a>
<a name="ln3346">      }</a>
<a name="ln3347"> </a>
<a name="ln3348">      /* add it to our list of charmaps */</a>
<a name="ln3349">      if ( FT_RENEW_ARRAY( face-&gt;charmaps,</a>
<a name="ln3350">                           face-&gt;num_charmaps,</a>
<a name="ln3351">                           face-&gt;num_charmaps + 1 ) )</a>
<a name="ln3352">        goto Fail;</a>
<a name="ln3353"> </a>
<a name="ln3354">      face-&gt;charmaps[face-&gt;num_charmaps++] = (FT_CharMap)cmap;</a>
<a name="ln3355">    }</a>
<a name="ln3356"> </a>
<a name="ln3357">  Exit:</a>
<a name="ln3358">    if ( acmap )</a>
<a name="ln3359">      *acmap = cmap;</a>
<a name="ln3360"> </a>
<a name="ln3361">    return error;</a>
<a name="ln3362"> </a>
<a name="ln3363">  Fail:</a>
<a name="ln3364">    ft_cmap_done_internal( cmap );</a>
<a name="ln3365">    cmap = NULL;</a>
<a name="ln3366">    goto Exit;</a>
<a name="ln3367">  }</a>
<a name="ln3368"> </a>
<a name="ln3369"> </a>
<a name="ln3370">  /* documentation is in freetype.h */</a>
<a name="ln3371"> </a>
<a name="ln3372">  FT_EXPORT_DEF( FT_UInt )</a>
<a name="ln3373">  FT_Get_Char_Index( FT_Face   face,</a>
<a name="ln3374">                     FT_ULong  charcode )</a>
<a name="ln3375">  {</a>
<a name="ln3376">    FT_UInt  result = 0;</a>
<a name="ln3377"> </a>
<a name="ln3378"> </a>
<a name="ln3379">    if ( face &amp;&amp; face-&gt;charmap )</a>
<a name="ln3380">    {</a>
<a name="ln3381">      FT_CMap  cmap = FT_CMAP( face-&gt;charmap );</a>
<a name="ln3382"> </a>
<a name="ln3383"> </a>
<a name="ln3384">      if ( charcode &gt; 0xFFFFFFFFUL )</a>
<a name="ln3385">      {</a>
<a name="ln3386">        FT_TRACE1(( &quot;FT_Get_Char_Index: too large charcode&quot; ));</a>
<a name="ln3387">        FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, charcode ));</a>
<a name="ln3388">      }</a>
<a name="ln3389"> </a>
<a name="ln3390">      result = cmap-&gt;clazz-&gt;char_index( cmap, (FT_UInt32)charcode );</a>
<a name="ln3391">      if ( result &gt;= (FT_UInt)face-&gt;num_glyphs )</a>
<a name="ln3392">        result = 0;</a>
<a name="ln3393">    }</a>
<a name="ln3394"> </a>
<a name="ln3395">    return result;</a>
<a name="ln3396">  }</a>
<a name="ln3397"> </a>
<a name="ln3398"> </a>
<a name="ln3399">  /* documentation is in freetype.h */</a>
<a name="ln3400"> </a>
<a name="ln3401">  FT_EXPORT_DEF( FT_ULong )</a>
<a name="ln3402">  FT_Get_First_Char( FT_Face   face,</a>
<a name="ln3403">                     FT_UInt  *agindex )</a>
<a name="ln3404">  {</a>
<a name="ln3405">    FT_ULong  result = 0;</a>
<a name="ln3406">    FT_UInt   gindex = 0;</a>
<a name="ln3407"> </a>
<a name="ln3408"> </a>
<a name="ln3409">    /* only do something if we have a charmap, and we have glyphs at all */</a>
<a name="ln3410">    if ( face &amp;&amp; face-&gt;charmap &amp;&amp; face-&gt;num_glyphs )</a>
<a name="ln3411">    {</a>
<a name="ln3412">      gindex = FT_Get_Char_Index( face, 0 );</a>
<a name="ln3413">      if ( gindex == 0 )</a>
<a name="ln3414">        result = FT_Get_Next_Char( face, 0, &amp;gindex );</a>
<a name="ln3415">    }</a>
<a name="ln3416"> </a>
<a name="ln3417">    if ( agindex )</a>
<a name="ln3418">      *agindex = gindex;</a>
<a name="ln3419"> </a>
<a name="ln3420">    return result;</a>
<a name="ln3421">  }</a>
<a name="ln3422"> </a>
<a name="ln3423"> </a>
<a name="ln3424">  /* documentation is in freetype.h */</a>
<a name="ln3425"> </a>
<a name="ln3426">  FT_EXPORT_DEF( FT_ULong )</a>
<a name="ln3427">  FT_Get_Next_Char( FT_Face   face,</a>
<a name="ln3428">                    FT_ULong  charcode,</a>
<a name="ln3429">                    FT_UInt  *agindex )</a>
<a name="ln3430">  {</a>
<a name="ln3431">    FT_ULong  result = 0;</a>
<a name="ln3432">    FT_UInt   gindex = 0;</a>
<a name="ln3433"> </a>
<a name="ln3434"> </a>
<a name="ln3435">    if ( face &amp;&amp; face-&gt;charmap &amp;&amp; face-&gt;num_glyphs )</a>
<a name="ln3436">    {</a>
<a name="ln3437">      FT_UInt32  code = (FT_UInt32)charcode;</a>
<a name="ln3438">      FT_CMap    cmap = FT_CMAP( face-&gt;charmap );</a>
<a name="ln3439"> </a>
<a name="ln3440"> </a>
<a name="ln3441">      do</a>
<a name="ln3442">      {</a>
<a name="ln3443">        gindex = cmap-&gt;clazz-&gt;char_next( cmap, &amp;code );</a>
<a name="ln3444"> </a>
<a name="ln3445">      } while ( gindex &gt;= (FT_UInt)face-&gt;num_glyphs );</a>
<a name="ln3446"> </a>
<a name="ln3447">      result = ( gindex == 0 ) ? 0 : code;</a>
<a name="ln3448">    }</a>
<a name="ln3449"> </a>
<a name="ln3450">    if ( agindex )</a>
<a name="ln3451">      *agindex = gindex;</a>
<a name="ln3452"> </a>
<a name="ln3453">    return result;</a>
<a name="ln3454">  }</a>
<a name="ln3455"> </a>
<a name="ln3456"> </a>
<a name="ln3457">  /* documentation is in freetype.h */</a>
<a name="ln3458"> </a>
<a name="ln3459">  FT_EXPORT_DEF( FT_UInt )</a>
<a name="ln3460">  FT_Face_GetCharVariantIndex( FT_Face   face,</a>
<a name="ln3461">                               FT_ULong  charcode,</a>
<a name="ln3462">                               FT_ULong  variantSelector )</a>
<a name="ln3463">  {</a>
<a name="ln3464">    FT_UInt  result = 0;</a>
<a name="ln3465"> </a>
<a name="ln3466"> </a>
<a name="ln3467">    if ( face                                           &amp;&amp;</a>
<a name="ln3468">         face-&gt;charmap                                  &amp;&amp;</a>
<a name="ln3469">         face-&gt;charmap-&gt;encoding == FT_ENCODING_UNICODE )</a>
<a name="ln3470">    {</a>
<a name="ln3471">      FT_CharMap  charmap = find_variant_selector_charmap( face );</a>
<a name="ln3472">      FT_CMap     ucmap = FT_CMAP( face-&gt;charmap );</a>
<a name="ln3473"> </a>
<a name="ln3474"> </a>
<a name="ln3475">      if ( charmap != NULL )</a>
<a name="ln3476">      {</a>
<a name="ln3477">        FT_CMap  vcmap = FT_CMAP( charmap );</a>
<a name="ln3478"> </a>
<a name="ln3479"> </a>
<a name="ln3480">        if ( charcode &gt; 0xFFFFFFFFUL )</a>
<a name="ln3481">        {</a>
<a name="ln3482">          FT_TRACE1(( &quot;FT_Get_Char_Index: too large charcode&quot; ));</a>
<a name="ln3483">          FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, charcode ));</a>
<a name="ln3484">        }</a>
<a name="ln3485">        if ( variantSelector &gt; 0xFFFFFFFFUL )</a>
<a name="ln3486">        {</a>
<a name="ln3487">          FT_TRACE1(( &quot;FT_Get_Char_Index: too large variantSelector&quot; ));</a>
<a name="ln3488">          FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, variantSelector ));</a>
<a name="ln3489">        }</a>
<a name="ln3490"> </a>
<a name="ln3491">        result = vcmap-&gt;clazz-&gt;char_var_index( vcmap, ucmap,</a>
<a name="ln3492">                                               (FT_UInt32)charcode,</a>
<a name="ln3493">                                               (FT_UInt32)variantSelector );</a>
<a name="ln3494">      }</a>
<a name="ln3495">    }</a>
<a name="ln3496"> </a>
<a name="ln3497">    return result;</a>
<a name="ln3498">  }</a>
<a name="ln3499"> </a>
<a name="ln3500"> </a>
<a name="ln3501">  /* documentation is in freetype.h */</a>
<a name="ln3502"> </a>
<a name="ln3503">  FT_EXPORT_DEF( FT_Int )</a>
<a name="ln3504">  FT_Face_GetCharVariantIsDefault( FT_Face   face,</a>
<a name="ln3505">                                   FT_ULong  charcode,</a>
<a name="ln3506">                                   FT_ULong  variantSelector )</a>
<a name="ln3507">  {</a>
<a name="ln3508">    FT_Int  result = -1;</a>
<a name="ln3509"> </a>
<a name="ln3510"> </a>
<a name="ln3511">    if ( face )</a>
<a name="ln3512">    {</a>
<a name="ln3513">      FT_CharMap  charmap = find_variant_selector_charmap( face );</a>
<a name="ln3514"> </a>
<a name="ln3515"> </a>
<a name="ln3516">      if ( charmap != NULL )</a>
<a name="ln3517">      {</a>
<a name="ln3518">        FT_CMap  vcmap = FT_CMAP( charmap );</a>
<a name="ln3519"> </a>
<a name="ln3520"> </a>
<a name="ln3521">        if ( charcode &gt; 0xFFFFFFFFUL )</a>
<a name="ln3522">        {</a>
<a name="ln3523">          FT_TRACE1(( &quot;FT_Get_Char_Index: too large charcode&quot; ));</a>
<a name="ln3524">          FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, charcode ));</a>
<a name="ln3525">        }</a>
<a name="ln3526">        if ( variantSelector &gt; 0xFFFFFFFFUL )</a>
<a name="ln3527">        {</a>
<a name="ln3528">          FT_TRACE1(( &quot;FT_Get_Char_Index: too large variantSelector&quot; ));</a>
<a name="ln3529">          FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, variantSelector ));</a>
<a name="ln3530">        }</a>
<a name="ln3531"> </a>
<a name="ln3532">        result = vcmap-&gt;clazz-&gt;char_var_default( vcmap,</a>
<a name="ln3533">                                                 (FT_UInt32)charcode,</a>
<a name="ln3534">                                                 (FT_UInt32)variantSelector );</a>
<a name="ln3535">      }</a>
<a name="ln3536">    }</a>
<a name="ln3537"> </a>
<a name="ln3538">    return result;</a>
<a name="ln3539">  }</a>
<a name="ln3540"> </a>
<a name="ln3541"> </a>
<a name="ln3542">  /* documentation is in freetype.h */</a>
<a name="ln3543"> </a>
<a name="ln3544">  FT_EXPORT_DEF( FT_UInt32* )</a>
<a name="ln3545">  FT_Face_GetVariantSelectors( FT_Face  face )</a>
<a name="ln3546">  {</a>
<a name="ln3547">    FT_UInt32  *result = NULL;</a>
<a name="ln3548"> </a>
<a name="ln3549"> </a>
<a name="ln3550">    if ( face )</a>
<a name="ln3551">    {</a>
<a name="ln3552">      FT_CharMap  charmap = find_variant_selector_charmap( face );</a>
<a name="ln3553"> </a>
<a name="ln3554"> </a>
<a name="ln3555">      if ( charmap != NULL )</a>
<a name="ln3556">      {</a>
<a name="ln3557">        FT_CMap    vcmap  = FT_CMAP( charmap );</a>
<a name="ln3558">        FT_Memory  memory = FT_FACE_MEMORY( face );</a>
<a name="ln3559"> </a>
<a name="ln3560"> </a>
<a name="ln3561">        result = vcmap-&gt;clazz-&gt;variant_list( vcmap, memory );</a>
<a name="ln3562">      }</a>
<a name="ln3563">    }</a>
<a name="ln3564"> </a>
<a name="ln3565">    return result;</a>
<a name="ln3566">  }</a>
<a name="ln3567"> </a>
<a name="ln3568"> </a>
<a name="ln3569">  /* documentation is in freetype.h */</a>
<a name="ln3570"> </a>
<a name="ln3571">  FT_EXPORT_DEF( FT_UInt32* )</a>
<a name="ln3572">  FT_Face_GetVariantsOfChar( FT_Face   face,</a>
<a name="ln3573">                             FT_ULong  charcode )</a>
<a name="ln3574">  {</a>
<a name="ln3575">    FT_UInt32  *result = NULL;</a>
<a name="ln3576"> </a>
<a name="ln3577"> </a>
<a name="ln3578">    if ( face )</a>
<a name="ln3579">    {</a>
<a name="ln3580">      FT_CharMap  charmap = find_variant_selector_charmap( face );</a>
<a name="ln3581"> </a>
<a name="ln3582"> </a>
<a name="ln3583">      if ( charmap != NULL )</a>
<a name="ln3584">      {</a>
<a name="ln3585">        FT_CMap    vcmap  = FT_CMAP( charmap );</a>
<a name="ln3586">        FT_Memory  memory = FT_FACE_MEMORY( face );</a>
<a name="ln3587"> </a>
<a name="ln3588"> </a>
<a name="ln3589">        if ( charcode &gt; 0xFFFFFFFFUL )</a>
<a name="ln3590">        {</a>
<a name="ln3591">          FT_TRACE1(( &quot;FT_Get_Char_Index: too large charcode&quot; ));</a>
<a name="ln3592">          FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, charcode ));</a>
<a name="ln3593">        }</a>
<a name="ln3594"> </a>
<a name="ln3595">        result = vcmap-&gt;clazz-&gt;charvariant_list( vcmap, memory,</a>
<a name="ln3596">                                                 (FT_UInt32)charcode );</a>
<a name="ln3597">      }</a>
<a name="ln3598">    }</a>
<a name="ln3599">    return result;</a>
<a name="ln3600">  }</a>
<a name="ln3601"> </a>
<a name="ln3602"> </a>
<a name="ln3603">  /* documentation is in freetype.h */</a>
<a name="ln3604"> </a>
<a name="ln3605">  FT_EXPORT_DEF( FT_UInt32* )</a>
<a name="ln3606">  FT_Face_GetCharsOfVariant( FT_Face   face,</a>
<a name="ln3607">                             FT_ULong  variantSelector )</a>
<a name="ln3608">  {</a>
<a name="ln3609">    FT_UInt32  *result = NULL;</a>
<a name="ln3610"> </a>
<a name="ln3611"> </a>
<a name="ln3612">    if ( face )</a>
<a name="ln3613">    {</a>
<a name="ln3614">      FT_CharMap  charmap = find_variant_selector_charmap( face );</a>
<a name="ln3615"> </a>
<a name="ln3616"> </a>
<a name="ln3617">      if ( charmap != NULL )</a>
<a name="ln3618">      {</a>
<a name="ln3619">        FT_CMap    vcmap  = FT_CMAP( charmap );</a>
<a name="ln3620">        FT_Memory  memory = FT_FACE_MEMORY( face );</a>
<a name="ln3621"> </a>
<a name="ln3622"> </a>
<a name="ln3623">        if ( variantSelector &gt; 0xFFFFFFFFUL )</a>
<a name="ln3624">        {</a>
<a name="ln3625">          FT_TRACE1(( &quot;FT_Get_Char_Index: too large variantSelector&quot; ));</a>
<a name="ln3626">          FT_TRACE1(( &quot; 0x%x is truncated\n&quot;, variantSelector ));</a>
<a name="ln3627">        }</a>
<a name="ln3628"> </a>
<a name="ln3629">        result = vcmap-&gt;clazz-&gt;variantchar_list( vcmap, memory,</a>
<a name="ln3630">                                                 (FT_UInt32)variantSelector );</a>
<a name="ln3631">      }</a>
<a name="ln3632">    }</a>
<a name="ln3633"> </a>
<a name="ln3634">    return result;</a>
<a name="ln3635">  }</a>
<a name="ln3636"> </a>
<a name="ln3637"> </a>
<a name="ln3638">  /* documentation is in freetype.h */</a>
<a name="ln3639"> </a>
<a name="ln3640">  FT_EXPORT_DEF( FT_UInt )</a>
<a name="ln3641">  FT_Get_Name_Index( FT_Face     face,</a>
<a name="ln3642">                     FT_String*  glyph_name )</a>
<a name="ln3643">  {</a>
<a name="ln3644">    FT_UInt  result = 0;</a>
<a name="ln3645"> </a>
<a name="ln3646"> </a>
<a name="ln3647">    if ( face                       &amp;&amp;</a>
<a name="ln3648">         FT_HAS_GLYPH_NAMES( face ) &amp;&amp;</a>
<a name="ln3649">         glyph_name                 )</a>
<a name="ln3650">    {</a>
<a name="ln3651">      FT_Service_GlyphDict  service;</a>
<a name="ln3652"> </a>
<a name="ln3653"> </a>
<a name="ln3654">      FT_FACE_LOOKUP_SERVICE( face,</a>
<a name="ln3655">                              service,</a>
<a name="ln3656">                              GLYPH_DICT );</a>
<a name="ln3657"> </a>
<a name="ln3658">      if ( service &amp;&amp; service-&gt;name_index )</a>
<a name="ln3659">        result = service-&gt;name_index( face, glyph_name );</a>
<a name="ln3660">    }</a>
<a name="ln3661"> </a>
<a name="ln3662">    return result;</a>
<a name="ln3663">  }</a>
<a name="ln3664"> </a>
<a name="ln3665"> </a>
<a name="ln3666">  /* documentation is in freetype.h */</a>
<a name="ln3667"> </a>
<a name="ln3668">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3669">  FT_Get_Glyph_Name( FT_Face     face,</a>
<a name="ln3670">                     FT_UInt     glyph_index,</a>
<a name="ln3671">                     FT_Pointer  buffer,</a>
<a name="ln3672">                     FT_UInt     buffer_max )</a>
<a name="ln3673">  {</a>
<a name="ln3674">    FT_Error              error;</a>
<a name="ln3675">    FT_Service_GlyphDict  service;</a>
<a name="ln3676"> </a>
<a name="ln3677"> </a>
<a name="ln3678">    if ( !face )</a>
<a name="ln3679">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln3680"> </a>
<a name="ln3681">    if ( !buffer || buffer_max == 0 )</a>
<a name="ln3682">      return FT_THROW( Invalid_Argument );</a>
<a name="ln3683"> </a>
<a name="ln3684">    /* clean up buffer */</a>
<a name="ln3685">    ((FT_Byte*)buffer)[0] = '\0';</a>
<a name="ln3686"> </a>
<a name="ln3687">    if ( (FT_Long)glyph_index &gt;= face-&gt;num_glyphs )</a>
<a name="ln3688">      return FT_THROW( Invalid_Glyph_Index );</a>
<a name="ln3689"> </a>
<a name="ln3690">    if ( !FT_HAS_GLYPH_NAMES( face ) )</a>
<a name="ln3691">      return FT_THROW( Invalid_Argument );</a>
<a name="ln3692"> </a>
<a name="ln3693">    FT_FACE_LOOKUP_SERVICE( face, service, GLYPH_DICT );</a>
<a name="ln3694">    if ( service &amp;&amp; service-&gt;get_name )</a>
<a name="ln3695">      error = service-&gt;get_name( face, glyph_index, buffer, buffer_max );</a>
<a name="ln3696">    else</a>
<a name="ln3697">      error = FT_THROW( Invalid_Argument );</a>
<a name="ln3698"> </a>
<a name="ln3699">    return error;</a>
<a name="ln3700">  }</a>
<a name="ln3701"> </a>
<a name="ln3702"> </a>
<a name="ln3703">  /* documentation is in freetype.h */</a>
<a name="ln3704"> </a>
<a name="ln3705">  FT_EXPORT_DEF( const char* )</a>
<a name="ln3706">  FT_Get_Postscript_Name( FT_Face  face )</a>
<a name="ln3707">  {</a>
<a name="ln3708">    const char*  result = NULL;</a>
<a name="ln3709"> </a>
<a name="ln3710"> </a>
<a name="ln3711">    if ( !face )</a>
<a name="ln3712">      goto Exit;</a>
<a name="ln3713"> </a>
<a name="ln3714">    if ( !result )</a>
<a name="ln3715">    {</a>
<a name="ln3716">      FT_Service_PsFontName  service;</a>
<a name="ln3717"> </a>
<a name="ln3718"> </a>
<a name="ln3719">      FT_FACE_LOOKUP_SERVICE( face,</a>
<a name="ln3720">                              service,</a>
<a name="ln3721">                              POSTSCRIPT_FONT_NAME );</a>
<a name="ln3722"> </a>
<a name="ln3723">      if ( service &amp;&amp; service-&gt;get_ps_font_name )</a>
<a name="ln3724">        result = service-&gt;get_ps_font_name( face );</a>
<a name="ln3725">    }</a>
<a name="ln3726"> </a>
<a name="ln3727">  Exit:</a>
<a name="ln3728">    return result;</a>
<a name="ln3729">  }</a>
<a name="ln3730"> </a>
<a name="ln3731"> </a>
<a name="ln3732">  /* documentation is in tttables.h */</a>
<a name="ln3733"> </a>
<a name="ln3734">  FT_EXPORT_DEF( void* )</a>
<a name="ln3735">  FT_Get_Sfnt_Table( FT_Face      face,</a>
<a name="ln3736">                     FT_Sfnt_Tag  tag )</a>
<a name="ln3737">  {</a>
<a name="ln3738">    void*                  table = NULL;</a>
<a name="ln3739">    FT_Service_SFNT_Table  service;</a>
<a name="ln3740"> </a>
<a name="ln3741"> </a>
<a name="ln3742">    if ( face &amp;&amp; FT_IS_SFNT( face ) )</a>
<a name="ln3743">    {</a>
<a name="ln3744">      FT_FACE_FIND_SERVICE( face, service, SFNT_TABLE );</a>
<a name="ln3745">      if ( service != NULL )</a>
<a name="ln3746">        table = service-&gt;get_table( face, tag );</a>
<a name="ln3747">    }</a>
<a name="ln3748"> </a>
<a name="ln3749">    return table;</a>
<a name="ln3750">  }</a>
<a name="ln3751"> </a>
<a name="ln3752"> </a>
<a name="ln3753">  /* documentation is in tttables.h */</a>
<a name="ln3754"> </a>
<a name="ln3755">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3756">  FT_Load_Sfnt_Table( FT_Face    face,</a>
<a name="ln3757">                      FT_ULong   tag,</a>
<a name="ln3758">                      FT_Long    offset,</a>
<a name="ln3759">                      FT_Byte*   buffer,</a>
<a name="ln3760">                      FT_ULong*  length )</a>
<a name="ln3761">  {</a>
<a name="ln3762">    FT_Service_SFNT_Table  service;</a>
<a name="ln3763"> </a>
<a name="ln3764"> </a>
<a name="ln3765">    if ( !face || !FT_IS_SFNT( face ) )</a>
<a name="ln3766">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln3767"> </a>
<a name="ln3768">    FT_FACE_FIND_SERVICE( face, service, SFNT_TABLE );</a>
<a name="ln3769">    if ( service == NULL )</a>
<a name="ln3770">      return FT_THROW( Unimplemented_Feature );</a>
<a name="ln3771"> </a>
<a name="ln3772">    return service-&gt;load_table( face, tag, offset, buffer, length );</a>
<a name="ln3773">  }</a>
<a name="ln3774"> </a>
<a name="ln3775"> </a>
<a name="ln3776">  /* documentation is in tttables.h */</a>
<a name="ln3777"> </a>
<a name="ln3778">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3779">  FT_Sfnt_Table_Info( FT_Face    face,</a>
<a name="ln3780">                      FT_UInt    table_index,</a>
<a name="ln3781">                      FT_ULong  *tag,</a>
<a name="ln3782">                      FT_ULong  *length )</a>
<a name="ln3783">  {</a>
<a name="ln3784">    FT_Service_SFNT_Table  service;</a>
<a name="ln3785">    FT_ULong               offset;</a>
<a name="ln3786"> </a>
<a name="ln3787"> </a>
<a name="ln3788">    /* test for valid `length' delayed to `service-&gt;table_info' */</a>
<a name="ln3789"> </a>
<a name="ln3790">    if ( !face || !FT_IS_SFNT( face ) )</a>
<a name="ln3791">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln3792"> </a>
<a name="ln3793">    FT_FACE_FIND_SERVICE( face, service, SFNT_TABLE );</a>
<a name="ln3794">    if ( service == NULL )</a>
<a name="ln3795">      return FT_THROW( Unimplemented_Feature );</a>
<a name="ln3796"> </a>
<a name="ln3797">    return service-&gt;table_info( face, table_index, tag, &amp;offset, length );</a>
<a name="ln3798">  }</a>
<a name="ln3799"> </a>
<a name="ln3800"> </a>
<a name="ln3801">  /* documentation is in tttables.h */</a>
<a name="ln3802"> </a>
<a name="ln3803">  FT_EXPORT_DEF( FT_ULong )</a>
<a name="ln3804">  FT_Get_CMap_Language_ID( FT_CharMap  charmap )</a>
<a name="ln3805">  {</a>
<a name="ln3806">    FT_Service_TTCMaps  service;</a>
<a name="ln3807">    FT_Face             face;</a>
<a name="ln3808">    TT_CMapInfo         cmap_info;</a>
<a name="ln3809"> </a>
<a name="ln3810"> </a>
<a name="ln3811">    if ( !charmap || !charmap-&gt;face )</a>
<a name="ln3812">      return 0;</a>
<a name="ln3813"> </a>
<a name="ln3814">    face = charmap-&gt;face;</a>
<a name="ln3815">    FT_FACE_FIND_SERVICE( face, service, TT_CMAP );</a>
<a name="ln3816">    if ( service == NULL )</a>
<a name="ln3817">      return 0;</a>
<a name="ln3818">    if ( service-&gt;get_cmap_info( charmap, &amp;cmap_info ))</a>
<a name="ln3819">      return 0;</a>
<a name="ln3820"> </a>
<a name="ln3821">    return cmap_info.language;</a>
<a name="ln3822">  }</a>
<a name="ln3823"> </a>
<a name="ln3824"> </a>
<a name="ln3825">  /* documentation is in tttables.h */</a>
<a name="ln3826"> </a>
<a name="ln3827">  FT_EXPORT_DEF( FT_Long )</a>
<a name="ln3828">  FT_Get_CMap_Format( FT_CharMap  charmap )</a>
<a name="ln3829">  {</a>
<a name="ln3830">    FT_Service_TTCMaps  service;</a>
<a name="ln3831">    FT_Face             face;</a>
<a name="ln3832">    TT_CMapInfo         cmap_info;</a>
<a name="ln3833"> </a>
<a name="ln3834"> </a>
<a name="ln3835">    if ( !charmap || !charmap-&gt;face )</a>
<a name="ln3836">      return -1;</a>
<a name="ln3837"> </a>
<a name="ln3838">    face = charmap-&gt;face;</a>
<a name="ln3839">    FT_FACE_FIND_SERVICE( face, service, TT_CMAP );</a>
<a name="ln3840">    if ( service == NULL )</a>
<a name="ln3841">      return -1;</a>
<a name="ln3842">    if ( service-&gt;get_cmap_info( charmap, &amp;cmap_info ))</a>
<a name="ln3843">      return -1;</a>
<a name="ln3844"> </a>
<a name="ln3845">    return cmap_info.format;</a>
<a name="ln3846">  }</a>
<a name="ln3847"> </a>
<a name="ln3848"> </a>
<a name="ln3849">  /* documentation is in ftsizes.h */</a>
<a name="ln3850"> </a>
<a name="ln3851">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln3852">  FT_Activate_Size( FT_Size  size )</a>
<a name="ln3853">  {</a>
<a name="ln3854">    FT_Face  face;</a>
<a name="ln3855"> </a>
<a name="ln3856"> </a>
<a name="ln3857">    if ( !size )</a>
<a name="ln3858">      return FT_THROW( Invalid_Size_Handle );</a>
<a name="ln3859"> </a>
<a name="ln3860">    face = size-&gt;face;</a>
<a name="ln3861">    if ( !face || !face-&gt;driver )</a>
<a name="ln3862">      return FT_THROW( Invalid_Face_Handle );</a>
<a name="ln3863"> </a>
<a name="ln3864">    /* we don't need anything more complex than that; all size objects */</a>
<a name="ln3865">    /* are already listed by the face                                  */</a>
<a name="ln3866">    face-&gt;size = size;</a>
<a name="ln3867"> </a>
<a name="ln3868">    return FT_Err_Ok;</a>
<a name="ln3869">  }</a>
<a name="ln3870"> </a>
<a name="ln3871"> </a>
<a name="ln3872">  /*************************************************************************/</a>
<a name="ln3873">  /*************************************************************************/</a>
<a name="ln3874">  /*************************************************************************/</a>
<a name="ln3875">  /****                                                                 ****/</a>
<a name="ln3876">  /****                                                                 ****/</a>
<a name="ln3877">  /****                        R E N D E R E R S                        ****/</a>
<a name="ln3878">  /****                                                                 ****/</a>
<a name="ln3879">  /****                                                                 ****/</a>
<a name="ln3880">  /*************************************************************************/</a>
<a name="ln3881">  /*************************************************************************/</a>
<a name="ln3882">  /*************************************************************************/</a>
<a name="ln3883"> </a>
<a name="ln3884">  /* lookup a renderer by glyph format in the library's list */</a>
<a name="ln3885">  FT_BASE_DEF( FT_Renderer )</a>
<a name="ln3886">  FT_Lookup_Renderer( FT_Library       library,</a>
<a name="ln3887">                      FT_Glyph_Format  format,</a>
<a name="ln3888">                      FT_ListNode*     node )</a>
<a name="ln3889">  {</a>
<a name="ln3890">    FT_ListNode  cur;</a>
<a name="ln3891">    FT_Renderer  result = NULL;</a>
<a name="ln3892"> </a>
<a name="ln3893"> </a>
<a name="ln3894">    if ( !library )</a>
<a name="ln3895">      goto Exit;</a>
<a name="ln3896"> </a>
<a name="ln3897">    cur = library-&gt;renderers.head;</a>
<a name="ln3898"> </a>
<a name="ln3899">    if ( node )</a>
<a name="ln3900">    {</a>
<a name="ln3901">      if ( *node )</a>
<a name="ln3902">        cur = (*node)-&gt;next;</a>
<a name="ln3903">      *node = NULL;</a>
<a name="ln3904">    }</a>
<a name="ln3905"> </a>
<a name="ln3906">    while ( cur )</a>
<a name="ln3907">    {</a>
<a name="ln3908">      FT_Renderer  renderer = FT_RENDERER( cur-&gt;data );</a>
<a name="ln3909"> </a>
<a name="ln3910"> </a>
<a name="ln3911">      if ( renderer-&gt;glyph_format == format )</a>
<a name="ln3912">      {</a>
<a name="ln3913">        if ( node )</a>
<a name="ln3914">          *node = cur;</a>
<a name="ln3915"> </a>
<a name="ln3916">        result = renderer;</a>
<a name="ln3917">        break;</a>
<a name="ln3918">      }</a>
<a name="ln3919">      cur = cur-&gt;next;</a>
<a name="ln3920">    }</a>
<a name="ln3921"> </a>
<a name="ln3922">  Exit:</a>
<a name="ln3923">    return result;</a>
<a name="ln3924">  }</a>
<a name="ln3925"> </a>
<a name="ln3926"> </a>
<a name="ln3927">  static FT_Renderer</a>
<a name="ln3928">  ft_lookup_glyph_renderer( FT_GlyphSlot  slot )</a>
<a name="ln3929">  {</a>
<a name="ln3930">    FT_Face      face    = slot-&gt;face;</a>
<a name="ln3931">    FT_Library   library = FT_FACE_LIBRARY( face );</a>
<a name="ln3932">    FT_Renderer  result  = library-&gt;cur_renderer;</a>
<a name="ln3933"> </a>
<a name="ln3934"> </a>
<a name="ln3935">    if ( !result || result-&gt;glyph_format != slot-&gt;format )</a>
<a name="ln3936">      result = FT_Lookup_Renderer( library, slot-&gt;format, 0 );</a>
<a name="ln3937"> </a>
<a name="ln3938">    return result;</a>
<a name="ln3939">  }</a>
<a name="ln3940"> </a>
<a name="ln3941"> </a>
<a name="ln3942">  static void</a>
<a name="ln3943">  ft_set_current_renderer( FT_Library  library )</a>
<a name="ln3944">  {</a>
<a name="ln3945">    FT_Renderer  renderer;</a>
<a name="ln3946"> </a>
<a name="ln3947"> </a>
<a name="ln3948">    renderer = FT_Lookup_Renderer( library, FT_GLYPH_FORMAT_OUTLINE, 0 );</a>
<a name="ln3949">    library-&gt;cur_renderer = renderer;</a>
<a name="ln3950">  }</a>
<a name="ln3951"> </a>
<a name="ln3952"> </a>
<a name="ln3953">  static FT_Error</a>
<a name="ln3954">  ft_add_renderer( FT_Module  module )</a>
<a name="ln3955">  {</a>
<a name="ln3956">    FT_Library   library = module-&gt;library;</a>
<a name="ln3957">    FT_Memory    memory  = library-&gt;memory;</a>
<a name="ln3958">    FT_Error     error;</a>
<a name="ln3959">    FT_ListNode  node    = NULL;</a>
<a name="ln3960"> </a>
<a name="ln3961"> </a>
<a name="ln3962">    if ( FT_NEW( node ) )</a>
<a name="ln3963">      goto Exit;</a>
<a name="ln3964"> </a>
<a name="ln3965">    {</a>
<a name="ln3966">      FT_Renderer         render = FT_RENDERER( module );</a>
<a name="ln3967">      FT_Renderer_Class*  clazz  = (FT_Renderer_Class*)module-&gt;clazz;</a>
<a name="ln3968"> </a>
<a name="ln3969"> </a>
<a name="ln3970">      render-&gt;clazz        = clazz;</a>
<a name="ln3971">      render-&gt;glyph_format = clazz-&gt;glyph_format;</a>
<a name="ln3972"> </a>
<a name="ln3973">      /* allocate raster object if needed */</a>
<a name="ln3974">      if ( clazz-&gt;glyph_format == FT_GLYPH_FORMAT_OUTLINE &amp;&amp;</a>
<a name="ln3975">           clazz-&gt;raster_class-&gt;raster_new                )</a>
<a name="ln3976">      {</a>
<a name="ln3977">        error = clazz-&gt;raster_class-&gt;raster_new( memory, &amp;render-&gt;raster );</a>
<a name="ln3978">        if ( error )</a>
<a name="ln3979">          goto Fail;</a>
<a name="ln3980"> </a>
<a name="ln3981">        render-&gt;raster_render = clazz-&gt;raster_class-&gt;raster_render;</a>
<a name="ln3982">        render-&gt;render        = clazz-&gt;render_glyph;</a>
<a name="ln3983">      }</a>
<a name="ln3984"> </a>
<a name="ln3985">      /* add to list */</a>
<a name="ln3986">      node-&gt;data = module;</a>
<a name="ln3987">      FT_List_Add( &amp;library-&gt;renderers, node );</a>
<a name="ln3988"> </a>
<a name="ln3989">      ft_set_current_renderer( library );</a>
<a name="ln3990">    }</a>
<a name="ln3991"> </a>
<a name="ln3992">  Fail:</a>
<a name="ln3993">    if ( error )</a>
<a name="ln3994">      FT_FREE( node );</a>
<a name="ln3995"> </a>
<a name="ln3996">  Exit:</a>
<a name="ln3997">    return error;</a>
<a name="ln3998">  }</a>
<a name="ln3999"> </a>
<a name="ln4000"> </a>
<a name="ln4001">  static void</a>
<a name="ln4002">  ft_remove_renderer( FT_Module  module )</a>
<a name="ln4003">  {</a>
<a name="ln4004">    FT_Library   library;</a>
<a name="ln4005">    FT_Memory    memory;</a>
<a name="ln4006">    FT_ListNode  node;</a>
<a name="ln4007"> </a>
<a name="ln4008"> </a>
<a name="ln4009">    library = module-&gt;library;</a>
<a name="ln4010">    if ( !library )</a>
<a name="ln4011">      return;</a>
<a name="ln4012"> </a>
<a name="ln4013">    memory = library-&gt;memory;</a>
<a name="ln4014"> </a>
<a name="ln4015">    node = FT_List_Find( &amp;library-&gt;renderers, module );</a>
<a name="ln4016">    if ( node )</a>
<a name="ln4017">    {</a>
<a name="ln4018">      FT_Renderer  render = FT_RENDERER( module );</a>
<a name="ln4019"> </a>
<a name="ln4020"> </a>
<a name="ln4021">      /* release raster object, if any */</a>
<a name="ln4022">      if ( render-&gt;clazz-&gt;glyph_format == FT_GLYPH_FORMAT_OUTLINE &amp;&amp;</a>
<a name="ln4023">           render-&gt;raster                                         )</a>
<a name="ln4024">        render-&gt;clazz-&gt;raster_class-&gt;raster_done( render-&gt;raster );</a>
<a name="ln4025"> </a>
<a name="ln4026">      /* remove from list */</a>
<a name="ln4027">      FT_List_Remove( &amp;library-&gt;renderers, node );</a>
<a name="ln4028">      FT_FREE( node );</a>
<a name="ln4029"> </a>
<a name="ln4030">      ft_set_current_renderer( library );</a>
<a name="ln4031">    }</a>
<a name="ln4032">  }</a>
<a name="ln4033"> </a>
<a name="ln4034"> </a>
<a name="ln4035">  /* documentation is in ftrender.h */</a>
<a name="ln4036"> </a>
<a name="ln4037">  FT_EXPORT_DEF( FT_Renderer )</a>
<a name="ln4038">  FT_Get_Renderer( FT_Library       library,</a>
<a name="ln4039">                   FT_Glyph_Format  format )</a>
<a name="ln4040">  {</a>
<a name="ln4041">    /* test for valid `library' delayed to `FT_Lookup_Renderer' */</a>
<a name="ln4042"> </a>
<a name="ln4043">    return FT_Lookup_Renderer( library, format, 0 );</a>
<a name="ln4044">  }</a>
<a name="ln4045"> </a>
<a name="ln4046"> </a>
<a name="ln4047">  /* documentation is in ftrender.h */</a>
<a name="ln4048"> </a>
<a name="ln4049">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4050">  FT_Set_Renderer( FT_Library     library,</a>
<a name="ln4051">                   FT_Renderer    renderer,</a>
<a name="ln4052">                   FT_UInt        num_params,</a>
<a name="ln4053">                   FT_Parameter*  parameters )</a>
<a name="ln4054">  {</a>
<a name="ln4055">    FT_ListNode  node;</a>
<a name="ln4056">    FT_Error     error = FT_Err_Ok;</a>
<a name="ln4057"> </a>
<a name="ln4058">    FT_Renderer_SetModeFunc  set_mode;</a>
<a name="ln4059"> </a>
<a name="ln4060"> </a>
<a name="ln4061">    if ( !library )</a>
<a name="ln4062">    {</a>
<a name="ln4063">      error = FT_THROW( Invalid_Library_Handle );</a>
<a name="ln4064">      goto Exit;</a>
<a name="ln4065">    }</a>
<a name="ln4066"> </a>
<a name="ln4067">    if ( !renderer )</a>
<a name="ln4068">    {</a>
<a name="ln4069">      error = FT_THROW( Invalid_Argument );</a>
<a name="ln4070">      goto Exit;</a>
<a name="ln4071">    }</a>
<a name="ln4072"> </a>
<a name="ln4073">    if ( num_params &gt; 0 &amp;&amp; !parameters )</a>
<a name="ln4074">    {</a>
<a name="ln4075">      error = FT_THROW( Invalid_Argument );</a>
<a name="ln4076">      goto Exit;</a>
<a name="ln4077">    }</a>
<a name="ln4078"> </a>
<a name="ln4079">    node = FT_List_Find( &amp;library-&gt;renderers, renderer );</a>
<a name="ln4080">    if ( !node )</a>
<a name="ln4081">    {</a>
<a name="ln4082">      error = FT_THROW( Invalid_Argument );</a>
<a name="ln4083">      goto Exit;</a>
<a name="ln4084">    }</a>
<a name="ln4085"> </a>
<a name="ln4086">    FT_List_Up( &amp;library-&gt;renderers, node );</a>
<a name="ln4087"> </a>
<a name="ln4088">    if ( renderer-&gt;glyph_format == FT_GLYPH_FORMAT_OUTLINE )</a>
<a name="ln4089">      library-&gt;cur_renderer = renderer;</a>
<a name="ln4090"> </a>
<a name="ln4091">    set_mode = renderer-&gt;clazz-&gt;set_mode;</a>
<a name="ln4092"> </a>
<a name="ln4093">    for ( ; num_params &gt; 0; num_params-- )</a>
<a name="ln4094">    {</a>
<a name="ln4095">      error = set_mode( renderer, parameters-&gt;tag, parameters-&gt;data );</a>
<a name="ln4096">      if ( error )</a>
<a name="ln4097">        break;</a>
<a name="ln4098">      parameters++;</a>
<a name="ln4099">    }</a>
<a name="ln4100"> </a>
<a name="ln4101">  Exit:</a>
<a name="ln4102">    return error;</a>
<a name="ln4103">  }</a>
<a name="ln4104"> </a>
<a name="ln4105"> </a>
<a name="ln4106">  FT_BASE_DEF( FT_Error )</a>
<a name="ln4107">  FT_Render_Glyph_Internal( FT_Library      library,</a>
<a name="ln4108">                            FT_GlyphSlot    slot,</a>
<a name="ln4109">                            FT_Render_Mode  render_mode )</a>
<a name="ln4110">  {</a>
<a name="ln4111">    FT_Error     error = FT_Err_Ok;</a>
<a name="ln4112">    FT_Renderer  renderer;</a>
<a name="ln4113"> </a>
<a name="ln4114"> </a>
<a name="ln4115">    /* if it is already a bitmap, no need to do anything */</a>
<a name="ln4116">    switch ( slot-&gt;format )</a>
<a name="ln4117">    {</a>
<a name="ln4118">    case FT_GLYPH_FORMAT_BITMAP:   /* already a bitmap, don't do anything */</a>
<a name="ln4119">      break;</a>
<a name="ln4120"> </a>
<a name="ln4121">    default:</a>
<a name="ln4122">      {</a>
<a name="ln4123">        FT_ListNode  node = NULL;</a>
<a name="ln4124"> </a>
<a name="ln4125"> </a>
<a name="ln4126">        /* small shortcut for the very common case */</a>
<a name="ln4127">        if ( slot-&gt;format == FT_GLYPH_FORMAT_OUTLINE )</a>
<a name="ln4128">        {</a>
<a name="ln4129">          renderer = library-&gt;cur_renderer;</a>
<a name="ln4130">          node     = library-&gt;renderers.head;</a>
<a name="ln4131">        }</a>
<a name="ln4132">        else</a>
<a name="ln4133">          renderer = FT_Lookup_Renderer( library, slot-&gt;format, &amp;node );</a>
<a name="ln4134"> </a>
<a name="ln4135">        error = FT_ERR( Unimplemented_Feature );</a>
<a name="ln4136">        while ( renderer )</a>
<a name="ln4137">        {</a>
<a name="ln4138">          error = renderer-&gt;render( renderer, slot, render_mode, NULL );</a>
<a name="ln4139">          if ( !error                                   ||</a>
<a name="ln4140">               FT_ERR_NEQ( error, Cannot_Render_Glyph ) )</a>
<a name="ln4141">            break;</a>
<a name="ln4142"> </a>
<a name="ln4143">          /* FT_Err_Cannot_Render_Glyph is returned if the render mode   */</a>
<a name="ln4144">          /* is unsupported by the current renderer for this glyph image */</a>
<a name="ln4145">          /* format.                                                     */</a>
<a name="ln4146"> </a>
<a name="ln4147">          /* now, look for another renderer that supports the same */</a>
<a name="ln4148">          /* format.                                               */</a>
<a name="ln4149">          renderer = FT_Lookup_Renderer( library, slot-&gt;format, &amp;node );</a>
<a name="ln4150">        }</a>
<a name="ln4151">      }</a>
<a name="ln4152">    }</a>
<a name="ln4153"> </a>
<a name="ln4154">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln4155"> </a>
<a name="ln4156">#undef  FT_COMPONENT</a>
<a name="ln4157">#define FT_COMPONENT  trace_bitmap</a>
<a name="ln4158"> </a>
<a name="ln4159">    /* we convert to a single bitmap format for computing the checksum */</a>
<a name="ln4160">    if ( !error )</a>
<a name="ln4161">    {</a>
<a name="ln4162">      FT_Bitmap  bitmap;</a>
<a name="ln4163">      FT_Error   err;</a>
<a name="ln4164"> </a>
<a name="ln4165"> </a>
<a name="ln4166">      FT_Bitmap_Init( &amp;bitmap );</a>
<a name="ln4167"> </a>
<a name="ln4168">      /* this also converts the bitmap flow to `down' (i.e., pitch &gt; 0) */</a>
<a name="ln4169">      err = FT_Bitmap_Convert( library, &amp;slot-&gt;bitmap, &amp;bitmap, 1 );</a>
<a name="ln4170">      if ( !err )</a>
<a name="ln4171">      {</a>
<a name="ln4172">        MD5_CTX        ctx;</a>
<a name="ln4173">        unsigned char  md5[16];</a>
<a name="ln4174">        int            i;</a>
<a name="ln4175">        unsigned int   rows  = bitmap.rows;</a>
<a name="ln4176">        unsigned int   pitch = (unsigned int)bitmap.pitch;</a>
<a name="ln4177"> </a>
<a name="ln4178"> </a>
<a name="ln4179">        MD5_Init( &amp;ctx );</a>
<a name="ln4180">        MD5_Update( &amp;ctx, bitmap.buffer, rows * pitch );</a>
<a name="ln4181">        MD5_Final( md5, &amp;ctx );</a>
<a name="ln4182"> </a>
<a name="ln4183">        FT_TRACE3(( &quot;MD5 checksum for %dx%d bitmap:\n&quot;</a>
<a name="ln4184">                    &quot;  &quot;,</a>
<a name="ln4185">                    rows, pitch ));</a>
<a name="ln4186">        for ( i = 0; i &lt; 16; i++ )</a>
<a name="ln4187">          FT_TRACE3(( &quot;%02X&quot;, md5[i] ));</a>
<a name="ln4188">        FT_TRACE3(( &quot;\n&quot; ));</a>
<a name="ln4189">      }</a>
<a name="ln4190"> </a>
<a name="ln4191">      FT_Bitmap_Done( library, &amp;bitmap );</a>
<a name="ln4192">    }</a>
<a name="ln4193"> </a>
<a name="ln4194">#undef  FT_COMPONENT</a>
<a name="ln4195">#define FT_COMPONENT  trace_objs</a>
<a name="ln4196"> </a>
<a name="ln4197">#endif /* FT_DEBUG_LEVEL_TRACE */</a>
<a name="ln4198"> </a>
<a name="ln4199">    return error;</a>
<a name="ln4200">  }</a>
<a name="ln4201"> </a>
<a name="ln4202"> </a>
<a name="ln4203">  /* documentation is in freetype.h */</a>
<a name="ln4204"> </a>
<a name="ln4205">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4206">  FT_Render_Glyph( FT_GlyphSlot    slot,</a>
<a name="ln4207">                   FT_Render_Mode  render_mode )</a>
<a name="ln4208">  {</a>
<a name="ln4209">    FT_Library  library;</a>
<a name="ln4210"> </a>
<a name="ln4211"> </a>
<a name="ln4212">    if ( !slot || !slot-&gt;face )</a>
<a name="ln4213">      return FT_THROW( Invalid_Argument );</a>
<a name="ln4214"> </a>
<a name="ln4215">    library = FT_FACE_LIBRARY( slot-&gt;face );</a>
<a name="ln4216"> </a>
<a name="ln4217">    return FT_Render_Glyph_Internal( library, slot, render_mode );</a>
<a name="ln4218">  }</a>
<a name="ln4219"> </a>
<a name="ln4220"> </a>
<a name="ln4221">  /*************************************************************************/</a>
<a name="ln4222">  /*************************************************************************/</a>
<a name="ln4223">  /*************************************************************************/</a>
<a name="ln4224">  /****                                                                 ****/</a>
<a name="ln4225">  /****                                                                 ****/</a>
<a name="ln4226">  /****                         M O D U L E S                           ****/</a>
<a name="ln4227">  /****                                                                 ****/</a>
<a name="ln4228">  /****                                                                 ****/</a>
<a name="ln4229">  /*************************************************************************/</a>
<a name="ln4230">  /*************************************************************************/</a>
<a name="ln4231">  /*************************************************************************/</a>
<a name="ln4232"> </a>
<a name="ln4233"> </a>
<a name="ln4234">  /*************************************************************************/</a>
<a name="ln4235">  /*                                                                       */</a>
<a name="ln4236">  /* &lt;Function&gt;                                                            */</a>
<a name="ln4237">  /*    Destroy_Module                                                     */</a>
<a name="ln4238">  /*                                                                       */</a>
<a name="ln4239">  /* &lt;Description&gt;                                                         */</a>
<a name="ln4240">  /*    Destroys a given module object.  For drivers, this also destroys   */</a>
<a name="ln4241">  /*    all child faces.                                                   */</a>
<a name="ln4242">  /*                                                                       */</a>
<a name="ln4243">  /* &lt;InOut&gt;                                                               */</a>
<a name="ln4244">  /*    module :: A handle to the target driver object.                    */</a>
<a name="ln4245">  /*                                                                       */</a>
<a name="ln4246">  /* &lt;Note&gt;                                                                */</a>
<a name="ln4247">  /*    The driver _must_ be LOCKED!                                       */</a>
<a name="ln4248">  /*                                                                       */</a>
<a name="ln4249">  static void</a>
<a name="ln4250">  Destroy_Module( FT_Module  module )</a>
<a name="ln4251">  {</a>
<a name="ln4252">    FT_Memory         memory  = module-&gt;memory;</a>
<a name="ln4253">    FT_Module_Class*  clazz   = module-&gt;clazz;</a>
<a name="ln4254">    FT_Library        library = module-&gt;library;</a>
<a name="ln4255"> </a>
<a name="ln4256"> </a>
<a name="ln4257">    if ( library &amp;&amp; library-&gt;auto_hinter == module )</a>
<a name="ln4258">      library-&gt;auto_hinter = NULL;</a>
<a name="ln4259"> </a>
<a name="ln4260">    /* if the module is a renderer */</a>
<a name="ln4261">    if ( FT_MODULE_IS_RENDERER( module ) )</a>
<a name="ln4262">      ft_remove_renderer( module );</a>
<a name="ln4263"> </a>
<a name="ln4264">    /* if the module is a font driver, add some steps */</a>
<a name="ln4265">    if ( FT_MODULE_IS_DRIVER( module ) )</a>
<a name="ln4266">      Destroy_Driver( FT_DRIVER( module ) );</a>
<a name="ln4267"> </a>
<a name="ln4268">    /* finalize the module object */</a>
<a name="ln4269">    if ( clazz-&gt;module_done )</a>
<a name="ln4270">      clazz-&gt;module_done( module );</a>
<a name="ln4271"> </a>
<a name="ln4272">    /* discard it */</a>
<a name="ln4273">    FT_FREE( module );</a>
<a name="ln4274">  }</a>
<a name="ln4275"> </a>
<a name="ln4276"> </a>
<a name="ln4277">  /* documentation is in ftmodapi.h */</a>
<a name="ln4278"> </a>
<a name="ln4279">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4280">  FT_Add_Module( FT_Library              library,</a>
<a name="ln4281">                 const FT_Module_Class*  clazz )</a>
<a name="ln4282">  {</a>
<a name="ln4283">    FT_Error   error;</a>
<a name="ln4284">    FT_Memory  memory;</a>
<a name="ln4285">    FT_Module  module;</a>
<a name="ln4286">    FT_UInt    nn;</a>
<a name="ln4287"> </a>
<a name="ln4288"> </a>
<a name="ln4289">#define FREETYPE_VER_FIXED  ( ( (FT_Long)FREETYPE_MAJOR &lt;&lt; 16 ) | \</a>
<a name="ln4290">                                FREETYPE_MINOR                  )</a>
<a name="ln4291"> </a>
<a name="ln4292">    if ( !library )</a>
<a name="ln4293">      return FT_THROW( Invalid_Library_Handle );</a>
<a name="ln4294"> </a>
<a name="ln4295">    if ( !clazz )</a>
<a name="ln4296">      return FT_THROW( Invalid_Argument );</a>
<a name="ln4297"> </a>
<a name="ln4298">    /* check freetype version */</a>
<a name="ln4299">    if ( clazz-&gt;module_requires &gt; FREETYPE_VER_FIXED )</a>
<a name="ln4300">      return FT_THROW( Invalid_Version );</a>
<a name="ln4301"> </a>
<a name="ln4302">    /* look for a module with the same name in the library's table */</a>
<a name="ln4303">    for ( nn = 0; nn &lt; library-&gt;num_modules; nn++ )</a>
<a name="ln4304">    {</a>
<a name="ln4305">      module = library-&gt;modules[nn];</a>
<a name="ln4306">      if ( ft_strcmp( module-&gt;clazz-&gt;module_name, clazz-&gt;module_name ) == 0 )</a>
<a name="ln4307">      {</a>
<a name="ln4308">        /* this installed module has the same name, compare their versions */</a>
<a name="ln4309">        if ( clazz-&gt;module_version &lt;= module-&gt;clazz-&gt;module_version )</a>
<a name="ln4310">          return FT_THROW( Lower_Module_Version );</a>
<a name="ln4311"> </a>
<a name="ln4312">        /* remove the module from our list, then exit the loop to replace */</a>
<a name="ln4313">        /* it by our new version..                                        */</a>
<a name="ln4314">        FT_Remove_Module( library, module );</a>
<a name="ln4315">        break;</a>
<a name="ln4316">      }</a>
<a name="ln4317">    }</a>
<a name="ln4318"> </a>
<a name="ln4319">    memory = library-&gt;memory;</a>
<a name="ln4320">    error  = FT_Err_Ok;</a>
<a name="ln4321"> </a>
<a name="ln4322">    if ( library-&gt;num_modules &gt;= FT_MAX_MODULES )</a>
<a name="ln4323">    {</a>
<a name="ln4324">      error = FT_THROW( Too_Many_Drivers );</a>
<a name="ln4325">      goto Exit;</a>
<a name="ln4326">    }</a>
<a name="ln4327"> </a>
<a name="ln4328">    /* allocate module object */</a>
<a name="ln4329">    if ( FT_ALLOC( module, clazz-&gt;module_size ) )</a>
<a name="ln4330">      goto Exit;</a>
<a name="ln4331"> </a>
<a name="ln4332">    /* base initialization */</a>
<a name="ln4333">    module-&gt;library = library;</a>
<a name="ln4334">    module-&gt;memory  = memory;</a>
<a name="ln4335">    module-&gt;clazz   = (FT_Module_Class*)clazz;</a>
<a name="ln4336"> </a>
<a name="ln4337">    /* check whether the module is a renderer - this must be performed */</a>
<a name="ln4338">    /* before the normal module initialization                         */</a>
<a name="ln4339">    if ( FT_MODULE_IS_RENDERER( module ) )</a>
<a name="ln4340">    {</a>
<a name="ln4341">      /* add to the renderers list */</a>
<a name="ln4342">      error = ft_add_renderer( module );</a>
<a name="ln4343">      if ( error )</a>
<a name="ln4344">        goto Fail;</a>
<a name="ln4345">    }</a>
<a name="ln4346"> </a>
<a name="ln4347">    /* is the module a auto-hinter? */</a>
<a name="ln4348">    if ( FT_MODULE_IS_HINTER( module ) )</a>
<a name="ln4349">      library-&gt;auto_hinter = module;</a>
<a name="ln4350"> </a>
<a name="ln4351">    /* if the module is a font driver */</a>
<a name="ln4352">    if ( FT_MODULE_IS_DRIVER( module ) )</a>
<a name="ln4353">    {</a>
<a name="ln4354">      FT_Driver  driver = FT_DRIVER( module );</a>
<a name="ln4355"> </a>
<a name="ln4356"> </a>
<a name="ln4357">      driver-&gt;clazz = (FT_Driver_Class)module-&gt;clazz;</a>
<a name="ln4358">    }</a>
<a name="ln4359"> </a>
<a name="ln4360">    if ( clazz-&gt;module_init )</a>
<a name="ln4361">    {</a>
<a name="ln4362">      error = clazz-&gt;module_init( module );</a>
<a name="ln4363">      if ( error )</a>
<a name="ln4364">        goto Fail;</a>
<a name="ln4365">    }</a>
<a name="ln4366"> </a>
<a name="ln4367">    /* add module to the library's table */</a>
<a name="ln4368">    library-&gt;modules[library-&gt;num_modules++] = module;</a>
<a name="ln4369"> </a>
<a name="ln4370">  Exit:</a>
<a name="ln4371">    return error;</a>
<a name="ln4372"> </a>
<a name="ln4373">  Fail:</a>
<a name="ln4374">    if ( FT_MODULE_IS_RENDERER( module ) )</a>
<a name="ln4375">    {</a>
<a name="ln4376">      FT_Renderer  renderer = FT_RENDERER( module );</a>
<a name="ln4377"> </a>
<a name="ln4378"> </a>
<a name="ln4379">      if ( renderer-&gt;clazz                                          &amp;&amp;</a>
<a name="ln4380">           renderer-&gt;clazz-&gt;glyph_format == FT_GLYPH_FORMAT_OUTLINE &amp;&amp;</a>
<a name="ln4381">           renderer-&gt;raster                                         )</a>
<a name="ln4382">        renderer-&gt;clazz-&gt;raster_class-&gt;raster_done( renderer-&gt;raster );</a>
<a name="ln4383">    }</a>
<a name="ln4384"> </a>
<a name="ln4385">    FT_FREE( module );</a>
<a name="ln4386">    goto Exit;</a>
<a name="ln4387">  }</a>
<a name="ln4388"> </a>
<a name="ln4389"> </a>
<a name="ln4390">  /* documentation is in ftmodapi.h */</a>
<a name="ln4391"> </a>
<a name="ln4392">  FT_EXPORT_DEF( FT_Module )</a>
<a name="ln4393">  FT_Get_Module( FT_Library   library,</a>
<a name="ln4394">                 const char*  module_name )</a>
<a name="ln4395">  {</a>
<a name="ln4396">    FT_Module   result = NULL;</a>
<a name="ln4397">    FT_Module*  cur;</a>
<a name="ln4398">    FT_Module*  limit;</a>
<a name="ln4399"> </a>
<a name="ln4400"> </a>
<a name="ln4401">    if ( !library || !module_name )</a>
<a name="ln4402">      return result;</a>
<a name="ln4403"> </a>
<a name="ln4404">    cur   = library-&gt;modules;</a>
<a name="ln4405">    limit = cur + library-&gt;num_modules;</a>
<a name="ln4406"> </a>
<a name="ln4407">    for ( ; cur &lt; limit; cur++ )</a>
<a name="ln4408">      if ( ft_strcmp( cur[0]-&gt;clazz-&gt;module_name, module_name ) == 0 )</a>
<a name="ln4409">      {</a>
<a name="ln4410">        result = cur[0];</a>
<a name="ln4411">        break;</a>
<a name="ln4412">      }</a>
<a name="ln4413"> </a>
<a name="ln4414">    return result;</a>
<a name="ln4415">  }</a>
<a name="ln4416"> </a>
<a name="ln4417"> </a>
<a name="ln4418">  /* documentation is in ftobjs.h */</a>
<a name="ln4419"> </a>
<a name="ln4420">  FT_BASE_DEF( const void* )</a>
<a name="ln4421">  FT_Get_Module_Interface( FT_Library   library,</a>
<a name="ln4422">                           const char*  mod_name )</a>
<a name="ln4423">  {</a>
<a name="ln4424">    FT_Module  module;</a>
<a name="ln4425"> </a>
<a name="ln4426"> </a>
<a name="ln4427">    /* test for valid `library' delayed to FT_Get_Module() */</a>
<a name="ln4428"> </a>
<a name="ln4429">    module = FT_Get_Module( library, mod_name );</a>
<a name="ln4430"> </a>
<a name="ln4431">    return module ? module-&gt;clazz-&gt;module_interface : 0;</a>
<a name="ln4432">  }</a>
<a name="ln4433"> </a>
<a name="ln4434"> </a>
<a name="ln4435">  FT_BASE_DEF( FT_Pointer )</a>
<a name="ln4436">  ft_module_get_service( FT_Module    module,</a>
<a name="ln4437">                         const char*  service_id )</a>
<a name="ln4438">  {</a>
<a name="ln4439">    FT_Pointer  result = NULL;</a>
<a name="ln4440"> </a>
<a name="ln4441"> </a>
<a name="ln4442">    if ( module )</a>
<a name="ln4443">    {</a>
<a name="ln4444">      FT_ASSERT( module-&gt;clazz &amp;&amp; module-&gt;clazz-&gt;get_interface );</a>
<a name="ln4445"> </a>
<a name="ln4446">      /* first, look for the service in the module */</a>
<a name="ln4447">      if ( module-&gt;clazz-&gt;get_interface )</a>
<a name="ln4448">        result = module-&gt;clazz-&gt;get_interface( module, service_id );</a>
<a name="ln4449"> </a>
<a name="ln4450">      if ( result == NULL )</a>
<a name="ln4451">      {</a>
<a name="ln4452">        /* we didn't find it, look in all other modules then */</a>
<a name="ln4453">        FT_Library  library = module-&gt;library;</a>
<a name="ln4454">        FT_Module*  cur     = library-&gt;modules;</a>
<a name="ln4455">        FT_Module*  limit   = cur + library-&gt;num_modules;</a>
<a name="ln4456"> </a>
<a name="ln4457"> </a>
<a name="ln4458">        for ( ; cur &lt; limit; cur++ )</a>
<a name="ln4459">        {</a>
<a name="ln4460">          if ( cur[0] != module )</a>
<a name="ln4461">          {</a>
<a name="ln4462">            FT_ASSERT( cur[0]-&gt;clazz );</a>
<a name="ln4463"> </a>
<a name="ln4464">            if ( cur[0]-&gt;clazz-&gt;get_interface )</a>
<a name="ln4465">            {</a>
<a name="ln4466">              result = cur[0]-&gt;clazz-&gt;get_interface( cur[0], service_id );</a>
<a name="ln4467">              if ( result != NULL )</a>
<a name="ln4468">                break;</a>
<a name="ln4469">            }</a>
<a name="ln4470">          }</a>
<a name="ln4471">        }</a>
<a name="ln4472">      }</a>
<a name="ln4473">    }</a>
<a name="ln4474"> </a>
<a name="ln4475">    return result;</a>
<a name="ln4476">  }</a>
<a name="ln4477"> </a>
<a name="ln4478"> </a>
<a name="ln4479">  /* documentation is in ftmodapi.h */</a>
<a name="ln4480"> </a>
<a name="ln4481">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4482">  FT_Remove_Module( FT_Library  library,</a>
<a name="ln4483">                    FT_Module   module )</a>
<a name="ln4484">  {</a>
<a name="ln4485">    /* try to find the module from the table, then remove it from there */</a>
<a name="ln4486"> </a>
<a name="ln4487">    if ( !library )</a>
<a name="ln4488">      return FT_THROW( Invalid_Library_Handle );</a>
<a name="ln4489"> </a>
<a name="ln4490">    if ( module )</a>
<a name="ln4491">    {</a>
<a name="ln4492">      FT_Module*  cur   = library-&gt;modules;</a>
<a name="ln4493">      FT_Module*  limit = cur + library-&gt;num_modules;</a>
<a name="ln4494"> </a>
<a name="ln4495"> </a>
<a name="ln4496">      for ( ; cur &lt; limit; cur++ )</a>
<a name="ln4497">      {</a>
<a name="ln4498">        if ( cur[0] == module )</a>
<a name="ln4499">        {</a>
<a name="ln4500">          /* remove it from the table */</a>
<a name="ln4501">          library-&gt;num_modules--;</a>
<a name="ln4502">          limit--;</a>
<a name="ln4503">          while ( cur &lt; limit )</a>
<a name="ln4504">          {</a>
<a name="ln4505">            cur[0] = cur[1];</a>
<a name="ln4506">            cur++;</a>
<a name="ln4507">          }</a>
<a name="ln4508">          limit[0] = NULL;</a>
<a name="ln4509"> </a>
<a name="ln4510">          /* destroy the module */</a>
<a name="ln4511">          Destroy_Module( module );</a>
<a name="ln4512"> </a>
<a name="ln4513">          return FT_Err_Ok;</a>
<a name="ln4514">        }</a>
<a name="ln4515">      }</a>
<a name="ln4516">    }</a>
<a name="ln4517">    return FT_THROW( Invalid_Driver_Handle );</a>
<a name="ln4518">  }</a>
<a name="ln4519"> </a>
<a name="ln4520"> </a>
<a name="ln4521">  static FT_Error</a>
<a name="ln4522">  ft_property_do( FT_Library        library,</a>
<a name="ln4523">                  const FT_String*  module_name,</a>
<a name="ln4524">                  const FT_String*  property_name,</a>
<a name="ln4525">                  void*             value,</a>
<a name="ln4526">                  FT_Bool           set )</a>
<a name="ln4527">  {</a>
<a name="ln4528">    FT_Module*           cur;</a>
<a name="ln4529">    FT_Module*           limit;</a>
<a name="ln4530">    FT_Module_Interface  interface;</a>
<a name="ln4531"> </a>
<a name="ln4532">    FT_Service_Properties  service;</a>
<a name="ln4533"> </a>
<a name="ln4534">#ifdef FT_DEBUG_LEVEL_ERROR</a>
<a name="ln4535">    const FT_String*  set_name  = &quot;FT_Property_Set&quot;;</a>
<a name="ln4536">    const FT_String*  get_name  = &quot;FT_Property_Get&quot;;</a>
<a name="ln4537">    const FT_String*  func_name = set ? set_name : get_name;</a>
<a name="ln4538">#endif</a>
<a name="ln4539"> </a>
<a name="ln4540">    FT_Bool  missing_func;</a>
<a name="ln4541"> </a>
<a name="ln4542"> </a>
<a name="ln4543">    if ( !library )</a>
<a name="ln4544">      return FT_THROW( Invalid_Library_Handle );</a>
<a name="ln4545"> </a>
<a name="ln4546">    if ( !module_name || !property_name || !value )</a>
<a name="ln4547">      return FT_THROW( Invalid_Argument );</a>
<a name="ln4548"> </a>
<a name="ln4549">    cur   = library-&gt;modules;</a>
<a name="ln4550">    limit = cur + library-&gt;num_modules;</a>
<a name="ln4551"> </a>
<a name="ln4552">    /* search module */</a>
<a name="ln4553">    for ( ; cur &lt; limit; cur++ )</a>
<a name="ln4554">      if ( !ft_strcmp( cur[0]-&gt;clazz-&gt;module_name, module_name ) )</a>
<a name="ln4555">        break;</a>
<a name="ln4556"> </a>
<a name="ln4557">    if ( cur == limit )</a>
<a name="ln4558">    {</a>
<a name="ln4559">      FT_ERROR(( &quot;%s: can't find module `%s'\n&quot;,</a>
<a name="ln4560">                 func_name, module_name ));</a>
<a name="ln4561">      return FT_THROW( Missing_Module );</a>
<a name="ln4562">    }</a>
<a name="ln4563"> </a>
<a name="ln4564">    /* check whether we have a service interface */</a>
<a name="ln4565">    if ( !cur[0]-&gt;clazz-&gt;get_interface )</a>
<a name="ln4566">    {</a>
<a name="ln4567">      FT_ERROR(( &quot;%s: module `%s' doesn't support properties\n&quot;,</a>
<a name="ln4568">                 func_name, module_name ));</a>
<a name="ln4569">      return FT_THROW( Unimplemented_Feature );</a>
<a name="ln4570">    }</a>
<a name="ln4571"> </a>
<a name="ln4572">    /* search property service */</a>
<a name="ln4573">    interface = cur[0]-&gt;clazz-&gt;get_interface( cur[0],</a>
<a name="ln4574">                                              FT_SERVICE_ID_PROPERTIES );</a>
<a name="ln4575">    if ( !interface )</a>
<a name="ln4576">    {</a>
<a name="ln4577">      FT_ERROR(( &quot;%s: module `%s' doesn't support properties\n&quot;,</a>
<a name="ln4578">                 func_name, module_name ));</a>
<a name="ln4579">      return FT_THROW( Unimplemented_Feature );</a>
<a name="ln4580">    }</a>
<a name="ln4581"> </a>
<a name="ln4582">    service = (FT_Service_Properties)interface;</a>
<a name="ln4583"> </a>
<a name="ln4584">    if ( set )</a>
<a name="ln4585">      missing_func = (FT_Bool)( !service-&gt;set_property );</a>
<a name="ln4586">    else</a>
<a name="ln4587">      missing_func = (FT_Bool)( !service-&gt;get_property );</a>
<a name="ln4588"> </a>
<a name="ln4589">    if ( missing_func )</a>
<a name="ln4590">    {</a>
<a name="ln4591">      FT_ERROR(( &quot;%s: property service of module `%s' is broken\n&quot;,</a>
<a name="ln4592">                 func_name, module_name ));</a>
<a name="ln4593">      return FT_THROW( Unimplemented_Feature );</a>
<a name="ln4594">    }</a>
<a name="ln4595"> </a>
<a name="ln4596">    return set ? service-&gt;set_property( cur[0], property_name, value )</a>
<a name="ln4597">               : service-&gt;get_property( cur[0], property_name, value );</a>
<a name="ln4598">  }</a>
<a name="ln4599"> </a>
<a name="ln4600"> </a>
<a name="ln4601">  /* documentation is in ftmodapi.h */</a>
<a name="ln4602"> </a>
<a name="ln4603">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4604">  FT_Property_Set( FT_Library        library,</a>
<a name="ln4605">                   const FT_String*  module_name,</a>
<a name="ln4606">                   const FT_String*  property_name,</a>
<a name="ln4607">                   const void*       value )</a>
<a name="ln4608">  {</a>
<a name="ln4609">    return ft_property_do( library,</a>
<a name="ln4610">                           module_name,</a>
<a name="ln4611">                           property_name,</a>
<a name="ln4612">                           (void*)value,</a>
<a name="ln4613">                           TRUE );</a>
<a name="ln4614">  }</a>
<a name="ln4615"> </a>
<a name="ln4616"> </a>
<a name="ln4617">  /* documentation is in ftmodapi.h */</a>
<a name="ln4618"> </a>
<a name="ln4619">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4620">  FT_Property_Get( FT_Library        library,</a>
<a name="ln4621">                   const FT_String*  module_name,</a>
<a name="ln4622">                   const FT_String*  property_name,</a>
<a name="ln4623">                   void*             value )</a>
<a name="ln4624">  {</a>
<a name="ln4625">    return ft_property_do( library,</a>
<a name="ln4626">                           module_name,</a>
<a name="ln4627">                           property_name,</a>
<a name="ln4628">                           value,</a>
<a name="ln4629">                           FALSE );</a>
<a name="ln4630">  }</a>
<a name="ln4631"> </a>
<a name="ln4632"> </a>
<a name="ln4633">  /*************************************************************************/</a>
<a name="ln4634">  /*************************************************************************/</a>
<a name="ln4635">  /*************************************************************************/</a>
<a name="ln4636">  /****                                                                 ****/</a>
<a name="ln4637">  /****                                                                 ****/</a>
<a name="ln4638">  /****                         L I B R A R Y                           ****/</a>
<a name="ln4639">  /****                                                                 ****/</a>
<a name="ln4640">  /****                                                                 ****/</a>
<a name="ln4641">  /*************************************************************************/</a>
<a name="ln4642">  /*************************************************************************/</a>
<a name="ln4643">  /*************************************************************************/</a>
<a name="ln4644"> </a>
<a name="ln4645"> </a>
<a name="ln4646">  /* documentation is in ftmodapi.h */</a>
<a name="ln4647"> </a>
<a name="ln4648">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4649">  FT_Reference_Library( FT_Library  library )</a>
<a name="ln4650">  {</a>
<a name="ln4651">    if ( !library )</a>
<a name="ln4652">      return FT_THROW( Invalid_Library_Handle );</a>
<a name="ln4653"> </a>
<a name="ln4654">    library-&gt;refcount++;</a>
<a name="ln4655"> </a>
<a name="ln4656">    return FT_Err_Ok;</a>
<a name="ln4657">  }</a>
<a name="ln4658"> </a>
<a name="ln4659"> </a>
<a name="ln4660">  /* documentation is in ftmodapi.h */</a>
<a name="ln4661"> </a>
<a name="ln4662">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4663">  FT_New_Library( FT_Memory    memory,</a>
<a name="ln4664">                  FT_Library  *alibrary )</a>
<a name="ln4665">  {</a>
<a name="ln4666">    FT_Library  library = NULL;</a>
<a name="ln4667">    FT_Error    error;</a>
<a name="ln4668"> </a>
<a name="ln4669"> </a>
<a name="ln4670">    if ( !memory || !alibrary )</a>
<a name="ln4671">      return FT_THROW( Invalid_Argument );</a>
<a name="ln4672"> </a>
<a name="ln4673">#ifdef FT_DEBUG_LEVEL_ERROR</a>
<a name="ln4674">    /* init debugging support */</a>
<a name="ln4675">    ft_debug_init();</a>
<a name="ln4676">#endif</a>
<a name="ln4677"> </a>
<a name="ln4678">    /* first of all, allocate the library object */</a>
<a name="ln4679">    if ( FT_NEW( library ) )</a>
<a name="ln4680">      return error;</a>
<a name="ln4681"> </a>
<a name="ln4682">    library-&gt;memory = memory;</a>
<a name="ln4683"> </a>
<a name="ln4684">#ifdef FT_CONFIG_OPTION_PIC</a>
<a name="ln4685">    /* initialize position independent code containers */</a>
<a name="ln4686">    error = ft_pic_container_init( library );</a>
<a name="ln4687">    if ( error )</a>
<a name="ln4688">      goto Fail;</a>
<a name="ln4689">#endif</a>
<a name="ln4690"> </a>
<a name="ln4691">    /* we don't use raster_pool anymore. */</a>
<a name="ln4692">    library-&gt;raster_pool_size = 0;</a>
<a name="ln4693">    library-&gt;raster_pool      = NULL;</a>
<a name="ln4694"> </a>
<a name="ln4695">    library-&gt;version_major = FREETYPE_MAJOR;</a>
<a name="ln4696">    library-&gt;version_minor = FREETYPE_MINOR;</a>
<a name="ln4697">    library-&gt;version_patch = FREETYPE_PATCH;</a>
<a name="ln4698"> </a>
<a name="ln4699">    library-&gt;refcount = 1;</a>
<a name="ln4700"> </a>
<a name="ln4701">    /* That's ok now */</a>
<a name="ln4702">    *alibrary = library;</a>
<a name="ln4703"> </a>
<a name="ln4704">    return FT_Err_Ok;</a>
<a name="ln4705"> </a>
<a name="ln4706">#ifdef FT_CONFIG_OPTION_PIC</a>
<a name="ln4707">  Fail:</a>
<a name="ln4708">    ft_pic_container_destroy( library );</a>
<a name="ln4709"> </a>
<a name="ln4710">    FT_FREE( library );</a>
<a name="ln4711">    return error;</a>
<a name="ln4712">#endif</a>
<a name="ln4713">  }</a>
<a name="ln4714"> </a>
<a name="ln4715"> </a>
<a name="ln4716">  /* documentation is in freetype.h */</a>
<a name="ln4717"> </a>
<a name="ln4718">  FT_EXPORT_DEF( void )</a>
<a name="ln4719">  FT_Library_Version( FT_Library   library,</a>
<a name="ln4720">                      FT_Int      *amajor,</a>
<a name="ln4721">                      FT_Int      *aminor,</a>
<a name="ln4722">                      FT_Int      *apatch )</a>
<a name="ln4723">  {</a>
<a name="ln4724">    FT_Int  major = 0;</a>
<a name="ln4725">    FT_Int  minor = 0;</a>
<a name="ln4726">    FT_Int  patch = 0;</a>
<a name="ln4727"> </a>
<a name="ln4728"> </a>
<a name="ln4729">    if ( library )</a>
<a name="ln4730">    {</a>
<a name="ln4731">      major = library-&gt;version_major;</a>
<a name="ln4732">      minor = library-&gt;version_minor;</a>
<a name="ln4733">      patch = library-&gt;version_patch;</a>
<a name="ln4734">    }</a>
<a name="ln4735"> </a>
<a name="ln4736">    if ( amajor )</a>
<a name="ln4737">      *amajor = major;</a>
<a name="ln4738"> </a>
<a name="ln4739">    if ( aminor )</a>
<a name="ln4740">      *aminor = minor;</a>
<a name="ln4741"> </a>
<a name="ln4742">    if ( apatch )</a>
<a name="ln4743">      *apatch = patch;</a>
<a name="ln4744">  }</a>
<a name="ln4745"> </a>
<a name="ln4746"> </a>
<a name="ln4747">  /* documentation is in ftmodapi.h */</a>
<a name="ln4748"> </a>
<a name="ln4749">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4750">  FT_Done_Library( FT_Library  library )</a>
<a name="ln4751">  {</a>
<a name="ln4752">    FT_Memory  memory;</a>
<a name="ln4753"> </a>
<a name="ln4754"> </a>
<a name="ln4755">    if ( !library )</a>
<a name="ln4756">      return FT_THROW( Invalid_Library_Handle );</a>
<a name="ln4757"> </a>
<a name="ln4758">    library-&gt;refcount--;</a>
<a name="ln4759">    if ( library-&gt;refcount &gt; 0 )</a>
<a name="ln4760">      goto Exit;</a>
<a name="ln4761"> </a>
<a name="ln4762">    memory = library-&gt;memory;</a>
<a name="ln4763"> </a>
<a name="ln4764">    /*</a>
<a name="ln4765">     * Close all faces in the library.  If we don't do this, we can have</a>
<a name="ln4766">     * some subtle memory leaks.</a>
<a name="ln4767">     *</a>
<a name="ln4768">     * Example:</a>
<a name="ln4769">     *</a>
<a name="ln4770">     *  - the cff font driver uses the pshinter module in cff_size_done</a>
<a name="ln4771">     *  - if the pshinter module is destroyed before the cff font driver,</a>
<a name="ln4772">     *    opened FT_Face objects managed by the driver are not properly</a>
<a name="ln4773">     *    destroyed, resulting in a memory leak</a>
<a name="ln4774">     *</a>
<a name="ln4775">     * Some faces are dependent on other faces, like Type42 faces that</a>
<a name="ln4776">     * depend on TrueType faces synthesized internally.</a>
<a name="ln4777">     *</a>
<a name="ln4778">     * The order of drivers should be specified in driver_name[].</a>
<a name="ln4779">     */</a>
<a name="ln4780">    {</a>
<a name="ln4781">      FT_UInt      m, n;</a>
<a name="ln4782">      const char*  driver_name[] = { &quot;type42&quot;, NULL };</a>
<a name="ln4783"> </a>
<a name="ln4784"> </a>
<a name="ln4785">      for ( m = 0;</a>
<a name="ln4786">            m &lt; sizeof ( driver_name ) / sizeof ( driver_name[0] );</a>
<a name="ln4787">            m++ )</a>
<a name="ln4788">      {</a>
<a name="ln4789">        for ( n = 0; n &lt; library-&gt;num_modules; n++ )</a>
<a name="ln4790">        {</a>
<a name="ln4791">          FT_Module    module      = library-&gt;modules[n];</a>
<a name="ln4792">          const char*  module_name = module-&gt;clazz-&gt;module_name;</a>
<a name="ln4793">          FT_List      faces;</a>
<a name="ln4794"> </a>
<a name="ln4795"> </a>
<a name="ln4796">          if ( driver_name[m]                                &amp;&amp;</a>
<a name="ln4797">               ft_strcmp( module_name, driver_name[m] ) != 0 )</a>
<a name="ln4798">            continue;</a>
<a name="ln4799"> </a>
<a name="ln4800">          if ( ( module-&gt;clazz-&gt;module_flags &amp; FT_MODULE_FONT_DRIVER ) == 0 )</a>
<a name="ln4801">            continue;</a>
<a name="ln4802"> </a>
<a name="ln4803">          FT_TRACE7(( &quot;FT_Done_Library: close faces for %s\n&quot;, module_name ));</a>
<a name="ln4804"> </a>
<a name="ln4805">          faces = &amp;FT_DRIVER( module )-&gt;faces_list;</a>
<a name="ln4806">          while ( faces-&gt;head )</a>
<a name="ln4807">          {</a>
<a name="ln4808">            FT_Done_Face( FT_FACE( faces-&gt;head-&gt;data ) );</a>
<a name="ln4809">            if ( faces-&gt;head )</a>
<a name="ln4810">              FT_TRACE0(( &quot;FT_Done_Library: failed to free some faces\n&quot; ));</a>
<a name="ln4811">          }</a>
<a name="ln4812">        }</a>
<a name="ln4813">      }</a>
<a name="ln4814">    }</a>
<a name="ln4815"> </a>
<a name="ln4816">    /* Close all other modules in the library */</a>
<a name="ln4817">#if 1</a>
<a name="ln4818">    /* XXX Modules are removed in the reversed order so that  */</a>
<a name="ln4819">    /* type42 module is removed before truetype module.  This */</a>
<a name="ln4820">    /* avoids double free in some occasions.  It is a hack.   */</a>
<a name="ln4821">    while ( library-&gt;num_modules &gt; 0 )</a>
<a name="ln4822">      FT_Remove_Module( library,</a>
<a name="ln4823">                        library-&gt;modules[library-&gt;num_modules - 1] );</a>
<a name="ln4824">#else</a>
<a name="ln4825">    {</a>
<a name="ln4826">      FT_UInt  n;</a>
<a name="ln4827"> </a>
<a name="ln4828"> </a>
<a name="ln4829">      for ( n = 0; n &lt; library-&gt;num_modules; n++ )</a>
<a name="ln4830">      {</a>
<a name="ln4831">        FT_Module  module = library-&gt;modules[n];</a>
<a name="ln4832"> </a>
<a name="ln4833"> </a>
<a name="ln4834">        if ( module )</a>
<a name="ln4835">        {</a>
<a name="ln4836">          Destroy_Module( module );</a>
<a name="ln4837">          library-&gt;modules[n] = NULL;</a>
<a name="ln4838">        }</a>
<a name="ln4839">      }</a>
<a name="ln4840">    }</a>
<a name="ln4841">#endif</a>
<a name="ln4842"> </a>
<a name="ln4843">#ifdef FT_CONFIG_OPTION_PIC</a>
<a name="ln4844">    /* Destroy pic container contents */</a>
<a name="ln4845">    ft_pic_container_destroy( library );</a>
<a name="ln4846">#endif</a>
<a name="ln4847"> </a>
<a name="ln4848">    FT_FREE( library );</a>
<a name="ln4849"> </a>
<a name="ln4850">  Exit:</a>
<a name="ln4851">    return FT_Err_Ok;</a>
<a name="ln4852">  }</a>
<a name="ln4853"> </a>
<a name="ln4854"> </a>
<a name="ln4855">  /* documentation is in ftmodapi.h */</a>
<a name="ln4856"> </a>
<a name="ln4857">  FT_EXPORT_DEF( void )</a>
<a name="ln4858">  FT_Set_Debug_Hook( FT_Library         library,</a>
<a name="ln4859">                     FT_UInt            hook_index,</a>
<a name="ln4860">                     FT_DebugHook_Func  debug_hook )</a>
<a name="ln4861">  {</a>
<a name="ln4862">    if ( library &amp;&amp; debug_hook &amp;&amp;</a>
<a name="ln4863">         hook_index &lt;</a>
<a name="ln4864">           ( sizeof ( library-&gt;debug_hooks ) / sizeof ( void* ) ) )</a>
<a name="ln4865">      library-&gt;debug_hooks[hook_index] = debug_hook;</a>
<a name="ln4866">  }</a>
<a name="ln4867"> </a>
<a name="ln4868"> </a>
<a name="ln4869">  /* documentation is in ftmodapi.h */</a>
<a name="ln4870"> </a>
<a name="ln4871">  FT_EXPORT_DEF( FT_TrueTypeEngineType )</a>
<a name="ln4872">  FT_Get_TrueType_Engine_Type( FT_Library  library )</a>
<a name="ln4873">  {</a>
<a name="ln4874">    FT_TrueTypeEngineType  result = FT_TRUETYPE_ENGINE_TYPE_NONE;</a>
<a name="ln4875"> </a>
<a name="ln4876"> </a>
<a name="ln4877">    if ( library )</a>
<a name="ln4878">    {</a>
<a name="ln4879">      FT_Module  module = FT_Get_Module( library, &quot;truetype&quot; );</a>
<a name="ln4880"> </a>
<a name="ln4881"> </a>
<a name="ln4882">      if ( module )</a>
<a name="ln4883">      {</a>
<a name="ln4884">        FT_Service_TrueTypeEngine  service;</a>
<a name="ln4885"> </a>
<a name="ln4886"> </a>
<a name="ln4887">        service = (FT_Service_TrueTypeEngine)</a>
<a name="ln4888">                    ft_module_get_service( module,</a>
<a name="ln4889">                                           FT_SERVICE_ID_TRUETYPE_ENGINE );</a>
<a name="ln4890">        if ( service )</a>
<a name="ln4891">          result = service-&gt;engine_type;</a>
<a name="ln4892">      }</a>
<a name="ln4893">    }</a>
<a name="ln4894"> </a>
<a name="ln4895">    return result;</a>
<a name="ln4896">  }</a>
<a name="ln4897"> </a>
<a name="ln4898"> </a>
<a name="ln4899">  /* documentation is in freetype.h */</a>
<a name="ln4900"> </a>
<a name="ln4901">  FT_EXPORT_DEF( FT_Error )</a>
<a name="ln4902">  FT_Get_SubGlyph_Info( FT_GlyphSlot  glyph,</a>
<a name="ln4903">                        FT_UInt       sub_index,</a>
<a name="ln4904">                        FT_Int       *p_index,</a>
<a name="ln4905">                        FT_UInt      *p_flags,</a>
<a name="ln4906">                        FT_Int       *p_arg1,</a>
<a name="ln4907">                        FT_Int       *p_arg2,</a>
<a name="ln4908">                        FT_Matrix    *p_transform )</a>
<a name="ln4909">  {</a>
<a name="ln4910">    FT_Error  error = FT_ERR( Invalid_Argument );</a>
<a name="ln4911"> </a>
<a name="ln4912"> </a>
<a name="ln4913">    if ( glyph                                      &amp;&amp;</a>
<a name="ln4914">         glyph-&gt;subglyphs                           &amp;&amp;</a>
<a name="ln4915">         glyph-&gt;format == FT_GLYPH_FORMAT_COMPOSITE &amp;&amp;</a>
<a name="ln4916">         sub_index &lt; glyph-&gt;num_subglyphs           )</a>
<a name="ln4917">    {</a>
<a name="ln4918">      FT_SubGlyph  subg = glyph-&gt;subglyphs + sub_index;</a>
<a name="ln4919"> </a>
<a name="ln4920"> </a>
<a name="ln4921">      *p_index     = subg-&gt;index;</a>
<a name="ln4922">      *p_flags     = subg-&gt;flags;</a>
<a name="ln4923">      *p_arg1      = subg-&gt;arg1;</a>
<a name="ln4924">      *p_arg2      = subg-&gt;arg2;</a>
<a name="ln4925">      *p_transform = subg-&gt;transform;</a>
<a name="ln4926"> </a>
<a name="ln4927">      error = FT_Err_Ok;</a>
<a name="ln4928">    }</a>
<a name="ln4929"> </a>
<a name="ln4930">    return error;</a>
<a name="ln4931">  }</a>
<a name="ln4932"> </a>
<a name="ln4933"> </a>
<a name="ln4934">/* END */</a>

</code></pre>
<div class="balloon" rel="1182"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always false.</p></div>
<div class="balloon" rel="1736"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'error' is always true.</p></div>
<div class="balloon" rel="3040"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'pixel_width << 6' operator to the 'FT_Long' type, not the result.</p></div>
<div class="balloon" rel="3041"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1028/" target="_blank">V1028</a> Possible overflow. Consider casting operands of the 'pixel_height << 6' operator to the 'FT_Long' type, not the result.</p></div>
<div class="balloon" rel="3714"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression '!result' is always true.</p></div>
<div class="balloon" rel="4809"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'faces->head' is always true.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
