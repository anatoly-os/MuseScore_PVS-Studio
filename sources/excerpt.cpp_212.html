
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>excerpt.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2009-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;excerpt.h&quot;</a>
<a name="ln14">#include &quot;score.h&quot;</a>
<a name="ln15">#include &quot;part.h&quot;</a>
<a name="ln16">#include &quot;xml.h&quot;</a>
<a name="ln17">#include &quot;staff.h&quot;</a>
<a name="ln18">#include &quot;box.h&quot;</a>
<a name="ln19">#include &quot;textframe.h&quot;</a>
<a name="ln20">#include &quot;style.h&quot;</a>
<a name="ln21">#include &quot;page.h&quot;</a>
<a name="ln22">#include &quot;text.h&quot;</a>
<a name="ln23">#include &quot;slur.h&quot;</a>
<a name="ln24">#include &quot;tie.h&quot;</a>
<a name="ln25">#include &quot;sig.h&quot;</a>
<a name="ln26">#include &quot;tempo.h&quot;</a>
<a name="ln27">#include &quot;measure.h&quot;</a>
<a name="ln28">#include &quot;rest.h&quot;</a>
<a name="ln29">#include &quot;stafftype.h&quot;</a>
<a name="ln30">#include &quot;tuplet.h&quot;</a>
<a name="ln31">#include &quot;chord.h&quot;</a>
<a name="ln32">#include &quot;note.h&quot;</a>
<a name="ln33">#include &quot;lyrics.h&quot;</a>
<a name="ln34">#include &quot;segment.h&quot;</a>
<a name="ln35">#include &quot;tupletmap.h&quot;</a>
<a name="ln36">#include &quot;tiemap.h&quot;</a>
<a name="ln37">#include &quot;layoutbreak.h&quot;</a>
<a name="ln38">#include &quot;harmony.h&quot;</a>
<a name="ln39">#include &quot;beam.h&quot;</a>
<a name="ln40">#include &quot;utils.h&quot;</a>
<a name="ln41">#include &quot;tremolo.h&quot;</a>
<a name="ln42">#include &quot;barline.h&quot;</a>
<a name="ln43">#include &quot;undo.h&quot;</a>
<a name="ln44">#include &quot;bracketItem.h&quot;</a>
<a name="ln45"> </a>
<a name="ln46">namespace Ms {</a>
<a name="ln47"> </a>
<a name="ln48">//---------------------------------------------------------</a>
<a name="ln49">//   Excerpt</a>
<a name="ln50">//---------------------------------------------------------</a>
<a name="ln51"> </a>
<a name="ln52">Excerpt::Excerpt(const Excerpt&amp; ex, bool copyPartScore)</a>
<a name="ln53">   : QObject(), _oscore(ex._oscore), _title(ex._title), _parts(ex._parts), _tracks(ex._tracks)</a>
<a name="ln54">      {</a>
<a name="ln55">      _partScore = (copyPartScore &amp;&amp; ex._partScore) ? ex._partScore-&gt;clone() : nullptr;</a>
<a name="ln56">      }</a>
<a name="ln57"> </a>
<a name="ln58">//---------------------------------------------------------</a>
<a name="ln59">//   ~Excerpt</a>
<a name="ln60">//---------------------------------------------------------</a>
<a name="ln61"> </a>
<a name="ln62">Excerpt::~Excerpt() {</a>
<a name="ln63">      delete _partScore;</a>
<a name="ln64">      }</a>
<a name="ln65"> </a>
<a name="ln66">//---------------------------------------------------------</a>
<a name="ln67">//   read</a>
<a name="ln68">//---------------------------------------------------------</a>
<a name="ln69"> </a>
<a name="ln70">void Excerpt::read(XmlReader&amp; e)</a>
<a name="ln71">      {</a>
<a name="ln72">      const QList&lt;Part*&gt;&amp; pl = _oscore-&gt;parts();</a>
<a name="ln73">      QString name;</a>
<a name="ln74">      while (e.readNextStartElement()) {</a>
<a name="ln75">            const QStringRef&amp; tag = e.name();</a>
<a name="ln76">            if (tag == &quot;name&quot;)</a>
<a name="ln77">                  name = e.readElementText();</a>
<a name="ln78">            else if (tag == &quot;title&quot;)</a>
<a name="ln79">                  _title = e.readElementText().trimmed();</a>
<a name="ln80">            else if (tag == &quot;part&quot;) {</a>
<a name="ln81">                  int partIdx = e.readInt();</a>
<a name="ln82">                  if (partIdx &lt; 0 || partIdx &gt;= pl.size())</a>
<a name="ln83">                        qDebug(&quot;Excerpt::read: bad part index&quot;);</a>
<a name="ln84">                  else</a>
<a name="ln85">                        _parts.append(pl.at(partIdx));</a>
<a name="ln86">                  }</a>
<a name="ln87">            }</a>
<a name="ln88">      if (_title.isEmpty())</a>
<a name="ln89">            _title = name.trimmed();</a>
<a name="ln90">      }</a>
<a name="ln91"> </a>
<a name="ln92">//---------------------------------------------------------</a>
<a name="ln93">//   operator!=</a>
<a name="ln94">//---------------------------------------------------------</a>
<a name="ln95"> </a>
<a name="ln96">bool Excerpt::operator!=(const Excerpt&amp; e) const</a>
<a name="ln97">      {</a>
<a name="ln98">      if (e._oscore != _oscore)</a>
<a name="ln99">            return true;</a>
<a name="ln100">      if (e._title != _title)</a>
<a name="ln101">            return true;</a>
<a name="ln102">      if (e._parts != _parts)</a>
<a name="ln103">            return true;</a>
<a name="ln104">      if (e._tracks != _tracks)</a>
<a name="ln105">            return true;</a>
<a name="ln106">      return false;</a>
<a name="ln107">      }</a>
<a name="ln108"> </a>
<a name="ln109">//---------------------------------------------------------</a>
<a name="ln110">//   operator==</a>
<a name="ln111">//---------------------------------------------------------</a>
<a name="ln112"> </a>
<a name="ln113">bool Excerpt::operator==(const Excerpt&amp; e) const</a>
<a name="ln114">      {</a>
<a name="ln115">      if (e._oscore != _oscore)</a>
<a name="ln116">            return false;</a>
<a name="ln117">      if (e._title != _title)</a>
<a name="ln118">            return false;</a>
<a name="ln119">      if (e._parts != _parts)</a>
<a name="ln120">            return false;</a>
<a name="ln121">      if (e._tracks != _tracks)</a>
<a name="ln122">            return false;</a>
<a name="ln123">      return true;</a>
<a name="ln124">      }</a>
<a name="ln125"> </a>
<a name="ln126">//---------------------------------------------------------</a>
<a name="ln127">//   createExcerpt</a>
<a name="ln128">//---------------------------------------------------------</a>
<a name="ln129"> </a>
<a name="ln130">void Excerpt::createExcerpt(Excerpt* excerpt)</a>
<a name="ln131">      {</a>
<a name="ln132">      MasterScore* oscore = excerpt-&gt;oscore();</a>
<a name="ln133">      Score* score        = excerpt-&gt;partScore();</a>
<a name="ln134"> </a>
<a name="ln135">      QList&lt;Part*&gt;&amp; parts = excerpt-&gt;parts();</a>
<a name="ln136">      QList&lt;int&gt; srcStaves;</a>
<a name="ln137"> </a>
<a name="ln138">      // clone layer:</a>
<a name="ln139">      for (int i = 0; i &lt; 32; ++i) {</a>
<a name="ln140">            score-&gt;layerTags()[i] = oscore-&gt;layerTags()[i];</a>
<a name="ln141">            score-&gt;layerTagComments()[i] = oscore-&gt;layerTagComments()[i];</a>
<a name="ln142">            }</a>
<a name="ln143">      score-&gt;setCurrentLayer(oscore-&gt;currentLayer());</a>
<a name="ln144">      score-&gt;layer().clear();</a>
<a name="ln145">      foreach (const Layer&amp; l, oscore-&gt;layer())</a>
<a name="ln146">            score-&gt;layer().append(l);</a>
<a name="ln147"> </a>
<a name="ln148">      score-&gt;setPageNumberOffset(oscore-&gt;pageNumberOffset());</a>
<a name="ln149"> </a>
<a name="ln150">      // Set instruments and create linked staffs</a>
<a name="ln151">      for (const Part* part : parts) {</a>
<a name="ln152">            Part* p = new Part(score);</a>
<a name="ln153">            p-&gt;setInstrument(*part-&gt;instrument());</a>
<a name="ln154">            p-&gt;setPartName(part-&gt;partName());</a>
<a name="ln155"> </a>
<a name="ln156">            for (Staff* staff : *part-&gt;staves()) {</a>
<a name="ln157">                  Staff* s = new Staff(score);</a>
<a name="ln158">                  s-&gt;setPart(p);</a>
<a name="ln159">//                  s-&gt;setStaffType(0, *staff-&gt;staffType(0));              // TODO</a>
<a name="ln160">                  s-&gt;init(staff);</a>
<a name="ln161">                  s-&gt;setDefaultClefType(staff-&gt;defaultClefType());</a>
<a name="ln162">                  // the order of staff - s matters as staff should be the first entry in the</a>
<a name="ln163">                  // created link list to make primaryStaff() work</a>
<a name="ln164">                  // TODO: change implementation, maybe create an explicit &quot;primary&quot; flag</a>
<a name="ln165">                  score-&gt;undo(new Link(s, staff));</a>
<a name="ln166">                  p-&gt;staves()-&gt;append(s);</a>
<a name="ln167">                  score-&gt;staves().append(s);</a>
<a name="ln168">                  srcStaves.append(staff-&gt;idx());</a>
<a name="ln169">                  }</a>
<a name="ln170">            score-&gt;appendPart(p);</a>
<a name="ln171">            }</a>
<a name="ln172"> </a>
<a name="ln173">      // Fill tracklist (map all tracks of a stave)</a>
<a name="ln174">      if (excerpt-&gt;tracks().isEmpty()) {</a>
<a name="ln175">            QMultiMap&lt;int, int&gt; tracks;</a>
<a name="ln176">            for (Staff* s : score-&gt;staves()) {</a>
<a name="ln177">                  const LinkedElements* ls = s-&gt;links();</a>
<a name="ln178">                  if (ls == 0)</a>
<a name="ln179">                        continue;</a>
<a name="ln180">                  for (auto le : *ls) {</a>
<a name="ln181">                        Staff* ps = toStaff(le);</a>
<a name="ln182">                        if (ps-&gt;primaryStaff()) {</a>
<a name="ln183">                              for (int i = 0; i &lt; VOICES; i++) {</a>
<a name="ln184">                                    tracks.insert(ps-&gt;idx() * VOICES + i % VOICES, s-&gt;idx() * VOICES + i % VOICES);</a>
<a name="ln185">                                    }</a>
<a name="ln186">                              break;</a>
<a name="ln187">                              }</a>
<a name="ln188">                        }</a>
<a name="ln189">                  }</a>
<a name="ln190">            excerpt-&gt;setTracks(tracks);</a>
<a name="ln191">            }</a>
<a name="ln192"> </a>
<a name="ln193">      cloneStaves(oscore, score, srcStaves, excerpt-&gt;tracks());</a>
<a name="ln194"> </a>
<a name="ln195">      // create excerpt title and title frame for all scores if not already there</a>
<a name="ln196">      MeasureBase* measure = oscore-&gt;first();</a>
<a name="ln197"> </a>
<a name="ln198">      if (!measure || !measure-&gt;isVBox()) {</a>
<a name="ln199">            qDebug(&quot;original score has no header frame&quot;);</a>
<a name="ln200">            oscore-&gt;insertMeasure(ElementType::VBOX, measure);</a>
<a name="ln201">            measure = oscore-&gt;first();</a>
<a name="ln202">            }</a>
<a name="ln203">      VBox* titleFrameScore = toVBox(measure);</a>
<a name="ln204"> </a>
<a name="ln205">      measure = score-&gt;first();</a>
<a name="ln206">      Q_ASSERT(measure-&gt;isVBox());</a>
<a name="ln207"> </a>
<a name="ln208">      VBox* titleFramePart = toVBox(measure);</a>
<a name="ln209">      titleFramePart-&gt;copyValues(titleFrameScore);</a>
<a name="ln210">      QString partLabel = excerpt-&gt;title();     // parts.front()-&gt;longName();</a>
<a name="ln211">      if (!partLabel.isEmpty()) {</a>
<a name="ln212">            Text* txt = new Text(score, Tid::INSTRUMENT_EXCERPT);</a>
<a name="ln213">            txt-&gt;setPlainText(partLabel);</a>
<a name="ln214">            measure-&gt;add(txt);</a>
<a name="ln215">            score-&gt;setMetaTag(&quot;partName&quot;, partLabel);</a>
<a name="ln216">            }</a>
<a name="ln217"> </a>
<a name="ln218">      // initial layout of score</a>
<a name="ln219">      score-&gt;addLayoutFlags(LayoutFlag::FIX_PITCH_VELO);</a>
<a name="ln220">      score-&gt;doLayout();</a>
<a name="ln221"> </a>
<a name="ln222">      // handle transposing instruments</a>
<a name="ln223">      if (oscore-&gt;styleB(Sid::concertPitch) != score-&gt;styleB(Sid::concertPitch)) {</a>
<a name="ln224">            for (const Staff* staff : score-&gt;staves()) {</a>
<a name="ln225">                  if (staff-&gt;staffType(Fraction(0,1))-&gt;group() == StaffGroup::PERCUSSION)</a>
<a name="ln226">                        continue;</a>
<a name="ln227"> </a>
<a name="ln228">                  // if this staff has no transposition, and no instrument changes, we can skip it</a>
<a name="ln229">                  Interval interval = staff-&gt;part()-&gt;instrument()-&gt;transpose();</a>
<a name="ln230">                  if (interval.isZero() &amp;&amp; staff-&gt;part()-&gt;instruments()-&gt;size() == 1)</a>
<a name="ln231">                        continue;</a>
<a name="ln232">                  bool flip = false;</a>
<a name="ln233">                  if (oscore-&gt;styleB(Sid::concertPitch)) {</a>
<a name="ln234">                        interval.flip();  // flip the transposition for the original instrument</a>
<a name="ln235">                        flip = true;      // transposeKeys() will flip transposition for each instrument change</a>
<a name="ln236">                        }</a>
<a name="ln237"> </a>
<a name="ln238">                  int staffIdx   = staff-&gt;idx();</a>
<a name="ln239">                  int startTrack = staffIdx * VOICES;</a>
<a name="ln240">                  int endTrack   = startTrack + VOICES;</a>
<a name="ln241"> </a>
<a name="ln242">                  Fraction endTick = Fraction(0,1);</a>
<a name="ln243">                  if (score-&gt;lastSegment())</a>
<a name="ln244">                        endTick = score-&gt;lastSegment()-&gt;tick();</a>
<a name="ln245">                  score-&gt;transposeKeys(staffIdx, staffIdx+1, Fraction(0,1), endTick, interval, true, flip);</a>
<a name="ln246"> </a>
<a name="ln247">                  for (auto segment = score-&gt;firstSegmentMM(SegmentType::ChordRest); segment; segment = segment-&gt;next1MM(SegmentType::ChordRest)) {</a>
<a name="ln248">                        interval = staff-&gt;part()-&gt;instrument(segment-&gt;tick())-&gt;transpose();</a>
<a name="ln249">                        if (interval.isZero())</a>
<a name="ln250">                              continue;</a>
<a name="ln251">                        if (oscore-&gt;styleB(Sid::concertPitch))</a>
<a name="ln252">                              interval.flip();</a>
<a name="ln253"> </a>
<a name="ln254">                        for (auto e : segment-&gt;annotations()) {</a>
<a name="ln255">                              if (!e-&gt;isHarmony() || (e-&gt;track() &lt; startTrack) || (e-&gt;track() &gt;= endTrack))</a>
<a name="ln256">                                    continue;</a>
<a name="ln257">                              Harmony* h  = toHarmony(e);</a>
<a name="ln258">                              int rootTpc = Ms::transposeTpc(h-&gt;rootTpc(), interval, true);</a>
<a name="ln259">                              int baseTpc = Ms::transposeTpc(h-&gt;baseTpc(), interval, true);</a>
<a name="ln260">                              // mmrests are on by default in part</a>
<a name="ln261">                              // if this harmony is attached to an mmrest,</a>
<a name="ln262">                              // be sure to transpose harmony in underlying measure as well</a>
<a name="ln263">                              for (ScoreElement* se : h-&gt;linkList()) {</a>
<a name="ln264">                                    Harmony* hh = static_cast&lt;Harmony*&gt;(se);</a>
<a name="ln265">                                    // skip links to other staves (including in other scores)</a>
<a name="ln266">                                    if (hh-&gt;staff() != h-&gt;staff())</a>
<a name="ln267">                                          continue;</a>
<a name="ln268">                                    score-&gt;undoTransposeHarmony(hh, rootTpc, baseTpc);</a>
<a name="ln269">                                    }</a>
<a name="ln270">                              }</a>
<a name="ln271">                        }</a>
<a name="ln272">                  }</a>
<a name="ln273">            }</a>
<a name="ln274"> </a>
<a name="ln275">      // update style values if spatium different for part</a>
<a name="ln276">      if (oscore-&gt;spatium() != score-&gt;spatium()) {</a>
<a name="ln277">            //score-&gt;spatiumChanged(oscore-&gt;spatium(), score-&gt;spatium());</a>
<a name="ln278">            score-&gt;styleChanged();</a>
<a name="ln279">            }</a>
<a name="ln280"> </a>
<a name="ln281">      // second layout of score</a>
<a name="ln282">      score-&gt;setPlaylistDirty();</a>
<a name="ln283">      oscore-&gt;rebuildMidiMapping();</a>
<a name="ln284">      oscore-&gt;updateChannel();</a>
<a name="ln285"> </a>
<a name="ln286">      score-&gt;setLayoutAll();</a>
<a name="ln287">      score-&gt;doLayout();</a>
<a name="ln288">      }</a>
<a name="ln289"> </a>
<a name="ln290">//---------------------------------------------------------</a>
<a name="ln291">//   deleteExcerpt</a>
<a name="ln292">//---------------------------------------------------------</a>
<a name="ln293"> </a>
<a name="ln294">void MasterScore::deleteExcerpt(Excerpt* excerpt)</a>
<a name="ln295">      {</a>
<a name="ln296">      Q_ASSERT(excerpt-&gt;oscore() == this);</a>
<a name="ln297">      Score* partScore = excerpt-&gt;partScore();</a>
<a name="ln298"> </a>
<a name="ln299">      if (!partScore) {</a>
<a name="ln300">            qDebug(&quot;deleteExcerpt: no partScore&quot;);</a>
<a name="ln301">            return;</a>
<a name="ln302">            }</a>
<a name="ln303"> </a>
<a name="ln304">      // unlink the staves in the excerpt</a>
<a name="ln305">      for (Staff* st : partScore-&gt;staves()) {</a>
<a name="ln306">            bool hasLinksInMaster = false;</a>
<a name="ln307">            if (st-&gt;links()) {</a>
<a name="ln308">                  for (auto le : *st-&gt;links()) {</a>
<a name="ln309">                        if (le-&gt;score() == this) {</a>
<a name="ln310">                              hasLinksInMaster = true;</a>
<a name="ln311">                              break;</a>
<a name="ln312">                              }</a>
<a name="ln313">                        }</a>
<a name="ln314">                  }</a>
<a name="ln315">            if (hasLinksInMaster) {</a>
<a name="ln316">                  int staffIdx = st-&gt;idx();</a>
<a name="ln317">                  // unlink the spanners</a>
<a name="ln318">                  for (auto i = partScore-&gt;spanner().begin(); i != partScore-&gt;spanner().cend(); ++i) {</a>
<a name="ln319">                        Spanner* sp = i-&gt;second;</a>
<a name="ln320">                        if (sp-&gt;staffIdx() == staffIdx)</a>
<a name="ln321">                              sp-&gt;undoUnlink();</a>
<a name="ln322">                        }</a>
<a name="ln323">                  int sTrack = staffIdx * VOICES;</a>
<a name="ln324">                  int eTrack = sTrack + VOICES;</a>
<a name="ln325">                  // unlink elements and annotation</a>
<a name="ln326">                  for (Segment* s = partScore-&gt;firstSegmentMM(SegmentType::All); s; s = s-&gt;next1MM()) {</a>
<a name="ln327">                        for (int track = eTrack - 1; track &gt;= sTrack; --track) {</a>
<a name="ln328">                              Element* el = s-&gt;element(track);</a>
<a name="ln329">                              if (el)</a>
<a name="ln330">                                    el-&gt;undoUnlink();</a>
<a name="ln331">                              }</a>
<a name="ln332">                        for (Element* e : s-&gt;annotations()) {</a>
<a name="ln333">                              if (e-&gt;staffIdx() == staffIdx)</a>
<a name="ln334">                                    e-&gt;undoUnlink();</a>
<a name="ln335">                              }</a>
<a name="ln336">                        }</a>
<a name="ln337">                  // unlink the staff</a>
<a name="ln338">                  undo(new Unlink(st));</a>
<a name="ln339">                  }</a>
<a name="ln340">            }</a>
<a name="ln341">      undo(new RemoveExcerpt(excerpt));</a>
<a name="ln342">      }</a>
<a name="ln343"> </a>
<a name="ln344">//---------------------------------------------------------</a>
<a name="ln345">//   cloneSpanner</a>
<a name="ln346">//---------------------------------------------------------</a>
<a name="ln347"> </a>
<a name="ln348">static void cloneSpanner(Spanner* s, Score* score, int dstTrack, int dstTrack2)</a>
<a name="ln349">      {</a>
<a name="ln350">      // don’t clone voltas for track != 0</a>
<a name="ln351">      if (s-&gt;type() == ElementType::VOLTA &amp;&amp; s-&gt;track() != 0)</a>
<a name="ln352">            return;</a>
<a name="ln353">      Spanner* ns = toSpanner(s-&gt;linkedClone());</a>
<a name="ln354">      ns-&gt;setScore(score);</a>
<a name="ln355">      ns-&gt;setParent(0);</a>
<a name="ln356">      ns-&gt;setTrack(dstTrack);</a>
<a name="ln357">      ns-&gt;setTrack2(dstTrack2);</a>
<a name="ln358"> </a>
<a name="ln359">      if (ns-&gt;type() == ElementType::SLUR) {</a>
<a name="ln360"> </a>
<a name="ln361">            // set start/end element for slur</a>
<a name="ln362">            ChordRest* cr1 = s-&gt;startCR();</a>
<a name="ln363">            ChordRest* cr2 = s-&gt;endCR();</a>
<a name="ln364"> </a>
<a name="ln365">            ns-&gt;setStartElement(0);</a>
<a name="ln366">            ns-&gt;setEndElement(0);</a>
<a name="ln367">            if (cr1 &amp;&amp; cr1-&gt;links()) {</a>
<a name="ln368">                  for (ScoreElement* e : *cr1-&gt;links()) {</a>
<a name="ln369">                        ChordRest* cr = toChordRest(e);</a>
<a name="ln370">                        if (cr == cr1)</a>
<a name="ln371">                              continue;</a>
<a name="ln372">                        if ((cr-&gt;score() == score) &amp;&amp; (cr-&gt;tick() == ns-&gt;tick()) &amp;&amp; cr-&gt;track() == dstTrack) {</a>
<a name="ln373">                              ns-&gt;setStartElement(cr);</a>
<a name="ln374">                              break;</a>
<a name="ln375">                              }</a>
<a name="ln376">                        }</a>
<a name="ln377">                  }</a>
<a name="ln378">            if (cr2 &amp;&amp; cr2-&gt;links()) {</a>
<a name="ln379">                  for (ScoreElement* e : *cr2-&gt;links()) {</a>
<a name="ln380">                        ChordRest* cr = toChordRest(e);</a>
<a name="ln381">                        if (cr == cr2)</a>
<a name="ln382">                              continue;</a>
<a name="ln383">                        if ((cr-&gt;score() == score) &amp;&amp; (cr-&gt;tick() == ns-&gt;tick2()) &amp;&amp; cr-&gt;track() == dstTrack2) {</a>
<a name="ln384">                              ns-&gt;setEndElement(cr);</a>
<a name="ln385">                              break;</a>
<a name="ln386">                              }</a>
<a name="ln387">                        }</a>
<a name="ln388">                  }</a>
<a name="ln389">            if (!ns-&gt;startElement())</a>
<a name="ln390">                  qDebug(&quot;clone Slur: no start element&quot;);</a>
<a name="ln391">            if (!ns-&gt;endElement())</a>
<a name="ln392">                  qDebug(&quot;clone Slur: no end element&quot;);</a>
<a name="ln393">            }</a>
<a name="ln394">      score-&gt;undo(new AddElement(ns));</a>
<a name="ln395">      }</a>
<a name="ln396"> </a>
<a name="ln397">//---------------------------------------------------------</a>
<a name="ln398">//   cloneTuplets</a>
<a name="ln399">//---------------------------------------------------------</a>
<a name="ln400"> </a>
<a name="ln401">static void cloneTuplets(ChordRest* ocr, ChordRest* ncr, Tuplet* ot, TupletMap&amp; tupletMap, Measure* m, int track)</a>
<a name="ln402">      {</a>
<a name="ln403">      ot-&gt;setTrack(ocr-&gt;track());</a>
<a name="ln404">      Tuplet* nt = tupletMap.findNew(ot);</a>
<a name="ln405">      if (nt == 0) {</a>
<a name="ln406">            nt = toTuplet(ot-&gt;linkedClone());</a>
<a name="ln407">            nt-&gt;setTrack(track);</a>
<a name="ln408">            nt-&gt;setParent(m);</a>
<a name="ln409">            nt-&gt;setScore(ncr-&gt;score());</a>
<a name="ln410">            tupletMap.add(ot, nt);</a>
<a name="ln411"> </a>
<a name="ln412">            Tuplet* nt1 = nt;</a>
<a name="ln413">            while (ot-&gt;tuplet()) {</a>
<a name="ln414">                  Tuplet* nt2 = tupletMap.findNew(ot-&gt;tuplet());</a>
<a name="ln415">                  if (nt2 == 0) {</a>
<a name="ln416">                        nt2 = toTuplet(ot-&gt;tuplet()-&gt;linkedClone());</a>
<a name="ln417">                        nt2-&gt;setTrack(track);</a>
<a name="ln418">                        nt2-&gt;setParent(m);</a>
<a name="ln419">                        nt2-&gt;setScore(ncr-&gt;score());</a>
<a name="ln420">                        tupletMap.add(ot-&gt;tuplet(), nt2);</a>
<a name="ln421">                        }</a>
<a name="ln422">                  nt2-&gt;add(nt1);</a>
<a name="ln423">                  nt1-&gt;setTuplet(nt2);</a>
<a name="ln424">                  ot = ot-&gt;tuplet();</a>
<a name="ln425">                  nt1 = nt2;</a>
<a name="ln426">                  }</a>
<a name="ln427">            }</a>
<a name="ln428">      nt-&gt;add(ncr);</a>
<a name="ln429">      ncr-&gt;setTuplet(nt);</a>
<a name="ln430">      }</a>
<a name="ln431"> </a>
<a name="ln432">//---------------------------------------------------------</a>
<a name="ln433">//   cloneStaves</a>
<a name="ln434">//---------------------------------------------------------</a>
<a name="ln435"> </a>
<a name="ln436">void Excerpt::cloneStaves(Score* oscore, Score* score, const QList&lt;int&gt;&amp; map, QMultiMap&lt;int, int&gt;&amp; trackList)</a>
<a name="ln437">      {</a>
<a name="ln438">      TieMap  tieMap;</a>
<a name="ln439"> </a>
<a name="ln440">      MeasureBaseList* nmbl = score-&gt;measures();</a>
<a name="ln441">      for (MeasureBase* mb = oscore-&gt;measures()-&gt;first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln442">            MeasureBase* nmb = 0;</a>
<a name="ln443">            if (mb-&gt;isHBox())</a>
<a name="ln444">                  nmb = new HBox(score);</a>
<a name="ln445">            else if (mb-&gt;isVBox())</a>
<a name="ln446">                  nmb = new VBox(score);</a>
<a name="ln447">            else if (mb-&gt;isTBox()) {</a>
<a name="ln448">                  nmb = new TBox(score);</a>
<a name="ln449">                  Text* text = toTBox(mb)-&gt;text();</a>
<a name="ln450">                  Element* ne = text-&gt;linkedClone();</a>
<a name="ln451">                  ne-&gt;setScore(score);</a>
<a name="ln452">                  nmb-&gt;add(ne);</a>
<a name="ln453">                  }</a>
<a name="ln454">            else if (mb-&gt;isMeasure()) {</a>
<a name="ln455">                  Measure* m  = toMeasure(mb);</a>
<a name="ln456">                  Measure* nm = new Measure(score);</a>
<a name="ln457">                  nmb = nm;</a>
<a name="ln458">                  nm-&gt;setTick(m-&gt;tick());</a>
<a name="ln459">                  nm-&gt;setTicks(m-&gt;ticks());</a>
<a name="ln460">                  nm-&gt;setTimesig(m-&gt;timesig());</a>
<a name="ln461"> </a>
<a name="ln462">                  nm-&gt;setRepeatCount(m-&gt;repeatCount());</a>
<a name="ln463">                  nm-&gt;setRepeatStart(m-&gt;repeatStart());</a>
<a name="ln464">                  nm-&gt;setRepeatEnd(m-&gt;repeatEnd());</a>
<a name="ln465">                  nm-&gt;setRepeatJump(m-&gt;repeatJump());</a>
<a name="ln466"> </a>
<a name="ln467">                  nm-&gt;setIrregular(m-&gt;irregular());</a>
<a name="ln468">                  nm-&gt;setNo(m-&gt;no());</a>
<a name="ln469">                  nm-&gt;setNoOffset(m-&gt;noOffset());</a>
<a name="ln470">                  nm-&gt;setBreakMultiMeasureRest(m-&gt;breakMultiMeasureRest());</a>
<a name="ln471">//TODO                  nm-&gt;setEndBarLineType(</a>
<a name="ln472">//                     m-&gt;endBarLineType(),</a>
<a name="ln473">//                     m-&gt;endBarLineGenerated(),</a>
<a name="ln474">//                     m-&gt;endBarLineVisible(),</a>
<a name="ln475">//                     m-&gt;endBarLineColor());</a>
<a name="ln476"> </a>
<a name="ln477">                  // Fraction ts = nm-&gt;len();</a>
<a name="ln478">                  int tracks = oscore-&gt;nstaves() * VOICES;</a>
<a name="ln479">                  for (int srcTrack = 0; srcTrack &lt; tracks; ++srcTrack) {</a>
<a name="ln480">                        TupletMap tupletMap;    // tuplets cannot cross measure boundaries</a>
<a name="ln481"> </a>
<a name="ln482">                        int strack = trackList.value(srcTrack, -1);</a>
<a name="ln483"> </a>
<a name="ln484">                        Tremolo* tremolo = 0;</a>
<a name="ln485">                        for (Segment* oseg = m-&gt;first(); oseg; oseg = oseg-&gt;next()) {</a>
<a name="ln486">                              Segment* ns = nullptr; //create segment later, on demand</a>
<a name="ln487">                              for (Element* e : oseg-&gt;annotations()) {</a>
<a name="ln488">                                    if (e-&gt;generated())</a>
<a name="ln489">                                          continue;</a>
<a name="ln490">                                    if ((e-&gt;track() == srcTrack &amp;&amp; strack != -1) || (e-&gt;systemFlag() &amp;&amp; srcTrack == 0)) {</a>
<a name="ln491">                                          Element* ne = e-&gt;linkedClone();</a>
<a name="ln492">                                          // reset offset as most likely it will not fit</a>
<a name="ln493">                                          PropertyFlags f = ne-&gt;propertyFlags(Pid::OFFSET);</a>
<a name="ln494">                                          if (f == PropertyFlags::UNSTYLED) {</a>
<a name="ln495">                                                ne-&gt;setPropertyFlags(Pid::OFFSET, PropertyFlags::STYLED);</a>
<a name="ln496">                                                ne-&gt;resetProperty(Pid::OFFSET);</a>
<a name="ln497">                                                }</a>
<a name="ln498">                                          ne-&gt;setTrack(strack == -1 ? 0 : strack);</a>
<a name="ln499">                                          ne-&gt;setScore(score);</a>
<a name="ln500">                                          if (!ns)</a>
<a name="ln501">                                                ns = nm-&gt;getSegment(oseg-&gt;segmentType(), oseg-&gt;tick());</a>
<a name="ln502">                                          ns-&gt;add(ne);</a>
<a name="ln503">                                          // for chord symbols,</a>
<a name="ln504">                                          // re-render with new style settings</a>
<a name="ln505">                                          if (ne-&gt;isHarmony()) {</a>
<a name="ln506">                                                Harmony* h = toHarmony(ne);</a>
<a name="ln507">                                                h-&gt;render();</a>
<a name="ln508">                                                }</a>
<a name="ln509">                                          }</a>
<a name="ln510">                                    }</a>
<a name="ln511"> </a>
<a name="ln512">                              //If track is not mapped skip the following</a>
<a name="ln513">                              if (trackList.value(srcTrack, -1) == -1)</a>
<a name="ln514">                                    continue;</a>
<a name="ln515"> </a>
<a name="ln516">                              //There are probably more destination tracks for the same source</a>
<a name="ln517">                              QList&lt;int&gt; t = trackList.values(srcTrack);</a>
<a name="ln518"> </a>
<a name="ln519">                              for (int track : t) {</a>
<a name="ln520">                                    //Clone KeySig TimeSig and Clefs if voice 1 of source staff is not mapped to a track</a>
<a name="ln521">                                    Element* oef = oseg-&gt;element(srcTrack &amp; ~3);</a>
<a name="ln522">                                    if (oef &amp;&amp; (oef-&gt;isTimeSig() || oef-&gt;isKeySig()) &amp;&amp; oef-&gt;tick().isZero()</a>
<a name="ln523">                                        &amp;&amp; !(trackList.size() == (score-&gt;excerpt()-&gt;parts().size() * VOICES))) {</a>
<a name="ln524">                                          Element* ne = oef-&gt;linkedClone();</a>
<a name="ln525">                                          ne-&gt;setTrack(track &amp; ~3);</a>
<a name="ln526">                                          ne-&gt;setScore(score);</a>
<a name="ln527">                                          ns = nm-&gt;getSegment(oseg-&gt;segmentType(), oseg-&gt;tick());</a>
<a name="ln528">                                          ns-&gt;add(ne);</a>
<a name="ln529">                                          }</a>
<a name="ln530"> </a>
<a name="ln531">                                    Element* oe = oseg-&gt;element(srcTrack);</a>
<a name="ln532">                                    int adjustedBarlineSpan = 0;</a>
<a name="ln533">                                    if (srcTrack % VOICES == 0 &amp;&amp; oseg-&gt;segmentType() == SegmentType::BarLine) {</a>
<a name="ln534">                                          // mid-measure barline segment</a>
<a name="ln535">                                          // may need to clone barline from a previous staff and/or adjust span</a>
<a name="ln536">                                          int oIdx = srcTrack / VOICES;</a>
<a name="ln537">                                          if (!oe) {</a>
<a name="ln538">                                                // no barline on this staff in original score,</a>
<a name="ln539">                                                // but check previous staves</a>
<a name="ln540">                                                for (int i = oIdx - 1; i &gt;= 0; --i) {</a>
<a name="ln541">                                                      oe = oseg-&gt;element(i * VOICES);</a>
<a name="ln542">                                                      if (oe)</a>
<a name="ln543">                                                            break;</a>
<a name="ln544">                                                      }</a>
<a name="ln545">                                                }</a>
<a name="ln546">                                          if (oe) {</a>
<a name="ln547">                                                // barline found, now check span</a>
<a name="ln548">                                                BarLine* bl = toBarLine(oe);</a>
<a name="ln549">                                                int oSpan1 = bl-&gt;staff()-&gt;idx();</a>
<a name="ln550">                                                int oSpan2 = oSpan1 + bl-&gt;spanStaff();</a>
<a name="ln551">                                                if (oSpan1 &lt;= oIdx &amp;&amp; oIdx &lt; oSpan2) {</a>
<a name="ln552">                                                      // this staff is within span</a>
<a name="ln553">                                                      // calculate adjusted span for excerpt</a>
<a name="ln554">                                                      int oSpan = oSpan2 - oIdx;</a>
<a name="ln555">                                                      adjustedBarlineSpan = qMin(oSpan, score-&gt;nstaves());</a>
<a name="ln556">                                                      }</a>
<a name="ln557">                                                else {</a>
<a name="ln558">                                                      // this staff is not within span</a>
<a name="ln559">                                                      oe = nullptr;</a>
<a name="ln560">                                                      }</a>
<a name="ln561">                                                }</a>
<a name="ln562">                                          }</a>
<a name="ln563"> </a>
<a name="ln564">                                    if (oe &amp;&amp; !oe-&gt;generated()) {</a>
<a name="ln565">                                          Element* ne;</a>
<a name="ln566">                                          ne = oe-&gt;linkedClone();</a>
<a name="ln567">                                          ne-&gt;setTrack(track);</a>
<a name="ln568"> </a>
<a name="ln569">                                          if (!(ne-&gt;track() % VOICES) &amp;&amp; ne-&gt;isRest())</a>
<a name="ln570">                                                toRest(ne)-&gt;setGap(false);</a>
<a name="ln571"> </a>
<a name="ln572">                                          ne-&gt;setScore(score);</a>
<a name="ln573">                                          if (oe-&gt;type() == ElementType::BAR_LINE &amp;&amp; adjustedBarlineSpan) {</a>
<a name="ln574">                                                BarLine* nbl = toBarLine(ne);</a>
<a name="ln575">                                                nbl-&gt;setSpanStaff(adjustedBarlineSpan);</a>
<a name="ln576">                                                }</a>
<a name="ln577">                                          else if (oe-&gt;isChordRest()) {</a>
<a name="ln578">                                                ChordRest* ocr = toChordRest(oe);</a>
<a name="ln579">                                                ChordRest* ncr = toChordRest(ne);</a>
<a name="ln580"> </a>
<a name="ln581">                                                if (ocr-&gt;beam() &amp;&amp; !ocr-&gt;beam()-&gt;empty() &amp;&amp; ocr-&gt;beam()-&gt;elements().front() == ocr) {</a>
<a name="ln582">                                                      Beam* nb = ocr-&gt;beam()-&gt;clone();</a>
<a name="ln583">                                                      nb-&gt;clear();</a>
<a name="ln584">                                                      nb-&gt;setTrack(track);</a>
<a name="ln585">                                                      nb-&gt;setScore(score);</a>
<a name="ln586">                                                      nb-&gt;add(ncr);</a>
<a name="ln587">                                                      ncr-&gt;setBeam(nb);</a>
<a name="ln588">                                                      }</a>
<a name="ln589"> </a>
<a name="ln590">                                                Tuplet* ot = ocr-&gt;tuplet();</a>
<a name="ln591"> </a>
<a name="ln592">                                                if (ot)</a>
<a name="ln593">                                                      cloneTuplets(ocr, ncr, ot, tupletMap, nm, track);</a>
<a name="ln594"> </a>
<a name="ln595">                                                if (oe-&gt;isChord()) {</a>
<a name="ln596">                                                      Chord* och = toChord(ocr);</a>
<a name="ln597">                                                      Chord* nch = toChord(ncr);</a>
<a name="ln598"> </a>
<a name="ln599">                                                      size_t n = och-&gt;notes().size();</a>
<a name="ln600">                                                      for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln601">                                                            Note* on = och-&gt;notes().at(i);</a>
<a name="ln602">                                                            Note* nn = nch-&gt;notes().at(i);</a>
<a name="ln603">                                                            if (on-&gt;tieFor()) {</a>
<a name="ln604">                                                                  Tie* tie = toTie(on-&gt;tieFor()-&gt;linkedClone());</a>
<a name="ln605">                                                                  tie-&gt;setScore(score);</a>
<a name="ln606">                                                                  nn-&gt;setTieFor(tie);</a>
<a name="ln607">                                                                  tie-&gt;setStartNote(nn);</a>
<a name="ln608">                                                                  tie-&gt;setTrack(nn-&gt;track());</a>
<a name="ln609">                                                                  tieMap.add(on-&gt;tieFor(), tie);</a>
<a name="ln610">                                                                  }</a>
<a name="ln611">                                                            if (on-&gt;tieBack()) {</a>
<a name="ln612">                                                                  Tie* tie = tieMap.findNew(on-&gt;tieBack());</a>
<a name="ln613">                                                                  if (tie) {</a>
<a name="ln614">                                                                        nn-&gt;setTieBack(tie);</a>
<a name="ln615">                                                                        tie-&gt;setEndNote(nn);</a>
<a name="ln616">                                                                        }</a>
<a name="ln617">                                                                  else {</a>
<a name="ln618">                                                                        qDebug(&quot;cloneStaves: cannot find tie&quot;);</a>
<a name="ln619">                                                                        }</a>
<a name="ln620">                                                                  }</a>
<a name="ln621">                                                            // add back spanners (going back from end to start spanner element</a>
<a name="ln622">                                                            // makes sure the 'other' spanner anchor element is already set up)</a>
<a name="ln623">                                                            // 'on' is the old spanner end note and 'nn' is the new spanner end note</a>
<a name="ln624">                                                            for (Spanner* oldSp : on-&gt;spannerBack()) {</a>
<a name="ln625">                                                                  if (oldSp-&gt;startElement() &amp;&amp; oldSp-&gt;endElement() &amp;&amp; oldSp-&gt;startElement()-&gt;track() &gt; oldSp-&gt;endElement()-&gt;track())</a>
<a name="ln626">                                                                        continue;</a>
<a name="ln627">                                                                  Note* newStart = Spanner::startElementFromSpanner(oldSp, nn);</a>
<a name="ln628">                                                                  if (newStart != nullptr) {</a>
<a name="ln629">                                                                        Spanner* newSp = toSpanner(oldSp-&gt;linkedClone());</a>
<a name="ln630">                                                                        newSp-&gt;setNoteSpan(newStart, nn);</a>
<a name="ln631">                                                                        score-&gt;addElement(newSp);</a>
<a name="ln632">                                                                        }</a>
<a name="ln633">                                                                  else {</a>
<a name="ln634">                                                                        qDebug(&quot;cloneStaves: cannot find spanner start note&quot;);</a>
<a name="ln635">                                                                        }</a>
<a name="ln636">                                                                  }</a>
<a name="ln637">                                                            for (Spanner* oldSp : on-&gt;spannerFor()) {</a>
<a name="ln638">                                                                  if (oldSp-&gt;startElement() &amp;&amp; oldSp-&gt;endElement() &amp;&amp; oldSp-&gt;startElement()-&gt;track() &lt;= oldSp-&gt;endElement()-&gt;track())</a>
<a name="ln639">                                                                        continue;</a>
<a name="ln640">                                                                  Note* newEnd = Spanner::endElementFromSpanner(oldSp, nn);</a>
<a name="ln641">                                                                  if (newEnd != nullptr) {</a>
<a name="ln642">                                                                        Spanner* newSp = toSpanner(oldSp-&gt;linkedClone());</a>
<a name="ln643">                                                                        newSp-&gt;setNoteSpan(nn, newEnd);</a>
<a name="ln644">                                                                        score-&gt;addElement(newSp);</a>
<a name="ln645">                                                                        }</a>
<a name="ln646">                                                                  else {</a>
<a name="ln647">                                                                        qDebug(&quot;cloneStaves: cannot find spanner end note&quot;);</a>
<a name="ln648">                                                                        }</a>
<a name="ln649">                                                                  }</a>
<a name="ln650">                                                            }</a>
<a name="ln651">                                                      // two note tremolo</a>
<a name="ln652">                                                      if (och-&gt;tremolo() &amp;&amp; och-&gt;tremolo()-&gt;twoNotes()) {</a>
<a name="ln653">                                                           if (och == och-&gt;tremolo()-&gt;chord1()) {</a>
<a name="ln654">                                                                  if (tremolo)</a>
<a name="ln655">                                                                        qDebug(&quot;unconnected two note tremolo&quot;);</a>
<a name="ln656">                                                                  tremolo = toTremolo(och-&gt;tremolo()-&gt;linkedClone());</a>
<a name="ln657">                                                                  tremolo-&gt;setScore(nch-&gt;score());</a>
<a name="ln658">                                                                  tremolo-&gt;setParent(nch);</a>
<a name="ln659">                                                                  tremolo-&gt;setTrack(nch-&gt;track());</a>
<a name="ln660">                                                                  tremolo-&gt;setChords(nch, 0);</a>
<a name="ln661">                                                                  nch-&gt;setTremolo(tremolo);</a>
<a name="ln662">                                                                  }</a>
<a name="ln663">                                                            else if (och == och-&gt;tremolo()-&gt;chord2()) {</a>
<a name="ln664">                                                                  if (!tremolo)</a>
<a name="ln665">                                                                        qDebug(&quot;first note for two note tremolo missing&quot;);</a>
<a name="ln666">                                                                  else {</a>
<a name="ln667">                                                                        tremolo-&gt;setChords(tremolo-&gt;chord1(), nch);</a>
<a name="ln668">                                                                        nch-&gt;setTremolo(tremolo);</a>
<a name="ln669">                                                                        }</a>
<a name="ln670">                                                                  }</a>
<a name="ln671">                                                            else</a>
<a name="ln672">                                                                  qDebug(&quot;inconsistent two note tremolo&quot;);</a>
<a name="ln673">                                                            }</a>
<a name="ln674">                                                      }</a>
<a name="ln675">                                                }</a>
<a name="ln676">                                          if (!ns)</a>
<a name="ln677">                                                ns = nm-&gt;getSegment(oseg-&gt;segmentType(), oseg-&gt;tick());</a>
<a name="ln678">                                          ns-&gt;add(ne);</a>
<a name="ln679">                                          }</a>
<a name="ln680"> </a>
<a name="ln681">                                    Segment* tst = nm-&gt;segments().firstCRSegment();</a>
<a name="ln682">                                    if (srcTrack % VOICES &amp;&amp; !(track % VOICES) &amp;&amp; (!tst || (!tst-&gt;element(track)))) {</a>
<a name="ln683">                                          Rest* rest = new Rest(score);</a>
<a name="ln684">                                          rest-&gt;setTicks(nm-&gt;ticks());</a>
<a name="ln685">                                          rest-&gt;setDurationType(nm-&gt;ticks());</a>
<a name="ln686">                                          rest-&gt;setTrack(track);</a>
<a name="ln687">                                          Segment* segment = nm-&gt;getSegment(SegmentType::ChordRest, nm-&gt;tick());</a>
<a name="ln688">                                          segment-&gt;add(rest);</a>
<a name="ln689">                                          }</a>
<a name="ln690"> </a>
<a name="ln691">                                    }</a>
<a name="ln692">                              }</a>
<a name="ln693">                        }</a>
<a name="ln694">                  }</a>
<a name="ln695"> </a>
<a name="ln696">            nmb-&gt;linkTo(mb);</a>
<a name="ln697">            for (Element* e : mb-&gt;el()) {</a>
<a name="ln698">                  if (e-&gt;isLayoutBreak()) {</a>
<a name="ln699">                        LayoutBreak::Type st = toLayoutBreak(e)-&gt;layoutBreakType();</a>
<a name="ln700">                        if (st == LayoutBreak::Type::PAGE || st == LayoutBreak::Type::LINE)</a>
<a name="ln701">                              continue;</a>
<a name="ln702">                        }</a>
<a name="ln703">                  int track = -1;</a>
<a name="ln704">                  if (e-&gt;track() != -1) {</a>
<a name="ln705">                        // try to map track</a>
<a name="ln706">                        track = trackList.value(e-&gt;track(), -1);</a>
<a name="ln707">                        if (track == -1) {</a>
<a name="ln708">                              // even if track not in excerpt, we need to clone system elements</a>
<a name="ln709">                              if (e-&gt;systemFlag())</a>
<a name="ln710">                                    track = 0;</a>
<a name="ln711">                              else</a>
<a name="ln712">                                    continue;</a>
<a name="ln713">                              }</a>
<a name="ln714">                        }</a>
<a name="ln715"> </a>
<a name="ln716">                  Element* ne;</a>
<a name="ln717">                  // link text - title, subtitle, also repeats (eg, coda/segno)</a>
<a name="ln718">                  // measure numbers are not stored in this list, but they should not be cloned anyhow</a>
<a name="ln719">                  // layout breaks other than section were skipped above,</a>
<a name="ln720">                  // but section breaks do need to be cloned &amp; linked</a>
<a name="ln721">                  // other measure-attached elements (?) are cloned but not linked</a>
<a name="ln722">                  if (e-&gt;isText() &amp;&amp; toText(e)-&gt;tid() == Tid::INSTRUMENT_EXCERPT) {</a>
<a name="ln723">                        // skip part name in score</a>
<a name="ln724">                        continue;</a>
<a name="ln725">                        }</a>
<a name="ln726">                  else if (e-&gt;isTextBase() || e-&gt;isLayoutBreak()) {</a>
<a name="ln727">                        ne = e-&gt;clone();</a>
<a name="ln728">                        ne-&gt;setAutoplace(true);</a>
<a name="ln729">                        ne-&gt;linkTo(e);</a>
<a name="ln730">                        }</a>
<a name="ln731">                  else</a>
<a name="ln732">                        ne = e-&gt;clone();</a>
<a name="ln733">                  ne-&gt;setScore(score);</a>
<a name="ln734">                  ne-&gt;setTrack(track);</a>
<a name="ln735">                  nmb-&gt;add(ne);</a>
<a name="ln736">                  }</a>
<a name="ln737">            nmbl-&gt;add(nmb);</a>
<a name="ln738">            }</a>
<a name="ln739"> </a>
<a name="ln740">      int n = map.size();</a>
<a name="ln741">      for (int dstStaffIdx = 0; dstStaffIdx &lt; n; ++dstStaffIdx) {</a>
<a name="ln742">            Staff* srcStaff = oscore-&gt;staff(map[dstStaffIdx]);</a>
<a name="ln743">            Staff* dstStaff = score-&gt;staff(dstStaffIdx);</a>
<a name="ln744"> </a>
<a name="ln745">            if (srcStaff-&gt;primaryStaff()) {</a>
<a name="ln746">                  int span = srcStaff-&gt;barLineSpan();</a>
<a name="ln747">                  int sIdx = srcStaff-&gt;idx();</a>
<a name="ln748">                  if (dstStaffIdx == 0 &amp;&amp; span == 0) {</a>
<a name="ln749">                        // this is first staff of new score,</a>
<a name="ln750">                        // but it was somewhere within a barline span in the old score</a>
<a name="ln751">                        // so, find beginning of span</a>
<a name="ln752">                        for (int i = 0; i &lt;= sIdx; ++i) {</a>
<a name="ln753">                              span = oscore-&gt;staff(i)-&gt;barLineSpan();</a>
<a name="ln754">                              if (i + span &gt; sIdx) {</a>
<a name="ln755">                                    sIdx = i;</a>
<a name="ln756">                                    break;</a>
<a name="ln757">                                    }</a>
<a name="ln758">                              }</a>
<a name="ln759">                        }</a>
<a name="ln760">                  int eIdx = sIdx + span;</a>
<a name="ln761">                  for (int staffIdx = sIdx; staffIdx &lt; eIdx; ++staffIdx) {</a>
<a name="ln762">                        if (!map.contains(staffIdx))</a>
<a name="ln763">                             --span;</a>
<a name="ln764">                        }</a>
<a name="ln765">                  if (dstStaffIdx + span &gt; n)</a>
<a name="ln766">                        span = n - dstStaffIdx - 1;</a>
<a name="ln767">                  dstStaff-&gt;setBarLineSpan(span);</a>
<a name="ln768">                  int idx = 0;</a>
<a name="ln769">                  for (BracketItem* bi : srcStaff-&gt;brackets()) {</a>
<a name="ln770">                        dstStaff-&gt;setBracketType(idx, bi-&gt;bracketType());</a>
<a name="ln771">                        dstStaff-&gt;setBracketSpan(idx, bi-&gt;bracketSpan());</a>
<a name="ln772">                        }</a>
<a name="ln773">                  }</a>
<a name="ln774">            }</a>
<a name="ln775"> </a>
<a name="ln776">      for (auto i : oscore-&gt;spanner()) {</a>
<a name="ln777">            Spanner* s    = i.second;</a>
<a name="ln778">            int dstTrack  = -1;</a>
<a name="ln779">            int dstTrack2 = -1;</a>
<a name="ln780"> </a>
<a name="ln781">            if (s-&gt;type() == ElementType::VOLTA) {</a>
<a name="ln782">                  //always export voltas to first staff in part</a>
<a name="ln783">                  dstTrack  = 0;</a>
<a name="ln784">                  dstTrack2 = 0;</a>
<a name="ln785">                  cloneSpanner(s, score, dstTrack, dstTrack2);</a>
<a name="ln786">                  }</a>
<a name="ln787">            else if (s-&gt;isHairpin()) {</a>
<a name="ln788">                  //always export these spanners to first voice of the destination staff</a>
<a name="ln789"> </a>
<a name="ln790">                  QList&lt;int&gt; track1;</a>
<a name="ln791">                  for (int ii = s-&gt;track(); ii &lt; s-&gt;track() + VOICES; ii++) {</a>
<a name="ln792">                        track1 += trackList.values(ii);</a>
<a name="ln793">                        }</a>
<a name="ln794"> </a>
<a name="ln795">                  for (int track : track1) {</a>
<a name="ln796">                        if (!(track % VOICES))</a>
<a name="ln797">                              cloneSpanner(s, score, track, track);</a>
<a name="ln798">                        }</a>
<a name="ln799"> </a>
<a name="ln800">                  }</a>
<a name="ln801">            else {</a>
<a name="ln802">                  if (trackList.value(s-&gt;track(), -1) == -1 || trackList.value(s-&gt;track2(), -1) == -1)</a>
<a name="ln803">                        continue;</a>
<a name="ln804">                  QList&lt;int&gt; track1 = trackList.values(s-&gt;track());</a>
<a name="ln805">                  QList&lt;int&gt; track2 = trackList.values(s-&gt;track2());</a>
<a name="ln806"> </a>
<a name="ln807">                  if (track1.length() != track2.length())</a>
<a name="ln808">                        continue;</a>
<a name="ln809"> </a>
<a name="ln810">                  //export other spanner if staffidx matches</a>
<a name="ln811">                  for (int ii = 0; ii &lt; track1.length(); ii++) {</a>
<a name="ln812">                        dstTrack = track1.at(ii);</a>
<a name="ln813">                        dstTrack2 = track2.at(ii);</a>
<a name="ln814">                        cloneSpanner(s, score, dstTrack, dstTrack2);</a>
<a name="ln815">                        }</a>
<a name="ln816">                  }</a>
<a name="ln817">            }</a>
<a name="ln818">      }</a>
<a name="ln819"> </a>
<a name="ln820">//---------------------------------------------------------</a>
<a name="ln821">//   cloneStaff</a>
<a name="ln822">//    staves are in same score</a>
<a name="ln823">//---------------------------------------------------------</a>
<a name="ln824"> </a>
<a name="ln825">void Excerpt::cloneStaff(Staff* srcStaff, Staff* dstStaff)</a>
<a name="ln826">      {</a>
<a name="ln827">      Score* score = srcStaff-&gt;score();</a>
<a name="ln828">      TieMap tieMap;</a>
<a name="ln829"> </a>
<a name="ln830">      score-&gt;undo(new Link(dstStaff, srcStaff));</a>
<a name="ln831"> </a>
<a name="ln832">      int srcStaffIdx = srcStaff-&gt;idx();</a>
<a name="ln833">      int dstStaffIdx = dstStaff-&gt;idx();</a>
<a name="ln834"> </a>
<a name="ln835">      for (Measure* m = score-&gt;firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln836">            int sTrack = srcStaffIdx * VOICES;</a>
<a name="ln837">            int eTrack = sTrack + VOICES;</a>
<a name="ln838">            for (int srcTrack = sTrack; srcTrack &lt; eTrack; ++srcTrack) {</a>
<a name="ln839">                  TupletMap tupletMap;    // tuplets cannot cross measure boundaries</a>
<a name="ln840">                  int dstTrack = dstStaffIdx * VOICES + (srcTrack - sTrack);</a>
<a name="ln841">                  Tremolo* tremolo = 0;</a>
<a name="ln842">                  for (Segment* seg = m-&gt;first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln843">                        Element* oe = seg-&gt;element(srcTrack);</a>
<a name="ln844">                        if (oe == 0 || oe-&gt;generated())</a>
<a name="ln845">                              continue;</a>
<a name="ln846">                        if (oe-&gt;isTimeSig())</a>
<a name="ln847">                              continue;</a>
<a name="ln848">                        Element* ne = 0;</a>
<a name="ln849">                        if (oe-&gt;isClef()) {</a>
<a name="ln850">                              // only clone clef if it matches staff group and does not exists yet</a>
<a name="ln851">                              Clef* clef = toClef(oe);</a>
<a name="ln852">                              Fraction   tick = seg-&gt;tick();</a>
<a name="ln853">                              if (ClefInfo::staffGroup(clef-&gt;concertClef()) == dstStaff-&gt;constStaffType(Fraction(0,1))-&gt;group()</a>
<a name="ln854">                                          &amp;&amp; dstStaff-&gt;clefType(tick) != clef-&gt;clefTypeList()) {</a>
<a name="ln855">                                    ne = oe-&gt;clone();</a>
<a name="ln856">                                    }</a>
<a name="ln857">                              }</a>
<a name="ln858">                        else</a>
<a name="ln859">                              ne = oe-&gt;linkedClone();</a>
<a name="ln860">                        if (ne) {</a>
<a name="ln861">                              ne-&gt;setTrack(dstTrack);</a>
<a name="ln862">                              ne-&gt;setParent(seg);</a>
<a name="ln863">                              ne-&gt;setScore(score);</a>
<a name="ln864">                              if (ne-&gt;isChordRest()) {</a>
<a name="ln865">                                    ChordRest* ncr = toChordRest(ne);</a>
<a name="ln866">                                    if (ncr-&gt;tuplet()) {</a>
<a name="ln867">                                          ncr-&gt;setTuplet(0); //TODO nested tuplets</a>
<a name="ln868">                                          }</a>
<a name="ln869">                                    }</a>
<a name="ln870">                              score-&gt;undoAddElement(ne);</a>
<a name="ln871">                              }</a>
<a name="ln872">                        if (oe-&gt;isChordRest()) {</a>
<a name="ln873">                              ChordRest* ocr = toChordRest(oe);</a>
<a name="ln874">                              ChordRest* ncr = toChordRest(ne);</a>
<a name="ln875">                              Tuplet* ot     = ocr-&gt;tuplet();</a>
<a name="ln876">                              if (ot)</a>
<a name="ln877">                                    cloneTuplets(ocr, ncr, ot, tupletMap, m, dstTrack);</a>
<a name="ln878"> </a>
<a name="ln879">                              // remove lyrics from chord</a>
<a name="ln880">                              // since only one set of lyrics is used with linked staves</a>
<a name="ln881">                              foreach (Lyrics* l, ncr-&gt;lyrics()) {</a>
<a name="ln882">                                    if (l)</a>
<a name="ln883">                                          l-&gt;unlink();</a>
<a name="ln884">                                    }</a>
<a name="ln885">                              qDeleteAll(ncr-&gt;lyrics());</a>
<a name="ln886">                              ncr-&gt;lyrics().clear();</a>
<a name="ln887"> </a>
<a name="ln888">                              for (Element* e : seg-&gt;annotations()) {</a>
<a name="ln889">                                    if (e-&gt;generated() || e-&gt;systemFlag())</a>
<a name="ln890">                                          continue;</a>
<a name="ln891">                                    if (e-&gt;track() != srcTrack)</a>
<a name="ln892">                                          continue;</a>
<a name="ln893">                                    switch (e-&gt;type()) {</a>
<a name="ln894">                                          // exclude certain element types</a>
<a name="ln895">                                          // this should be same list excluded in Score::undoAddElement()</a>
<a name="ln896">                                          case ElementType::STAFF_TEXT:</a>
<a name="ln897">                                          case ElementType::SYSTEM_TEXT:</a>
<a name="ln898">                                          case ElementType::FRET_DIAGRAM:</a>
<a name="ln899">                                          case ElementType::HARMONY:</a>
<a name="ln900">                                          case ElementType::FIGURED_BASS:</a>
<a name="ln901">                                          case ElementType::DYNAMIC:</a>
<a name="ln902">                                          case ElementType::LYRICS:   // not normally segment-attached</a>
<a name="ln903">                                                continue;</a>
<a name="ln904">                                          default:</a>
<a name="ln905">                                                Element* ne1 = e-&gt;clone();</a>
<a name="ln906">                                                ne1-&gt;setTrack(dstTrack);</a>
<a name="ln907">                                                ne1-&gt;setParent(seg);</a>
<a name="ln908">                                                ne1-&gt;setScore(score);</a>
<a name="ln909">                                                score-&gt;undoAddElement(ne1);</a>
<a name="ln910">                                          }</a>
<a name="ln911">                                    }</a>
<a name="ln912">                              if (oe-&gt;isChord()) {</a>
<a name="ln913">                                    Chord* och = toChord(ocr);</a>
<a name="ln914">                                    Chord* nch = toChord(ncr);</a>
<a name="ln915">                                    size_t n = och-&gt;notes().size();</a>
<a name="ln916">                                    for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln917">                                          Note* on = och-&gt;notes().at(i);</a>
<a name="ln918">                                          Note* nn = nch-&gt;notes().at(i);</a>
<a name="ln919">                                          if (on-&gt;tieFor()) {</a>
<a name="ln920">                                                Tie* tie = toTie(on-&gt;tieFor()-&gt;linkedClone());</a>
<a name="ln921">                                                tie-&gt;setScore(score);</a>
<a name="ln922">                                                nn-&gt;setTieFor(tie);</a>
<a name="ln923">                                                tie-&gt;setStartNote(nn);</a>
<a name="ln924">                                                tie-&gt;setTrack(nn-&gt;track());</a>
<a name="ln925">                                                tieMap.add(on-&gt;tieFor(), tie);</a>
<a name="ln926">                                                }</a>
<a name="ln927">                                          if (on-&gt;tieBack()) {</a>
<a name="ln928">                                                Tie* tie = tieMap.findNew(on-&gt;tieBack());</a>
<a name="ln929">                                                if (tie) {</a>
<a name="ln930">                                                      nn-&gt;setTieBack(tie);</a>
<a name="ln931">                                                      tie-&gt;setEndNote(nn);</a>
<a name="ln932">                                                      }</a>
<a name="ln933">                                                else {</a>
<a name="ln934">                                                      qDebug(&quot;cloneStave: cannot find tie&quot;);</a>
<a name="ln935">                                                      }</a>
<a name="ln936">                                                }</a>
<a name="ln937">                                          // add back spanners (going back from end to start spanner element</a>
<a name="ln938">                                          // makes sure the 'other' spanner anchor element is already set up)</a>
<a name="ln939">                                          // 'on' is the old spanner end note and 'nn' is the new spanner end note</a>
<a name="ln940">                                          for (Spanner* oldSp : on-&gt;spannerBack()) {</a>
<a name="ln941">                                                Note* newStart = Spanner::startElementFromSpanner(oldSp, nn);</a>
<a name="ln942">                                                if (newStart != nullptr) {</a>
<a name="ln943">                                                      Spanner* newSp = toSpanner(oldSp-&gt;linkedClone());</a>
<a name="ln944">                                                      newSp-&gt;setNoteSpan(newStart, nn);</a>
<a name="ln945">                                                      score-&gt;addElement(newSp);</a>
<a name="ln946">                                                      }</a>
<a name="ln947">                                                else {</a>
<a name="ln948">                                                      qDebug(&quot;cloneStave: cannot find spanner start note&quot;);</a>
<a name="ln949">                                                      }</a>
<a name="ln950">                                                }</a>
<a name="ln951">                                          }</a>
<a name="ln952">                                    // two note tremolo</a>
<a name="ln953">                                    if (och-&gt;tremolo() &amp;&amp; och-&gt;tremolo()-&gt;twoNotes()) {</a>
<a name="ln954">                                          if (och == och-&gt;tremolo()-&gt;chord1()) {</a>
<a name="ln955">                                                if (tremolo)</a>
<a name="ln956">                                                      qDebug(&quot;unconnected two note tremolo&quot;);</a>
<a name="ln957">                                                tremolo = toTremolo(och-&gt;tremolo()-&gt;linkedClone());</a>
<a name="ln958">                                                tremolo-&gt;setScore(nch-&gt;score());</a>
<a name="ln959">                                                tremolo-&gt;setParent(nch);</a>
<a name="ln960">                                                tremolo-&gt;setTrack(nch-&gt;track());</a>
<a name="ln961">                                                tremolo-&gt;setChords(nch, 0);</a>
<a name="ln962">                                                nch-&gt;setTremolo(tremolo);</a>
<a name="ln963">                                                }</a>
<a name="ln964">                                          else if (och == och-&gt;tremolo()-&gt;chord2()) {</a>
<a name="ln965">                                                if (!tremolo)</a>
<a name="ln966">                                                      qDebug(&quot;first note for two note tremolo missing&quot;);</a>
<a name="ln967">                                                else {</a>
<a name="ln968">                                                      tremolo-&gt;setChords(tremolo-&gt;chord1(), nch);</a>
<a name="ln969">                                                      nch-&gt;setTremolo(tremolo);</a>
<a name="ln970">                                                      }</a>
<a name="ln971">                                                }</a>
<a name="ln972">                                          else</a>
<a name="ln973">                                                qDebug(&quot;inconsistent two note tremolo&quot;);</a>
<a name="ln974">                                          }</a>
<a name="ln975">                                    }</a>
<a name="ln976">                              }</a>
<a name="ln977">                        }</a>
<a name="ln978">                  }</a>
<a name="ln979">            }</a>
<a name="ln980"> </a>
<a name="ln981">      for (auto i : score-&gt;spanner()) {</a>
<a name="ln982">            Spanner* s = i.second;</a>
<a name="ln983">            int staffIdx = s-&gt;staffIdx();</a>
<a name="ln984">            int dstTrack = -1;</a>
<a name="ln985">            int dstTrack2 = -1;</a>
<a name="ln986">            if (s-&gt;type() != ElementType::VOLTA) {</a>
<a name="ln987">                  //export other spanner if staffidx matches</a>
<a name="ln988">                  if (srcStaffIdx == staffIdx) {</a>
<a name="ln989">                        dstTrack = dstStaffIdx * VOICES + s-&gt;voice();</a>
<a name="ln990">                        dstTrack2 = dstStaffIdx * VOICES + (s-&gt;track2() % VOICES);</a>
<a name="ln991">                        }</a>
<a name="ln992">                  }</a>
<a name="ln993">            if (dstTrack == -1)</a>
<a name="ln994">                  continue;</a>
<a name="ln995">            cloneSpanner(s, score, dstTrack, dstTrack2);</a>
<a name="ln996">            }</a>
<a name="ln997">      }</a>
<a name="ln998"> </a>
<a name="ln999">//---------------------------------------------------------</a>
<a name="ln1000">//   cloneStaff2</a>
<a name="ln1001">//    staves are potentially in different scores</a>
<a name="ln1002">//---------------------------------------------------------</a>
<a name="ln1003"> </a>
<a name="ln1004">void Excerpt::cloneStaff2(Staff* srcStaff, Staff* dstStaff, const Fraction&amp; stick, const Fraction&amp; etick)</a>
<a name="ln1005">      {</a>
<a name="ln1006">      Score* oscore = srcStaff-&gt;score();</a>
<a name="ln1007">      Score* score  = dstStaff-&gt;score();</a>
<a name="ln1008"> </a>
<a name="ln1009">      Excerpt* oex = oscore-&gt;excerpt();</a>
<a name="ln1010">      Excerpt* ex  = score-&gt;excerpt();</a>
<a name="ln1011">      QMultiMap&lt;int, int&gt; otracks, tracks;</a>
<a name="ln1012">      if (oex)</a>
<a name="ln1013">            otracks = oex-&gt;tracks();</a>
<a name="ln1014">      if (ex)</a>
<a name="ln1015">            tracks  = ex-&gt;tracks();</a>
<a name="ln1016"> </a>
<a name="ln1017">      Measure* m1   = oscore-&gt;tick2measure(stick);</a>
<a name="ln1018">      Measure* m2   = oscore-&gt;tick2measure(etick);</a>
<a name="ln1019"> </a>
<a name="ln1020">      if (m2-&gt;tick() &lt; etick) // end of score</a>
<a name="ln1021">            m2 = 0;</a>
<a name="ln1022"> </a>
<a name="ln1023">      TieMap tieMap;</a>
<a name="ln1024"> </a>
<a name="ln1025">      int srcStaffIdx = srcStaff-&gt;idx();</a>
<a name="ln1026">      int dstStaffIdx = dstStaff-&gt;idx();</a>
<a name="ln1027"> </a>
<a name="ln1028">      int sTrack = srcStaffIdx * VOICES;</a>
<a name="ln1029">      int eTrack = sTrack + VOICES;</a>
<a name="ln1030"> </a>
<a name="ln1031">      QMap&lt;int, int&gt; map;</a>
<a name="ln1032">      for (int i = sTrack; i &lt; eTrack; i++) {</a>
<a name="ln1033">            if (!oex &amp;&amp; !ex)</a>
<a name="ln1034">                  map.insert(i, dstStaffIdx * VOICES + i % VOICES);</a>
<a name="ln1035">            else if (oex &amp;&amp; !ex) {</a>
<a name="ln1036">                  if (otracks.key(i, -1) != -1)</a>
<a name="ln1037">                        map.insert(i, otracks.key(i));</a>
<a name="ln1038">                  }</a>
<a name="ln1039">            else if (!oex &amp;&amp; ex) {</a>
<a name="ln1040">                  for (int j : tracks.values(i)) {</a>
<a name="ln1041">                        if (dstStaffIdx * VOICES &lt;= j &amp;&amp; j &lt; (dstStaffIdx + 1) * VOICES) {</a>
<a name="ln1042">                              map.insert(i, j);</a>
<a name="ln1043">                              break;</a>
<a name="ln1044">                              }</a>
<a name="ln1045">                        }</a>
<a name="ln1046">                  }</a>
<a name="ln1047">            else if (oex &amp;&amp; ex) {</a>
<a name="ln1048">                  if (otracks.key(i, -1) != -1) {</a>
<a name="ln1049">                        for (int j : tracks.values(otracks.key(i))) {</a>
<a name="ln1050">                              if (dstStaffIdx * VOICES &lt;= j &amp;&amp; j &lt; (dstStaffIdx + 1) * VOICES) {</a>
<a name="ln1051">                                    map.insert(i, j);</a>
<a name="ln1052">                                    break;</a>
<a name="ln1053">                                    }</a>
<a name="ln1054">                              }</a>
<a name="ln1055">                        }</a>
<a name="ln1056">                  }</a>
<a name="ln1057">            }</a>
<a name="ln1058"> </a>
<a name="ln1059"> </a>
<a name="ln1060">      for (Measure* m = m1; m &amp;&amp; (m != m2); m = m-&gt;nextMeasure()) {</a>
<a name="ln1061">            Measure* nm = score-&gt;tick2measure(m-&gt;tick());</a>
<a name="ln1062">            for (int srcTrack : map.keys()) {</a>
<a name="ln1063">                  TupletMap tupletMap;    // tuplets cannot cross measure boundaries</a>
<a name="ln1064">                  int dstTrack = map.value(srcTrack);</a>
<a name="ln1065">                  for (Segment* oseg = m-&gt;first(); oseg; oseg = oseg-&gt;next()) {</a>
<a name="ln1066">                        Element* oe = oseg-&gt;element(srcTrack);</a>
<a name="ln1067">                        if (oe == 0 || oe-&gt;generated())</a>
<a name="ln1068">                              continue;</a>
<a name="ln1069">                        if (oe-&gt;type() == ElementType::TIMESIG)</a>
<a name="ln1070">                              continue;</a>
<a name="ln1071">                        Segment* ns = nm-&gt;getSegment(oseg-&gt;segmentType(), oseg-&gt;tick());</a>
<a name="ln1072">                        Element* ne = oe-&gt;linkedClone();</a>
<a name="ln1073">                        ne-&gt;setTrack(dstTrack);</a>
<a name="ln1074">                        ne-&gt;setParent(ns);</a>
<a name="ln1075">                        ne-&gt;setScore(score);</a>
<a name="ln1076">                        score-&gt;undoAddElement(ne);</a>
<a name="ln1077">                        if (oe-&gt;isChordRest()) {</a>
<a name="ln1078">                              ChordRest* ocr = toChordRest(oe);</a>
<a name="ln1079">                              ChordRest* ncr = toChordRest(ne);</a>
<a name="ln1080">                              Tuplet* ot     = ocr-&gt;tuplet();</a>
<a name="ln1081">                              if (ot) {</a>
<a name="ln1082">                                    Tuplet* nt = tupletMap.findNew(ot);</a>
<a name="ln1083">                                    if (nt == 0) {</a>
<a name="ln1084">                                          // nt = new Tuplet(*ot);</a>
<a name="ln1085">                                          nt = toTuplet(ot-&gt;linkedClone());</a>
<a name="ln1086">                                          nt-&gt;clear();</a>
<a name="ln1087">                                          nt-&gt;setTrack(dstTrack);</a>
<a name="ln1088">                                          nt-&gt;setParent(m);</a>
<a name="ln1089">                                          tupletMap.add(ot, nt);</a>
<a name="ln1090">                                          }</a>
<a name="ln1091">                                    ncr-&gt;setTuplet(nt);</a>
<a name="ln1092">                                    nt-&gt;add(ncr);</a>
<a name="ln1093">                                    }</a>
<a name="ln1094"> </a>
<a name="ln1095">                              for (Element* e : oseg-&gt;annotations()) {</a>
<a name="ln1096">                                    if (e-&gt;generated() || e-&gt;systemFlag())</a>
<a name="ln1097">                                          continue;</a>
<a name="ln1098">                                    if (e-&gt;track() != srcTrack)</a>
<a name="ln1099">                                          continue;</a>
<a name="ln1100">                                    switch (e-&gt;type()) {</a>
<a name="ln1101">                                          // exclude certain element types</a>
<a name="ln1102">                                          // this should be same list excluded in Score::undoAddElement()</a>
<a name="ln1103">                                          case ElementType::STAFF_TEXT:</a>
<a name="ln1104">                                          case ElementType::SYSTEM_TEXT:</a>
<a name="ln1105">                                          case ElementType::FRET_DIAGRAM:</a>
<a name="ln1106">                                          case ElementType::HARMONY:</a>
<a name="ln1107">                                          case ElementType::FIGURED_BASS:</a>
<a name="ln1108">                                          case ElementType::DYNAMIC:</a>
<a name="ln1109">                                          case ElementType::LYRICS:   // not normally segment-attached</a>
<a name="ln1110">                                                continue;</a>
<a name="ln1111">                                          default:</a>
<a name="ln1112">                                                Element* ne1 = e-&gt;clone();</a>
<a name="ln1113">                                                ne1-&gt;setTrack(dstTrack);</a>
<a name="ln1114">                                                ne1-&gt;setParent(ns);</a>
<a name="ln1115">                                                ne1-&gt;setScore(score);</a>
<a name="ln1116">                                                score-&gt;undoAddElement(ne1);</a>
<a name="ln1117">                                          }</a>
<a name="ln1118">                                    }</a>
<a name="ln1119">                              if (oe-&gt;isChord()) {</a>
<a name="ln1120">                                    Chord* och = toChord(ocr);</a>
<a name="ln1121">                                    Chord* nch = toChord(ncr);</a>
<a name="ln1122">                                    size_t n = och-&gt;notes().size();</a>
<a name="ln1123">                                    for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln1124">                                          Note* on = och-&gt;notes().at(i);</a>
<a name="ln1125">                                          Note* nn = nch-&gt;notes().at(i);</a>
<a name="ln1126">                                          if (on-&gt;tieFor()) {</a>
<a name="ln1127">                                                Tie* tie = toTie(on-&gt;tieFor()-&gt;linkedClone());</a>
<a name="ln1128">                                                tie-&gt;setScore(score);</a>
<a name="ln1129">                                                nn-&gt;setTieFor(tie);</a>
<a name="ln1130">                                                tie-&gt;setStartNote(nn);</a>
<a name="ln1131">                                                tie-&gt;setTrack(nn-&gt;track());</a>
<a name="ln1132">                                                tieMap.add(on-&gt;tieFor(), tie);</a>
<a name="ln1133">                                                }</a>
<a name="ln1134">                                          if (on-&gt;tieBack()) {</a>
<a name="ln1135">                                                Tie* tie = tieMap.findNew(on-&gt;tieBack());</a>
<a name="ln1136">                                                if (tie) {</a>
<a name="ln1137">                                                      nn-&gt;setTieBack(tie);</a>
<a name="ln1138">                                                      tie-&gt;setEndNote(nn);</a>
<a name="ln1139">                                                      }</a>
<a name="ln1140">                                                else {</a>
<a name="ln1141">                                                      qDebug(&quot;cloneStave: cannot find tie&quot;);</a>
<a name="ln1142">                                                      }</a>
<a name="ln1143">                                                }</a>
<a name="ln1144">                                          }</a>
<a name="ln1145">                                    }</a>
<a name="ln1146">                              }</a>
<a name="ln1147">                        }</a>
<a name="ln1148">                  }</a>
<a name="ln1149">            }</a>
<a name="ln1150"> </a>
<a name="ln1151">      for (auto i : oscore-&gt;spanner()) {</a>
<a name="ln1152">            Spanner* s = i.second;</a>
<a name="ln1153">            if (!(s-&gt;tick() &gt;= stick &amp;&amp; s-&gt;tick2() &lt; etick))</a>
<a name="ln1154">                  continue;</a>
<a name="ln1155"> </a>
<a name="ln1156">            int staffIdx = s-&gt;staffIdx();</a>
<a name="ln1157">            int dstTrack = -1;</a>
<a name="ln1158">            int dstTrack2 = -1;</a>
<a name="ln1159">            if (s-&gt;type() != ElementType::VOLTA) {</a>
<a name="ln1160">                  //export other spanner if staffidx matches</a>
<a name="ln1161">                  if (srcStaffIdx == staffIdx) {</a>
<a name="ln1162">                        dstTrack  = dstStaffIdx * VOICES + s-&gt;voice();</a>
<a name="ln1163">                        dstTrack2 = dstStaffIdx * VOICES + (s-&gt;track2() % VOICES);</a>
<a name="ln1164">                        }</a>
<a name="ln1165">                  }</a>
<a name="ln1166">            if (dstTrack == -1)</a>
<a name="ln1167">                  continue;</a>
<a name="ln1168">            cloneSpanner(s, score, dstTrack, dstTrack2);</a>
<a name="ln1169">            }</a>
<a name="ln1170">      }</a>
<a name="ln1171"> </a>
<a name="ln1172">//---------------------------------------------------------</a>
<a name="ln1173">//   createAllExcerpt</a>
<a name="ln1174">//---------------------------------------------------------</a>
<a name="ln1175"> </a>
<a name="ln1176">QList&lt;Excerpt*&gt; Excerpt::createAllExcerpt(MasterScore *score)</a>
<a name="ln1177">      {</a>
<a name="ln1178">      QList&lt;Excerpt*&gt; all;</a>
<a name="ln1179">      for (Part* part : score-&gt;parts()) {</a>
<a name="ln1180">            if (part-&gt;show()) {</a>
<a name="ln1181">                  Excerpt* e = new Excerpt(score);</a>
<a name="ln1182">                  e-&gt;parts().append(part);</a>
<a name="ln1183">                  for (int i = part-&gt;startTrack(), j = 0; i &lt; part-&gt;endTrack(); i++, j++) {</a>
<a name="ln1184">                        e-&gt;tracks().insert(i, j);</a>
<a name="ln1185">                        }</a>
<a name="ln1186">                  QString name = createName(part-&gt;partName(), all);</a>
<a name="ln1187">                  e-&gt;setTitle(name);</a>
<a name="ln1188">                  all.append(e);</a>
<a name="ln1189">                  }</a>
<a name="ln1190">            }</a>
<a name="ln1191">      return all;</a>
<a name="ln1192">      }</a>
<a name="ln1193"> </a>
<a name="ln1194">//---------------------------------------------------------</a>
<a name="ln1195">//   createName</a>
<a name="ln1196">//---------------------------------------------------------</a>
<a name="ln1197"> </a>
<a name="ln1198">QString Excerpt::createName(const QString&amp; partName, QList&lt;Excerpt*&gt;&amp; excerptList)</a>
<a name="ln1199">      {</a>
<a name="ln1200">      QString name = partName.simplified();</a>
<a name="ln1201">      int count = 0;    // no of occurrences of partName</a>
<a name="ln1202"> </a>
<a name="ln1203">      for (Excerpt* e : excerptList) {</a>
<a name="ln1204">            // if &lt;partName&gt; already exists, change &lt;partName&gt; to &lt;partName 1&gt;</a>
<a name="ln1205">            if (e-&gt;title().compare(name) == 0)</a>
<a name="ln1206">                  e-&gt;setTitle(e-&gt;title() + &quot; 1&quot;);</a>
<a name="ln1207"> </a>
<a name="ln1208">            QRegExp rx(&quot;^(.+)\\s\\d+$&quot;);</a>
<a name="ln1209">            if (rx.indexIn(e-&gt;title()) &gt; -1 &amp;&amp; rx.cap(1) == name)</a>
<a name="ln1210">                  count++;</a>
<a name="ln1211">            }</a>
<a name="ln1212"> </a>
<a name="ln1213">      if (count &gt; 0)</a>
<a name="ln1214">            name += QString(&quot; %1&quot;).arg(count + 1);</a>
<a name="ln1215"> </a>
<a name="ln1216">      return name;</a>
<a name="ln1217">      }</a>
<a name="ln1218"> </a>
<a name="ln1219">//---------------------------------------------------------</a>
<a name="ln1220">//   setPartScore</a>
<a name="ln1221">//---------------------------------------------------------</a>
<a name="ln1222"> </a>
<a name="ln1223">void Excerpt::setPartScore(Score* s)</a>
<a name="ln1224">      {</a>
<a name="ln1225">      _partScore = s;</a>
<a name="ln1226">      s-&gt;setExcerpt(this);</a>
<a name="ln1227">      }</a>
<a name="ln1228"> </a>
<a name="ln1229">}</a>

</code></pre>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
