
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>qlist.h</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2016 The Qt Company Ltd.</a>
<a name="ln4">** Contact: https://www.qt.io/licensing/</a>
<a name="ln5">**</a>
<a name="ln6">** This file is part of the QtCore module of the Qt Toolkit.</a>
<a name="ln7">**</a>
<a name="ln8">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln9">** Commercial License Usage</a>
<a name="ln10">** Licensees holding valid commercial Qt licenses may use this file in</a>
<a name="ln11">** accordance with the commercial license agreement provided with the</a>
<a name="ln12">** Software or, alternatively, in accordance with the terms contained in</a>
<a name="ln13">** a written agreement between you and The Qt Company. For licensing terms</a>
<a name="ln14">** and conditions see https://www.qt.io/terms-conditions. For further</a>
<a name="ln15">** information use the contact form at https://www.qt.io/contact-us.</a>
<a name="ln16">**</a>
<a name="ln17">** GNU Lesser General Public License Usage</a>
<a name="ln18">** Alternatively, this file may be used under the terms of the GNU Lesser</a>
<a name="ln19">** General Public License version 3 as published by the Free Software</a>
<a name="ln20">** Foundation and appearing in the file LICENSE.LGPL3 included in the</a>
<a name="ln21">** packaging of this file. Please review the following information to</a>
<a name="ln22">** ensure the GNU Lesser General Public License version 3 requirements</a>
<a name="ln23">** will be met: https://www.gnu.org/licenses/lgpl-3.0.html.</a>
<a name="ln24">**</a>
<a name="ln25">** GNU General Public License Usage</a>
<a name="ln26">** Alternatively, this file may be used under the terms of the GNU</a>
<a name="ln27">** General Public License version 2.0 or (at your option) the GNU General</a>
<a name="ln28">** Public license version 3 or any later version approved by the KDE Free</a>
<a name="ln29">** Qt Foundation. The licenses are as published by the Free Software</a>
<a name="ln30">** Foundation and appearing in the file LICENSE.GPL2 and LICENSE.GPL3</a>
<a name="ln31">** included in the packaging of this file. Please review the following</a>
<a name="ln32">** information to ensure the GNU General Public License requirements will</a>
<a name="ln33">** be met: https://www.gnu.org/licenses/gpl-2.0.html and</a>
<a name="ln34">** https://www.gnu.org/licenses/gpl-3.0.html.</a>
<a name="ln35">**</a>
<a name="ln36">** $QT_END_LICENSE$</a>
<a name="ln37">**</a>
<a name="ln38">****************************************************************************/</a>
<a name="ln39"> </a>
<a name="ln40">#ifndef QLIST_H</a>
<a name="ln41">#define QLIST_H</a>
<a name="ln42"> </a>
<a name="ln43">#include &lt;QtCore/qalgorithms.h&gt;</a>
<a name="ln44">#include &lt;QtCore/qiterator.h&gt;</a>
<a name="ln45">#include &lt;QtCore/qrefcount.h&gt;</a>
<a name="ln46">#include &lt;QtCore/qarraydata.h&gt;</a>
<a name="ln47">#include &lt;QtCore/qhashfunctions.h&gt;</a>
<a name="ln48"> </a>
<a name="ln49">#include &lt;iterator&gt;</a>
<a name="ln50">#include &lt;list&gt;</a>
<a name="ln51">#include &lt;algorithm&gt;</a>
<a name="ln52">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln53">#include &lt;initializer_list&gt;</a>
<a name="ln54">#endif</a>
<a name="ln55"> </a>
<a name="ln56">#include &lt;stdlib.h&gt;</a>
<a name="ln57">#include &lt;new&gt;</a>
<a name="ln58">#include &lt;limits.h&gt;</a>
<a name="ln59">#include &lt;string.h&gt;</a>
<a name="ln60"> </a>
<a name="ln61">#ifdef Q_CC_MSVC</a>
<a name="ln62">#pragma warning( push )</a>
<a name="ln63">#pragma warning( disable : 4127 ) // &quot;conditional expression is constant&quot;</a>
<a name="ln64">#endif</a>
<a name="ln65"> </a>
<a name="ln66">QT_BEGIN_NAMESPACE</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">template &lt;typename T&gt; class QVector;</a>
<a name="ln70">template &lt;typename T&gt; class QSet;</a>
<a name="ln71"> </a>
<a name="ln72">template &lt;typename T&gt; struct QListSpecialMethods</a>
<a name="ln73">{</a>
<a name="ln74">protected:</a>
<a name="ln75">    ~QListSpecialMethods() {}</a>
<a name="ln76">};</a>
<a name="ln77">template &lt;&gt; struct QListSpecialMethods&lt;QByteArray&gt;;</a>
<a name="ln78">template &lt;&gt; struct QListSpecialMethods&lt;QString&gt;;</a>
<a name="ln79"> </a>
<a name="ln80">struct Q_CORE_EXPORT QListData {</a>
<a name="ln81">    // tags for tag-dispatching of QList implementations,</a>
<a name="ln82">    // based on QList's three different memory layouts:</a>
<a name="ln83">    struct NotArrayCompatibleLayout {};</a>
<a name="ln84">    struct NotIndirectLayout {};</a>
<a name="ln85">    struct ArrayCompatibleLayout   : NotIndirectLayout {};                           // data laid out like a C array</a>
<a name="ln86">    struct InlineWithPaddingLayout : NotArrayCompatibleLayout, NotIndirectLayout {}; // data laid out like a C array with padding</a>
<a name="ln87">    struct IndirectLayout          : NotArrayCompatibleLayout {};                    // data allocated on the heap</a>
<a name="ln88"> </a>
<a name="ln89">    struct Data {</a>
<a name="ln90">        QtPrivate::RefCount ref;</a>
<a name="ln91">        int alloc, begin, end;</a>
<a name="ln92">        void *array[1];</a>
<a name="ln93">    };</a>
<a name="ln94">    enum { DataHeaderSize = sizeof(Data) - sizeof(void *) };</a>
<a name="ln95"> </a>
<a name="ln96">    Data *detach(int alloc);</a>
<a name="ln97">    Data *detach_grow(int *i, int n);</a>
<a name="ln98">    void realloc(int alloc);</a>
<a name="ln99">    void realloc_grow(int growth);</a>
<a name="ln100">    inline void dispose() { dispose(d); }</a>
<a name="ln101">    static void dispose(Data *d);</a>
<a name="ln102">    static const Data shared_null;</a>
<a name="ln103">    Data *d;</a>
<a name="ln104">    void **erase(void **xi);</a>
<a name="ln105">    void **append(int n);</a>
<a name="ln106">    void **append();</a>
<a name="ln107">    void **append(const QListData &amp;l);</a>
<a name="ln108">    void **prepend();</a>
<a name="ln109">    void **insert(int i);</a>
<a name="ln110">    void remove(int i);</a>
<a name="ln111">    void remove(int i, int n);</a>
<a name="ln112">    void move(int from, int to);</a>
<a name="ln113">    inline int size() const Q_DECL_NOTHROW { return d-&gt;end - d-&gt;begin; }</a>
<a name="ln114">    inline bool isEmpty() const Q_DECL_NOTHROW { return d-&gt;end  == d-&gt;begin; }</a>
<a name="ln115">    inline void **at(int i) const Q_DECL_NOTHROW { return d-&gt;array + d-&gt;begin + i; }</a>
<a name="ln116">    inline void **begin() const Q_DECL_NOTHROW { return d-&gt;array + d-&gt;begin; }</a>
<a name="ln117">    inline void **end() const Q_DECL_NOTHROW { return d-&gt;array + d-&gt;end; }</a>
<a name="ln118">};</a>
<a name="ln119"> </a>
<a name="ln120">template &lt;typename T&gt;</a>
<a name="ln121">class QList</a>
<a name="ln122">#ifndef Q_QDOC</a>
<a name="ln123">    : public QListSpecialMethods&lt;T&gt;</a>
<a name="ln124">#endif</a>
<a name="ln125">{</a>
<a name="ln126">public:</a>
<a name="ln127">    struct MemoryLayout</a>
<a name="ln128">        : std::conditional&lt;</a>
<a name="ln129">            // must stay isStatic until ### Qt 6 for BC reasons (don't use !isRelocatable)!</a>
<a name="ln130">            QTypeInfo&lt;T&gt;::isStatic || QTypeInfo&lt;T&gt;::isLarge,</a>
<a name="ln131">            QListData::IndirectLayout,</a>
<a name="ln132">            typename std::conditional&lt;</a>
<a name="ln133">                sizeof(T) == sizeof(void*),</a>
<a name="ln134">                QListData::ArrayCompatibleLayout,</a>
<a name="ln135">                QListData::InlineWithPaddingLayout</a>
<a name="ln136">             &gt;::type&gt;::type {};</a>
<a name="ln137">private:</a>
<a name="ln138">    struct Node { void *v;</a>
<a name="ln139">#if defined(Q_CC_BOR)</a>
<a name="ln140">        Q_INLINE_TEMPLATE T &amp;t();</a>
<a name="ln141">#else</a>
<a name="ln142">        Q_INLINE_TEMPLATE T &amp;t()</a>
<a name="ln143">        { return *reinterpret_cast&lt;T*&gt;(QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic</a>
<a name="ln144">                                       ? v : this); }</a>
<a name="ln145">#endif</a>
<a name="ln146">    };</a>
<a name="ln147"> </a>
<a name="ln148">    union { QListData p; QListData::Data *d; };</a>
<a name="ln149"> </a>
<a name="ln150">public:</a>
<a name="ln151">    inline QList() Q_DECL_NOTHROW : d(const_cast&lt;QListData::Data *&gt;(&amp;QListData::shared_null)) { }</a>
<a name="ln152">    QList(const QList&lt;T&gt; &amp;l);</a>
<a name="ln153">    ~QList();</a>
<a name="ln154">    QList&lt;T&gt; &amp;operator=(const QList&lt;T&gt; &amp;l);</a>
<a name="ln155">#ifdef Q_COMPILER_RVALUE_REFS</a>
<a name="ln156">    inline QList(QList&lt;T&gt; &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln157">        : d(other.d) { other.d = const_cast&lt;QListData::Data *&gt;(&amp;QListData::shared_null); }</a>
<a name="ln158">    inline QList &amp;operator=(QList&lt;T&gt; &amp;&amp;other) Q_DECL_NOTHROW</a>
<a name="ln159">    { QList moved(std::move(other)); swap(moved); return *this; }</a>
<a name="ln160">#endif</a>
<a name="ln161">    inline void swap(QList&lt;T&gt; &amp;other) Q_DECL_NOTHROW { qSwap(d, other.d); }</a>
<a name="ln162">#ifdef Q_COMPILER_INITIALIZER_LISTS</a>
<a name="ln163">    inline QList(std::initializer_list&lt;T&gt; args)</a>
<a name="ln164">        : d(const_cast&lt;QListData::Data *&gt;(&amp;QListData::shared_null))</a>
<a name="ln165">    { reserve(int(args.size())); std::copy(args.begin(), args.end(), std::back_inserter(*this)); }</a>
<a name="ln166">#endif</a>
<a name="ln167">    bool operator==(const QList&lt;T&gt; &amp;l) const;</a>
<a name="ln168">    inline bool operator!=(const QList&lt;T&gt; &amp;l) const { return !(*this == l); }</a>
<a name="ln169"> </a>
<a name="ln170">    inline int size() const Q_DECL_NOTHROW { return p.size(); }</a>
<a name="ln171"> </a>
<a name="ln172">    inline void detach() { if (d-&gt;ref.isShared()) detach_helper(); }</a>
<a name="ln173"> </a>
<a name="ln174">    inline void detachShared()</a>
<a name="ln175">    {</a>
<a name="ln176">        // The &quot;this-&gt;&quot; qualification is needed for GCCE.</a>
<a name="ln177">        if (d-&gt;ref.isShared() &amp;&amp; this-&gt;d != &amp;QListData::shared_null)</a>
<a name="ln178">            detach_helper();</a>
<a name="ln179">    }</a>
<a name="ln180"> </a>
<a name="ln181">    inline bool isDetached() const { return !d-&gt;ref.isShared(); }</a>
<a name="ln182">#if !defined(QT_NO_UNSHARABLE_CONTAINERS)</a>
<a name="ln183">    inline void setSharable(bool sharable)</a>
<a name="ln184">    {</a>
<a name="ln185">        if (sharable == d-&gt;ref.isSharable())</a>
<a name="ln186">            return;</a>
<a name="ln187">        if (!sharable)</a>
<a name="ln188">            detach();</a>
<a name="ln189">        if (d != &amp;QListData::shared_null)</a>
<a name="ln190">            d-&gt;ref.setSharable(sharable);</a>
<a name="ln191">    }</a>
<a name="ln192">#endif</a>
<a name="ln193">    inline bool isSharedWith(const QList&lt;T&gt; &amp;other) const Q_DECL_NOTHROW { return d == other.d; }</a>
<a name="ln194"> </a>
<a name="ln195">    inline bool isEmpty() const Q_DECL_NOTHROW { return p.isEmpty(); }</a>
<a name="ln196"> </a>
<a name="ln197">    void clear();</a>
<a name="ln198"> </a>
<a name="ln199">    const T &amp;at(int i) const;</a>
<a name="ln200">    const T &amp;operator[](int i) const;</a>
<a name="ln201">    T &amp;operator[](int i);</a>
<a name="ln202"> </a>
<a name="ln203">    void reserve(int size);</a>
<a name="ln204">    void append(const T &amp;t);</a>
<a name="ln205">    void append(const QList&lt;T&gt; &amp;t);</a>
<a name="ln206">    void prepend(const T &amp;t);</a>
<a name="ln207">    void insert(int i, const T &amp;t);</a>
<a name="ln208">    void replace(int i, const T &amp;t);</a>
<a name="ln209">    void removeAt(int i);</a>
<a name="ln210">    int removeAll(const T &amp;t);</a>
<a name="ln211">    bool removeOne(const T &amp;t);</a>
<a name="ln212">    T takeAt(int i);</a>
<a name="ln213">    T takeFirst();</a>
<a name="ln214">    T takeLast();</a>
<a name="ln215">    void move(int from, int to);</a>
<a name="ln216">    void swap(int i, int j);</a>
<a name="ln217">    int indexOf(const T &amp;t, int from = 0) const;</a>
<a name="ln218">    int lastIndexOf(const T &amp;t, int from = -1) const;</a>
<a name="ln219">    bool contains(const T &amp;t) const;</a>
<a name="ln220">    int count(const T &amp;t) const;</a>
<a name="ln221"> </a>
<a name="ln222">    class const_iterator;</a>
<a name="ln223"> </a>
<a name="ln224">    class iterator {</a>
<a name="ln225">    public:</a>
<a name="ln226">        Node *i;</a>
<a name="ln227">        typedef std::random_access_iterator_tag  iterator_category;</a>
<a name="ln228">        // ### Qt6: use int</a>
<a name="ln229">        typedef qptrdiff difference_type;</a>
<a name="ln230">        typedef T value_type;</a>
<a name="ln231">        typedef T *pointer;</a>
<a name="ln232">        typedef T &amp;reference;</a>
<a name="ln233"> </a>
<a name="ln234">        inline iterator() Q_DECL_NOTHROW : i(nullptr) {}</a>
<a name="ln235">        inline iterator(Node *n) Q_DECL_NOTHROW : i(n) {}</a>
<a name="ln236">#if QT_VERSION &lt; QT_VERSION_CHECK(6,0,0)</a>
<a name="ln237">        // can't remove it in Qt 5, since doing so would make the type trivial,</a>
<a name="ln238">        // which changes the way it's passed to functions by value.</a>
<a name="ln239">        inline iterator(const iterator &amp;o) Q_DECL_NOTHROW : i(o.i){}</a>
<a name="ln240">#endif</a>
<a name="ln241">        inline T &amp;operator*() const { return i-&gt;t(); }</a>
<a name="ln242">        inline T *operator-&gt;() const { return &amp;i-&gt;t(); }</a>
<a name="ln243">        inline T &amp;operator[](difference_type j) const { return i[j].t(); }</a>
<a name="ln244">        inline bool operator==(const iterator &amp;o) const Q_DECL_NOTHROW { return i == o.i; }</a>
<a name="ln245">        inline bool operator!=(const iterator &amp;o) const Q_DECL_NOTHROW { return i != o.i; }</a>
<a name="ln246">        inline bool operator&lt;(const iterator&amp; other) const Q_DECL_NOTHROW { return i &lt; other.i; }</a>
<a name="ln247">        inline bool operator&lt;=(const iterator&amp; other) const Q_DECL_NOTHROW { return i &lt;= other.i; }</a>
<a name="ln248">        inline bool operator&gt;(const iterator&amp; other) const Q_DECL_NOTHROW { return i &gt; other.i; }</a>
<a name="ln249">        inline bool operator&gt;=(const iterator&amp; other) const Q_DECL_NOTHROW { return i &gt;= other.i; }</a>
<a name="ln250">#ifndef QT_STRICT_ITERATORS</a>
<a name="ln251">        inline bool operator==(const const_iterator &amp;o) const Q_DECL_NOTHROW</a>
<a name="ln252">            { return i == o.i; }</a>
<a name="ln253">        inline bool operator!=(const const_iterator &amp;o) const Q_DECL_NOTHROW</a>
<a name="ln254">            { return i != o.i; }</a>
<a name="ln255">        inline bool operator&lt;(const const_iterator&amp; other) const Q_DECL_NOTHROW</a>
<a name="ln256">            { return i &lt; other.i; }</a>
<a name="ln257">        inline bool operator&lt;=(const const_iterator&amp; other) const Q_DECL_NOTHROW</a>
<a name="ln258">            { return i &lt;= other.i; }</a>
<a name="ln259">        inline bool operator&gt;(const const_iterator&amp; other) const Q_DECL_NOTHROW</a>
<a name="ln260">            { return i &gt; other.i; }</a>
<a name="ln261">        inline bool operator&gt;=(const const_iterator&amp; other) const Q_DECL_NOTHROW</a>
<a name="ln262">            { return i &gt;= other.i; }</a>
<a name="ln263">#endif</a>
<a name="ln264">        inline iterator &amp;operator++() { ++i; return *this; }</a>
<a name="ln265">        inline iterator operator++(int) { Node *n = i; ++i; return n; }</a>
<a name="ln266">        inline iterator &amp;operator--() { i--; return *this; }</a>
<a name="ln267">        inline iterator operator--(int) { Node *n = i; i--; return n; }</a>
<a name="ln268">        inline iterator &amp;operator+=(difference_type j) { i+=j; return *this; }</a>
<a name="ln269">        inline iterator &amp;operator-=(difference_type j) { i-=j; return *this; }</a>
<a name="ln270">        inline iterator operator+(difference_type j) const { return iterator(i+j); }</a>
<a name="ln271">        inline iterator operator-(difference_type j) const { return iterator(i-j); }</a>
<a name="ln272">        friend inline iterator operator+(difference_type j, iterator k) { return k + j; }</a>
<a name="ln273">        inline int operator-(iterator j) const { return int(i - j.i); }</a>
<a name="ln274">    };</a>
<a name="ln275">    friend class iterator;</a>
<a name="ln276"> </a>
<a name="ln277">    class const_iterator {</a>
<a name="ln278">    public:</a>
<a name="ln279">        Node *i;</a>
<a name="ln280">        typedef std::random_access_iterator_tag  iterator_category;</a>
<a name="ln281">        // ### Qt6: use int</a>
<a name="ln282">        typedef qptrdiff difference_type;</a>
<a name="ln283">        typedef T value_type;</a>
<a name="ln284">        typedef const T *pointer;</a>
<a name="ln285">        typedef const T &amp;reference;</a>
<a name="ln286"> </a>
<a name="ln287">        inline const_iterator() Q_DECL_NOTHROW : i(nullptr) {}</a>
<a name="ln288">        inline const_iterator(Node *n) Q_DECL_NOTHROW : i(n) {}</a>
<a name="ln289">#if QT_VERSION &lt; QT_VERSION_CHECK(6,0,0)</a>
<a name="ln290">        // can't remove it in Qt 5, since doing so would make the type trivial,</a>
<a name="ln291">        // which changes the way it's passed to functions by value.</a>
<a name="ln292">        inline const_iterator(const const_iterator &amp;o) Q_DECL_NOTHROW : i(o.i) {}</a>
<a name="ln293">#endif</a>
<a name="ln294">#ifdef QT_STRICT_ITERATORS</a>
<a name="ln295">        inline explicit const_iterator(const iterator &amp;o) Q_DECL_NOTHROW : i(o.i) {}</a>
<a name="ln296">#else</a>
<a name="ln297">        inline const_iterator(const iterator &amp;o) Q_DECL_NOTHROW : i(o.i) {}</a>
<a name="ln298">#endif</a>
<a name="ln299">        inline const T &amp;operator*() const { return i-&gt;t(); }</a>
<a name="ln300">        inline const T *operator-&gt;() const { return &amp;i-&gt;t(); }</a>
<a name="ln301">        inline const T &amp;operator[](difference_type j) const { return i[j].t(); }</a>
<a name="ln302">        inline bool operator==(const const_iterator &amp;o) const Q_DECL_NOTHROW { return i == o.i; }</a>
<a name="ln303">        inline bool operator!=(const const_iterator &amp;o) const Q_DECL_NOTHROW { return i != o.i; }</a>
<a name="ln304">        inline bool operator&lt;(const const_iterator&amp; other) const Q_DECL_NOTHROW { return i &lt; other.i; }</a>
<a name="ln305">        inline bool operator&lt;=(const const_iterator&amp; other) const Q_DECL_NOTHROW { return i &lt;= other.i; }</a>
<a name="ln306">        inline bool operator&gt;(const const_iterator&amp; other) const Q_DECL_NOTHROW { return i &gt; other.i; }</a>
<a name="ln307">        inline bool operator&gt;=(const const_iterator&amp; other) const Q_DECL_NOTHROW { return i &gt;= other.i; }</a>
<a name="ln308">        inline const_iterator &amp;operator++() { ++i; return *this; }</a>
<a name="ln309">        inline const_iterator operator++(int) { Node *n = i; ++i; return n; }</a>
<a name="ln310">        inline const_iterator &amp;operator--() { i--; return *this; }</a>
<a name="ln311">        inline const_iterator operator--(int) { Node *n = i; i--; return n; }</a>
<a name="ln312">        inline const_iterator &amp;operator+=(difference_type j) { i+=j; return *this; }</a>
<a name="ln313">        inline const_iterator &amp;operator-=(difference_type j) { i-=j; return *this; }</a>
<a name="ln314">        inline const_iterator operator+(difference_type j) const { return const_iterator(i+j); }</a>
<a name="ln315">        inline const_iterator operator-(difference_type j) const { return const_iterator(i-j); }</a>
<a name="ln316">        friend inline const_iterator operator+(difference_type j, const_iterator k) { return k + j; }</a>
<a name="ln317">        inline int operator-(const_iterator j) const { return int(i - j.i); }</a>
<a name="ln318">    };</a>
<a name="ln319">    friend class const_iterator;</a>
<a name="ln320"> </a>
<a name="ln321">    // stl style</a>
<a name="ln322">    typedef std::reverse_iterator&lt;iterator&gt; reverse_iterator;</a>
<a name="ln323">    typedef std::reverse_iterator&lt;const_iterator&gt; const_reverse_iterator;</a>
<a name="ln324">    inline iterator begin() { detach(); return reinterpret_cast&lt;Node *&gt;(p.begin()); }</a>
<a name="ln325">    inline const_iterator begin() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.begin()); }</a>
<a name="ln326">    inline const_iterator cbegin() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.begin()); }</a>
<a name="ln327">    inline const_iterator constBegin() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.begin()); }</a>
<a name="ln328">    inline iterator end() { detach(); return reinterpret_cast&lt;Node *&gt;(p.end()); }</a>
<a name="ln329">    inline const_iterator end() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.end()); }</a>
<a name="ln330">    inline const_iterator cend() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.end()); }</a>
<a name="ln331">    inline const_iterator constEnd() const Q_DECL_NOTHROW { return reinterpret_cast&lt;Node *&gt;(p.end()); }</a>
<a name="ln332">    reverse_iterator rbegin() { return reverse_iterator(end()); }</a>
<a name="ln333">    reverse_iterator rend() { return reverse_iterator(begin()); }</a>
<a name="ln334">    const_reverse_iterator rbegin() const Q_DECL_NOTHROW { return const_reverse_iterator(end()); }</a>
<a name="ln335">    const_reverse_iterator rend() const Q_DECL_NOTHROW { return const_reverse_iterator(begin()); }</a>
<a name="ln336">    const_reverse_iterator crbegin() const Q_DECL_NOTHROW { return const_reverse_iterator(end()); }</a>
<a name="ln337">    const_reverse_iterator crend() const Q_DECL_NOTHROW { return const_reverse_iterator(begin()); }</a>
<a name="ln338">    iterator insert(iterator before, const T &amp;t);</a>
<a name="ln339">    iterator erase(iterator pos);</a>
<a name="ln340">    iterator erase(iterator first, iterator last);</a>
<a name="ln341"> </a>
<a name="ln342">    // more Qt</a>
<a name="ln343">    typedef iterator Iterator;</a>
<a name="ln344">    typedef const_iterator ConstIterator;</a>
<a name="ln345">    inline int count() const { return p.size(); }</a>
<a name="ln346">    inline int length() const { return p.size(); } // Same as count()</a>
<a name="ln347">    inline T&amp; first() { Q_ASSERT(!isEmpty()); return *begin(); }</a>
<a name="ln348">    inline const T&amp; constFirst() const { return first(); }</a>
<a name="ln349">    inline const T&amp; first() const { Q_ASSERT(!isEmpty()); return at(0); }</a>
<a name="ln350">    T&amp; last() { Q_ASSERT(!isEmpty()); return *(--end()); }</a>
<a name="ln351">    const T&amp; last() const { Q_ASSERT(!isEmpty()); return at(count() - 1); }</a>
<a name="ln352">    inline const T&amp; constLast() const { return last(); }</a>
<a name="ln353">    inline void removeFirst() { Q_ASSERT(!isEmpty()); erase(begin()); }</a>
<a name="ln354">    inline void removeLast() { Q_ASSERT(!isEmpty()); erase(--end()); }</a>
<a name="ln355">    inline bool startsWith(const T &amp;t) const { return !isEmpty() &amp;&amp; first() == t; }</a>
<a name="ln356">    inline bool endsWith(const T &amp;t) const { return !isEmpty() &amp;&amp; last() == t; }</a>
<a name="ln357">    QList&lt;T&gt; mid(int pos, int length = -1) const;</a>
<a name="ln358"> </a>
<a name="ln359">    T value(int i) const;</a>
<a name="ln360">    T value(int i, const T &amp;defaultValue) const;</a>
<a name="ln361"> </a>
<a name="ln362">    // stl compatibility</a>
<a name="ln363">    inline void push_back(const T &amp;t) { append(t); }</a>
<a name="ln364">    inline void push_front(const T &amp;t) { prepend(t); }</a>
<a name="ln365">    inline T&amp; front() { return first(); }</a>
<a name="ln366">    inline const T&amp; front() const { return first(); }</a>
<a name="ln367">    inline T&amp; back() { return last(); }</a>
<a name="ln368">    inline const T&amp; back() const { return last(); }</a>
<a name="ln369">    inline void pop_front() { removeFirst(); }</a>
<a name="ln370">    inline void pop_back() { removeLast(); }</a>
<a name="ln371">    inline bool empty() const { return isEmpty(); }</a>
<a name="ln372">    typedef int size_type;</a>
<a name="ln373">    typedef T value_type;</a>
<a name="ln374">    typedef value_type *pointer;</a>
<a name="ln375">    typedef const value_type *const_pointer;</a>
<a name="ln376">    typedef value_type &amp;reference;</a>
<a name="ln377">    typedef const value_type &amp;const_reference;</a>
<a name="ln378">    // ### Qt6: use int</a>
<a name="ln379">    typedef qptrdiff difference_type;</a>
<a name="ln380"> </a>
<a name="ln381">    // comfort</a>
<a name="ln382">    QList&lt;T&gt; &amp;operator+=(const QList&lt;T&gt; &amp;l);</a>
<a name="ln383">    inline QList&lt;T&gt; operator+(const QList&lt;T&gt; &amp;l) const</a>
<a name="ln384">    { QList n = *this; n += l; return n; }</a>
<a name="ln385">    inline QList&lt;T&gt; &amp;operator+=(const T &amp;t)</a>
<a name="ln386">    { append(t); return *this; }</a>
<a name="ln387">    inline QList&lt;T&gt; &amp;operator&lt;&lt; (const T &amp;t)</a>
<a name="ln388">    { append(t); return *this; }</a>
<a name="ln389">    inline QList&lt;T&gt; &amp;operator&lt;&lt;(const QList&lt;T&gt; &amp;l)</a>
<a name="ln390">    { *this += l; return *this; }</a>
<a name="ln391"> </a>
<a name="ln392">    QVector&lt;T&gt; toVector() const;</a>
<a name="ln393">    QSet&lt;T&gt; toSet() const;</a>
<a name="ln394"> </a>
<a name="ln395">    static QList&lt;T&gt; fromVector(const QVector&lt;T&gt; &amp;vector);</a>
<a name="ln396">    static QList&lt;T&gt; fromSet(const QSet&lt;T&gt; &amp;set);</a>
<a name="ln397"> </a>
<a name="ln398">    static inline QList&lt;T&gt; fromStdList(const std::list&lt;T&gt; &amp;list)</a>
<a name="ln399">    { QList&lt;T&gt; tmp; std::copy(list.begin(), list.end(), std::back_inserter(tmp)); return tmp; }</a>
<a name="ln400">    inline std::list&lt;T&gt; toStdList() const</a>
<a name="ln401">    { std::list&lt;T&gt; tmp; std::copy(constBegin(), constEnd(), std::back_inserter(tmp)); return tmp; }</a>
<a name="ln402"> </a>
<a name="ln403">private:</a>
<a name="ln404">    Node *detach_helper_grow(int i, int n);</a>
<a name="ln405">    void detach_helper(int alloc);</a>
<a name="ln406">    void detach_helper();</a>
<a name="ln407">    void dealloc(QListData::Data *d);</a>
<a name="ln408"> </a>
<a name="ln409">    void node_construct(Node *n, const T &amp;t);</a>
<a name="ln410">    void node_destruct(Node *n);</a>
<a name="ln411">    void node_copy(Node *from, Node *to, Node *src);</a>
<a name="ln412">    void node_destruct(Node *from, Node *to);</a>
<a name="ln413"> </a>
<a name="ln414">    bool isValidIterator(const iterator &amp;i) const Q_DECL_NOTHROW</a>
<a name="ln415">    {</a>
<a name="ln416">        const std::less&lt;const Node *&gt; less = {};</a>
<a name="ln417">        return !less(i.i, cbegin().i) &amp;&amp; !less(cend().i, i.i);</a>
<a name="ln418">    }</a>
<a name="ln419"> </a>
<a name="ln420">private:</a>
<a name="ln421">    inline bool op_eq_impl(const QList &amp;other, QListData::NotArrayCompatibleLayout) const;</a>
<a name="ln422">    inline bool op_eq_impl(const QList &amp;other, QListData::ArrayCompatibleLayout) const;</a>
<a name="ln423">    inline bool contains_impl(const T &amp;, QListData::NotArrayCompatibleLayout) const;</a>
<a name="ln424">    inline bool contains_impl(const T &amp;, QListData::ArrayCompatibleLayout) const;</a>
<a name="ln425">    inline int count_impl(const T &amp;, QListData::NotArrayCompatibleLayout) const;</a>
<a name="ln426">    inline int count_impl(const T &amp;, QListData::ArrayCompatibleLayout) const;</a>
<a name="ln427">};</a>
<a name="ln428"> </a>
<a name="ln429">#if defined(Q_CC_BOR)</a>
<a name="ln430">template &lt;typename T&gt;</a>
<a name="ln431">Q_INLINE_TEMPLATE T &amp;QList&lt;T&gt;::Node::t()</a>
<a name="ln432">{ return QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic ? *(T*)v:*(T*)this; }</a>
<a name="ln433">#endif</a>
<a name="ln434"> </a>
<a name="ln435">template &lt;typename T&gt;</a>
<a name="ln436">Q_INLINE_TEMPLATE void QList&lt;T&gt;::node_construct(Node *n, const T &amp;t)</a>
<a name="ln437">{</a>
<a name="ln438">    if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) n-&gt;v = new T(t);</a>
<a name="ln439">    else if (QTypeInfo&lt;T&gt;::isComplex) new (n) T(t);</a>
<a name="ln440">#if (defined(__GNUC__) || defined(__INTEL_COMPILER) || defined(__IBMCPP__)) &amp;&amp; !defined(__OPTIMIZE__)</a>
<a name="ln441">    // This violates pointer aliasing rules, but it is known to be safe (and silent)</a>
<a name="ln442">    // in unoptimized GCC builds (-fno-strict-aliasing). The other compilers which</a>
<a name="ln443">    // set the same define are assumed to be safe.</a>
<a name="ln444">    else *reinterpret_cast&lt;T*&gt;(n) = t;</a>
<a name="ln445">#else</a>
<a name="ln446">    // This is always safe, but penaltizes unoptimized builds a lot.</a>
<a name="ln447">    else ::memcpy(n, static_cast&lt;const void *&gt;(&amp;t), sizeof(T));</a>
<a name="ln448">#endif</a>
<a name="ln449">}</a>
<a name="ln450"> </a>
<a name="ln451">template &lt;typename T&gt;</a>
<a name="ln452">Q_INLINE_TEMPLATE void QList&lt;T&gt;::node_destruct(Node *n)</a>
<a name="ln453">{</a>
<a name="ln454">    if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) delete reinterpret_cast&lt;T*&gt;(n-&gt;v);</a>
<a name="ln455">    else if (QTypeInfo&lt;T&gt;::isComplex) reinterpret_cast&lt;T*&gt;(n)-&gt;~T();</a>
<a name="ln456">}</a>
<a name="ln457"> </a>
<a name="ln458">template &lt;typename T&gt;</a>
<a name="ln459">Q_INLINE_TEMPLATE void QList&lt;T&gt;::node_copy(Node *from, Node *to, Node *src)</a>
<a name="ln460">{</a>
<a name="ln461">    Node *current = from;</a>
<a name="ln462">    if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) {</a>
<a name="ln463">        QT_TRY {</a>
<a name="ln464">            while(current != to) {</a>
<a name="ln465">                current-&gt;v = new T(*reinterpret_cast&lt;T*&gt;(src-&gt;v));</a>
<a name="ln466">                ++current;</a>
<a name="ln467">                ++src;</a>
<a name="ln468">            }</a>
<a name="ln469">        } QT_CATCH(...) {</a>
<a name="ln470">            while (current-- != from)</a>
<a name="ln471">                delete reinterpret_cast&lt;T*&gt;(current-&gt;v);</a>
<a name="ln472">            QT_RETHROW;</a>
<a name="ln473">        }</a>
<a name="ln474"> </a>
<a name="ln475">    } else if (QTypeInfo&lt;T&gt;::isComplex) {</a>
<a name="ln476">        QT_TRY {</a>
<a name="ln477">            while(current != to) {</a>
<a name="ln478">                new (current) T(*reinterpret_cast&lt;T*&gt;(src));</a>
<a name="ln479">                ++current;</a>
<a name="ln480">                ++src;</a>
<a name="ln481">            }</a>
<a name="ln482">        } QT_CATCH(...) {</a>
<a name="ln483">            while (current-- != from)</a>
<a name="ln484">                (reinterpret_cast&lt;T*&gt;(current))-&gt;~T();</a>
<a name="ln485">            QT_RETHROW;</a>
<a name="ln486">        }</a>
<a name="ln487">    } else {</a>
<a name="ln488">        if (src != from &amp;&amp; to - from &gt; 0)</a>
<a name="ln489">            memcpy(from, src, (to - from) * sizeof(Node));</a>
<a name="ln490">    }</a>
<a name="ln491">}</a>
<a name="ln492"> </a>
<a name="ln493">template &lt;typename T&gt;</a>
<a name="ln494">Q_INLINE_TEMPLATE void QList&lt;T&gt;::node_destruct(Node *from, Node *to)</a>
<a name="ln495">{</a>
<a name="ln496">    if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic)</a>
<a name="ln497">        while(from != to) --to, delete reinterpret_cast&lt;T*&gt;(to-&gt;v);</a>
<a name="ln498">    else if (QTypeInfo&lt;T&gt;::isComplex)</a>
<a name="ln499">        while (from != to) --to, reinterpret_cast&lt;T*&gt;(to)-&gt;~T();</a>
<a name="ln500">}</a>
<a name="ln501"> </a>
<a name="ln502">template &lt;typename T&gt;</a>
<a name="ln503">Q_INLINE_TEMPLATE QList&lt;T&gt; &amp;QList&lt;T&gt;::operator=(const QList&lt;T&gt; &amp;l)</a>
<a name="ln504">{</a>
<a name="ln505">    if (d != l.d) {</a>
<a name="ln506">        QList&lt;T&gt; tmp(l);</a>
<a name="ln507">        tmp.swap(*this);</a>
<a name="ln508">    }</a>
<a name="ln509">    return *this;</a>
<a name="ln510">}</a>
<a name="ln511">template &lt;typename T&gt;</a>
<a name="ln512">inline typename QList&lt;T&gt;::iterator QList&lt;T&gt;::insert(iterator before, const T &amp;t)</a>
<a name="ln513">{</a>
<a name="ln514">    Q_ASSERT_X(isValidIterator(before), &quot;QList::insert&quot;, &quot;The specified iterator argument 'before' is invalid&quot;);</a>
<a name="ln515"> </a>
<a name="ln516">    int iBefore = int(before.i - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln517">    Node *n = 0;</a>
<a name="ln518">    if (d-&gt;ref.isShared())</a>
<a name="ln519">        n = detach_helper_grow(iBefore, 1);</a>
<a name="ln520">    else</a>
<a name="ln521">        n = reinterpret_cast&lt;Node *&gt;(p.insert(iBefore));</a>
<a name="ln522">    QT_TRY {</a>
<a name="ln523">        node_construct(n, t);</a>
<a name="ln524">    } QT_CATCH(...) {</a>
<a name="ln525">        p.remove(iBefore);</a>
<a name="ln526">        QT_RETHROW;</a>
<a name="ln527">    }</a>
<a name="ln528">    return n;</a>
<a name="ln529">}</a>
<a name="ln530">template &lt;typename T&gt;</a>
<a name="ln531">inline typename QList&lt;T&gt;::iterator QList&lt;T&gt;::erase(iterator it)</a>
<a name="ln532">{</a>
<a name="ln533">    Q_ASSERT_X(isValidIterator(it), &quot;QList::erase&quot;, &quot;The specified iterator argument 'it' is invalid&quot;);</a>
<a name="ln534">    if (d-&gt;ref.isShared()) {</a>
<a name="ln535">        int offset = int(it.i - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln536">        it = begin(); // implies detach()</a>
<a name="ln537">        it += offset;</a>
<a name="ln538">    }</a>
<a name="ln539">    node_destruct(it.i);</a>
<a name="ln540">    return reinterpret_cast&lt;Node *&gt;(p.erase(reinterpret_cast&lt;void**&gt;(it.i)));</a>
<a name="ln541">}</a>
<a name="ln542">template &lt;typename T&gt;</a>
<a name="ln543">inline const T &amp;QList&lt;T&gt;::at(int i) const</a>
<a name="ln544">{ Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::at&quot;, &quot;index out of range&quot;);</a>
<a name="ln545"> return reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t(); }</a>
<a name="ln546">template &lt;typename T&gt;</a>
<a name="ln547">inline const T &amp;QList&lt;T&gt;::operator[](int i) const</a>
<a name="ln548">{ Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::operator[]&quot;, &quot;index out of range&quot;);</a>
<a name="ln549"> return reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t(); }</a>
<a name="ln550">template &lt;typename T&gt;</a>
<a name="ln551">inline T &amp;QList&lt;T&gt;::operator[](int i)</a>
<a name="ln552">{ Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::operator[]&quot;, &quot;index out of range&quot;);</a>
<a name="ln553">  detach(); return reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t(); }</a>
<a name="ln554">template &lt;typename T&gt;</a>
<a name="ln555">inline void QList&lt;T&gt;::removeAt(int i)</a>
<a name="ln556">{ if(i &gt;= 0 &amp;&amp; i &lt; p.size()) { detach();</a>
<a name="ln557"> node_destruct(reinterpret_cast&lt;Node *&gt;(p.at(i))); p.remove(i); } }</a>
<a name="ln558">template &lt;typename T&gt;</a>
<a name="ln559">inline T QList&lt;T&gt;::takeAt(int i)</a>
<a name="ln560">{ Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::take&quot;, &quot;index out of range&quot;);</a>
<a name="ln561"> detach(); Node *n = reinterpret_cast&lt;Node *&gt;(p.at(i)); T t = std::move(n-&gt;t()); node_destruct(n);</a>
<a name="ln562"> p.remove(i); return t; }</a>
<a name="ln563">template &lt;typename T&gt;</a>
<a name="ln564">inline T QList&lt;T&gt;::takeFirst()</a>
<a name="ln565">{ T t = std::move(first()); removeFirst(); return t; }</a>
<a name="ln566">template &lt;typename T&gt;</a>
<a name="ln567">inline T QList&lt;T&gt;::takeLast()</a>
<a name="ln568">{ T t = std::move(last()); removeLast(); return t; }</a>
<a name="ln569"> </a>
<a name="ln570">template &lt;typename T&gt;</a>
<a name="ln571">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::reserve(int alloc)</a>
<a name="ln572">{</a>
<a name="ln573">    if (d-&gt;alloc &lt; alloc) {</a>
<a name="ln574">        if (d-&gt;ref.isShared())</a>
<a name="ln575">            detach_helper(alloc);</a>
<a name="ln576">        else</a>
<a name="ln577">            p.realloc(alloc);</a>
<a name="ln578">    }</a>
<a name="ln579">}</a>
<a name="ln580"> </a>
<a name="ln581">template &lt;typename T&gt;</a>
<a name="ln582">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::append(const T &amp;t)</a>
<a name="ln583">{</a>
<a name="ln584">    if (d-&gt;ref.isShared()) {</a>
<a name="ln585">        Node *n = detach_helper_grow(INT_MAX, 1);</a>
<a name="ln586">        QT_TRY {</a>
<a name="ln587">            node_construct(n, t);</a>
<a name="ln588">        } QT_CATCH(...) {</a>
<a name="ln589">            --d-&gt;end;</a>
<a name="ln590">            QT_RETHROW;</a>
<a name="ln591">        }</a>
<a name="ln592">    } else {</a>
<a name="ln593">        if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) {</a>
<a name="ln594">            Node *n = reinterpret_cast&lt;Node *&gt;(p.append());</a>
<a name="ln595">            QT_TRY {</a>
<a name="ln596">                node_construct(n, t);</a>
<a name="ln597">            } QT_CATCH(...) {</a>
<a name="ln598">                --d-&gt;end;</a>
<a name="ln599">                QT_RETHROW;</a>
<a name="ln600">            }</a>
<a name="ln601">        } else {</a>
<a name="ln602">            Node *n, copy;</a>
<a name="ln603">            node_construct(&amp;copy, t); // t might be a reference to an object in the array</a>
<a name="ln604">            QT_TRY {</a>
<a name="ln605">                n = reinterpret_cast&lt;Node *&gt;(p.append());;</a>
<a name="ln606">            } QT_CATCH(...) {</a>
<a name="ln607">                node_destruct(&amp;copy);</a>
<a name="ln608">                QT_RETHROW;</a>
<a name="ln609">            }</a>
<a name="ln610">            *n = copy;</a>
<a name="ln611">        }</a>
<a name="ln612">    }</a>
<a name="ln613">}</a>
<a name="ln614"> </a>
<a name="ln615">template &lt;typename T&gt;</a>
<a name="ln616">inline void QList&lt;T&gt;::prepend(const T &amp;t)</a>
<a name="ln617">{</a>
<a name="ln618">    if (d-&gt;ref.isShared()) {</a>
<a name="ln619">        Node *n = detach_helper_grow(0, 1);</a>
<a name="ln620">        QT_TRY {</a>
<a name="ln621">            node_construct(n, t);</a>
<a name="ln622">        } QT_CATCH(...) {</a>
<a name="ln623">            ++d-&gt;begin;</a>
<a name="ln624">            QT_RETHROW;</a>
<a name="ln625">        }</a>
<a name="ln626">    } else {</a>
<a name="ln627">        if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) {</a>
<a name="ln628">            Node *n = reinterpret_cast&lt;Node *&gt;(p.prepend());</a>
<a name="ln629">            QT_TRY {</a>
<a name="ln630">                node_construct(n, t);</a>
<a name="ln631">            } QT_CATCH(...) {</a>
<a name="ln632">                ++d-&gt;begin;</a>
<a name="ln633">                QT_RETHROW;</a>
<a name="ln634">            }</a>
<a name="ln635">        } else {</a>
<a name="ln636">            Node *n, copy;</a>
<a name="ln637">            node_construct(&amp;copy, t); // t might be a reference to an object in the array</a>
<a name="ln638">            QT_TRY {</a>
<a name="ln639">                n = reinterpret_cast&lt;Node *&gt;(p.prepend());;</a>
<a name="ln640">            } QT_CATCH(...) {</a>
<a name="ln641">                node_destruct(&amp;copy);</a>
<a name="ln642">                QT_RETHROW;</a>
<a name="ln643">            }</a>
<a name="ln644">            *n = copy;</a>
<a name="ln645">        }</a>
<a name="ln646">    }</a>
<a name="ln647">}</a>
<a name="ln648"> </a>
<a name="ln649">template &lt;typename T&gt;</a>
<a name="ln650">inline void QList&lt;T&gt;::insert(int i, const T &amp;t)</a>
<a name="ln651">{</a>
<a name="ln652">    if (d-&gt;ref.isShared()) {</a>
<a name="ln653">        Node *n = detach_helper_grow(i, 1);</a>
<a name="ln654">        QT_TRY {</a>
<a name="ln655">            node_construct(n, t);</a>
<a name="ln656">        } QT_CATCH(...) {</a>
<a name="ln657">            p.remove(i);</a>
<a name="ln658">            QT_RETHROW;</a>
<a name="ln659">        }</a>
<a name="ln660">    } else {</a>
<a name="ln661">        if (QTypeInfo&lt;T&gt;::isLarge || QTypeInfo&lt;T&gt;::isStatic) {</a>
<a name="ln662">            Node *n = reinterpret_cast&lt;Node *&gt;(p.insert(i));</a>
<a name="ln663">            QT_TRY {</a>
<a name="ln664">                node_construct(n, t);</a>
<a name="ln665">            } QT_CATCH(...) {</a>
<a name="ln666">                p.remove(i);</a>
<a name="ln667">                QT_RETHROW;</a>
<a name="ln668">            }</a>
<a name="ln669">        } else {</a>
<a name="ln670">            Node *n, copy;</a>
<a name="ln671">            node_construct(&amp;copy, t); // t might be a reference to an object in the array</a>
<a name="ln672">            QT_TRY {</a>
<a name="ln673">                n = reinterpret_cast&lt;Node *&gt;(p.insert(i));;</a>
<a name="ln674">            } QT_CATCH(...) {</a>
<a name="ln675">                node_destruct(&amp;copy);</a>
<a name="ln676">                QT_RETHROW;</a>
<a name="ln677">            }</a>
<a name="ln678">            *n = copy;</a>
<a name="ln679">        }</a>
<a name="ln680">    }</a>
<a name="ln681">}</a>
<a name="ln682"> </a>
<a name="ln683">template &lt;typename T&gt;</a>
<a name="ln684">inline void QList&lt;T&gt;::replace(int i, const T &amp;t)</a>
<a name="ln685">{</a>
<a name="ln686">    Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size(), &quot;QList&lt;T&gt;::replace&quot;, &quot;index out of range&quot;);</a>
<a name="ln687">    detach();</a>
<a name="ln688">    reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t() = t;</a>
<a name="ln689">}</a>
<a name="ln690"> </a>
<a name="ln691">template &lt;typename T&gt;</a>
<a name="ln692">inline void QList&lt;T&gt;::swap(int i, int j)</a>
<a name="ln693">{</a>
<a name="ln694">    Q_ASSERT_X(i &gt;= 0 &amp;&amp; i &lt; p.size() &amp;&amp; j &gt;= 0 &amp;&amp; j &lt; p.size(),</a>
<a name="ln695">                &quot;QList&lt;T&gt;::swap&quot;, &quot;index out of range&quot;);</a>
<a name="ln696">    detach();</a>
<a name="ln697">    std::swap(d-&gt;array[d-&gt;begin + i], d-&gt;array[d-&gt;begin + j]);</a>
<a name="ln698">}</a>
<a name="ln699"> </a>
<a name="ln700">template &lt;typename T&gt;</a>
<a name="ln701">inline void QList&lt;T&gt;::move(int from, int to)</a>
<a name="ln702">{</a>
<a name="ln703">    Q_ASSERT_X(from &gt;= 0 &amp;&amp; from &lt; p.size() &amp;&amp; to &gt;= 0 &amp;&amp; to &lt; p.size(),</a>
<a name="ln704">               &quot;QList&lt;T&gt;::move&quot;, &quot;index out of range&quot;);</a>
<a name="ln705">    detach();</a>
<a name="ln706">    p.move(from, to);</a>
<a name="ln707">}</a>
<a name="ln708"> </a>
<a name="ln709">template&lt;typename T&gt;</a>
<a name="ln710">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt; QList&lt;T&gt;::mid(int pos, int alength) const</a>
<a name="ln711">{</a>
<a name="ln712">    using namespace QtPrivate;</a>
<a name="ln713">    switch (QContainerImplHelper::mid(size(), &amp;pos, &amp;alength)) {</a>
<a name="ln714">    case QContainerImplHelper::Null:</a>
<a name="ln715">    case QContainerImplHelper::Empty:</a>
<a name="ln716">        return QList&lt;T&gt;();</a>
<a name="ln717">    case QContainerImplHelper::Full:</a>
<a name="ln718">        return *this;</a>
<a name="ln719">    case QContainerImplHelper::Subset:</a>
<a name="ln720">        break;</a>
<a name="ln721">    }</a>
<a name="ln722"> </a>
<a name="ln723">    QList&lt;T&gt; cpy;</a>
<a name="ln724">    if (alength &lt;= 0)</a>
<a name="ln725">        return cpy;</a>
<a name="ln726">    cpy.reserve(alength);</a>
<a name="ln727">    cpy.d-&gt;end = alength;</a>
<a name="ln728">    QT_TRY {</a>
<a name="ln729">        cpy.node_copy(reinterpret_cast&lt;Node *&gt;(cpy.p.begin()),</a>
<a name="ln730">                      reinterpret_cast&lt;Node *&gt;(cpy.p.end()),</a>
<a name="ln731">                      reinterpret_cast&lt;Node *&gt;(p.begin() + pos));</a>
<a name="ln732">    } QT_CATCH(...) {</a>
<a name="ln733">        // restore the old end</a>
<a name="ln734">        cpy.d-&gt;end = 0;</a>
<a name="ln735">        QT_RETHROW;</a>
<a name="ln736">    }</a>
<a name="ln737">    return cpy;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">template&lt;typename T&gt;</a>
<a name="ln741">Q_OUTOFLINE_TEMPLATE T QList&lt;T&gt;::value(int i) const</a>
<a name="ln742">{</a>
<a name="ln743">    if (i &lt; 0 || i &gt;= p.size()) {</a>
<a name="ln744">        return T();</a>
<a name="ln745">    }</a>
<a name="ln746">    return reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t();</a>
<a name="ln747">}</a>
<a name="ln748"> </a>
<a name="ln749">template&lt;typename T&gt;</a>
<a name="ln750">Q_OUTOFLINE_TEMPLATE T QList&lt;T&gt;::value(int i, const T&amp; defaultValue) const</a>
<a name="ln751">{</a>
<a name="ln752">    return ((i &lt; 0 || i &gt;= p.size()) ? defaultValue : reinterpret_cast&lt;Node *&gt;(p.at(i))-&gt;t());</a>
<a name="ln753">}</a>
<a name="ln754"> </a>
<a name="ln755">template &lt;typename T&gt;</a>
<a name="ln756">Q_OUTOFLINE_TEMPLATE typename QList&lt;T&gt;::Node *QList&lt;T&gt;::detach_helper_grow(int i, int c)</a>
<a name="ln757">{</a>
<a name="ln758">    Node *n = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln759">    QListData::Data *x = p.detach_grow(&amp;i, c);</a>
<a name="ln760">    QT_TRY {</a>
<a name="ln761">        node_copy(reinterpret_cast&lt;Node *&gt;(p.begin()),</a>
<a name="ln762">                  reinterpret_cast&lt;Node *&gt;(p.begin() + i), n);</a>
<a name="ln763">    } QT_CATCH(...) {</a>
<a name="ln764">        p.dispose();</a>
<a name="ln765">        d = x;</a>
<a name="ln766">        QT_RETHROW;</a>
<a name="ln767">    }</a>
<a name="ln768">    QT_TRY {</a>
<a name="ln769">        node_copy(reinterpret_cast&lt;Node *&gt;(p.begin() + i + c),</a>
<a name="ln770">                  reinterpret_cast&lt;Node *&gt;(p.end()), n + i);</a>
<a name="ln771">    } QT_CATCH(...) {</a>
<a name="ln772">        node_destruct(reinterpret_cast&lt;Node *&gt;(p.begin()),</a>
<a name="ln773">                      reinterpret_cast&lt;Node *&gt;(p.begin() + i));</a>
<a name="ln774">        p.dispose();</a>
<a name="ln775">        d = x;</a>
<a name="ln776">        QT_RETHROW;</a>
<a name="ln777">    }</a>
<a name="ln778"> </a>
<a name="ln779">    if (!x-&gt;ref.deref())</a>
<a name="ln780">        dealloc(x);</a>
<a name="ln781"> </a>
<a name="ln782">    return reinterpret_cast&lt;Node *&gt;(p.begin() + i);</a>
<a name="ln783">}</a>
<a name="ln784"> </a>
<a name="ln785">template &lt;typename T&gt;</a>
<a name="ln786">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::detach_helper(int alloc)</a>
<a name="ln787">{</a>
<a name="ln788">    Node *n = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln789">    QListData::Data *x = p.detach(alloc);</a>
<a name="ln790">    QT_TRY {</a>
<a name="ln791">        node_copy(reinterpret_cast&lt;Node *&gt;(p.begin()), reinterpret_cast&lt;Node *&gt;(p.end()), n);</a>
<a name="ln792">    } QT_CATCH(...) {</a>
<a name="ln793">        p.dispose();</a>
<a name="ln794">        d = x;</a>
<a name="ln795">        QT_RETHROW;</a>
<a name="ln796">    }</a>
<a name="ln797"> </a>
<a name="ln798">    if (!x-&gt;ref.deref())</a>
<a name="ln799">        dealloc(x);</a>
<a name="ln800">}</a>
<a name="ln801"> </a>
<a name="ln802">template &lt;typename T&gt;</a>
<a name="ln803">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::detach_helper()</a>
<a name="ln804">{</a>
<a name="ln805">    detach_helper(d-&gt;alloc);</a>
<a name="ln806">}</a>
<a name="ln807"> </a>
<a name="ln808">template &lt;typename T&gt;</a>
<a name="ln809">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt;::QList(const QList&lt;T&gt; &amp;l)</a>
<a name="ln810">    : QListSpecialMethods&lt;T&gt;(l), d(l.d)</a>
<a name="ln811">{</a>
<a name="ln812">    if (!d-&gt;ref.ref()) {</a>
<a name="ln813">        p.detach(d-&gt;alloc);</a>
<a name="ln814"> </a>
<a name="ln815">        QT_TRY {</a>
<a name="ln816">            node_copy(reinterpret_cast&lt;Node *&gt;(p.begin()),</a>
<a name="ln817">                    reinterpret_cast&lt;Node *&gt;(p.end()),</a>
<a name="ln818">                    reinterpret_cast&lt;Node *&gt;(l.p.begin()));</a>
<a name="ln819">        } QT_CATCH(...) {</a>
<a name="ln820">            QListData::dispose(d);</a>
<a name="ln821">            QT_RETHROW;</a>
<a name="ln822">        }</a>
<a name="ln823">    }</a>
<a name="ln824">}</a>
<a name="ln825"> </a>
<a name="ln826">template &lt;typename T&gt;</a>
<a name="ln827">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt;::~QList()</a>
<a name="ln828">{</a>
<a name="ln829">    if (!d-&gt;ref.deref())</a>
<a name="ln830">        dealloc(d);</a>
<a name="ln831">}</a>
<a name="ln832"> </a>
<a name="ln833">template &lt;typename T&gt;</a>
<a name="ln834">Q_OUTOFLINE_TEMPLATE bool QList&lt;T&gt;::operator==(const QList&lt;T&gt; &amp;l) const</a>
<a name="ln835">{</a>
<a name="ln836">    if (d == l.d)</a>
<a name="ln837">        return true;</a>
<a name="ln838">    if (p.size() != l.p.size())</a>
<a name="ln839">        return false;</a>
<a name="ln840">    return this-&gt;op_eq_impl(l, MemoryLayout());</a>
<a name="ln841">}</a>
<a name="ln842"> </a>
<a name="ln843">template &lt;typename T&gt;</a>
<a name="ln844">inline bool QList&lt;T&gt;::op_eq_impl(const QList &amp;l, QListData::NotArrayCompatibleLayout) const</a>
<a name="ln845">{</a>
<a name="ln846">    Node *i = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln847">    Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln848">    Node *li = reinterpret_cast&lt;Node *&gt;(l.p.begin());</a>
<a name="ln849">    for (; i != e; ++i, ++li) {</a>
<a name="ln850">        if (!(i-&gt;t() == li-&gt;t()))</a>
<a name="ln851">            return false;</a>
<a name="ln852">    }</a>
<a name="ln853">    return true;</a>
<a name="ln854">}</a>
<a name="ln855"> </a>
<a name="ln856">template &lt;typename T&gt;</a>
<a name="ln857">inline bool QList&lt;T&gt;::op_eq_impl(const QList &amp;l, QListData::ArrayCompatibleLayout) const</a>
<a name="ln858">{</a>
<a name="ln859">    const T *lb = reinterpret_cast&lt;const T*&gt;(l.p.begin());</a>
<a name="ln860">    const T *b  = reinterpret_cast&lt;const T*&gt;(p.begin());</a>
<a name="ln861">    const T *e  = reinterpret_cast&lt;const T*&gt;(p.end());</a>
<a name="ln862">    return std::equal(b, e, QT_MAKE_CHECKED_ARRAY_ITERATOR(lb, l.p.size()));</a>
<a name="ln863">}</a>
<a name="ln864"> </a>
<a name="ln865">template &lt;typename T&gt;</a>
<a name="ln866">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::dealloc(QListData::Data *data)</a>
<a name="ln867">{</a>
<a name="ln868">    node_destruct(reinterpret_cast&lt;Node *&gt;(data-&gt;array + data-&gt;begin),</a>
<a name="ln869">                  reinterpret_cast&lt;Node *&gt;(data-&gt;array + data-&gt;end));</a>
<a name="ln870">    QListData::dispose(data);</a>
<a name="ln871">}</a>
<a name="ln872"> </a>
<a name="ln873"> </a>
<a name="ln874">template &lt;typename T&gt;</a>
<a name="ln875">Q_OUTOFLINE_TEMPLATE void QList&lt;T&gt;::clear()</a>
<a name="ln876">{</a>
<a name="ln877">    *this = QList&lt;T&gt;();</a>
<a name="ln878">}</a>
<a name="ln879"> </a>
<a name="ln880">template &lt;typename T&gt;</a>
<a name="ln881">Q_OUTOFLINE_TEMPLATE int QList&lt;T&gt;::removeAll(const T &amp;_t)</a>
<a name="ln882">{</a>
<a name="ln883">    int index = indexOf(_t);</a>
<a name="ln884">    if (index == -1)</a>
<a name="ln885">        return 0;</a>
<a name="ln886"> </a>
<a name="ln887">    const T t = _t;</a>
<a name="ln888">    detach();</a>
<a name="ln889"> </a>
<a name="ln890">    Node *i = reinterpret_cast&lt;Node *&gt;(p.at(index));</a>
<a name="ln891">    Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln892">    Node *n = i;</a>
<a name="ln893">    node_destruct(i);</a>
<a name="ln894">    while (++i != e) {</a>
<a name="ln895">        if (i-&gt;t() == t)</a>
<a name="ln896">            node_destruct(i);</a>
<a name="ln897">        else</a>
<a name="ln898">            *n++ = *i;</a>
<a name="ln899">    }</a>
<a name="ln900"> </a>
<a name="ln901">    int removedCount = int(e - n);</a>
<a name="ln902">    d-&gt;end -= removedCount;</a>
<a name="ln903">    return removedCount;</a>
<a name="ln904">}</a>
<a name="ln905"> </a>
<a name="ln906">template &lt;typename T&gt;</a>
<a name="ln907">Q_OUTOFLINE_TEMPLATE bool QList&lt;T&gt;::removeOne(const T &amp;_t)</a>
<a name="ln908">{</a>
<a name="ln909">    int index = indexOf(_t);</a>
<a name="ln910">    if (index != -1) {</a>
<a name="ln911">        removeAt(index);</a>
<a name="ln912">        return true;</a>
<a name="ln913">    }</a>
<a name="ln914">    return false;</a>
<a name="ln915">}</a>
<a name="ln916"> </a>
<a name="ln917">template &lt;typename T&gt;</a>
<a name="ln918">Q_OUTOFLINE_TEMPLATE typename QList&lt;T&gt;::iterator QList&lt;T&gt;::erase(typename QList&lt;T&gt;::iterator afirst,</a>
<a name="ln919">                                                                 typename QList&lt;T&gt;::iterator alast)</a>
<a name="ln920">{</a>
<a name="ln921">    Q_ASSERT_X(isValidIterator(afirst), &quot;QList::erase&quot;, &quot;The specified iterator argument 'afirst' is invalid&quot;);</a>
<a name="ln922">    Q_ASSERT_X(isValidIterator(alast), &quot;QList::erase&quot;, &quot;The specified iterator argument 'alast' is invalid&quot;);</a>
<a name="ln923"> </a>
<a name="ln924">    if (d-&gt;ref.isShared()) {</a>
<a name="ln925">        // ### A block is erased and a detach is needed. We should shrink and only copy relevant items.</a>
<a name="ln926">        int offsetfirst = int(afirst.i - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln927">        int offsetlast = int(alast.i - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln928">        afirst = begin(); // implies detach()</a>
<a name="ln929">        alast = afirst;</a>
<a name="ln930">        afirst += offsetfirst;</a>
<a name="ln931">        alast += offsetlast;</a>
<a name="ln932">    }</a>
<a name="ln933"> </a>
<a name="ln934">    for (Node *n = afirst.i; n &lt; alast.i; ++n)</a>
<a name="ln935">        node_destruct(n);</a>
<a name="ln936">    int idx = afirst - begin();</a>
<a name="ln937">    p.remove(idx, alast - afirst);</a>
<a name="ln938">    return begin() + idx;</a>
<a name="ln939">}</a>
<a name="ln940"> </a>
<a name="ln941">template &lt;typename T&gt;</a>
<a name="ln942">Q_OUTOFLINE_TEMPLATE QList&lt;T&gt; &amp;QList&lt;T&gt;::operator+=(const QList&lt;T&gt; &amp;l)</a>
<a name="ln943">{</a>
<a name="ln944">    if (!l.isEmpty()) {</a>
<a name="ln945">        if (d == &amp;QListData::shared_null) {</a>
<a name="ln946">            *this = l;</a>
<a name="ln947">        } else {</a>
<a name="ln948">            Node *n = (d-&gt;ref.isShared())</a>
<a name="ln949">                      ? detach_helper_grow(INT_MAX, l.size())</a>
<a name="ln950">                      : reinterpret_cast&lt;Node *&gt;(p.append(l.p));</a>
<a name="ln951">            QT_TRY {</a>
<a name="ln952">                node_copy(n, reinterpret_cast&lt;Node *&gt;(p.end()),</a>
<a name="ln953">                          reinterpret_cast&lt;Node *&gt;(l.p.begin()));</a>
<a name="ln954">            } QT_CATCH(...) {</a>
<a name="ln955">                // restore the old end</a>
<a name="ln956">                d-&gt;end -= int(reinterpret_cast&lt;Node *&gt;(p.end()) - n);</a>
<a name="ln957">                QT_RETHROW;</a>
<a name="ln958">            }</a>
<a name="ln959">        }</a>
<a name="ln960">    }</a>
<a name="ln961">    return *this;</a>
<a name="ln962">}</a>
<a name="ln963"> </a>
<a name="ln964">template &lt;typename T&gt;</a>
<a name="ln965">inline void QList&lt;T&gt;::append(const QList&lt;T&gt; &amp;t)</a>
<a name="ln966">{</a>
<a name="ln967">    *this += t;</a>
<a name="ln968">}</a>
<a name="ln969"> </a>
<a name="ln970">template &lt;typename T&gt;</a>
<a name="ln971">Q_OUTOFLINE_TEMPLATE int QList&lt;T&gt;::indexOf(const T &amp;t, int from) const</a>
<a name="ln972">{</a>
<a name="ln973">    if (from &lt; 0)</a>
<a name="ln974">        from = qMax(from + p.size(), 0);</a>
<a name="ln975">    if (from &lt; p.size()) {</a>
<a name="ln976">        Node *n = reinterpret_cast&lt;Node *&gt;(p.at(from -1));</a>
<a name="ln977">        Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln978">        while (++n != e)</a>
<a name="ln979">            if (n-&gt;t() == t)</a>
<a name="ln980">                return int(n - reinterpret_cast&lt;Node *&gt;(p.begin()));</a>
<a name="ln981">    }</a>
<a name="ln982">    return -1;</a>
<a name="ln983">}</a>
<a name="ln984"> </a>
<a name="ln985">template &lt;typename T&gt;</a>
<a name="ln986">Q_OUTOFLINE_TEMPLATE int QList&lt;T&gt;::lastIndexOf(const T &amp;t, int from) const</a>
<a name="ln987">{</a>
<a name="ln988">    if (from &lt; 0)</a>
<a name="ln989">        from += p.size();</a>
<a name="ln990">    else if (from &gt;= p.size())</a>
<a name="ln991">        from = p.size()-1;</a>
<a name="ln992">    if (from &gt;= 0) {</a>
<a name="ln993">        Node *b = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln994">        Node *n = reinterpret_cast&lt;Node *&gt;(p.at(from + 1));</a>
<a name="ln995">        while (n-- != b) {</a>
<a name="ln996">            if (n-&gt;t() == t)</a>
<a name="ln997">                return n - b;</a>
<a name="ln998">        }</a>
<a name="ln999">    }</a>
<a name="ln1000">    return -1;</a>
<a name="ln1001">}</a>
<a name="ln1002"> </a>
<a name="ln1003">template &lt;typename T&gt;</a>
<a name="ln1004">Q_OUTOFLINE_TEMPLATE bool QList&lt;T&gt;::contains(const T &amp;t) const</a>
<a name="ln1005">{</a>
<a name="ln1006">    return contains_impl(t, MemoryLayout());</a>
<a name="ln1007">}</a>
<a name="ln1008"> </a>
<a name="ln1009">template &lt;typename T&gt;</a>
<a name="ln1010">inline bool QList&lt;T&gt;::contains_impl(const T &amp;t, QListData::NotArrayCompatibleLayout) const</a>
<a name="ln1011">{</a>
<a name="ln1012">    Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln1013">    Node *i = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln1014">    for (; i != e; ++i)</a>
<a name="ln1015">        if (i-&gt;t() == t)</a>
<a name="ln1016">            return true;</a>
<a name="ln1017">    return false;</a>
<a name="ln1018">}</a>
<a name="ln1019"> </a>
<a name="ln1020">template &lt;typename T&gt;</a>
<a name="ln1021">inline bool QList&lt;T&gt;::contains_impl(const T &amp;t, QListData::ArrayCompatibleLayout) const</a>
<a name="ln1022">{</a>
<a name="ln1023">    const T *b = reinterpret_cast&lt;const T*&gt;(p.begin());</a>
<a name="ln1024">    const T *e = reinterpret_cast&lt;const T*&gt;(p.end());</a>
<a name="ln1025">    return std::find(b, e, t) != e;</a>
<a name="ln1026">}</a>
<a name="ln1027"> </a>
<a name="ln1028">template &lt;typename T&gt;</a>
<a name="ln1029">Q_OUTOFLINE_TEMPLATE int QList&lt;T&gt;::count(const T &amp;t) const</a>
<a name="ln1030">{</a>
<a name="ln1031">    return this-&gt;count_impl(t, MemoryLayout());</a>
<a name="ln1032">}</a>
<a name="ln1033"> </a>
<a name="ln1034">template &lt;typename T&gt;</a>
<a name="ln1035">inline int QList&lt;T&gt;::count_impl(const T &amp;t, QListData::NotArrayCompatibleLayout) const</a>
<a name="ln1036">{</a>
<a name="ln1037">    int c = 0;</a>
<a name="ln1038">    Node *e = reinterpret_cast&lt;Node *&gt;(p.end());</a>
<a name="ln1039">    Node *i = reinterpret_cast&lt;Node *&gt;(p.begin());</a>
<a name="ln1040">    for (; i != e; ++i)</a>
<a name="ln1041">        if (i-&gt;t() == t)</a>
<a name="ln1042">            ++c;</a>
<a name="ln1043">    return c;</a>
<a name="ln1044">}</a>
<a name="ln1045"> </a>
<a name="ln1046">template &lt;typename T&gt;</a>
<a name="ln1047">inline int QList&lt;T&gt;::count_impl(const T &amp;t, QListData::ArrayCompatibleLayout) const</a>
<a name="ln1048">{</a>
<a name="ln1049">    return int(std::count(reinterpret_cast&lt;const T*&gt;(p.begin()),</a>
<a name="ln1050">                          reinterpret_cast&lt;const T*&gt;(p.end()),</a>
<a name="ln1051">                          t));</a>
<a name="ln1052">}</a>
<a name="ln1053"> </a>
<a name="ln1054">Q_DECLARE_SEQUENTIAL_ITERATOR(List)</a>
<a name="ln1055">Q_DECLARE_MUTABLE_SEQUENTIAL_ITERATOR(List)</a>
<a name="ln1056"> </a>
<a name="ln1057">template &lt;typename T&gt;</a>
<a name="ln1058">uint qHash(const QList&lt;T&gt; &amp;key, uint seed = 0)</a>
<a name="ln1059">    Q_DECL_NOEXCEPT_EXPR(noexcept(qHashRange(key.cbegin(), key.cend(), seed)))</a>
<a name="ln1060">{</a>
<a name="ln1061">    return qHashRange(key.cbegin(), key.cend(), seed);</a>
<a name="ln1062">}</a>
<a name="ln1063"> </a>
<a name="ln1064">template &lt;typename T&gt;</a>
<a name="ln1065">bool operator&lt;(const QList&lt;T&gt; &amp;lhs, const QList&lt;T&gt; &amp;rhs)</a>
<a name="ln1066">    Q_DECL_NOEXCEPT_EXPR(noexcept(std::lexicographical_compare(lhs.begin(), lhs.end(),</a>
<a name="ln1067">                                                               rhs.begin(), rhs.end())))</a>
<a name="ln1068">{</a>
<a name="ln1069">    return std::lexicographical_compare(lhs.begin(), lhs.end(),</a>
<a name="ln1070">                                        rhs.begin(), rhs.end());</a>
<a name="ln1071">}</a>
<a name="ln1072"> </a>
<a name="ln1073">template &lt;typename T&gt;</a>
<a name="ln1074">inline bool operator&gt;(const QList&lt;T&gt; &amp;lhs, const QList&lt;T&gt; &amp;rhs)</a>
<a name="ln1075">    Q_DECL_NOEXCEPT_EXPR(noexcept(lhs &lt; rhs))</a>
<a name="ln1076">{</a>
<a name="ln1077">    return rhs &lt; lhs;</a>
<a name="ln1078">}</a>
<a name="ln1079"> </a>
<a name="ln1080">template &lt;typename T&gt;</a>
<a name="ln1081">inline bool operator&lt;=(const QList&lt;T&gt; &amp;lhs, const QList&lt;T&gt; &amp;rhs)</a>
<a name="ln1082">    Q_DECL_NOEXCEPT_EXPR(noexcept(lhs &lt; rhs))</a>
<a name="ln1083">{</a>
<a name="ln1084">    return !(lhs &gt; rhs);</a>
<a name="ln1085">}</a>
<a name="ln1086"> </a>
<a name="ln1087">template &lt;typename T&gt;</a>
<a name="ln1088">inline bool operator&gt;=(const QList&lt;T&gt; &amp;lhs, const QList&lt;T&gt; &amp;rhs)</a>
<a name="ln1089">    Q_DECL_NOEXCEPT_EXPR(noexcept(lhs &lt; rhs))</a>
<a name="ln1090">{</a>
<a name="ln1091">    return !(lhs &lt; rhs);</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">QT_END_NAMESPACE</a>
<a name="ln1095"> </a>
<a name="ln1096">#include &lt;QtCore/qbytearraylist.h&gt;</a>
<a name="ln1097">#include &lt;QtCore/qstringlist.h&gt;</a>
<a name="ln1098"> </a>
<a name="ln1099">#ifdef Q_CC_MSVC</a>
<a name="ln1100">#pragma warning( pop )</a>
<a name="ln1101">#endif</a>
<a name="ln1102"> </a>
<a name="ln1103">#endif // QLIST_H</a>

</code></pre>
<div class="balloon" rel="224"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'iterator' class implements a copy constructor, but lacks the copy assignment operator. It is dangerous to use such a class.</p></div>
<div class="balloon" rel="277"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v690/" target="_blank">V690</a> The 'const_iterator' class implements a copy constructor, but lacks the copy assignment operator. It is dangerous to use such a class.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
