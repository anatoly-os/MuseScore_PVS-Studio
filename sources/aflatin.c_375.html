
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>aflatin.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***************************************************************************/</a>
<a name="ln2">/*                                                                         */</a>
<a name="ln3">/*  aflatin.c                                                              */</a>
<a name="ln4">/*                                                                         */</a>
<a name="ln5">/*    Auto-fitter hinting routines for latin writing system (body).        */</a>
<a name="ln6">/*                                                                         */</a>
<a name="ln7">/*  Copyright 2003-2015 by                                                 */</a>
<a name="ln8">/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</a>
<a name="ln9">/*                                                                         */</a>
<a name="ln10">/*  This file is part of the FreeType project, and may only be used,       */</a>
<a name="ln11">/*  modified, and distributed under the terms of the FreeType project      */</a>
<a name="ln12">/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</a>
<a name="ln13">/*  this file you indicate that you have read the license and              */</a>
<a name="ln14">/*  understand and accept it fully.                                        */</a>
<a name="ln15">/*                                                                         */</a>
<a name="ln16">/***************************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &lt;ft2build.h&gt;</a>
<a name="ln20">#include FT_ADVANCES_H</a>
<a name="ln21">#include FT_INTERNAL_DEBUG_H</a>
<a name="ln22"> </a>
<a name="ln23">#include &quot;afglobal.h&quot;</a>
<a name="ln24">#include &quot;afpic.h&quot;</a>
<a name="ln25">#include &quot;aflatin.h&quot;</a>
<a name="ln26">#include &quot;aferrors.h&quot;</a>
<a name="ln27"> </a>
<a name="ln28"> </a>
<a name="ln29">#ifdef AF_CONFIG_OPTION_USE_WARPER</a>
<a name="ln30">#include &quot;afwarp.h&quot;</a>
<a name="ln31">#endif</a>
<a name="ln32"> </a>
<a name="ln33"> </a>
<a name="ln34">  /*************************************************************************/</a>
<a name="ln35">  /*                                                                       */</a>
<a name="ln36">  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</a>
<a name="ln37">  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</a>
<a name="ln38">  /* messages during execution.                                            */</a>
<a name="ln39">  /*                                                                       */</a>
<a name="ln40">#undef  FT_COMPONENT</a>
<a name="ln41">#define FT_COMPONENT  trace_aflatin</a>
<a name="ln42"> </a>
<a name="ln43"> </a>
<a name="ln44">  /* needed for computation of round vs. flat segments */</a>
<a name="ln45">#define FLAT_THRESHOLD( x )  ( x / 14 )</a>
<a name="ln46"> </a>
<a name="ln47"> </a>
<a name="ln48">  /*************************************************************************/</a>
<a name="ln49">  /*************************************************************************/</a>
<a name="ln50">  /*****                                                               *****/</a>
<a name="ln51">  /*****            L A T I N   G L O B A L   M E T R I C S            *****/</a>
<a name="ln52">  /*****                                                               *****/</a>
<a name="ln53">  /*************************************************************************/</a>
<a name="ln54">  /*************************************************************************/</a>
<a name="ln55"> </a>
<a name="ln56"> </a>
<a name="ln57">  /* Find segments and links, compute all stem widths, and initialize */</a>
<a name="ln58">  /* standard width and height for the glyph with given charcode.     */</a>
<a name="ln59"> </a>
<a name="ln60">  FT_LOCAL_DEF( void )</a>
<a name="ln61">  af_latin_metrics_init_widths( AF_LatinMetrics  metrics,</a>
<a name="ln62">                                FT_Face          face )</a>
<a name="ln63">  {</a>
<a name="ln64">    /* scan the array of segments in each direction */</a>
<a name="ln65">    AF_GlyphHintsRec  hints[1];</a>
<a name="ln66"> </a>
<a name="ln67"> </a>
<a name="ln68">    FT_TRACE5(( &quot;\n&quot;</a>
<a name="ln69">                &quot;latin standard widths computation (style `%s')\n&quot;</a>
<a name="ln70">                &quot;=====================================================\n&quot;</a>
<a name="ln71">                &quot;\n&quot;,</a>
<a name="ln72">                af_style_names[metrics-&gt;root.style_class-&gt;style] ));</a>
<a name="ln73"> </a>
<a name="ln74">    af_glyph_hints_init( hints, face-&gt;memory );</a>
<a name="ln75"> </a>
<a name="ln76">    metrics-&gt;axis[AF_DIMENSION_HORZ].width_count = 0;</a>
<a name="ln77">    metrics-&gt;axis[AF_DIMENSION_VERT].width_count = 0;</a>
<a name="ln78"> </a>
<a name="ln79">    {</a>
<a name="ln80">      FT_Error            error;</a>
<a name="ln81">      FT_ULong            glyph_index;</a>
<a name="ln82">      FT_Long             y_offset;</a>
<a name="ln83">      int                 dim;</a>
<a name="ln84">      AF_LatinMetricsRec  dummy[1];</a>
<a name="ln85">      AF_Scaler           scaler = &amp;dummy-&gt;root.scaler;</a>
<a name="ln86"> </a>
<a name="ln87">#ifdef FT_CONFIG_OPTION_PIC</a>
<a name="ln88">      AF_FaceGlobals  globals = metrics-&gt;root.globals;</a>
<a name="ln89">#endif</a>
<a name="ln90"> </a>
<a name="ln91">      AF_StyleClass   style_class  = metrics-&gt;root.style_class;</a>
<a name="ln92">      AF_ScriptClass  script_class = AF_SCRIPT_CLASSES_GET</a>
<a name="ln93">                                       [style_class-&gt;script];</a>
<a name="ln94"> </a>
<a name="ln95">      FT_UInt32  standard_char;</a>
<a name="ln96"> </a>
<a name="ln97"> </a>
<a name="ln98">      /*</a>
<a name="ln99">       * We check more than a single standard character to catch features</a>
<a name="ln100">       * like `c2sc' (small caps from caps) that don't contain lowercase</a>
<a name="ln101">       * letters by definition, or other features that mainly operate on</a>
<a name="ln102">       * numerals.</a>
<a name="ln103">       */</a>
<a name="ln104"> </a>
<a name="ln105">      standard_char = script_class-&gt;standard_char1;</a>
<a name="ln106">      af_get_char_index( &amp;metrics-&gt;root,</a>
<a name="ln107">                         standard_char,</a>
<a name="ln108">                         &amp;glyph_index,</a>
<a name="ln109">                         &amp;y_offset );</a>
<a name="ln110">      if ( !glyph_index )</a>
<a name="ln111">      {</a>
<a name="ln112">        if ( script_class-&gt;standard_char2 )</a>
<a name="ln113">        {</a>
<a name="ln114">          standard_char = script_class-&gt;standard_char2;</a>
<a name="ln115">          af_get_char_index( &amp;metrics-&gt;root,</a>
<a name="ln116">                             standard_char,</a>
<a name="ln117">                             &amp;glyph_index,</a>
<a name="ln118">                             &amp;y_offset );</a>
<a name="ln119">          if ( !glyph_index )</a>
<a name="ln120">          {</a>
<a name="ln121">            if ( script_class-&gt;standard_char3 )</a>
<a name="ln122">            {</a>
<a name="ln123">              standard_char = script_class-&gt;standard_char3;</a>
<a name="ln124">              af_get_char_index( &amp;metrics-&gt;root,</a>
<a name="ln125">                                 standard_char,</a>
<a name="ln126">                                 &amp;glyph_index,</a>
<a name="ln127">                                 &amp;y_offset );</a>
<a name="ln128">              if ( !glyph_index )</a>
<a name="ln129">                goto Exit;</a>
<a name="ln130">            }</a>
<a name="ln131">            else</a>
<a name="ln132">              goto Exit;</a>
<a name="ln133">          }</a>
<a name="ln134">        }</a>
<a name="ln135">        else</a>
<a name="ln136">          goto Exit;</a>
<a name="ln137">      }</a>
<a name="ln138"> </a>
<a name="ln139">      FT_TRACE5(( &quot;standard character: U+%04lX (glyph index %d)\n&quot;,</a>
<a name="ln140">                  standard_char, glyph_index ));</a>
<a name="ln141"> </a>
<a name="ln142">      error = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );</a>
<a name="ln143">      if ( error || face-&gt;glyph-&gt;outline.n_points &lt;= 0 )</a>
<a name="ln144">        goto Exit;</a>
<a name="ln145"> </a>
<a name="ln146">      FT_ZERO( dummy );</a>
<a name="ln147"> </a>
<a name="ln148">      dummy-&gt;units_per_em = metrics-&gt;units_per_em;</a>
<a name="ln149"> </a>
<a name="ln150">      scaler-&gt;x_scale = 0x10000L;</a>
<a name="ln151">      scaler-&gt;y_scale = 0x10000L;</a>
<a name="ln152">      scaler-&gt;x_delta = 0;</a>
<a name="ln153">      scaler-&gt;y_delta = 0;</a>
<a name="ln154"> </a>
<a name="ln155">      scaler-&gt;face        = face;</a>
<a name="ln156">      scaler-&gt;render_mode = FT_RENDER_MODE_NORMAL;</a>
<a name="ln157">      scaler-&gt;flags       = 0;</a>
<a name="ln158"> </a>
<a name="ln159">      af_glyph_hints_rescale( hints, (AF_StyleMetrics)dummy );</a>
<a name="ln160"> </a>
<a name="ln161">      error = af_glyph_hints_reload( hints, &amp;face-&gt;glyph-&gt;outline );</a>
<a name="ln162">      if ( error )</a>
<a name="ln163">        goto Exit;</a>
<a name="ln164"> </a>
<a name="ln165">      for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )</a>
<a name="ln166">      {</a>
<a name="ln167">        AF_LatinAxis  axis    = &amp;metrics-&gt;axis[dim];</a>
<a name="ln168">        AF_AxisHints  axhints = &amp;hints-&gt;axis[dim];</a>
<a name="ln169">        AF_Segment    seg, limit, link;</a>
<a name="ln170">        FT_UInt       num_widths = 0;</a>
<a name="ln171"> </a>
<a name="ln172"> </a>
<a name="ln173">        error = af_latin_hints_compute_segments( hints,</a>
<a name="ln174">                                                 (AF_Dimension)dim );</a>
<a name="ln175">        if ( error )</a>
<a name="ln176">          goto Exit;</a>
<a name="ln177"> </a>
<a name="ln178">        /*</a>
<a name="ln179">         *  We assume that the glyphs selected for the stem width</a>
<a name="ln180">         *  computation are `featureless' enough so that the linking</a>
<a name="ln181">         *  algorithm works fine without adjustments of its scoring</a>
<a name="ln182">         *  function.</a>
<a name="ln183">         */</a>
<a name="ln184">        af_latin_hints_link_segments( hints,</a>
<a name="ln185">                                      0,</a>
<a name="ln186">                                      NULL,</a>
<a name="ln187">                                      (AF_Dimension)dim );</a>
<a name="ln188"> </a>
<a name="ln189">        seg   = axhints-&gt;segments;</a>
<a name="ln190">        limit = seg + axhints-&gt;num_segments;</a>
<a name="ln191"> </a>
<a name="ln192">        for ( ; seg &lt; limit; seg++ )</a>
<a name="ln193">        {</a>
<a name="ln194">          link = seg-&gt;link;</a>
<a name="ln195"> </a>
<a name="ln196">          /* we only consider stem segments there! */</a>
<a name="ln197">          if ( link &amp;&amp; link-&gt;link == seg &amp;&amp; link &gt; seg )</a>
<a name="ln198">          {</a>
<a name="ln199">            FT_Pos  dist;</a>
<a name="ln200"> </a>
<a name="ln201"> </a>
<a name="ln202">            dist = seg-&gt;pos - link-&gt;pos;</a>
<a name="ln203">            if ( dist &lt; 0 )</a>
<a name="ln204">              dist = -dist;</a>
<a name="ln205"> </a>
<a name="ln206">            if ( num_widths &lt; AF_LATIN_MAX_WIDTHS )</a>
<a name="ln207">              axis-&gt;widths[num_widths++].org = dist;</a>
<a name="ln208">          }</a>
<a name="ln209">        }</a>
<a name="ln210"> </a>
<a name="ln211">        /* this also replaces multiple almost identical stem widths */</a>
<a name="ln212">        /* with a single one (the value 100 is heuristic)           */</a>
<a name="ln213">        af_sort_and_quantize_widths( &amp;num_widths, axis-&gt;widths,</a>
<a name="ln214">                                     dummy-&gt;units_per_em / 100 );</a>
<a name="ln215">        axis-&gt;width_count = num_widths;</a>
<a name="ln216">      }</a>
<a name="ln217"> </a>
<a name="ln218">    Exit:</a>
<a name="ln219">      for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )</a>
<a name="ln220">      {</a>
<a name="ln221">        AF_LatinAxis  axis = &amp;metrics-&gt;axis[dim];</a>
<a name="ln222">        FT_Pos        stdw;</a>
<a name="ln223"> </a>
<a name="ln224"> </a>
<a name="ln225">        stdw = ( axis-&gt;width_count &gt; 0 ) ? axis-&gt;widths[0].org</a>
<a name="ln226">                                         : AF_LATIN_CONSTANT( metrics, 50 );</a>
<a name="ln227"> </a>
<a name="ln228">        /* let's try 20% of the smallest width */</a>
<a name="ln229">        axis-&gt;edge_distance_threshold = stdw / 5;</a>
<a name="ln230">        axis-&gt;standard_width          = stdw;</a>
<a name="ln231">        axis-&gt;extra_light             = 0;</a>
<a name="ln232"> </a>
<a name="ln233">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln234">        {</a>
<a name="ln235">          FT_UInt  i;</a>
<a name="ln236"> </a>
<a name="ln237"> </a>
<a name="ln238">          FT_TRACE5(( &quot;%s widths:\n&quot;,</a>
<a name="ln239">                      dim == AF_DIMENSION_VERT ? &quot;horizontal&quot;</a>
<a name="ln240">                                               : &quot;vertical&quot; ));</a>
<a name="ln241"> </a>
<a name="ln242">          FT_TRACE5(( &quot;  %d (standard)&quot;, axis-&gt;standard_width ));</a>
<a name="ln243">          for ( i = 1; i &lt; axis-&gt;width_count; i++ )</a>
<a name="ln244">            FT_TRACE5(( &quot; %d&quot;, axis-&gt;widths[i].org ));</a>
<a name="ln245"> </a>
<a name="ln246">          FT_TRACE5(( &quot;\n&quot; ));</a>
<a name="ln247">        }</a>
<a name="ln248">#endif</a>
<a name="ln249">      }</a>
<a name="ln250">    }</a>
<a name="ln251"> </a>
<a name="ln252">    FT_TRACE5(( &quot;\n&quot; ));</a>
<a name="ln253"> </a>
<a name="ln254">    af_glyph_hints_done( hints );</a>
<a name="ln255">  }</a>
<a name="ln256"> </a>
<a name="ln257"> </a>
<a name="ln258">  /* Find all blue zones.  Flat segments give the reference points, */</a>
<a name="ln259">  /* round segments the overshoot positions.                        */</a>
<a name="ln260"> </a>
<a name="ln261">  static void</a>
<a name="ln262">  af_latin_metrics_init_blues( AF_LatinMetrics  metrics,</a>
<a name="ln263">                               FT_Face          face )</a>
<a name="ln264">  {</a>
<a name="ln265">    FT_Pos        flats [AF_BLUE_STRING_MAX_LEN];</a>
<a name="ln266">    FT_Pos        rounds[AF_BLUE_STRING_MAX_LEN];</a>
<a name="ln267"> </a>
<a name="ln268">    FT_UInt       num_flats;</a>
<a name="ln269">    FT_UInt       num_rounds;</a>
<a name="ln270"> </a>
<a name="ln271">    AF_LatinBlue  blue;</a>
<a name="ln272">    FT_Error      error;</a>
<a name="ln273">    AF_LatinAxis  axis = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];</a>
<a name="ln274">    FT_Outline    outline;</a>
<a name="ln275"> </a>
<a name="ln276">    AF_StyleClass  sc = metrics-&gt;root.style_class;</a>
<a name="ln277"> </a>
<a name="ln278">    AF_Blue_Stringset         bss = sc-&gt;blue_stringset;</a>
<a name="ln279">    const AF_Blue_StringRec*  bs  = &amp;af_blue_stringsets[bss];</a>
<a name="ln280"> </a>
<a name="ln281">    FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics-&gt;units_per_em );</a>
<a name="ln282"> </a>
<a name="ln283"> </a>
<a name="ln284">    /* we walk over the blue character strings as specified in the */</a>
<a name="ln285">    /* style's entry in the `af_blue_stringset' array              */</a>
<a name="ln286"> </a>
<a name="ln287">    FT_TRACE5(( &quot;latin blue zones computation\n&quot;</a>
<a name="ln288">                &quot;============================\n&quot;</a>
<a name="ln289">                &quot;\n&quot; ));</a>
<a name="ln290"> </a>
<a name="ln291">    for ( ; bs-&gt;string != AF_BLUE_STRING_MAX; bs++ )</a>
<a name="ln292">    {</a>
<a name="ln293">      const char*  p = &amp;af_blue_strings[bs-&gt;string];</a>
<a name="ln294">      FT_Pos*      blue_ref;</a>
<a name="ln295">      FT_Pos*      blue_shoot;</a>
<a name="ln296"> </a>
<a name="ln297"> </a>
<a name="ln298">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln299">      {</a>
<a name="ln300">        FT_Bool  have_flag = 0;</a>
<a name="ln301"> </a>
<a name="ln302"> </a>
<a name="ln303">        FT_TRACE5(( &quot;blue zone %d&quot;, axis-&gt;blue_count ));</a>
<a name="ln304"> </a>
<a name="ln305">        if ( bs-&gt;properties )</a>
<a name="ln306">        {</a>
<a name="ln307">          FT_TRACE5(( &quot; (&quot; ));</a>
<a name="ln308"> </a>
<a name="ln309">          if ( AF_LATIN_IS_TOP_BLUE( bs ) )</a>
<a name="ln310">          {</a>
<a name="ln311">            FT_TRACE5(( &quot;top&quot; ));</a>
<a name="ln312">            have_flag = 1;</a>
<a name="ln313">          }</a>
<a name="ln314"> </a>
<a name="ln315">          if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )</a>
<a name="ln316">          {</a>
<a name="ln317">            if ( have_flag )</a>
<a name="ln318">              FT_TRACE5(( &quot;, &quot; ));</a>
<a name="ln319">            FT_TRACE5(( &quot;neutral&quot; ));</a>
<a name="ln320">            have_flag = 1;</a>
<a name="ln321">          }</a>
<a name="ln322"> </a>
<a name="ln323">          if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )</a>
<a name="ln324">          {</a>
<a name="ln325">            if ( have_flag )</a>
<a name="ln326">              FT_TRACE5(( &quot;, &quot; ));</a>
<a name="ln327">            FT_TRACE5(( &quot;small top&quot; ));</a>
<a name="ln328">            have_flag = 1;</a>
<a name="ln329">          }</a>
<a name="ln330"> </a>
<a name="ln331">          if ( AF_LATIN_IS_LONG_BLUE( bs ) )</a>
<a name="ln332">          {</a>
<a name="ln333">            if ( have_flag )</a>
<a name="ln334">              FT_TRACE5(( &quot;, &quot; ));</a>
<a name="ln335">            FT_TRACE5(( &quot;long&quot; ));</a>
<a name="ln336">          }</a>
<a name="ln337"> </a>
<a name="ln338">          FT_TRACE5(( &quot;)&quot; ));</a>
<a name="ln339">        }</a>
<a name="ln340"> </a>
<a name="ln341">        FT_TRACE5(( &quot;:\n&quot; ));</a>
<a name="ln342">      }</a>
<a name="ln343">#endif /* FT_DEBUG_LEVEL_TRACE */</a>
<a name="ln344"> </a>
<a name="ln345">      num_flats  = 0;</a>
<a name="ln346">      num_rounds = 0;</a>
<a name="ln347"> </a>
<a name="ln348">      while ( *p )</a>
<a name="ln349">      {</a>
<a name="ln350">        FT_ULong    ch;</a>
<a name="ln351">        FT_ULong    glyph_index;</a>
<a name="ln352">        FT_Long     y_offset;</a>
<a name="ln353">        FT_Pos      best_y;                            /* same as points.y */</a>
<a name="ln354">        FT_Int      best_point, best_contour_first, best_contour_last;</a>
<a name="ln355">        FT_Vector*  points;</a>
<a name="ln356">        FT_Bool     round = 0;</a>
<a name="ln357"> </a>
<a name="ln358"> </a>
<a name="ln359">        GET_UTF8_CHAR( ch, p );</a>
<a name="ln360"> </a>
<a name="ln361">        /* load the character in the face -- skip unknown or empty ones */</a>
<a name="ln362">        af_get_char_index( &amp;metrics-&gt;root, ch, &amp;glyph_index, &amp;y_offset );</a>
<a name="ln363">        if ( glyph_index == 0 )</a>
<a name="ln364">        {</a>
<a name="ln365">          FT_TRACE5(( &quot;  U+%04lX unavailable\n&quot;, ch ));</a>
<a name="ln366">          continue;</a>
<a name="ln367">        }</a>
<a name="ln368"> </a>
<a name="ln369">        error   = FT_Load_Glyph( face, glyph_index, FT_LOAD_NO_SCALE );</a>
<a name="ln370">        outline = face-&gt;glyph-&gt;outline;</a>
<a name="ln371">        /* reject glyphs that don't produce any rendering */</a>
<a name="ln372">        if ( error || outline.n_points &lt;= 2 )</a>
<a name="ln373">        {</a>
<a name="ln374">          FT_TRACE5(( &quot;  U+%04lX contains no (usable) outlines\n&quot;, ch ));</a>
<a name="ln375">          continue;</a>
<a name="ln376">        }</a>
<a name="ln377"> </a>
<a name="ln378">        /* now compute min or max point indices and coordinates */</a>
<a name="ln379">        points             = outline.points;</a>
<a name="ln380">        best_point         = -1;</a>
<a name="ln381">        best_y             = 0;  /* make compiler happy */</a>
<a name="ln382">        best_contour_first = 0;  /* ditto */</a>
<a name="ln383">        best_contour_last  = 0;  /* ditto */</a>
<a name="ln384"> </a>
<a name="ln385">        {</a>
<a name="ln386">          FT_Int  nn;</a>
<a name="ln387">          FT_Int  first = 0;</a>
<a name="ln388">          FT_Int  last  = -1;</a>
<a name="ln389"> </a>
<a name="ln390"> </a>
<a name="ln391">          for ( nn = 0; nn &lt; outline.n_contours; first = last + 1, nn++ )</a>
<a name="ln392">          {</a>
<a name="ln393">            FT_Int  old_best_point = best_point;</a>
<a name="ln394">            FT_Int  pp;</a>
<a name="ln395"> </a>
<a name="ln396"> </a>
<a name="ln397">            last = outline.contours[nn];</a>
<a name="ln398"> </a>
<a name="ln399">            /* Avoid single-point contours since they are never rasterized. */</a>
<a name="ln400">            /* In some fonts, they correspond to mark attachment points     */</a>
<a name="ln401">            /* that are way outside of the glyph's real outline.            */</a>
<a name="ln402">            if ( last &lt;= first )</a>
<a name="ln403">              continue;</a>
<a name="ln404"> </a>
<a name="ln405">            if ( AF_LATIN_IS_TOP_BLUE( bs ) )</a>
<a name="ln406">            {</a>
<a name="ln407">              for ( pp = first; pp &lt;= last; pp++ )</a>
<a name="ln408">                if ( best_point &lt; 0 || points[pp].y &gt; best_y )</a>
<a name="ln409">                {</a>
<a name="ln410">                  best_point = pp;</a>
<a name="ln411">                  best_y     = points[pp].y;</a>
<a name="ln412">                }</a>
<a name="ln413">            }</a>
<a name="ln414">            else</a>
<a name="ln415">            {</a>
<a name="ln416">              for ( pp = first; pp &lt;= last; pp++ )</a>
<a name="ln417">                if ( best_point &lt; 0 || points[pp].y &lt; best_y )</a>
<a name="ln418">                {</a>
<a name="ln419">                  best_point = pp;</a>
<a name="ln420">                  best_y     = points[pp].y;</a>
<a name="ln421">                }</a>
<a name="ln422">            }</a>
<a name="ln423"> </a>
<a name="ln424">            if ( best_point != old_best_point )</a>
<a name="ln425">            {</a>
<a name="ln426">              best_contour_first = first;</a>
<a name="ln427">              best_contour_last  = last;</a>
<a name="ln428">            }</a>
<a name="ln429">          }</a>
<a name="ln430">        }</a>
<a name="ln431"> </a>
<a name="ln432">        /* now check whether the point belongs to a straight or round   */</a>
<a name="ln433">        /* segment; we first need to find in which contour the extremum */</a>
<a name="ln434">        /* lies, then inspect its previous and next points              */</a>
<a name="ln435">        if ( best_point &gt;= 0 )</a>
<a name="ln436">        {</a>
<a name="ln437">          FT_Pos  best_x = points[best_point].x;</a>
<a name="ln438">          FT_Int  prev, next;</a>
<a name="ln439">          FT_Int  best_segment_first, best_segment_last;</a>
<a name="ln440">          FT_Int  best_on_point_first, best_on_point_last;</a>
<a name="ln441">          FT_Pos  dist;</a>
<a name="ln442"> </a>
<a name="ln443"> </a>
<a name="ln444">          best_segment_first = best_point;</a>
<a name="ln445">          best_segment_last  = best_point;</a>
<a name="ln446"> </a>
<a name="ln447">          if ( FT_CURVE_TAG( outline.tags[best_point] ) == FT_CURVE_TAG_ON )</a>
<a name="ln448">          {</a>
<a name="ln449">            best_on_point_first = best_point;</a>
<a name="ln450">            best_on_point_last  = best_point;</a>
<a name="ln451">          }</a>
<a name="ln452">          else</a>
<a name="ln453">          {</a>
<a name="ln454">            best_on_point_first = -1;</a>
<a name="ln455">            best_on_point_last  = -1;</a>
<a name="ln456">          }</a>
<a name="ln457"> </a>
<a name="ln458">          /* look for the previous and next points on the contour  */</a>
<a name="ln459">          /* that are not on the same Y coordinate, then threshold */</a>
<a name="ln460">          /* the `closeness'...                                    */</a>
<a name="ln461">          prev = best_point;</a>
<a name="ln462">          next = prev;</a>
<a name="ln463"> </a>
<a name="ln464">          do</a>
<a name="ln465">          {</a>
<a name="ln466">            if ( prev &gt; best_contour_first )</a>
<a name="ln467">              prev--;</a>
<a name="ln468">            else</a>
<a name="ln469">              prev = best_contour_last;</a>
<a name="ln470"> </a>
<a name="ln471">            dist = FT_ABS( points[prev].y - best_y );</a>
<a name="ln472">            /* accept a small distance or a small angle (both values are */</a>
<a name="ln473">            /* heuristic; value 20 corresponds to approx. 2.9 degrees)   */</a>
<a name="ln474">            if ( dist &gt; 5 )</a>
<a name="ln475">              if ( FT_ABS( points[prev].x - best_x ) &lt;= 20 * dist )</a>
<a name="ln476">                break;</a>
<a name="ln477"> </a>
<a name="ln478">            best_segment_first = prev;</a>
<a name="ln479"> </a>
<a name="ln480">            if ( FT_CURVE_TAG( outline.tags[prev] ) == FT_CURVE_TAG_ON )</a>
<a name="ln481">            {</a>
<a name="ln482">              best_on_point_first = prev;</a>
<a name="ln483">              if ( best_on_point_last &lt; 0 )</a>
<a name="ln484">                best_on_point_last = prev;</a>
<a name="ln485">            }</a>
<a name="ln486"> </a>
<a name="ln487">          } while ( prev != best_point );</a>
<a name="ln488"> </a>
<a name="ln489">          do</a>
<a name="ln490">          {</a>
<a name="ln491">            if ( next &lt; best_contour_last )</a>
<a name="ln492">              next++;</a>
<a name="ln493">            else</a>
<a name="ln494">              next = best_contour_first;</a>
<a name="ln495"> </a>
<a name="ln496">            dist = FT_ABS( points[next].y - best_y );</a>
<a name="ln497">            if ( dist &gt; 5 )</a>
<a name="ln498">              if ( FT_ABS( points[next].x - best_x ) &lt;= 20 * dist )</a>
<a name="ln499">                break;</a>
<a name="ln500"> </a>
<a name="ln501">            best_segment_last = next;</a>
<a name="ln502"> </a>
<a name="ln503">            if ( FT_CURVE_TAG( outline.tags[next] ) == FT_CURVE_TAG_ON )</a>
<a name="ln504">            {</a>
<a name="ln505">              best_on_point_last = next;</a>
<a name="ln506">              if ( best_on_point_first &lt; 0 )</a>
<a name="ln507">                best_on_point_first = next;</a>
<a name="ln508">            }</a>
<a name="ln509"> </a>
<a name="ln510">          } while ( next != best_point );</a>
<a name="ln511"> </a>
<a name="ln512">          if ( AF_LATIN_IS_LONG_BLUE( bs ) )</a>
<a name="ln513">          {</a>
<a name="ln514">            /* If this flag is set, we have an additional constraint to  */</a>
<a name="ln515">            /* get the blue zone distance: Find a segment of the topmost */</a>
<a name="ln516">            /* (or bottommost) contour that is longer than a heuristic   */</a>
<a name="ln517">            /* threshold.  This ensures that small bumps in the outline  */</a>
<a name="ln518">            /* are ignored (for example, the `vertical serifs' found in  */</a>
<a name="ln519">            /* many Hebrew glyph designs).                               */</a>
<a name="ln520"> </a>
<a name="ln521">            /* If this segment is long enough, we are done.  Otherwise,  */</a>
<a name="ln522">            /* search the segment next to the extremum that is long      */</a>
<a name="ln523">            /* enough, has the same direction, and a not too large       */</a>
<a name="ln524">            /* vertical distance from the extremum.  Note that the       */</a>
<a name="ln525">            /* algorithm doesn't check whether the found segment is      */</a>
<a name="ln526">            /* actually the one (vertically) nearest to the extremum.    */</a>
<a name="ln527"> </a>
<a name="ln528">            /* heuristic threshold value */</a>
<a name="ln529">            FT_Pos  length_threshold = metrics-&gt;units_per_em / 25;</a>
<a name="ln530"> </a>
<a name="ln531"> </a>
<a name="ln532">            dist = FT_ABS( points[best_segment_last].x -</a>
<a name="ln533">                             points[best_segment_first].x );</a>
<a name="ln534"> </a>
<a name="ln535">            if ( dist &lt; length_threshold                       &amp;&amp;</a>
<a name="ln536">                 best_segment_last - best_segment_first + 2 &lt;=</a>
<a name="ln537">                   best_contour_last - best_contour_first      )</a>
<a name="ln538">            {</a>
<a name="ln539">              /* heuristic threshold value */</a>
<a name="ln540">              FT_Pos  height_threshold = metrics-&gt;units_per_em / 4;</a>
<a name="ln541"> </a>
<a name="ln542">              FT_Int   first;</a>
<a name="ln543">              FT_Int   last;</a>
<a name="ln544">              FT_Bool  hit;</a>
<a name="ln545"> </a>
<a name="ln546">              /* we intentionally declare these two variables        */</a>
<a name="ln547">              /* outside of the loop since various compilers emit    */</a>
<a name="ln548">              /* incorrect warning messages otherwise, talking about */</a>
<a name="ln549">              /* `possibly uninitialized variables'                  */</a>
<a name="ln550">              FT_Int  p_first = 0;            /* make compiler happy */</a>
<a name="ln551">              FT_Int  p_last  = 0;</a>
<a name="ln552"> </a>
<a name="ln553">              FT_Bool  left2right;</a>
<a name="ln554"> </a>
<a name="ln555"> </a>
<a name="ln556">              /* compute direction */</a>
<a name="ln557">              prev = best_point;</a>
<a name="ln558"> </a>
<a name="ln559">              do</a>
<a name="ln560">              {</a>
<a name="ln561">                if ( prev &gt; best_contour_first )</a>
<a name="ln562">                  prev--;</a>
<a name="ln563">                else</a>
<a name="ln564">                  prev = best_contour_last;</a>
<a name="ln565"> </a>
<a name="ln566">                if ( points[prev].x != best_x )</a>
<a name="ln567">                  break;</a>
<a name="ln568"> </a>
<a name="ln569">              } while ( prev != best_point );</a>
<a name="ln570"> </a>
<a name="ln571">              /* skip glyph for the degenerate case */</a>
<a name="ln572">              if ( prev == best_point )</a>
<a name="ln573">                continue;</a>
<a name="ln574"> </a>
<a name="ln575">              left2right = FT_BOOL( points[prev].x &lt; points[best_point].x );</a>
<a name="ln576"> </a>
<a name="ln577">              first = best_segment_last;</a>
<a name="ln578">              last  = first;</a>
<a name="ln579">              hit   = 0;</a>
<a name="ln580"> </a>
<a name="ln581">              do</a>
<a name="ln582">              {</a>
<a name="ln583">                FT_Bool  l2r;</a>
<a name="ln584">                FT_Pos   d;</a>
<a name="ln585"> </a>
<a name="ln586"> </a>
<a name="ln587">                if ( !hit )</a>
<a name="ln588">                {</a>
<a name="ln589">                  /* no hit; adjust first point */</a>
<a name="ln590">                  first = last;</a>
<a name="ln591"> </a>
<a name="ln592">                  /* also adjust first and last on point */</a>
<a name="ln593">                  if ( FT_CURVE_TAG( outline.tags[first] ) ==</a>
<a name="ln594">                         FT_CURVE_TAG_ON )</a>
<a name="ln595">                  {</a>
<a name="ln596">                    p_first = first;</a>
<a name="ln597">                    p_last  = first;</a>
<a name="ln598">                  }</a>
<a name="ln599">                  else</a>
<a name="ln600">                  {</a>
<a name="ln601">                    p_first = -1;</a>
<a name="ln602">                    p_last  = -1;</a>
<a name="ln603">                  }</a>
<a name="ln604"> </a>
<a name="ln605">                  hit = 1;</a>
<a name="ln606">                }</a>
<a name="ln607"> </a>
<a name="ln608">                if ( last &lt; best_contour_last )</a>
<a name="ln609">                  last++;</a>
<a name="ln610">                else</a>
<a name="ln611">                  last = best_contour_first;</a>
<a name="ln612"> </a>
<a name="ln613">                if ( FT_ABS( best_y - points[first].y ) &gt; height_threshold )</a>
<a name="ln614">                {</a>
<a name="ln615">                  /* vertical distance too large */</a>
<a name="ln616">                  hit = 0;</a>
<a name="ln617">                  continue;</a>
<a name="ln618">                }</a>
<a name="ln619"> </a>
<a name="ln620">                /* same test as above */</a>
<a name="ln621">                dist = FT_ABS( points[last].y - points[first].y );</a>
<a name="ln622">                if ( dist &gt; 5 )</a>
<a name="ln623">                  if ( FT_ABS( points[last].x - points[first].x ) &lt;=</a>
<a name="ln624">                         20 * dist )</a>
<a name="ln625">                  {</a>
<a name="ln626">                    hit = 0;</a>
<a name="ln627">                    continue;</a>
<a name="ln628">                  }</a>
<a name="ln629"> </a>
<a name="ln630">                if ( FT_CURVE_TAG( outline.tags[last] ) == FT_CURVE_TAG_ON )</a>
<a name="ln631">                {</a>
<a name="ln632">                  p_last = last;</a>
<a name="ln633">                  if ( p_first &lt; 0 )</a>
<a name="ln634">                    p_first = last;</a>
<a name="ln635">                }</a>
<a name="ln636"> </a>
<a name="ln637">                l2r = FT_BOOL( points[first].x &lt; points[last].x );</a>
<a name="ln638">                d   = FT_ABS( points[last].x - points[first].x );</a>
<a name="ln639"> </a>
<a name="ln640">                if ( l2r == left2right     &amp;&amp;</a>
<a name="ln641">                     d &gt;= length_threshold )</a>
<a name="ln642">                {</a>
<a name="ln643">                  /* all constraints are met; update segment after finding */</a>
<a name="ln644">                  /* its end                                               */</a>
<a name="ln645">                  do</a>
<a name="ln646">                  {</a>
<a name="ln647">                    if ( last &lt; best_contour_last )</a>
<a name="ln648">                      last++;</a>
<a name="ln649">                    else</a>
<a name="ln650">                      last = best_contour_first;</a>
<a name="ln651"> </a>
<a name="ln652">                    d = FT_ABS( points[last].y - points[first].y );</a>
<a name="ln653">                    if ( d &gt; 5 )</a>
<a name="ln654">                      if ( FT_ABS( points[next].x - points[first].x ) &lt;=</a>
<a name="ln655">                             20 * dist )</a>
<a name="ln656">                      {</a>
<a name="ln657">                        if ( last &gt; best_contour_first )</a>
<a name="ln658">                          last--;</a>
<a name="ln659">                        else</a>
<a name="ln660">                          last = best_contour_last;</a>
<a name="ln661">                        break;</a>
<a name="ln662">                      }</a>
<a name="ln663"> </a>
<a name="ln664">                    p_last = last;</a>
<a name="ln665"> </a>
<a name="ln666">                    if ( FT_CURVE_TAG( outline.tags[last] ) ==</a>
<a name="ln667">                           FT_CURVE_TAG_ON )</a>
<a name="ln668">                    {</a>
<a name="ln669">                      p_last = last;</a>
<a name="ln670">                      if ( p_first &lt; 0 )</a>
<a name="ln671">                        p_first = last;</a>
<a name="ln672">                    }</a>
<a name="ln673"> </a>
<a name="ln674">                  } while ( last != best_segment_first );</a>
<a name="ln675"> </a>
<a name="ln676">                  best_y = points[first].y;</a>
<a name="ln677"> </a>
<a name="ln678">                  best_segment_first = first;</a>
<a name="ln679">                  best_segment_last  = last;</a>
<a name="ln680"> </a>
<a name="ln681">                  best_on_point_first = p_first;</a>
<a name="ln682">                  best_on_point_last  = p_last;</a>
<a name="ln683"> </a>
<a name="ln684">                  break;</a>
<a name="ln685">                }</a>
<a name="ln686"> </a>
<a name="ln687">              } while ( last != best_segment_first );</a>
<a name="ln688">            }</a>
<a name="ln689">          }</a>
<a name="ln690"> </a>
<a name="ln691">          /* for computing blue zones, we add the y offset as returned */</a>
<a name="ln692">          /* by the currently used OpenType feature -- for example,    */</a>
<a name="ln693">          /* superscript glyphs might be identical to subscript glyphs */</a>
<a name="ln694">          /* with a vertical shift                                     */</a>
<a name="ln695">          best_y += y_offset;</a>
<a name="ln696"> </a>
<a name="ln697">          FT_TRACE5(( &quot;  U+%04lX: best_y = %5ld&quot;, ch, best_y ));</a>
<a name="ln698"> </a>
<a name="ln699">          /* now set the `round' flag depending on the segment's kind: */</a>
<a name="ln700">          /*                                                           */</a>
<a name="ln701">          /* - if the horizontal distance between the first and last   */</a>
<a name="ln702">          /*   `on' point is larger than a heuristic threshold         */</a>
<a name="ln703">          /*   we have a flat segment                                  */</a>
<a name="ln704">          /* - if either the first or the last point of the segment is */</a>
<a name="ln705">          /*   an `off' point, the segment is round, otherwise it is   */</a>
<a name="ln706">          /*   flat                                                    */</a>
<a name="ln707">          if ( best_on_point_first &gt;= 0                               &amp;&amp;</a>
<a name="ln708">               best_on_point_last &gt;= 0                                &amp;&amp;</a>
<a name="ln709">               ( FT_ABS( points[best_on_point_last].x -</a>
<a name="ln710">                         points[best_on_point_first].x ) ) &gt;</a>
<a name="ln711">                 flat_threshold                                       )</a>
<a name="ln712">            round = 0;</a>
<a name="ln713">          else</a>
<a name="ln714">            round = FT_BOOL(</a>
<a name="ln715">                      FT_CURVE_TAG( outline.tags[best_segment_first] ) !=</a>
<a name="ln716">                        FT_CURVE_TAG_ON                                   ||</a>
<a name="ln717">                      FT_CURVE_TAG( outline.tags[best_segment_last]  ) !=</a>
<a name="ln718">                        FT_CURVE_TAG_ON                                   );</a>
<a name="ln719"> </a>
<a name="ln720">          if ( round &amp;&amp; AF_LATIN_IS_NEUTRAL_BLUE( bs ) )</a>
<a name="ln721">          {</a>
<a name="ln722">            /* only use flat segments for a neutral blue zone */</a>
<a name="ln723">            FT_TRACE5(( &quot; (round, skipped)\n&quot; ));</a>
<a name="ln724">            continue;</a>
<a name="ln725">          }</a>
<a name="ln726"> </a>
<a name="ln727">          FT_TRACE5(( &quot; (%s)\n&quot;, round ? &quot;round&quot; : &quot;flat&quot; ));</a>
<a name="ln728">        }</a>
<a name="ln729"> </a>
<a name="ln730">        if ( round )</a>
<a name="ln731">          rounds[num_rounds++] = best_y;</a>
<a name="ln732">        else</a>
<a name="ln733">          flats[num_flats++]   = best_y;</a>
<a name="ln734">      }</a>
<a name="ln735"> </a>
<a name="ln736">      if ( num_flats == 0 &amp;&amp; num_rounds == 0 )</a>
<a name="ln737">      {</a>
<a name="ln738">        /*</a>
<a name="ln739">         *  we couldn't find a single glyph to compute this blue zone,</a>
<a name="ln740">         *  we will simply ignore it then</a>
<a name="ln741">         */</a>
<a name="ln742">        FT_TRACE5(( &quot;  empty\n&quot; ));</a>
<a name="ln743">        continue;</a>
<a name="ln744">      }</a>
<a name="ln745"> </a>
<a name="ln746">      /* we have computed the contents of the `rounds' and `flats' tables, */</a>
<a name="ln747">      /* now determine the reference and overshoot position of the blue -- */</a>
<a name="ln748">      /* we simply take the median value after a simple sort               */</a>
<a name="ln749">      af_sort_pos( num_rounds, rounds );</a>
<a name="ln750">      af_sort_pos( num_flats,  flats );</a>
<a name="ln751"> </a>
<a name="ln752">      blue       = &amp;axis-&gt;blues[axis-&gt;blue_count];</a>
<a name="ln753">      blue_ref   = &amp;blue-&gt;ref.org;</a>
<a name="ln754">      blue_shoot = &amp;blue-&gt;shoot.org;</a>
<a name="ln755"> </a>
<a name="ln756">      axis-&gt;blue_count++;</a>
<a name="ln757"> </a>
<a name="ln758">      if ( num_flats == 0 )</a>
<a name="ln759">      {</a>
<a name="ln760">        *blue_ref   =</a>
<a name="ln761">        *blue_shoot = rounds[num_rounds / 2];</a>
<a name="ln762">      }</a>
<a name="ln763">      else if ( num_rounds == 0 )</a>
<a name="ln764">      {</a>
<a name="ln765">        *blue_ref   =</a>
<a name="ln766">        *blue_shoot = flats[num_flats / 2];</a>
<a name="ln767">      }</a>
<a name="ln768">      else</a>
<a name="ln769">      {</a>
<a name="ln770">        *blue_ref   = flats [num_flats  / 2];</a>
<a name="ln771">        *blue_shoot = rounds[num_rounds / 2];</a>
<a name="ln772">      }</a>
<a name="ln773"> </a>
<a name="ln774">      /* there are sometimes problems: if the overshoot position of top     */</a>
<a name="ln775">      /* zones is under its reference position, or the opposite for bottom  */</a>
<a name="ln776">      /* zones.  We must thus check everything there and correct the errors */</a>
<a name="ln777">      if ( *blue_shoot != *blue_ref )</a>
<a name="ln778">      {</a>
<a name="ln779">        FT_Pos   ref      = *blue_ref;</a>
<a name="ln780">        FT_Pos   shoot    = *blue_shoot;</a>
<a name="ln781">        FT_Bool  over_ref = FT_BOOL( shoot &gt; ref );</a>
<a name="ln782"> </a>
<a name="ln783"> </a>
<a name="ln784">        if ( AF_LATIN_IS_TOP_BLUE( bs ) ^ over_ref )</a>
<a name="ln785">        {</a>
<a name="ln786">          *blue_ref   =</a>
<a name="ln787">          *blue_shoot = ( shoot + ref ) / 2;</a>
<a name="ln788"> </a>
<a name="ln789">          FT_TRACE5(( &quot;  [overshoot smaller than reference,&quot;</a>
<a name="ln790">                      &quot; taking mean value]\n&quot; ));</a>
<a name="ln791">        }</a>
<a name="ln792">      }</a>
<a name="ln793"> </a>
<a name="ln794">      blue-&gt;flags = 0;</a>
<a name="ln795">      if ( AF_LATIN_IS_TOP_BLUE( bs ) )</a>
<a name="ln796">        blue-&gt;flags |= AF_LATIN_BLUE_TOP;</a>
<a name="ln797">      if ( AF_LATIN_IS_NEUTRAL_BLUE( bs ) )</a>
<a name="ln798">        blue-&gt;flags |= AF_LATIN_BLUE_NEUTRAL;</a>
<a name="ln799"> </a>
<a name="ln800">      /*</a>
<a name="ln801">       * The following flag is used later to adjust the y and x scales</a>
<a name="ln802">       * in order to optimize the pixel grid alignment of the top of small</a>
<a name="ln803">       * letters.</a>
<a name="ln804">       */</a>
<a name="ln805">      if ( AF_LATIN_IS_X_HEIGHT_BLUE( bs ) )</a>
<a name="ln806">        blue-&gt;flags |= AF_LATIN_BLUE_ADJUSTMENT;</a>
<a name="ln807"> </a>
<a name="ln808">      FT_TRACE5(( &quot;    -&gt; reference = %ld\n&quot;</a>
<a name="ln809">                  &quot;       overshoot = %ld\n&quot;,</a>
<a name="ln810">                  *blue_ref, *blue_shoot ));</a>
<a name="ln811">    }</a>
<a name="ln812"> </a>
<a name="ln813">    FT_TRACE5(( &quot;\n&quot; ));</a>
<a name="ln814"> </a>
<a name="ln815">    return;</a>
<a name="ln816">  }</a>
<a name="ln817"> </a>
<a name="ln818"> </a>
<a name="ln819">  /* Check whether all ASCII digits have the same advance width. */</a>
<a name="ln820"> </a>
<a name="ln821">  FT_LOCAL_DEF( void )</a>
<a name="ln822">  af_latin_metrics_check_digits( AF_LatinMetrics  metrics,</a>
<a name="ln823">                                 FT_Face          face )</a>
<a name="ln824">  {</a>
<a name="ln825">    FT_UInt   i;</a>
<a name="ln826">    FT_Bool   started = 0, same_width = 1;</a>
<a name="ln827">    FT_Fixed  advance, old_advance = 0;</a>
<a name="ln828"> </a>
<a name="ln829"> </a>
<a name="ln830">    /* digit `0' is 0x30 in all supported charmaps */</a>
<a name="ln831">    for ( i = 0x30; i &lt;= 0x39; i++ )</a>
<a name="ln832">    {</a>
<a name="ln833">      FT_ULong  glyph_index;</a>
<a name="ln834">      FT_Long   y_offset;</a>
<a name="ln835"> </a>
<a name="ln836"> </a>
<a name="ln837">      af_get_char_index( &amp;metrics-&gt;root, i, &amp;glyph_index, &amp;y_offset );</a>
<a name="ln838">      if ( glyph_index == 0 )</a>
<a name="ln839">        continue;</a>
<a name="ln840"> </a>
<a name="ln841">      if ( FT_Get_Advance( face, glyph_index,</a>
<a name="ln842">                           FT_LOAD_NO_SCALE         |</a>
<a name="ln843">                           FT_LOAD_NO_HINTING       |</a>
<a name="ln844">                           FT_LOAD_IGNORE_TRANSFORM,</a>
<a name="ln845">                           &amp;advance ) )</a>
<a name="ln846">        continue;</a>
<a name="ln847"> </a>
<a name="ln848">      if ( started )</a>
<a name="ln849">      {</a>
<a name="ln850">        if ( advance != old_advance )</a>
<a name="ln851">        {</a>
<a name="ln852">          same_width = 0;</a>
<a name="ln853">          break;</a>
<a name="ln854">        }</a>
<a name="ln855">      }</a>
<a name="ln856">      else</a>
<a name="ln857">      {</a>
<a name="ln858">        old_advance = advance;</a>
<a name="ln859">        started     = 1;</a>
<a name="ln860">      }</a>
<a name="ln861">    }</a>
<a name="ln862"> </a>
<a name="ln863">    metrics-&gt;root.digits_have_same_width = same_width;</a>
<a name="ln864">  }</a>
<a name="ln865"> </a>
<a name="ln866"> </a>
<a name="ln867">  /* Initialize global metrics. */</a>
<a name="ln868"> </a>
<a name="ln869">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln870">  af_latin_metrics_init( AF_LatinMetrics  metrics,</a>
<a name="ln871">                         FT_Face          face )</a>
<a name="ln872">  {</a>
<a name="ln873">    FT_CharMap  oldmap = face-&gt;charmap;</a>
<a name="ln874"> </a>
<a name="ln875"> </a>
<a name="ln876">    metrics-&gt;units_per_em = face-&gt;units_per_EM;</a>
<a name="ln877"> </a>
<a name="ln878">    if ( !FT_Select_Charmap( face, FT_ENCODING_UNICODE ) )</a>
<a name="ln879">    {</a>
<a name="ln880">      af_latin_metrics_init_widths( metrics, face );</a>
<a name="ln881">      af_latin_metrics_init_blues( metrics, face );</a>
<a name="ln882">      af_latin_metrics_check_digits( metrics, face );</a>
<a name="ln883">    }</a>
<a name="ln884"> </a>
<a name="ln885">    FT_Set_Charmap( face, oldmap );</a>
<a name="ln886">    return FT_Err_Ok;</a>
<a name="ln887">  }</a>
<a name="ln888"> </a>
<a name="ln889"> </a>
<a name="ln890">  /* Adjust scaling value, then scale and shift widths   */</a>
<a name="ln891">  /* and blue zones (if applicable) for given dimension. */</a>
<a name="ln892"> </a>
<a name="ln893">  static void</a>
<a name="ln894">  af_latin_metrics_scale_dim( AF_LatinMetrics  metrics,</a>
<a name="ln895">                              AF_Scaler        scaler,</a>
<a name="ln896">                              AF_Dimension     dim )</a>
<a name="ln897">  {</a>
<a name="ln898">    FT_Fixed      scale;</a>
<a name="ln899">    FT_Pos        delta;</a>
<a name="ln900">    AF_LatinAxis  axis;</a>
<a name="ln901">    FT_UInt       nn;</a>
<a name="ln902"> </a>
<a name="ln903"> </a>
<a name="ln904">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln905">    {</a>
<a name="ln906">      scale = scaler-&gt;x_scale;</a>
<a name="ln907">      delta = scaler-&gt;x_delta;</a>
<a name="ln908">    }</a>
<a name="ln909">    else</a>
<a name="ln910">    {</a>
<a name="ln911">      scale = scaler-&gt;y_scale;</a>
<a name="ln912">      delta = scaler-&gt;y_delta;</a>
<a name="ln913">    }</a>
<a name="ln914"> </a>
<a name="ln915">    axis = &amp;metrics-&gt;axis[dim];</a>
<a name="ln916"> </a>
<a name="ln917">    if ( axis-&gt;org_scale == scale &amp;&amp; axis-&gt;org_delta == delta )</a>
<a name="ln918">      return;</a>
<a name="ln919"> </a>
<a name="ln920">    axis-&gt;org_scale = scale;</a>
<a name="ln921">    axis-&gt;org_delta = delta;</a>
<a name="ln922"> </a>
<a name="ln923">    /*</a>
<a name="ln924">     * correct X and Y scale to optimize the alignment of the top of small</a>
<a name="ln925">     * letters to the pixel grid</a>
<a name="ln926">     */</a>
<a name="ln927">    {</a>
<a name="ln928">      AF_LatinAxis  Axis = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];</a>
<a name="ln929">      AF_LatinBlue  blue = NULL;</a>
<a name="ln930"> </a>
<a name="ln931"> </a>
<a name="ln932">      for ( nn = 0; nn &lt; Axis-&gt;blue_count; nn++ )</a>
<a name="ln933">      {</a>
<a name="ln934">        if ( Axis-&gt;blues[nn].flags &amp; AF_LATIN_BLUE_ADJUSTMENT )</a>
<a name="ln935">        {</a>
<a name="ln936">          blue = &amp;Axis-&gt;blues[nn];</a>
<a name="ln937">          break;</a>
<a name="ln938">        }</a>
<a name="ln939">      }</a>
<a name="ln940"> </a>
<a name="ln941">      if ( blue )</a>
<a name="ln942">      {</a>
<a name="ln943">        FT_Pos   scaled;</a>
<a name="ln944">        FT_Pos   threshold;</a>
<a name="ln945">        FT_Pos   fitted;</a>
<a name="ln946">        FT_UInt  limit;</a>
<a name="ln947">        FT_UInt  ppem;</a>
<a name="ln948"> </a>
<a name="ln949"> </a>
<a name="ln950">        scaled    = FT_MulFix( blue-&gt;shoot.org, scaler-&gt;y_scale );</a>
<a name="ln951">        ppem      = metrics-&gt;root.scaler.face-&gt;size-&gt;metrics.x_ppem;</a>
<a name="ln952">        limit     = metrics-&gt;root.globals-&gt;increase_x_height;</a>
<a name="ln953">        threshold = 40;</a>
<a name="ln954"> </a>
<a name="ln955">        /* if the `increase-x-height' property is active, */</a>
<a name="ln956">        /* we round up much more often                    */</a>
<a name="ln957">        if ( limit                                 &amp;&amp;</a>
<a name="ln958">             ppem &lt;= limit                         &amp;&amp;</a>
<a name="ln959">             ppem &gt;= AF_PROP_INCREASE_X_HEIGHT_MIN )</a>
<a name="ln960">          threshold = 52;</a>
<a name="ln961"> </a>
<a name="ln962">        fitted = ( scaled + threshold ) &amp; ~63;</a>
<a name="ln963"> </a>
<a name="ln964">        if ( scaled != fitted )</a>
<a name="ln965">        {</a>
<a name="ln966">#if 0</a>
<a name="ln967">          if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln968">          {</a>
<a name="ln969">            if ( fitted &lt; scaled )</a>
<a name="ln970">              scale -= scale / 50;  /* scale *= 0.98 */</a>
<a name="ln971">          }</a>
<a name="ln972">          else</a>
<a name="ln973">#endif</a>
<a name="ln974">          if ( dim == AF_DIMENSION_VERT )</a>
<a name="ln975">          {</a>
<a name="ln976">            scale = FT_MulDiv( scale, fitted, scaled );</a>
<a name="ln977"> </a>
<a name="ln978">            FT_TRACE5((</a>
<a name="ln979">              &quot;af_latin_metrics_scale_dim:&quot;</a>
<a name="ln980">              &quot; x height alignment (style `%s'):\n&quot;</a>
<a name="ln981">              &quot;                           &quot;</a>
<a name="ln982">              &quot; vertical scaling changed from %.4f to %.4f (by %d%%)\n&quot;</a>
<a name="ln983">              &quot;\n&quot;,</a>
<a name="ln984">              af_style_names[metrics-&gt;root.style_class-&gt;style],</a>
<a name="ln985">              axis-&gt;org_scale / 65536.0,</a>
<a name="ln986">              scale / 65536.0,</a>
<a name="ln987">              ( fitted - scaled ) * 100 / scaled ));</a>
<a name="ln988">          }</a>
<a name="ln989">        }</a>
<a name="ln990">      }</a>
<a name="ln991">    }</a>
<a name="ln992"> </a>
<a name="ln993">    axis-&gt;scale = scale;</a>
<a name="ln994">    axis-&gt;delta = delta;</a>
<a name="ln995"> </a>
<a name="ln996">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln997">    {</a>
<a name="ln998">      metrics-&gt;root.scaler.x_scale = scale;</a>
<a name="ln999">      metrics-&gt;root.scaler.x_delta = delta;</a>
<a name="ln1000">    }</a>
<a name="ln1001">    else</a>
<a name="ln1002">    {</a>
<a name="ln1003">      metrics-&gt;root.scaler.y_scale = scale;</a>
<a name="ln1004">      metrics-&gt;root.scaler.y_delta = delta;</a>
<a name="ln1005">    }</a>
<a name="ln1006"> </a>
<a name="ln1007">    FT_TRACE5(( &quot;%s widths (style `%s')\n&quot;,</a>
<a name="ln1008">                dim == AF_DIMENSION_HORZ ? &quot;horizontal&quot; : &quot;vertical&quot;,</a>
<a name="ln1009">                af_style_names[metrics-&gt;root.style_class-&gt;style] ));</a>
<a name="ln1010"> </a>
<a name="ln1011">    /* scale the widths */</a>
<a name="ln1012">    for ( nn = 0; nn &lt; axis-&gt;width_count; nn++ )</a>
<a name="ln1013">    {</a>
<a name="ln1014">      AF_Width  width = axis-&gt;widths + nn;</a>
<a name="ln1015"> </a>
<a name="ln1016"> </a>
<a name="ln1017">      width-&gt;cur = FT_MulFix( width-&gt;org, scale );</a>
<a name="ln1018">      width-&gt;fit = width-&gt;cur;</a>
<a name="ln1019"> </a>
<a name="ln1020">      FT_TRACE5(( &quot;  %d scaled to %.2f\n&quot;,</a>
<a name="ln1021">                  width-&gt;org,</a>
<a name="ln1022">                  width-&gt;cur / 64.0 ));</a>
<a name="ln1023">    }</a>
<a name="ln1024"> </a>
<a name="ln1025">    FT_TRACE5(( &quot;\n&quot; ));</a>
<a name="ln1026"> </a>
<a name="ln1027">    /* an extra-light axis corresponds to a standard width that is */</a>
<a name="ln1028">    /* smaller than 5/8 pixels                                     */</a>
<a name="ln1029">    axis-&gt;extra_light =</a>
<a name="ln1030">      (FT_Bool)( FT_MulFix( axis-&gt;standard_width, scale ) &lt; 32 + 8 );</a>
<a name="ln1031"> </a>
<a name="ln1032">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln1033">    if ( axis-&gt;extra_light )</a>
<a name="ln1034">      FT_TRACE5(( &quot;`%s' style is extra light (at current resolution)\n&quot;</a>
<a name="ln1035">                  &quot;\n&quot;,</a>
<a name="ln1036">                  af_style_names[metrics-&gt;root.style_class-&gt;style] ));</a>
<a name="ln1037">#endif</a>
<a name="ln1038"> </a>
<a name="ln1039">    if ( dim == AF_DIMENSION_VERT )</a>
<a name="ln1040">    {</a>
<a name="ln1041">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln1042">      if ( axis-&gt;blue_count )</a>
<a name="ln1043">        FT_TRACE5(( &quot;blue zones (style `%s')\n&quot;,</a>
<a name="ln1044">                    af_style_names[metrics-&gt;root.style_class-&gt;style] ));</a>
<a name="ln1045">#endif</a>
<a name="ln1046"> </a>
<a name="ln1047">      /* scale the blue zones */</a>
<a name="ln1048">      for ( nn = 0; nn &lt; axis-&gt;blue_count; nn++ )</a>
<a name="ln1049">      {</a>
<a name="ln1050">        AF_LatinBlue  blue = &amp;axis-&gt;blues[nn];</a>
<a name="ln1051">        FT_Pos        dist;</a>
<a name="ln1052"> </a>
<a name="ln1053"> </a>
<a name="ln1054">        blue-&gt;ref.cur   = FT_MulFix( blue-&gt;ref.org, scale ) + delta;</a>
<a name="ln1055">        blue-&gt;ref.fit   = blue-&gt;ref.cur;</a>
<a name="ln1056">        blue-&gt;shoot.cur = FT_MulFix( blue-&gt;shoot.org, scale ) + delta;</a>
<a name="ln1057">        blue-&gt;shoot.fit = blue-&gt;shoot.cur;</a>
<a name="ln1058">        blue-&gt;flags    &amp;= ~AF_LATIN_BLUE_ACTIVE;</a>
<a name="ln1059"> </a>
<a name="ln1060">        /* a blue zone is only active if it is less than 3/4 pixels tall */</a>
<a name="ln1061">        dist = FT_MulFix( blue-&gt;ref.org - blue-&gt;shoot.org, scale );</a>
<a name="ln1062">        if ( dist &lt;= 48 &amp;&amp; dist &gt;= -48 )</a>
<a name="ln1063">        {</a>
<a name="ln1064">#if 0</a>
<a name="ln1065">          FT_Pos  delta1;</a>
<a name="ln1066">#endif</a>
<a name="ln1067">          FT_Pos  delta2;</a>
<a name="ln1068"> </a>
<a name="ln1069"> </a>
<a name="ln1070">          /* use discrete values for blue zone widths */</a>
<a name="ln1071"> </a>
<a name="ln1072">#if 0</a>
<a name="ln1073"> </a>
<a name="ln1074">          /* generic, original code */</a>
<a name="ln1075">          delta1 = blue-&gt;shoot.org - blue-&gt;ref.org;</a>
<a name="ln1076">          delta2 = delta1;</a>
<a name="ln1077">          if ( delta1 &lt; 0 )</a>
<a name="ln1078">            delta2 = -delta2;</a>
<a name="ln1079"> </a>
<a name="ln1080">          delta2 = FT_MulFix( delta2, scale );</a>
<a name="ln1081"> </a>
<a name="ln1082">          if ( delta2 &lt; 32 )</a>
<a name="ln1083">            delta2 = 0;</a>
<a name="ln1084">          else if ( delta2 &lt; 64 )</a>
<a name="ln1085">            delta2 = 32 + ( ( ( delta2 - 32 ) + 16 ) &amp; ~31 );</a>
<a name="ln1086">          else</a>
<a name="ln1087">            delta2 = FT_PIX_ROUND( delta2 );</a>
<a name="ln1088"> </a>
<a name="ln1089">          if ( delta1 &lt; 0 )</a>
<a name="ln1090">            delta2 = -delta2;</a>
<a name="ln1091"> </a>
<a name="ln1092">          blue-&gt;ref.fit   = FT_PIX_ROUND( blue-&gt;ref.cur );</a>
<a name="ln1093">          blue-&gt;shoot.fit = blue-&gt;ref.fit + delta2;</a>
<a name="ln1094"> </a>
<a name="ln1095">#else</a>
<a name="ln1096"> </a>
<a name="ln1097">          /* simplified version due to abs(dist) &lt;= 48 */</a>
<a name="ln1098">          delta2 = dist;</a>
<a name="ln1099">          if ( dist &lt; 0 )</a>
<a name="ln1100">            delta2 = -delta2;</a>
<a name="ln1101"> </a>
<a name="ln1102">          if ( delta2 &lt; 32 )</a>
<a name="ln1103">            delta2 = 0;</a>
<a name="ln1104">          else if ( delta2 &lt; 48 )</a>
<a name="ln1105">            delta2 = 32;</a>
<a name="ln1106">          else</a>
<a name="ln1107">            delta2 = 64;</a>
<a name="ln1108"> </a>
<a name="ln1109">          if ( dist &lt; 0 )</a>
<a name="ln1110">            delta2 = -delta2;</a>
<a name="ln1111"> </a>
<a name="ln1112">          blue-&gt;ref.fit   = FT_PIX_ROUND( blue-&gt;ref.cur );</a>
<a name="ln1113">          blue-&gt;shoot.fit = blue-&gt;ref.fit - delta2;</a>
<a name="ln1114"> </a>
<a name="ln1115">#endif</a>
<a name="ln1116"> </a>
<a name="ln1117">          blue-&gt;flags |= AF_LATIN_BLUE_ACTIVE;</a>
<a name="ln1118"> </a>
<a name="ln1119">          FT_TRACE5(( &quot;  reference %d: %d scaled to %.2f%s\n&quot;</a>
<a name="ln1120">                      &quot;  overshoot %d: %d scaled to %.2f%s\n&quot;,</a>
<a name="ln1121">                      nn,</a>
<a name="ln1122">                      blue-&gt;ref.org,</a>
<a name="ln1123">                      blue-&gt;ref.fit / 64.0,</a>
<a name="ln1124">                      blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ? &quot;&quot;</a>
<a name="ln1125">                                                         : &quot; (inactive)&quot;,</a>
<a name="ln1126">                      nn,</a>
<a name="ln1127">                      blue-&gt;shoot.org,</a>
<a name="ln1128">                      blue-&gt;shoot.fit / 64.0,</a>
<a name="ln1129">                      blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ? &quot;&quot;</a>
<a name="ln1130">                                                         : &quot; (inactive)&quot; ));</a>
<a name="ln1131">        }</a>
<a name="ln1132">      }</a>
<a name="ln1133">    }</a>
<a name="ln1134">  }</a>
<a name="ln1135"> </a>
<a name="ln1136"> </a>
<a name="ln1137">  /* Scale global values in both directions. */</a>
<a name="ln1138"> </a>
<a name="ln1139">  FT_LOCAL_DEF( void )</a>
<a name="ln1140">  af_latin_metrics_scale( AF_LatinMetrics  metrics,</a>
<a name="ln1141">                          AF_Scaler        scaler )</a>
<a name="ln1142">  {</a>
<a name="ln1143">    metrics-&gt;root.scaler.render_mode = scaler-&gt;render_mode;</a>
<a name="ln1144">    metrics-&gt;root.scaler.face        = scaler-&gt;face;</a>
<a name="ln1145">    metrics-&gt;root.scaler.flags       = scaler-&gt;flags;</a>
<a name="ln1146"> </a>
<a name="ln1147">    af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_HORZ );</a>
<a name="ln1148">    af_latin_metrics_scale_dim( metrics, scaler, AF_DIMENSION_VERT );</a>
<a name="ln1149">  }</a>
<a name="ln1150"> </a>
<a name="ln1151"> </a>
<a name="ln1152">  /*************************************************************************/</a>
<a name="ln1153">  /*************************************************************************/</a>
<a name="ln1154">  /*****                                                               *****/</a>
<a name="ln1155">  /*****           L A T I N   G L Y P H   A N A L Y S I S             *****/</a>
<a name="ln1156">  /*****                                                               *****/</a>
<a name="ln1157">  /*************************************************************************/</a>
<a name="ln1158">  /*************************************************************************/</a>
<a name="ln1159"> </a>
<a name="ln1160"> </a>
<a name="ln1161">  /* Walk over all contours and compute its segments. */</a>
<a name="ln1162"> </a>
<a name="ln1163">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln1164">  af_latin_hints_compute_segments( AF_GlyphHints  hints,</a>
<a name="ln1165">                                   AF_Dimension   dim )</a>
<a name="ln1166">  {</a>
<a name="ln1167">    AF_LatinMetrics  metrics       = (AF_LatinMetrics)hints-&gt;metrics;</a>
<a name="ln1168">    AF_AxisHints     axis          = &amp;hints-&gt;axis[dim];</a>
<a name="ln1169">    FT_Memory        memory        = hints-&gt;memory;</a>
<a name="ln1170">    FT_Error         error         = FT_Err_Ok;</a>
<a name="ln1171">    AF_Segment       segment       = NULL;</a>
<a name="ln1172">    AF_SegmentRec    seg0;</a>
<a name="ln1173">    AF_Point*        contour       = hints-&gt;contours;</a>
<a name="ln1174">    AF_Point*        contour_limit = contour + hints-&gt;num_contours;</a>
<a name="ln1175">    AF_Direction     major_dir, segment_dir;</a>
<a name="ln1176"> </a>
<a name="ln1177">    FT_Pos  flat_threshold = FLAT_THRESHOLD( metrics-&gt;units_per_em );</a>
<a name="ln1178"> </a>
<a name="ln1179"> </a>
<a name="ln1180">    FT_ZERO( &amp;seg0 );</a>
<a name="ln1181">    seg0.score = 32000;</a>
<a name="ln1182">    seg0.flags = AF_EDGE_NORMAL;</a>
<a name="ln1183"> </a>
<a name="ln1184">    major_dir   = (AF_Direction)FT_ABS( axis-&gt;major_dir );</a>
<a name="ln1185">    segment_dir = major_dir;</a>
<a name="ln1186"> </a>
<a name="ln1187">    axis-&gt;num_segments = 0;</a>
<a name="ln1188"> </a>
<a name="ln1189">    /* set up (u,v) in each point */</a>
<a name="ln1190">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln1191">    {</a>
<a name="ln1192">      AF_Point  point = hints-&gt;points;</a>
<a name="ln1193">      AF_Point  limit = point + hints-&gt;num_points;</a>
<a name="ln1194"> </a>
<a name="ln1195"> </a>
<a name="ln1196">      for ( ; point &lt; limit; point++ )</a>
<a name="ln1197">      {</a>
<a name="ln1198">        point-&gt;u = point-&gt;fx;</a>
<a name="ln1199">        point-&gt;v = point-&gt;fy;</a>
<a name="ln1200">      }</a>
<a name="ln1201">    }</a>
<a name="ln1202">    else</a>
<a name="ln1203">    {</a>
<a name="ln1204">      AF_Point  point = hints-&gt;points;</a>
<a name="ln1205">      AF_Point  limit = point + hints-&gt;num_points;</a>
<a name="ln1206"> </a>
<a name="ln1207"> </a>
<a name="ln1208">      for ( ; point &lt; limit; point++ )</a>
<a name="ln1209">      {</a>
<a name="ln1210">        point-&gt;u = point-&gt;fy;</a>
<a name="ln1211">        point-&gt;v = point-&gt;fx;</a>
<a name="ln1212">      }</a>
<a name="ln1213">    }</a>
<a name="ln1214"> </a>
<a name="ln1215">    /* do each contour separately */</a>
<a name="ln1216">    for ( ; contour &lt; contour_limit; contour++ )</a>
<a name="ln1217">    {</a>
<a name="ln1218">      AF_Point  point      =  contour[0];</a>
<a name="ln1219">      AF_Point  last       =  point-&gt;prev;</a>
<a name="ln1220">      int       on_edge    =  0;</a>
<a name="ln1221">      FT_Pos    min_pos    =  32000;  /* minimum segment pos != min_coord */</a>
<a name="ln1222">      FT_Pos    max_pos    = -32000;  /* maximum segment pos != max_coord */</a>
<a name="ln1223">      FT_Pos    min_on_pos =  32000;</a>
<a name="ln1224">      FT_Pos    max_on_pos = -32000;</a>
<a name="ln1225">      FT_Bool   passed;</a>
<a name="ln1226"> </a>
<a name="ln1227"> </a>
<a name="ln1228">      if ( point == last )  /* skip singletons -- just in case */</a>
<a name="ln1229">        continue;</a>
<a name="ln1230"> </a>
<a name="ln1231">      if ( FT_ABS( last-&gt;out_dir )  == major_dir &amp;&amp;</a>
<a name="ln1232">           FT_ABS( point-&gt;out_dir ) == major_dir )</a>
<a name="ln1233">      {</a>
<a name="ln1234">        /* we are already on an edge, try to locate its start */</a>
<a name="ln1235">        last = point;</a>
<a name="ln1236"> </a>
<a name="ln1237">        for (;;)</a>
<a name="ln1238">        {</a>
<a name="ln1239">          point = point-&gt;prev;</a>
<a name="ln1240">          if ( FT_ABS( point-&gt;out_dir ) != major_dir )</a>
<a name="ln1241">          {</a>
<a name="ln1242">            point = point-&gt;next;</a>
<a name="ln1243">            break;</a>
<a name="ln1244">          }</a>
<a name="ln1245">          if ( point == last )</a>
<a name="ln1246">            break;</a>
<a name="ln1247">        }</a>
<a name="ln1248">      }</a>
<a name="ln1249"> </a>
<a name="ln1250">      last   = point;</a>
<a name="ln1251">      passed = 0;</a>
<a name="ln1252"> </a>
<a name="ln1253">      for (;;)</a>
<a name="ln1254">      {</a>
<a name="ln1255">        FT_Pos  u, v;</a>
<a name="ln1256"> </a>
<a name="ln1257"> </a>
<a name="ln1258">        if ( on_edge )</a>
<a name="ln1259">        {</a>
<a name="ln1260">          u = point-&gt;u;</a>
<a name="ln1261">          if ( u &lt; min_pos )</a>
<a name="ln1262">            min_pos = u;</a>
<a name="ln1263">          if ( u &gt; max_pos )</a>
<a name="ln1264">            max_pos = u;</a>
<a name="ln1265"> </a>
<a name="ln1266">          /* get minimum and maximum coordinate of on points */</a>
<a name="ln1267">          if ( !( point-&gt;flags &amp; AF_FLAG_CONTROL ) )</a>
<a name="ln1268">          {</a>
<a name="ln1269">            v = point-&gt;v;</a>
<a name="ln1270">            if ( v &lt; min_on_pos )</a>
<a name="ln1271">              min_on_pos = v;</a>
<a name="ln1272">            if ( v &gt; max_on_pos )</a>
<a name="ln1273">              max_on_pos = v;</a>
<a name="ln1274">          }</a>
<a name="ln1275"> </a>
<a name="ln1276">          if ( point-&gt;out_dir != segment_dir || point == last )</a>
<a name="ln1277">          {</a>
<a name="ln1278">            /* we are just leaving an edge; record a new segment! */</a>
<a name="ln1279">            segment-&gt;last = point;</a>
<a name="ln1280">            segment-&gt;pos  = (FT_Short)( ( min_pos + max_pos ) &gt;&gt; 1 );</a>
<a name="ln1281"> </a>
<a name="ln1282">            /* a segment is round if either its first or last point */</a>
<a name="ln1283">            /* is a control point, and the length of the on points  */</a>
<a name="ln1284">            /* inbetween doesn't exceed a heuristic limit           */</a>
<a name="ln1285">            if ( ( segment-&gt;first-&gt;flags | point-&gt;flags ) &amp; AF_FLAG_CONTROL &amp;&amp;</a>
<a name="ln1286">                 ( max_on_pos - min_on_pos ) &lt; flat_threshold               )</a>
<a name="ln1287">              segment-&gt;flags |= AF_EDGE_ROUND;</a>
<a name="ln1288"> </a>
<a name="ln1289">            /* compute segment size */</a>
<a name="ln1290">            min_pos = max_pos = point-&gt;v;</a>
<a name="ln1291"> </a>
<a name="ln1292">            v = segment-&gt;first-&gt;v;</a>
<a name="ln1293">            if ( v &lt; min_pos )</a>
<a name="ln1294">              min_pos = v;</a>
<a name="ln1295">            if ( v &gt; max_pos )</a>
<a name="ln1296">              max_pos = v;</a>
<a name="ln1297"> </a>
<a name="ln1298">            segment-&gt;min_coord = (FT_Short)min_pos;</a>
<a name="ln1299">            segment-&gt;max_coord = (FT_Short)max_pos;</a>
<a name="ln1300">            segment-&gt;height    = (FT_Short)( segment-&gt;max_coord -</a>
<a name="ln1301">                                             segment-&gt;min_coord );</a>
<a name="ln1302"> </a>
<a name="ln1303">            on_edge = 0;</a>
<a name="ln1304">            segment = NULL;</a>
<a name="ln1305">            /* fall through */</a>
<a name="ln1306">          }</a>
<a name="ln1307">        }</a>
<a name="ln1308"> </a>
<a name="ln1309">        /* now exit if we are at the start/end point */</a>
<a name="ln1310">        if ( point == last )</a>
<a name="ln1311">        {</a>
<a name="ln1312">          if ( passed )</a>
<a name="ln1313">            break;</a>
<a name="ln1314">          passed = 1;</a>
<a name="ln1315">        }</a>
<a name="ln1316"> </a>
<a name="ln1317">        if ( !on_edge &amp;&amp; FT_ABS( point-&gt;out_dir ) == major_dir )</a>
<a name="ln1318">        {</a>
<a name="ln1319">          /* this is the start of a new segment! */</a>
<a name="ln1320">          segment_dir = (AF_Direction)point-&gt;out_dir;</a>
<a name="ln1321"> </a>
<a name="ln1322">          error = af_axis_hints_new_segment( axis, memory, &amp;segment );</a>
<a name="ln1323">          if ( error )</a>
<a name="ln1324">            goto Exit;</a>
<a name="ln1325"> </a>
<a name="ln1326">          /* clear all segment fields */</a>
<a name="ln1327">          segment[0] = seg0;</a>
<a name="ln1328"> </a>
<a name="ln1329">          segment-&gt;dir   = (FT_Char)segment_dir;</a>
<a name="ln1330">          segment-&gt;first = point;</a>
<a name="ln1331">          segment-&gt;last  = point;</a>
<a name="ln1332"> </a>
<a name="ln1333">          min_pos = max_pos = point-&gt;u;</a>
<a name="ln1334"> </a>
<a name="ln1335">          if ( point-&gt;flags &amp; AF_FLAG_CONTROL )</a>
<a name="ln1336">          {</a>
<a name="ln1337">            min_on_pos =  32000;</a>
<a name="ln1338">            max_on_pos = -32000;</a>
<a name="ln1339">          }</a>
<a name="ln1340">          else</a>
<a name="ln1341">            min_on_pos = max_on_pos = point-&gt;v;</a>
<a name="ln1342"> </a>
<a name="ln1343">          on_edge = 1;</a>
<a name="ln1344">        }</a>
<a name="ln1345"> </a>
<a name="ln1346">        point = point-&gt;next;</a>
<a name="ln1347">      }</a>
<a name="ln1348"> </a>
<a name="ln1349">    } /* contours */</a>
<a name="ln1350"> </a>
<a name="ln1351"> </a>
<a name="ln1352">    /* now slightly increase the height of segments if this makes */</a>
<a name="ln1353">    /* sense -- this is used to better detect and ignore serifs   */</a>
<a name="ln1354">    {</a>
<a name="ln1355">      AF_Segment  segments     = axis-&gt;segments;</a>
<a name="ln1356">      AF_Segment  segments_end = segments + axis-&gt;num_segments;</a>
<a name="ln1357"> </a>
<a name="ln1358"> </a>
<a name="ln1359">      for ( segment = segments; segment &lt; segments_end; segment++ )</a>
<a name="ln1360">      {</a>
<a name="ln1361">        AF_Point  first   = segment-&gt;first;</a>
<a name="ln1362">        AF_Point  last    = segment-&gt;last;</a>
<a name="ln1363">        FT_Pos    first_v = first-&gt;v;</a>
<a name="ln1364">        FT_Pos    last_v  = last-&gt;v;</a>
<a name="ln1365"> </a>
<a name="ln1366"> </a>
<a name="ln1367">        if ( first_v &lt; last_v )</a>
<a name="ln1368">        {</a>
<a name="ln1369">          AF_Point  p;</a>
<a name="ln1370"> </a>
<a name="ln1371"> </a>
<a name="ln1372">          p = first-&gt;prev;</a>
<a name="ln1373">          if ( p-&gt;v &lt; first_v )</a>
<a name="ln1374">            segment-&gt;height = (FT_Short)( segment-&gt;height +</a>
<a name="ln1375">                                          ( ( first_v - p-&gt;v ) &gt;&gt; 1 ) );</a>
<a name="ln1376"> </a>
<a name="ln1377">          p = last-&gt;next;</a>
<a name="ln1378">          if ( p-&gt;v &gt; last_v )</a>
<a name="ln1379">            segment-&gt;height = (FT_Short)( segment-&gt;height +</a>
<a name="ln1380">                                          ( ( p-&gt;v - last_v ) &gt;&gt; 1 ) );</a>
<a name="ln1381">        }</a>
<a name="ln1382">        else</a>
<a name="ln1383">        {</a>
<a name="ln1384">          AF_Point  p;</a>
<a name="ln1385"> </a>
<a name="ln1386"> </a>
<a name="ln1387">          p = first-&gt;prev;</a>
<a name="ln1388">          if ( p-&gt;v &gt; first_v )</a>
<a name="ln1389">            segment-&gt;height = (FT_Short)( segment-&gt;height +</a>
<a name="ln1390">                                          ( ( p-&gt;v - first_v ) &gt;&gt; 1 ) );</a>
<a name="ln1391"> </a>
<a name="ln1392">          p = last-&gt;next;</a>
<a name="ln1393">          if ( p-&gt;v &lt; last_v )</a>
<a name="ln1394">            segment-&gt;height = (FT_Short)( segment-&gt;height +</a>
<a name="ln1395">                                          ( ( last_v - p-&gt;v ) &gt;&gt; 1 ) );</a>
<a name="ln1396">        }</a>
<a name="ln1397">      }</a>
<a name="ln1398">    }</a>
<a name="ln1399"> </a>
<a name="ln1400">  Exit:</a>
<a name="ln1401">    return error;</a>
<a name="ln1402">  }</a>
<a name="ln1403"> </a>
<a name="ln1404"> </a>
<a name="ln1405">  /* Link segments to form stems and serifs.  If `width_count' and      */</a>
<a name="ln1406">  /* `widths' are non-zero, use them to fine-tune the scoring function. */</a>
<a name="ln1407"> </a>
<a name="ln1408">  FT_LOCAL_DEF( void )</a>
<a name="ln1409">  af_latin_hints_link_segments( AF_GlyphHints  hints,</a>
<a name="ln1410">                                FT_UInt        width_count,</a>
<a name="ln1411">                                AF_WidthRec*   widths,</a>
<a name="ln1412">                                AF_Dimension   dim )</a>
<a name="ln1413">  {</a>
<a name="ln1414">    AF_AxisHints  axis          = &amp;hints-&gt;axis[dim];</a>
<a name="ln1415">    AF_Segment    segments      = axis-&gt;segments;</a>
<a name="ln1416">    AF_Segment    segment_limit = segments + axis-&gt;num_segments;</a>
<a name="ln1417">    FT_Pos        len_threshold, len_score, dist_score, max_width;</a>
<a name="ln1418">    AF_Segment    seg1, seg2;</a>
<a name="ln1419"> </a>
<a name="ln1420"> </a>
<a name="ln1421">    if ( width_count )</a>
<a name="ln1422">      max_width = widths[width_count - 1].org;</a>
<a name="ln1423">    else</a>
<a name="ln1424">      max_width = 0;</a>
<a name="ln1425"> </a>
<a name="ln1426">    /* a heuristic value to set up a minimum value for overlapping */</a>
<a name="ln1427">    len_threshold = AF_LATIN_CONSTANT( hints-&gt;metrics, 8 );</a>
<a name="ln1428">    if ( len_threshold == 0 )</a>
<a name="ln1429">      len_threshold = 1;</a>
<a name="ln1430"> </a>
<a name="ln1431">    /* a heuristic value to weight lengths */</a>
<a name="ln1432">    len_score = AF_LATIN_CONSTANT( hints-&gt;metrics, 6000 );</a>
<a name="ln1433"> </a>
<a name="ln1434">    /* a heuristic value to weight distances (no call to    */</a>
<a name="ln1435">    /* AF_LATIN_CONSTANT needed, since we work on multiples */</a>
<a name="ln1436">    /* of the stem width)                                   */</a>
<a name="ln1437">    dist_score = 3000;</a>
<a name="ln1438"> </a>
<a name="ln1439">    /* now compare each segment to the others */</a>
<a name="ln1440">    for ( seg1 = segments; seg1 &lt; segment_limit; seg1++ )</a>
<a name="ln1441">    {</a>
<a name="ln1442">      if ( seg1-&gt;dir != axis-&gt;major_dir )</a>
<a name="ln1443">        continue;</a>
<a name="ln1444"> </a>
<a name="ln1445">      /* search for stems having opposite directions, */</a>
<a name="ln1446">      /* with seg1 to the `left' of seg2              */</a>
<a name="ln1447">      for ( seg2 = segments; seg2 &lt; segment_limit; seg2++ )</a>
<a name="ln1448">      {</a>
<a name="ln1449">        FT_Pos  pos1 = seg1-&gt;pos;</a>
<a name="ln1450">        FT_Pos  pos2 = seg2-&gt;pos;</a>
<a name="ln1451"> </a>
<a name="ln1452"> </a>
<a name="ln1453">        if ( seg1-&gt;dir + seg2-&gt;dir == 0 &amp;&amp; pos2 &gt; pos1 )</a>
<a name="ln1454">        {</a>
<a name="ln1455">          /* compute distance between the two segments */</a>
<a name="ln1456">          FT_Pos  min = seg1-&gt;min_coord;</a>
<a name="ln1457">          FT_Pos  max = seg1-&gt;max_coord;</a>
<a name="ln1458">          FT_Pos  len;</a>
<a name="ln1459"> </a>
<a name="ln1460"> </a>
<a name="ln1461">          if ( min &lt; seg2-&gt;min_coord )</a>
<a name="ln1462">            min = seg2-&gt;min_coord;</a>
<a name="ln1463"> </a>
<a name="ln1464">          if ( max &gt; seg2-&gt;max_coord )</a>
<a name="ln1465">            max = seg2-&gt;max_coord;</a>
<a name="ln1466"> </a>
<a name="ln1467">          /* compute maximum coordinate difference of the two segments */</a>
<a name="ln1468">          /* (this is, how much they overlap)                          */</a>
<a name="ln1469">          len = max - min;</a>
<a name="ln1470">          if ( len &gt;= len_threshold )</a>
<a name="ln1471">          {</a>
<a name="ln1472">            /*</a>
<a name="ln1473">             *  The score is the sum of two demerits indicating the</a>
<a name="ln1474">             *  `badness' of a fit, measured along the segments' main axis</a>
<a name="ln1475">             *  and orthogonal to it, respectively.</a>
<a name="ln1476">             *</a>
<a name="ln1477">             *  o The less overlapping along the main axis, the worse it</a>
<a name="ln1478">             *    is, causing a larger demerit.</a>
<a name="ln1479">             *</a>
<a name="ln1480">             *  o The nearer the orthogonal distance to a stem width, the</a>
<a name="ln1481">             *    better it is, causing a smaller demerit.  For simplicity,</a>
<a name="ln1482">             *    however, we only increase the demerit for values that</a>
<a name="ln1483">             *    exceed the largest stem width.</a>
<a name="ln1484">             */</a>
<a name="ln1485"> </a>
<a name="ln1486">            FT_Pos  dist = pos2 - pos1;</a>
<a name="ln1487"> </a>
<a name="ln1488">            FT_Pos  dist_demerit, score;</a>
<a name="ln1489"> </a>
<a name="ln1490"> </a>
<a name="ln1491">            if ( max_width )</a>
<a name="ln1492">            {</a>
<a name="ln1493">              /* distance demerits are based on multiples of `max_width'; */</a>
<a name="ln1494">              /* we scale by 1024 for getting more precision              */</a>
<a name="ln1495">              FT_Pos  delta = ( dist &lt;&lt; 10 ) / max_width - ( 1 &lt;&lt; 10 );</a>
<a name="ln1496"> </a>
<a name="ln1497"> </a>
<a name="ln1498">              if ( delta &gt; 10000 )</a>
<a name="ln1499">                dist_demerit = 32000;</a>
<a name="ln1500">              else if ( delta &gt; 0 )</a>
<a name="ln1501">                dist_demerit = delta * delta / dist_score;</a>
<a name="ln1502">              else</a>
<a name="ln1503">                dist_demerit = 0;</a>
<a name="ln1504">            }</a>
<a name="ln1505">            else</a>
<a name="ln1506">              dist_demerit = dist; /* default if no widths available */</a>
<a name="ln1507"> </a>
<a name="ln1508">            score = dist_demerit + len_score / len;</a>
<a name="ln1509"> </a>
<a name="ln1510">            /* and we search for the smallest score */</a>
<a name="ln1511">            if ( score &lt; seg1-&gt;score )</a>
<a name="ln1512">            {</a>
<a name="ln1513">              seg1-&gt;score = score;</a>
<a name="ln1514">              seg1-&gt;link  = seg2;</a>
<a name="ln1515">            }</a>
<a name="ln1516"> </a>
<a name="ln1517">            if ( score &lt; seg2-&gt;score )</a>
<a name="ln1518">            {</a>
<a name="ln1519">              seg2-&gt;score = score;</a>
<a name="ln1520">              seg2-&gt;link  = seg1;</a>
<a name="ln1521">            }</a>
<a name="ln1522">          }</a>
<a name="ln1523">        }</a>
<a name="ln1524">      }</a>
<a name="ln1525">    }</a>
<a name="ln1526"> </a>
<a name="ln1527">    /* now compute the `serif' segments, cf. explanations in `afhints.h' */</a>
<a name="ln1528">    for ( seg1 = segments; seg1 &lt; segment_limit; seg1++ )</a>
<a name="ln1529">    {</a>
<a name="ln1530">      seg2 = seg1-&gt;link;</a>
<a name="ln1531"> </a>
<a name="ln1532">      if ( seg2 )</a>
<a name="ln1533">      {</a>
<a name="ln1534">        if ( seg2-&gt;link != seg1 )</a>
<a name="ln1535">        {</a>
<a name="ln1536">          seg1-&gt;link  = 0;</a>
<a name="ln1537">          seg1-&gt;serif = seg2-&gt;link;</a>
<a name="ln1538">        }</a>
<a name="ln1539">      }</a>
<a name="ln1540">    }</a>
<a name="ln1541">  }</a>
<a name="ln1542"> </a>
<a name="ln1543"> </a>
<a name="ln1544">  /* Link segments to edges, using feature analysis for selection. */</a>
<a name="ln1545"> </a>
<a name="ln1546">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln1547">  af_latin_hints_compute_edges( AF_GlyphHints  hints,</a>
<a name="ln1548">                                AF_Dimension   dim )</a>
<a name="ln1549">  {</a>
<a name="ln1550">    AF_AxisHints  axis   = &amp;hints-&gt;axis[dim];</a>
<a name="ln1551">    FT_Error      error  = FT_Err_Ok;</a>
<a name="ln1552">    FT_Memory     memory = hints-&gt;memory;</a>
<a name="ln1553">    AF_LatinAxis  laxis  = &amp;((AF_LatinMetrics)hints-&gt;metrics)-&gt;axis[dim];</a>
<a name="ln1554"> </a>
<a name="ln1555">    AF_Segment    segments      = axis-&gt;segments;</a>
<a name="ln1556">    AF_Segment    segment_limit = segments + axis-&gt;num_segments;</a>
<a name="ln1557">    AF_Segment    seg;</a>
<a name="ln1558"> </a>
<a name="ln1559">#if 0</a>
<a name="ln1560">    AF_Direction  up_dir;</a>
<a name="ln1561">#endif</a>
<a name="ln1562">    FT_Fixed      scale;</a>
<a name="ln1563">    FT_Pos        edge_distance_threshold;</a>
<a name="ln1564">    FT_Pos        segment_length_threshold;</a>
<a name="ln1565"> </a>
<a name="ln1566"> </a>
<a name="ln1567">    axis-&gt;num_edges = 0;</a>
<a name="ln1568"> </a>
<a name="ln1569">    scale = ( dim == AF_DIMENSION_HORZ ) ? hints-&gt;x_scale</a>
<a name="ln1570">                                         : hints-&gt;y_scale;</a>
<a name="ln1571"> </a>
<a name="ln1572">#if 0</a>
<a name="ln1573">    up_dir = ( dim == AF_DIMENSION_HORZ ) ? AF_DIR_UP</a>
<a name="ln1574">                                          : AF_DIR_RIGHT;</a>
<a name="ln1575">#endif</a>
<a name="ln1576"> </a>
<a name="ln1577">    /*</a>
<a name="ln1578">     *  We ignore all segments that are less than 1 pixel in length</a>
<a name="ln1579">     *  to avoid many problems with serif fonts.  We compute the</a>
<a name="ln1580">     *  corresponding threshold in font units.</a>
<a name="ln1581">     */</a>
<a name="ln1582">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln1583">        segment_length_threshold = FT_DivFix( 64, hints-&gt;y_scale );</a>
<a name="ln1584">    else</a>
<a name="ln1585">        segment_length_threshold = 0;</a>
<a name="ln1586"> </a>
<a name="ln1587">    /*********************************************************************/</a>
<a name="ln1588">    /*                                                                   */</a>
<a name="ln1589">    /* We begin by generating a sorted table of edges for the current    */</a>
<a name="ln1590">    /* direction.  To do so, we simply scan each segment and try to find */</a>
<a name="ln1591">    /* an edge in our table that corresponds to its position.            */</a>
<a name="ln1592">    /*                                                                   */</a>
<a name="ln1593">    /* If no edge is found, we create and insert a new edge in the       */</a>
<a name="ln1594">    /* sorted table.  Otherwise, we simply add the segment to the edge's */</a>
<a name="ln1595">    /* list which gets processed in the second step to compute the       */</a>
<a name="ln1596">    /* edge's properties.                                                */</a>
<a name="ln1597">    /*                                                                   */</a>
<a name="ln1598">    /* Note that the table of edges is sorted along the segment/edge     */</a>
<a name="ln1599">    /* position.                                                         */</a>
<a name="ln1600">    /*                                                                   */</a>
<a name="ln1601">    /*********************************************************************/</a>
<a name="ln1602"> </a>
<a name="ln1603">    /* assure that edge distance threshold is at most 0.25px */</a>
<a name="ln1604">    edge_distance_threshold = FT_MulFix( laxis-&gt;edge_distance_threshold,</a>
<a name="ln1605">                                         scale );</a>
<a name="ln1606">    if ( edge_distance_threshold &gt; 64 / 4 )</a>
<a name="ln1607">      edge_distance_threshold = 64 / 4;</a>
<a name="ln1608"> </a>
<a name="ln1609">    edge_distance_threshold = FT_DivFix( edge_distance_threshold,</a>
<a name="ln1610">                                         scale );</a>
<a name="ln1611"> </a>
<a name="ln1612">    for ( seg = segments; seg &lt; segment_limit; seg++ )</a>
<a name="ln1613">    {</a>
<a name="ln1614">      AF_Edge  found = NULL;</a>
<a name="ln1615">      FT_Int   ee;</a>
<a name="ln1616"> </a>
<a name="ln1617"> </a>
<a name="ln1618">      if ( seg-&gt;height &lt; segment_length_threshold )</a>
<a name="ln1619">        continue;</a>
<a name="ln1620"> </a>
<a name="ln1621">      /* A special case for serif edges: If they are smaller than */</a>
<a name="ln1622">      /* 1.5 pixels we ignore them.                               */</a>
<a name="ln1623">      if ( seg-&gt;serif                                     &amp;&amp;</a>
<a name="ln1624">           2 * seg-&gt;height &lt; 3 * segment_length_threshold )</a>
<a name="ln1625">        continue;</a>
<a name="ln1626"> </a>
<a name="ln1627">      /* look for an edge corresponding to the segment */</a>
<a name="ln1628">      for ( ee = 0; ee &lt; axis-&gt;num_edges; ee++ )</a>
<a name="ln1629">      {</a>
<a name="ln1630">        AF_Edge  edge = axis-&gt;edges + ee;</a>
<a name="ln1631">        FT_Pos   dist;</a>
<a name="ln1632"> </a>
<a name="ln1633"> </a>
<a name="ln1634">        dist = seg-&gt;pos - edge-&gt;fpos;</a>
<a name="ln1635">        if ( dist &lt; 0 )</a>
<a name="ln1636">          dist = -dist;</a>
<a name="ln1637"> </a>
<a name="ln1638">        if ( dist &lt; edge_distance_threshold &amp;&amp; edge-&gt;dir == seg-&gt;dir )</a>
<a name="ln1639">        {</a>
<a name="ln1640">          found = edge;</a>
<a name="ln1641">          break;</a>
<a name="ln1642">        }</a>
<a name="ln1643">      }</a>
<a name="ln1644"> </a>
<a name="ln1645">      if ( !found )</a>
<a name="ln1646">      {</a>
<a name="ln1647">        AF_Edge  edge;</a>
<a name="ln1648"> </a>
<a name="ln1649"> </a>
<a name="ln1650">        /* insert a new edge in the list and */</a>
<a name="ln1651">        /* sort according to the position    */</a>
<a name="ln1652">        error = af_axis_hints_new_edge( axis, seg-&gt;pos,</a>
<a name="ln1653">                                        (AF_Direction)seg-&gt;dir,</a>
<a name="ln1654">                                        memory, &amp;edge );</a>
<a name="ln1655">        if ( error )</a>
<a name="ln1656">          goto Exit;</a>
<a name="ln1657"> </a>
<a name="ln1658">        /* add the segment to the new edge's list */</a>
<a name="ln1659">        FT_ZERO( edge );</a>
<a name="ln1660"> </a>
<a name="ln1661">        edge-&gt;first    = seg;</a>
<a name="ln1662">        edge-&gt;last     = seg;</a>
<a name="ln1663">        edge-&gt;dir      = seg-&gt;dir;</a>
<a name="ln1664">        edge-&gt;fpos     = seg-&gt;pos;</a>
<a name="ln1665">        edge-&gt;opos     = FT_MulFix( seg-&gt;pos, scale );</a>
<a name="ln1666">        edge-&gt;pos      = edge-&gt;opos;</a>
<a name="ln1667">        seg-&gt;edge_next = seg;</a>
<a name="ln1668">      }</a>
<a name="ln1669">      else</a>
<a name="ln1670">      {</a>
<a name="ln1671">        /* if an edge was found, simply add the segment to the edge's */</a>
<a name="ln1672">        /* list                                                       */</a>
<a name="ln1673">        seg-&gt;edge_next         = found-&gt;first;</a>
<a name="ln1674">        found-&gt;last-&gt;edge_next = seg;</a>
<a name="ln1675">        found-&gt;last            = seg;</a>
<a name="ln1676">      }</a>
<a name="ln1677">    }</a>
<a name="ln1678"> </a>
<a name="ln1679"> </a>
<a name="ln1680">    /******************************************************************/</a>
<a name="ln1681">    /*                                                                */</a>
<a name="ln1682">    /* Good, we now compute each edge's properties according to the   */</a>
<a name="ln1683">    /* segments found on its position.  Basically, these are          */</a>
<a name="ln1684">    /*                                                                */</a>
<a name="ln1685">    /*  - the edge's main direction                                   */</a>
<a name="ln1686">    /*  - stem edge, serif edge or both (which defaults to stem then) */</a>
<a name="ln1687">    /*  - rounded edge, straight or both (which defaults to straight) */</a>
<a name="ln1688">    /*  - link for edge                                               */</a>
<a name="ln1689">    /*                                                                */</a>
<a name="ln1690">    /******************************************************************/</a>
<a name="ln1691"> </a>
<a name="ln1692">    /* first of all, set the `edge' field in each segment -- this is */</a>
<a name="ln1693">    /* required in order to compute edge links                       */</a>
<a name="ln1694"> </a>
<a name="ln1695">    /*</a>
<a name="ln1696">     * Note that removing this loop and setting the `edge' field of each</a>
<a name="ln1697">     * segment directly in the code above slows down execution speed for</a>
<a name="ln1698">     * some reasons on platforms like the Sun.</a>
<a name="ln1699">     */</a>
<a name="ln1700">    {</a>
<a name="ln1701">      AF_Edge  edges      = axis-&gt;edges;</a>
<a name="ln1702">      AF_Edge  edge_limit = edges + axis-&gt;num_edges;</a>
<a name="ln1703">      AF_Edge  edge;</a>
<a name="ln1704"> </a>
<a name="ln1705"> </a>
<a name="ln1706">      for ( edge = edges; edge &lt; edge_limit; edge++ )</a>
<a name="ln1707">      {</a>
<a name="ln1708">        seg = edge-&gt;first;</a>
<a name="ln1709">        if ( seg )</a>
<a name="ln1710">          do</a>
<a name="ln1711">          {</a>
<a name="ln1712">            seg-&gt;edge = edge;</a>
<a name="ln1713">            seg       = seg-&gt;edge_next;</a>
<a name="ln1714"> </a>
<a name="ln1715">          } while ( seg != edge-&gt;first );</a>
<a name="ln1716">      }</a>
<a name="ln1717"> </a>
<a name="ln1718">      /* now compute each edge properties */</a>
<a name="ln1719">      for ( edge = edges; edge &lt; edge_limit; edge++ )</a>
<a name="ln1720">      {</a>
<a name="ln1721">        FT_Int  is_round    = 0;  /* does it contain round segments?    */</a>
<a name="ln1722">        FT_Int  is_straight = 0;  /* does it contain straight segments? */</a>
<a name="ln1723">#if 0</a>
<a name="ln1724">        FT_Pos  ups         = 0;  /* number of upwards segments         */</a>
<a name="ln1725">        FT_Pos  downs       = 0;  /* number of downwards segments       */</a>
<a name="ln1726">#endif</a>
<a name="ln1727"> </a>
<a name="ln1728"> </a>
<a name="ln1729">        seg = edge-&gt;first;</a>
<a name="ln1730"> </a>
<a name="ln1731">        do</a>
<a name="ln1732">        {</a>
<a name="ln1733">          FT_Bool  is_serif;</a>
<a name="ln1734"> </a>
<a name="ln1735"> </a>
<a name="ln1736">          /* check for roundness of segment */</a>
<a name="ln1737">          if ( seg-&gt;flags &amp; AF_EDGE_ROUND )</a>
<a name="ln1738">            is_round++;</a>
<a name="ln1739">          else</a>
<a name="ln1740">            is_straight++;</a>
<a name="ln1741"> </a>
<a name="ln1742">#if 0</a>
<a name="ln1743">          /* check for segment direction */</a>
<a name="ln1744">          if ( seg-&gt;dir == up_dir )</a>
<a name="ln1745">            ups   += seg-&gt;max_coord - seg-&gt;min_coord;</a>
<a name="ln1746">          else</a>
<a name="ln1747">            downs += seg-&gt;max_coord - seg-&gt;min_coord;</a>
<a name="ln1748">#endif</a>
<a name="ln1749"> </a>
<a name="ln1750">          /* check for links -- if seg-&gt;serif is set, then seg-&gt;link must */</a>
<a name="ln1751">          /* be ignored                                                   */</a>
<a name="ln1752">          is_serif = (FT_Bool)( seg-&gt;serif               &amp;&amp;</a>
<a name="ln1753">                                seg-&gt;serif-&gt;edge         &amp;&amp;</a>
<a name="ln1754">                                seg-&gt;serif-&gt;edge != edge );</a>
<a name="ln1755"> </a>
<a name="ln1756">          if ( ( seg-&gt;link &amp;&amp; seg-&gt;link-&gt;edge != NULL ) || is_serif )</a>
<a name="ln1757">          {</a>
<a name="ln1758">            AF_Edge     edge2;</a>
<a name="ln1759">            AF_Segment  seg2;</a>
<a name="ln1760"> </a>
<a name="ln1761"> </a>
<a name="ln1762">            edge2 = edge-&gt;link;</a>
<a name="ln1763">            seg2  = seg-&gt;link;</a>
<a name="ln1764"> </a>
<a name="ln1765">            if ( is_serif )</a>
<a name="ln1766">            {</a>
<a name="ln1767">              seg2  = seg-&gt;serif;</a>
<a name="ln1768">              edge2 = edge-&gt;serif;</a>
<a name="ln1769">            }</a>
<a name="ln1770"> </a>
<a name="ln1771">            if ( edge2 )</a>
<a name="ln1772">            {</a>
<a name="ln1773">              FT_Pos  edge_delta;</a>
<a name="ln1774">              FT_Pos  seg_delta;</a>
<a name="ln1775"> </a>
<a name="ln1776"> </a>
<a name="ln1777">              edge_delta = edge-&gt;fpos - edge2-&gt;fpos;</a>
<a name="ln1778">              if ( edge_delta &lt; 0 )</a>
<a name="ln1779">                edge_delta = -edge_delta;</a>
<a name="ln1780"> </a>
<a name="ln1781">              seg_delta = seg-&gt;pos - seg2-&gt;pos;</a>
<a name="ln1782">              if ( seg_delta &lt; 0 )</a>
<a name="ln1783">                seg_delta = -seg_delta;</a>
<a name="ln1784"> </a>
<a name="ln1785">              if ( seg_delta &lt; edge_delta )</a>
<a name="ln1786">                edge2 = seg2-&gt;edge;</a>
<a name="ln1787">            }</a>
<a name="ln1788">            else</a>
<a name="ln1789">              edge2 = seg2-&gt;edge;</a>
<a name="ln1790"> </a>
<a name="ln1791">            if ( is_serif )</a>
<a name="ln1792">            {</a>
<a name="ln1793">              edge-&gt;serif   = edge2;</a>
<a name="ln1794">              edge2-&gt;flags |= AF_EDGE_SERIF;</a>
<a name="ln1795">            }</a>
<a name="ln1796">            else</a>
<a name="ln1797">              edge-&gt;link  = edge2;</a>
<a name="ln1798">          }</a>
<a name="ln1799"> </a>
<a name="ln1800">          seg = seg-&gt;edge_next;</a>
<a name="ln1801"> </a>
<a name="ln1802">        } while ( seg != edge-&gt;first );</a>
<a name="ln1803"> </a>
<a name="ln1804">        /* set the round/straight flags */</a>
<a name="ln1805">        edge-&gt;flags = AF_EDGE_NORMAL;</a>
<a name="ln1806"> </a>
<a name="ln1807">        if ( is_round &gt; 0 &amp;&amp; is_round &gt;= is_straight )</a>
<a name="ln1808">          edge-&gt;flags |= AF_EDGE_ROUND;</a>
<a name="ln1809"> </a>
<a name="ln1810">#if 0</a>
<a name="ln1811">        /* set the edge's main direction */</a>
<a name="ln1812">        edge-&gt;dir = AF_DIR_NONE;</a>
<a name="ln1813"> </a>
<a name="ln1814">        if ( ups &gt; downs )</a>
<a name="ln1815">          edge-&gt;dir = (FT_Char)up_dir;</a>
<a name="ln1816"> </a>
<a name="ln1817">        else if ( ups &lt; downs )</a>
<a name="ln1818">          edge-&gt;dir = (FT_Char)-up_dir;</a>
<a name="ln1819"> </a>
<a name="ln1820">        else if ( ups == downs )</a>
<a name="ln1821">          edge-&gt;dir = 0;  /* both up and down! */</a>
<a name="ln1822">#endif</a>
<a name="ln1823"> </a>
<a name="ln1824">        /* get rid of serifs if link is set                 */</a>
<a name="ln1825">        /* XXX: This gets rid of many unpleasant artefacts! */</a>
<a name="ln1826">        /*      Example: the `c' in cour.pfa at size 13     */</a>
<a name="ln1827"> </a>
<a name="ln1828">        if ( edge-&gt;serif &amp;&amp; edge-&gt;link )</a>
<a name="ln1829">          edge-&gt;serif = NULL;</a>
<a name="ln1830">      }</a>
<a name="ln1831">    }</a>
<a name="ln1832"> </a>
<a name="ln1833">  Exit:</a>
<a name="ln1834">    return error;</a>
<a name="ln1835">  }</a>
<a name="ln1836"> </a>
<a name="ln1837"> </a>
<a name="ln1838">  /* Detect segments and edges for given dimension. */</a>
<a name="ln1839"> </a>
<a name="ln1840">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln1841">  af_latin_hints_detect_features( AF_GlyphHints  hints,</a>
<a name="ln1842">                                  FT_UInt        width_count,</a>
<a name="ln1843">                                  AF_WidthRec*   widths,</a>
<a name="ln1844">                                  AF_Dimension   dim )</a>
<a name="ln1845">  {</a>
<a name="ln1846">    FT_Error  error;</a>
<a name="ln1847"> </a>
<a name="ln1848"> </a>
<a name="ln1849">    error = af_latin_hints_compute_segments( hints, dim );</a>
<a name="ln1850">    if ( !error )</a>
<a name="ln1851">    {</a>
<a name="ln1852">      af_latin_hints_link_segments( hints, width_count, widths, dim );</a>
<a name="ln1853"> </a>
<a name="ln1854">      error = af_latin_hints_compute_edges( hints, dim );</a>
<a name="ln1855">    }</a>
<a name="ln1856"> </a>
<a name="ln1857">    return error;</a>
<a name="ln1858">  }</a>
<a name="ln1859"> </a>
<a name="ln1860"> </a>
<a name="ln1861">  /* Compute all edges which lie within blue zones. */</a>
<a name="ln1862"> </a>
<a name="ln1863">  static void</a>
<a name="ln1864">  af_latin_hints_compute_blue_edges( AF_GlyphHints    hints,</a>
<a name="ln1865">                                     AF_LatinMetrics  metrics )</a>
<a name="ln1866">  {</a>
<a name="ln1867">    AF_AxisHints  axis       = &amp;hints-&gt;axis[AF_DIMENSION_VERT];</a>
<a name="ln1868">    AF_Edge       edge       = axis-&gt;edges;</a>
<a name="ln1869">    AF_Edge       edge_limit = edge + axis-&gt;num_edges;</a>
<a name="ln1870">    AF_LatinAxis  latin      = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];</a>
<a name="ln1871">    FT_Fixed      scale      = latin-&gt;scale;</a>
<a name="ln1872"> </a>
<a name="ln1873"> </a>
<a name="ln1874">    /* compute which blue zones are active, i.e. have their scaled */</a>
<a name="ln1875">    /* size &lt; 3/4 pixels                                           */</a>
<a name="ln1876"> </a>
<a name="ln1877">    /* for each horizontal edge search the blue zone which is closest */</a>
<a name="ln1878">    for ( ; edge &lt; edge_limit; edge++ )</a>
<a name="ln1879">    {</a>
<a name="ln1880">      FT_UInt   bb;</a>
<a name="ln1881">      AF_Width  best_blue            = NULL;</a>
<a name="ln1882">      FT_Bool   best_blue_is_neutral = 0;</a>
<a name="ln1883">      FT_Pos    best_dist;                 /* initial threshold */</a>
<a name="ln1884"> </a>
<a name="ln1885"> </a>
<a name="ln1886">      /* compute the initial threshold as a fraction of the EM size */</a>
<a name="ln1887">      /* (the value 40 is heuristic)                                */</a>
<a name="ln1888">      best_dist = FT_MulFix( metrics-&gt;units_per_em / 40, scale );</a>
<a name="ln1889"> </a>
<a name="ln1890">      /* assure a minimum distance of 0.5px */</a>
<a name="ln1891">      if ( best_dist &gt; 64 / 2 )</a>
<a name="ln1892">        best_dist = 64 / 2;</a>
<a name="ln1893"> </a>
<a name="ln1894">      for ( bb = 0; bb &lt; latin-&gt;blue_count; bb++ )</a>
<a name="ln1895">      {</a>
<a name="ln1896">        AF_LatinBlue  blue = latin-&gt;blues + bb;</a>
<a name="ln1897">        FT_Bool       is_top_blue, is_neutral_blue, is_major_dir;</a>
<a name="ln1898"> </a>
<a name="ln1899"> </a>
<a name="ln1900">        /* skip inactive blue zones (i.e., those that are too large) */</a>
<a name="ln1901">        if ( !( blue-&gt;flags &amp; AF_LATIN_BLUE_ACTIVE ) )</a>
<a name="ln1902">          continue;</a>
<a name="ln1903"> </a>
<a name="ln1904">        /* if it is a top zone, check for right edges (against the major */</a>
<a name="ln1905">        /* direction); if it is a bottom zone, check for left edges (in  */</a>
<a name="ln1906">        /* the major direction) -- this assumes the TrueType convention  */</a>
<a name="ln1907">        /* for the orientation of contours                               */</a>
<a name="ln1908">        is_top_blue =</a>
<a name="ln1909">          (FT_Byte)( ( blue-&gt;flags &amp; AF_LATIN_BLUE_TOP ) != 0 );</a>
<a name="ln1910">        is_neutral_blue =</a>
<a name="ln1911">          (FT_Byte)( ( blue-&gt;flags &amp; AF_LATIN_BLUE_NEUTRAL ) != 0);</a>
<a name="ln1912">        is_major_dir =</a>
<a name="ln1913">          FT_BOOL( edge-&gt;dir == axis-&gt;major_dir );</a>
<a name="ln1914"> </a>
<a name="ln1915">        /* neutral blue zones are handled for both directions */</a>
<a name="ln1916">        if ( is_top_blue ^ is_major_dir || is_neutral_blue )</a>
<a name="ln1917">        {</a>
<a name="ln1918">          FT_Pos  dist;</a>
<a name="ln1919"> </a>
<a name="ln1920"> </a>
<a name="ln1921">          /* first of all, compare it to the reference position */</a>
<a name="ln1922">          dist = edge-&gt;fpos - blue-&gt;ref.org;</a>
<a name="ln1923">          if ( dist &lt; 0 )</a>
<a name="ln1924">            dist = -dist;</a>
<a name="ln1925"> </a>
<a name="ln1926">          dist = FT_MulFix( dist, scale );</a>
<a name="ln1927">          if ( dist &lt; best_dist )</a>
<a name="ln1928">          {</a>
<a name="ln1929">            best_dist            = dist;</a>
<a name="ln1930">            best_blue            = &amp;blue-&gt;ref;</a>
<a name="ln1931">            best_blue_is_neutral = is_neutral_blue;</a>
<a name="ln1932">          }</a>
<a name="ln1933"> </a>
<a name="ln1934">          /* now compare it to the overshoot position and check whether */</a>
<a name="ln1935">          /* the edge is rounded, and whether the edge is over the      */</a>
<a name="ln1936">          /* reference position of a top zone, or under the reference   */</a>
<a name="ln1937">          /* position of a bottom zone (provided we don't have a        */</a>
<a name="ln1938">          /* neutral blue zone)                                         */</a>
<a name="ln1939">          if ( edge-&gt;flags &amp; AF_EDGE_ROUND &amp;&amp;</a>
<a name="ln1940">               dist != 0                   &amp;&amp;</a>
<a name="ln1941">               !is_neutral_blue            )</a>
<a name="ln1942">          {</a>
<a name="ln1943">            FT_Bool  is_under_ref = FT_BOOL( edge-&gt;fpos &lt; blue-&gt;ref.org );</a>
<a name="ln1944"> </a>
<a name="ln1945"> </a>
<a name="ln1946">            if ( is_top_blue ^ is_under_ref )</a>
<a name="ln1947">            {</a>
<a name="ln1948">              dist = edge-&gt;fpos - blue-&gt;shoot.org;</a>
<a name="ln1949">              if ( dist &lt; 0 )</a>
<a name="ln1950">                dist = -dist;</a>
<a name="ln1951"> </a>
<a name="ln1952">              dist = FT_MulFix( dist, scale );</a>
<a name="ln1953">              if ( dist &lt; best_dist )</a>
<a name="ln1954">              {</a>
<a name="ln1955">                best_dist            = dist;</a>
<a name="ln1956">                best_blue            = &amp;blue-&gt;shoot;</a>
<a name="ln1957">                best_blue_is_neutral = is_neutral_blue;</a>
<a name="ln1958">              }</a>
<a name="ln1959">            }</a>
<a name="ln1960">          }</a>
<a name="ln1961">        }</a>
<a name="ln1962">      }</a>
<a name="ln1963"> </a>
<a name="ln1964">      if ( best_blue )</a>
<a name="ln1965">      {</a>
<a name="ln1966">        edge-&gt;blue_edge = best_blue;</a>
<a name="ln1967">        if ( best_blue_is_neutral )</a>
<a name="ln1968">          edge-&gt;flags |= AF_EDGE_NEUTRAL;</a>
<a name="ln1969">      }</a>
<a name="ln1970">    }</a>
<a name="ln1971">  }</a>
<a name="ln1972"> </a>
<a name="ln1973"> </a>
<a name="ln1974">  /* Initalize hinting engine. */</a>
<a name="ln1975"> </a>
<a name="ln1976">  static FT_Error</a>
<a name="ln1977">  af_latin_hints_init( AF_GlyphHints    hints,</a>
<a name="ln1978">                       AF_LatinMetrics  metrics )</a>
<a name="ln1979">  {</a>
<a name="ln1980">    FT_Render_Mode  mode;</a>
<a name="ln1981">    FT_UInt32       scaler_flags, other_flags;</a>
<a name="ln1982">    FT_Face         face = metrics-&gt;root.scaler.face;</a>
<a name="ln1983"> </a>
<a name="ln1984"> </a>
<a name="ln1985">    af_glyph_hints_rescale( hints, (AF_StyleMetrics)metrics );</a>
<a name="ln1986"> </a>
<a name="ln1987">    /*</a>
<a name="ln1988">     *  correct x_scale and y_scale if needed, since they may have</a>
<a name="ln1989">     *  been modified by `af_latin_metrics_scale_dim' above</a>
<a name="ln1990">     */</a>
<a name="ln1991">    hints-&gt;x_scale = metrics-&gt;axis[AF_DIMENSION_HORZ].scale;</a>
<a name="ln1992">    hints-&gt;x_delta = metrics-&gt;axis[AF_DIMENSION_HORZ].delta;</a>
<a name="ln1993">    hints-&gt;y_scale = metrics-&gt;axis[AF_DIMENSION_VERT].scale;</a>
<a name="ln1994">    hints-&gt;y_delta = metrics-&gt;axis[AF_DIMENSION_VERT].delta;</a>
<a name="ln1995"> </a>
<a name="ln1996">    /* compute flags depending on render mode, etc. */</a>
<a name="ln1997">    mode = metrics-&gt;root.scaler.render_mode;</a>
<a name="ln1998"> </a>
<a name="ln1999">#if 0 /* #ifdef AF_CONFIG_OPTION_USE_WARPER */</a>
<a name="ln2000">    if ( mode == FT_RENDER_MODE_LCD || mode == FT_RENDER_MODE_LCD_V )</a>
<a name="ln2001">      metrics-&gt;root.scaler.render_mode = mode = FT_RENDER_MODE_NORMAL;</a>
<a name="ln2002">#endif</a>
<a name="ln2003"> </a>
<a name="ln2004">    scaler_flags = hints-&gt;scaler_flags;</a>
<a name="ln2005">    other_flags  = 0;</a>
<a name="ln2006"> </a>
<a name="ln2007">    /*</a>
<a name="ln2008">     *  We snap the width of vertical stems for the monochrome and</a>
<a name="ln2009">     *  horizontal LCD rendering targets only.</a>
<a name="ln2010">     */</a>
<a name="ln2011">    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD )</a>
<a name="ln2012">      other_flags |= AF_LATIN_HINTS_HORZ_SNAP;</a>
<a name="ln2013"> </a>
<a name="ln2014">    /*</a>
<a name="ln2015">     *  We snap the width of horizontal stems for the monochrome and</a>
<a name="ln2016">     *  vertical LCD rendering targets only.</a>
<a name="ln2017">     */</a>
<a name="ln2018">    if ( mode == FT_RENDER_MODE_MONO || mode == FT_RENDER_MODE_LCD_V )</a>
<a name="ln2019">      other_flags |= AF_LATIN_HINTS_VERT_SNAP;</a>
<a name="ln2020"> </a>
<a name="ln2021">    /*</a>
<a name="ln2022">     *  We adjust stems to full pixels only if we don't use the `light' mode.</a>
<a name="ln2023">     */</a>
<a name="ln2024">    if ( mode != FT_RENDER_MODE_LIGHT )</a>
<a name="ln2025">      other_flags |= AF_LATIN_HINTS_STEM_ADJUST;</a>
<a name="ln2026"> </a>
<a name="ln2027">    if ( mode == FT_RENDER_MODE_MONO )</a>
<a name="ln2028">      other_flags |= AF_LATIN_HINTS_MONO;</a>
<a name="ln2029"> </a>
<a name="ln2030">    /*</a>
<a name="ln2031">     *  In `light' hinting mode we disable horizontal hinting completely.</a>
<a name="ln2032">     *  We also do it if the face is italic.</a>
<a name="ln2033">     *</a>
<a name="ln2034">     *  However, if warping is enabled (which only works in `light' hinting</a>
<a name="ln2035">     *  mode), advance widths get adjusted, too.</a>
<a name="ln2036">     */</a>
<a name="ln2037">    if ( mode == FT_RENDER_MODE_LIGHT                      ||</a>
<a name="ln2038">         ( face-&gt;style_flags &amp; FT_STYLE_FLAG_ITALIC ) != 0 )</a>
<a name="ln2039">      scaler_flags |= AF_SCALER_FLAG_NO_HORIZONTAL;</a>
<a name="ln2040"> </a>
<a name="ln2041">#ifdef AF_CONFIG_OPTION_USE_WARPER</a>
<a name="ln2042">    /* get (global) warper flag */</a>
<a name="ln2043">    if ( !metrics-&gt;root.globals-&gt;module-&gt;warping )</a>
<a name="ln2044">      scaler_flags |= AF_SCALER_FLAG_NO_WARPER;</a>
<a name="ln2045">#endif</a>
<a name="ln2046"> </a>
<a name="ln2047">    hints-&gt;scaler_flags = scaler_flags;</a>
<a name="ln2048">    hints-&gt;other_flags  = other_flags;</a>
<a name="ln2049"> </a>
<a name="ln2050">    return FT_Err_Ok;</a>
<a name="ln2051">  }</a>
<a name="ln2052"> </a>
<a name="ln2053"> </a>
<a name="ln2054">  /*************************************************************************/</a>
<a name="ln2055">  /*************************************************************************/</a>
<a name="ln2056">  /*****                                                               *****/</a>
<a name="ln2057">  /*****        L A T I N   G L Y P H   G R I D - F I T T I N G        *****/</a>
<a name="ln2058">  /*****                                                               *****/</a>
<a name="ln2059">  /*************************************************************************/</a>
<a name="ln2060">  /*************************************************************************/</a>
<a name="ln2061"> </a>
<a name="ln2062">  /* Snap a given width in scaled coordinates to one of the */</a>
<a name="ln2063">  /* current standard widths.                               */</a>
<a name="ln2064"> </a>
<a name="ln2065">  static FT_Pos</a>
<a name="ln2066">  af_latin_snap_width( AF_Width  widths,</a>
<a name="ln2067">                       FT_UInt   count,</a>
<a name="ln2068">                       FT_Pos    width )</a>
<a name="ln2069">  {</a>
<a name="ln2070">    FT_UInt  n;</a>
<a name="ln2071">    FT_Pos   best      = 64 + 32 + 2;</a>
<a name="ln2072">    FT_Pos   reference = width;</a>
<a name="ln2073">    FT_Pos   scaled;</a>
<a name="ln2074"> </a>
<a name="ln2075"> </a>
<a name="ln2076">    for ( n = 0; n &lt; count; n++ )</a>
<a name="ln2077">    {</a>
<a name="ln2078">      FT_Pos  w;</a>
<a name="ln2079">      FT_Pos  dist;</a>
<a name="ln2080"> </a>
<a name="ln2081"> </a>
<a name="ln2082">      w = widths[n].cur;</a>
<a name="ln2083">      dist = width - w;</a>
<a name="ln2084">      if ( dist &lt; 0 )</a>
<a name="ln2085">        dist = -dist;</a>
<a name="ln2086">      if ( dist &lt; best )</a>
<a name="ln2087">      {</a>
<a name="ln2088">        best      = dist;</a>
<a name="ln2089">        reference = w;</a>
<a name="ln2090">      }</a>
<a name="ln2091">    }</a>
<a name="ln2092"> </a>
<a name="ln2093">    scaled = FT_PIX_ROUND( reference );</a>
<a name="ln2094"> </a>
<a name="ln2095">    if ( width &gt;= reference )</a>
<a name="ln2096">    {</a>
<a name="ln2097">      if ( width &lt; scaled + 48 )</a>
<a name="ln2098">        width = reference;</a>
<a name="ln2099">    }</a>
<a name="ln2100">    else</a>
<a name="ln2101">    {</a>
<a name="ln2102">      if ( width &gt; scaled - 48 )</a>
<a name="ln2103">        width = reference;</a>
<a name="ln2104">    }</a>
<a name="ln2105"> </a>
<a name="ln2106">    return width;</a>
<a name="ln2107">  }</a>
<a name="ln2108"> </a>
<a name="ln2109"> </a>
<a name="ln2110">  /* Compute the snapped width of a given stem, ignoring very thin ones. */</a>
<a name="ln2111">  /* There is a lot of voodoo in this function; changing the hard-coded  */</a>
<a name="ln2112">  /* parameters influence the whole hinting process.                     */</a>
<a name="ln2113"> </a>
<a name="ln2114">  static FT_Pos</a>
<a name="ln2115">  af_latin_compute_stem_width( AF_GlyphHints  hints,</a>
<a name="ln2116">                               AF_Dimension   dim,</a>
<a name="ln2117">                               FT_Pos         width,</a>
<a name="ln2118">                               FT_UInt        base_flags,</a>
<a name="ln2119">                               FT_UInt        stem_flags )</a>
<a name="ln2120">  {</a>
<a name="ln2121">    AF_LatinMetrics  metrics  = (AF_LatinMetrics)hints-&gt;metrics;</a>
<a name="ln2122">    AF_LatinAxis     axis     = &amp;metrics-&gt;axis[dim];</a>
<a name="ln2123">    FT_Pos           dist     = width;</a>
<a name="ln2124">    FT_Int           sign     = 0;</a>
<a name="ln2125">    FT_Int           vertical = ( dim == AF_DIMENSION_VERT );</a>
<a name="ln2126"> </a>
<a name="ln2127"> </a>
<a name="ln2128">    if ( !AF_LATIN_HINTS_DO_STEM_ADJUST( hints ) ||</a>
<a name="ln2129">         axis-&gt;extra_light                       )</a>
<a name="ln2130">      return width;</a>
<a name="ln2131"> </a>
<a name="ln2132">    if ( dist &lt; 0 )</a>
<a name="ln2133">    {</a>
<a name="ln2134">      dist = -width;</a>
<a name="ln2135">      sign = 1;</a>
<a name="ln2136">    }</a>
<a name="ln2137"> </a>
<a name="ln2138">    if ( (  vertical &amp;&amp; !AF_LATIN_HINTS_DO_VERT_SNAP( hints ) ) ||</a>
<a name="ln2139">         ( !vertical &amp;&amp; !AF_LATIN_HINTS_DO_HORZ_SNAP( hints ) ) )</a>
<a name="ln2140">    {</a>
<a name="ln2141">      /* smooth hinting process: very lightly quantize the stem width */</a>
<a name="ln2142"> </a>
<a name="ln2143">      /* leave the widths of serifs alone */</a>
<a name="ln2144">      if ( ( stem_flags &amp; AF_EDGE_SERIF ) &amp;&amp;</a>
<a name="ln2145">           vertical                       &amp;&amp;</a>
<a name="ln2146">           ( dist &lt; 3 * 64 )              )</a>
<a name="ln2147">        goto Done_Width;</a>
<a name="ln2148"> </a>
<a name="ln2149">      else if ( base_flags &amp; AF_EDGE_ROUND )</a>
<a name="ln2150">      {</a>
<a name="ln2151">        if ( dist &lt; 80 )</a>
<a name="ln2152">          dist = 64;</a>
<a name="ln2153">      }</a>
<a name="ln2154">      else if ( dist &lt; 56 )</a>
<a name="ln2155">        dist = 56;</a>
<a name="ln2156"> </a>
<a name="ln2157">      if ( axis-&gt;width_count &gt; 0 )</a>
<a name="ln2158">      {</a>
<a name="ln2159">        FT_Pos  delta;</a>
<a name="ln2160"> </a>
<a name="ln2161"> </a>
<a name="ln2162">        /* compare to standard width */</a>
<a name="ln2163">        delta = dist - axis-&gt;widths[0].cur;</a>
<a name="ln2164"> </a>
<a name="ln2165">        if ( delta &lt; 0 )</a>
<a name="ln2166">          delta = -delta;</a>
<a name="ln2167"> </a>
<a name="ln2168">        if ( delta &lt; 40 )</a>
<a name="ln2169">        {</a>
<a name="ln2170">          dist = axis-&gt;widths[0].cur;</a>
<a name="ln2171">          if ( dist &lt; 48 )</a>
<a name="ln2172">            dist = 48;</a>
<a name="ln2173"> </a>
<a name="ln2174">          goto Done_Width;</a>
<a name="ln2175">        }</a>
<a name="ln2176"> </a>
<a name="ln2177">        if ( dist &lt; 3 * 64 )</a>
<a name="ln2178">        {</a>
<a name="ln2179">          delta  = dist &amp; 63;</a>
<a name="ln2180">          dist  &amp;= -64;</a>
<a name="ln2181"> </a>
<a name="ln2182">          if ( delta &lt; 10 )</a>
<a name="ln2183">            dist += delta;</a>
<a name="ln2184"> </a>
<a name="ln2185">          else if ( delta &lt; 32 )</a>
<a name="ln2186">            dist += 10;</a>
<a name="ln2187"> </a>
<a name="ln2188">          else if ( delta &lt; 54 )</a>
<a name="ln2189">            dist += 54;</a>
<a name="ln2190"> </a>
<a name="ln2191">          else</a>
<a name="ln2192">            dist += delta;</a>
<a name="ln2193">        }</a>
<a name="ln2194">        else</a>
<a name="ln2195">          dist = ( dist + 32 ) &amp; ~63;</a>
<a name="ln2196">      }</a>
<a name="ln2197">    }</a>
<a name="ln2198">    else</a>
<a name="ln2199">    {</a>
<a name="ln2200">      /* strong hinting process: snap the stem width to integer pixels */</a>
<a name="ln2201"> </a>
<a name="ln2202">      FT_Pos  org_dist = dist;</a>
<a name="ln2203"> </a>
<a name="ln2204"> </a>
<a name="ln2205">      dist = af_latin_snap_width( axis-&gt;widths, axis-&gt;width_count, dist );</a>
<a name="ln2206"> </a>
<a name="ln2207">      if ( vertical )</a>
<a name="ln2208">      {</a>
<a name="ln2209">        /* in the case of vertical hinting, always round */</a>
<a name="ln2210">        /* the stem heights to integer pixels            */</a>
<a name="ln2211"> </a>
<a name="ln2212">        if ( dist &gt;= 64 )</a>
<a name="ln2213">          dist = ( dist + 16 ) &amp; ~63;</a>
<a name="ln2214">        else</a>
<a name="ln2215">          dist = 64;</a>
<a name="ln2216">      }</a>
<a name="ln2217">      else</a>
<a name="ln2218">      {</a>
<a name="ln2219">        if ( AF_LATIN_HINTS_DO_MONO( hints ) )</a>
<a name="ln2220">        {</a>
<a name="ln2221">          /* monochrome horizontal hinting: snap widths to integer pixels */</a>
<a name="ln2222">          /* with a different threshold                                   */</a>
<a name="ln2223"> </a>
<a name="ln2224">          if ( dist &lt; 64 )</a>
<a name="ln2225">            dist = 64;</a>
<a name="ln2226">          else</a>
<a name="ln2227">            dist = ( dist + 32 ) &amp; ~63;</a>
<a name="ln2228">        }</a>
<a name="ln2229">        else</a>
<a name="ln2230">        {</a>
<a name="ln2231">          /* for horizontal anti-aliased hinting, we adopt a more subtle */</a>
<a name="ln2232">          /* approach: we strengthen small stems, round stems whose size */</a>
<a name="ln2233">          /* is between 1 and 2 pixels to an integer, otherwise nothing  */</a>
<a name="ln2234"> </a>
<a name="ln2235">          if ( dist &lt; 48 )</a>
<a name="ln2236">            dist = ( dist + 64 ) &gt;&gt; 1;</a>
<a name="ln2237"> </a>
<a name="ln2238">          else if ( dist &lt; 128 )</a>
<a name="ln2239">          {</a>
<a name="ln2240">            /* We only round to an integer width if the corresponding */</a>
<a name="ln2241">            /* distortion is less than 1/4 pixel.  Otherwise this     */</a>
<a name="ln2242">            /* makes everything worse since the diagonals, which are  */</a>
<a name="ln2243">            /* not hinted, appear a lot bolder or thinner than the    */</a>
<a name="ln2244">            /* vertical stems.                                        */</a>
<a name="ln2245"> </a>
<a name="ln2246">            FT_Pos  delta;</a>
<a name="ln2247"> </a>
<a name="ln2248"> </a>
<a name="ln2249">            dist = ( dist + 22 ) &amp; ~63;</a>
<a name="ln2250">            delta = dist - org_dist;</a>
<a name="ln2251">            if ( delta &lt; 0 )</a>
<a name="ln2252">              delta = -delta;</a>
<a name="ln2253"> </a>
<a name="ln2254">            if ( delta &gt;= 16 )</a>
<a name="ln2255">            {</a>
<a name="ln2256">              dist = org_dist;</a>
<a name="ln2257">              if ( dist &lt; 48 )</a>
<a name="ln2258">                dist = ( dist + 64 ) &gt;&gt; 1;</a>
<a name="ln2259">            }</a>
<a name="ln2260">          }</a>
<a name="ln2261">          else</a>
<a name="ln2262">            /* round otherwise to prevent color fringes in LCD mode */</a>
<a name="ln2263">            dist = ( dist + 32 ) &amp; ~63;</a>
<a name="ln2264">        }</a>
<a name="ln2265">      }</a>
<a name="ln2266">    }</a>
<a name="ln2267"> </a>
<a name="ln2268">  Done_Width:</a>
<a name="ln2269">    if ( sign )</a>
<a name="ln2270">      dist = -dist;</a>
<a name="ln2271"> </a>
<a name="ln2272">    return dist;</a>
<a name="ln2273">  }</a>
<a name="ln2274"> </a>
<a name="ln2275"> </a>
<a name="ln2276">  /* Align one stem edge relative to the previous stem edge. */</a>
<a name="ln2277"> </a>
<a name="ln2278">  static void</a>
<a name="ln2279">  af_latin_align_linked_edge( AF_GlyphHints  hints,</a>
<a name="ln2280">                              AF_Dimension   dim,</a>
<a name="ln2281">                              AF_Edge        base_edge,</a>
<a name="ln2282">                              AF_Edge        stem_edge )</a>
<a name="ln2283">  {</a>
<a name="ln2284">    FT_Pos  dist = stem_edge-&gt;opos - base_edge-&gt;opos;</a>
<a name="ln2285"> </a>
<a name="ln2286">    FT_Pos  fitted_width = af_latin_compute_stem_width( hints, dim, dist,</a>
<a name="ln2287">                                                        base_edge-&gt;flags,</a>
<a name="ln2288">                                                        stem_edge-&gt;flags );</a>
<a name="ln2289"> </a>
<a name="ln2290"> </a>
<a name="ln2291">    stem_edge-&gt;pos = base_edge-&gt;pos + fitted_width;</a>
<a name="ln2292"> </a>
<a name="ln2293">    FT_TRACE5(( &quot;  LINK: edge %d (opos=%.2f) linked to %.2f,&quot;</a>
<a name="ln2294">                &quot; dist was %.2f, now %.2f\n&quot;,</a>
<a name="ln2295">                stem_edge - hints-&gt;axis[dim].edges, stem_edge-&gt;opos / 64.0,</a>
<a name="ln2296">                stem_edge-&gt;pos / 64.0, dist / 64.0, fitted_width / 64.0 ));</a>
<a name="ln2297">  }</a>
<a name="ln2298"> </a>
<a name="ln2299"> </a>
<a name="ln2300">  /* Shift the coordinates of the `serif' edge by the same amount */</a>
<a name="ln2301">  /* as the corresponding `base' edge has been moved already.     */</a>
<a name="ln2302"> </a>
<a name="ln2303">  static void</a>
<a name="ln2304">  af_latin_align_serif_edge( AF_GlyphHints  hints,</a>
<a name="ln2305">                             AF_Edge        base,</a>
<a name="ln2306">                             AF_Edge        serif )</a>
<a name="ln2307">  {</a>
<a name="ln2308">    FT_UNUSED( hints );</a>
<a name="ln2309"> </a>
<a name="ln2310">    serif-&gt;pos = base-&gt;pos + ( serif-&gt;opos - base-&gt;opos );</a>
<a name="ln2311">  }</a>
<a name="ln2312"> </a>
<a name="ln2313"> </a>
<a name="ln2314">  /*************************************************************************/</a>
<a name="ln2315">  /*************************************************************************/</a>
<a name="ln2316">  /*************************************************************************/</a>
<a name="ln2317">  /****                                                                 ****/</a>
<a name="ln2318">  /****                    E D G E   H I N T I N G                      ****/</a>
<a name="ln2319">  /****                                                                 ****/</a>
<a name="ln2320">  /*************************************************************************/</a>
<a name="ln2321">  /*************************************************************************/</a>
<a name="ln2322">  /*************************************************************************/</a>
<a name="ln2323"> </a>
<a name="ln2324"> </a>
<a name="ln2325">  /* The main grid-fitting routine. */</a>
<a name="ln2326"> </a>
<a name="ln2327">  static void</a>
<a name="ln2328">  af_latin_hint_edges( AF_GlyphHints  hints,</a>
<a name="ln2329">                       AF_Dimension   dim )</a>
<a name="ln2330">  {</a>
<a name="ln2331">    AF_AxisHints  axis       = &amp;hints-&gt;axis[dim];</a>
<a name="ln2332">    AF_Edge       edges      = axis-&gt;edges;</a>
<a name="ln2333">    AF_Edge       edge_limit = edges + axis-&gt;num_edges;</a>
<a name="ln2334">    FT_PtrDist    n_edges;</a>
<a name="ln2335">    AF_Edge       edge;</a>
<a name="ln2336">    AF_Edge       anchor     = NULL;</a>
<a name="ln2337">    FT_Int        has_serifs = 0;</a>
<a name="ln2338"> </a>
<a name="ln2339">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2340">    FT_UInt       num_actions = 0;</a>
<a name="ln2341">#endif</a>
<a name="ln2342"> </a>
<a name="ln2343"> </a>
<a name="ln2344">    FT_TRACE5(( &quot;latin %s edge hinting (style `%s')\n&quot;,</a>
<a name="ln2345">                dim == AF_DIMENSION_VERT ? &quot;horizontal&quot; : &quot;vertical&quot;,</a>
<a name="ln2346">                af_style_names[hints-&gt;metrics-&gt;style_class-&gt;style] ));</a>
<a name="ln2347"> </a>
<a name="ln2348">    /* we begin by aligning all stems relative to the blue zone */</a>
<a name="ln2349">    /* if needed -- that's only for horizontal edges            */</a>
<a name="ln2350"> </a>
<a name="ln2351">    if ( dim == AF_DIMENSION_VERT &amp;&amp; AF_HINTS_DO_BLUES( hints ) )</a>
<a name="ln2352">    {</a>
<a name="ln2353">      for ( edge = edges; edge &lt; edge_limit; edge++ )</a>
<a name="ln2354">      {</a>
<a name="ln2355">        AF_Width  blue;</a>
<a name="ln2356">        AF_Edge   edge1, edge2; /* these edges form the stem to check */</a>
<a name="ln2357"> </a>
<a name="ln2358"> </a>
<a name="ln2359">        if ( edge-&gt;flags &amp; AF_EDGE_DONE )</a>
<a name="ln2360">          continue;</a>
<a name="ln2361"> </a>
<a name="ln2362">        edge1 = NULL;</a>
<a name="ln2363">        edge2 = edge-&gt;link;</a>
<a name="ln2364"> </a>
<a name="ln2365">        /*</a>
<a name="ln2366">         *  If a stem contains both a neutral and a non-neutral blue zone,</a>
<a name="ln2367">         *  skip the neutral one.  Otherwise, outlines with different</a>
<a name="ln2368">         *  directions might be incorrectly aligned at the same vertical</a>
<a name="ln2369">         *  position.</a>
<a name="ln2370">         *</a>
<a name="ln2371">         *  If we have two neutral blue zones, skip one of them.</a>
<a name="ln2372">         *</a>
<a name="ln2373">         */</a>
<a name="ln2374">        if ( edge-&gt;blue_edge &amp;&amp; edge2 &amp;&amp; edge2-&gt;blue_edge )</a>
<a name="ln2375">        {</a>
<a name="ln2376">          FT_Byte  neutral  = edge-&gt;flags  &amp; AF_EDGE_NEUTRAL;</a>
<a name="ln2377">          FT_Byte  neutral2 = edge2-&gt;flags &amp; AF_EDGE_NEUTRAL;</a>
<a name="ln2378"> </a>
<a name="ln2379"> </a>
<a name="ln2380">          if ( neutral2 )</a>
<a name="ln2381">          {</a>
<a name="ln2382">            edge2-&gt;blue_edge = NULL;</a>
<a name="ln2383">            edge2-&gt;flags    &amp;= ~AF_EDGE_NEUTRAL;</a>
<a name="ln2384">          }</a>
<a name="ln2385">          else if ( neutral )</a>
<a name="ln2386">          {</a>
<a name="ln2387">            edge-&gt;blue_edge = NULL;</a>
<a name="ln2388">            edge-&gt;flags    &amp;= ~AF_EDGE_NEUTRAL;</a>
<a name="ln2389">          }</a>
<a name="ln2390">        }</a>
<a name="ln2391"> </a>
<a name="ln2392">        blue = edge-&gt;blue_edge;</a>
<a name="ln2393">        if ( blue )</a>
<a name="ln2394">          edge1 = edge;</a>
<a name="ln2395"> </a>
<a name="ln2396">        /* flip edges if the other edge is aligned to a blue zone */</a>
<a name="ln2397">        else if ( edge2 &amp;&amp; edge2-&gt;blue_edge )</a>
<a name="ln2398">        {</a>
<a name="ln2399">          blue  = edge2-&gt;blue_edge;</a>
<a name="ln2400">          edge1 = edge2;</a>
<a name="ln2401">          edge2 = edge;</a>
<a name="ln2402">        }</a>
<a name="ln2403"> </a>
<a name="ln2404">        if ( !edge1 )</a>
<a name="ln2405">          continue;</a>
<a name="ln2406"> </a>
<a name="ln2407">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2408">        if ( !anchor )</a>
<a name="ln2409">          FT_TRACE5(( &quot;  BLUE_ANCHOR: edge %d (opos=%.2f) snapped to %.2f,&quot;</a>
<a name="ln2410">                      &quot; was %.2f (anchor=edge %d)\n&quot;,</a>
<a name="ln2411">                      edge1 - edges, edge1-&gt;opos / 64.0, blue-&gt;fit / 64.0,</a>
<a name="ln2412">                      edge1-&gt;pos / 64.0, edge - edges ));</a>
<a name="ln2413">        else</a>
<a name="ln2414">          FT_TRACE5(( &quot;  BLUE: edge %d (opos=%.2f) snapped to %.2f,&quot;</a>
<a name="ln2415">                      &quot; was %.2f\n&quot;,</a>
<a name="ln2416">                      edge1 - edges, edge1-&gt;opos / 64.0, blue-&gt;fit / 64.0,</a>
<a name="ln2417">                      edge1-&gt;pos / 64.0 ));</a>
<a name="ln2418"> </a>
<a name="ln2419">        num_actions++;</a>
<a name="ln2420">#endif</a>
<a name="ln2421"> </a>
<a name="ln2422">        edge1-&gt;pos    = blue-&gt;fit;</a>
<a name="ln2423">        edge1-&gt;flags |= AF_EDGE_DONE;</a>
<a name="ln2424"> </a>
<a name="ln2425">        if ( edge2 &amp;&amp; !edge2-&gt;blue_edge )</a>
<a name="ln2426">        {</a>
<a name="ln2427">          af_latin_align_linked_edge( hints, dim, edge1, edge2 );</a>
<a name="ln2428">          edge2-&gt;flags |= AF_EDGE_DONE;</a>
<a name="ln2429"> </a>
<a name="ln2430">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2431">          num_actions++;</a>
<a name="ln2432">#endif</a>
<a name="ln2433">        }</a>
<a name="ln2434"> </a>
<a name="ln2435">        if ( !anchor )</a>
<a name="ln2436">          anchor = edge;</a>
<a name="ln2437">      }</a>
<a name="ln2438">    }</a>
<a name="ln2439"> </a>
<a name="ln2440">    /* now we align all other stem edges, trying to maintain the */</a>
<a name="ln2441">    /* relative order of stems in the glyph                      */</a>
<a name="ln2442">    for ( edge = edges; edge &lt; edge_limit; edge++ )</a>
<a name="ln2443">    {</a>
<a name="ln2444">      AF_Edge  edge2;</a>
<a name="ln2445"> </a>
<a name="ln2446"> </a>
<a name="ln2447">      if ( edge-&gt;flags &amp; AF_EDGE_DONE )</a>
<a name="ln2448">        continue;</a>
<a name="ln2449"> </a>
<a name="ln2450">      /* skip all non-stem edges */</a>
<a name="ln2451">      edge2 = edge-&gt;link;</a>
<a name="ln2452">      if ( !edge2 )</a>
<a name="ln2453">      {</a>
<a name="ln2454">        has_serifs++;</a>
<a name="ln2455">        continue;</a>
<a name="ln2456">      }</a>
<a name="ln2457"> </a>
<a name="ln2458">      /* now align the stem */</a>
<a name="ln2459"> </a>
<a name="ln2460">      /* this should not happen, but it's better to be safe */</a>
<a name="ln2461">      if ( edge2-&gt;blue_edge )</a>
<a name="ln2462">      {</a>
<a name="ln2463">        FT_TRACE5(( &quot;  ASSERTION FAILED for edge %d\n&quot;, edge2 - edges ));</a>
<a name="ln2464"> </a>
<a name="ln2465">        af_latin_align_linked_edge( hints, dim, edge2, edge );</a>
<a name="ln2466">        edge-&gt;flags |= AF_EDGE_DONE;</a>
<a name="ln2467"> </a>
<a name="ln2468">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2469">        num_actions++;</a>
<a name="ln2470">#endif</a>
<a name="ln2471">        continue;</a>
<a name="ln2472">      }</a>
<a name="ln2473"> </a>
<a name="ln2474">      if ( !anchor )</a>
<a name="ln2475">      {</a>
<a name="ln2476">        /* if we reach this if clause, no stem has been aligned yet */</a>
<a name="ln2477"> </a>
<a name="ln2478">        FT_Pos  org_len, org_center, cur_len;</a>
<a name="ln2479">        FT_Pos  cur_pos1, error1, error2, u_off, d_off;</a>
<a name="ln2480"> </a>
<a name="ln2481"> </a>
<a name="ln2482">        org_len = edge2-&gt;opos - edge-&gt;opos;</a>
<a name="ln2483">        cur_len = af_latin_compute_stem_width( hints, dim, org_len,</a>
<a name="ln2484">                                               edge-&gt;flags,</a>
<a name="ln2485">                                               edge2-&gt;flags );</a>
<a name="ln2486"> </a>
<a name="ln2487">        /* some voodoo to specially round edges for small stem widths; */</a>
<a name="ln2488">        /* the idea is to align the center of a stem, then shifting    */</a>
<a name="ln2489">        /* the stem edges to suitable positions                        */</a>
<a name="ln2490">        if ( cur_len &lt;= 64 )</a>
<a name="ln2491">        {</a>
<a name="ln2492">          /* width &lt;= 1px */</a>
<a name="ln2493">          u_off = 32;</a>
<a name="ln2494">          d_off = 32;</a>
<a name="ln2495">        }</a>
<a name="ln2496">        else</a>
<a name="ln2497">        {</a>
<a name="ln2498">          /* 1px &lt; width &lt; 1.5px */</a>
<a name="ln2499">          u_off = 38;</a>
<a name="ln2500">          d_off = 26;</a>
<a name="ln2501">        }</a>
<a name="ln2502"> </a>
<a name="ln2503">        if ( cur_len &lt; 96 )</a>
<a name="ln2504">        {</a>
<a name="ln2505">          org_center = edge-&gt;opos + ( org_len &gt;&gt; 1 );</a>
<a name="ln2506">          cur_pos1   = FT_PIX_ROUND( org_center );</a>
<a name="ln2507"> </a>
<a name="ln2508">          error1 = org_center - ( cur_pos1 - u_off );</a>
<a name="ln2509">          if ( error1 &lt; 0 )</a>
<a name="ln2510">            error1 = -error1;</a>
<a name="ln2511"> </a>
<a name="ln2512">          error2 = org_center - ( cur_pos1 + d_off );</a>
<a name="ln2513">          if ( error2 &lt; 0 )</a>
<a name="ln2514">            error2 = -error2;</a>
<a name="ln2515"> </a>
<a name="ln2516">          if ( error1 &lt; error2 )</a>
<a name="ln2517">            cur_pos1 -= u_off;</a>
<a name="ln2518">          else</a>
<a name="ln2519">            cur_pos1 += d_off;</a>
<a name="ln2520"> </a>
<a name="ln2521">          edge-&gt;pos  = cur_pos1 - cur_len / 2;</a>
<a name="ln2522">          edge2-&gt;pos = edge-&gt;pos + cur_len;</a>
<a name="ln2523">        }</a>
<a name="ln2524">        else</a>
<a name="ln2525">          edge-&gt;pos = FT_PIX_ROUND( edge-&gt;opos );</a>
<a name="ln2526"> </a>
<a name="ln2527">        anchor       = edge;</a>
<a name="ln2528">        edge-&gt;flags |= AF_EDGE_DONE;</a>
<a name="ln2529"> </a>
<a name="ln2530">        FT_TRACE5(( &quot;  ANCHOR: edge %d (opos=%.2f) and %d (opos=%.2f)&quot;</a>
<a name="ln2531">                    &quot; snapped to %.2f and %.2f\n&quot;,</a>
<a name="ln2532">                    edge - edges, edge-&gt;opos / 64.0,</a>
<a name="ln2533">                    edge2 - edges, edge2-&gt;opos / 64.0,</a>
<a name="ln2534">                    edge-&gt;pos / 64.0, edge2-&gt;pos / 64.0 ));</a>
<a name="ln2535"> </a>
<a name="ln2536">        af_latin_align_linked_edge( hints, dim, edge, edge2 );</a>
<a name="ln2537"> </a>
<a name="ln2538">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2539">        num_actions += 2;</a>
<a name="ln2540">#endif</a>
<a name="ln2541">      }</a>
<a name="ln2542">      else</a>
<a name="ln2543">      {</a>
<a name="ln2544">        FT_Pos  org_pos, org_len, org_center, cur_len;</a>
<a name="ln2545">        FT_Pos  cur_pos1, cur_pos2, delta1, delta2;</a>
<a name="ln2546"> </a>
<a name="ln2547"> </a>
<a name="ln2548">        org_pos    = anchor-&gt;pos + ( edge-&gt;opos - anchor-&gt;opos );</a>
<a name="ln2549">        org_len    = edge2-&gt;opos - edge-&gt;opos;</a>
<a name="ln2550">        org_center = org_pos + ( org_len &gt;&gt; 1 );</a>
<a name="ln2551"> </a>
<a name="ln2552">        cur_len = af_latin_compute_stem_width( hints, dim, org_len,</a>
<a name="ln2553">                                               edge-&gt;flags,</a>
<a name="ln2554">                                               edge2-&gt;flags );</a>
<a name="ln2555"> </a>
<a name="ln2556">        if ( edge2-&gt;flags &amp; AF_EDGE_DONE )</a>
<a name="ln2557">        {</a>
<a name="ln2558">          FT_TRACE5(( &quot;  ADJUST: edge %d (pos=%.2f) moved to %.2f\n&quot;,</a>
<a name="ln2559">                      edge - edges, edge-&gt;pos / 64.0,</a>
<a name="ln2560">                      ( edge2-&gt;pos - cur_len ) / 64.0 ));</a>
<a name="ln2561"> </a>
<a name="ln2562">          edge-&gt;pos = edge2-&gt;pos - cur_len;</a>
<a name="ln2563">        }</a>
<a name="ln2564"> </a>
<a name="ln2565">        else if ( cur_len &lt; 96 )</a>
<a name="ln2566">        {</a>
<a name="ln2567">          FT_Pos  u_off, d_off;</a>
<a name="ln2568"> </a>
<a name="ln2569"> </a>
<a name="ln2570">          cur_pos1 = FT_PIX_ROUND( org_center );</a>
<a name="ln2571"> </a>
<a name="ln2572">          if ( cur_len &lt;= 64 )</a>
<a name="ln2573">          {</a>
<a name="ln2574">            u_off = 32;</a>
<a name="ln2575">            d_off = 32;</a>
<a name="ln2576">          }</a>
<a name="ln2577">          else</a>
<a name="ln2578">          {</a>
<a name="ln2579">            u_off = 38;</a>
<a name="ln2580">            d_off = 26;</a>
<a name="ln2581">          }</a>
<a name="ln2582"> </a>
<a name="ln2583">          delta1 = org_center - ( cur_pos1 - u_off );</a>
<a name="ln2584">          if ( delta1 &lt; 0 )</a>
<a name="ln2585">            delta1 = -delta1;</a>
<a name="ln2586"> </a>
<a name="ln2587">          delta2 = org_center - ( cur_pos1 + d_off );</a>
<a name="ln2588">          if ( delta2 &lt; 0 )</a>
<a name="ln2589">            delta2 = -delta2;</a>
<a name="ln2590"> </a>
<a name="ln2591">          if ( delta1 &lt; delta2 )</a>
<a name="ln2592">            cur_pos1 -= u_off;</a>
<a name="ln2593">          else</a>
<a name="ln2594">            cur_pos1 += d_off;</a>
<a name="ln2595"> </a>
<a name="ln2596">          edge-&gt;pos  = cur_pos1 - cur_len / 2;</a>
<a name="ln2597">          edge2-&gt;pos = cur_pos1 + cur_len / 2;</a>
<a name="ln2598"> </a>
<a name="ln2599">          FT_TRACE5(( &quot;  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)&quot;</a>
<a name="ln2600">                      &quot; snapped to %.2f and %.2f\n&quot;,</a>
<a name="ln2601">                      edge - edges, edge-&gt;opos / 64.0,</a>
<a name="ln2602">                      edge2 - edges, edge2-&gt;opos / 64.0,</a>
<a name="ln2603">                      edge-&gt;pos / 64.0, edge2-&gt;pos / 64.0 ));</a>
<a name="ln2604">        }</a>
<a name="ln2605"> </a>
<a name="ln2606">        else</a>
<a name="ln2607">        {</a>
<a name="ln2608">          org_pos    = anchor-&gt;pos + ( edge-&gt;opos - anchor-&gt;opos );</a>
<a name="ln2609">          org_len    = edge2-&gt;opos - edge-&gt;opos;</a>
<a name="ln2610">          org_center = org_pos + ( org_len &gt;&gt; 1 );</a>
<a name="ln2611"> </a>
<a name="ln2612">          cur_len    = af_latin_compute_stem_width( hints, dim, org_len,</a>
<a name="ln2613">                                                    edge-&gt;flags,</a>
<a name="ln2614">                                                    edge2-&gt;flags );</a>
<a name="ln2615"> </a>
<a name="ln2616">          cur_pos1 = FT_PIX_ROUND( org_pos );</a>
<a name="ln2617">          delta1   = cur_pos1 + ( cur_len &gt;&gt; 1 ) - org_center;</a>
<a name="ln2618">          if ( delta1 &lt; 0 )</a>
<a name="ln2619">            delta1 = -delta1;</a>
<a name="ln2620"> </a>
<a name="ln2621">          cur_pos2 = FT_PIX_ROUND( org_pos + org_len ) - cur_len;</a>
<a name="ln2622">          delta2   = cur_pos2 + ( cur_len &gt;&gt; 1 ) - org_center;</a>
<a name="ln2623">          if ( delta2 &lt; 0 )</a>
<a name="ln2624">            delta2 = -delta2;</a>
<a name="ln2625"> </a>
<a name="ln2626">          edge-&gt;pos  = ( delta1 &lt; delta2 ) ? cur_pos1 : cur_pos2;</a>
<a name="ln2627">          edge2-&gt;pos = edge-&gt;pos + cur_len;</a>
<a name="ln2628"> </a>
<a name="ln2629">          FT_TRACE5(( &quot;  STEM: edge %d (opos=%.2f) linked to %d (opos=%.2f)&quot;</a>
<a name="ln2630">                      &quot; snapped to %.2f and %.2f\n&quot;,</a>
<a name="ln2631">                      edge - edges, edge-&gt;opos / 64.0,</a>
<a name="ln2632">                      edge2 - edges, edge2-&gt;opos / 64.0,</a>
<a name="ln2633">                      edge-&gt;pos / 64.0, edge2-&gt;pos / 64.0 ));</a>
<a name="ln2634">        }</a>
<a name="ln2635"> </a>
<a name="ln2636">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2637">        num_actions++;</a>
<a name="ln2638">#endif</a>
<a name="ln2639"> </a>
<a name="ln2640">        edge-&gt;flags  |= AF_EDGE_DONE;</a>
<a name="ln2641">        edge2-&gt;flags |= AF_EDGE_DONE;</a>
<a name="ln2642"> </a>
<a name="ln2643">        if ( edge &gt; edges &amp;&amp; edge-&gt;pos &lt; edge[-1].pos )</a>
<a name="ln2644">        {</a>
<a name="ln2645">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2646">          FT_TRACE5(( &quot;  BOUND: edge %d (pos=%.2f) moved to %.2f\n&quot;,</a>
<a name="ln2647">                      edge - edges, edge-&gt;pos / 64.0, edge[-1].pos / 64.0 ));</a>
<a name="ln2648"> </a>
<a name="ln2649">          num_actions++;</a>
<a name="ln2650">#endif</a>
<a name="ln2651"> </a>
<a name="ln2652">          edge-&gt;pos = edge[-1].pos;</a>
<a name="ln2653">        }</a>
<a name="ln2654">      }</a>
<a name="ln2655">    }</a>
<a name="ln2656"> </a>
<a name="ln2657">    /* make sure that lowercase m's maintain their symmetry */</a>
<a name="ln2658"> </a>
<a name="ln2659">    /* In general, lowercase m's have six vertical edges if they are sans */</a>
<a name="ln2660">    /* serif, or twelve if they are with serifs.  This implementation is  */</a>
<a name="ln2661">    /* based on that assumption, and seems to work very well with most    */</a>
<a name="ln2662">    /* faces.  However, if for a certain face this assumption is not      */</a>
<a name="ln2663">    /* true, the m is just rendered like before.  In addition, any stem   */</a>
<a name="ln2664">    /* correction will only be applied to symmetrical glyphs (even if the */</a>
<a name="ln2665">    /* glyph is not an m), so the potential for unwanted distortion is    */</a>
<a name="ln2666">    /* relatively low.                                                    */</a>
<a name="ln2667"> </a>
<a name="ln2668">    /* We don't handle horizontal edges since we can't easily assure that */</a>
<a name="ln2669">    /* the third (lowest) stem aligns with the base line; it might end up */</a>
<a name="ln2670">    /* one pixel higher or lower.                                         */</a>
<a name="ln2671"> </a>
<a name="ln2672">    n_edges = edge_limit - edges;</a>
<a name="ln2673">    if ( dim == AF_DIMENSION_HORZ &amp;&amp; ( n_edges == 6 || n_edges == 12 ) )</a>
<a name="ln2674">    {</a>
<a name="ln2675">      AF_Edge  edge1, edge2, edge3;</a>
<a name="ln2676">      FT_Pos   dist1, dist2, span, delta;</a>
<a name="ln2677"> </a>
<a name="ln2678"> </a>
<a name="ln2679">      if ( n_edges == 6 )</a>
<a name="ln2680">      {</a>
<a name="ln2681">        edge1 = edges;</a>
<a name="ln2682">        edge2 = edges + 2;</a>
<a name="ln2683">        edge3 = edges + 4;</a>
<a name="ln2684">      }</a>
<a name="ln2685">      else</a>
<a name="ln2686">      {</a>
<a name="ln2687">        edge1 = edges + 1;</a>
<a name="ln2688">        edge2 = edges + 5;</a>
<a name="ln2689">        edge3 = edges + 9;</a>
<a name="ln2690">      }</a>
<a name="ln2691"> </a>
<a name="ln2692">      dist1 = edge2-&gt;opos - edge1-&gt;opos;</a>
<a name="ln2693">      dist2 = edge3-&gt;opos - edge2-&gt;opos;</a>
<a name="ln2694"> </a>
<a name="ln2695">      span = dist1 - dist2;</a>
<a name="ln2696">      if ( span &lt; 0 )</a>
<a name="ln2697">        span = -span;</a>
<a name="ln2698"> </a>
<a name="ln2699">      if ( span &lt; 8 )</a>
<a name="ln2700">      {</a>
<a name="ln2701">        delta = edge3-&gt;pos - ( 2 * edge2-&gt;pos - edge1-&gt;pos );</a>
<a name="ln2702">        edge3-&gt;pos -= delta;</a>
<a name="ln2703">        if ( edge3-&gt;link )</a>
<a name="ln2704">          edge3-&gt;link-&gt;pos -= delta;</a>
<a name="ln2705"> </a>
<a name="ln2706">        /* move the serifs along with the stem */</a>
<a name="ln2707">        if ( n_edges == 12 )</a>
<a name="ln2708">        {</a>
<a name="ln2709">          ( edges + 8 )-&gt;pos -= delta;</a>
<a name="ln2710">          ( edges + 11 )-&gt;pos -= delta;</a>
<a name="ln2711">        }</a>
<a name="ln2712"> </a>
<a name="ln2713">        edge3-&gt;flags |= AF_EDGE_DONE;</a>
<a name="ln2714">        if ( edge3-&gt;link )</a>
<a name="ln2715">          edge3-&gt;link-&gt;flags |= AF_EDGE_DONE;</a>
<a name="ln2716">      }</a>
<a name="ln2717">    }</a>
<a name="ln2718"> </a>
<a name="ln2719">    if ( has_serifs || !anchor )</a>
<a name="ln2720">    {</a>
<a name="ln2721">      /*</a>
<a name="ln2722">       *  now hint the remaining edges (serifs and single) in order</a>
<a name="ln2723">       *  to complete our processing</a>
<a name="ln2724">       */</a>
<a name="ln2725">      for ( edge = edges; edge &lt; edge_limit; edge++ )</a>
<a name="ln2726">      {</a>
<a name="ln2727">        FT_Pos  delta;</a>
<a name="ln2728"> </a>
<a name="ln2729"> </a>
<a name="ln2730">        if ( edge-&gt;flags &amp; AF_EDGE_DONE )</a>
<a name="ln2731">          continue;</a>
<a name="ln2732"> </a>
<a name="ln2733">        delta = 1000;</a>
<a name="ln2734"> </a>
<a name="ln2735">        if ( edge-&gt;serif )</a>
<a name="ln2736">        {</a>
<a name="ln2737">          delta = edge-&gt;serif-&gt;opos - edge-&gt;opos;</a>
<a name="ln2738">          if ( delta &lt; 0 )</a>
<a name="ln2739">            delta = -delta;</a>
<a name="ln2740">        }</a>
<a name="ln2741"> </a>
<a name="ln2742">        if ( delta &lt; 64 + 16 )</a>
<a name="ln2743">        {</a>
<a name="ln2744">          af_latin_align_serif_edge( hints, edge-&gt;serif, edge );</a>
<a name="ln2745">          FT_TRACE5(( &quot;  SERIF: edge %d (opos=%.2f) serif to %d (opos=%.2f)&quot;</a>
<a name="ln2746">                      &quot; aligned to %.2f\n&quot;,</a>
<a name="ln2747">                      edge - edges, edge-&gt;opos / 64.0,</a>
<a name="ln2748">                      edge-&gt;serif - edges, edge-&gt;serif-&gt;opos / 64.0,</a>
<a name="ln2749">                      edge-&gt;pos / 64.0 ));</a>
<a name="ln2750">        }</a>
<a name="ln2751">        else if ( !anchor )</a>
<a name="ln2752">        {</a>
<a name="ln2753">          edge-&gt;pos = FT_PIX_ROUND( edge-&gt;opos );</a>
<a name="ln2754">          anchor    = edge;</a>
<a name="ln2755">          FT_TRACE5(( &quot;  SERIF_ANCHOR: edge %d (opos=%.2f)&quot;</a>
<a name="ln2756">                      &quot; snapped to %.2f\n&quot;,</a>
<a name="ln2757">                      edge-edges, edge-&gt;opos / 64.0, edge-&gt;pos / 64.0 ));</a>
<a name="ln2758">        }</a>
<a name="ln2759">        else</a>
<a name="ln2760">        {</a>
<a name="ln2761">          AF_Edge  before, after;</a>
<a name="ln2762"> </a>
<a name="ln2763"> </a>
<a name="ln2764">          for ( before = edge - 1; before &gt;= edges; before-- )</a>
<a name="ln2765">            if ( before-&gt;flags &amp; AF_EDGE_DONE )</a>
<a name="ln2766">              break;</a>
<a name="ln2767"> </a>
<a name="ln2768">          for ( after = edge + 1; after &lt; edge_limit; after++ )</a>
<a name="ln2769">            if ( after-&gt;flags &amp; AF_EDGE_DONE )</a>
<a name="ln2770">              break;</a>
<a name="ln2771"> </a>
<a name="ln2772">          if ( before &gt;= edges &amp;&amp; before &lt; edge   &amp;&amp;</a>
<a name="ln2773">               after &lt; edge_limit &amp;&amp; after &gt; edge )</a>
<a name="ln2774">          {</a>
<a name="ln2775">            if ( after-&gt;opos == before-&gt;opos )</a>
<a name="ln2776">              edge-&gt;pos = before-&gt;pos;</a>
<a name="ln2777">            else</a>
<a name="ln2778">              edge-&gt;pos = before-&gt;pos +</a>
<a name="ln2779">                          FT_MulDiv( edge-&gt;opos - before-&gt;opos,</a>
<a name="ln2780">                                     after-&gt;pos - before-&gt;pos,</a>
<a name="ln2781">                                     after-&gt;opos - before-&gt;opos );</a>
<a name="ln2782"> </a>
<a name="ln2783">            FT_TRACE5(( &quot;  SERIF_LINK1: edge %d (opos=%.2f) snapped to %.2f&quot;</a>
<a name="ln2784">                        &quot; from %d (opos=%.2f)\n&quot;,</a>
<a name="ln2785">                        edge - edges, edge-&gt;opos / 64.0,</a>
<a name="ln2786">                        edge-&gt;pos / 64.0,</a>
<a name="ln2787">                        before - edges, before-&gt;opos / 64.0 ));</a>
<a name="ln2788">          }</a>
<a name="ln2789">          else</a>
<a name="ln2790">          {</a>
<a name="ln2791">            edge-&gt;pos = anchor-&gt;pos +</a>
<a name="ln2792">                        ( ( edge-&gt;opos - anchor-&gt;opos + 16 ) &amp; ~31 );</a>
<a name="ln2793">            FT_TRACE5(( &quot;  SERIF_LINK2: edge %d (opos=%.2f)&quot;</a>
<a name="ln2794">                        &quot; snapped to %.2f\n&quot;,</a>
<a name="ln2795">                        edge - edges, edge-&gt;opos / 64.0, edge-&gt;pos / 64.0 ));</a>
<a name="ln2796">          }</a>
<a name="ln2797">        }</a>
<a name="ln2798"> </a>
<a name="ln2799">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2800">        num_actions++;</a>
<a name="ln2801">#endif</a>
<a name="ln2802">        edge-&gt;flags |= AF_EDGE_DONE;</a>
<a name="ln2803"> </a>
<a name="ln2804">        if ( edge &gt; edges &amp;&amp; edge-&gt;pos &lt; edge[-1].pos )</a>
<a name="ln2805">        {</a>
<a name="ln2806">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2807">          FT_TRACE5(( &quot;  BOUND: edge %d (pos=%.2f) moved to %.2f\n&quot;,</a>
<a name="ln2808">                      edge - edges, edge-&gt;pos / 64.0, edge[-1].pos / 64.0 ));</a>
<a name="ln2809"> </a>
<a name="ln2810">          num_actions++;</a>
<a name="ln2811">#endif</a>
<a name="ln2812">          edge-&gt;pos = edge[-1].pos;</a>
<a name="ln2813">        }</a>
<a name="ln2814"> </a>
<a name="ln2815">        if ( edge + 1 &lt; edge_limit        &amp;&amp;</a>
<a name="ln2816">             edge[1].flags &amp; AF_EDGE_DONE &amp;&amp;</a>
<a name="ln2817">             edge-&gt;pos &gt; edge[1].pos      )</a>
<a name="ln2818">        {</a>
<a name="ln2819">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2820">          FT_TRACE5(( &quot;  BOUND: edge %d (pos=%.2f) moved to %.2f\n&quot;,</a>
<a name="ln2821">                      edge - edges, edge-&gt;pos / 64.0, edge[1].pos / 64.0 ));</a>
<a name="ln2822"> </a>
<a name="ln2823">          num_actions++;</a>
<a name="ln2824">#endif</a>
<a name="ln2825"> </a>
<a name="ln2826">          edge-&gt;pos = edge[1].pos;</a>
<a name="ln2827">        }</a>
<a name="ln2828">      }</a>
<a name="ln2829">    }</a>
<a name="ln2830"> </a>
<a name="ln2831">#ifdef FT_DEBUG_LEVEL_TRACE</a>
<a name="ln2832">    if ( !num_actions )</a>
<a name="ln2833">      FT_TRACE5(( &quot;  (none)\n&quot; ));</a>
<a name="ln2834">    FT_TRACE5(( &quot;\n&quot; ));</a>
<a name="ln2835">#endif</a>
<a name="ln2836">  }</a>
<a name="ln2837"> </a>
<a name="ln2838"> </a>
<a name="ln2839">  /* Apply the complete hinting algorithm to a latin glyph. */</a>
<a name="ln2840"> </a>
<a name="ln2841">  static FT_Error</a>
<a name="ln2842">  af_latin_hints_apply( FT_UInt          glyph_index,</a>
<a name="ln2843">                        AF_GlyphHints    hints,</a>
<a name="ln2844">                        FT_Outline*      outline,</a>
<a name="ln2845">                        AF_LatinMetrics  metrics )</a>
<a name="ln2846">  {</a>
<a name="ln2847">    FT_Error  error;</a>
<a name="ln2848">    int       dim;</a>
<a name="ln2849"> </a>
<a name="ln2850">    AF_LatinAxis  axis;</a>
<a name="ln2851"> </a>
<a name="ln2852"> </a>
<a name="ln2853">    error = af_glyph_hints_reload( hints, outline );</a>
<a name="ln2854">    if ( error )</a>
<a name="ln2855">      goto Exit;</a>
<a name="ln2856"> </a>
<a name="ln2857">    /* analyze glyph outline */</a>
<a name="ln2858">#ifdef AF_CONFIG_OPTION_USE_WARPER</a>
<a name="ln2859">    if ( ( metrics-&gt;root.scaler.render_mode == FT_RENDER_MODE_LIGHT &amp;&amp;</a>
<a name="ln2860">           AF_HINTS_DO_WARP( hints )                                ) ||</a>
<a name="ln2861">         AF_HINTS_DO_HORIZONTAL( hints )                              )</a>
<a name="ln2862">#else</a>
<a name="ln2863">    if ( AF_HINTS_DO_HORIZONTAL( hints ) )</a>
<a name="ln2864">#endif</a>
<a name="ln2865">    {</a>
<a name="ln2866">      axis  = &amp;metrics-&gt;axis[AF_DIMENSION_HORZ];</a>
<a name="ln2867">      error = af_latin_hints_detect_features( hints,</a>
<a name="ln2868">                                              axis-&gt;width_count,</a>
<a name="ln2869">                                              axis-&gt;widths,</a>
<a name="ln2870">                                              AF_DIMENSION_HORZ );</a>
<a name="ln2871">      if ( error )</a>
<a name="ln2872">        goto Exit;</a>
<a name="ln2873">    }</a>
<a name="ln2874"> </a>
<a name="ln2875">    if ( AF_HINTS_DO_VERTICAL( hints ) )</a>
<a name="ln2876">    {</a>
<a name="ln2877">      axis  = &amp;metrics-&gt;axis[AF_DIMENSION_VERT];</a>
<a name="ln2878">      error = af_latin_hints_detect_features( hints,</a>
<a name="ln2879">                                              axis-&gt;width_count,</a>
<a name="ln2880">                                              axis-&gt;widths,</a>
<a name="ln2881">                                              AF_DIMENSION_VERT );</a>
<a name="ln2882">      if ( error )</a>
<a name="ln2883">        goto Exit;</a>
<a name="ln2884"> </a>
<a name="ln2885">      /* apply blue zones to base characters only */</a>
<a name="ln2886">      if ( !( metrics-&gt;root.globals-&gt;glyph_styles[glyph_index] &amp; AF_NONBASE ) )</a>
<a name="ln2887">        af_latin_hints_compute_blue_edges( hints, metrics );</a>
<a name="ln2888">    }</a>
<a name="ln2889"> </a>
<a name="ln2890">    /* grid-fit the outline */</a>
<a name="ln2891">    for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )</a>
<a name="ln2892">    {</a>
<a name="ln2893">#ifdef AF_CONFIG_OPTION_USE_WARPER</a>
<a name="ln2894">      if ( dim == AF_DIMENSION_HORZ                                 &amp;&amp;</a>
<a name="ln2895">           metrics-&gt;root.scaler.render_mode == FT_RENDER_MODE_LIGHT &amp;&amp;</a>
<a name="ln2896">           AF_HINTS_DO_WARP( hints )                                )</a>
<a name="ln2897">      {</a>
<a name="ln2898">        AF_WarperRec  warper;</a>
<a name="ln2899">        FT_Fixed      scale;</a>
<a name="ln2900">        FT_Pos        delta;</a>
<a name="ln2901"> </a>
<a name="ln2902"> </a>
<a name="ln2903">        af_warper_compute( &amp;warper, hints, (AF_Dimension)dim,</a>
<a name="ln2904">                           &amp;scale, &amp;delta );</a>
<a name="ln2905">        af_glyph_hints_scale_dim( hints, (AF_Dimension)dim,</a>
<a name="ln2906">                                  scale, delta );</a>
<a name="ln2907">        continue;</a>
<a name="ln2908">      }</a>
<a name="ln2909">#endif /* AF_CONFIG_OPTION_USE_WARPER */</a>
<a name="ln2910"> </a>
<a name="ln2911">      if ( ( dim == AF_DIMENSION_HORZ &amp;&amp; AF_HINTS_DO_HORIZONTAL( hints ) ) ||</a>
<a name="ln2912">           ( dim == AF_DIMENSION_VERT &amp;&amp; AF_HINTS_DO_VERTICAL( hints ) )   )</a>
<a name="ln2913">      {</a>
<a name="ln2914">        af_latin_hint_edges( hints, (AF_Dimension)dim );</a>
<a name="ln2915">        af_glyph_hints_align_edge_points( hints, (AF_Dimension)dim );</a>
<a name="ln2916">        af_glyph_hints_align_strong_points( hints, (AF_Dimension)dim );</a>
<a name="ln2917">        af_glyph_hints_align_weak_points( hints, (AF_Dimension)dim );</a>
<a name="ln2918">      }</a>
<a name="ln2919">    }</a>
<a name="ln2920"> </a>
<a name="ln2921">    af_glyph_hints_save( hints, outline );</a>
<a name="ln2922"> </a>
<a name="ln2923">  Exit:</a>
<a name="ln2924">    return error;</a>
<a name="ln2925">  }</a>
<a name="ln2926"> </a>
<a name="ln2927"> </a>
<a name="ln2928">  /*************************************************************************/</a>
<a name="ln2929">  /*************************************************************************/</a>
<a name="ln2930">  /*****                                                               *****/</a>
<a name="ln2931">  /*****              L A T I N   S C R I P T   C L A S S              *****/</a>
<a name="ln2932">  /*****                                                               *****/</a>
<a name="ln2933">  /*************************************************************************/</a>
<a name="ln2934">  /*************************************************************************/</a>
<a name="ln2935"> </a>
<a name="ln2936"> </a>
<a name="ln2937">  AF_DEFINE_WRITING_SYSTEM_CLASS(</a>
<a name="ln2938">    af_latin_writing_system_class,</a>
<a name="ln2939"> </a>
<a name="ln2940">    AF_WRITING_SYSTEM_LATIN,</a>
<a name="ln2941"> </a>
<a name="ln2942">    sizeof ( AF_LatinMetricsRec ),</a>
<a name="ln2943"> </a>
<a name="ln2944">    (AF_WritingSystem_InitMetricsFunc) af_latin_metrics_init,</a>
<a name="ln2945">    (AF_WritingSystem_ScaleMetricsFunc)af_latin_metrics_scale,</a>
<a name="ln2946">    (AF_WritingSystem_DoneMetricsFunc) NULL,</a>
<a name="ln2947"> </a>
<a name="ln2948">    (AF_WritingSystem_InitHintsFunc)   af_latin_hints_init,</a>
<a name="ln2949">    (AF_WritingSystem_ApplyHintsFunc)  af_latin_hints_apply</a>
<a name="ln2950">  )</a>
<a name="ln2951"> </a>
<a name="ln2952"> </a>
<a name="ln2953">/* END */</a>

</code></pre>
<div class="balloon" rel="669"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'p_last' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
