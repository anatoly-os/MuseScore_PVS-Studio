
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>chord.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2013 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;chord.h&quot;</a>
<a name="ln14">#include &quot;note.h&quot;</a>
<a name="ln15">#include &quot;xml.h&quot;</a>
<a name="ln16">#include &quot;style.h&quot;</a>
<a name="ln17">#include &quot;segment.h&quot;</a>
<a name="ln18">#include &quot;text.h&quot;</a>
<a name="ln19">#include &quot;measure.h&quot;</a>
<a name="ln20">#include &quot;system.h&quot;</a>
<a name="ln21">#include &quot;tuplet.h&quot;</a>
<a name="ln22">#include &quot;hook.h&quot;</a>
<a name="ln23">#include &quot;tie.h&quot;</a>
<a name="ln24">#include &quot;arpeggio.h&quot;</a>
<a name="ln25">#include &quot;score.h&quot;</a>
<a name="ln26">#include &quot;tremolo.h&quot;</a>
<a name="ln27">#include &quot;glissando.h&quot;</a>
<a name="ln28">#include &quot;staff.h&quot;</a>
<a name="ln29">#include &quot;part.h&quot;</a>
<a name="ln30">#include &quot;utils.h&quot;</a>
<a name="ln31">#include &quot;articulation.h&quot;</a>
<a name="ln32">#include &quot;undo.h&quot;</a>
<a name="ln33">#include &quot;chordline.h&quot;</a>
<a name="ln34">#include &quot;lyrics.h&quot;</a>
<a name="ln35">#include &quot;navigate.h&quot;</a>
<a name="ln36">#include &quot;stafftype.h&quot;</a>
<a name="ln37">#include &quot;stem.h&quot;</a>
<a name="ln38">#include &quot;mscore.h&quot;</a>
<a name="ln39">#include &quot;accidental.h&quot;</a>
<a name="ln40">#include &quot;noteevent.h&quot;</a>
<a name="ln41">#include &quot;pitchspelling.h&quot;</a>
<a name="ln42">#include &quot;stemslash.h&quot;</a>
<a name="ln43">#include &quot;ledgerline.h&quot;</a>
<a name="ln44">#include &quot;drumset.h&quot;</a>
<a name="ln45">#include &quot;key.h&quot;</a>
<a name="ln46">#include &quot;sym.h&quot;</a>
<a name="ln47">#include &quot;stringdata.h&quot;</a>
<a name="ln48">#include &quot;beam.h&quot;</a>
<a name="ln49">#include &quot;slur.h&quot;</a>
<a name="ln50">#include &quot;fingering.h&quot;</a>
<a name="ln51"> </a>
<a name="ln52">namespace Ms {</a>
<a name="ln53"> </a>
<a name="ln54">//---------------------------------------------------------</a>
<a name="ln55">//   LedgerLineData</a>
<a name="ln56">//---------------------------------------------------------</a>
<a name="ln57"> </a>
<a name="ln58">struct LedgerLineData {</a>
<a name="ln59">      int   line;</a>
<a name="ln60">      qreal minX, maxX;</a>
<a name="ln61">      bool  visible;</a>
<a name="ln62">      bool  accidental;</a>
<a name="ln63">      };</a>
<a name="ln64"> </a>
<a name="ln65">//---------------------------------------------------------</a>
<a name="ln66">//   upNote</a>
<a name="ln67">//---------------------------------------------------------</a>
<a name="ln68"> </a>
<a name="ln69">Note* Chord::upNote() const</a>
<a name="ln70">      {</a>
<a name="ln71">      Q_ASSERT(!_notes.empty());</a>
<a name="ln72"> </a>
<a name="ln73">      Note* result = _notes.back();</a>
<a name="ln74">      if (!staff())</a>
<a name="ln75">            return result;</a>
<a name="ln76"> </a>
<a name="ln77">      const Staff* stf = staff();</a>
<a name="ln78">      const StaffType* st  = stf-&gt;staffType(tick());</a>
<a name="ln79">      if (st-&gt;isDrumStaff()) {</a>
<a name="ln80">            for (Note* n : _notes) {</a>
<a name="ln81">                  if (n-&gt;line() &lt; result-&gt;line()) {</a>
<a name="ln82">                        result = n;</a>
<a name="ln83">                        }</a>
<a name="ln84">                  }</a>
<a name="ln85">            }</a>
<a name="ln86">      else if (st-&gt;isTabStaff()) {</a>
<a name="ln87">            int line = st-&gt;lines() - 1;      // start at bottom line</a>
<a name="ln88">            int noteLine;</a>
<a name="ln89">            // scan each note: if TAB strings are not in sequential order,</a>
<a name="ln90">            // visual order of notes might not correspond to pitch order</a>
<a name="ln91">            for (Note* n : _notes) {</a>
<a name="ln92">                  noteLine = st-&gt;physStringToVisual(n-&gt;string());</a>
<a name="ln93">                  if (noteLine &lt; line) {</a>
<a name="ln94">                        line   = noteLine;</a>
<a name="ln95">                        result = n;</a>
<a name="ln96">                        }</a>
<a name="ln97">                  }</a>
<a name="ln98">            }</a>
<a name="ln99">      return result;</a>
<a name="ln100">      }</a>
<a name="ln101"> </a>
<a name="ln102">//---------------------------------------------------------</a>
<a name="ln103">//   downNote</a>
<a name="ln104">//---------------------------------------------------------</a>
<a name="ln105"> </a>
<a name="ln106">Note* Chord::downNote() const</a>
<a name="ln107">      {</a>
<a name="ln108">      Q_ASSERT(!_notes.empty());</a>
<a name="ln109"> </a>
<a name="ln110">      Note* result = _notes.front();</a>
<a name="ln111">      if (!staff())</a>
<a name="ln112">            return result;</a>
<a name="ln113"> </a>
<a name="ln114">      const Staff* stf = staff();</a>
<a name="ln115">      const StaffType* st  = stf-&gt;staffType(tick());</a>
<a name="ln116">      if (st-&gt;isDrumStaff()) {</a>
<a name="ln117">            for (Note* n : _notes) {</a>
<a name="ln118">                  if (n-&gt;line() &gt; result-&gt;line()) {</a>
<a name="ln119">                        result = n;</a>
<a name="ln120">                        }</a>
<a name="ln121">                  }</a>
<a name="ln122">            }</a>
<a name="ln123">      else if (st-&gt;isTabStaff()) {</a>
<a name="ln124">            int line        = 0;      // start at top line</a>
<a name="ln125">            int noteLine;</a>
<a name="ln126">            // scan each note: if TAB strings are not in sequential order,</a>
<a name="ln127">            // visual order of notes might not correspond to pitch order</a>
<a name="ln128">            for (Note* n : _notes) {</a>
<a name="ln129">                  noteLine = st-&gt;physStringToVisual(n-&gt;string());</a>
<a name="ln130">                  if (noteLine &gt; line) {</a>
<a name="ln131">                        line = noteLine;</a>
<a name="ln132">                        result = n;</a>
<a name="ln133">                        }</a>
<a name="ln134">                  }</a>
<a name="ln135">            }</a>
<a name="ln136">      return result;</a>
<a name="ln137">      }</a>
<a name="ln138"> </a>
<a name="ln139">//---------------------------------------------------------</a>
<a name="ln140">//   upLine / downLine</a>
<a name="ln141">//---------------------------------------------------------</a>
<a name="ln142"> </a>
<a name="ln143">int Chord::upLine() const</a>
<a name="ln144">      {</a>
<a name="ln145">      return (staff() &amp;&amp; staff()-&gt;isTabStaff(tick())) ? upString()*2 : upNote()-&gt;line();</a>
<a name="ln146">      }</a>
<a name="ln147"> </a>
<a name="ln148">int Chord::downLine() const</a>
<a name="ln149">      {</a>
<a name="ln150">      return (staff() &amp;&amp; staff()-&gt;isTabStaff(tick())) ? downString()*2 : downNote()-&gt;line();</a>
<a name="ln151">      }</a>
<a name="ln152"> </a>
<a name="ln153">//---------------------------------------------------------</a>
<a name="ln154">//   upString / downString</a>
<a name="ln155">//</a>
<a name="ln156">//    return the topmost / bottommost string used by chord</a>
<a name="ln157">//    Top and bottom refer to the DRAWN position, not the position in the instrument</a>
<a name="ln158">//    (i.e., upside-down TAB are taken into account)</a>
<a name="ln159">//</a>
<a name="ln160">//    If no staff, always return 0</a>
<a name="ln161">//    If staf is not a TAB, always returns TOP and BOTTOM staff lines</a>
<a name="ln162">//---------------------------------------------------------</a>
<a name="ln163"> </a>
<a name="ln164">int Chord::upString() const</a>
<a name="ln165">      {</a>
<a name="ln166">      // if no staff or staff not a TAB, return 0 (=topmost line)</a>
<a name="ln167">      if(!staff() || !staff()-&gt;isTabStaff(tick()))</a>
<a name="ln168">            return 0;</a>
<a name="ln169">      const Staff* st = staff();</a>
<a name="ln170">      const StaffType* tab = st-&gt;staffType(tick());</a>
<a name="ln171">      int       line = tab-&gt;lines() - 1;      // start at bottom line</a>
<a name="ln172">      int                     noteLine;</a>
<a name="ln173">      // scan each note: if TAB strings are not in sequential order,</a>
<a name="ln174">      // visual order of notes might not correspond to pitch order</a>
<a name="ln175">      size_t n = _notes.size();</a>
<a name="ln176">      for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln177">            noteLine = tab-&gt;physStringToVisual(_notes.at(i)-&gt;string());</a>
<a name="ln178">            if (noteLine &lt; line)</a>
<a name="ln179">                  line = noteLine;</a>
<a name="ln180">            }</a>
<a name="ln181">      return line;</a>
<a name="ln182">      }</a>
<a name="ln183"> </a>
<a name="ln184">int Chord::downString() const</a>
<a name="ln185">      {</a>
<a name="ln186">      if (!staff())                              // if no staff, return 0</a>
<a name="ln187">            return 0;</a>
<a name="ln188">      if (!staff()-&gt;isTabStaff(tick()))                // if staff not a TAB, return bottom line</a>
<a name="ln189">            return staff()-&gt;lines(tick())-1;</a>
<a name="ln190">      const Staff* st = staff();</a>
<a name="ln191">      const StaffType* tab = st-&gt;staffType(tick());</a>
<a name="ln192">      int line = 0;         // start at top line</a>
<a name="ln193">      int noteLine;</a>
<a name="ln194">      size_t n = _notes.size();</a>
<a name="ln195">      for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln196">            noteLine = tab-&gt;physStringToVisual(_notes.at(i)-&gt;string());</a>
<a name="ln197">            if (noteLine &gt; line)</a>
<a name="ln198">                  line = noteLine;</a>
<a name="ln199">            }</a>
<a name="ln200">      return line;</a>
<a name="ln201">      }</a>
<a name="ln202"> </a>
<a name="ln203">//---------------------------------------------------------</a>
<a name="ln204">//   Chord</a>
<a name="ln205">//---------------------------------------------------------</a>
<a name="ln206"> </a>
<a name="ln207">Chord::Chord(Score* s)</a>
<a name="ln208">   : ChordRest(s)</a>
<a name="ln209">      {</a>
<a name="ln210">      _ledgerLines      = 0;</a>
<a name="ln211">      _stem             = 0;</a>
<a name="ln212">      _hook             = 0;</a>
<a name="ln213">      _stemDirection    = Direction::AUTO;</a>
<a name="ln214">      _arpeggio         = 0;</a>
<a name="ln215">      _tremolo          = 0;</a>
<a name="ln216">      _endsGlissando    = false;</a>
<a name="ln217">      _noteType         = NoteType::NORMAL;</a>
<a name="ln218">      _stemSlash        = 0;</a>
<a name="ln219">      _noStem           = false;</a>
<a name="ln220">      _playEventType    = PlayEventType::Auto;</a>
<a name="ln221">      _crossMeasure     = CrossMeasure::UNKNOWN;</a>
<a name="ln222">      _graceIndex   = 0;</a>
<a name="ln223">      }</a>
<a name="ln224"> </a>
<a name="ln225">Chord::Chord(const Chord&amp; c, bool link)</a>
<a name="ln226">   : ChordRest(c, link)</a>
<a name="ln227">      {</a>
<a name="ln228">      if (link)</a>
<a name="ln229">            score()-&gt;undo(new Link(this, const_cast&lt;Chord*&gt;(&amp;c)));</a>
<a name="ln230">      _ledgerLines = 0;</a>
<a name="ln231"> </a>
<a name="ln232">      for (Note* onote : c._notes) {</a>
<a name="ln233">            Note* nnote = new Note(*onote, link);</a>
<a name="ln234">            add(nnote);</a>
<a name="ln235">            }</a>
<a name="ln236">      for (Chord* gn : c.graceNotes()) {</a>
<a name="ln237">            Chord* nc = new Chord(*gn, link);</a>
<a name="ln238">            add(nc);</a>
<a name="ln239">            }</a>
<a name="ln240">      for (Articulation* a : c._articulations) {    // make deep copy</a>
<a name="ln241">            Articulation* na = new Articulation(*a);</a>
<a name="ln242">            if (link)</a>
<a name="ln243">                  na-&gt;linkTo(a);</a>
<a name="ln244">            na-&gt;setParent(this);</a>
<a name="ln245">            na-&gt;setTrack(track());</a>
<a name="ln246">            _articulations.append(na);</a>
<a name="ln247">            }</a>
<a name="ln248">      _stem          = 0;</a>
<a name="ln249">      _hook          = 0;</a>
<a name="ln250">      _endsGlissando = false;</a>
<a name="ln251">      _arpeggio      = 0;</a>
<a name="ln252">      _stemSlash     = 0;</a>
<a name="ln253">      _tremolo       = 0;</a>
<a name="ln254"> </a>
<a name="ln255">      _graceIndex     = c._graceIndex;</a>
<a name="ln256">      _noStem         = c._noStem;</a>
<a name="ln257">      _playEventType  = c._playEventType;</a>
<a name="ln258">      _stemDirection  = c._stemDirection;</a>
<a name="ln259">      _noteType       = c._noteType;</a>
<a name="ln260">      _crossMeasure   = CrossMeasure::UNKNOWN;</a>
<a name="ln261"> </a>
<a name="ln262">      if (c._stem)</a>
<a name="ln263">            add(new Stem(*(c._stem)));</a>
<a name="ln264">      if (c._hook)</a>
<a name="ln265">            add(new Hook(*(c._hook)));</a>
<a name="ln266">      if (c._stemSlash)</a>
<a name="ln267">            add(new StemSlash(*(c._stemSlash)));</a>
<a name="ln268">      if (c._arpeggio) {</a>
<a name="ln269">            Arpeggio* a = new Arpeggio(*(c._arpeggio));</a>
<a name="ln270">            add(a);</a>
<a name="ln271">            if (link)</a>
<a name="ln272">                  score()-&gt;undo(new Link(a, const_cast&lt;Arpeggio*&gt;(c._arpeggio)));</a>
<a name="ln273">            }</a>
<a name="ln274">      if (c._tremolo) {</a>
<a name="ln275">            Tremolo* t = new Tremolo(*(c._tremolo));</a>
<a name="ln276">            if (link)</a>
<a name="ln277">                  score()-&gt;undo(new Link(t, const_cast&lt;Tremolo*&gt;(c._tremolo)));</a>
<a name="ln278">            if (c._tremolo-&gt;twoNotes()) {</a>
<a name="ln279">                  if (c._tremolo-&gt;chord1() == &amp;c)</a>
<a name="ln280">                        t-&gt;setChords(this, nullptr);</a>
<a name="ln281">                  else</a>
<a name="ln282">                        t-&gt;setChords(nullptr, this);</a>
<a name="ln283">                  }</a>
<a name="ln284">            add(t);</a>
<a name="ln285">            }</a>
<a name="ln286"> </a>
<a name="ln287">      for (Element* e : c.el()) {</a>
<a name="ln288">            if (e-&gt;isChordLine()) {</a>
<a name="ln289">                  ChordLine* cl = toChordLine(e);</a>
<a name="ln290">                  ChordLine* ncl = new ChordLine(*cl);</a>
<a name="ln291">                  add(ncl);</a>
<a name="ln292">                  if (link)</a>
<a name="ln293">                        score()-&gt;undo(new Link(ncl, cl));</a>
<a name="ln294">                  }</a>
<a name="ln295">            }</a>
<a name="ln296">      }</a>
<a name="ln297"> </a>
<a name="ln298">//---------------------------------------------------------</a>
<a name="ln299">//   undoUnlink</a>
<a name="ln300">//---------------------------------------------------------</a>
<a name="ln301"> </a>
<a name="ln302">void Chord::undoUnlink()</a>
<a name="ln303">      {</a>
<a name="ln304">      ChordRest::undoUnlink();</a>
<a name="ln305">      for (Note* n : _notes)</a>
<a name="ln306">            n-&gt;undoUnlink();</a>
<a name="ln307">      for (Chord* gn : graceNotes())</a>
<a name="ln308">            gn-&gt;undoUnlink();</a>
<a name="ln309">      for (Articulation* a : _articulations)</a>
<a name="ln310">            a-&gt;undoUnlink();</a>
<a name="ln311">/*      if (_glissando)</a>
<a name="ln312">            _glissando-&gt;undoUnlink(); */</a>
<a name="ln313">      if (_arpeggio)</a>
<a name="ln314">            _arpeggio-&gt;undoUnlink();</a>
<a name="ln315">      if (_tremolo &amp;&amp; !_tremolo-&gt;twoNotes())</a>
<a name="ln316">            _tremolo-&gt;undoUnlink();</a>
<a name="ln317"> </a>
<a name="ln318">      for (Element* e : el()) {</a>
<a name="ln319">            if (e-&gt;type() == ElementType::CHORDLINE)</a>
<a name="ln320">                  e-&gt;undoUnlink();</a>
<a name="ln321">            }</a>
<a name="ln322">      }</a>
<a name="ln323"> </a>
<a name="ln324">//---------------------------------------------------------</a>
<a name="ln325">//   ~Chord</a>
<a name="ln326">//---------------------------------------------------------</a>
<a name="ln327"> </a>
<a name="ln328">Chord::~Chord()</a>
<a name="ln329">      {</a>
<a name="ln330">      qDeleteAll(_articulations);</a>
<a name="ln331">      delete _arpeggio;</a>
<a name="ln332">      if (_tremolo) {</a>
<a name="ln333">            if (_tremolo-&gt;chord1() == this) {</a>
<a name="ln334">                  Tremolo* tremoloPointer = _tremolo; // setTremolo(0) loses reference to the current pointer</a>
<a name="ln335">                  if (_tremolo-&gt;chord2())</a>
<a name="ln336">                        _tremolo-&gt;chord2()-&gt;setTremolo(0);</a>
<a name="ln337">                  delete tremoloPointer;</a>
<a name="ln338">                  }</a>
<a name="ln339">            else if (!(_tremolo-&gt;chord1())) // delete orphaned tremolo</a>
<a name="ln340">                  delete _tremolo;</a>
<a name="ln341">            }</a>
<a name="ln342">      delete _stemSlash;</a>
<a name="ln343">      delete _stem;</a>
<a name="ln344">      delete _hook;</a>
<a name="ln345">      for (LedgerLine* ll = _ledgerLines; ll;) {</a>
<a name="ln346">            LedgerLine* llNext = ll-&gt;next();</a>
<a name="ln347">            delete ll;</a>
<a name="ln348">            ll = llNext;</a>
<a name="ln349">            }</a>
<a name="ln350">      qDeleteAll(_graceNotes);</a>
<a name="ln351">      qDeleteAll(_notes);</a>
<a name="ln352">      }</a>
<a name="ln353"> </a>
<a name="ln354">//---------------------------------------------------------</a>
<a name="ln355">//   noteHeadWidth</a>
<a name="ln356">//---------------------------------------------------------</a>
<a name="ln357"> </a>
<a name="ln358">qreal Chord::noteHeadWidth() const</a>
<a name="ln359">      {</a>
<a name="ln360">      qreal nhw = score()-&gt;noteHeadWidth();</a>
<a name="ln361">      if (_noteType != NoteType::NORMAL)</a>
<a name="ln362">            nhw *= score()-&gt;styleD(Sid::graceNoteMag);</a>
<a name="ln363">      return nhw * mag();</a>
<a name="ln364">      }</a>
<a name="ln365"> </a>
<a name="ln366">//---------------------------------------------------------</a>
<a name="ln367">//   stemPosX</a>
<a name="ln368">//    return Chord coordinates. Based on nominal notehead</a>
<a name="ln369">//---------------------------------------------------------</a>
<a name="ln370"> </a>
<a name="ln371">qreal Chord::stemPosX() const</a>
<a name="ln372">      {</a>
<a name="ln373">      const Staff* stf = staff();</a>
<a name="ln374">      const StaffType* st = stf ? stf-&gt;staffType(tick()) : 0;</a>
<a name="ln375">      if (st &amp;&amp; st-&gt;isTabStaff())</a>
<a name="ln376">            return st-&gt;chordStemPosX(this) * spatium();</a>
<a name="ln377">      return _up ? noteHeadWidth() : 0.0;</a>
<a name="ln378">      }</a>
<a name="ln379"> </a>
<a name="ln380">//---------------------------------------------------------</a>
<a name="ln381">//   stemPos</a>
<a name="ln382">//    return page coordinates</a>
<a name="ln383">//---------------------------------------------------------</a>
<a name="ln384"> </a>
<a name="ln385">QPointF Chord::stemPos() const</a>
<a name="ln386">      {</a>
<a name="ln387">      QPointF p(pagePos());</a>
<a name="ln388"> </a>
<a name="ln389">      const Staff* stf = staff();</a>
<a name="ln390">      const StaffType* st = stf ? stf-&gt;staffType(tick()) : 0;</a>
<a name="ln391">      if (st &amp;&amp; st-&gt;isTabStaff())</a>
<a name="ln392">            return st-&gt;chordStemPos(this) * spatium() + p;</a>
<a name="ln393"> </a>
<a name="ln394">      if (_up) {</a>
<a name="ln395">            qreal nhw = _notes.size() == 1 ? downNote()-&gt;bboxRightPos() : noteHeadWidth();</a>
<a name="ln396">            p.rx() += nhw;</a>
<a name="ln397">            p.ry() += downNote()-&gt;pos().y();</a>
<a name="ln398">            }</a>
<a name="ln399">      else</a>
<a name="ln400">            p.ry() += upNote()-&gt;pos().y();</a>
<a name="ln401">      return p;</a>
<a name="ln402">      }</a>
<a name="ln403"> </a>
<a name="ln404">//---------------------------------------------------------</a>
<a name="ln405">//   stemPosBeam</a>
<a name="ln406">//    return stem position of note on beam side</a>
<a name="ln407">//    return page coordinates</a>
<a name="ln408">//---------------------------------------------------------</a>
<a name="ln409"> </a>
<a name="ln410">QPointF Chord::stemPosBeam() const</a>
<a name="ln411">      {</a>
<a name="ln412">      qreal _spatium = spatium();</a>
<a name="ln413">      QPointF p(pagePos());</a>
<a name="ln414"> </a>
<a name="ln415">      const Staff* stf = staff();</a>
<a name="ln416">      const StaffType* st = stf ? stf-&gt;staffType(tick()) : 0;</a>
<a name="ln417"> </a>
<a name="ln418">      if (st &amp;&amp; st-&gt;isTabStaff())</a>
<a name="ln419">            return st-&gt;chordStemPosBeam(this) * _spatium + p;</a>
<a name="ln420"> </a>
<a name="ln421">      if (_up) {</a>
<a name="ln422">            qreal nhw = noteHeadWidth();</a>
<a name="ln423">            p.rx() += nhw;</a>
<a name="ln424">            p.ry() += upNote()-&gt;pos().y();</a>
<a name="ln425">            }</a>
<a name="ln426">      else</a>
<a name="ln427">            p.ry() += downNote()-&gt;pos().y();</a>
<a name="ln428"> </a>
<a name="ln429">      return p;</a>
<a name="ln430">      }</a>
<a name="ln431"> </a>
<a name="ln432">//---------------------------------------------------------</a>
<a name="ln433">//   setTremolo</a>
<a name="ln434">//---------------------------------------------------------</a>
<a name="ln435"> </a>
<a name="ln436">void Chord::setTremolo(Tremolo* tr)</a>
<a name="ln437">      {</a>
<a name="ln438">      if (_tremolo &amp;&amp; tr &amp;&amp; tr == _tremolo)</a>
<a name="ln439">            return;</a>
<a name="ln440"> </a>
<a name="ln441">      if (_tremolo) {</a>
<a name="ln442">            if (_tremolo-&gt;twoNotes()) {</a>
<a name="ln443">                  TDuration d;</a>
<a name="ln444">                  const Fraction f = ticks();</a>
<a name="ln445">                  if (f.numerator() &gt; 0)</a>
<a name="ln446">                        d = TDuration(f);</a>
<a name="ln447">                  else {</a>
<a name="ln448">                        d = _tremolo-&gt;durationType();</a>
<a name="ln449">                        const int dots = d.dots();</a>
<a name="ln450">                        d = d.shift(1);</a>
<a name="ln451">                        d.setDots(dots);</a>
<a name="ln452">                        }</a>
<a name="ln453"> </a>
<a name="ln454">                  setDurationType(d);</a>
<a name="ln455">                  Chord* other = _tremolo-&gt;chord1() == this ? _tremolo-&gt;chord2() : _tremolo-&gt;chord1();</a>
<a name="ln456">                  _tremolo = nullptr;</a>
<a name="ln457">                  if (other)</a>
<a name="ln458">                        other-&gt;setTremolo(nullptr);</a>
<a name="ln459">                  }</a>
<a name="ln460">            else</a>
<a name="ln461">                  _tremolo = nullptr;</a>
<a name="ln462">            }</a>
<a name="ln463"> </a>
<a name="ln464">      if (tr) {</a>
<a name="ln465">            if (tr-&gt;twoNotes()) {</a>
<a name="ln466">                  TDuration d = tr-&gt;durationType();</a>
<a name="ln467">                  if (!d.isValid()) {</a>
<a name="ln468">                        d = durationType();</a>
<a name="ln469">                        const int dots = d.dots();</a>
<a name="ln470">                        d = d.shift(-1);</a>
<a name="ln471">                        d.setDots(dots);</a>
<a name="ln472">                        tr-&gt;setDurationType(d);</a>
<a name="ln473">                        }</a>
<a name="ln474"> </a>
<a name="ln475">                  setDurationType(d);</a>
<a name="ln476">                  Chord* other = tr-&gt;chord1() == this ? tr-&gt;chord2() : tr-&gt;chord1();</a>
<a name="ln477">                  _tremolo = tr;</a>
<a name="ln478">                  if (other)</a>
<a name="ln479">                        other-&gt;setTremolo(tr);</a>
<a name="ln480">                  }</a>
<a name="ln481">            else</a>
<a name="ln482">                  _tremolo = tr;</a>
<a name="ln483">            }</a>
<a name="ln484">      else {</a>
<a name="ln485">            _tremolo = nullptr;</a>
<a name="ln486">            }</a>
<a name="ln487">      }</a>
<a name="ln488"> </a>
<a name="ln489">//---------------------------------------------------------</a>
<a name="ln490">//   add</a>
<a name="ln491">//---------------------------------------------------------</a>
<a name="ln492"> </a>
<a name="ln493">void Chord::add(Element* e)</a>
<a name="ln494">      {</a>
<a name="ln495">      e-&gt;setParent(this);</a>
<a name="ln496">      e-&gt;setTrack(track());</a>
<a name="ln497">      switch(e-&gt;type()) {</a>
<a name="ln498">            case ElementType::NOTE:</a>
<a name="ln499">                  {</a>
<a name="ln500">                  Note* note = toNote(e);</a>
<a name="ln501">                  bool found = false;</a>
<a name="ln502"> </a>
<a name="ln503">                  // _notes should be sorted by line position,</a>
<a name="ln504">                  // but it's often not yet possible since line is unknown</a>
<a name="ln505">                  // use pitch instead, and line as a second sort criteria.</a>
<a name="ln506"> </a>
<a name="ln507">                  for (unsigned idx = 0; idx &lt; _notes.size(); ++idx) {</a>
<a name="ln508">                        if (note-&gt;pitch() &lt;= _notes[idx]-&gt;pitch()) {</a>
<a name="ln509">                              if (note-&gt;pitch() == _notes[idx]-&gt;pitch() &amp;&amp; note-&gt;line() &gt;= _notes[idx]-&gt;line())</a>
<a name="ln510">                                    _notes.insert(_notes.begin()+idx+1, note);</a>
<a name="ln511">                              else</a>
<a name="ln512">                                    _notes.insert(_notes.begin()+idx, note);</a>
<a name="ln513">                              found = true;</a>
<a name="ln514">                              break;</a>
<a name="ln515">                              }</a>
<a name="ln516">                        }</a>
<a name="ln517">                  if (!found)</a>
<a name="ln518">                        _notes.push_back(note);</a>
<a name="ln519">                  note-&gt;connectTiedNotes();</a>
<a name="ln520">                  if (voice() &amp;&amp; measure() &amp;&amp; note-&gt;visible())</a>
<a name="ln521">                        measure()-&gt;setHasVoices(staffIdx(), true);</a>
<a name="ln522">                  }</a>
<a name="ln523">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln524">                  break;</a>
<a name="ln525">            case ElementType::ARPEGGIO:</a>
<a name="ln526">                  _arpeggio = toArpeggio(e);</a>
<a name="ln527">                  break;</a>
<a name="ln528">            case ElementType::TREMOLO:</a>
<a name="ln529">                  setTremolo(toTremolo(e));</a>
<a name="ln530">                  break;</a>
<a name="ln531">            case ElementType::GLISSANDO:</a>
<a name="ln532">                  _endsGlissando = true;</a>
<a name="ln533">                  break;</a>
<a name="ln534">            case ElementType::STEM:</a>
<a name="ln535">                  Q_ASSERT(!_stem);</a>
<a name="ln536">                  _stem = toStem(e);</a>
<a name="ln537">                  break;</a>
<a name="ln538">            case ElementType::HOOK:</a>
<a name="ln539">                  _hook = toHook(e);</a>
<a name="ln540">                  break;</a>
<a name="ln541">            case ElementType::CHORDLINE:</a>
<a name="ln542">                  el().push_back(e);</a>
<a name="ln543">                  break;</a>
<a name="ln544">            case ElementType::STEM_SLASH:</a>
<a name="ln545">                  Q_ASSERT(!_stemSlash);</a>
<a name="ln546">                  _stemSlash = toStemSlash(e);</a>
<a name="ln547">                  break;</a>
<a name="ln548">            case ElementType::CHORD:</a>
<a name="ln549">                  {</a>
<a name="ln550">                  Chord* gc = toChord(e);</a>
<a name="ln551">                  Q_ASSERT(gc-&gt;noteType() != NoteType::NORMAL);</a>
<a name="ln552">                  int idx = gc-&gt;graceIndex();</a>
<a name="ln553">                  gc-&gt;setFlag(ElementFlag::MOVABLE, true);</a>
<a name="ln554">                  _graceNotes.insert(_graceNotes.begin() + idx, gc);</a>
<a name="ln555">                  }</a>
<a name="ln556">                  break;</a>
<a name="ln557">            case ElementType::LEDGER_LINE:</a>
<a name="ln558">                  qFatal(&quot;Chord::add ledgerline&quot;);</a>
<a name="ln559">                  break;</a>
<a name="ln560">            case ElementType::ARTICULATION:</a>
<a name="ln561">                  {</a>
<a name="ln562">                  Articulation* a = toArticulation(e);</a>
<a name="ln563">                  if (a-&gt;layoutCloseToNote()) {</a>
<a name="ln564">                        auto i = _articulations.begin();</a>
<a name="ln565">                        while (i != _articulations.end() &amp;&amp; (*i)-&gt;layoutCloseToNote())</a>
<a name="ln566">                              i++;</a>
<a name="ln567">                        _articulations.insert(i, a);</a>
<a name="ln568">                        }</a>
<a name="ln569">                  else</a>
<a name="ln570">                        _articulations.push_back(a);</a>
<a name="ln571">                  }</a>
<a name="ln572">                  break;</a>
<a name="ln573">            default:</a>
<a name="ln574">                  ChordRest::add(e);</a>
<a name="ln575">                  break;</a>
<a name="ln576">            }</a>
<a name="ln577">      }</a>
<a name="ln578"> </a>
<a name="ln579">//---------------------------------------------------------</a>
<a name="ln580">//   remove</a>
<a name="ln581">//---------------------------------------------------------</a>
<a name="ln582"> </a>
<a name="ln583">void Chord::remove(Element* e)</a>
<a name="ln584">      {</a>
<a name="ln585">      if (!e)</a>
<a name="ln586">            return;</a>
<a name="ln587"> </a>
<a name="ln588">      switch (e-&gt;type()) {</a>
<a name="ln589">            case ElementType::NOTE:</a>
<a name="ln590">                  {</a>
<a name="ln591">                  Note* note = toNote(e);</a>
<a name="ln592">                  auto i = std::find(_notes.begin(), _notes.end(), note);</a>
<a name="ln593">                  if (i != _notes.end()) {</a>
<a name="ln594">                        _notes.erase(i);</a>
<a name="ln595">                        note-&gt;disconnectTiedNotes();</a>
<a name="ln596">                        for (Spanner* s : note-&gt;spannerBack())</a>
<a name="ln597">                              note-&gt;removeSpannerBack(s);</a>
<a name="ln598">                        for (Spanner* s : note-&gt;spannerFor())</a>
<a name="ln599">                              note-&gt;removeSpannerFor(s);</a>
<a name="ln600">                        }</a>
<a name="ln601">                  else</a>
<a name="ln602">                        qDebug(&quot;Chord::remove() note %p not found!&quot;, e);</a>
<a name="ln603">                  if (voice() &amp;&amp; measure() &amp;&amp; note-&gt;visible())</a>
<a name="ln604">                        measure()-&gt;checkMultiVoices(staffIdx());</a>
<a name="ln605">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln606">                  }</a>
<a name="ln607">                  break;</a>
<a name="ln608"> </a>
<a name="ln609">            case ElementType::ARPEGGIO:</a>
<a name="ln610">                  _arpeggio = 0;</a>
<a name="ln611">                  break;</a>
<a name="ln612">            case ElementType::TREMOLO:</a>
<a name="ln613">                  setTremolo(nullptr);</a>
<a name="ln614">                  break;</a>
<a name="ln615">            case ElementType::GLISSANDO:</a>
<a name="ln616">                  _endsGlissando = false;</a>
<a name="ln617">                  break;</a>
<a name="ln618">            case ElementType::STEM:</a>
<a name="ln619">                  _stem = 0;</a>
<a name="ln620">                  break;</a>
<a name="ln621">            case ElementType::HOOK:</a>
<a name="ln622">                  _hook = 0;</a>
<a name="ln623">                  break;</a>
<a name="ln624">            case ElementType::STEM_SLASH:</a>
<a name="ln625">                  Q_ASSERT(_stemSlash);</a>
<a name="ln626">                  if (_stemSlash-&gt;selected() &amp;&amp; score())</a>
<a name="ln627">                        score()-&gt;deselect(_stemSlash);</a>
<a name="ln628">                  _stemSlash = 0;</a>
<a name="ln629">                  break;</a>
<a name="ln630">            case ElementType::CHORDLINE:</a>
<a name="ln631">                  el().remove(e);</a>
<a name="ln632">                  break;</a>
<a name="ln633">            case ElementType::CHORD:</a>
<a name="ln634">                  {</a>
<a name="ln635">                  auto i = std::find(_graceNotes.begin(), _graceNotes.end(), toChord(e));</a>
<a name="ln636">                  Chord* grace = *i;</a>
<a name="ln637">                  grace-&gt;setGraceIndex(i - _graceNotes.begin());</a>
<a name="ln638">                  _graceNotes.erase(i);</a>
<a name="ln639">                  }</a>
<a name="ln640">                  break;</a>
<a name="ln641">            case ElementType::ARTICULATION:</a>
<a name="ln642">                  {</a>
<a name="ln643">                  Articulation* a = toArticulation(e);</a>
<a name="ln644">                  if (!_articulations.removeOne(a))</a>
<a name="ln645">                        qDebug(&quot;ChordRest::remove(): articulation not found&quot;);</a>
<a name="ln646">                  }</a>
<a name="ln647">                  break;</a>
<a name="ln648">            default:</a>
<a name="ln649">                  ChordRest::remove(e);</a>
<a name="ln650">                  break;</a>
<a name="ln651">            }</a>
<a name="ln652">      }</a>
<a name="ln653"> </a>
<a name="ln654">//---------------------------------------------------------</a>
<a name="ln655">//   maxHeadWidth</a>
<a name="ln656">//---------------------------------------------------------</a>
<a name="ln657"> </a>
<a name="ln658">qreal Chord::maxHeadWidth() const</a>
<a name="ln659">      {</a>
<a name="ln660">      // determine max head width in chord</a>
<a name="ln661">      qreal hw = 0;</a>
<a name="ln662">      for (const Note* n : _notes) {</a>
<a name="ln663">            qreal t = n-&gt;headWidth();</a>
<a name="ln664">            if (t &gt; hw)</a>
<a name="ln665">                  hw = t;</a>
<a name="ln666">            }</a>
<a name="ln667">      return hw;</a>
<a name="ln668">      }</a>
<a name="ln669"> </a>
<a name="ln670">//---------------------------------------------------------</a>
<a name="ln671">//   addLedgerLines</a>
<a name="ln672">//---------------------------------------------------------</a>
<a name="ln673"> </a>
<a name="ln674">void Chord::addLedgerLines()</a>
<a name="ln675">      {</a>
<a name="ln676">      // initialize for palette</a>
<a name="ln677">      int track          = 0;                   // the track lines belong to</a>
<a name="ln678">      // the line pos corresponding to the bottom line of the staff</a>
<a name="ln679">      int lineBelow      = 8;                   // assuming 5-lined &quot;staff&quot;</a>
<a name="ln680">      qreal lineDistance = 1;</a>
<a name="ln681">      qreal mag         = 1;</a>
<a name="ln682">      bool staffVisible  = true;</a>
<a name="ln683"> </a>
<a name="ln684">      if (segment()) { //not palette</a>
<a name="ln685">            Fraction tick = segment()-&gt;tick();</a>
<a name="ln686">            int idx       = staffIdx() + staffMove();</a>
<a name="ln687">            track         = staff2track(idx);</a>
<a name="ln688">            Staff* st     = score()-&gt;staff(idx);</a>
<a name="ln689">            lineBelow     = (st-&gt;lines(tick) - 1) * 2;</a>
<a name="ln690">            lineDistance  = st-&gt;lineDistance(tick);</a>
<a name="ln691">            mag           = staff()-&gt;mag(tick);</a>
<a name="ln692">            staffVisible  = !staff()-&gt;invisible();</a>
<a name="ln693">            }</a>
<a name="ln694"> </a>
<a name="ln695">      // need ledger lines?</a>
<a name="ln696">      if (downLine() &lt;= lineBelow + 1 &amp;&amp; upLine() &gt;= -1)</a>
<a name="ln697">            return;</a>
<a name="ln698"> </a>
<a name="ln699">      // the extra length of a ledger line with respect to notehead (half of it on each side)</a>
<a name="ln700">      qreal extraLen = score()-&gt;styleP(Sid::ledgerLineLength) * mag * 0.5;</a>
<a name="ln701">      qreal hw;</a>
<a name="ln702">      qreal minX, maxX;                         // note extrema in raster units</a>
<a name="ln703">      int   minLine, maxLine;</a>
<a name="ln704">      bool  visible = false;</a>
<a name="ln705">      qreal x;</a>
<a name="ln706"> </a>
<a name="ln707">      // scan chord notes, collecting visibility and x and y extrema</a>
<a name="ln708">      // NOTE: notes are sorted from bottom to top (line no. decreasing)</a>
<a name="ln709">      // notes are scanned twice from outside (bottom or top) toward the staff</a>
<a name="ln710">      // each pass stops at the first note without ledger lines</a>
<a name="ln711">      size_t n = _notes.size();</a>
<a name="ln712">      for (size_t j = 0; j &lt; 2; j++) {             // notes are scanned twice...</a>
<a name="ln713">            int from, delta;</a>
<a name="ln714">            vector&lt;LedgerLineData&gt; vecLines;</a>
<a name="ln715">            hw = 0.0;</a>
<a name="ln716">            minX  = maxX = 0;</a>
<a name="ln717">            minLine = 0;</a>
<a name="ln718">            maxLine = lineBelow;</a>
<a name="ln719">            if (j == 0) {                       // ...once from lowest up...</a>
<a name="ln720">                  from  = 0;</a>
<a name="ln721">                  delta = +1;</a>
<a name="ln722">                  }</a>
<a name="ln723">            else {</a>
<a name="ln724">                  from = int(n)-1;                   // ...once from highest down</a>
<a name="ln725">                  delta = -1;</a>
<a name="ln726">                  }</a>
<a name="ln727">            for (int i = from; i &lt; int(n) &amp;&amp; i &gt;= 0 ; i += delta) {</a>
<a name="ln728">                  Note* note = _notes.at(i);</a>
<a name="ln729">                  int l = note-&gt;line();</a>
<a name="ln730"> </a>
<a name="ln731">                  // if 1st pass and note not below staff or 2nd pass and note not above staff</a>
<a name="ln732">                  if ((!j &amp;&amp; l &lt;= lineBelow + 1) || (j &amp;&amp; l &gt;= -1))</a>
<a name="ln733">                        break;                  // stop this pass</a>
<a name="ln734">                  // round line number to even number toward 0</a>
<a name="ln735">                  if (l &lt; 0)</a>
<a name="ln736">                        l = (l + 1) &amp; ~ 1;</a>
<a name="ln737">                  else</a>
<a name="ln738">                        l = l &amp; ~ 1;</a>
<a name="ln739"> </a>
<a name="ln740">                  if (note-&gt;visible())          // if one note is visible,</a>
<a name="ln741">                        visible = true;         // all lines between it and the staff are visible</a>
<a name="ln742">                  hw = qMax(hw, note-&gt;headWidth());</a>
<a name="ln743"> </a>
<a name="ln744">                  //</a>
<a name="ln745">                  // Experimental:</a>
<a name="ln746">                  //  shorten ledger line to avoid collisions with accidentals</a>
<a name="ln747">                  //</a>
<a name="ln748">                  // bool accid = (note-&gt;accidental() &amp;&amp; note-&gt;line() &gt;= (l-1) &amp;&amp; note-&gt;line() &lt;= (l+1) );</a>
<a name="ln749">                  //</a>
<a name="ln750">                  // TODO : do something with this accid flag in the following code!</a>
<a name="ln751">                  //</a>
<a name="ln752"> </a>
<a name="ln753">                  // check if note horiz. pos. is outside current range</a>
<a name="ln754">                  // if more length on the right, increase range</a>
<a name="ln755">//                  note-&gt;layout();</a>
<a name="ln756"> </a>
<a name="ln757">                  //ledger lines need the leftmost point of the notehead with a respect of bbox</a>
<a name="ln758">                  x = note-&gt;pos().x() + note-&gt;bboxXShift();</a>
<a name="ln759">                  if (x - extraLen &lt; minX) {</a>
<a name="ln760">                        minX  = x - extraLen;</a>
<a name="ln761">                        // increase width of all lines between this one and the staff</a>
<a name="ln762">                        for (auto&amp; d : vecLines) {</a>
<a name="ln763">                              if (!d.accidental &amp;&amp; ((l &lt; 0 &amp;&amp; d.line &gt;= l) || (l &gt; 0 &amp;&amp; d.line &lt;= l)) )</a>
<a name="ln764">                                    d.minX = minX ;</a>
<a name="ln765">                              }</a>
<a name="ln766">                        }</a>
<a name="ln767">                  // same for left side</a>
<a name="ln768">                  if (x + hw + extraLen &gt; maxX) {</a>
<a name="ln769">                        maxX = x + hw + extraLen;</a>
<a name="ln770">                        for (auto&amp; d : vecLines)</a>
<a name="ln771">                              if ( (l &lt; 0 &amp;&amp; d.line &gt;= l) || (l &gt; 0 &amp;&amp; d.line &lt;= l) )</a>
<a name="ln772">                                    d.maxX = maxX;</a>
<a name="ln773">                        }</a>
<a name="ln774"> </a>
<a name="ln775">                  LedgerLineData lld;</a>
<a name="ln776">                  // check if note vert. pos. is outside current range</a>
<a name="ln777">                  // and, if so, add data for new line(s)</a>
<a name="ln778">                  if (l &lt; minLine) {</a>
<a name="ln779">                        for (int i1 = l; i1 &lt; minLine; i1 += 2) {</a>
<a name="ln780">                              lld.line = i1;</a>
<a name="ln781">                              if (lineDistance != 1.0)</a>
<a name="ln782">                                    lld.line *= lineDistance;</a>
<a name="ln783">                              lld.minX = minX;</a>
<a name="ln784">                              lld.maxX = maxX;</a>
<a name="ln785">                              lld.visible = visible;</a>
<a name="ln786">                              lld.accidental = false;</a>
<a name="ln787">                              vecLines.push_back(lld);</a>
<a name="ln788">                              }</a>
<a name="ln789">                        minLine = l;</a>
<a name="ln790">                        }</a>
<a name="ln791">                  if (l &gt; maxLine) {</a>
<a name="ln792">                        for (int i1 = maxLine+2; i1 &lt;= l; i1 += 2) {</a>
<a name="ln793">                              lld.line = i1;</a>
<a name="ln794">                              if (lineDistance != 1.0)</a>
<a name="ln795">                                    lld.line *= lineDistance;</a>
<a name="ln796">                              lld.minX = minX;</a>
<a name="ln797">                              lld.maxX = maxX;</a>
<a name="ln798">                              lld.visible = visible;</a>
<a name="ln799">                              lld.accidental = false;</a>
<a name="ln800">                              vecLines.push_back(lld);</a>
<a name="ln801">                              }</a>
<a name="ln802">                        maxLine = l;</a>
<a name="ln803">                        }</a>
<a name="ln804">                  }</a>
<a name="ln805">            if (minLine &lt; 0 || maxLine &gt; lineBelow) {</a>
<a name="ln806">                  qreal _spatium = spatium();</a>
<a name="ln807">                  qreal stepDistance = 0.5;     // staff() ? staff()-&gt;lineDistance() * 0.5 : 0.5;</a>
<a name="ln808">                  for (auto lld : vecLines) {</a>
<a name="ln809">                        LedgerLine* h = new LedgerLine(score());</a>
<a name="ln810">                        h-&gt;setParent(this);</a>
<a name="ln811">                        h-&gt;setTrack(track);</a>
<a name="ln812">                        h-&gt;setVisible(lld.visible &amp;&amp; staffVisible);</a>
<a name="ln813">                        h-&gt;setLen(lld.maxX - lld.minX);</a>
<a name="ln814">                        h-&gt;setPos(lld.minX, lld.line * _spatium * stepDistance);</a>
<a name="ln815">                        h-&gt;setNext(_ledgerLines);</a>
<a name="ln816">                        _ledgerLines = h;</a>
<a name="ln817">                        }</a>
<a name="ln818">                  }</a>
<a name="ln819">            }</a>
<a name="ln820">      for (LedgerLine* ll = _ledgerLines; ll; ll = ll-&gt;next())</a>
<a name="ln821">            ll-&gt;layout();</a>
<a name="ln822">      }</a>
<a name="ln823"> </a>
<a name="ln824">//-----------------------------------------------------------------------------</a>
<a name="ln825">//   computeUp</a>
<a name="ln826">//    rules:</a>
<a name="ln827">//      single note:</a>
<a name="ln828">//          All notes beneath the middle line: upward stems</a>
<a name="ln829">//          All notes on or above the middle line: downward stems</a>
<a name="ln830">//      two notes:</a>
<a name="ln831">//          If the interval above the middle line is greater than the interval</a>
<a name="ln832">//             below the middle line: downward stems</a>
<a name="ln833">//          If the interval below the middle line is greater than the interval</a>
<a name="ln834">//             above the middle line: upward stems</a>
<a name="ln835">//          If the two notes are the same distance from the middle line:</a>
<a name="ln836">//             stem can go in either direction. but most engravers prefer</a>
<a name="ln837">//             downward stems</a>
<a name="ln838">//      &gt; two notes:</a>
<a name="ln839">//          If the interval of the highest note above the middle line is greater</a>
<a name="ln840">//             than the interval of the lowest note below the middle line:</a>
<a name="ln841">//             downward stems</a>
<a name="ln842">//          If the interval of the lowest note below the middle line is greater</a>
<a name="ln843">//             than the interval of the highest note above the middle line:</a>
<a name="ln844">//             upward stem</a>
<a name="ln845">//          If the highest and the lowest notes are the same distance from</a>
<a name="ln846">//          the middle line:, use these rules to determine stem direction:</a>
<a name="ln847">//             - If the majority of the notes are above the middle:</a>
<a name="ln848">//               downward stems</a>
<a name="ln849">//             - If the majority of the notes are below the middle:</a>
<a name="ln850">//               upward stems</a>
<a name="ln851">//    TABlatures:</a>
<a name="ln852">//       stems beside staves:</a>
<a name="ln853">//          All stems are up / down according to TAB::stemsDown() setting</a>
<a name="ln854">//       stems through staves:</a>
<a name="ln855">//          Same rules as per pitched staves</a>
<a name="ln856">//-----------------------------------------------------------------------------</a>
<a name="ln857"> </a>
<a name="ln858">void Chord::computeUp()</a>
<a name="ln859">      {</a>
<a name="ln860">      Q_ASSERT(!_notes.empty());</a>
<a name="ln861">      const Staff* st = staff();</a>
<a name="ln862">      const StaffType* tab = st ? st-&gt;staffType(tick()) : 0;</a>
<a name="ln863">      bool tabStaff  = tab &amp;&amp; tab-&gt;isTabStaff();</a>
<a name="ln864">      // TAB STAVES</a>
<a name="ln865">      if (tabStaff) {</a>
<a name="ln866">            // if no stems or stem beside staves</a>
<a name="ln867">            if (tab-&gt;stemless() || !tab-&gt;stemThrough()) {</a>
<a name="ln868">                  // if measure has voices, set stem direction according to voice</a>
<a name="ln869">                  if (measure()-&gt;hasVoices(staffIdx()))</a>
<a name="ln870">                        _up = !(track() % 2);</a>
<a name="ln871">                  else                          // if only voice 1,</a>
<a name="ln872">                        // unconditionally set to down if not stems or according to TAB stem direction otherwise</a>
<a name="ln873">                        // (even with no stems, stem direction controls position of slurs and ties)</a>
<a name="ln874">                        _up = tab-&gt;stemless() ? false : !tab-&gt;stemsDown();</a>
<a name="ln875">                  return;</a>
<a name="ln876">                  }</a>
<a name="ln877">            // if TAB has stems through staves, chain into standard processing</a>
<a name="ln878">            }</a>
<a name="ln879"> </a>
<a name="ln880">      // PITCHED STAVES (or TAB with stems through staves)</a>
<a name="ln881">      if (_stemDirection != Direction::AUTO)</a>
<a name="ln882">            _up = _stemDirection == Direction::UP;</a>
<a name="ln883">      else if (!parent())</a>
<a name="ln884">            // hack for palette and drumset editor</a>
<a name="ln885">            _up = upNote()-&gt;line() &gt; 4;</a>
<a name="ln886">      else if (_noteType != NoteType::NORMAL) {</a>
<a name="ln887">            //</a>
<a name="ln888">            // stem direction for grace notes</a>
<a name="ln889">            //</a>
<a name="ln890">            if (measure()-&gt;hasVoices(staffIdx()))</a>
<a name="ln891">                  _up = !(track() % 2);</a>
<a name="ln892">            else</a>
<a name="ln893">                  _up = true;</a>
<a name="ln894">            }</a>
<a name="ln895">      else if (staffMove())</a>
<a name="ln896">            _up = staffMove() &gt; 0;</a>
<a name="ln897">      else if (measure()-&gt;hasVoices(staffIdx()))</a>
<a name="ln898">            _up = !(track() % 2);</a>
<a name="ln899">      else {</a>
<a name="ln900">            int   dnMaxLine   = staff()-&gt;middleLine(tick());</a>
<a name="ln901">            int   ud          = (tabStaff ? upString() * 2 : upNote()-&gt;line() ) - dnMaxLine;</a>
<a name="ln902">            // standard case: if only 1 note or cross beaming</a>
<a name="ln903">            if (_notes.size() == 1 || staffMove()) {</a>
<a name="ln904">                  if (staffMove() &gt; 0)</a>
<a name="ln905">                        _up = true;</a>
<a name="ln906">                  else if (staffMove() &lt; 0)</a>
<a name="ln907">                        _up = false;</a>
<a name="ln908">                  else</a>
<a name="ln909">                        _up = ud &gt; 0;</a>
<a name="ln910">                  }</a>
<a name="ln911">            // if more than 1 note, compare extrema (topmost and bottommost notes)</a>
<a name="ln912">            else {</a>
<a name="ln913">                  int dd = (tabStaff ? downString() * 2 : downNote()-&gt;line() ) - dnMaxLine;</a>
<a name="ln914">                  // if extrema symmetrical, average directions of intermediate notes</a>
<a name="ln915">                  if (-ud == dd) {</a>
<a name="ln916">                        int up = 0;</a>
<a name="ln917">                        size_t n = _notes.size();</a>
<a name="ln918">                        for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln919">                              const Note* currentNote = _notes.at(i);</a>
<a name="ln920">                              int l = tabStaff ? currentNote-&gt;string() * 2 : currentNote-&gt;line();</a>
<a name="ln921">                              if (l &lt;= dnMaxLine)</a>
<a name="ln922">                                    --up;</a>
<a name="ln923">                              else</a>
<a name="ln924">                                    ++up;</a>
<a name="ln925">                              }</a>
<a name="ln926">                        _up = up &gt; 0;</a>
<a name="ln927">                        }</a>
<a name="ln928">                  // if extrema not symmetrical, set _up to prevailing</a>
<a name="ln929">                  else</a>
<a name="ln930">                        _up = dd &gt; -ud;</a>
<a name="ln931">                  }</a>
<a name="ln932">            }</a>
<a name="ln933">      }</a>
<a name="ln934"> </a>
<a name="ln935">//---------------------------------------------------------</a>
<a name="ln936">//   selectedNote</a>
<a name="ln937">//---------------------------------------------------------</a>
<a name="ln938"> </a>
<a name="ln939">Note* Chord::selectedNote() const</a>
<a name="ln940">      {</a>
<a name="ln941">      Note* note = 0;</a>
<a name="ln942">      size_t n = _notes.size();</a>
<a name="ln943">      for (size_t i = 0; i &lt; n; ++i) {</a>
<a name="ln944">            Note* currentNote = _notes.at(i);</a>
<a name="ln945">            if (currentNote-&gt;selected()) {</a>
<a name="ln946">                  if (note)</a>
<a name="ln947">                        return 0;</a>
<a name="ln948">                  note = currentNote;</a>
<a name="ln949">                  }</a>
<a name="ln950">            }</a>
<a name="ln951">      return note;</a>
<a name="ln952">      }</a>
<a name="ln953"> </a>
<a name="ln954">//---------------------------------------------------------</a>
<a name="ln955">//   Chord::write</a>
<a name="ln956">//---------------------------------------------------------</a>
<a name="ln957"> </a>
<a name="ln958">void Chord::write(XmlWriter&amp; xml) const</a>
<a name="ln959">      {</a>
<a name="ln960">      for (Chord* c : _graceNotes) {</a>
<a name="ln961">            c-&gt;write(xml);</a>
<a name="ln962">            }</a>
<a name="ln963">      writeBeam(xml);</a>
<a name="ln964">      xml.stag(this);</a>
<a name="ln965">      ChordRest::writeProperties(xml);</a>
<a name="ln966">      for (const Articulation* a : _articulations)</a>
<a name="ln967">            a-&gt;write(xml);</a>
<a name="ln968">      switch (_noteType) {</a>
<a name="ln969">            case NoteType::NORMAL:</a>
<a name="ln970">                  break;</a>
<a name="ln971">            case NoteType::ACCIACCATURA:</a>
<a name="ln972">                  xml.tagE(&quot;acciaccatura&quot;);</a>
<a name="ln973">                  break;</a>
<a name="ln974">            case NoteType::APPOGGIATURA:</a>
<a name="ln975">                  xml.tagE(&quot;appoggiatura&quot;);</a>
<a name="ln976">                  break;</a>
<a name="ln977">            case NoteType::GRACE4:</a>
<a name="ln978">                  xml.tagE(&quot;grace4&quot;);</a>
<a name="ln979">                  break;</a>
<a name="ln980">            case NoteType::GRACE16:</a>
<a name="ln981">                  xml.tagE(&quot;grace16&quot;);</a>
<a name="ln982">                  break;</a>
<a name="ln983">            case NoteType::GRACE32:</a>
<a name="ln984">                  xml.tagE(&quot;grace32&quot;);</a>
<a name="ln985">                  break;</a>
<a name="ln986">            case NoteType::GRACE8_AFTER:</a>
<a name="ln987">                  xml.tagE(&quot;grace8after&quot;);</a>
<a name="ln988">                  break;</a>
<a name="ln989">            case NoteType::GRACE16_AFTER:</a>
<a name="ln990">                  xml.tagE(&quot;grace16after&quot;);</a>
<a name="ln991">                  break;</a>
<a name="ln992">            case NoteType::GRACE32_AFTER:</a>
<a name="ln993">                  xml.tagE(&quot;grace32after&quot;);</a>
<a name="ln994">                  break;</a>
<a name="ln995">            default:</a>
<a name="ln996">                  break;</a>
<a name="ln997">            }</a>
<a name="ln998"> </a>
<a name="ln999">      if (_noStem)</a>
<a name="ln1000">            xml.tag(&quot;noStem&quot;, _noStem);</a>
<a name="ln1001">      else if (_stem &amp;&amp; (_stem-&gt;isUserModified() || (_stem-&gt;userLen() != 0.0)))</a>
<a name="ln1002">            _stem-&gt;write(xml);</a>
<a name="ln1003">      if (_hook &amp;&amp; _hook-&gt;isUserModified())</a>
<a name="ln1004">            _hook-&gt;write(xml);</a>
<a name="ln1005">      if (_stemSlash &amp;&amp; _stemSlash-&gt;isUserModified())</a>
<a name="ln1006">            _stemSlash-&gt;write(xml);</a>
<a name="ln1007">      writeProperty(xml, Pid::STEM_DIRECTION);</a>
<a name="ln1008">      for (Note* n : _notes)</a>
<a name="ln1009">            n-&gt;write(xml);</a>
<a name="ln1010">      if (_arpeggio)</a>
<a name="ln1011">            _arpeggio-&gt;write(xml);</a>
<a name="ln1012">      if (_tremolo &amp;&amp; tremoloChordType() != TremoloChordType::TremoloSecondNote)</a>
<a name="ln1013">            _tremolo-&gt;write(xml);</a>
<a name="ln1014">      for (Element* e : el())</a>
<a name="ln1015">            e-&gt;write(xml);</a>
<a name="ln1016">      xml.etag();</a>
<a name="ln1017">      }</a>
<a name="ln1018"> </a>
<a name="ln1019">//---------------------------------------------------------</a>
<a name="ln1020">//   Chord::read</a>
<a name="ln1021">//---------------------------------------------------------</a>
<a name="ln1022"> </a>
<a name="ln1023">void Chord::read(XmlReader&amp; e)</a>
<a name="ln1024">      {</a>
<a name="ln1025">      while (e.readNextStartElement()) {</a>
<a name="ln1026">            if (readProperties(e))</a>
<a name="ln1027">                  ;</a>
<a name="ln1028">            else</a>
<a name="ln1029">                  e.unknown();</a>
<a name="ln1030">            }</a>
<a name="ln1031">      }</a>
<a name="ln1032"> </a>
<a name="ln1033">//---------------------------------------------------------</a>
<a name="ln1034">//   readProperties</a>
<a name="ln1035">//---------------------------------------------------------</a>
<a name="ln1036"> </a>
<a name="ln1037">bool Chord::readProperties(XmlReader&amp; e)</a>
<a name="ln1038">      {</a>
<a name="ln1039">      const QStringRef&amp; tag(e.name());</a>
<a name="ln1040"> </a>
<a name="ln1041">      if (tag == &quot;Note&quot;) {</a>
<a name="ln1042">            Note* note = new Note(score());</a>
<a name="ln1043">            // the note needs to know the properties of the track it belongs to</a>
<a name="ln1044">            note-&gt;setTrack(track());</a>
<a name="ln1045">            note-&gt;setChord(this);</a>
<a name="ln1046">            note-&gt;read(e);</a>
<a name="ln1047">            add(note);</a>
<a name="ln1048">            }</a>
<a name="ln1049">      else if (ChordRest::readProperties(e))</a>
<a name="ln1050">            ;</a>
<a name="ln1051">      else if (tag == &quot;Stem&quot;) {</a>
<a name="ln1052">            Stem* s = new Stem(score());</a>
<a name="ln1053">            s-&gt;read(e);</a>
<a name="ln1054">            add(s);</a>
<a name="ln1055">            }</a>
<a name="ln1056">      else if (tag == &quot;Hook&quot;) {</a>
<a name="ln1057">            _hook = new Hook(score());</a>
<a name="ln1058">            _hook-&gt;read(e);</a>
<a name="ln1059">            add(_hook);</a>
<a name="ln1060">            }</a>
<a name="ln1061">      else if (tag == &quot;appoggiatura&quot;) {</a>
<a name="ln1062">            _noteType = NoteType::APPOGGIATURA;</a>
<a name="ln1063">            e.readNext();</a>
<a name="ln1064">            }</a>
<a name="ln1065">      else if (tag == &quot;acciaccatura&quot;) {</a>
<a name="ln1066">            _noteType = NoteType::ACCIACCATURA;</a>
<a name="ln1067">            e.readNext();</a>
<a name="ln1068">            }</a>
<a name="ln1069">      else if (tag == &quot;grace4&quot;) {</a>
<a name="ln1070">            _noteType = NoteType::GRACE4;</a>
<a name="ln1071">            e.readNext();</a>
<a name="ln1072">            }</a>
<a name="ln1073">      else if (tag == &quot;grace16&quot;) {</a>
<a name="ln1074">            _noteType = NoteType::GRACE16;</a>
<a name="ln1075">            e.readNext();</a>
<a name="ln1076">            }</a>
<a name="ln1077">      else if (tag == &quot;grace32&quot;) {</a>
<a name="ln1078">            _noteType = NoteType::GRACE32;</a>
<a name="ln1079">            e.readNext();</a>
<a name="ln1080">            }</a>
<a name="ln1081">      else if (tag == &quot;grace8after&quot;) {</a>
<a name="ln1082">            _noteType = NoteType::GRACE8_AFTER;</a>
<a name="ln1083">            e.readNext();</a>
<a name="ln1084">            }</a>
<a name="ln1085">      else if (tag == &quot;grace16after&quot;) {</a>
<a name="ln1086">            _noteType = NoteType::GRACE16_AFTER;</a>
<a name="ln1087">            e.readNext();</a>
<a name="ln1088">            }</a>
<a name="ln1089">      else if (tag == &quot;grace32after&quot;) {</a>
<a name="ln1090">            _noteType = NoteType::GRACE32_AFTER;</a>
<a name="ln1091">            e.readNext();</a>
<a name="ln1092">            }</a>
<a name="ln1093">      else if (tag == &quot;StemSlash&quot;) {</a>
<a name="ln1094">            StemSlash* ss = new StemSlash(score());</a>
<a name="ln1095">            ss-&gt;read(e);</a>
<a name="ln1096">            add(ss);</a>
<a name="ln1097">            }</a>
<a name="ln1098">      else if (readProperty(tag, e, Pid::STEM_DIRECTION))</a>
<a name="ln1099">            ;</a>
<a name="ln1100">      else if (tag == &quot;noStem&quot;)</a>
<a name="ln1101">            _noStem = e.readInt();</a>
<a name="ln1102">      else if (tag == &quot;Arpeggio&quot;) {</a>
<a name="ln1103">            _arpeggio = new Arpeggio(score());</a>
<a name="ln1104">            _arpeggio-&gt;setTrack(track());</a>
<a name="ln1105">            _arpeggio-&gt;read(e);</a>
<a name="ln1106">            _arpeggio-&gt;setParent(this);</a>
<a name="ln1107">            }</a>
<a name="ln1108">      else if (tag == &quot;Tremolo&quot;) {</a>
<a name="ln1109">            _tremolo = new Tremolo(score());</a>
<a name="ln1110">            _tremolo-&gt;setTrack(track());</a>
<a name="ln1111">            _tremolo-&gt;read(e);</a>
<a name="ln1112">            _tremolo-&gt;setParent(this);</a>
<a name="ln1113">            _tremolo-&gt;setDurationType(durationType());</a>
<a name="ln1114">            }</a>
<a name="ln1115">      else if (tag == &quot;tickOffset&quot;)       // obsolete</a>
<a name="ln1116">            ;</a>
<a name="ln1117">      else if (tag == &quot;ChordLine&quot;) {</a>
<a name="ln1118">            ChordLine* cl = new ChordLine(score());</a>
<a name="ln1119">            cl-&gt;read(e);</a>
<a name="ln1120">            add(cl);</a>
<a name="ln1121">            }</a>
<a name="ln1122">      else</a>
<a name="ln1123">            return false;</a>
<a name="ln1124">      return true;</a>
<a name="ln1125">      }</a>
<a name="ln1126"> </a>
<a name="ln1127">//---------------------------------------------------------</a>
<a name="ln1128">//   upPos</a>
<a name="ln1129">//---------------------------------------------------------</a>
<a name="ln1130"> </a>
<a name="ln1131">qreal Chord::upPos() const</a>
<a name="ln1132">      {</a>
<a name="ln1133">      return upNote()-&gt;pos().y();</a>
<a name="ln1134">      }</a>
<a name="ln1135"> </a>
<a name="ln1136">//---------------------------------------------------------</a>
<a name="ln1137">//   downPos</a>
<a name="ln1138">//---------------------------------------------------------</a>
<a name="ln1139"> </a>
<a name="ln1140">qreal Chord::downPos() const</a>
<a name="ln1141">      {</a>
<a name="ln1142">      return downNote()-&gt;pos().y();</a>
<a name="ln1143">      }</a>
<a name="ln1144"> </a>
<a name="ln1145">//---------------------------------------------------------</a>
<a name="ln1146">//   centerX</a>
<a name="ln1147">//    return x position for attributes</a>
<a name="ln1148">//---------------------------------------------------------</a>
<a name="ln1149"> </a>
<a name="ln1150">qreal Chord::centerX() const</a>
<a name="ln1151">      {</a>
<a name="ln1152">      // TAB 'notes' are always centered on the stem</a>
<a name="ln1153">      const Staff* st = staff();</a>
<a name="ln1154">      if (st-&gt;isTabStaff(tick()))</a>
<a name="ln1155">            return st-&gt;staffType(tick())-&gt;chordStemPosX(this) * spatium();</a>
<a name="ln1156"> </a>
<a name="ln1157">      const Note* note = up() ? upNote() : downNote();</a>
<a name="ln1158">      qreal x = note-&gt;pos().x() + note-&gt;noteheadCenterX();</a>
<a name="ln1159">      if (note-&gt;mirror())</a>
<a name="ln1160">                  x += (note-&gt;headBodyWidth()) * (up() ? -1.0 : 1.0);</a>
<a name="ln1161">      return x;</a>
<a name="ln1162">      }</a>
<a name="ln1163"> </a>
<a name="ln1164">//---------------------------------------------------------</a>
<a name="ln1165">//   scanElements</a>
<a name="ln1166">//---------------------------------------------------------</a>
<a name="ln1167"> </a>
<a name="ln1168">void Chord::scanElements(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln1169">      {</a>
<a name="ln1170">      for (Articulation* a : _articulations)</a>
<a name="ln1171">            func(data, a);</a>
<a name="ln1172">      if (_hook)</a>
<a name="ln1173">            func(data, _hook );</a>
<a name="ln1174">      if (_stem)</a>
<a name="ln1175">            func(data, _stem);</a>
<a name="ln1176">      if (_stemSlash)</a>
<a name="ln1177">            func(data, _stemSlash);</a>
<a name="ln1178">      if (_arpeggio)</a>
<a name="ln1179">            func(data, _arpeggio);</a>
<a name="ln1180">      if (_tremolo &amp;&amp; (tremoloChordType() != TremoloChordType::TremoloSecondNote))</a>
<a name="ln1181">            func(data, _tremolo);</a>
<a name="ln1182">      const Staff* st = staff();</a>
<a name="ln1183">      if ((st &amp;&amp; st-&gt;showLedgerLines(tick())) || !st)       // also for palette</a>
<a name="ln1184">            for (LedgerLine* ll = _ledgerLines; ll; ll = ll-&gt;next())</a>
<a name="ln1185">                  func(data, ll);</a>
<a name="ln1186">      size_t n = _notes.size();</a>
<a name="ln1187">      for (size_t i = 0; i &lt; n; ++i)</a>
<a name="ln1188">            _notes.at(i)-&gt;scanElements(data, func, all);</a>
<a name="ln1189">      for (Chord* chord : _graceNotes)</a>
<a name="ln1190">            chord-&gt;scanElements(data, func, all);</a>
<a name="ln1191">      for (Element* e : el())</a>
<a name="ln1192">            e-&gt;scanElements(data, func, all);</a>
<a name="ln1193">      ChordRest::scanElements(data, func, all);</a>
<a name="ln1194">      }</a>
<a name="ln1195"> </a>
<a name="ln1196">//---------------------------------------------------------</a>
<a name="ln1197">//   processSiblings</a>
<a name="ln1198">//---------------------------------------------------------</a>
<a name="ln1199"> </a>
<a name="ln1200">void Chord::processSiblings(std::function&lt;void(Element*)&gt; func) const</a>
<a name="ln1201">      {</a>
<a name="ln1202">      if (_hook)</a>
<a name="ln1203">            func(_hook);</a>
<a name="ln1204">      if (_stem)</a>
<a name="ln1205">            func(_stem);</a>
<a name="ln1206">      if (_stemSlash)</a>
<a name="ln1207">            func(_stemSlash);</a>
<a name="ln1208">      if (_arpeggio)</a>
<a name="ln1209">            func(_arpeggio);</a>
<a name="ln1210">      if (_tremolo)</a>
<a name="ln1211">            func(_tremolo);</a>
<a name="ln1212">      for (LedgerLine* ll = _ledgerLines; ll; ll = ll-&gt;next())</a>
<a name="ln1213">            func(ll);</a>
<a name="ln1214">      for (Articulation* a : _articulations)</a>
<a name="ln1215">            func(a);</a>
<a name="ln1216">      for (Note* note : _notes)</a>
<a name="ln1217">            func(note);</a>
<a name="ln1218">      for (Element* e : el())</a>
<a name="ln1219">            func(e);</a>
<a name="ln1220">      for (Chord* chord : _graceNotes)    // process grace notes last, needed for correct shape calculation</a>
<a name="ln1221">            func(chord);</a>
<a name="ln1222">      }</a>
<a name="ln1223"> </a>
<a name="ln1224">//---------------------------------------------------------</a>
<a name="ln1225">//   setTrack</a>
<a name="ln1226">//---------------------------------------------------------</a>
<a name="ln1227"> </a>
<a name="ln1228">void Chord::setTrack(int val)</a>
<a name="ln1229">      {</a>
<a name="ln1230">      ChordRest::setTrack(val);</a>
<a name="ln1231">      processSiblings([val] (Element* e) { e-&gt;setTrack(val); } );</a>
<a name="ln1232">      }</a>
<a name="ln1233"> </a>
<a name="ln1234">//---------------------------------------------------------</a>
<a name="ln1235">//   setScore</a>
<a name="ln1236">//---------------------------------------------------------</a>
<a name="ln1237"> </a>
<a name="ln1238">void Chord::setScore(Score* s)</a>
<a name="ln1239">      {</a>
<a name="ln1240">      ChordRest::setScore(s);</a>
<a name="ln1241">      processSiblings([s] (Element* e) { e-&gt;setScore(s); } );</a>
<a name="ln1242">      }</a>
<a name="ln1243"> </a>
<a name="ln1244">//-----------------------------------------------------------------------------</a>
<a name="ln1245">//   hookAdjustment</a>
<a name="ln1246">//    Adjustment to the length of the stem in order to accommodate hooks</a>
<a name="ln1247">//    This function replaces this bit of code:</a>
<a name="ln1248">//      switch (hookIdx) {</a>
<a name="ln1249">//            case 3: normalStemLen += small() ? .5  : 0.75; break; //32nd notes</a>
<a name="ln1250">//            case 4: normalStemLen += small() ? 1.0 : 1.5;  break; //64th notes</a>
<a name="ln1251">//            case 5: normalStemLen += small() ? 1.5 : 2.25; break; //128th notes</a>
<a name="ln1252">//            }</a>
<a name="ln1253">//    which was not sufficient for two reasons:</a>
<a name="ln1254">//      1. It only lengthened the stem for 3, 4, or 5 hooks.</a>
<a name="ln1255">//      2. It was too general to produce good results for all combinations of factors.</a>
<a name="ln1256">//    This provides a way to take a number of factors into account. Further tweaking may be in order.</a>
<a name="ln1257">//-----------------------------------------------------------------------------</a>
<a name="ln1258"> </a>
<a name="ln1259">qreal hookAdjustment(QString font, int hooks, bool up, bool small)</a>
<a name="ln1260">      {</a>
<a name="ln1261">      bool fallback = MScore::useFallbackFont &amp;&amp; (hooks &gt; 5);</a>
<a name="ln1262"> </a>
<a name="ln1263">      if (font == &quot;Emmentaler&quot; &amp;&amp; !fallback) {</a>
<a name="ln1264">            if (up) {</a>
<a name="ln1265">                  if (hooks &gt; 2)</a>
<a name="ln1266">                        return (hooks - 2) * (small ? .75 : 1);</a>
<a name="ln1267">                  }</a>
<a name="ln1268">            else {</a>
<a name="ln1269">                  if (hooks == 3)</a>
<a name="ln1270">                        return (small ? .75 : 1);</a>
<a name="ln1271">                  else if (hooks &gt; 3)</a>
<a name="ln1272">                        return (hooks - 2) * (small ? .5 : .75);</a>
<a name="ln1273">                  }</a>
<a name="ln1274">            }</a>
<a name="ln1275">      else if (font == &quot;Gonville&quot; &amp;&amp; !fallback) {</a>
<a name="ln1276">            if (up) {</a>
<a name="ln1277">                  if (hooks &gt; 2)</a>
<a name="ln1278">                        return (hooks - 2) * (small ? .5 : .75);</a>
<a name="ln1279">                  }</a>
<a name="ln1280">            else {</a>
<a name="ln1281">                  if (hooks &gt; 1)</a>
<a name="ln1282">                        return (hooks - 1) * (small ? .5 : .75);</a>
<a name="ln1283">                  }</a>
<a name="ln1284">            }</a>
<a name="ln1285">      else if (font == &quot;MuseJazz&quot;) {</a>
<a name="ln1286">            if (hooks &gt; 2)</a>
<a name="ln1287">                  return (hooks - 2) * (small ? .75 : 1);</a>
<a name="ln1288">            }</a>
<a name="ln1289">      else {</a>
<a name="ln1290">            if (hooks &gt; 2)</a>
<a name="ln1291">                  return (hooks - 2) * (small ? .5 : .75);</a>
<a name="ln1292">            }</a>
<a name="ln1293">      return 0;</a>
<a name="ln1294">      }</a>
<a name="ln1295"> </a>
<a name="ln1296">//-----------------------------------------------------------------------------</a>
<a name="ln1297">//   defaultStemLength</a>
<a name="ln1298">///   Get the default stem length for this chord</a>
<a name="ln1299">//-----------------------------------------------------------------------------</a>
<a name="ln1300"> </a>
<a name="ln1301">qreal Chord::defaultStemLength() const</a>
<a name="ln1302">      {</a>
<a name="ln1303">      Note* downnote;</a>
<a name="ln1304">      qreal stemLen;</a>
<a name="ln1305">      qreal _spatium     = spatium();</a>
<a name="ln1306">      int hookIdx        = durationType().hooks();</a>
<a name="ln1307">      downnote           = downNote();</a>
<a name="ln1308">      int ul             = upLine();</a>
<a name="ln1309">      int dl             = downLine();</a>
<a name="ln1310">      const Staff* st    = staff();</a>
<a name="ln1311">      qreal lineDistance = st ? st-&gt;lineDistance(tick()) : 1.0;</a>
<a name="ln1312"> </a>
<a name="ln1313">      const StaffType* tab = (st &amp;&amp; st-&gt;isTabStaff(tick())) ? st-&gt;staffType(tick()) : nullptr;</a>
<a name="ln1314">      if (tab) {</a>
<a name="ln1315">            // require stems only if TAB is not stemless and this chord has a stem</a>
<a name="ln1316">            if (!tab-&gt;stemless() &amp;&amp; _stem) {</a>
<a name="ln1317">                  // if stems are beside staff, apply special formatting</a>
<a name="ln1318">                  if (!tab-&gt;stemThrough()) {</a>
<a name="ln1319">                        // process stem:</a>
<a name="ln1320">                        return tab-&gt;chordStemLength(this) * _spatium;</a>
<a name="ln1321">                        }</a>
<a name="ln1322">                  }</a>
<a name="ln1323">            }</a>
<a name="ln1324">      else if (lineDistance != 1.0) {</a>
<a name="ln1325">            // convert to actual distance from top of staff in sp</a>
<a name="ln1326">            // ul *= lineDistance;</a>
<a name="ln1327">            // dl *= lineDistance;</a>
<a name="ln1328">            }</a>
<a name="ln1329"> </a>
<a name="ln1330">      if (tab &amp;&amp; !tab-&gt;onLines()) {       // if TAB and frets above strings, move 1 position up</a>
<a name="ln1331">            --ul;</a>
<a name="ln1332">            --dl;</a>
<a name="ln1333">            }</a>
<a name="ln1334">      bool shortenStem = score()-&gt;styleB(Sid::shortenStem);</a>
<a name="ln1335">      if (hookIdx &gt;= 2 || _tremolo)</a>
<a name="ln1336">            shortenStem = false;</a>
<a name="ln1337"> </a>
<a name="ln1338">      Spatium progression = score()-&gt;styleS(Sid::shortStemProgression);</a>
<a name="ln1339">      qreal shortest      = score()-&gt;styleS(Sid::shortestStem).val();</a>
<a name="ln1340">      if (hookIdx) {</a>
<a name="ln1341">            if (up()) {</a>
<a name="ln1342">                  if (shortest &lt; 3.0)</a>
<a name="ln1343">                        shortest = 3.0;</a>
<a name="ln1344">                  }</a>
<a name="ln1345">            else {</a>
<a name="ln1346">                  if (shortest &lt; 3.5)</a>
<a name="ln1347">                        shortest = 3.5;</a>
<a name="ln1348">                  }</a>
<a name="ln1349">            }</a>
<a name="ln1350"> </a>
<a name="ln1351">      qreal normalStemLen = small() ? 2.5 : 3.5;</a>
<a name="ln1352">      normalStemLen += hookAdjustment(score()-&gt;styleSt(Sid::MusicalSymbolFont), hookIdx, up(), small());</a>
<a name="ln1353">      if (hookIdx &amp;&amp; tab == 0) {</a>
<a name="ln1354">            if (up() &amp;&amp; durationType().dots()) {</a>
<a name="ln1355">                  //</a>
<a name="ln1356">                  // avoid collision of dot with hook</a>
<a name="ln1357">                  //</a>
<a name="ln1358">                  if (!(ul &amp; 1))</a>
<a name="ln1359">                        normalStemLen += .5;</a>
<a name="ln1360">                  shortenStem = false;</a>
<a name="ln1361">                  }</a>
<a name="ln1362">            }</a>
<a name="ln1363"> </a>
<a name="ln1364">      if (isGrace()) {</a>
<a name="ln1365">            // grace notes stems are not subject to normal</a>
<a name="ln1366">            // stem rules</a>
<a name="ln1367">            stemLen =  qAbs(ul - dl) * .5;</a>
<a name="ln1368">            stemLen += normalStemLen * score()-&gt;styleD(Sid::graceNoteMag);</a>
<a name="ln1369">            if (up())</a>
<a name="ln1370">                  stemLen *= -1;</a>
<a name="ln1371">            }</a>
<a name="ln1372">      else {</a>
<a name="ln1373">            // normal note (not grace)</a>
<a name="ln1374">            qreal staffHeight = st ? st-&gt;lines(tick()) - 1 : 4;</a>
<a name="ln1375">            if (!tab)</a>
<a name="ln1376">                  staffHeight *= lineDistance;</a>
<a name="ln1377">            qreal staffHlfHgt = staffHeight * 0.5;</a>
<a name="ln1378">            if (up()) {                   // stem up</a>
<a name="ln1379">                  qreal dy  = dl * .5;                      // note-side vert. pos.</a>
<a name="ln1380">                  qreal sel = ul * .5 - normalStemLen;      // stem end vert. pos</a>
<a name="ln1381"> </a>
<a name="ln1382">                  // if stem ends above top line (with some exceptions), shorten it</a>
<a name="ln1383">                  if (shortenStem &amp;&amp; (sel &lt; 0.0) &amp;&amp; (hookIdx == 0 || tab || !downnote-&gt;mirror()))</a>
<a name="ln1384">                        sel -= sel  * progression.val();</a>
<a name="ln1385">                  if (sel &gt; staffHlfHgt)                    // if stem ends below ('&gt;') staff mid position,</a>
<a name="ln1386">                        sel = staffHlfHgt;                  // stretch it to mid position</a>
<a name="ln1387">                  stemLen = sel - dy;                       // actual stem length</a>
<a name="ln1388">                  if (-stemLen &lt; shortest)                  // is stem too short,</a>
<a name="ln1389">                        stemLen = -shortest;                // lengthen it to shortest possible length</a>
<a name="ln1390">                  }</a>
<a name="ln1391">            else {                        // stem down</a>
<a name="ln1392">                  qreal uy  = ul * .5;                      // note-side vert. pos.</a>
<a name="ln1393">                  qreal sel = dl * .5 + normalStemLen;      // stem end vert. pos.</a>
<a name="ln1394"> </a>
<a name="ln1395">                  // if stem ends below bottom line (with some exceptions), shorten it</a>
<a name="ln1396">                  if (shortenStem &amp;&amp; (sel &gt; staffHeight) &amp;&amp; (hookIdx == 0 || tab || downnote-&gt;mirror()))</a>
<a name="ln1397">                        sel -= (sel - staffHeight)  * progression.val();</a>
<a name="ln1398">                  if (sel &lt; staffHlfHgt)                    // if stem ends above ('&lt;') staff mid position,</a>
<a name="ln1399">                        sel = staffHlfHgt;                  // stretch it to mid position</a>
<a name="ln1400">                  stemLen = sel - uy;                       // actual stem length</a>
<a name="ln1401">                  if (stemLen &lt; shortest)                   // if stem too short,</a>
<a name="ln1402">                        stemLen = shortest;                 // lengthen it to shortest possible position</a>
<a name="ln1403">                  }</a>
<a name="ln1404">            }</a>
<a name="ln1405"> </a>
<a name="ln1406">      // adjust stem len for tremolo</a>
<a name="ln1407">      if (_tremolo &amp;&amp; !_tremolo-&gt;twoNotes() &amp;&amp; !_tremolo-&gt;placeMidStem()) {</a>
<a name="ln1408">            // Use the old algorithm for stem lengthening. It not always</a>
<a name="ln1409">            // optimal but still performs better when not placing the tremolo</a>
<a name="ln1410">            // at stem middle. TODO: rework minAbsStemLen() to perform</a>
<a name="ln1411">            // correctly in this case too.</a>
<a name="ln1412"> </a>
<a name="ln1413">            // hook up odd lines</a>
<a name="ln1414">            static const int tab1[2][2][2][4] = {</a>
<a name="ln1415">                  { { { 0, 0, 0,  1 },  // stem - down - even - lines</a>
<a name="ln1416">                      { 0, 0, 0,  2 }   // stem - down - odd - lines</a>
<a name="ln1417">                      },</a>
<a name="ln1418">                    { { 0, 0, 0, -1 },  // stem - up - even - lines</a>
<a name="ln1419">                      { 0, 0, 0, -2 }   // stem - up - odd - lines</a>
<a name="ln1420">                      }</a>
<a name="ln1421">                    },</a>
<a name="ln1422">                  { { { 0, 0, 1, 2 },   // hook - down - even - lines</a>
<a name="ln1423">                      { 0, 0, 1, 2 }    // hook - down - odd - lines</a>
<a name="ln1424">                      },</a>
<a name="ln1425">                    { { 0, 0, -1, -2 }, // hook - up - even - lines</a>
<a name="ln1426">                      { 0, 0, -1, -2 }  // hook - up - odd - lines</a>
<a name="ln1427">                      }</a>
<a name="ln1428">                    }</a>
<a name="ln1429">                  };</a>
<a name="ln1430">            int odd = (up() ? upLine() : downLine()) &amp; 1;</a>
<a name="ln1431">            int n = tab1[hookIdx ? 1 : 0][up() ? 1 : 0][odd][_tremolo-&gt;lines()-1];</a>
<a name="ln1432">            stemLen += n * .5;</a>
<a name="ln1433">            }</a>
<a name="ln1434"> </a>
<a name="ln1435">      if (tab)</a>
<a name="ln1436">            stemLen *= lineDistance;</a>
<a name="ln1437"> </a>
<a name="ln1438">      const qreal sgn = up() ? -1.0 : 1.0;</a>
<a name="ln1439">      qreal stemLenPoints = stemLen * _spatium;</a>
<a name="ln1440">      const qreal minAbsStemLen = minAbsStemLength();</a>
<a name="ln1441">      if (sgn * stemLenPoints &lt; minAbsStemLen)</a>
<a name="ln1442">            stemLenPoints = sgn * minAbsStemLen;</a>
<a name="ln1443"> </a>
<a name="ln1444">      return stemLenPoints;</a>
<a name="ln1445">      }</a>
<a name="ln1446"> </a>
<a name="ln1447">//---------------------------------------------------------</a>
<a name="ln1448">//   minAbsStemLength</a>
<a name="ln1449">//---------------------------------------------------------</a>
<a name="ln1450"> </a>
<a name="ln1451">qreal Chord::minAbsStemLength() const</a>
<a name="ln1452">      {</a>
<a name="ln1453">      if (!_tremolo || _tremolo-&gt;twoNotes() || !_tremolo-&gt;placeMidStem())</a>
<a name="ln1454">            return 0.0;</a>
<a name="ln1455"> </a>
<a name="ln1456">      int beamLvl = beams();</a>
<a name="ln1457">      const bool hasHook = (beamLvl &gt; 0) &amp;&amp; !beam();</a>
<a name="ln1458">      if (hasHook)</a>
<a name="ln1459">            ++beamLvl; // reserve more space for stem with both hook and tremolo</a>
<a name="ln1460">      const qreal beamDist = beam() ? beam()-&gt;beamDist() : (0.5 * spatium());</a>
<a name="ln1461">      const qreal tremoloSpacing = 0.5 * spatium(); // TODO: style setting</a>
<a name="ln1462"> </a>
<a name="ln1463">      return beamLvl * beamDist + _tremolo-&gt;height() + 2 * tremoloSpacing;</a>
<a name="ln1464">      }</a>
<a name="ln1465"> </a>
<a name="ln1466">//---------------------------------------------------------</a>
<a name="ln1467">//   layoutStem1</a>
<a name="ln1468">///   Layout _stem and _stemSlash</a>
<a name="ln1469">//</a>
<a name="ln1470">//    Called before layout spacing of notes.</a>
<a name="ln1471">//    Create stem if necessary.</a>
<a name="ln1472">//---------------------------------------------------------</a>
<a name="ln1473"> </a>
<a name="ln1474">void Chord::layoutStem1()</a>
<a name="ln1475">      {</a>
<a name="ln1476">      const Staff* stf = staff();</a>
<a name="ln1477">      const StaffType* st = stf ? stf-&gt;staffType(tick()) : 0;</a>
<a name="ln1478">      if (durationType().hasStem() &amp;&amp; !(_noStem || (measure() &amp;&amp; measure()-&gt;stemless(staffIdx())) || (st &amp;&amp; st-&gt;isTabStaff() &amp;&amp; st-&gt;stemless()))) {</a>
<a name="ln1479">            if (!_stem) {</a>
<a name="ln1480">                  Stem* stem = new Stem(score());</a>
<a name="ln1481">                  stem-&gt;setParent(this);</a>
<a name="ln1482">                  stem-&gt;setGenerated(true);</a>
<a name="ln1483">                  score()-&gt;undoAddElement(stem);</a>
<a name="ln1484">                  }</a>
<a name="ln1485">            if ((_noteType == NoteType::ACCIACCATURA) &amp;&amp; !(beam() &amp;&amp; beam()-&gt;elements().front() != this)) {</a>
<a name="ln1486">                  if (!_stemSlash)</a>
<a name="ln1487">                        add(new StemSlash(score()));</a>
<a name="ln1488">                  }</a>
<a name="ln1489">            else if (_stemSlash)</a>
<a name="ln1490">                  remove(_stemSlash);</a>
<a name="ln1491"> </a>
<a name="ln1492">            qreal stemWidth5 = _stem-&gt;lineWidth() * .5 * mag();</a>
<a name="ln1493">            _stem-&gt;rxpos()   = stemPosX() + (up() ? -stemWidth5 : +stemWidth5);</a>
<a name="ln1494">            _stem-&gt;setLen(defaultStemLength());</a>
<a name="ln1495">            }</a>
<a name="ln1496">      else {</a>
<a name="ln1497">            if (_stem)</a>
<a name="ln1498">                  score()-&gt;undoRemoveElement(_stem);</a>
<a name="ln1499">            if (_stemSlash)</a>
<a name="ln1500">                  score()-&gt;undoRemoveElement(_stemSlash);</a>
<a name="ln1501">            }</a>
<a name="ln1502">      }</a>
<a name="ln1503"> </a>
<a name="ln1504">//-----------------------------------------------------------------------------</a>
<a name="ln1505">//   layoutStem</a>
<a name="ln1506">///   Layout chord tremolo stem and hook.</a>
<a name="ln1507">//</a>
<a name="ln1508">//    hook: sets position</a>
<a name="ln1509">//-----------------------------------------------------------------------------</a>
<a name="ln1510"> </a>
<a name="ln1511">void Chord::layoutStem()</a>
<a name="ln1512">      {</a>
<a name="ln1513">      for (Chord* c : _graceNotes)</a>
<a name="ln1514">            c-&gt;layoutStem();</a>
<a name="ln1515">      if (_beam)</a>
<a name="ln1516">            return;</a>
<a name="ln1517"> </a>
<a name="ln1518">      // create hooks for unbeamed chords</a>
<a name="ln1519"> </a>
<a name="ln1520">      int hookIdx  = durationType().hooks();</a>
<a name="ln1521"> </a>
<a name="ln1522">      if (hookIdx &amp;&amp; !(noStem() || measure()-&gt;stemless(staffIdx()))) {</a>
<a name="ln1523">            if (!hook()) {</a>
<a name="ln1524">                  Hook* hook = new Hook(score());</a>
<a name="ln1525">                  hook-&gt;setParent(this);</a>
<a name="ln1526">                  hook-&gt;setGenerated(true);</a>
<a name="ln1527">                  score()-&gt;undoAddElement(hook);</a>
<a name="ln1528">                  }</a>
<a name="ln1529">            hook()-&gt;setHookType(up() ? hookIdx : -hookIdx);</a>
<a name="ln1530">            }</a>
<a name="ln1531">      else if (hook())</a>
<a name="ln1532">            score()-&gt;undoRemoveElement(hook());</a>
<a name="ln1533"> </a>
<a name="ln1534">      //</a>
<a name="ln1535">      // TAB</a>
<a name="ln1536">      //</a>
<a name="ln1537">      const Staff* st = staff();</a>
<a name="ln1538">      const StaffType* tab = st ? st-&gt;staffType(tick()) : 0;</a>
<a name="ln1539">      if (tab &amp;&amp; tab-&gt;isTabStaff()) {</a>
<a name="ln1540">            // if stemless TAB</a>
<a name="ln1541">            if (tab-&gt;stemless()) {</a>
<a name="ln1542">                  // if 'grid' duration symbol of MEDIALFINAL type, it is time to compute its width</a>
<a name="ln1543">                  if (_tabDur != nullptr &amp;&amp; _tabDur-&gt;beamGrid() == TabBeamGrid::MEDIALFINAL)</a>
<a name="ln1544">                        _tabDur-&gt;layout2();</a>
<a name="ln1545">                  // in all other stemless cases, do nothing</a>
<a name="ln1546">                  return;</a>
<a name="ln1547">                  }</a>
<a name="ln1548">            // not a stemless TAB; if stems are beside staff, apply special formatting</a>
<a name="ln1549">            if (!tab-&gt;stemThrough()) {</a>
<a name="ln1550">                  if (_stem) { // (duplicate code with defaultStemLength())</a>
<a name="ln1551">                        // process stem:</a>
<a name="ln1552">                        _stem-&gt;setLen(tab-&gt;chordStemLength(this) * spatium());</a>
<a name="ln1553">                        // process hook</a>
<a name="ln1554">                        hookIdx = durationType().hooks();</a>
<a name="ln1555">                        if (!up())</a>
<a name="ln1556">                              hookIdx = -hookIdx;</a>
<a name="ln1557">                        if (hookIdx &amp;&amp; _hook) {</a>
<a name="ln1558">                              _hook-&gt;setHookType(hookIdx);</a>
<a name="ln1559">#if 0</a>
<a name="ln1560">                              _hook-&gt;layout();</a>
<a name="ln1561">                              QPointF p(_stem-&gt;hookPos());</a>
<a name="ln1562">                              if (up()) {</a>
<a name="ln1563">                                    p.ry() -= _hook-&gt;bbox().top();</a>
<a name="ln1564">                                    p.rx() -= _stem-&gt;width();</a>
<a name="ln1565">                                    }</a>
<a name="ln1566">                              else {</a>
<a name="ln1567">                                    p.ry() -= _hook-&gt;bbox().bottom();</a>
<a name="ln1568">                                    p.rx() -= _stem-&gt;width();</a>
<a name="ln1569">                                    }</a>
<a name="ln1570">                              _hook-&gt;setPos(p);</a>
<a name="ln1571">#endif</a>
<a name="ln1572">                              }</a>
<a name="ln1573">                        }</a>
<a name="ln1574">                  return;</a>
<a name="ln1575">                  }</a>
<a name="ln1576">            // if stems are through staff, use standard formatting</a>
<a name="ln1577">            }</a>
<a name="ln1578"> </a>
<a name="ln1579">      //</a>
<a name="ln1580">      // NON-TAB (or TAB with stems through staff)</a>
<a name="ln1581">      //</a>
<a name="ln1582">      if (_stem) {</a>
<a name="ln1583">            if (_hook) {</a>
<a name="ln1584">                  _hook-&gt;layout();</a>
<a name="ln1585">                  QPointF p(_stem-&gt;hookPos());</a>
<a name="ln1586">                  if (up()) {</a>
<a name="ln1587">                        p.ry() -= _hook-&gt;bbox().top();</a>
<a name="ln1588">                        p.rx() -= _stem-&gt;width();</a>
<a name="ln1589">                        }</a>
<a name="ln1590">                  else {</a>
<a name="ln1591">                        p.ry() -= _hook-&gt;bbox().bottom();</a>
<a name="ln1592">                        p.rx() -= _stem-&gt;width();</a>
<a name="ln1593">                        }</a>
<a name="ln1594">                  _hook-&gt;setPos(p);</a>
<a name="ln1595">                  }</a>
<a name="ln1596">            if (_stemSlash)</a>
<a name="ln1597">                  _stemSlash-&gt;layout();</a>
<a name="ln1598">            }</a>
<a name="ln1599"> </a>
<a name="ln1600">      //-----------------------------------------</a>
<a name="ln1601">      //    process tremolo</a>
<a name="ln1602">      //-----------------------------------------</a>
<a name="ln1603"> </a>
<a name="ln1604">//      if (_tremolo)</a>
<a name="ln1605">//            _tremolo-&gt;layout();</a>
<a name="ln1606">      }</a>
<a name="ln1607"> </a>
<a name="ln1608">//---------------------------------------------------------</a>
<a name="ln1609">//    underBeam: true, if grace note is placed under a beam.</a>
<a name="ln1610">//---------------------------------------------------------</a>
<a name="ln1611"> </a>
<a name="ln1612">bool Chord::underBeam() const</a>
<a name="ln1613">      {</a>
<a name="ln1614">      if (_noteType == NoteType::NORMAL)</a>
<a name="ln1615">          return false;</a>
<a name="ln1616">      const Chord* cr = toChord(parent());</a>
<a name="ln1617">      Beam* beam = cr-&gt;beam();</a>
<a name="ln1618">      if(!beam || !cr-&gt;beam()-&gt;up())</a>
<a name="ln1619">            return false;</a>
<a name="ln1620">      int s = beam-&gt;elements().count();</a>
<a name="ln1621">      if (isGraceBefore()){</a>
<a name="ln1622">            if (beam-&gt;elements()[0] != cr)</a>
<a name="ln1623">                return true;</a>
<a name="ln1624">            }</a>
<a name="ln1625">      if (isGraceAfter()){</a>
<a name="ln1626">            if (beam-&gt;elements()[s - 1] != cr)</a>
<a name="ln1627">                return true;</a>
<a name="ln1628">            }</a>
<a name="ln1629">      return false;</a>
<a name="ln1630">      }</a>
<a name="ln1631"> </a>
<a name="ln1632">//---------------------------------------------------------</a>
<a name="ln1633">//   layout2</a>
<a name="ln1634">//    Called after horizontal positions of all elements</a>
<a name="ln1635">//    are fixed.</a>
<a name="ln1636">//---------------------------------------------------------</a>
<a name="ln1637"> </a>
<a name="ln1638">void Chord::layout2()</a>
<a name="ln1639">      {</a>
<a name="ln1640">      for (Chord* c : _graceNotes)</a>
<a name="ln1641">            c-&gt;layout2();</a>
<a name="ln1642"> </a>
<a name="ln1643">      qreal mag = staff()-&gt;mag(tick());</a>
<a name="ln1644"> </a>
<a name="ln1645">      //</a>
<a name="ln1646">      // position after-chord grace notes</a>
<a name="ln1647">      // room for them has been reserved in Chord::layout()</a>
<a name="ln1648">      //</a>
<a name="ln1649"> </a>
<a name="ln1650">      QVector&lt;Chord*&gt; gna = graceNotesAfter();</a>
<a name="ln1651">      if (!gna.empty()) {</a>
<a name="ln1652">            qreal minNoteDist = score()-&gt;styleP(Sid::minNoteDistance) * mag * score()-&gt;styleD(Sid::graceNoteMag);</a>
<a name="ln1653">            // position grace notes from the rightmost to the leftmost</a>
<a name="ln1654">            // get segment (of whatever type) at the end of this chord; if none, get measure last segment</a>
<a name="ln1655">            Segment* s = measure()-&gt;tick2segment(segment()-&gt;tick() + actualTicks(), SegmentType::All);</a>
<a name="ln1656">            if (s == nullptr)</a>
<a name="ln1657">                  s = measure()-&gt;last();</a>
<a name="ln1658">            if (s == segment())           // if our segment is the last, no adjacent segment found</a>
<a name="ln1659">                  s = nullptr;</a>
<a name="ln1660">            // start from the right (if next segment found, x of it relative to this chord;</a>
<a name="ln1661">            // chord right space otherwise)</a>
<a name="ln1662">            Chord* last = gna.last();</a>
<a name="ln1663">            qreal xOff =  s ? (s-&gt;pos().x() - s-&gt;staffShape(last-&gt;vStaffIdx()).left()) - (segment()-&gt;pos().x() + pos().x()) : _spaceRw;</a>
<a name="ln1664">            // final distance: if near to another chord, leave minNoteDist at right of last grace</a>
<a name="ln1665">            // else leave note-to-barline distance;</a>
<a name="ln1666">            xOff -= (s != nullptr &amp;&amp; s-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln1667">                  ? score()-&gt;styleP(Sid::noteBarDistance) * mag</a>
<a name="ln1668">                  : minNoteDist;</a>
<a name="ln1669">            // scan grace note list from the end</a>
<a name="ln1670">            int n = gna.size();</a>
<a name="ln1671">            for (int i = n-1; i &gt;= 0; i--) {</a>
<a name="ln1672">                  Chord* g = gna.value(i);</a>
<a name="ln1673">                  xOff -= g-&gt;_spaceRw;                  // move to left by grace note left space (incl. grace own width)</a>
<a name="ln1674">                  g-&gt;rxpos() = xOff;</a>
<a name="ln1675">                  xOff -= minNoteDist + g-&gt;_spaceLw;    // move to left by grace note right space and inter-grace distance</a>
<a name="ln1676">                  }</a>
<a name="ln1677">            }</a>
<a name="ln1678">      if (_tabDur)</a>
<a name="ln1679">            _tabDur-&gt;layout2();</a>
<a name="ln1680">      }</a>
<a name="ln1681"> </a>
<a name="ln1682">//---------------------------------------------------------</a>
<a name="ln1683">//   updatePercussionNotes</a>
<a name="ln1684">//---------------------------------------------------------</a>
<a name="ln1685"> </a>
<a name="ln1686">static void updatePercussionNotes(Chord* c, const Drumset* drumset)</a>
<a name="ln1687">      {</a>
<a name="ln1688">      for (Chord* ch : c-&gt;graceNotes())</a>
<a name="ln1689">            updatePercussionNotes(ch, drumset);</a>
<a name="ln1690">      std::vector&lt;Note*&gt; lnotes(c-&gt;notes());  // we need a copy!</a>
<a name="ln1691">      for (Note* note : lnotes) {</a>
<a name="ln1692">            if (!drumset)</a>
<a name="ln1693">                  note-&gt;setLine(0);</a>
<a name="ln1694">            else {</a>
<a name="ln1695">                  int pitch = note-&gt;pitch();</a>
<a name="ln1696">                  if (!drumset-&gt;isValid(pitch)) {</a>
<a name="ln1697">                        note-&gt;setLine(0);</a>
<a name="ln1698">                        qWarning(&quot;unmapped drum note %d&quot;, pitch);</a>
<a name="ln1699">                        }</a>
<a name="ln1700">                  else if (!note-&gt;fixed()) {</a>
<a name="ln1701">                        note-&gt;undoChangeProperty(Pid::HEAD_GROUP, int(drumset-&gt;noteHead(pitch)));</a>
<a name="ln1702">                        note-&gt;setLine(drumset-&gt;line(pitch));</a>
<a name="ln1703">                        }</a>
<a name="ln1704">                  }</a>
<a name="ln1705">            }</a>
<a name="ln1706">      }</a>
<a name="ln1707"> </a>
<a name="ln1708">//---------------------------------------------------------</a>
<a name="ln1709">//   cmdUpdateNotes</a>
<a name="ln1710">//---------------------------------------------------------</a>
<a name="ln1711"> </a>
<a name="ln1712">void Chord::cmdUpdateNotes(AccidentalState* as)</a>
<a name="ln1713">      {</a>
<a name="ln1714">      // TAB_STAFF is different, as each note has to be fretted</a>
<a name="ln1715">      // in the context of the all of the chords of the whole segment</a>
<a name="ln1716"> </a>
<a name="ln1717">      const Staff* st = staff();</a>
<a name="ln1718">      StaffGroup staffGroup = st-&gt;staffType(tick())-&gt;group();</a>
<a name="ln1719">      if (staffGroup == StaffGroup::TAB) {</a>
<a name="ln1720">            const Instrument* instrument = part()-&gt;instrument();</a>
<a name="ln1721">            for (Chord* ch : graceNotes())</a>
<a name="ln1722">                  instrument-&gt;stringData()-&gt;fretChords(ch);</a>
<a name="ln1723">            instrument-&gt;stringData()-&gt;fretChords(this);</a>
<a name="ln1724">            return;</a>
<a name="ln1725">            }</a>
<a name="ln1726"> </a>
<a name="ln1727">      // PITCHED_ and PERCUSSION_STAFF can go note by note</a>
<a name="ln1728"> </a>
<a name="ln1729">      if (staffGroup == StaffGroup::STANDARD) {</a>
<a name="ln1730">            for (Chord* ch : graceNotesBefore()) {</a>
<a name="ln1731">                  std::vector&lt;Note*&gt; notes(ch-&gt;notes());  // we need a copy!</a>
<a name="ln1732">                  for (Note* note : notes)</a>
<a name="ln1733">                        note-&gt;updateAccidental(as);</a>
<a name="ln1734">                  ch-&gt;sortNotes();</a>
<a name="ln1735">                  }</a>
<a name="ln1736">            std::vector&lt;Note*&gt; lnotes(notes());  // we need a copy!</a>
<a name="ln1737">            for (Note* note : lnotes) {</a>
<a name="ln1738">                  if (note-&gt;tieBack() &amp;&amp; note-&gt;tpc() == note-&gt;tieBack()-&gt;startNote()-&gt;tpc()) {</a>
<a name="ln1739">                        // same pitch</a>
<a name="ln1740">                        if (note-&gt;accidental() &amp;&amp; note-&gt;accidental()-&gt;role() == AccidentalRole::AUTO) {</a>
<a name="ln1741">                              // not courtesy</a>
<a name="ln1742">                              // TODO: remove accidental only if note is not</a>
<a name="ln1743">                              // on new system</a>
<a name="ln1744">                              score()-&gt;undoRemoveElement(note-&gt;accidental());</a>
<a name="ln1745">                              }</a>
<a name="ln1746">                        }</a>
<a name="ln1747">                  note-&gt;updateAccidental(as);</a>
<a name="ln1748">                  }</a>
<a name="ln1749">            for (Chord* ch : graceNotesAfter()) {</a>
<a name="ln1750">                  std::vector&lt;Note*&gt; notes(ch-&gt;notes());  // we need a copy!</a>
<a name="ln1751">                  for (Note* note : notes)</a>
<a name="ln1752">                        note-&gt;updateAccidental(as);</a>
<a name="ln1753">                  ch-&gt;sortNotes();</a>
<a name="ln1754">                  }</a>
<a name="ln1755">            }</a>
<a name="ln1756">      else if (staffGroup == StaffGroup::PERCUSSION) {</a>
<a name="ln1757">            const Instrument* instrument = part()-&gt;instrument();</a>
<a name="ln1758">            const Drumset* drumset = instrument-&gt;drumset();</a>
<a name="ln1759">            if (!drumset)</a>
<a name="ln1760">                  qWarning(&quot;no drumset&quot;);</a>
<a name="ln1761">            updatePercussionNotes(this, drumset);</a>
<a name="ln1762">            }</a>
<a name="ln1763"> </a>
<a name="ln1764">      sortNotes();</a>
<a name="ln1765">      }</a>
<a name="ln1766"> </a>
<a name="ln1767">//---------------------------------------------------------</a>
<a name="ln1768">//   pagePos</a>
<a name="ln1769">//---------------------------------------------------------</a>
<a name="ln1770"> </a>
<a name="ln1771">QPointF Chord::pagePos() const</a>
<a name="ln1772">      {</a>
<a name="ln1773">      if (isGrace()) {</a>
<a name="ln1774">            QPointF p(pos());</a>
<a name="ln1775">            if (parent() == 0)</a>
<a name="ln1776">                  return p;</a>
<a name="ln1777">            p.rx() = pageX();</a>
<a name="ln1778"> </a>
<a name="ln1779">            const Chord* pc = static_cast&lt;const Chord*&gt;(parent());</a>
<a name="ln1780">            System* system = pc-&gt;segment()-&gt;system();</a>
<a name="ln1781">            if (!system)</a>
<a name="ln1782">                  return p;</a>
<a name="ln1783">            p.ry() += system-&gt;staffYpage(vStaffIdx());</a>
<a name="ln1784">            return p;</a>
<a name="ln1785">            }</a>
<a name="ln1786">      return Element::pagePos();</a>
<a name="ln1787">      }</a>
<a name="ln1788"> </a>
<a name="ln1789">//---------------------------------------------------------</a>
<a name="ln1790">//   layout</a>
<a name="ln1791">//---------------------------------------------------------</a>
<a name="ln1792"> </a>
<a name="ln1793">void Chord::layout()</a>
<a name="ln1794">      {</a>
<a name="ln1795">      if (_notes.empty())</a>
<a name="ln1796">            return;</a>
<a name="ln1797">      if (staff() &amp;&amp; staff()-&gt;isTabStaff(tick()))</a>
<a name="ln1798">            layoutTablature();</a>
<a name="ln1799">      else</a>
<a name="ln1800">            layoutPitched();</a>
<a name="ln1801">      }</a>
<a name="ln1802"> </a>
<a name="ln1803">//---------------------------------------------------------</a>
<a name="ln1804">//   layoutPitched</a>
<a name="ln1805">//---------------------------------------------------------</a>
<a name="ln1806"> </a>
<a name="ln1807">void Chord::layoutPitched()</a>
<a name="ln1808">      {</a>
<a name="ln1809">      int gi = 0;</a>
<a name="ln1810">      for (Chord* c : _graceNotes) {</a>
<a name="ln1811">            // HACK: graceIndex is not well-maintained on add &amp; remove</a>
<a name="ln1812">            // so rebuild now</a>
<a name="ln1813">            c-&gt;setGraceIndex(gi++);</a>
<a name="ln1814">            if (c-&gt;isGraceBefore())</a>
<a name="ln1815">                  c-&gt;layoutPitched();</a>
<a name="ln1816">            }</a>
<a name="ln1817">      QVector&lt;Chord*&gt; graceNotesBefore = Chord::graceNotesBefore();</a>
<a name="ln1818">      int gnb = graceNotesBefore.size();</a>
<a name="ln1819"> </a>
<a name="ln1820">      // lay out grace notes after separately so they are processed left to right</a>
<a name="ln1821">      // (they are normally stored right to left)</a>
<a name="ln1822"> </a>
<a name="ln1823">      QVector&lt;Chord*&gt; gna = graceNotesAfter();</a>
<a name="ln1824">      for (Chord* c : gna)</a>
<a name="ln1825">            c-&gt;layoutPitched();</a>
<a name="ln1826"> </a>
<a name="ln1827">      qreal _spatium         = spatium();</a>
<a name="ln1828">      qreal mag_             = staff() ? staff()-&gt;mag(tick()) : 1.0;    // palette elements do not have a staff</a>
<a name="ln1829">      qreal dotNoteDistance  = score()-&gt;styleP(Sid::dotNoteDistance)  * mag_;</a>
<a name="ln1830">      qreal minNoteDistance  = score()-&gt;styleP(Sid::minNoteDistance)  * mag_;</a>
<a name="ln1831">      qreal minTieLength     = score()-&gt;styleP(Sid::MinTieLength)     * mag_;</a>
<a name="ln1832"> </a>
<a name="ln1833">      qreal graceMag         = score()-&gt;styleD(Sid::graceNoteMag);</a>
<a name="ln1834">      qreal chordX           = (_noteType == NoteType::NORMAL) ? ipos().x() : 0.0;</a>
<a name="ln1835"> </a>
<a name="ln1836">      while (_ledgerLines) {</a>
<a name="ln1837">            LedgerLine* l = _ledgerLines-&gt;next();</a>
<a name="ln1838">            delete _ledgerLines;</a>
<a name="ln1839">            _ledgerLines = l;</a>
<a name="ln1840">            }</a>
<a name="ln1841"> </a>
<a name="ln1842">      qreal lll    = 0.0;         // space to leave at left of chord</a>
<a name="ln1843">      qreal rrr    = 0.0;         // space to leave at right of chord</a>
<a name="ln1844">      qreal lhead  = 0.0;         // amount of notehead to left of chord origin</a>
<a name="ln1845">      Note* upnote = upNote();</a>
<a name="ln1846"> </a>
<a name="ln1847">      delete _tabDur;   // no TAB? no duration symbol! (may happen when converting a TAB into PITCHED)</a>
<a name="ln1848">      _tabDur = 0;</a>
<a name="ln1849"> </a>
<a name="ln1850">      if (!segment()) {</a>
<a name="ln1851">            //</a>
<a name="ln1852">            // hack for use in palette</a>
<a name="ln1853">            //</a>
<a name="ln1854">            size_t n = _notes.size();</a>
<a name="ln1855">            for (size_t i = 0; i &lt; n; i++) {</a>
<a name="ln1856">                  Note* note = _notes.at(i);</a>
<a name="ln1857">                  note-&gt;layout();</a>
<a name="ln1858">                  qreal x = 0.0;</a>
<a name="ln1859">                  qreal y = note-&gt;line() * _spatium * .5;</a>
<a name="ln1860">                  note-&gt;setPos(x, y);</a>
<a name="ln1861">                  }</a>
<a name="ln1862">            computeUp();</a>
<a name="ln1863">            layoutStem1();</a>
<a name="ln1864">            if (_stem) { //false when dragging notes from drum palette</a>
<a name="ln1865">                  qreal stemWidth5 = _stem-&gt;lineWidth() * .5;</a>
<a name="ln1866">                  _stem-&gt;rxpos()   = up() ? (upNote()-&gt;headBodyWidth() - stemWidth5) : stemWidth5;</a>
<a name="ln1867">                  }</a>
<a name="ln1868">            addLedgerLines();</a>
<a name="ln1869">            return;</a>
<a name="ln1870">            }</a>
<a name="ln1871"> </a>
<a name="ln1872">      //-----------------------------------------</a>
<a name="ln1873">      //  process notes</a>
<a name="ln1874">      //-----------------------------------------</a>
<a name="ln1875"> </a>
<a name="ln1876">      for (Note* note : _notes) {</a>
<a name="ln1877">            note-&gt;layout();</a>
<a name="ln1878"> </a>
<a name="ln1879">            qreal x1 = note-&gt;pos().x() + chordX;</a>
<a name="ln1880">            qreal x2 = x1 + note-&gt;headWidth();</a>
<a name="ln1881">            lll      = qMax(lll, -x1);</a>
<a name="ln1882">            rrr      = qMax(rrr, x2);</a>
<a name="ln1883">            // track amount of space due to notehead only</a>
<a name="ln1884">            lhead    = qMax(lhead, -x1);</a>
<a name="ln1885"> </a>
<a name="ln1886">            Accidental* accidental = note-&gt;accidental();</a>
<a name="ln1887">            if (accidental &amp;&amp; !note-&gt;fixed()) {</a>
<a name="ln1888">                  // convert x position of accidental to segment coordinate system</a>
<a name="ln1889">                  qreal x = accidental-&gt;pos().x() + note-&gt;pos().x() + chordX;</a>
<a name="ln1890">                  // distance from accidental to note already taken into account</a>
<a name="ln1891">                  // but here perhaps we create more padding in *front* of accidental?</a>
<a name="ln1892">                  x -= score()-&gt;styleP(Sid::accidentalDistance) * mag_;</a>
<a name="ln1893">                  lll = qMax(lll, -x);</a>
<a name="ln1894">                  }</a>
<a name="ln1895"> </a>
<a name="ln1896">            // allow extra space for shortened ties</a>
<a name="ln1897">            // this code must be kept synchronized</a>
<a name="ln1898">            // with the tie positioning code in Tie::slurPos()</a>
<a name="ln1899">            // but the allocation of space needs to be performed here</a>
<a name="ln1900">            Tie* tie;</a>
<a name="ln1901">            tie = note-&gt;tieBack();</a>
<a name="ln1902">            if (tie) {</a>
<a name="ln1903">                  tie-&gt;calculateDirection();</a>
<a name="ln1904">                  qreal overlap = 0.0;</a>
<a name="ln1905">                  bool shortStart = false;</a>
<a name="ln1906">                  Note* sn = tie-&gt;startNote();</a>
<a name="ln1907">                  Chord* sc = sn-&gt;chord();</a>
<a name="ln1908">                  if (sc &amp;&amp; sc-&gt;measure() == measure() &amp;&amp; sc == prevChordRest(this)) {</a>
<a name="ln1909">                        if (sc-&gt;notes().size() &gt; 1 || (sc-&gt;stem() &amp;&amp; sc-&gt;up() == tie-&gt;up())) {</a>
<a name="ln1910">                              shortStart = true;</a>
<a name="ln1911">                              if (sc-&gt;width() &gt; sn-&gt;width()) {</a>
<a name="ln1912">                                    // chord with second?</a>
<a name="ln1913">                                    // account for noteheads further to right</a>
<a name="ln1914">                                    qreal snEnd = sn-&gt;x() + sn-&gt;bboxRightPos();</a>
<a name="ln1915">                                    qreal scEnd = snEnd;</a>
<a name="ln1916">                                    for (unsigned i = 0; i &lt; sc-&gt;notes().size(); ++i)</a>
<a name="ln1917">                                          scEnd = qMax(scEnd, sc-&gt;notes().at(i)-&gt;x() + sc-&gt;notes().at(i)-&gt;bboxRightPos());</a>
<a name="ln1918">                                    overlap += scEnd - snEnd;</a>
<a name="ln1919">                                    }</a>
<a name="ln1920">                              else</a>
<a name="ln1921">                                    overlap -= sn-&gt;headWidth() * 0.12;</a>
<a name="ln1922">                              }</a>
<a name="ln1923">                        else</a>
<a name="ln1924">                              overlap += sn-&gt;headWidth() * 0.35;</a>
<a name="ln1925">                        if (notes().size() &gt; 1 || (stem() &amp;&amp; !up() &amp;&amp; !tie-&gt;up())) {</a>
<a name="ln1926">                              // for positive offset:</a>
<a name="ln1927">                              //    use available space</a>
<a name="ln1928">                              // for negative x offset:</a>
<a name="ln1929">                              //    space is allocated elsewhere, so don't re-allocate here</a>
<a name="ln1930">                              if (note-&gt;ipos().x() != 0.0)</a>
<a name="ln1931">                                    overlap += qAbs(note-&gt;ipos().x());</a>
<a name="ln1932">                              else</a>
<a name="ln1933">                                    overlap -= note-&gt;headWidth() * 0.12;</a>
<a name="ln1934">                              }</a>
<a name="ln1935">                        else {</a>
<a name="ln1936">                              if (shortStart)</a>
<a name="ln1937">                                    overlap += note-&gt;headWidth() * 0.15;</a>
<a name="ln1938">                              else</a>
<a name="ln1939">                                    overlap += note-&gt;headWidth() * 0.35;</a>
<a name="ln1940">                              }</a>
<a name="ln1941">                        qreal d = qMax(minTieLength - overlap, 0.0);</a>
<a name="ln1942">                        lll = qMax(lll, d);</a>
<a name="ln1943">                        }</a>
<a name="ln1944">                  }</a>
<a name="ln1945"> </a>
<a name="ln1946">            // clear layout for note-based fingerings</a>
<a name="ln1947">            for (Element* e : note-&gt;el()) {</a>
<a name="ln1948">                  if (e-&gt;isFingering()) {</a>
<a name="ln1949">                        Fingering* f = toFingering(e);</a>
<a name="ln1950">                        if (f-&gt;layoutType() == ElementType::NOTE) {</a>
<a name="ln1951">                              f-&gt;setPos(QPointF());</a>
<a name="ln1952">                              f-&gt;setbbox(QRectF());</a>
<a name="ln1953">                              }</a>
<a name="ln1954">                        }</a>
<a name="ln1955">                  }</a>
<a name="ln1956"> </a>
<a name="ln1957">            }</a>
<a name="ln1958"> </a>
<a name="ln1959">      //-----------------------------------------</a>
<a name="ln1960">      //  create ledger lines</a>
<a name="ln1961">      //-----------------------------------------</a>
<a name="ln1962"> </a>
<a name="ln1963">      addLedgerLines();</a>
<a name="ln1964"> </a>
<a name="ln1965">      if (_arpeggio) {</a>
<a name="ln1966">            qreal arpeggioDistance = score()-&gt;styleP(Sid::ArpeggioNoteDistance) * mag_;</a>
<a name="ln1967">            _arpeggio-&gt;layout();    // only for width() !</a>
<a name="ln1968">            _arpeggio-&gt;setHeight(0.0);</a>
<a name="ln1969">            qreal extraX = _arpeggio-&gt;width() + arpeggioDistance + chordX;</a>
<a name="ln1970">            qreal y1   = upnote-&gt;pos().y() - upnote-&gt;headHeight() * .5;</a>
<a name="ln1971">            _arpeggio-&gt;setPos(-(lll + extraX), y1);</a>
<a name="ln1972">            if (_arpeggio-&gt;visible())</a>
<a name="ln1973">                  lll += extraX;</a>
<a name="ln1974">            // _arpeggio-&gt;layout() called in layoutArpeggio2()</a>
<a name="ln1975"> </a>
<a name="ln1976">            // handle the special case of _arpeggio-&gt;span() &gt; 1</a>
<a name="ln1977">            // in layoutArpeggio2() after page layout has done so we</a>
<a name="ln1978">            // know the y position of the next staves</a>
<a name="ln1979">            }</a>
<a name="ln1980"> </a>
<a name="ln1981">      // allocate enough room for glissandi</a>
<a name="ln1982">      if (_endsGlissando) {</a>
<a name="ln1983">            for (const Note* note : notes()) {</a>
<a name="ln1984">                  for (const Spanner* sp : note-&gt;spannerBack()) {</a>
<a name="ln1985">                        if (sp-&gt;isGlissando()) {</a>
<a name="ln1986">                              if (toGlissando(sp)-&gt;visible()) {</a>
<a name="ln1987">                                    if (!rtick().isZero()                 // if not at beginning of measure</a>
<a name="ln1988">                                       || graceNotesBefore.size() &gt; 0) {  // or there are graces before</a>
<a name="ln1989">                                          lll += _spatium * 0.5 + minTieLength;</a>
<a name="ln1990">                                          break;</a>
<a name="ln1991">                                          }</a>
<a name="ln1992">                                    }</a>
<a name="ln1993">                              }</a>
<a name="ln1994">                        }</a>
<a name="ln1995">                  }</a>
<a name="ln1996">            // special case of system-initial glissando final note is handled in Glissando::layout() itself </a>
<a name="ln1997">            }</a>
<a name="ln1998"> </a>
<a name="ln1999">      if (dots()) {</a>
<a name="ln2000">            qreal x = dotPosX() + dotNoteDistance</a>
<a name="ln2001">               + (dots()-1) * score()-&gt;styleP(Sid::dotDotDistance) * mag_;</a>
<a name="ln2002">            x += symWidth(SymId::augmentationDot);</a>
<a name="ln2003">            rrr = qMax(rrr, x);</a>
<a name="ln2004">            }</a>
<a name="ln2005"> </a>
<a name="ln2006">      if (_hook) {</a>
<a name="ln2007">            if (beam())</a>
<a name="ln2008">                  score()-&gt;undoRemoveElement(_hook);</a>
<a name="ln2009">            else {</a>
<a name="ln2010">                  _hook-&gt;layout();</a>
<a name="ln2011">                  if (up() &amp;&amp; stem()) {</a>
<a name="ln2012">                        // hook position is not set yet</a>
<a name="ln2013">                        qreal x = _hook-&gt;bbox().right() + stem()-&gt;hookPos().x() + chordX;</a>
<a name="ln2014">                        rrr = qMax(rrr, x);</a>
<a name="ln2015">                        }</a>
<a name="ln2016">                  }</a>
<a name="ln2017">            }</a>
<a name="ln2018"> </a>
<a name="ln2019">#if 0</a>
<a name="ln2020">      if (!_articulations.isEmpty()) {</a>
<a name="ln2021">            // TODO: allocate space to avoid &quot;staircase&quot; effect</a>
<a name="ln2022">            // but we would need to determine direction in order to get correct symid &amp; bbox</a>
<a name="ln2023">            // another alternative is to limit the width contribution of the articulation in layoutArticulations2()</a>
<a name="ln2024">            //qreal aWidth = 0.0;</a>
<a name="ln2025">            for (Articulation* a : articulations())</a>
<a name="ln2026">                  a-&gt;layout();      // aWidth = qMax(aWidth, a-&gt;width());</a>
<a name="ln2027">            //qreal w = width();</a>
<a name="ln2028">            //qreal aExtra = (qMax(aWidth, w) - w) * 0.5;</a>
<a name="ln2029">            //lll = qMax(lll, aExtra);</a>
<a name="ln2030">            //rrr = qMax(rrr, aExtra);</a>
<a name="ln2031">            }</a>
<a name="ln2032">#endif</a>
<a name="ln2033"> </a>
<a name="ln2034">      _spaceLw = lll;</a>
<a name="ln2035">      _spaceRw = rrr;</a>
<a name="ln2036"> </a>
<a name="ln2037">      if (gnb) {</a>
<a name="ln2038">              qreal xl = -(_spaceLw + minNoteDistance) - chordX;</a>
<a name="ln2039">              for (int i = gnb-1; i &gt;= 0; --i) {</a>
<a name="ln2040">                    Chord* g = graceNotesBefore.value(i);</a>
<a name="ln2041">                    xl -= g-&gt;_spaceRw/* * 1.2*/;</a>
<a name="ln2042">                    g-&gt;setPos(xl, 0);</a>
<a name="ln2043">                    xl -= g-&gt;_spaceLw + minNoteDistance * graceMag;</a>
<a name="ln2044">                    }</a>
<a name="ln2045">              if (-xl &gt; _spaceLw)</a>
<a name="ln2046">                    _spaceLw = -xl;</a>
<a name="ln2047">              }</a>
<a name="ln2048">       if (!gna.empty()) {</a>
<a name="ln2049">            qreal xr = _spaceRw;</a>
<a name="ln2050">            int n = gna.size();</a>
<a name="ln2051">            for (int i = 0; i &lt;= n - 1; i++) {</a>
<a name="ln2052">                  Chord* g = gna.value(i);</a>
<a name="ln2053">                  xr += g-&gt;_spaceLw + g-&gt;_spaceRw + minNoteDistance * graceMag;</a>
<a name="ln2054">                  }</a>
<a name="ln2055">           if (xr &gt; _spaceRw)</a>
<a name="ln2056">                 _spaceRw = xr;</a>
<a name="ln2057">           }</a>
<a name="ln2058"> </a>
<a name="ln2059">      for (Element* e : el()) {</a>
<a name="ln2060">            if (e-&gt;type() == ElementType::SLUR)     // we cannot at this time as chordpositions are not fixed</a>
<a name="ln2061">                  continue;</a>
<a name="ln2062">            e-&gt;layout();</a>
<a name="ln2063">            if (e-&gt;type() == ElementType::CHORDLINE) {</a>
<a name="ln2064">                  QRectF tbbox = e-&gt;bbox().translated(e-&gt;pos());</a>
<a name="ln2065">                  qreal lx = tbbox.left() + chordX;</a>
<a name="ln2066">                  qreal rx = tbbox.right() + chordX;</a>
<a name="ln2067">                  if (-lx &gt; _spaceLw)</a>
<a name="ln2068">                        _spaceLw = -lx;</a>
<a name="ln2069">                  if (rx &gt; _spaceRw)</a>
<a name="ln2070">                        _spaceRw = rx;</a>
<a name="ln2071">                  }</a>
<a name="ln2072">            }</a>
<a name="ln2073"> </a>
<a name="ln2074">      for (Note* note : _notes)</a>
<a name="ln2075">            note-&gt;layout2();</a>
<a name="ln2076"> </a>
<a name="ln2077">      // align note-based fingerings</a>
<a name="ln2078">      std::vector&lt;Fingering*&gt; alignNote;</a>
<a name="ln2079">      qreal xNote = 10000.0;</a>
<a name="ln2080">      for (Note* note : _notes) {</a>
<a name="ln2081">            bool leftFound = false;</a>
<a name="ln2082">            for (Element* e : note-&gt;el()) {</a>
<a name="ln2083">                  if (e-&gt;isFingering() &amp;&amp; e-&gt;autoplace()) {</a>
<a name="ln2084">                        Fingering* f = toFingering(e);</a>
<a name="ln2085">                        if (f-&gt;layoutType() == ElementType::NOTE &amp;&amp; f-&gt;tid() == Tid::LH_GUITAR_FINGERING) {</a>
<a name="ln2086">                              alignNote.push_back(f);</a>
<a name="ln2087">                              if (!leftFound) {</a>
<a name="ln2088">                                    leftFound = true;</a>
<a name="ln2089">                                    qreal xf = f-&gt;ipos().x();</a>
<a name="ln2090">                                    xNote = qMin(xNote, xf);</a>
<a name="ln2091">                                    }</a>
<a name="ln2092">                              }</a>
<a name="ln2093">                        }</a>
<a name="ln2094">                  }</a>
<a name="ln2095">            }</a>
<a name="ln2096">      for (Fingering* f : alignNote)</a>
<a name="ln2097">            f-&gt;rxpos() = xNote;</a>
<a name="ln2098">      }</a>
<a name="ln2099"> </a>
<a name="ln2100">//---------------------------------------------------------</a>
<a name="ln2101">//   layoutTablature</a>
<a name="ln2102">//---------------------------------------------------------</a>
<a name="ln2103"> </a>
<a name="ln2104">void Chord::layoutTablature()</a>
<a name="ln2105">      {</a>
<a name="ln2106">      qreal _spatium          = spatium();</a>
<a name="ln2107">      qreal dotNoteDistance   = score()-&gt;styleP(Sid::dotNoteDistance);</a>
<a name="ln2108">      qreal minNoteDistance   = score()-&gt;styleP(Sid::minNoteDistance);</a>
<a name="ln2109">      qreal minTieLength      = score()-&gt;styleP(Sid::MinTieLength);</a>
<a name="ln2110"> </a>
<a name="ln2111">      for (Chord* c : _graceNotes)</a>
<a name="ln2112">            c-&gt;layoutTablature();</a>
<a name="ln2113"> </a>
<a name="ln2114">      while (_ledgerLines) {</a>
<a name="ln2115">            LedgerLine* l = _ledgerLines-&gt;next();</a>
<a name="ln2116">            delete _ledgerLines;</a>
<a name="ln2117">            _ledgerLines = l;</a>
<a name="ln2118">            }</a>
<a name="ln2119"> </a>
<a name="ln2120">      qreal lll         = 0.0;                  // space to leave at left of chord</a>
<a name="ln2121">      qreal rrr         = 0.0;                  // space to leave at right of chord</a>
<a name="ln2122">      Note* upnote      = upNote();</a>
<a name="ln2123">      qreal headWidth   = symWidth(SymId::noteheadBlack);</a>
<a name="ln2124">      const Staff* st   = staff();</a>
<a name="ln2125">      const StaffType* tab = st-&gt;staffType(tick());</a>
<a name="ln2126">      qreal lineDist    = tab-&gt;lineDistance().val() *_spatium;</a>
<a name="ln2127">      qreal stemX       = tab-&gt;chordStemPosX(this) *_spatium;</a>
<a name="ln2128">      int   ledgerLines = 0;</a>
<a name="ln2129">      qreal llY         = 0.0;</a>
<a name="ln2130"> </a>
<a name="ln2131">      size_t numOfNotes = _notes.size();</a>
<a name="ln2132">      qreal minY        = 1000.0;               // just a very large value</a>
<a name="ln2133">      for (size_t i = 0; i &lt; numOfNotes; ++i) {</a>
<a name="ln2134">            Note* note = _notes.at(i);</a>
<a name="ln2135">            note-&gt;layout();</a>
<a name="ln2136">            // set headWidth to max fret text width</a>
<a name="ln2137">            qreal fretWidth = note-&gt;bbox().width();</a>
<a name="ln2138">            if (headWidth &lt; fretWidth)</a>
<a name="ln2139">                  headWidth = fretWidth;</a>
<a name="ln2140">            // centre fret string on stem</a>
<a name="ln2141">            qreal x = stemX - fretWidth*0.5;</a>
<a name="ln2142">            qreal y = note-&gt;fixed() ? note-&gt;line() * lineDist / 2 : tab-&gt;physStringToYOffset(note-&gt;string()) * _spatium;</a>
<a name="ln2143">            note-&gt;setPos(x, y);</a>
<a name="ln2144">            if (y &lt; minY)</a>
<a name="ln2145">                  minY  = y;</a>
<a name="ln2146">            int   currLedgerLines   = tab-&gt;numOfTabLedgerLines(note-&gt;string());</a>
<a name="ln2147">            if (currLedgerLines &gt; ledgerLines) {</a>
<a name="ln2148">                  ledgerLines = currLedgerLines;</a>
<a name="ln2149">                  llY         = y;</a>
<a name="ln2150">                  }</a>
<a name="ln2151"> </a>
<a name="ln2152">            // allow extra space for shortened ties; this code must be kept synchronized</a>
<a name="ln2153">            // with the tie positioning code in Tie::slurPos()</a>
<a name="ln2154">            // but the allocation of space needs to be performed here</a>
<a name="ln2155">            Tie* tie;</a>
<a name="ln2156">            tie = note-&gt;tieBack();</a>
<a name="ln2157">            if (tie) {</a>
<a name="ln2158">                  tie-&gt;calculateDirection();</a>
<a name="ln2159">                  qreal overlap = 0.0;          // how much tie can overlap start and end notes</a>
<a name="ln2160">                  bool shortStart = false;      // whether tie should clear start note or not</a>
<a name="ln2161">                  Note* startNote = tie-&gt;startNote();</a>
<a name="ln2162">                  Chord* startChord = startNote-&gt;chord();</a>
<a name="ln2163">                  if (startChord &amp;&amp; startChord-&gt;measure() == measure() &amp;&amp; startChord == prevChordRest(this)) {</a>
<a name="ln2164">                        qreal startNoteWidth = startNote-&gt;width();</a>
<a name="ln2165">                        // overlap into start chord?</a>
<a name="ln2166">                        // if in start chord, there are several notes or stem and tie in same direction</a>
<a name="ln2167">                        if (startChord-&gt;notes().size() &gt; 1 || (startChord-&gt;stem() &amp;&amp; startChord-&gt;up() == tie-&gt;up())) {</a>
<a name="ln2168">                              // clear start note (1/8 of fret mark width)</a>
<a name="ln2169">                              shortStart = true;</a>
<a name="ln2170">                              overlap -= startNoteWidth * 0.125;</a>
<a name="ln2171">                              }</a>
<a name="ln2172">                        else        // overlap start note (by ca. 1/3 of fret mark width)</a>
<a name="ln2173">                              overlap += startNoteWidth * 0.35;</a>
<a name="ln2174">                        // overlap into end chord (this)?</a>
<a name="ln2175">                        // if several notes or neither stem or tie are up</a>
<a name="ln2176">                        if (notes().size() &gt; 1 || (stem() &amp;&amp; !up() &amp;&amp; !tie-&gt;up())) {</a>
<a name="ln2177">                              // for positive offset:</a>
<a name="ln2178">                              //    use available space</a>
<a name="ln2179">                              // for negative x offset:</a>
<a name="ln2180">                              //    space is allocated elsewhere, so don't re-allocate here</a>
<a name="ln2181">                              if (note-&gt;ipos().x() != 0.0)              // this probably does not work for TAB, as</a>
<a name="ln2182">                                    overlap += qAbs(note-&gt;ipos().x());  // _pos is used to centre the fret on the stem</a>
<a name="ln2183">                              else</a>
<a name="ln2184">                                    overlap -= fretWidth * 0.125;</a>
<a name="ln2185">                              }</a>
<a name="ln2186">                        else {</a>
<a name="ln2187">                              if (shortStart)</a>
<a name="ln2188">                                    overlap += fretWidth * 0.15;</a>
<a name="ln2189">                              else</a>
<a name="ln2190">                                    overlap += fretWidth * 0.35;</a>
<a name="ln2191">                              }</a>
<a name="ln2192">                        qreal d = qMax(minTieLength - overlap, 0.0);</a>
<a name="ln2193">                        lll = qMax(lll, d);</a>
<a name="ln2194">                        }</a>
<a name="ln2195">                  }</a>
<a name="ln2196">            }</a>
<a name="ln2197"> </a>
<a name="ln2198">      // create ledger lines, if required (in some historic styles)</a>
<a name="ln2199">      if (ledgerLines &gt; 0) {</a>
<a name="ln2200">// there seems to be no need for widening 'ledger lines' beyond fret mark widths; more 'on the field'</a>
<a name="ln2201">// tests and usage will show if this depends on the metrics of the specific fonts used or not.</a>
<a name="ln2202">//            qreal extraLen    = score()-&gt;styleS(Sid::ledgerLineLength).val() * _spatium;</a>
<a name="ln2203">            qreal extraLen    = 0;</a>
<a name="ln2204">            qreal llX         = stemX - (headWidth + extraLen) * 0.5;</a>
<a name="ln2205">            for (int i = 0; i &lt; ledgerLines; i++) {</a>
<a name="ln2206">                  LedgerLine* ldgLin = new LedgerLine(score());</a>
<a name="ln2207">                  ldgLin-&gt;setParent(this);</a>
<a name="ln2208">                  ldgLin-&gt;setTrack(track());</a>
<a name="ln2209">                  ldgLin-&gt;setVisible(visible());</a>
<a name="ln2210">                  ldgLin-&gt;setLen(headWidth + extraLen);</a>
<a name="ln2211">                  ldgLin-&gt;setPos(llX, llY);</a>
<a name="ln2212">                  ldgLin-&gt;setNext(_ledgerLines);</a>
<a name="ln2213">                  _ledgerLines = ldgLin;</a>
<a name="ln2214">                  ldgLin-&gt;layout();</a>
<a name="ln2215">                  llY += lineDist / ledgerLines;</a>
<a name="ln2216">                  }</a>
<a name="ln2217">            headWidth += extraLen;        // include ledger lines extra width in chord width</a>
<a name="ln2218">            }</a>
<a name="ln2219"> </a>
<a name="ln2220">      // horiz. spacing: leave half width at each side of the (potential) stem</a>
<a name="ln2221">      qreal halfHeadWidth = headWidth * 0.5;</a>
<a name="ln2222">      if (lll &lt; stemX - halfHeadWidth)</a>
<a name="ln2223">            lll = stemX - halfHeadWidth;</a>
<a name="ln2224">      if (rrr &lt; stemX + halfHeadWidth)</a>
<a name="ln2225">            rrr = stemX + halfHeadWidth;</a>
<a name="ln2226">      // align dots to the widest fret mark (not needed in all TAB styles, but harmless anyway)</a>
<a name="ln2227">      if (segment())</a>
<a name="ln2228">            segment()-&gt;setDotPosX(staffIdx(), headWidth);</a>
<a name="ln2229">      // if tab type is stemless or chord is stemless (possible when imported from MusicXML)</a>
<a name="ln2230">      // or measure is stemless</a>
<a name="ln2231">      // or duration longer than half (if halves have stems) or duration longer than crochet</a>
<a name="ln2232">      // remove stems</a>
<a name="ln2233">      if (tab-&gt;stemless() || _noStem || measure()-&gt;stemless(staffIdx()) || durationType().type() &lt;</a>
<a name="ln2234">         (tab-&gt;minimStyle() != TablatureMinimStyle::NONE ? TDuration::DurationType::V_HALF : TDuration::DurationType::V_QUARTER) ) {</a>
<a name="ln2235">            if (_stem)</a>
<a name="ln2236">                  score()-&gt;undo(new RemoveElement(_stem));</a>
<a name="ln2237">            if (_hook)</a>
<a name="ln2238">                  score()-&gt;undo(new RemoveElement(_hook));</a>
<a name="ln2239">            if (_beam)</a>
<a name="ln2240">                  score()-&gt;undo(new RemoveElement(_beam));</a>
<a name="ln2241">            }</a>
<a name="ln2242">      // if stem is required but missing, add it;</a>
<a name="ln2243">      // set stem position (stem length is set in Chord:layoutStem() )</a>
<a name="ln2244">      else {</a>
<a name="ln2245">            if (_stem == 0) {</a>
<a name="ln2246">                  Stem* stem = new Stem(score());</a>
<a name="ln2247">                  stem-&gt;setParent(this);</a>
<a name="ln2248">                  score()-&gt;undo(new AddElement(stem));</a>
<a name="ln2249">                  }</a>
<a name="ln2250">            _stem-&gt;setPos(tab-&gt;chordStemPos(this) * _spatium);</a>
<a name="ln2251">            if (_hook) {</a>
<a name="ln2252">                  if (beam())</a>
<a name="ln2253">                        score()-&gt;undoRemoveElement(_hook);</a>
<a name="ln2254">                  else {</a>
<a name="ln2255">                        _hook-&gt;layout();</a>
<a name="ln2256">                        if (rrr &lt; stemX + _hook-&gt;width())</a>
<a name="ln2257">                              rrr = stemX + _hook-&gt;width();</a>
<a name="ln2258"> </a>
<a name="ln2259">                        QPointF p(_stem-&gt;hookPos());</a>
<a name="ln2260">                        if (up()) {</a>
<a name="ln2261">                              p.ry() -= _hook-&gt;bbox().top();</a>
<a name="ln2262">                              p.rx() -= _stem-&gt;width();</a>
<a name="ln2263">                              }</a>
<a name="ln2264">                        else {</a>
<a name="ln2265">                              p.ry() -= _hook-&gt;bbox().bottom();</a>
<a name="ln2266">                              p.rx() -= _stem-&gt;width();</a>
<a name="ln2267">                              }</a>
<a name="ln2268">                        _hook-&gt;setPos(p);</a>
<a name="ln2269">                        }</a>
<a name="ln2270">                  }</a>
<a name="ln2271">            }</a>
<a name="ln2272">      if (!tab-&gt;genDurations()                         // if tab is not set for duration symbols</a>
<a name="ln2273">            || track2voice(track())                    // or not in first voice</a>
<a name="ln2274">            || (isGrace()                              // no tab duration symbols if grace notes</a>
<a name="ln2275">                &amp;&amp; beamMode() == Beam::Mode::AUTO)) {  // and beammode == AUTO</a>
<a name="ln2276">                                                       //</a>
<a name="ln2277">            delete _tabDur;   // delete an existing duration symbol</a>
<a name="ln2278">            _tabDur = 0;</a>
<a name="ln2279">            }</a>
<a name="ln2280">      else {</a>
<a name="ln2281">            //</a>
<a name="ln2282">            // tab duration symbols</a>
<a name="ln2283">            //</a>
<a name="ln2284">            // if no previous CR</a>
<a name="ln2285">            // OR symbol repeat set to ALWAYS</a>
<a name="ln2286">            // OR symbol repeat condition is triggered</a>
<a name="ln2287">            // OR duration type and/or number of dots is different from current CR</a>
<a name="ln2288">            // OR chord beam mode not AUTO</a>
<a name="ln2289">            // OR previous CR is a rest</a>
<a name="ln2290">            // AND no not-stem</a>
<a name="ln2291">            // set a duration symbol (trying to re-use existing symbols where existing to minimize</a>
<a name="ln2292">            // symbol creation and deletion)</a>
<a name="ln2293">            bool needTabDur = false;</a>
<a name="ln2294">            bool repeat = false;</a>
<a name="ln2295">            if (!noStem()) {</a>
<a name="ln2296">                  // check duration of prev. CR segm</a>
<a name="ln2297">                  ChordRest * prevCR = prevChordRest(this);</a>
<a name="ln2298">                  if (prevCR == 0)</a>
<a name="ln2299">                        needTabDur = true;</a>
<a name="ln2300">                  else if (beamMode() != Beam::Mode::AUTO</a>
<a name="ln2301">                        || prevCR-&gt;durationType().type() != durationType().type()</a>
<a name="ln2302">                        || prevCR-&gt;dots() != dots()</a>
<a name="ln2303">                        || prevCR-&gt;tuplet() != tuplet()</a>
<a name="ln2304">                        || prevCR-&gt;type() == ElementType::REST)</a>
<a name="ln2305">                        needTabDur = true;</a>
<a name="ln2306">                  else if (tab-&gt;symRepeat() == TablatureSymbolRepeat::ALWAYS</a>
<a name="ln2307">                        || ((tab-&gt;symRepeat() == TablatureSymbolRepeat::MEASURE ||</a>
<a name="ln2308">                              tab-&gt;symRepeat() == TablatureSymbolRepeat::SYSTEM)</a>
<a name="ln2309">                              &amp;&amp; measure() != prevCR-&gt;measure())) {</a>
<a name="ln2310">                        needTabDur = true;</a>
<a name="ln2311">                        repeat = true;</a>
<a name="ln2312">                        }</a>
<a name="ln2313">                  }</a>
<a name="ln2314">            if (needTabDur) {</a>
<a name="ln2315">                  // symbol needed; if not exist, create; if exists, update duration</a>
<a name="ln2316">                  if (!_tabDur)</a>
<a name="ln2317">                        _tabDur = new TabDurationSymbol(score(), tab, durationType().type(), dots());</a>
<a name="ln2318">                  else</a>
<a name="ln2319">                        _tabDur-&gt;setDuration(durationType().type(), dots(), tab);</a>
<a name="ln2320">                  _tabDur-&gt;setParent(this);</a>
<a name="ln2321">                  _tabDur-&gt;setRepeat(repeat);</a>
<a name="ln2322">//                  _tabDur-&gt;setMag(mag());           // useless to set grace mag: graces have no dur. symbol</a>
<a name="ln2323">                  _tabDur-&gt;layout();</a>
<a name="ln2324">                  if (minY &lt; 0) {                     // if some fret extends above tab body (like bass strings)</a>
<a name="ln2325">                        _tabDur-&gt;rypos() += minY;     // raise duration symbol</a>
<a name="ln2326">                        _tabDur-&gt;bbox().translate(0, minY);</a>
<a name="ln2327">                        }</a>
<a name="ln2328">                  }</a>
<a name="ln2329">            else {                              // symbol not needed: if exists, delete</a>
<a name="ln2330">                  delete _tabDur;</a>
<a name="ln2331">                  _tabDur = 0;</a>
<a name="ln2332">                  }</a>
<a name="ln2333">            }                             // end of if(duration_symbols)</a>
<a name="ln2334"> </a>
<a name="ln2335">      if (_arpeggio) {</a>
<a name="ln2336">            qreal headHeight = upnote-&gt;headHeight();</a>
<a name="ln2337">            _arpeggio-&gt;layout();</a>
<a name="ln2338">            lll += _arpeggio-&gt;width() + _spatium * .5;</a>
<a name="ln2339">            qreal y = upNote()-&gt;pos().y() - headHeight * .5;</a>
<a name="ln2340">            qreal h = downNote()-&gt;pos().y() + downNote()-&gt;headHeight() - y;</a>
<a name="ln2341">            _arpeggio-&gt;setHeight(h);</a>
<a name="ln2342">            _arpeggio-&gt;setPos(-lll, y);</a>
<a name="ln2343"> </a>
<a name="ln2344">            // handle the special case of _arpeggio-&gt;span() &gt; 1</a>
<a name="ln2345">            // in layoutArpeggio2() after page layout has done so we</a>
<a name="ln2346">            // know the y position of the next staves</a>
<a name="ln2347">            }</a>
<a name="ln2348"> </a>
<a name="ln2349">      // allocate enough room for glissandi</a>
<a name="ln2350">      if (_endsGlissando) {</a>
<a name="ln2351">            if (!rtick().isZero())                        // if not at beginning of measure</a>
<a name="ln2352">                  lll += (0.5 + score()-&gt;styleS(Sid::MinTieLength).val()) * _spatium;</a>
<a name="ln2353">            // special case of system-initial glissando final note is handled in Glissando::layout() itself</a>
<a name="ln2354">            }</a>
<a name="ln2355"> </a>
<a name="ln2356">      if (_hook) {</a>
<a name="ln2357">            if (beam())</a>
<a name="ln2358">                  score()-&gt;undoRemoveElement(_hook);</a>
<a name="ln2359">            else if(tab == 0) {</a>
<a name="ln2360">                  _hook-&gt;layout();</a>
<a name="ln2361">                  if (up()) {</a>
<a name="ln2362">                        // hook position is not set yet</a>
<a name="ln2363">                        qreal x = _hook-&gt;bbox().right() + stem()-&gt;hookPos().x();</a>
<a name="ln2364">                        rrr = qMax(rrr, x);</a>
<a name="ln2365">                        }</a>
<a name="ln2366">                  }</a>
<a name="ln2367">            }</a>
<a name="ln2368"> </a>
<a name="ln2369">      if (dots()) {</a>
<a name="ln2370">            qreal x = 0.0;</a>
<a name="ln2371">            // if stems are beside staff, dots are placed near to stem</a>
<a name="ln2372">            if (!tab-&gt;stemThrough()) {</a>
<a name="ln2373">                  // if there is an unbeamed hook, dots should start after the hook</a>
<a name="ln2374">                  if (_hook &amp;&amp; !beam())</a>
<a name="ln2375">                        x = _hook-&gt;width() + dotNoteDistance;</a>
<a name="ln2376">                  // if not, dots should start at a fixed distance right after the stem</a>
<a name="ln2377">                  else</a>
<a name="ln2378">                        x = STAFFTYPE_TAB_DEFAULTDOTDIST_X * _spatium;</a>
<a name="ln2379">                  if (segment())</a>
<a name="ln2380">                        segment()-&gt;setDotPosX(staffIdx(), x);</a>
<a name="ln2381">                  }</a>
<a name="ln2382">            // if stems are through staff, use dot position computed above on fret mark widths</a>
<a name="ln2383">            else</a>
<a name="ln2384">                  x = dotPosX() + dotNoteDistance</a>
<a name="ln2385">                        + (dots()-1) * score()-&gt;styleS(Sid::dotDotDistance).val() * _spatium;</a>
<a name="ln2386">            x += symWidth(SymId::augmentationDot);</a>
<a name="ln2387">            rrr = qMax(rrr, x);</a>
<a name="ln2388">            }</a>
<a name="ln2389"> </a>
<a name="ln2390">#if 0</a>
<a name="ln2391">      if (!_articulations.isEmpty()) {</a>
<a name="ln2392">            // TODO: allocate space? see layoutPitched()</a>
<a name="ln2393">            for (Articulation* a : articulations())</a>
<a name="ln2394">                  a-&gt;layout();</a>
<a name="ln2395">            }</a>
<a name="ln2396">#endif</a>
<a name="ln2397"> </a>
<a name="ln2398">      _spaceLw = lll;</a>
<a name="ln2399">      _spaceRw = rrr;</a>
<a name="ln2400"> </a>
<a name="ln2401">      qreal graceMag = score()-&gt;styleD(Sid::graceNoteMag);</a>
<a name="ln2402"> </a>
<a name="ln2403">      QVector&lt;Chord*&gt; graceNotesBefore = Chord::graceNotesBefore();</a>
<a name="ln2404">      int nb = graceNotesBefore.size();</a>
<a name="ln2405">      if (nb) {</a>
<a name="ln2406">              qreal xl = -(_spaceLw + minNoteDistance);</a>
<a name="ln2407">              for (int i = nb-1; i &gt;= 0; --i) {</a>
<a name="ln2408">                    Chord* c = graceNotesBefore.value(i);</a>
<a name="ln2409">                    xl -= c-&gt;_spaceRw/* * 1.2*/;</a>
<a name="ln2410">                    c-&gt;setPos(xl, 0);</a>
<a name="ln2411">                    xl -= c-&gt;_spaceLw + minNoteDistance * graceMag;</a>
<a name="ln2412">                    }</a>
<a name="ln2413">              if (-xl &gt; _spaceLw)</a>
<a name="ln2414">                    _spaceLw = -xl;</a>
<a name="ln2415">              }</a>
<a name="ln2416">       QVector&lt;Chord*&gt; gna = graceNotesAfter();</a>
<a name="ln2417">       int na = gna.size();</a>
<a name="ln2418">       if (na) {</a>
<a name="ln2419">           // get factor for start distance after main note. Values found by testing.</a>
<a name="ln2420">           qreal fc;</a>
<a name="ln2421">           switch (durationType().type()) {</a>
<a name="ln2422">                 case TDuration::DurationType::V_LONG:    fc = 3.8; break;</a>
<a name="ln2423">                 case TDuration::DurationType::V_BREVE:   fc = 3.8; break;</a>
<a name="ln2424">                 case TDuration::DurationType::V_WHOLE:   fc = 3.8; break;</a>
<a name="ln2425">                 case TDuration::DurationType::V_HALF:    fc = 3.6; break;</a>
<a name="ln2426">                 case TDuration::DurationType::V_QUARTER: fc = 2.1; break;</a>
<a name="ln2427">                 case TDuration::DurationType::V_EIGHTH:  fc = 1.4; break;</a>
<a name="ln2428">                 case TDuration::DurationType::V_16TH:    fc = 1.2; break;</a>
<a name="ln2429">                 default: fc = 1;</a>
<a name="ln2430">                 }</a>
<a name="ln2431">           qreal xr = fc * (_spaceRw + minNoteDistance);</a>
<a name="ln2432">           for (int i = 0; i &lt;= na - 1; i++) {</a>
<a name="ln2433">                 Chord* c = gna.value(i);</a>
<a name="ln2434">                 xr += c-&gt;_spaceLw * (i == 0 ? 1.3 : 1);</a>
<a name="ln2435">                 c-&gt;setPos(xr, 0);</a>
<a name="ln2436">                 xr += c-&gt;_spaceRw + minNoteDistance * graceMag;</a>
<a name="ln2437">                 }</a>
<a name="ln2438">           if (xr &gt; _spaceRw)</a>
<a name="ln2439">                 _spaceRw = xr;</a>
<a name="ln2440">           }</a>
<a name="ln2441">      for (Element* e : el()) {</a>
<a name="ln2442">            e-&gt;layout();</a>
<a name="ln2443">            if (e-&gt;type() == ElementType::CHORDLINE) {</a>
<a name="ln2444">                  QRectF tbbox = e-&gt;bbox().translated(e-&gt;pos());</a>
<a name="ln2445">                  qreal lx = tbbox.left();</a>
<a name="ln2446">                  qreal rx = tbbox.right();</a>
<a name="ln2447">                  if (-lx &gt; _spaceLw)</a>
<a name="ln2448">                        _spaceLw = -lx;</a>
<a name="ln2449">                  if (rx &gt; _spaceRw)</a>
<a name="ln2450">                        _spaceRw = rx;</a>
<a name="ln2451">                  }</a>
<a name="ln2452">            }</a>
<a name="ln2453"> </a>
<a name="ln2454">      for (size_t i = 0; i &lt; numOfNotes; ++i)</a>
<a name="ln2455">            _notes.at(i)-&gt;layout2();</a>
<a name="ln2456">      QRectF bb;</a>
<a name="ln2457">      processSiblings([&amp;bb] (Element* e) { bb |= e-&gt;bbox().translated(e-&gt;pos()); } );</a>
<a name="ln2458">      if (_tabDur)</a>
<a name="ln2459">            bb |= _tabDur-&gt;bbox().translated(_tabDur-&gt;pos());</a>
<a name="ln2460">      setbbox(bb);</a>
<a name="ln2461">      }</a>
<a name="ln2462"> </a>
<a name="ln2463">//---------------------------------------------------------</a>
<a name="ln2464">//   crossMeasureSetup</a>
<a name="ln2465">//---------------------------------------------------------</a>
<a name="ln2466"> </a>
<a name="ln2467">void Chord::crossMeasureSetup(bool on)</a>
<a name="ln2468">      {</a>
<a name="ln2469">      if (!on) {</a>
<a name="ln2470">            if (_crossMeasure != CrossMeasure::UNKNOWN) {</a>
<a name="ln2471">                  _crossMeasure = CrossMeasure::UNKNOWN;</a>
<a name="ln2472">                  layoutStem1();</a>
<a name="ln2473">                  }</a>
<a name="ln2474">            return;</a>
<a name="ln2475">            }</a>
<a name="ln2476">      if (_crossMeasure == CrossMeasure::UNKNOWN) {</a>
<a name="ln2477">            CrossMeasure tempCross = CrossMeasure::NONE;  // assume no cross-measure modification</a>
<a name="ln2478">            // if chord has only one note and note is tied forward</a>
<a name="ln2479">            if (notes().size() == 1 &amp;&amp; _notes[0]-&gt;tieFor()) {</a>
<a name="ln2480">                  Chord* tiedChord = _notes[0]-&gt;tieFor()-&gt;endNote()-&gt;chord();</a>
<a name="ln2481">                  // if tied note belongs to another measure and to a single-note chord</a>
<a name="ln2482">                  if (tiedChord-&gt;measure() != measure() &amp;&amp; tiedChord-&gt;notes().size() == 1) {</a>
<a name="ln2483">                        // get total duration</a>
<a name="ln2484">                        std::vector&lt;TDuration&gt; durList = toDurationList(</a>
<a name="ln2485">                                    actualDurationType().fraction() +</a>
<a name="ln2486">                                    tiedChord-&gt;actualDurationType().fraction(), true);</a>
<a name="ln2487">                        // if duration can be expressed as a single duration</a>
<a name="ln2488">                        // apply cross-measure modification</a>
<a name="ln2489">                        if (durList.size() == 1) {</a>
<a name="ln2490">                              _crossMeasure = tempCross = CrossMeasure::FIRST;</a>
<a name="ln2491">                              _crossMeasureTDur = durList[0];</a>
<a name="ln2492">                              layoutStem1();</a>
<a name="ln2493">                              }</a>
<a name="ln2494">                        }</a>
<a name="ln2495">                  _crossMeasure = tempCross;</a>
<a name="ln2496">                  tiedChord-&gt;setCrossMeasure(tempCross == CrossMeasure::FIRST ?</a>
<a name="ln2497">                              CrossMeasure::SECOND : CrossMeasure::NONE);</a>
<a name="ln2498">                  }</a>
<a name="ln2499">            }</a>
<a name="ln2500">      }</a>
<a name="ln2501"> </a>
<a name="ln2502">//---------------------------------------------------------</a>
<a name="ln2503">//   layoutArpeggio2</a>
<a name="ln2504">//    called after layout of page</a>
<a name="ln2505">//---------------------------------------------------------</a>
<a name="ln2506"> </a>
<a name="ln2507">void Chord::layoutArpeggio2()</a>
<a name="ln2508">      {</a>
<a name="ln2509">      if (!_arpeggio)</a>
<a name="ln2510">            return;</a>
<a name="ln2511">      qreal y           = upNote()-&gt;pagePos().y() - upNote()-&gt;headHeight() * .5;</a>
<a name="ln2512">      int span          = _arpeggio-&gt;span();</a>
<a name="ln2513">      int btrack        = track() + (span - 1) * VOICES;</a>
<a name="ln2514">      ChordRest* bchord = toChordRest(segment()-&gt;element(btrack));</a>
<a name="ln2515">      Note* dnote       = (bchord &amp;&amp; bchord-&gt;type() == ElementType::CHORD) ? toChord(bchord)-&gt;downNote() : downNote();</a>
<a name="ln2516"> </a>
<a name="ln2517">      qreal h = dnote-&gt;pagePos().y() + dnote-&gt;headHeight() * .5 - y;</a>
<a name="ln2518">      _arpeggio-&gt;setHeight(h);</a>
<a name="ln2519">      _arpeggio-&gt;layout();</a>
<a name="ln2520"> </a>
<a name="ln2521">#if 0 // collect notes for arpeggio</a>
<a name="ln2522">      QList&lt;Note*&gt; notes;</a>
<a name="ln2523">      int n = _notes.size();</a>
<a name="ln2524">      for (int j = n - 1; j &gt;= 0; --j) {</a>
<a name="ln2525">            Note* note = _notes[j];</a>
<a name="ln2526">            if (note-&gt;tieBack())</a>
<a name="ln2527">                  continue;</a>
<a name="ln2528">            notes.prepend(note);</a>
<a name="ln2529">            }</a>
<a name="ln2530"> </a>
<a name="ln2531">      for (int i = 1; i &lt; span; ++i) {</a>
<a name="ln2532">            ChordRest* c = toChordRest(segment()-&gt;element(track() + i * VOICES));</a>
<a name="ln2533">            if (c &amp;&amp; c-&gt;type() == CHORD) {</a>
<a name="ln2534">                  QList&lt;Note*&gt; nl = toChord(c)-&gt;notes();</a>
<a name="ln2535">                  int n = nl.size();</a>
<a name="ln2536">                  for (int j = n - 1; j &gt;= 0; --j) {</a>
<a name="ln2537">                        Note* note = nl[j];</a>
<a name="ln2538">                        if (note-&gt;tieBack())</a>
<a name="ln2539">                              continue;</a>
<a name="ln2540">                        notes.prepend(note);</a>
<a name="ln2541">                        }</a>
<a name="ln2542">                  }</a>
<a name="ln2543">            }</a>
<a name="ln2544">#endif</a>
<a name="ln2545">      }</a>
<a name="ln2546"> </a>
<a name="ln2547">//---------------------------------------------------------</a>
<a name="ln2548">//   findNote</a>
<a name="ln2549">//---------------------------------------------------------</a>
<a name="ln2550"> </a>
<a name="ln2551">Note* Chord::findNote(int pitch, int skip) const</a>
<a name="ln2552">      {</a>
<a name="ln2553">      size_t ns = _notes.size();</a>
<a name="ln2554">      for (size_t i = 0; i &lt; ns; ++i) {</a>
<a name="ln2555">            Note* n = _notes.at(i);</a>
<a name="ln2556">            if (n-&gt;pitch() == pitch) {</a>
<a name="ln2557">                  if (skip == 0)</a>
<a name="ln2558">                        return n;</a>
<a name="ln2559">                  else</a>
<a name="ln2560">                        --skip;</a>
<a name="ln2561">                  }</a>
<a name="ln2562">            }</a>
<a name="ln2563">      return 0;</a>
<a name="ln2564">      }</a>
<a name="ln2565"> </a>
<a name="ln2566">//---------------------------------------------------------</a>
<a name="ln2567">//   drop</a>
<a name="ln2568">//---------------------------------------------------------</a>
<a name="ln2569"> </a>
<a name="ln2570">Element* Chord::drop(EditData&amp; data)</a>
<a name="ln2571">      {</a>
<a name="ln2572">      Element* e = data.dropElement;</a>
<a name="ln2573">      switch (e-&gt;type()) {</a>
<a name="ln2574">            case ElementType::ARTICULATION:</a>
<a name="ln2575">                  {</a>
<a name="ln2576">                  Articulation* atr = toArticulation(e);</a>
<a name="ln2577">                  Articulation* oa = hasArticulation(atr);</a>
<a name="ln2578">                  if (oa) {</a>
<a name="ln2579">                        delete atr;</a>
<a name="ln2580">                        atr = 0;</a>
<a name="ln2581">                        // if attribute is already there, remove</a>
<a name="ln2582">                        // score()-&gt;cmdRemove(oa); // unexpected behaviour?</a>
<a name="ln2583">                        score()-&gt;select(oa, SelectType::SINGLE, 0);</a>
<a name="ln2584">                        }</a>
<a name="ln2585">                  else {</a>
<a name="ln2586">                        atr-&gt;setParent(this);</a>
<a name="ln2587">                        atr-&gt;setTrack(track());</a>
<a name="ln2588">                        score()-&gt;undoAddElement(atr);</a>
<a name="ln2589">                        }</a>
<a name="ln2590">                  return atr;</a>
<a name="ln2591">                  }</a>
<a name="ln2592"> </a>
<a name="ln2593">            case ElementType::CHORDLINE:</a>
<a name="ln2594">                  e-&gt;setParent(this);</a>
<a name="ln2595">                  e-&gt;setTrack(track());</a>
<a name="ln2596">                  score()-&gt;undoAddElement(e);</a>
<a name="ln2597">                  break;</a>
<a name="ln2598"> </a>
<a name="ln2599">            case ElementType::TREMOLO:</a>
<a name="ln2600">                  {</a>
<a name="ln2601">                  Tremolo* t = toTremolo(e);</a>
<a name="ln2602">                  if (t-&gt;twoNotes()) {</a>
<a name="ln2603">                        Segment* s = segment()-&gt;next();</a>
<a name="ln2604">                        while (s) {</a>
<a name="ln2605">                              if (s-&gt;element(track()) &amp;&amp; s-&gt;element(track())-&gt;isChord())</a>
<a name="ln2606">                                    break;</a>
<a name="ln2607">                              s = s-&gt;next();</a>
<a name="ln2608">                              }</a>
<a name="ln2609">                        if (s == 0) {</a>
<a name="ln2610">                              qDebug(&quot;no segment for second note of tremolo found&quot;);</a>
<a name="ln2611">                              delete e;</a>
<a name="ln2612">                              return 0;</a>
<a name="ln2613">                              }</a>
<a name="ln2614">                        Chord* ch2 = toChord(s-&gt;element(track()));</a>
<a name="ln2615">                        if (ch2-&gt;ticks() != ticks()) {</a>
<a name="ln2616">                              qDebug(&quot;no matching chord for second note of tremolo found&quot;);</a>
<a name="ln2617">                              delete e;</a>
<a name="ln2618">                              return 0;</a>
<a name="ln2619">                             }</a>
<a name="ln2620">                        t-&gt;setChords(this, ch2);</a>
<a name="ln2621">                        }</a>
<a name="ln2622">                  }</a>
<a name="ln2623">                  if (tremolo())</a>
<a name="ln2624">                        score()-&gt;undoRemoveElement(tremolo());</a>
<a name="ln2625">                  e-&gt;setParent(this);</a>
<a name="ln2626">                  e-&gt;setTrack(track());</a>
<a name="ln2627">                  score()-&gt;undoAddElement(e);</a>
<a name="ln2628">                  break;</a>
<a name="ln2629"> </a>
<a name="ln2630">            case ElementType::ARPEGGIO:</a>
<a name="ln2631">                  {</a>
<a name="ln2632">                  Arpeggio* a = toArpeggio(e);</a>
<a name="ln2633">                  if (arpeggio())</a>
<a name="ln2634">                        score()-&gt;undoRemoveElement(arpeggio());</a>
<a name="ln2635">                  a-&gt;setTrack(track());</a>
<a name="ln2636">                  a-&gt;setParent(this);</a>
<a name="ln2637">                  a-&gt;setHeight(spatium() * 5);   //DEBUG</a>
<a name="ln2638">                  score()-&gt;undoAddElement(a);</a>
<a name="ln2639">                  }</a>
<a name="ln2640">                  return e;</a>
<a name="ln2641"> </a>
<a name="ln2642">            default:</a>
<a name="ln2643">                  return ChordRest::drop(data);</a>
<a name="ln2644">            }</a>
<a name="ln2645">      return 0;</a>
<a name="ln2646">      }</a>
<a name="ln2647"> </a>
<a name="ln2648">//---------------------------------------------------------</a>
<a name="ln2649">//   dotPosX</a>
<a name="ln2650">//---------------------------------------------------------</a>
<a name="ln2651"> </a>
<a name="ln2652">qreal Chord::dotPosX() const</a>
<a name="ln2653">      {</a>
<a name="ln2654">      if (parent())</a>
<a name="ln2655">            return segment()-&gt;dotPosX(staffIdx());</a>
<a name="ln2656">      return -1000.0;</a>
<a name="ln2657">      }</a>
<a name="ln2658"> </a>
<a name="ln2659">//---------------------------------------------------------</a>
<a name="ln2660">//   localSpatiumChanged</a>
<a name="ln2661">//---------------------------------------------------------</a>
<a name="ln2662"> </a>
<a name="ln2663">void Chord::localSpatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln2664">      {</a>
<a name="ln2665">      ChordRest::localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2666">      for (Element* e : graceNotes())</a>
<a name="ln2667">            e-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2668">      if (_hook)</a>
<a name="ln2669">            _hook-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2670">      if (_stem)</a>
<a name="ln2671">            _stem-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2672">      if (_stemSlash)</a>
<a name="ln2673">            _stemSlash-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2674">      if (arpeggio())</a>
<a name="ln2675">            arpeggio()-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2676">      if (_tremolo &amp;&amp; (tremoloChordType() != TremoloChordType::TremoloSecondNote))</a>
<a name="ln2677">            _tremolo-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2678">      for (Element* e : articulations())</a>
<a name="ln2679">            e-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2680">      for (Note* note : notes())</a>
<a name="ln2681">            note-&gt;localSpatiumChanged(oldValue, newValue);</a>
<a name="ln2682">      }</a>
<a name="ln2683"> </a>
<a name="ln2684">//---------------------------------------------------------</a>
<a name="ln2685">//   getProperty</a>
<a name="ln2686">//---------------------------------------------------------</a>
<a name="ln2687"> </a>
<a name="ln2688">QVariant Chord::getProperty(Pid propertyId) const</a>
<a name="ln2689">      {</a>
<a name="ln2690">      switch (propertyId) {</a>
<a name="ln2691">            case Pid::NO_STEM:        return noStem();</a>
<a name="ln2692">            case Pid::SMALL:          return small();</a>
<a name="ln2693">            case Pid::STEM_DIRECTION: return QVariant::fromValue&lt;Direction&gt;(stemDirection());</a>
<a name="ln2694">            default:</a>
<a name="ln2695">                  return ChordRest::getProperty(propertyId);</a>
<a name="ln2696">            }</a>
<a name="ln2697">      }</a>
<a name="ln2698"> </a>
<a name="ln2699">//---------------------------------------------------------</a>
<a name="ln2700">//   propertyDefault</a>
<a name="ln2701">//---------------------------------------------------------</a>
<a name="ln2702"> </a>
<a name="ln2703">QVariant Chord::propertyDefault(Pid propertyId) const</a>
<a name="ln2704">      {</a>
<a name="ln2705">      switch (propertyId) {</a>
<a name="ln2706">            case Pid::NO_STEM:        return false;</a>
<a name="ln2707">            case Pid::SMALL:          return false;</a>
<a name="ln2708">            case Pid::STEM_DIRECTION: return QVariant::fromValue&lt;Direction&gt;(Direction::AUTO);</a>
<a name="ln2709">            default:</a>
<a name="ln2710">                  return ChordRest::propertyDefault(propertyId);</a>
<a name="ln2711">            }</a>
<a name="ln2712">      }</a>
<a name="ln2713"> </a>
<a name="ln2714">//---------------------------------------------------------</a>
<a name="ln2715">//   setProperty</a>
<a name="ln2716">//---------------------------------------------------------</a>
<a name="ln2717"> </a>
<a name="ln2718">bool Chord::setProperty(Pid propertyId, const QVariant&amp; v)</a>
<a name="ln2719">      {</a>
<a name="ln2720">      switch (propertyId) {</a>
<a name="ln2721">            case Pid::NO_STEM:</a>
<a name="ln2722">                  setNoStem(v.toBool());</a>
<a name="ln2723">                  break;</a>
<a name="ln2724">            case Pid::SMALL:</a>
<a name="ln2725">                  setSmall(v.toBool());</a>
<a name="ln2726">                  break;</a>
<a name="ln2727">            case Pid::STEM_DIRECTION:</a>
<a name="ln2728">                  setStemDirection(v.value&lt;Direction&gt;());</a>
<a name="ln2729">                  break;</a>
<a name="ln2730">            default:</a>
<a name="ln2731">                  return ChordRest::setProperty(propertyId, v);</a>
<a name="ln2732">            }</a>
<a name="ln2733">      triggerLayout();</a>
<a name="ln2734">      return true;</a>
<a name="ln2735">      }</a>
<a name="ln2736"> </a>
<a name="ln2737">//---------------------------------------------------------</a>
<a name="ln2738">//   hasArticulation</a>
<a name="ln2739">//---------------------------------------------------------</a>
<a name="ln2740"> </a>
<a name="ln2741">Articulation* Chord::hasArticulation(const Articulation* aa)</a>
<a name="ln2742">      {</a>
<a name="ln2743">      for (Articulation* a : _articulations) {</a>
<a name="ln2744">            if (a-&gt;subtype() == aa-&gt;subtype())</a>
<a name="ln2745">                  return a;</a>
<a name="ln2746">            }</a>
<a name="ln2747">      return 0;</a>
<a name="ln2748">      }</a>
<a name="ln2749"> </a>
<a name="ln2750">//---------------------------------------------------------</a>
<a name="ln2751">//   reset</a>
<a name="ln2752">//---------------------------------------------------------</a>
<a name="ln2753"> </a>
<a name="ln2754">void Chord::reset()</a>
<a name="ln2755">      {</a>
<a name="ln2756">      undoChangeProperty(Pid::STEM_DIRECTION, QVariant::fromValue&lt;Direction&gt;(Direction::AUTO));</a>
<a name="ln2757">      undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::AUTO));</a>
<a name="ln2758">      score()-&gt;createPlayEvents(this);</a>
<a name="ln2759">      ChordRest::reset();</a>
<a name="ln2760">      }</a>
<a name="ln2761"> </a>
<a name="ln2762">//---------------------------------------------------------</a>
<a name="ln2763">//   slash</a>
<a name="ln2764">//---------------------------------------------------------</a>
<a name="ln2765"> </a>
<a name="ln2766">bool Chord::slash()</a>
<a name="ln2767">      {</a>
<a name="ln2768">      Note* n = upNote();</a>
<a name="ln2769">      return n-&gt;fixed();</a>
<a name="ln2770">      }</a>
<a name="ln2771"> </a>
<a name="ln2772">//---------------------------------------------------------</a>
<a name="ln2773">//   setSlash</a>
<a name="ln2774">//---------------------------------------------------------</a>
<a name="ln2775"> </a>
<a name="ln2776">void Chord::setSlash(bool flag, bool stemless)</a>
<a name="ln2777">      {</a>
<a name="ln2778">      int line = 0;</a>
<a name="ln2779">      NoteHead::Group head = NoteHead::Group::HEAD_SLASH;</a>
<a name="ln2780"> </a>
<a name="ln2781">      if (!flag) {</a>
<a name="ln2782">            // restore to normal</a>
<a name="ln2783">            undoChangeProperty(Pid::NO_STEM, false);</a>
<a name="ln2784">            undoChangeProperty(Pid::SMALL, false);</a>
<a name="ln2785">            undoChangeProperty(Pid::OFFSET, QPointF());</a>
<a name="ln2786">            for (Note* n : _notes) {</a>
<a name="ln2787">                  n-&gt;undoChangeProperty(Pid::HEAD_GROUP, int(NoteHead::Group::HEAD_NORMAL));</a>
<a name="ln2788">                  n-&gt;undoChangeProperty(Pid::FIXED, false);</a>
<a name="ln2789">                  n-&gt;undoChangeProperty(Pid::FIXED_LINE, 0);</a>
<a name="ln2790">                  n-&gt;undoChangeProperty(Pid::PLAY, true);</a>
<a name="ln2791">                  n-&gt;undoChangeProperty(Pid::VISIBLE, true);</a>
<a name="ln2792">                  if (staff()-&gt;isDrumStaff(tick())) {</a>
<a name="ln2793">                        const Drumset* ds = part()-&gt;instrument()-&gt;drumset();</a>
<a name="ln2794">                        int pitch = n-&gt;pitch();</a>
<a name="ln2795">                        if (ds &amp;&amp; ds-&gt;isValid(pitch)) {</a>
<a name="ln2796">                              undoChangeProperty(Pid::STEM_DIRECTION, QVariant::fromValue&lt;Direction&gt;(ds-&gt;stemDirection(pitch)));</a>
<a name="ln2797">                              n-&gt;undoChangeProperty(Pid::HEAD_GROUP, int(ds-&gt;noteHead(pitch)));</a>
<a name="ln2798">                              }</a>
<a name="ln2799">                        }</a>
<a name="ln2800">                  }</a>
<a name="ln2801">            return;</a>
<a name="ln2802">            }</a>
<a name="ln2803"> </a>
<a name="ln2804">      // set stem to auto (mostly important for rhythmic notation on drum staves)</a>
<a name="ln2805">      undoChangeProperty(Pid::STEM_DIRECTION, QVariant::fromValue&lt;Direction&gt;(Direction::AUTO));</a>
<a name="ln2806"> </a>
<a name="ln2807">      // make stemless if asked</a>
<a name="ln2808">      if (stemless) {</a>
<a name="ln2809">            undoChangeProperty(Pid::NO_STEM, true);</a>
<a name="ln2810">            undoChangeProperty(Pid::BEAM_MODE, int(Beam::Mode::NONE));</a>
<a name="ln2811">            }</a>
<a name="ln2812"> </a>
<a name="ln2813">      // voice-dependent attributes - line, size, offset, head</a>
<a name="ln2814">      if (track() % VOICES &lt; 2) {</a>
<a name="ln2815">            // use middle line</a>
<a name="ln2816">            line = staff()-&gt;middleLine(tick());</a>
<a name="ln2817">            }</a>
<a name="ln2818">      else {</a>
<a name="ln2819">            // set small</a>
<a name="ln2820">            undoChangeProperty(Pid::SMALL, true);</a>
<a name="ln2821">            // set outside the staff</a>
<a name="ln2822">            qreal y = 0.0;</a>
<a name="ln2823">            if (track() % 2) {</a>
<a name="ln2824">                  line = staff()-&gt;bottomLine(tick()) + 1;</a>
<a name="ln2825">                  y    = 0.5 * spatium();</a>
<a name="ln2826">                  }</a>
<a name="ln2827">            else {</a>
<a name="ln2828">                  line = -1;</a>
<a name="ln2829">                  if (!staff()-&gt;isDrumStaff(tick()))</a>
<a name="ln2830">                        y = -0.5 * spatium();</a>
<a name="ln2831">                  }</a>
<a name="ln2832">            // for non-drum staves, add an additional offset</a>
<a name="ln2833">            // for drum staves, no offset, but use normal head</a>
<a name="ln2834">            if (!staff()-&gt;isDrumStaff(tick()))</a>
<a name="ln2835">                  // undoChangeProperty(Pid::OFFSET, QPointF(0.0, y));</a>
<a name="ln2836">                  rypos() += y;</a>
<a name="ln2837">            else</a>
<a name="ln2838">                  head = NoteHead::Group::HEAD_NORMAL;</a>
<a name="ln2839">            }</a>
<a name="ln2840"> </a>
<a name="ln2841">      size_t ns = _notes.size();</a>
<a name="ln2842">      for (size_t i = 0; i &lt; ns; ++i) {</a>
<a name="ln2843">            Note* n = _notes[i];</a>
<a name="ln2844">            n-&gt;undoChangeProperty(Pid::HEAD_GROUP, static_cast&lt;int&gt;(head));</a>
<a name="ln2845">            n-&gt;undoChangeProperty(Pid::FIXED, true);</a>
<a name="ln2846">            n-&gt;undoChangeProperty(Pid::FIXED_LINE, line);</a>
<a name="ln2847">            n-&gt;undoChangeProperty(Pid::PLAY, false);</a>
<a name="ln2848">            // hide all but first notehead</a>
<a name="ln2849">            if (i)</a>
<a name="ln2850">                  n-&gt;undoChangeProperty(Pid::VISIBLE, false);</a>
<a name="ln2851">            }</a>
<a name="ln2852">      }</a>
<a name="ln2853"> </a>
<a name="ln2854">//---------------------------------------------------------</a>
<a name="ln2855">//  updateEndsGlissando</a>
<a name="ln2856">//    sets/resets the chord _endsGlissando according any glissando (or more)</a>
<a name="ln2857">//    end into this chord or no.</a>
<a name="ln2858">//---------------------------------------------------------</a>
<a name="ln2859"> </a>
<a name="ln2860">void Chord::updateEndsGlissando()</a>
<a name="ln2861">      {</a>
<a name="ln2862">      _endsGlissando = false;       // assume no glissando ends here</a>
<a name="ln2863">      // scan all chord notes for glissandi ending on this chord</a>
<a name="ln2864">      for (Note* note : notes()) {</a>
<a name="ln2865">            for (Spanner* sp : note-&gt;spannerBack())</a>
<a name="ln2866">                  if (sp-&gt;type() == ElementType::GLISSANDO) {</a>
<a name="ln2867">                        _endsGlissando = true;</a>
<a name="ln2868">                        return;</a>
<a name="ln2869">                        }</a>
<a name="ln2870">            }</a>
<a name="ln2871">      }</a>
<a name="ln2872"> </a>
<a name="ln2873">//---------------------------------------------------------</a>
<a name="ln2874">//   removeMarkings</a>
<a name="ln2875">//    - this is normally called after cloning a chord to tie a note over the barline</a>
<a name="ln2876">//    - there is no special undo handling; the assumption is that undo will simply remove the cloned chord</a>
<a name="ln2877">//    - two note tremolos are converted into simple notes</a>
<a name="ln2878">//    - single note tremolos are optionally retained</a>
<a name="ln2879">//---------------------------------------------------------</a>
<a name="ln2880"> </a>
<a name="ln2881">void Chord::removeMarkings(bool keepTremolo)</a>
<a name="ln2882">      {</a>
<a name="ln2883">      if (tremolo() &amp;&amp; !keepTremolo)</a>
<a name="ln2884">            remove(tremolo());</a>
<a name="ln2885">      if (arpeggio())</a>
<a name="ln2886">            remove(arpeggio());</a>
<a name="ln2887">      qDeleteAll(graceNotes());</a>
<a name="ln2888">      graceNotes().clear();</a>
<a name="ln2889">      qDeleteAll(articulations());</a>
<a name="ln2890">      articulations().clear();</a>
<a name="ln2891">      for (Note* n : notes()) {</a>
<a name="ln2892">            for (Element* e : n-&gt;el())</a>
<a name="ln2893">                  n-&gt;remove(e);</a>
<a name="ln2894">            }</a>
<a name="ln2895">      ChordRest::removeMarkings(keepTremolo);</a>
<a name="ln2896">      }</a>
<a name="ln2897"> </a>
<a name="ln2898">//---------------------------------------------------------</a>
<a name="ln2899">//   mag</a>
<a name="ln2900">//---------------------------------------------------------</a>
<a name="ln2901"> </a>
<a name="ln2902">qreal Chord::mag() const</a>
<a name="ln2903">      {</a>
<a name="ln2904">      qreal m = staff() ? staff()-&gt;mag(tick()) : 1.0;</a>
<a name="ln2905">      if (small())</a>
<a name="ln2906">            m *= score()-&gt;styleD(Sid::smallNoteMag);</a>
<a name="ln2907">      if (_noteType != NoteType::NORMAL)</a>
<a name="ln2908">            m *= score()-&gt;styleD(Sid::graceNoteMag);</a>
<a name="ln2909">      return m;</a>
<a name="ln2910">      }</a>
<a name="ln2911"> </a>
<a name="ln2912">//---------------------------------------------------------</a>
<a name="ln2913">//   segment</a>
<a name="ln2914">//---------------------------------------------------------</a>
<a name="ln2915"> </a>
<a name="ln2916">Segment* Chord::segment() const</a>
<a name="ln2917">      {</a>
<a name="ln2918">      Element* e = parent();</a>
<a name="ln2919">      for (; e &amp;&amp; e-&gt;type() != ElementType::SEGMENT; e = e-&gt;parent())</a>
<a name="ln2920">            ;</a>
<a name="ln2921">      return toSegment(e);</a>
<a name="ln2922">      }</a>
<a name="ln2923"> </a>
<a name="ln2924">//---------------------------------------------------------</a>
<a name="ln2925">//   measure</a>
<a name="ln2926">//---------------------------------------------------------</a>
<a name="ln2927"> </a>
<a name="ln2928">Measure* Chord::measure() const</a>
<a name="ln2929">      {</a>
<a name="ln2930">      Element* e = parent();</a>
<a name="ln2931">      for (; e &amp;&amp; e-&gt;type() != ElementType::MEASURE; e = e-&gt;parent())</a>
<a name="ln2932">            ;</a>
<a name="ln2933">      return toMeasure(e);</a>
<a name="ln2934">      }</a>
<a name="ln2935"> </a>
<a name="ln2936">//---------------------------------------------------------</a>
<a name="ln2937">//   graceNotesBefore</a>
<a name="ln2938">//---------------------------------------------------------</a>
<a name="ln2939"> </a>
<a name="ln2940">QVector&lt;Chord*&gt; Chord::graceNotesBefore() const</a>
<a name="ln2941">      {</a>
<a name="ln2942">      QVector&lt;Chord*&gt; cl;</a>
<a name="ln2943">      for (Chord* c : _graceNotes) {</a>
<a name="ln2944">            Q_ASSERT(c-&gt;noteType() != NoteType::NORMAL &amp;&amp; c-&gt;noteType() != NoteType::INVALID);</a>
<a name="ln2945">            if (c-&gt;noteType() &amp; (</a>
<a name="ln2946">                 NoteType::ACCIACCATURA</a>
<a name="ln2947">               | NoteType::APPOGGIATURA</a>
<a name="ln2948">               | NoteType::GRACE4</a>
<a name="ln2949">               | NoteType::GRACE16</a>
<a name="ln2950">               | NoteType::GRACE32)) {</a>
<a name="ln2951">                  cl.push_back(c);</a>
<a name="ln2952">                  }</a>
<a name="ln2953">            }</a>
<a name="ln2954">      return cl;</a>
<a name="ln2955">      }</a>
<a name="ln2956"> </a>
<a name="ln2957">//---------------------------------------------------------</a>
<a name="ln2958">//   graceNotesAfter</a>
<a name="ln2959">//---------------------------------------------------------</a>
<a name="ln2960"> </a>
<a name="ln2961">QVector&lt;Chord*&gt; Chord::graceNotesAfter() const</a>
<a name="ln2962">      {</a>
<a name="ln2963">      QVector&lt;Chord*&gt; cl;</a>
<a name="ln2964">      for (int i = _graceNotes.size() - 1; i &gt;= 0; i--) {</a>
<a name="ln2965">            Chord* c = _graceNotes[i];</a>
<a name="ln2966">            Q_ASSERT(c-&gt;noteType() != NoteType::NORMAL &amp;&amp; c-&gt;noteType() != NoteType::INVALID);</a>
<a name="ln2967">            if (c-&gt;noteType() &amp; (NoteType::GRACE8_AFTER | NoteType::GRACE16_AFTER | NoteType::GRACE32_AFTER))</a>
<a name="ln2968">                  cl.push_back(c);</a>
<a name="ln2969">            }</a>
<a name="ln2970">      return cl;</a>
<a name="ln2971">      }</a>
<a name="ln2972"> </a>
<a name="ln2973">//---------------------------------------------------------</a>
<a name="ln2974">//   sortNotes</a>
<a name="ln2975">//---------------------------------------------------------</a>
<a name="ln2976"> </a>
<a name="ln2977">static bool noteIsBefore(const Note* n1, const Note* n2)</a>
<a name="ln2978">      {</a>
<a name="ln2979">      const int l1 = n1-&gt;line();</a>
<a name="ln2980">      const int l2 = n2-&gt;line();</a>
<a name="ln2981">      if (l1 != l2)</a>
<a name="ln2982">            return l1 &gt; l2;</a>
<a name="ln2983"> </a>
<a name="ln2984">      const int p1 = n1-&gt;pitch();</a>
<a name="ln2985">      const int p2 = n2-&gt;pitch();</a>
<a name="ln2986">      if (p1 != p2)</a>
<a name="ln2987">            return p1 &lt; p2;</a>
<a name="ln2988"> </a>
<a name="ln2989">      if (n1-&gt;tieBack()) {</a>
<a name="ln2990">            if (n2-&gt;tieBack()) {</a>
<a name="ln2991">                  const Note* sn1 = n1-&gt;tieBack()-&gt;startNote();</a>
<a name="ln2992">                  const Note* sn2 = n2-&gt;tieBack()-&gt;startNote();</a>
<a name="ln2993">                  if (sn1-&gt;chord() == sn2-&gt;chord())</a>
<a name="ln2994">                        return sn1-&gt;unisonIndex() &lt; sn2-&gt;unisonIndex();</a>
<a name="ln2995">                  return sn1-&gt;chord()-&gt;isBefore(sn2-&gt;chord());</a>
<a name="ln2996">                  }</a>
<a name="ln2997">            else</a>
<a name="ln2998">                  return true; // place tied notes before</a>
<a name="ln2999">            }</a>
<a name="ln3000"> </a>
<a name="ln3001">      return false;</a>
<a name="ln3002">      }</a>
<a name="ln3003"> </a>
<a name="ln3004">void Chord::sortNotes()</a>
<a name="ln3005">      {</a>
<a name="ln3006">      std::sort(notes().begin(), notes().end(), noteIsBefore);</a>
<a name="ln3007">      }</a>
<a name="ln3008"> </a>
<a name="ln3009">//---------------------------------------------------------</a>
<a name="ln3010">//   nextTiedChord</a>
<a name="ln3011">//    Return next chord if all notes in this chord are tied to it.</a>
<a name="ln3012">//    Set backwards=true to return the previous chord instead.</a>
<a name="ln3013">//</a>
<a name="ln3014">//    Note: the next chord might have extra notes that are not tied</a>
<a name="ln3015">//    back to this one. Set sameSize=true to return 0 in this case.</a>
<a name="ln3016">//---------------------------------------------------------</a>
<a name="ln3017"> </a>
<a name="ln3018">Chord* Chord::nextTiedChord(bool backwards, bool sameSize)</a>
<a name="ln3019">      {</a>
<a name="ln3020">      Segment* nextSeg = backwards ? segment()-&gt;prev1(SegmentType::ChordRest) : segment()-&gt;next1(SegmentType::ChordRest);</a>
<a name="ln3021">      if (!nextSeg)</a>
<a name="ln3022">            return 0;</a>
<a name="ln3023">      ChordRest* nextCR = nextSeg-&gt;nextChordRest(track(), backwards);</a>
<a name="ln3024">      if (!nextCR || !nextCR-&gt;isChord())</a>
<a name="ln3025">            return 0;</a>
<a name="ln3026">      Chord* next = toChord(nextCR);</a>
<a name="ln3027">      if (sameSize &amp;&amp; notes().size() != next-&gt;notes().size())</a>
<a name="ln3028">            return 0; // sizes don't match so some notes can't be tied</a>
<a name="ln3029">      if (tuplet() != next-&gt;tuplet())</a>
<a name="ln3030">            return 0; // next chord belongs to a different tuplet</a>
<a name="ln3031">      for (Note* n : _notes) {</a>
<a name="ln3032">            Tie* tie = backwards ? n-&gt;tieBack() : n-&gt;tieFor();</a>
<a name="ln3033">            if (!tie)</a>
<a name="ln3034">                  return 0; // not tied</a>
<a name="ln3035">            Note* nn = backwards ? tie-&gt;startNote() : tie-&gt;endNote();</a>
<a name="ln3036">            if (!nn || nn-&gt;chord() != next)</a>
<a name="ln3037">                  return 0; // tied to note in wrong voice, or tied over rest</a>
<a name="ln3038">            }</a>
<a name="ln3039">      return next; // all notes in this chord are tied to notes in next chord</a>
<a name="ln3040">      }</a>
<a name="ln3041"> </a>
<a name="ln3042">//---------------------------------------------------------</a>
<a name="ln3043">//   toGraceAfter</a>
<a name="ln3044">//---------------------------------------------------------</a>
<a name="ln3045"> </a>
<a name="ln3046">void Chord::toGraceAfter()</a>
<a name="ln3047">      {</a>
<a name="ln3048">      switch (noteType()) {</a>
<a name="ln3049">            case NoteType::APPOGGIATURA:  setNoteType(NoteType::GRACE8_AFTER);  break;</a>
<a name="ln3050">            case NoteType::GRACE16:       setNoteType(NoteType::GRACE16_AFTER); break;</a>
<a name="ln3051">            case NoteType::GRACE32:       setNoteType(NoteType::GRACE32_AFTER); break;</a>
<a name="ln3052">            default: break;</a>
<a name="ln3053">            }</a>
<a name="ln3054">      }</a>
<a name="ln3055"> </a>
<a name="ln3056">//---------------------------------------------------------</a>
<a name="ln3057">//   tremoloChordType</a>
<a name="ln3058">//---------------------------------------------------------</a>
<a name="ln3059"> </a>
<a name="ln3060">TremoloChordType Chord::tremoloChordType() const</a>
<a name="ln3061">      {</a>
<a name="ln3062">      if (_tremolo &amp;&amp; _tremolo-&gt;twoNotes()) {</a>
<a name="ln3063">            if (_tremolo-&gt;chord1() == this)</a>
<a name="ln3064">                  return TremoloChordType::TremoloFirstNote;</a>
<a name="ln3065">            else if (_tremolo-&gt;chord2() == this)</a>
<a name="ln3066">                  return TremoloChordType::TremoloSecondNote;</a>
<a name="ln3067">            else</a>
<a name="ln3068">                  qFatal(&quot;Chord::tremoloChordType(): inconsistency %p - %p, this is %p&quot;, _tremolo-&gt;chord1(), _tremolo-&gt;chord2(), this);</a>
<a name="ln3069">            }</a>
<a name="ln3070">      return TremoloChordType::TremoloSingle;</a>
<a name="ln3071">      }</a>
<a name="ln3072"> </a>
<a name="ln3073">//---------------------------------------------------------</a>
<a name="ln3074">//   nextElement</a>
<a name="ln3075">//---------------------------------------------------------</a>
<a name="ln3076"> </a>
<a name="ln3077">Element* Chord::nextElement()</a>
<a name="ln3078">      {</a>
<a name="ln3079">      Element* e = score()-&gt;selection().element();</a>
<a name="ln3080">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty())</a>
<a name="ln3081">            e = score()-&gt;selection().elements().first();</a>
<a name="ln3082"> </a>
<a name="ln3083">      switch(e-&gt;type()) {</a>
<a name="ln3084">            case ElementType::SYMBOL:</a>
<a name="ln3085">            case ElementType::IMAGE:</a>
<a name="ln3086">            case ElementType::FINGERING:</a>
<a name="ln3087">            case ElementType::TEXT:</a>
<a name="ln3088">            case ElementType::BEND: {</a>
<a name="ln3089">                  Note* n = toNote(e-&gt;parent());</a>
<a name="ln3090">                  if(n == _notes.front()) {</a>
<a name="ln3091">                        if (_arpeggio)</a>
<a name="ln3092">                              return _arpeggio;</a>
<a name="ln3093">                        else if (_tremolo)</a>
<a name="ln3094">                              return _tremolo;</a>
<a name="ln3095">                        break;</a>
<a name="ln3096">                        }</a>
<a name="ln3097">                  for (auto &amp;i : _notes) {</a>
<a name="ln3098">                        if (i == n) {</a>
<a name="ln3099">                              return *(&amp;i-1);</a>
<a name="ln3100">                              }</a>
<a name="ln3101">                        }</a>
<a name="ln3102">                  break;</a>
<a name="ln3103">                  }</a>
<a name="ln3104"> </a>
<a name="ln3105">            case ElementType::GLISSANDO_SEGMENT:</a>
<a name="ln3106">            case ElementType::TIE_SEGMENT: {</a>
<a name="ln3107">                  SpannerSegment* s = toSpannerSegment(e);</a>
<a name="ln3108">                  Spanner* sp = s-&gt;spanner();</a>
<a name="ln3109">                  Element* elSt = sp-&gt;startElement();</a>
<a name="ln3110">                  Q_ASSERT(elSt-&gt;type() == ElementType::NOTE);</a>
<a name="ln3111">                  Note* n = toNote(elSt);</a>
<a name="ln3112">                  Q_ASSERT(n != NULL);</a>
<a name="ln3113">                  if (n == _notes.front()) {</a>
<a name="ln3114">                        if (_arpeggio)</a>
<a name="ln3115">                              return _arpeggio;</a>
<a name="ln3116">                        else if (_tremolo)</a>
<a name="ln3117">                              return _tremolo;</a>
<a name="ln3118">                        break;</a>
<a name="ln3119">                        }</a>
<a name="ln3120">                  for (auto &amp;i : _notes) {</a>
<a name="ln3121">                        if (i == n) {</a>
<a name="ln3122">                              return *(&amp;i-1);</a>
<a name="ln3123">                              }</a>
<a name="ln3124">                        }</a>
<a name="ln3125">                  break;</a>
<a name="ln3126">                  }</a>
<a name="ln3127">            case ElementType::ARPEGGIO:</a>
<a name="ln3128">                  if (_tremolo)</a>
<a name="ln3129">                        return _tremolo;</a>
<a name="ln3130">                  break;</a>
<a name="ln3131"> </a>
<a name="ln3132">            case ElementType::ACCIDENTAL:</a>
<a name="ln3133">                  e = e-&gt;parent();</a>
<a name="ln3134">                  // fall through</a>
<a name="ln3135"> </a>
<a name="ln3136">            case ElementType::NOTE: {</a>
<a name="ln3137">                  if (e == _notes.front()) {</a>
<a name="ln3138">                        if (_arpeggio)</a>
<a name="ln3139">                              return _arpeggio;</a>
<a name="ln3140">                        else if (_tremolo)</a>
<a name="ln3141">                              return _tremolo;</a>
<a name="ln3142">                        break;</a>
<a name="ln3143">                        }</a>
<a name="ln3144">                  for (auto &amp;i : _notes) {</a>
<a name="ln3145">                        if (i == e)</a>
<a name="ln3146">                              return *(&amp;i -1);</a>
<a name="ln3147">                        }</a>
<a name="ln3148">                  }</a>
<a name="ln3149">                  break;</a>
<a name="ln3150"> </a>
<a name="ln3151">            case ElementType::CHORD:</a>
<a name="ln3152">                  return _notes.back();</a>
<a name="ln3153"> </a>
<a name="ln3154">            default:</a>
<a name="ln3155">                  break;</a>
<a name="ln3156">            }</a>
<a name="ln3157"> </a>
<a name="ln3158">      return ChordRest::nextElement();</a>
<a name="ln3159">      }</a>
<a name="ln3160"> </a>
<a name="ln3161">//---------------------------------------------------------</a>
<a name="ln3162">//   prevElement</a>
<a name="ln3163">//---------------------------------------------------------</a>
<a name="ln3164"> </a>
<a name="ln3165">Element* Chord::prevElement()</a>
<a name="ln3166">      {</a>
<a name="ln3167">      Element* e = score()-&gt;selection().element();</a>
<a name="ln3168">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty())</a>
<a name="ln3169">            e = score()-&gt;selection().elements().last();</a>
<a name="ln3170">      switch (e-&gt;type()) {</a>
<a name="ln3171">            case ElementType::NOTE: {</a>
<a name="ln3172">                  if (e == _notes.back())</a>
<a name="ln3173">                        break;</a>
<a name="ln3174">                  Note* prevNote = nullptr;</a>
<a name="ln3175">                  for (auto &amp;i : _notes) {</a>
<a name="ln3176">                        if (i == e) {</a>
<a name="ln3177">                              prevNote = *(&amp;i+1);</a>
<a name="ln3178">                              }</a>
<a name="ln3179">                        }</a>
<a name="ln3180">                  Element* next = prevNote-&gt;lastElementBeforeSegment();</a>
<a name="ln3181">                  return next;</a>
<a name="ln3182">                  }</a>
<a name="ln3183"> </a>
<a name="ln3184">            case ElementType::CHORD:</a>
<a name="ln3185">                  return _notes.front();</a>
<a name="ln3186"> </a>
<a name="ln3187">            case ElementType::TREMOLO:</a>
<a name="ln3188">                  if (_arpeggio)</a>
<a name="ln3189">                        return _arpeggio;</a>
<a name="ln3190">                  // fall through</a>
<a name="ln3191"> </a>
<a name="ln3192">            case ElementType::ARPEGGIO: {</a>
<a name="ln3193">                  Note* n = _notes.front();</a>
<a name="ln3194">                  Element* elN = n-&gt;lastElementBeforeSegment();</a>
<a name="ln3195">                  Q_ASSERT(elN != NULL);</a>
<a name="ln3196">                  return elN;</a>
<a name="ln3197">                  }</a>
<a name="ln3198"> </a>
<a name="ln3199">            default:</a>
<a name="ln3200">                  break;</a>
<a name="ln3201">            }</a>
<a name="ln3202">      return ChordRest::prevElement();</a>
<a name="ln3203">      }</a>
<a name="ln3204"> </a>
<a name="ln3205">//---------------------------------------------------------</a>
<a name="ln3206">//   lastElementBeforeSegment</a>
<a name="ln3207">//---------------------------------------------------------</a>
<a name="ln3208"> </a>
<a name="ln3209">Element* Chord::lastElementBeforeSegment()</a>
<a name="ln3210">      {</a>
<a name="ln3211">      if (_tremolo) {</a>
<a name="ln3212">            return _tremolo;</a>
<a name="ln3213">            }</a>
<a name="ln3214">      else if (_arpeggio) {</a>
<a name="ln3215">            return _arpeggio;</a>
<a name="ln3216">            }</a>
<a name="ln3217">      else {</a>
<a name="ln3218">            Note* n = _notes.front();</a>
<a name="ln3219">            Element* elN = n-&gt;lastElementBeforeSegment();</a>
<a name="ln3220">            Q_ASSERT(elN != NULL);</a>
<a name="ln3221">            return elN;</a>
<a name="ln3222">            }</a>
<a name="ln3223">      }</a>
<a name="ln3224"> </a>
<a name="ln3225">//---------------------------------------------------------</a>
<a name="ln3226">//   nextSegmentElement</a>
<a name="ln3227">//---------------------------------------------------------</a>
<a name="ln3228"> </a>
<a name="ln3229">Element* Chord::nextSegmentElement()</a>
<a name="ln3230">      {</a>
<a name="ln3231">      for (int v = track() + 1; staffIdx() == v/VOICES; ++v) {</a>
<a name="ln3232">            Element* e = segment()-&gt;element(v);</a>
<a name="ln3233">            if (e) {</a>
<a name="ln3234">                  if (e-&gt;type() == ElementType::CHORD)</a>
<a name="ln3235">                        return toChord(e)-&gt;notes().back();</a>
<a name="ln3236"> </a>
<a name="ln3237">                  return e;</a>
<a name="ln3238">                  }</a>
<a name="ln3239">            }</a>
<a name="ln3240"> </a>
<a name="ln3241">      return ChordRest::nextSegmentElement();</a>
<a name="ln3242">      }</a>
<a name="ln3243"> </a>
<a name="ln3244">//---------------------------------------------------------</a>
<a name="ln3245">//   prevSegmentElement</a>
<a name="ln3246">//---------------------------------------------------------</a>
<a name="ln3247"> </a>
<a name="ln3248">Element* Chord::prevSegmentElement()</a>
<a name="ln3249">      {</a>
<a name="ln3250">      Element* el = score()-&gt;selection().element();</a>
<a name="ln3251">      if (!el &amp;&amp; !score()-&gt;selection().elements().isEmpty() )</a>
<a name="ln3252">            el = score()-&gt;selection().elements().first();</a>
<a name="ln3253">      Element* e = segment()-&gt;lastInPrevSegments(el-&gt;staffIdx());</a>
<a name="ln3254">      if (e) {</a>
<a name="ln3255">            if (e-&gt;isChord())</a>
<a name="ln3256">                  return toChord(e)-&gt;notes().front();</a>
<a name="ln3257">            return e;</a>
<a name="ln3258">            }</a>
<a name="ln3259"> </a>
<a name="ln3260">      return ChordRest::prevSegmentElement();</a>
<a name="ln3261">      }</a>
<a name="ln3262"> </a>
<a name="ln3263">//---------------------------------------------------------</a>
<a name="ln3264">//   accessibleExtraInfo</a>
<a name="ln3265">//---------------------------------------------------------</a>
<a name="ln3266"> </a>
<a name="ln3267">QString Chord::accessibleExtraInfo() const</a>
<a name="ln3268">      {</a>
<a name="ln3269">      QString rez = &quot;&quot;;</a>
<a name="ln3270"> </a>
<a name="ln3271">      for (const Chord* c : graceNotes()) {</a>
<a name="ln3272">            if (!score()-&gt;selectionFilter().canSelect(c))</a>
<a name="ln3273">                  continue;</a>
<a name="ln3274">            for (const Note* n : c-&gt;notes())</a>
<a name="ln3275">                  rez = QString(&quot;%1 %2&quot;).arg(rez).arg(n-&gt;screenReaderInfo());</a>
<a name="ln3276">            }</a>
<a name="ln3277"> </a>
<a name="ln3278">      for (Articulation* a : articulations()) {</a>
<a name="ln3279">            if (!score()-&gt;selectionFilter().canSelect(a))</a>
<a name="ln3280">                  continue;</a>
<a name="ln3281">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(a-&gt;screenReaderInfo());</a>
<a name="ln3282">            }</a>
<a name="ln3283"> </a>
<a name="ln3284">      if (arpeggio() &amp;&amp; score()-&gt;selectionFilter().canSelect(arpeggio()))</a>
<a name="ln3285">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(arpeggio()-&gt;screenReaderInfo());</a>
<a name="ln3286"> </a>
<a name="ln3287">      if (tremolo() &amp;&amp; score()-&gt;selectionFilter().canSelect(tremolo()))</a>
<a name="ln3288">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(tremolo()-&gt;screenReaderInfo());</a>
<a name="ln3289"> </a>
<a name="ln3290">      foreach (Element* e, el()) {</a>
<a name="ln3291">            if (!score()-&gt;selectionFilter().canSelect(e))</a>
<a name="ln3292">                  continue;</a>
<a name="ln3293">            rez = QString(&quot;%1 %2&quot;).arg(rez).arg(e-&gt;screenReaderInfo());</a>
<a name="ln3294">            }</a>
<a name="ln3295"> </a>
<a name="ln3296">      return QString(&quot;%1 %2&quot;).arg(rez).arg(ChordRest::accessibleExtraInfo());</a>
<a name="ln3297">      }</a>
<a name="ln3298"> </a>
<a name="ln3299">//---------------------------------------------------------</a>
<a name="ln3300">//   shape</a>
<a name="ln3301">//    does not contain articulations</a>
<a name="ln3302">//---------------------------------------------------------</a>
<a name="ln3303"> </a>
<a name="ln3304">Shape Chord::shape() const</a>
<a name="ln3305">      {</a>
<a name="ln3306">      Shape shape;</a>
<a name="ln3307">      if (_hook &amp;&amp; _hook-&gt;addToSkyline())</a>
<a name="ln3308">            shape.add(_hook-&gt;shape().translated(_hook-&gt;pos()));</a>
<a name="ln3309">      if (_stem &amp;&amp; _stem-&gt;addToSkyline()) {</a>
<a name="ln3310">            // stem direction is not known soon enough for cross staff beamed notes</a>
<a name="ln3311">            if (!(beam() &amp;&amp; (staffMove() || beam()-&gt;cross())))</a>
<a name="ln3312">                  shape.add(_stem-&gt;shape().translated(_stem-&gt;pos()));</a>
<a name="ln3313">            }</a>
<a name="ln3314">      if (_stemSlash &amp;&amp; _stemSlash-&gt;addToSkyline())</a>
<a name="ln3315">            shape.add(_stemSlash-&gt;shape().translated(_stemSlash-&gt;pos()));</a>
<a name="ln3316">      if (_arpeggio &amp;&amp; _arpeggio-&gt;addToSkyline())</a>
<a name="ln3317">            shape.add(_arpeggio-&gt;shape().translated(_arpeggio-&gt;pos()));</a>
<a name="ln3318">//      if (_tremolo)</a>
<a name="ln3319">//            shape.add(_tremolo-&gt;shape().translated(_tremolo-&gt;pos()));</a>
<a name="ln3320">      for (Note* note : _notes) {</a>
<a name="ln3321">            shape.add(note-&gt;shape().translated(note-&gt;pos()));</a>
<a name="ln3322">            for (Element* e : note-&gt;el()) {</a>
<a name="ln3323">                  if (!e-&gt;addToSkyline())</a>
<a name="ln3324">                        continue;</a>
<a name="ln3325">                  if (e-&gt;isFingering() &amp;&amp; toFingering(e)-&gt;layoutType() == ElementType::CHORD &amp;&amp; e-&gt;bbox().isValid())</a>
<a name="ln3326">                        shape.add(e-&gt;bbox().translated(e-&gt;pos() + note-&gt;pos()));</a>
<a name="ln3327">                  }</a>
<a name="ln3328">            }</a>
<a name="ln3329">      for (Element* e : el()) {</a>
<a name="ln3330">            if (e-&gt;addToSkyline())</a>
<a name="ln3331">                  shape.add(e-&gt;shape().translated(e-&gt;pos()));</a>
<a name="ln3332">            }</a>
<a name="ln3333">      for (Chord* chord : _graceNotes)    // process grace notes last, needed for correct shape calculation</a>
<a name="ln3334">            shape.add(chord-&gt;shape().translated(chord-&gt;pos()));</a>
<a name="ln3335">      shape.add(ChordRest::shape());      // add lyrics</a>
<a name="ln3336">      for (LedgerLine* l = _ledgerLines; l; l = l-&gt;next())</a>
<a name="ln3337">            shape.add(l-&gt;shape().translated(l-&gt;pos()));</a>
<a name="ln3338">      if (_spaceLw || _spaceRw)</a>
<a name="ln3339">            shape.addHorizontalSpacing(Shape::SPACING_GENERAL, -_spaceLw, _spaceRw);</a>
<a name="ln3340">      return shape;</a>
<a name="ln3341">      }</a>
<a name="ln3342"> </a>
<a name="ln3343">//---------------------------------------------------------</a>
<a name="ln3344">//   layoutArticulations</a>
<a name="ln3345">//    layout tenuto and staccato</a>
<a name="ln3346">//    called before layouting slurs</a>
<a name="ln3347">//---------------------------------------------------------</a>
<a name="ln3348"> </a>
<a name="ln3349">void Chord::layoutArticulations()</a>
<a name="ln3350">      {</a>
<a name="ln3351">      for (Chord* gc : graceNotes())</a>
<a name="ln3352">            gc-&gt;layoutArticulations();</a>
<a name="ln3353"> </a>
<a name="ln3354">      if (_articulations.empty())</a>
<a name="ln3355">            return;</a>
<a name="ln3356">      const Staff* st = staff();</a>
<a name="ln3357">      const StaffType* staffType = st-&gt;staffType(tick());</a>
<a name="ln3358">      qreal mag            = (staffType-&gt;small() ? score()-&gt;styleD(Sid::smallStaffMag) : 1.0) * staffType-&gt;userMag();</a>
<a name="ln3359">      qreal _spatium       = score()-&gt;spatium() * mag;</a>
<a name="ln3360">      qreal _spStaff       = _spatium * staffType-&gt;lineDistance().val();</a>
<a name="ln3361"> </a>
<a name="ln3362">      //</a>
<a name="ln3363">      //    determine direction</a>
<a name="ln3364">      //    place tenuto and staccato</a>
<a name="ln3365">      //</a>
<a name="ln3366"> </a>
<a name="ln3367">      Articulation* prevArticulation = nullptr;</a>
<a name="ln3368">      for (Articulation* a : _articulations) {</a>
<a name="ln3369">            if (a-&gt;anchor() == ArticulationAnchor::CHORD) {</a>
<a name="ln3370">                  if (measure()-&gt;hasVoices(a-&gt;staffIdx()))</a>
<a name="ln3371">                        a-&gt;setUp(up()); // if there are voices place articulation at stem</a>
<a name="ln3372">                  else if (a-&gt;symId() &gt;= SymId::articMarcatoAbove &amp;&amp; a-&gt;symId() &lt;= SymId::articMarcatoTenutoBelow)</a>
<a name="ln3373">                        a-&gt;setUp(true); // Gould, p. 117: strong accents above staff</a>
<a name="ln3374">                  else if (isGrace() &amp;&amp; up() &amp;&amp; !a-&gt;layoutCloseToNote() &amp;&amp; downNote()-&gt;line() &lt; 6)</a>
<a name="ln3375">                        a-&gt;setUp(true); // keep articulation close to grace note</a>
<a name="ln3376">                  else</a>
<a name="ln3377">                        a-&gt;setUp(!up()); // place articulation at note head</a>
<a name="ln3378">                  }</a>
<a name="ln3379">            else</a>
<a name="ln3380">                  a-&gt;setUp(a-&gt;anchor() == ArticulationAnchor::TOP_STAFF || a-&gt;anchor() == ArticulationAnchor::TOP_CHORD);</a>
<a name="ln3381"> </a>
<a name="ln3382">            if (!a-&gt;layoutCloseToNote())</a>
<a name="ln3383">                  continue;</a>
<a name="ln3384"> </a>
<a name="ln3385">            bool bottom = !a-&gt;up();  // true: articulation is below chord;  false: articulation is above chord</a>
<a name="ln3386">            a-&gt;layout();             // must be done after assigning direction, or else symId is not reliable</a>
<a name="ln3387"> </a>
<a name="ln3388">            bool headSide = bottom == up();</a>
<a name="ln3389">            qreal x = centerX();</a>
<a name="ln3390">            qreal y = 0.0;</a>
<a name="ln3391"> </a>
<a name="ln3392">            if (bottom) {</a>
<a name="ln3393">                  if (!headSide &amp;&amp; stem()) {</a>
<a name="ln3394">                        y = upPos() + stem()-&gt;stemLen();</a>
<a name="ln3395">                        if (beam())</a>
<a name="ln3396">                              y += score()-&gt;styleS(Sid::beamWidth).val() * _spatium * .5;</a>
<a name="ln3397">                        int line   = lrint((y + 0.5 * _spStaff) / _spStaff);</a>
<a name="ln3398">                        if (line &lt; staffType-&gt;lines())  // align between staff lines</a>
<a name="ln3399">                              y = line * _spStaff + _spatium * .5;</a>
<a name="ln3400">                        else</a>
<a name="ln3401">                              y += _spatium;</a>
<a name="ln3402">                        if (a-&gt;isStaccato() &amp;&amp; articulations().size() == 1) {</a>
<a name="ln3403">                              if (_up)</a>
<a name="ln3404">                                    x = downNote()-&gt;bboxRightPos() - stem()-&gt;width() * .5;</a>
<a name="ln3405">                              else</a>
<a name="ln3406">                                    x = stem()-&gt;width() * .5;</a>
<a name="ln3407">                              }</a>
<a name="ln3408">                        }</a>
<a name="ln3409">                  else {</a>
<a name="ln3410">                        int line = downLine();</a>
<a name="ln3411">                        int lines = (staffType-&gt;lines() - 1) * 2;</a>
<a name="ln3412">                        if (line &lt; lines)</a>
<a name="ln3413">                              y = ((line &amp; ~1) + 3) * _spStaff;</a>
<a name="ln3414">                        else</a>
<a name="ln3415">                              y = line * _spStaff + 2 * _spatium;</a>
<a name="ln3416">                        y *= .5;</a>
<a name="ln3417">                        }</a>
<a name="ln3418">                  if (prevArticulation &amp;&amp; (prevArticulation-&gt;up() == a-&gt;up()))</a>
<a name="ln3419">                        y += _spatium;</a>
<a name="ln3420">                  y -= a-&gt;height() * .5;        // center symbol</a>
<a name="ln3421">                  }</a>
<a name="ln3422">            else {</a>
<a name="ln3423">                  if (!headSide &amp;&amp; stem()) {</a>
<a name="ln3424">                        y = downPos() + stem()-&gt;stemLen();</a>
<a name="ln3425">                        if (beam())</a>
<a name="ln3426">                              y -= score()-&gt;styleS(Sid::beamWidth).val() * _spatium * .5;</a>
<a name="ln3427">                        int line   = lrint((y-0.5*_spStaff) / _spStaff);</a>
<a name="ln3428">                        if (line &gt;= 0)  // align between staff lines</a>
<a name="ln3429">                              y = line * _spStaff - _spatium * .5;</a>
<a name="ln3430">                        else</a>
<a name="ln3431">                              y -= _spatium;</a>
<a name="ln3432">                        if (a-&gt;isStaccato() &amp;&amp; articulations().size() == 1) {</a>
<a name="ln3433">                              if (_up)</a>
<a name="ln3434">                                    x = downNote()-&gt;bboxRightPos() - stem()-&gt;width() * .5;</a>
<a name="ln3435">                              else</a>
<a name="ln3436">                                    x = stem()-&gt;width() * .5;</a>
<a name="ln3437">                              }</a>
<a name="ln3438">                        }</a>
<a name="ln3439">                  else {</a>
<a name="ln3440">                        int line = upLine();</a>
<a name="ln3441">                        if (line &gt; 0)</a>
<a name="ln3442">                              y = (((line+1) &amp; ~1) - 3) * _spStaff;</a>
<a name="ln3443">                        else</a>
<a name="ln3444">                              y = line * _spStaff - 2 * _spatium;</a>
<a name="ln3445">                        y *= .5;</a>
<a name="ln3446">                        }</a>
<a name="ln3447">                  if (prevArticulation &amp;&amp; (prevArticulation-&gt;up() == a-&gt;up()))</a>
<a name="ln3448">                        y -= _spatium;</a>
<a name="ln3449">                  y += a-&gt;height() * .5;        // center symbol</a>
<a name="ln3450">                  }</a>
<a name="ln3451">            a-&gt;setPos(x, y);</a>
<a name="ln3452">            prevArticulation = a;</a>
<a name="ln3453">//            measure()-&gt;system()-&gt;staff(a-&gt;staffIdx())-&gt;skyline().add(a-&gt;shape().translated(a-&gt;pos() + segment()-&gt;pos() + measure()-&gt;pos()));</a>
<a name="ln3454">            }</a>
<a name="ln3455">      }</a>
<a name="ln3456"> </a>
<a name="ln3457">//---------------------------------------------------------</a>
<a name="ln3458">//   layoutArticulations2</a>
<a name="ln3459">//    Called after layouting systems</a>
<a name="ln3460">//    Tentatively layout all articulations</a>
<a name="ln3461">//    To be finished after laying out slurs</a>
<a name="ln3462">//---------------------------------------------------------</a>
<a name="ln3463"> </a>
<a name="ln3464">void Chord::layoutArticulations2()</a>
<a name="ln3465">      {</a>
<a name="ln3466">      for (Chord* gc : graceNotes())</a>
<a name="ln3467">            gc-&gt;layoutArticulations2();</a>
<a name="ln3468"> </a>
<a name="ln3469">      if (_articulations.empty())</a>
<a name="ln3470">            return;</a>
<a name="ln3471">      qreal _spatium  = spatium();</a>
<a name="ln3472">      qreal x         = centerX();</a>
<a name="ln3473">      qreal distance0 = score()-&gt;styleP(Sid::propertyDistance);</a>
<a name="ln3474">      qreal distance2 = score()-&gt;styleP(Sid::propertyDistanceStem);</a>
<a name="ln3475"> </a>
<a name="ln3476">      qreal chordTopY = upPos();    // note position of highest note</a>
<a name="ln3477">      qreal chordBotY = downPos();  // note position of lowest note</a>
<a name="ln3478"> </a>
<a name="ln3479">      qreal staffTopY = -distance2;</a>
<a name="ln3480">      qreal staffBotY = staff()-&gt;height() + distance2;</a>
<a name="ln3481"> </a>
<a name="ln3482">      // avoid collisions of staff articulations with chord notes:</a>
<a name="ln3483">      // gap between note and staff articulation is distance0 + 0.5 spatium</a>
<a name="ln3484"> </a>
<a name="ln3485">      if (stem()) {</a>
<a name="ln3486">            qreal y = stem()-&gt;pos().y() + pos().y() + stem()-&gt;stemLen();</a>
<a name="ln3487">            if (beam()) {</a>
<a name="ln3488">                  qreal bw = score()-&gt;styleS(Sid::beamWidth).val() * _spatium;</a>
<a name="ln3489">                  y += up() ? -bw : bw;</a>
<a name="ln3490">                  }</a>
<a name="ln3491">            if (up())</a>
<a name="ln3492">                  chordTopY = y;</a>
<a name="ln3493">            else</a>
<a name="ln3494">                  chordBotY = y;</a>
<a name="ln3495">            }</a>
<a name="ln3496"> </a>
<a name="ln3497">      //</a>
<a name="ln3498">      //    place all articulations with anchor at chord/rest</a>
<a name="ln3499">      //</a>
<a name="ln3500">      qreal distance1 = score()-&gt;styleP(Sid::propertyDistanceHead);</a>
<a name="ln3501">      chordTopY -= up() ? 0.5 * _spatium : distance1;</a>
<a name="ln3502">      chordBotY += up() ? distance1 : 0.5 * _spatium;</a>
<a name="ln3503">      for (Articulation* a : _articulations) {</a>
<a name="ln3504">            ArticulationAnchor aa = a-&gt;anchor();</a>
<a name="ln3505">            if (aa != ArticulationAnchor::CHORD &amp;&amp; aa != ArticulationAnchor::TOP_CHORD &amp;&amp; aa != ArticulationAnchor::BOTTOM_CHORD)</a>
<a name="ln3506">                  continue;</a>
<a name="ln3507"> </a>
<a name="ln3508">            if (a-&gt;up()) {</a>
<a name="ln3509">                  if (!a-&gt;layoutCloseToNote()) {</a>
<a name="ln3510">                        a-&gt;layout();</a>
<a name="ln3511">                        a-&gt;setPos(x, chordTopY);</a>
<a name="ln3512">                        a-&gt;doAutoplace();</a>
<a name="ln3513">                        }</a>
<a name="ln3514">                  if (a-&gt;visible())</a>
<a name="ln3515">                        chordTopY = a-&gt;y() - a-&gt;height() - 0.5 * _spatium;</a>
<a name="ln3516">                  }</a>
<a name="ln3517">            else {</a>
<a name="ln3518">                  if (!a-&gt;layoutCloseToNote()) {</a>
<a name="ln3519">                        a-&gt;layout();</a>
<a name="ln3520">                        a-&gt;setPos(x, chordBotY);</a>
<a name="ln3521">                        a-&gt;doAutoplace();</a>
<a name="ln3522">                        }</a>
<a name="ln3523">                  if (a-&gt;visible())</a>
<a name="ln3524">                        chordBotY = a-&gt;y() + a-&gt;height() + 0.5 * _spatium;</a>
<a name="ln3525">                  }</a>
<a name="ln3526">            }</a>
<a name="ln3527">      //</a>
<a name="ln3528">      //    now place all articulations with staff top or bottom anchor</a>
<a name="ln3529">      //</a>
<a name="ln3530"> </a>
<a name="ln3531">      staffTopY = qMin(staffTopY, chordTopY - distance0 - 0.5 * _spatium);</a>
<a name="ln3532">      staffBotY = qMax(staffBotY, chordBotY + distance0 + 0.5 * _spatium);</a>
<a name="ln3533">      for (Articulation* a : _articulations) {</a>
<a name="ln3534">            ArticulationAnchor aa = a-&gt;anchor();</a>
<a name="ln3535">            if (aa == ArticulationAnchor::TOP_STAFF || aa == ArticulationAnchor::BOTTOM_STAFF) {</a>
<a name="ln3536">                  a-&gt;layout();</a>
<a name="ln3537">                  if (a-&gt;up()) {</a>
<a name="ln3538">                        a-&gt;setPos(x, staffTopY);</a>
<a name="ln3539">                        if (a-&gt;visible())</a>
<a name="ln3540">                              staffTopY -= distance0;</a>
<a name="ln3541">                        }</a>
<a name="ln3542">                  else {</a>
<a name="ln3543">                        a-&gt;setPos(x, staffBotY);</a>
<a name="ln3544">                        if (a-&gt;visible())</a>
<a name="ln3545">                              staffBotY += distance0;</a>
<a name="ln3546">                        }</a>
<a name="ln3547">                  a-&gt;doAutoplace();</a>
<a name="ln3548">                  }</a>
<a name="ln3549">            }</a>
<a name="ln3550">      for (Articulation* a : _articulations) {</a>
<a name="ln3551">            if (a-&gt;addToSkyline()) {</a>
<a name="ln3552">                  // the segment shape has already been calculated</a>
<a name="ln3553">                  // so measure width and spacing is already determined</a>
<a name="ln3554">                  // in line mode, we cannot add to segment shape without throwing this off</a>
<a name="ln3555">                  // but adding to skyline is always good</a>
<a name="ln3556">                  Segment* s = segment();</a>
<a name="ln3557">                  Measure* m = s-&gt;measure();</a>
<a name="ln3558">                  QRectF r = a-&gt;bbox().translated(a-&gt;pos() + pos());</a>
<a name="ln3559">                  // TODO: limit to width of chord</a>
<a name="ln3560">                  // this avoids &quot;staircase&quot; effect due to space not having been allocated already</a>
<a name="ln3561">                  // ANOTHER alternative is to allocate the space in layoutPitched() / layoutTablature()</a>
<a name="ln3562">                  //qreal w = qMin(r.width(), width());</a>
<a name="ln3563">                  //r.translate((r.width() - w) * 0.5, 0.0);</a>
<a name="ln3564">                  //r.setWidth(w);</a>
<a name="ln3565">                  if (!score()-&gt;lineMode())</a>
<a name="ln3566">                        s-&gt;staffShape(staffIdx()).add(r);</a>
<a name="ln3567">                  r.translate(s-&gt;pos() + m-&gt;pos());</a>
<a name="ln3568">                  m-&gt;system()-&gt;staff(vStaffIdx())-&gt;skyline().add(r);</a>
<a name="ln3569">                  }</a>
<a name="ln3570">            }</a>
<a name="ln3571">      }</a>
<a name="ln3572"> </a>
<a name="ln3573">//---------------------------------------------------------</a>
<a name="ln3574">//   layoutArticulations3</a>
<a name="ln3575">//    Called after layouting slurs</a>
<a name="ln3576">//    Fix up articulations that need to go outside the slur</a>
<a name="ln3577">//---------------------------------------------------------</a>
<a name="ln3578"> </a>
<a name="ln3579">void Chord::layoutArticulations3(Slur* slur)</a>
<a name="ln3580">      {</a>
<a name="ln3581">      SlurSegment* ss;</a>
<a name="ln3582">      if (this == slur-&gt;startCR())</a>
<a name="ln3583">            ss = slur-&gt;frontSegment();</a>
<a name="ln3584">      else if (this == slur-&gt;endCR())</a>
<a name="ln3585">            ss = slur-&gt;backSegment();</a>
<a name="ln3586">      else</a>
<a name="ln3587">            return;</a>
<a name="ln3588">      Segment* s = segment();</a>
<a name="ln3589">      Measure* m = measure();</a>
<a name="ln3590">      SysStaff* sstaff = m-&gt;system() ? m-&gt;system()-&gt;staff(vStaffIdx()) : nullptr;</a>
<a name="ln3591">      for (Articulation* a : _articulations) {</a>
<a name="ln3592">            if (a-&gt;layoutCloseToNote() || !a-&gt;autoplace() || !slur-&gt;addToSkyline())</a>
<a name="ln3593">                  continue;</a>
<a name="ln3594">            Shape aShape = a-&gt;shape().translated(a-&gt;pos() + pos() + s-&gt;pos() + m-&gt;pos());</a>
<a name="ln3595">            Shape sShape = ss-&gt;shape().translated(ss-&gt;pos());</a>
<a name="ln3596">            if (aShape.intersects(sShape)) {</a>
<a name="ln3597">                  qreal d = score()-&gt;styleS(Sid::articulationMinDistance).val() * spatium();</a>
<a name="ln3598">                  if (slur-&gt;up()) {</a>
<a name="ln3599">                        d += qMax(aShape.minVerticalDistance(sShape), 0.0);</a>
<a name="ln3600">                        a-&gt;rypos() -= d;</a>
<a name="ln3601">                        aShape.translateY(-d);</a>
<a name="ln3602">                        }</a>
<a name="ln3603">                  else {</a>
<a name="ln3604">                        d += qMax(sShape.minVerticalDistance(aShape), 0.0);</a>
<a name="ln3605">                        a-&gt;rypos() += d;</a>
<a name="ln3606">                        aShape.translateY(d);</a>
<a name="ln3607">                        }</a>
<a name="ln3608">                  if (sstaff &amp;&amp; a-&gt;addToSkyline())</a>
<a name="ln3609">                        sstaff-&gt;skyline().add(aShape);</a>
<a name="ln3610">                  }</a>
<a name="ln3611">            }</a>
<a name="ln3612">      }</a>
<a name="ln3613"> </a>
<a name="ln3614">//---------------------------------------------------------</a>
<a name="ln3615">//   getNoteEventLists</a>
<a name="ln3616">//    Get contents of all NoteEventLists for all notes in</a>
<a name="ln3617">//    the chord.</a>
<a name="ln3618">//---------------------------------------------------------</a>
<a name="ln3619"> </a>
<a name="ln3620">QList&lt;NoteEventList&gt; Chord::getNoteEventLists()</a>
<a name="ln3621">      {</a>
<a name="ln3622">      QList&lt;NoteEventList&gt; ell;</a>
<a name="ln3623">      if (notes().empty())</a>
<a name="ln3624">            return ell;</a>
<a name="ln3625">      for (size_t i = 0; i &lt; notes().size(); ++i) {</a>
<a name="ln3626">            ell.append(NoteEventList(notes()[i]-&gt;playEvents()));</a>
<a name="ln3627">            }</a>
<a name="ln3628">      return ell;</a>
<a name="ln3629">      }</a>
<a name="ln3630"> </a>
<a name="ln3631">   //---------------------------------------------------------</a>
<a name="ln3632">   //   setNoteEventLists</a>
<a name="ln3633">   //    Set contents of all NoteEventLists for all notes in</a>
<a name="ln3634">   //    the chord.</a>
<a name="ln3635">   //---------------------------------------------------------</a>
<a name="ln3636"> </a>
<a name="ln3637">void Chord::setNoteEventLists(QList&lt;NoteEventList&gt;&amp; ell)</a>
<a name="ln3638">      {</a>
<a name="ln3639">      if (notes().empty())</a>
<a name="ln3640">            return;</a>
<a name="ln3641">      Q_ASSERT(ell.size() == int(notes().size()));</a>
<a name="ln3642">      for (size_t i = 0; int(i) &lt; ell.size(); i++) {</a>
<a name="ln3643">            notes()[i]-&gt;setPlayEvents(ell[int(i)]);</a>
<a name="ln3644">            }</a>
<a name="ln3645"> </a>
<a name="ln3646">      }</a>
<a name="ln3647"> </a>
<a name="ln3648">}</a>

</code></pre>
<div class="balloon" rel="1183"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v728/" target="_blank">V728</a> An excessive check can be simplified. The '||' operator is surrounded by opposite expressions '!st' and 'st'. </p></div>
<div class="balloon" rel="1529"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1004/" target="_blank">V1004</a> The 'hook()' pointer was used unsafely after it was verified against nullptr. Check lines: 1523, 1529.</p></div>
<div class="balloon" rel="2495"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v519/" target="_blank">V519</a> The '_crossMeasure' variable is assigned values twice successively. Perhaps this is a mistake. Check lines: 2490, 2495.</p></div>
<div class="balloon" rel="3099"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The '-1' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="3122"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The '-1' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="3146"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v557/" target="_blank">V557</a> Array underrun is possible. The '-1' index is pointing beyond array bound.</p></div>
<div class="balloon" rel="207"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _spaceLw, _spaceRw.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
