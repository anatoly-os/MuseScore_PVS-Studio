
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>importmidi.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2013 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;midi/midifile.h&quot;</a>
<a name="ln14">#include &quot;mscore/preferences.h&quot;</a>
<a name="ln15">#include &quot;libmscore/score.h&quot;</a>
<a name="ln16">#include &quot;libmscore/key.h&quot;</a>
<a name="ln17">#include &quot;libmscore/clef.h&quot;</a>
<a name="ln18">#include &quot;libmscore/sig.h&quot;</a>
<a name="ln19">#include &quot;libmscore/tempo.h&quot;</a>
<a name="ln20">#include &quot;libmscore/note.h&quot;</a>
<a name="ln21">#include &quot;libmscore/chord.h&quot;</a>
<a name="ln22">#include &quot;libmscore/rest.h&quot;</a>
<a name="ln23">#include &quot;libmscore/segment.h&quot;</a>
<a name="ln24">#include &quot;libmscore/utils.h&quot;</a>
<a name="ln25">#include &quot;libmscore/text.h&quot;</a>
<a name="ln26">#include &quot;libmscore/slur.h&quot;</a>
<a name="ln27">#include &quot;libmscore/tie.h&quot;</a>
<a name="ln28">#include &quot;libmscore/staff.h&quot;</a>
<a name="ln29">#include &quot;libmscore/measure.h&quot;</a>
<a name="ln30">#include &quot;libmscore/style.h&quot;</a>
<a name="ln31">#include &quot;libmscore/part.h&quot;</a>
<a name="ln32">#include &quot;libmscore/timesig.h&quot;</a>
<a name="ln33">#include &quot;libmscore/barline.h&quot;</a>
<a name="ln34">#include &quot;libmscore/pedal.h&quot;</a>
<a name="ln35">#include &quot;libmscore/ottava.h&quot;</a>
<a name="ln36">#include &quot;libmscore/lyrics.h&quot;</a>
<a name="ln37">#include &quot;libmscore/bracket.h&quot;</a>
<a name="ln38">#include &quot;libmscore/drumset.h&quot;</a>
<a name="ln39">#include &quot;libmscore/box.h&quot;</a>
<a name="ln40">#include &quot;libmscore/sym.h&quot;</a>
<a name="ln41">#include &quot;libmscore/pitchspelling.h&quot;</a>
<a name="ln42">#include &quot;importmidi_meter.h&quot;</a>
<a name="ln43">#include &quot;importmidi_chord.h&quot;</a>
<a name="ln44">#include &quot;importmidi_quant.h&quot;</a>
<a name="ln45">#include &quot;importmidi_tuplet.h&quot;</a>
<a name="ln46">#include &quot;importmidi_tuplet_tonotes.h&quot;</a>
<a name="ln47">#include &quot;libmscore/tuplet.h&quot;</a>
<a name="ln48">#include &quot;libmscore/articulation.h&quot;</a>
<a name="ln49">#include &quot;importmidi_swing.h&quot;</a>
<a name="ln50">#include &quot;importmidi_fraction.h&quot;</a>
<a name="ln51">#include &quot;importmidi_drum.h&quot;</a>
<a name="ln52">#include &quot;importmidi_inner.h&quot;</a>
<a name="ln53">#include &quot;importmidi_clef.h&quot;</a>
<a name="ln54">#include &quot;importmidi_lrhand.h&quot;</a>
<a name="ln55">#include &quot;importmidi_lyrics.h&quot;</a>
<a name="ln56">#include &quot;importmidi_tie.h&quot;</a>
<a name="ln57">#include &quot;importmidi_beat.h&quot;</a>
<a name="ln58">#include &quot;importmidi_tempo.h&quot;</a>
<a name="ln59">#include &quot;importmidi_simplify.h&quot;</a>
<a name="ln60">#include &quot;importmidi_voice.h&quot;</a>
<a name="ln61">#include &quot;importmidi_operations.h&quot;</a>
<a name="ln62">#include &quot;importmidi_key.h&quot;</a>
<a name="ln63">#include &quot;importmidi_instrument.h&quot;</a>
<a name="ln64">#include &quot;importmidi_chordname.h&quot;</a>
<a name="ln65"> </a>
<a name="ln66">#include &lt;set&gt;</a>
<a name="ln67"> </a>
<a name="ln68"> </a>
<a name="ln69">namespace Ms {</a>
<a name="ln70"> </a>
<a name="ln71">extern void updateNoteLines(Segment*, int track);</a>
<a name="ln72"> </a>
<a name="ln73"> </a>
<a name="ln74">void lengthenTooShortNotes(std::multimap&lt;int, MTrack&gt; &amp;tracks)</a>
<a name="ln75">      {</a>
<a name="ln76">      for (auto &amp;track: tracks) {</a>
<a name="ln77">            MTrack &amp;mtrack = track.second;</a>
<a name="ln78">            for (auto &amp;chord: mtrack.chords) {</a>
<a name="ln79">                  for (auto &amp;note: chord.second.notes) {</a>
<a name="ln80">                        if (note.offTime - chord.first &lt; MChord::minAllowedDuration())</a>
<a name="ln81">                              note.offTime = chord.first + MChord::minAllowedDuration();</a>
<a name="ln82">                        }</a>
<a name="ln83">                  }</a>
<a name="ln84">            }</a>
<a name="ln85">      }</a>
<a name="ln86"> </a>
<a name="ln87"> </a>
<a name="ln88">#ifdef QT_DEBUG</a>
<a name="ln89"> </a>
<a name="ln90">bool doNotesOverlap(const MTrack &amp;track)</a>
<a name="ln91">      {</a>
<a name="ln92">      const auto &amp;chords = track.chords;</a>
<a name="ln93">      for (auto i1 = chords.begin(); i1 != chords.end(); ++i1) {</a>
<a name="ln94">            const auto &amp;chord1 = i1-&gt;second;</a>
<a name="ln95">            for (auto noteIt1 = chord1.notes.begin();</a>
<a name="ln96">                      noteIt1 != chord1.notes.end(); ++noteIt1) {</a>
<a name="ln97">                  for (auto noteIt2 = std::next(noteIt1);</a>
<a name="ln98">                            noteIt2 != chord1.notes.end(); ++noteIt2) {</a>
<a name="ln99">                        if (noteIt2-&gt;pitch == noteIt1-&gt;pitch)</a>
<a name="ln100">                              return true;</a>
<a name="ln101">                        }</a>
<a name="ln102">                  for (auto i2 = std::next(i1); i2 != chords.end(); ++i2) {</a>
<a name="ln103">                        if (i2-&gt;first &gt;= noteIt1-&gt;offTime)</a>
<a name="ln104">                              break;</a>
<a name="ln105">                        const auto &amp;chord2 = i2-&gt;second;</a>
<a name="ln106">                        if (chord1.voice != chord2.voice)</a>
<a name="ln107">                              continue;</a>
<a name="ln108">                        for (const auto &amp;note2: chord2.notes) {</a>
<a name="ln109">                              if (note2.pitch == noteIt1-&gt;pitch)</a>
<a name="ln110">                                    return true;</a>
<a name="ln111">                              }</a>
<a name="ln112">                        }</a>
<a name="ln113">                  }</a>
<a name="ln114">            }</a>
<a name="ln115">      return false;</a>
<a name="ln116">      }</a>
<a name="ln117"> </a>
<a name="ln118">bool doNotesOverlap(const std::multimap&lt;int, MTrack&gt; &amp;tracks)</a>
<a name="ln119">      {</a>
<a name="ln120">      bool result = false;</a>
<a name="ln121">      for (const auto &amp;track: tracks)</a>
<a name="ln122">            result = doNotesOverlap(track.second);</a>
<a name="ln123">      return result;</a>
<a name="ln124">      }</a>
<a name="ln125"> </a>
<a name="ln126">bool noTooShortNotes(const std::multimap&lt;int, MTrack&gt; &amp;tracks)</a>
<a name="ln127">      {</a>
<a name="ln128">      for (const auto &amp;track: tracks) {</a>
<a name="ln129">            const auto &amp;chords = track.second.chords;</a>
<a name="ln130">            for (const auto &amp;chord: chords) {</a>
<a name="ln131">                  for (const auto &amp;note: chord.second.notes) {</a>
<a name="ln132">                        if (note.offTime - chord.first &lt; MChord::minAllowedDuration())</a>
<a name="ln133">                              return false;</a>
<a name="ln134">                        }</a>
<a name="ln135">                  }</a>
<a name="ln136">            }</a>
<a name="ln137">      return true;</a>
<a name="ln138">      }</a>
<a name="ln139"> </a>
<a name="ln140">#endif</a>
<a name="ln141"> </a>
<a name="ln142">std::vector&lt;std::multimap&lt;ReducedFraction, MidiChord&gt; &gt;</a>
<a name="ln143">separateDrumChordsTo2Voices(const std::multimap&lt;ReducedFraction, MidiChord&gt; &amp;chords)</a>
<a name="ln144">      {</a>
<a name="ln145">      std::vector&lt;std::multimap&lt;ReducedFraction, MidiChord&gt; &gt; separatedChords(2);</a>
<a name="ln146">      for (const auto &amp;chord: chords) {</a>
<a name="ln147">            const MidiChord &amp;c = chord.second;</a>
<a name="ln148"> </a>
<a name="ln149">            Q_ASSERT(c.voice == 0 || c.voice == 1);</a>
<a name="ln150"> </a>
<a name="ln151">            separatedChords[c.voice].insert({chord.first, c});</a>
<a name="ln152">            }</a>
<a name="ln153">      return separatedChords;</a>
<a name="ln154">      }</a>
<a name="ln155"> </a>
<a name="ln156">void setChordVoice(MidiChord &amp;chord, int voice)</a>
<a name="ln157">      {</a>
<a name="ln158">      chord.voice = voice;</a>
<a name="ln159">      if (chord.isInTuplet)</a>
<a name="ln160">            chord.tuplet-&gt;second.voice = voice;</a>
<a name="ln161">      for (auto &amp;note: chord.notes) {</a>
<a name="ln162">            if (note.isInTuplet)</a>
<a name="ln163">                  note.tuplet-&gt;second.voice = voice;</a>
<a name="ln164">            }</a>
<a name="ln165">      }</a>
<a name="ln166"> </a>
<a name="ln167">void findAllTupletsForDrums(</a>
<a name="ln168">            MTrack &amp;mtrack,</a>
<a name="ln169">            TimeSigMap *sigmap,</a>
<a name="ln170">            const ReducedFraction &amp;basicQuant)</a>
<a name="ln171">      {</a>
<a name="ln172">      const size_t drumVoiceCount = 2;</a>
<a name="ln173">            // drum track has 2 voices (stem up and stem down),</a>
<a name="ln174">            // and tuplet detection is applicable for single voice drum tracks,</a>
<a name="ln175">            // so split track chords into 2 voice groups,</a>
<a name="ln176">            // detect tuplets and merge chords (and found tuplets) back;</a>
<a name="ln177">            // it's a small hack due to the fact that tuplet detection</a>
<a name="ln178">            // is designed to work before voice setting</a>
<a name="ln179"> </a>
<a name="ln180">      std::vector&lt;std::multimap&lt;ReducedFraction, MidiChord&gt; &gt; chords(drumVoiceCount);</a>
<a name="ln181">      for (const auto &amp;chord: mtrack.chords) {</a>
<a name="ln182">            const MidiChord &amp;c = chord.second;</a>
<a name="ln183"> </a>
<a name="ln184">            Q_ASSERT(c.voice == 0 || c.voice == 1);</a>
<a name="ln185"> </a>
<a name="ln186">            chords[c.voice].insert({chord.first, c});</a>
<a name="ln187">            }</a>
<a name="ln188"> </a>
<a name="ln189">      std::vector&lt;std::multimap&lt;ReducedFraction,</a>
<a name="ln190">                                MidiTuplet::TupletData&gt; &gt; tuplets(drumVoiceCount);</a>
<a name="ln191">      for (size_t voice = 0; voice &lt; drumVoiceCount; ++voice) {</a>
<a name="ln192">            if (!chords[voice].empty())</a>
<a name="ln193">                  MidiTuplet::findAllTuplets(tuplets[voice], chords[voice], sigmap, basicQuant);</a>
<a name="ln194">            }</a>
<a name="ln195">      mtrack.chords.clear();</a>
<a name="ln196">      for (size_t voice = 0; voice &lt; drumVoiceCount; ++voice) {</a>
<a name="ln197">            for (auto &amp;chord: chords[voice]) {</a>
<a name="ln198">                        // correct voice because it can be changed during tuplet detection</a>
<a name="ln199">                  setChordVoice(chord.second, int(voice));</a>
<a name="ln200">                  mtrack.chords.insert({chord.first, chord.second});</a>
<a name="ln201">                  }</a>
<a name="ln202">            }</a>
<a name="ln203">      mtrack.updateTupletsFromChords();</a>
<a name="ln204">      // note: temporary local tuplets and chords are deleted here</a>
<a name="ln205">      }</a>
<a name="ln206"> </a>
<a name="ln207">void quantizeAllTracks(std::multimap&lt;int, MTrack&gt; &amp;tracks,</a>
<a name="ln208">                       TimeSigMap *sigmap,</a>
<a name="ln209">                       const ReducedFraction &amp;lastTick)</a>
<a name="ln210">      {</a>
<a name="ln211">      auto &amp;opers = midiImportOperations;</a>
<a name="ln212"> </a>
<a name="ln213">      for (auto &amp;track: tracks) {</a>
<a name="ln214">            MTrack &amp;mtrack = track.second;</a>
<a name="ln215">            if (mtrack.chords.empty())</a>
<a name="ln216">                  continue;</a>
<a name="ln217">                        // pass current track index through MidiImportOperations</a>
<a name="ln218">                        // for further usage</a>
<a name="ln219">            MidiOperations::CurrentTrackSetter setCurrentTrack{opers, mtrack.indexOfOperation};</a>
<a name="ln220"> </a>
<a name="ln221">            if (opers.data()-&gt;processingsOfOpenedFile == 0) {</a>
<a name="ln222">                  opers.data()-&gt;trackOpers.isDrumTrack.setValue(</a>
<a name="ln223">                                          opers.currentTrack(), mtrack.mtrack-&gt;drumTrack());</a>
<a name="ln224">                  if (mtrack.mtrack-&gt;drumTrack()) {</a>
<a name="ln225">                        opers.data()-&gt;trackOpers.maxVoiceCount.setValue(</a>
<a name="ln226">                                          opers.currentTrack(), MidiOperations::VoiceCount::V_1);</a>
<a name="ln227">                        }</a>
<a name="ln228">                  }</a>
<a name="ln229">            const auto basicQuant = Quantize::quantValueToFraction(</a>
<a name="ln230">                        opers.data()-&gt;trackOpers.quantValue.value(mtrack.indexOfOperation));</a>
<a name="ln231"> </a>
<a name="ln232">            Q_ASSERT_X(MChord::isLastTickValid(lastTick, mtrack.chords),</a>
<a name="ln233">                       &quot;quantizeAllTracks&quot;, &quot;Last tick is less than max note off time&quot;);</a>
<a name="ln234"> </a>
<a name="ln235">            MChord::setBarIndexes(mtrack.chords, basicQuant, lastTick, sigmap);</a>
<a name="ln236"> </a>
<a name="ln237">            if (mtrack.mtrack-&gt;drumTrack())</a>
<a name="ln238">                  findAllTupletsForDrums(mtrack, sigmap, basicQuant);</a>
<a name="ln239">            else</a>
<a name="ln240">                  MidiTuplet::findAllTuplets(mtrack.tuplets, mtrack.chords, sigmap, basicQuant);</a>
<a name="ln241"> </a>
<a name="ln242">            Q_ASSERT_X(!doNotesOverlap(track.second),</a>
<a name="ln243">                       &quot;quantizeAllTracks&quot;,</a>
<a name="ln244">                       &quot;There are overlapping notes of the same voice that is incorrect&quot;);</a>
<a name="ln245"> </a>
<a name="ln246">                        // (4/3 of the smallest duration) tol is less sensitive</a>
<a name="ln247">                        // to on time inaccuracies than 1/2 earlier</a>
<a name="ln248">            MChord::collectChords(mtrack, {2, 1}, {4, 3});</a>
<a name="ln249">            Quantize::quantizeChords(mtrack.chords, sigmap, basicQuant);</a>
<a name="ln250">            MidiTuplet::removeEmptyTuplets(mtrack);</a>
<a name="ln251"> </a>
<a name="ln252">            Q_ASSERT_X(MidiTuplet::areTupletRangesOk(mtrack.chords, mtrack.tuplets),</a>
<a name="ln253">                       &quot;quantizeAllTracks&quot;, &quot;Tuplet chord/note is outside tuplet &quot;</a>
<a name="ln254">                        &quot;or non-tuplet chord/note is inside tuplet&quot;);</a>
<a name="ln255">            }</a>
<a name="ln256">      }</a>
<a name="ln257"> </a>
<a name="ln258">//---------------------------------------------------------</a>
<a name="ln259">//   processMeta</a>
<a name="ln260">//---------------------------------------------------------</a>
<a name="ln261"> </a>
<a name="ln262">void MTrack::processMeta(int tick, const MidiEvent&amp; mm)</a>
<a name="ln263">      {</a>
<a name="ln264">      if (!staff) {</a>
<a name="ln265">            qDebug(&quot;processMeta: no staff&quot;);</a>
<a name="ln266">            return;</a>
<a name="ln267">            }</a>
<a name="ln268">      const uchar* data = mm.edata();</a>
<a name="ln269">      Score* cs         = staff-&gt;score();</a>
<a name="ln270"> </a>
<a name="ln271">      switch (mm.metaType()) {</a>
<a name="ln272">            case META_TEXT:</a>
<a name="ln273">            case META_LYRIC:</a>
<a name="ln274">                  break;      // lyric and text are added in importmidi_lyrics.cpp</a>
<a name="ln275">            case META_TRACK_NAME:</a>
<a name="ln276">                  {</a>
<a name="ln277">                  const std::string text = MidiCharset::fromUchar(data);</a>
<a name="ln278"> </a>
<a name="ln279">                  auto &amp;opers = midiImportOperations;</a>
<a name="ln280">                  if (opers.data()-&gt;processingsOfOpenedFile == 0) {</a>
<a name="ln281">                        const int currentTrack = indexOfOperation;</a>
<a name="ln282">                        opers.data()-&gt;trackOpers.staffName.setValue(currentTrack, text);</a>
<a name="ln283">                        }</a>
<a name="ln284"> </a>
<a name="ln285">                  if (name.isEmpty())</a>
<a name="ln286">                        name = MidiCharset::convertToCharset(text);</a>
<a name="ln287">                  }</a>
<a name="ln288">                  break;</a>
<a name="ln289">            case META_TEMPO:  // add later, after adding of notes</a>
<a name="ln290">                  break;</a>
<a name="ln291">            case META_KEY_SIGNATURE:</a>
<a name="ln292">                  {</a>
<a name="ln293">                  const signed char key = ((const signed char*)data)[0];</a>
<a name="ln294">                  if (key &lt; -7 || key &gt; 7) {</a>
<a name="ln295">                        qDebug(&quot;ImportMidi: illegal key %d&quot;, key);</a>
<a name="ln296">                        break;</a>
<a name="ln297">                        }</a>
<a name="ln298">                  KeySigEvent ke;</a>
<a name="ln299">                  ke.setKey(Key(key));</a>
<a name="ln300">                  staff-&gt;setKey(Fraction::fromTicks(tick), ke);</a>
<a name="ln301">                  hasKey = true;</a>
<a name="ln302">                  }</a>
<a name="ln303">                  break;</a>
<a name="ln304">            case META_COMPOSER:     // mscore extension</a>
<a name="ln305">            case META_POET:</a>
<a name="ln306">            case META_TRANSLATOR:</a>
<a name="ln307">            case META_SUBTITLE:</a>
<a name="ln308">            case META_TITLE:</a>
<a name="ln309">                  {</a>
<a name="ln310">                  Tid ssid = Tid::DEFAULT;</a>
<a name="ln311">                  switch(mm.metaType()) {</a>
<a name="ln312">                        case META_COMPOSER:</a>
<a name="ln313">                              ssid = Tid::COMPOSER;</a>
<a name="ln314">                              break;</a>
<a name="ln315">                        case META_TRANSLATOR:</a>
<a name="ln316">                              ssid = Tid::TRANSLATOR;</a>
<a name="ln317">                              break;</a>
<a name="ln318">                        case META_POET:</a>
<a name="ln319">                              ssid = Tid::POET;</a>
<a name="ln320">                              break;</a>
<a name="ln321">                        case META_SUBTITLE:</a>
<a name="ln322">                              ssid = Tid::SUBTITLE;</a>
<a name="ln323">                              break;</a>
<a name="ln324">                        case META_TITLE:</a>
<a name="ln325">                              ssid = Tid::TITLE;</a>
<a name="ln326">                              break;</a>
<a name="ln327">                        }</a>
<a name="ln328">                  Text* text = new Text(cs, ssid);</a>
<a name="ln329"> </a>
<a name="ln330">                  text-&gt;setPlainText((const char*)(mm.edata()));</a>
<a name="ln331"> </a>
<a name="ln332">                  MeasureBase* measure = cs-&gt;first();</a>
<a name="ln333">                  if (!measure-&gt;isVBox()) {</a>
<a name="ln334">                        measure = new VBox(cs);</a>
<a name="ln335">                        measure-&gt;setTick(Fraction(0,1));</a>
<a name="ln336">                        measure-&gt;setNext(cs-&gt;first());</a>
<a name="ln337">                        cs-&gt;measures()-&gt;add(measure);</a>
<a name="ln338">                        }</a>
<a name="ln339">                  measure-&gt;add(text);</a>
<a name="ln340">                  }</a>
<a name="ln341">                  break;</a>
<a name="ln342">            case META_COPYRIGHT:</a>
<a name="ln343">                  cs-&gt;setMetaTag(&quot;copyright&quot;, QString((const char*)(mm.edata())));</a>
<a name="ln344">                  break;</a>
<a name="ln345">            case META_TIME_SIGNATURE:</a>
<a name="ln346">                  break;                        // added earlier</a>
<a name="ln347">            case META_PORT_CHANGE:</a>
<a name="ln348">                  staff-&gt;part()-&gt;setMidiChannel(-1, (int)data[0]);</a>
<a name="ln349">                  break;</a>
<a name="ln350">            default:</a>
<a name="ln351">                  if (MScore::debugMode)</a>
<a name="ln352">                        qDebug(&quot;unknown meta type 0x%02x&quot;, mm.metaType());</a>
<a name="ln353">                  break;</a>
<a name="ln354">            }</a>
<a name="ln355">      }</a>
<a name="ln356"> </a>
<a name="ln357">QList&lt;std::pair&lt;ReducedFraction, TDuration&gt; &gt;</a>
<a name="ln358">MTrack::toDurationList(const Measure *measure,</a>
<a name="ln359">                       int voice,</a>
<a name="ln360">                       const ReducedFraction &amp;startTick,</a>
<a name="ln361">                       const ReducedFraction &amp;len,</a>
<a name="ln362">                       Meter::DurationType durationType)</a>
<a name="ln363">      {</a>
<a name="ln364">                  // find tuplets over which duration goes</a>
<a name="ln365">      auto barTick = ReducedFraction(measure-&gt;tick());</a>
<a name="ln366">      auto tupletsData = MidiTuplet::findTupletsInBarForDuration(</a>
<a name="ln367">                        voice, barTick, startTick, len, tuplets);</a>
<a name="ln368">      struct {</a>
<a name="ln369">            bool operator()(const MidiTuplet::TupletData &amp;d1,</a>
<a name="ln370">                            const MidiTuplet::TupletData &amp;d2)</a>
<a name="ln371">                  {</a>
<a name="ln372">                  return (d1.len &gt; d2.len);</a>
<a name="ln373">                  }</a>
<a name="ln374">            } comparator;</a>
<a name="ln375">                  // sort by tuplet length in desc order</a>
<a name="ln376">      sort(tupletsData.begin(), tupletsData.end(), comparator);</a>
<a name="ln377"> </a>
<a name="ln378">      const ReducedFraction startTickInBar = startTick - barTick;</a>
<a name="ln379">      const ReducedFraction endTickInBar = startTickInBar + len;</a>
<a name="ln380"> </a>
<a name="ln381">      const auto &amp;opers = midiImportOperations;</a>
<a name="ln382">      const bool useDots = opers.data()-&gt;trackOpers.useDots.value(indexOfOperation);</a>
<a name="ln383">      return Meter::toDurationList(startTickInBar, endTickInBar,</a>
<a name="ln384">                                   ReducedFraction(measure-&gt;timesig()), tupletsData,</a>
<a name="ln385">                                   durationType, useDots);</a>
<a name="ln386">      }</a>
<a name="ln387"> </a>
<a name="ln388">ReducedFraction splitDurationOnBarBoundary(const ReducedFraction &amp;len,</a>
<a name="ln389">                                           const ReducedFraction &amp;onTime,</a>
<a name="ln390">                                           const Measure* measure)</a>
<a name="ln391">      {</a>
<a name="ln392">      const ReducedFraction barLimit = ReducedFraction(measure-&gt;endTick());</a>
<a name="ln393">      if (onTime + len &gt; barLimit)</a>
<a name="ln394">            return barLimit - onTime;</a>
<a name="ln395">      return len;</a>
<a name="ln396">      }</a>
<a name="ln397"> </a>
<a name="ln398">// fill the gap between successive chords with rests</a>
<a name="ln399"> </a>
<a name="ln400">void MTrack::fillGapWithRests(Score* score,</a>
<a name="ln401">                              int voice,</a>
<a name="ln402">                              const ReducedFraction &amp;startChordTickFrac,</a>
<a name="ln403">                              const ReducedFraction &amp;restLength,</a>
<a name="ln404">                              int track)</a>
<a name="ln405">      {</a>
<a name="ln406">      ReducedFraction startChordTick = startChordTickFrac;</a>
<a name="ln407">      ReducedFraction restLen = restLength;</a>
<a name="ln408">      while (restLen &gt; ReducedFraction(0, 1)) {</a>
<a name="ln409">            ReducedFraction len = restLen;</a>
<a name="ln410">            Measure* measure = score-&gt;tick2measure(startChordTick.fraction());</a>
<a name="ln411">            if (startChordTick &gt;= ReducedFraction(measure-&gt;endTick())) {</a>
<a name="ln412">                  qDebug(&quot;tick2measure: %d end of score?&quot;, startChordTick.ticks());</a>
<a name="ln413">                  startChordTick += restLen;</a>
<a name="ln414">                  restLen = ReducedFraction(0, 1);</a>
<a name="ln415">                  break;</a>
<a name="ln416">                  }</a>
<a name="ln417">            len = splitDurationOnBarBoundary(len, startChordTick, measure);</a>
<a name="ln418"> </a>
<a name="ln419">            if (len &gt;= ReducedFraction(measure-&gt;ticks())) {</a>
<a name="ln420">                              // rest to the whole measure</a>
<a name="ln421">                  len = ReducedFraction(measure-&gt;ticks());</a>
<a name="ln422">                  if (voice == 0) {</a>
<a name="ln423">                        TDuration duration(TDuration::DurationType::V_MEASURE);</a>
<a name="ln424">                        Rest* rest = new Rest(score, duration);</a>
<a name="ln425">                        rest-&gt;setTicks(measure-&gt;ticks());</a>
<a name="ln426">                        rest-&gt;setTrack(track);</a>
<a name="ln427">                        Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, startChordTick.fraction());</a>
<a name="ln428">                        s-&gt;add(rest);</a>
<a name="ln429">                        }</a>
<a name="ln430">                  restLen -= len;</a>
<a name="ln431">                  startChordTick += len;</a>
<a name="ln432">                  }</a>
<a name="ln433">            else {</a>
<a name="ln434">                  const auto dl = toDurationList(measure, voice, startChordTick, len,</a>
<a name="ln435">                                                 Meter::DurationType::REST);</a>
<a name="ln436">                  if (dl.isEmpty()) {</a>
<a name="ln437">                        qDebug(&quot;cannot create duration list for len %d&quot;, len.ticks());</a>
<a name="ln438">                        restLen = ReducedFraction(0, 1);      // fake</a>
<a name="ln439">                        break;</a>
<a name="ln440">                        }</a>
<a name="ln441">                  for (const auto &amp;durationPair: dl) {</a>
<a name="ln442">                        const TDuration &amp;duration = durationPair.second;</a>
<a name="ln443">                        const ReducedFraction &amp;tupletRatio = durationPair.first;</a>
<a name="ln444">                        len = ReducedFraction(duration.fraction()) / tupletRatio;</a>
<a name="ln445">                        Rest* rest = new Rest(score, duration);</a>
<a name="ln446">                        rest-&gt;setTicks(duration.fraction());</a>
<a name="ln447">                        rest-&gt;setTrack(track);</a>
<a name="ln448">                        Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, startChordTick.fraction());</a>
<a name="ln449">                        s-&gt;add(rest);</a>
<a name="ln450">                        MidiTuplet::addElementToTuplet(voice, startChordTick, len, rest, tuplets);</a>
<a name="ln451">                        restLen -= len;</a>
<a name="ln452">                        startChordTick += len;</a>
<a name="ln453">                        }</a>
<a name="ln454">                  }</a>
<a name="ln455"> </a>
<a name="ln456">            }</a>
<a name="ln457">      }</a>
<a name="ln458"> </a>
<a name="ln459">void setMusicNotesFromMidi(Score *score,</a>
<a name="ln460">                           const QList&lt;MidiNote&gt; &amp;midiNotes,</a>
<a name="ln461">                           Chord *chord,</a>
<a name="ln462">                           const Drumset *drumset,</a>
<a name="ln463">                           bool useDrumset)</a>
<a name="ln464">      {</a>
<a name="ln465">      for (int i = 0; i &lt; midiNotes.size(); ++i) {</a>
<a name="ln466">            const MidiNote&amp; mn = midiNotes[i];</a>
<a name="ln467">            Note* note = new Note(score);</a>
<a name="ln468">            note-&gt;setTrack(chord-&gt;track());</a>
<a name="ln469"> </a>
<a name="ln470">            NoteVal nval(mn.pitch);</a>
<a name="ln471">            note-&gt;setNval(nval, chord-&gt;tick());</a>
<a name="ln472">            // TODO - does this need to be key-aware?</a>
<a name="ln473">            //note-&gt;setPitch(mn.pitch);</a>
<a name="ln474">            //note-&gt;setTpcFromPitch();</a>
<a name="ln475"> </a>
<a name="ln476">            chord-&gt;add(note);</a>
<a name="ln477">            note-&gt;setVeloType(Note::ValueType::USER_VAL);</a>
<a name="ln478">            note-&gt;setVeloOffset(mn.velo);</a>
<a name="ln479"> </a>
<a name="ln480">            if (useDrumset) {</a>
<a name="ln481">                  if (!drumset-&gt;isValid(mn.pitch))</a>
<a name="ln482">                        qDebug(&quot;unmapped drum note 0x%02x %d&quot;, mn.pitch, mn.pitch);</a>
<a name="ln483">                  else {</a>
<a name="ln484">                        Direction sd = drumset-&gt;stemDirection(mn.pitch);</a>
<a name="ln485">                        chord-&gt;setStemDirection(sd);</a>
<a name="ln486">                        }</a>
<a name="ln487">                  }</a>
<a name="ln488"> </a>
<a name="ln489">            if (midiNotes[i].tie) {</a>
<a name="ln490">                  midiNotes[i].tie-&gt;setEndNote(note);</a>
<a name="ln491">                  midiNotes[i].tie-&gt;setTrack(note-&gt;track());</a>
<a name="ln492">                  note-&gt;setTieBack(midiNotes[i].tie);</a>
<a name="ln493">                  }</a>
<a name="ln494">            }</a>
<a name="ln495">      }</a>
<a name="ln496"> </a>
<a name="ln497">void setTies(Chord *chord,</a>
<a name="ln498">             Score *score,</a>
<a name="ln499">             QList&lt;MidiNote&gt; &amp;midiNotes)</a>
<a name="ln500">      {</a>
<a name="ln501">      for (int i = 0; i &lt; midiNotes.size(); ++i) {</a>
<a name="ln502">            const MidiNote &amp;midiNote = midiNotes[i];</a>
<a name="ln503">            Note *note = chord-&gt;findNote(midiNote.pitch);</a>
<a name="ln504">            midiNotes[i].tie = new Tie(score);</a>
<a name="ln505">            midiNotes[i].tie-&gt;setStartNote(note);</a>
<a name="ln506">            note-&gt;setTieFor(midiNotes[i].tie);</a>
<a name="ln507">            }</a>
<a name="ln508">      }</a>
<a name="ln509"> </a>
<a name="ln510"> </a>
<a name="ln511">// convert midiChords with the same onTime value to music notation</a>
<a name="ln512">// and fill the remaining empty duration with rests</a>
<a name="ln513"> </a>
<a name="ln514">void MTrack::processPendingNotes(QList&lt;MidiChord&gt; &amp;midiChords,</a>
<a name="ln515">                                 int voice,</a>
<a name="ln516">                                 const ReducedFraction &amp;startChordTickFrac,</a>
<a name="ln517">                                 const ReducedFraction &amp;nextChordTick)</a>
<a name="ln518">      {</a>
<a name="ln519">      Score* score = staff-&gt;score();</a>
<a name="ln520">      const int track = staff-&gt;idx() * VOICES + voice;</a>
<a name="ln521">      const Drumset* drumset = staff-&gt;part()-&gt;instrument()-&gt;drumset();</a>
<a name="ln522">      const bool useDrumset  = staff-&gt;part()-&gt;instrument()-&gt;useDrumset();</a>
<a name="ln523"> </a>
<a name="ln524">      const auto&amp; opers = midiImportOperations.data()-&gt;trackOpers;</a>
<a name="ln525">      const int currentTrack = indexOfOperation;</a>
<a name="ln526"> </a>
<a name="ln527">                  // all midiChords here should have the same onTime value</a>
<a name="ln528">                  // and all notes in each midiChord should have the same duration</a>
<a name="ln529">      ReducedFraction startChordTick = startChordTickFrac;</a>
<a name="ln530">      while (!midiChords.isEmpty()) {</a>
<a name="ln531">            const ReducedFraction tick = startChordTick;</a>
<a name="ln532">            ReducedFraction len = nextChordTick - tick;</a>
<a name="ln533">            if (len &lt;= ReducedFraction(0, 1))</a>
<a name="ln534">                  break;</a>
<a name="ln535">            len = MChord::findMinDuration(tick, midiChords, len);</a>
<a name="ln536">            Measure* measure = score-&gt;tick2measure(tick.fraction());</a>
<a name="ln537">            len = splitDurationOnBarBoundary(len, tick, measure);</a>
<a name="ln538"> </a>
<a name="ln539">            const auto dl = toDurationList(measure, voice, tick, len, Meter::DurationType::NOTE);</a>
<a name="ln540">            if (dl.isEmpty())</a>
<a name="ln541">                  break;</a>
<a name="ln542">            const TDuration &amp;d = dl[0].second;</a>
<a name="ln543">            const ReducedFraction &amp;tupletRatio = dl[0].first;</a>
<a name="ln544">            len = ReducedFraction(d.fraction()) / tupletRatio;</a>
<a name="ln545"> </a>
<a name="ln546">            Chord* chord = new Chord(score);</a>
<a name="ln547">            chord-&gt;setTrack(track);</a>
<a name="ln548">            chord-&gt;setDurationType(d);</a>
<a name="ln549">            chord-&gt;setTicks(d.fraction());</a>
<a name="ln550"> </a>
<a name="ln551">            if (opers.showStaccato.value(currentTrack)</a>
<a name="ln552">                        &amp;&amp; startChordTick == startChordTickFrac   // first chord in tied chord sequence</a>
<a name="ln553">                        &amp;&amp; midiChords.begin()-&gt;isStaccato()) {</a>
<a name="ln554">                  Articulation* a = new Articulation(chord-&gt;score());</a>
<a name="ln555">                  a-&gt;setSymId(SymId::articStaccatoAbove);</a>
<a name="ln556">                  chord-&gt;add(a);</a>
<a name="ln557">                  }</a>
<a name="ln558"> </a>
<a name="ln559">            Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, tick.fraction());</a>
<a name="ln560">            s-&gt;add(chord);</a>
<a name="ln561">            MidiTuplet::addElementToTuplet(voice, tick, len, chord, tuplets);</a>
<a name="ln562"> </a>
<a name="ln563">            for (int k = 0; k &lt; midiChords.size(); ++k) {</a>
<a name="ln564">                  MidiChord&amp; midiChord = midiChords[k];</a>
<a name="ln565">                  setMusicNotesFromMidi(score, midiChord.notes, chord, drumset, useDrumset);</a>
<a name="ln566">                  if (!midiChord.notes.empty() &amp;&amp; midiChord.notes.first().offTime - tick &lt;= len) {</a>
<a name="ln567">                        midiChords.removeAt(k);</a>
<a name="ln568">                        --k;</a>
<a name="ln569">                        continue;</a>
<a name="ln570">                        }</a>
<a name="ln571">                  setTies(chord, score, midiChord.notes);</a>
<a name="ln572">                  }</a>
<a name="ln573">            startChordTick += len;</a>
<a name="ln574">            }</a>
<a name="ln575">      fillGapWithRests(score, voice, startChordTick, nextChordTick - startChordTick, track);</a>
<a name="ln576">      }</a>
<a name="ln577"> </a>
<a name="ln578">void MTrack::createKeys(Key defaultKey, const KeyList &amp;allKeyList)</a>
<a name="ln579">      {</a>
<a name="ln580">      KeyList &amp;staffKeyList = *staff-&gt;keyList();</a>
<a name="ln581"> </a>
<a name="ln582">      if (!hasKey &amp;&amp; !mtrack-&gt;drumTrack()) {</a>
<a name="ln583">            if (allKeyList.empty()) {</a>
<a name="ln584">                  KeySigEvent ke;</a>
<a name="ln585">                  ke.setKey(defaultKey);</a>
<a name="ln586">                  staffKeyList[0] = ke;</a>
<a name="ln587">                  MidiKey::assignKeyListToStaff(staffKeyList, staff);</a>
<a name="ln588">                  }</a>
<a name="ln589">            else {</a>
<a name="ln590">                  hasKey = true;</a>
<a name="ln591">                  MidiKey::assignKeyListToStaff(allKeyList, staff);</a>
<a name="ln592">                  }</a>
<a name="ln593">            }</a>
<a name="ln594">      else {</a>
<a name="ln595">            MidiKey::assignKeyListToStaff(staffKeyList, staff);</a>
<a name="ln596">            }</a>
<a name="ln597">      }</a>
<a name="ln598"> </a>
<a name="ln599">void MTrack::createNotes(const ReducedFraction &amp;lastTick)</a>
<a name="ln600">      {</a>
<a name="ln601">      for (int voice = 0; voice &lt; VOICES; ++voice) {</a>
<a name="ln602">                        // startChordTick is onTime value of all simultaneous notes</a>
<a name="ln603">                        // chords here are consist of notes with equal durations</a>
<a name="ln604">                        // several chords may have the same onTime value</a>
<a name="ln605">            ReducedFraction startChordTick;</a>
<a name="ln606">            QList&lt;MidiChord&gt; midiChords;</a>
<a name="ln607"> </a>
<a name="ln608">            for (auto it = chords.begin(); it != chords.end();) {</a>
<a name="ln609">                  const auto &amp;nextChordTick = it-&gt;first;</a>
<a name="ln610">                  const MidiChord&amp; midiChord = it-&gt;second;</a>
<a name="ln611">                  if (midiChord.voice != voice) {</a>
<a name="ln612">                        ++it;</a>
<a name="ln613">                        continue;</a>
<a name="ln614">                        }</a>
<a name="ln615">                  processPendingNotes(midiChords, voice, startChordTick, nextChordTick);</a>
<a name="ln616">                              // now 'midiChords' list is empty</a>
<a name="ln617">                              // so - fill it:</a>
<a name="ln618">                              // collect all midiChords on current tick position</a>
<a name="ln619">                  startChordTick = nextChordTick;       // debug</a>
<a name="ln620">                  for ( ; it != chords.end(); ++it) {</a>
<a name="ln621">                        const MidiChord&amp; midiChord1 = it-&gt;second;</a>
<a name="ln622">                        if (it-&gt;first != startChordTick)</a>
<a name="ln623">                              break;</a>
<a name="ln624">                        if (midiChord1.voice != voice)</a>
<a name="ln625">                              continue;</a>
<a name="ln626">                        midiChords.append(midiChord1);</a>
<a name="ln627">                        }</a>
<a name="ln628">                  if (midiChords.isEmpty())</a>
<a name="ln629">                        break;</a>
<a name="ln630">                  }</a>
<a name="ln631">                        // process last chords at the end of the score</a>
<a name="ln632">            processPendingNotes(midiChords, voice, startChordTick, lastTick);</a>
<a name="ln633">            }</a>
<a name="ln634">      }</a>
<a name="ln635"> </a>
<a name="ln636">Fraction metaTimeSignature(const MidiEvent&amp; e)</a>
<a name="ln637">      {</a>
<a name="ln638">      const unsigned char* data = e.edata();</a>
<a name="ln639">      const int z  = data[0];</a>
<a name="ln640">      const int nn = data[1];</a>
<a name="ln641">      int n  = 1;</a>
<a name="ln642">      for (int i = 0; i &lt; nn; ++i)</a>
<a name="ln643">            n *= 2;</a>
<a name="ln644">      return Fraction(z, n);</a>
<a name="ln645">      }</a>
<a name="ln646"> </a>
<a name="ln647">QList&lt;MTrack&gt; prepareTrackList(const std::multimap&lt;int, MTrack&gt; &amp;tracks)</a>
<a name="ln648">      {</a>
<a name="ln649">      QList&lt;MTrack&gt; trackList;</a>
<a name="ln650">      for (const auto &amp;track: tracks) {</a>
<a name="ln651">                        // show track even if all initial notes were cleaned up</a>
<a name="ln652">            if (track.second.hadInitialNotes)</a>
<a name="ln653">                  trackList.push_back(track.second);</a>
<a name="ln654">            }</a>
<a name="ln655">      return trackList;</a>
<a name="ln656">      }</a>
<a name="ln657"> </a>
<a name="ln658">std::multimap&lt;int, MTrack&gt; createMTrackList(TimeSigMap *sigmap, const MidiFile *mf)</a>
<a name="ln659">      {</a>
<a name="ln660">      sigmap-&gt;clear();</a>
<a name="ln661">      sigmap-&gt;add(0, Fraction(4, 4));   // default time signature</a>
<a name="ln662"> </a>
<a name="ln663">      std::multimap&lt;int, MTrack&gt; tracks;   // &lt;track index, track&gt;</a>
<a name="ln664">      int trackIndex = -1;</a>
<a name="ln665">      for (const auto &amp;t: mf-&gt;tracks()) {</a>
<a name="ln666">            MTrack track;</a>
<a name="ln667">            track.mtrack = &amp;t;</a>
<a name="ln668">            track.division = mf-&gt;division();</a>
<a name="ln669">            track.isDivisionInTps = mf-&gt;isDivisionInTps();</a>
<a name="ln670">            bool hasNotes = false;</a>
<a name="ln671">                        //  - create time signature list from meta events</a>
<a name="ln672">                        //  - create MidiChord list</a>
<a name="ln673">                        //  - extract some information from track: program, min/max pitch</a>
<a name="ln674">            for (const auto &amp;i: t.events()) {</a>
<a name="ln675">                  const MidiEvent&amp; e = i.second;</a>
<a name="ln676">                  const auto tick = toMuseScoreTicks(i.first, track.division,</a>
<a name="ln677">                                                     track.isDivisionInTps);</a>
<a name="ln678">                              // remove time signature events</a>
<a name="ln679">                  if ((e.type() == ME_META) &amp;&amp; (e.metaType() == META_TIME_SIGNATURE)) {</a>
<a name="ln680">                                    // because file can have incorrect data</a>
<a name="ln681">                                    // like time sig event not at the beginning of bar</a>
<a name="ln682">                                    // we need to round tick value to integral bar count</a>
<a name="ln683">                        int bars, beats, ticks;</a>
<a name="ln684">                        sigmap-&gt;tickValues(tick.ticks(), &amp;bars, &amp;beats, &amp;ticks);</a>
<a name="ln685">                        sigmap-&gt;add(sigmap-&gt;bar2tick(bars, 0), metaTimeSignature(e));</a>
<a name="ln686">                        }</a>
<a name="ln687">                  else if (e.type() == ME_NOTE) {</a>
<a name="ln688">                        hasNotes = true;</a>
<a name="ln689">                        const int pitch = e.pitch();</a>
<a name="ln690">                        const auto len = toMuseScoreTicks(e.len(), track.division,</a>
<a name="ln691">                                                          track.isDivisionInTps);</a>
<a name="ln692">                        MidiNote n;</a>
<a name="ln693">                        n.pitch           = pitch;</a>
<a name="ln694">                        n.velo            = e.velo();</a>
<a name="ln695">                        n.offTime         = tick + len;</a>
<a name="ln696">                        n.origOnTime      = tick;</a>
<a name="ln697"> </a>
<a name="ln698">                        MidiChord c;</a>
<a name="ln699">                        c.notes.push_back(n);</a>
<a name="ln700"> </a>
<a name="ln701">                        track.chords.insert({tick, c});</a>
<a name="ln702">                        }</a>
<a name="ln703">                  else if (e.type() == ME_PROGRAM)</a>
<a name="ln704">                        track.program = e.dataB();</a>
<a name="ln705">                  else if (e.type() == ME_CONTROLLER &amp;&amp; e.controller() == CTRL_VOLUME) {</a>
<a name="ln706">                        track.volumes.insert({tick, e.value()});</a>
<a name="ln707">                        }</a>
<a name="ln708">                  }</a>
<a name="ln709">            if (hasNotes) {</a>
<a name="ln710">                  ++trackIndex;</a>
<a name="ln711">                  track.hadInitialNotes = true;</a>
<a name="ln712">                  const auto *data = midiImportOperations.data();</a>
<a name="ln713">                  if (data-&gt;processingsOfOpenedFile &gt; 0) {</a>
<a name="ln714">                        if (data-&gt;trackOpers.doImport.value(trackIndex)) {</a>
<a name="ln715">                              track.indexOfOperation = trackIndex;</a>
<a name="ln716">                              const int reorderedIndex</a>
<a name="ln717">                                    = data-&gt;trackOpers.trackIndexAfterReorder.value(trackIndex);</a>
<a name="ln718">                              tracks.insert({reorderedIndex, track});</a>
<a name="ln719">                              }</a>
<a name="ln720">                        }</a>
<a name="ln721">                  else {            // if it is an initial track-list query from MIDI import panel</a>
<a name="ln722">                        track.indexOfOperation = trackIndex;</a>
<a name="ln723">                        tracks.insert({trackIndex, track});</a>
<a name="ln724">                        }</a>
<a name="ln725">                  }</a>
<a name="ln726">            else {</a>
<a name="ln727">                  track.hadInitialNotes = false;       // it's a tempo track or something else</a>
<a name="ln728">                  tracks.insert({-1, track});</a>
<a name="ln729">                  }</a>
<a name="ln730">            }</a>
<a name="ln731"> </a>
<a name="ln732">      return tracks;</a>
<a name="ln733">      }</a>
<a name="ln734"> </a>
<a name="ln735">Measure* barFromIndex(const Score *score, int barIndex)</a>
<a name="ln736">      {</a>
<a name="ln737">      const int tick = score-&gt;sigmap()-&gt;bar2tick(barIndex, 0);</a>
<a name="ln738">      return score-&gt;tick2measure(Fraction::fromTicks(tick));</a>
<a name="ln739">      }</a>
<a name="ln740"> </a>
<a name="ln741">bool isPickupWithLessTimeSig(const Fraction &amp;firstBarTimeSig, const Fraction &amp;secondBarTimeSig)</a>
<a name="ln742">      {</a>
<a name="ln743">      return firstBarTimeSig &lt; secondBarTimeSig;</a>
<a name="ln744">      }</a>
<a name="ln745"> </a>
<a name="ln746">bool isPickupWithGreaterTimeSig(</a>
<a name="ln747">            const Fraction &amp;firstBarTimeSig,</a>
<a name="ln748">            const Fraction &amp;secondBarTimeSig,</a>
<a name="ln749">            const ReducedFraction &amp;firstTick)</a>
<a name="ln750">      {</a>
<a name="ln751">      return firstBarTimeSig == secondBarTimeSig * 2</a>
<a name="ln752">                  &amp;&amp; firstBarTimeSig.numerator() % 3 != 0</a>
<a name="ln753">                  &amp;&amp; firstTick &gt; ReducedFraction(0, 1);</a>
<a name="ln754">      }</a>
<a name="ln755"> </a>
<a name="ln756">// search for pickup measure only if next 3 bars have equal time signatures</a>
<a name="ln757">bool areNextBarsEqual(const Score *score, int barCount)</a>
<a name="ln758">      {</a>
<a name="ln759">      const int baseBarTick = score-&gt;sigmap()-&gt;bar2tick(1, 0);</a>
<a name="ln760">      const Fraction baseTimeSig = score-&gt;sigmap()-&gt;timesig(baseBarTick).timesig();</a>
<a name="ln761"> </a>
<a name="ln762">      const int equalTimeSigCount = 3;</a>
<a name="ln763">      for (int i = 2; i &lt;= equalTimeSigCount - 1 &amp;&amp; i &lt; barCount; ++i) {</a>
<a name="ln764">            const int barTick = score-&gt;sigmap()-&gt;bar2tick(i, 0);</a>
<a name="ln765">            const Fraction timeSig = score-&gt;sigmap()-&gt;timesig(barTick).timesig();</a>
<a name="ln766">            if (timeSig != baseTimeSig)</a>
<a name="ln767">                  return false;</a>
<a name="ln768">            }</a>
<a name="ln769">      return true;</a>
<a name="ln770">      }</a>
<a name="ln771"> </a>
<a name="ln772">void tryCreatePickupMeasure(</a>
<a name="ln773">            const ReducedFraction &amp;firstTick,</a>
<a name="ln774">            Score *score,</a>
<a name="ln775">            int *begBarIndex,</a>
<a name="ln776">            int *barCount)</a>
<a name="ln777">      {</a>
<a name="ln778">      const int firstBarTick  = score-&gt;sigmap()-&gt;bar2tick(0, 0);</a>
<a name="ln779">      const int secondBarTick = score-&gt;sigmap()-&gt;bar2tick(1, 0);</a>
<a name="ln780">      const Fraction firstTimeSig = score-&gt;sigmap()-&gt;timesig(firstBarTick).timesig();</a>
<a name="ln781">      const Fraction secondTimeSig = score-&gt;sigmap()-&gt;timesig(secondBarTick).timesig();</a>
<a name="ln782"> </a>
<a name="ln783">      if (isPickupWithLessTimeSig(firstTimeSig, secondTimeSig)) {</a>
<a name="ln784">            Measure* pickup = new Measure(score);</a>
<a name="ln785">            pickup-&gt;setTick(Fraction::fromTicks(firstBarTick));</a>
<a name="ln786">            pickup-&gt;setNo(0);</a>
<a name="ln787">            pickup-&gt;setIrregular(true);</a>
<a name="ln788">            pickup-&gt;setTimesig(secondTimeSig);       // nominal time signature</a>
<a name="ln789">            pickup-&gt;setTicks(firstTimeSig);            // actual length</a>
<a name="ln790">            score-&gt;measures()-&gt;add(pickup);</a>
<a name="ln791">            *begBarIndex = 1;</a>
<a name="ln792">            }</a>
<a name="ln793">      else if (isPickupWithGreaterTimeSig(firstTimeSig, secondTimeSig, firstTick)) {</a>
<a name="ln794">                        // split measure into 2 equal measures</a>
<a name="ln795">                        // but for simplicity don't treat first bar as a pickup measure:</a>
<a name="ln796">                        // leave its actual length equal to nominal length</a>
<a name="ln797">            ++(*barCount);</a>
<a name="ln798"> </a>
<a name="ln799">            score-&gt;sigmap()-&gt;add(firstBarTick, secondTimeSig);</a>
<a name="ln800"> </a>
<a name="ln801">            Measure* firstBar = new Measure(score);</a>
<a name="ln802">            firstBar-&gt;setTick(Fraction::fromTicks(firstBarTick));</a>
<a name="ln803">            firstBar-&gt;setNo(0);</a>
<a name="ln804">            firstBar-&gt;setTimesig(secondTimeSig);</a>
<a name="ln805">            firstBar-&gt;setTicks(secondTimeSig);</a>
<a name="ln806">            score-&gt;measures()-&gt;add(firstBar);</a>
<a name="ln807"> </a>
<a name="ln808">            Measure* secondBar = new Measure(score);</a>
<a name="ln809">            secondBar-&gt;setTick(Fraction::fromTicks(firstBarTick + secondTimeSig.ticks()));</a>
<a name="ln810">            secondBar-&gt;setNo(1);</a>
<a name="ln811">            secondBar-&gt;setTimesig(secondTimeSig);</a>
<a name="ln812">            secondBar-&gt;setTicks(secondTimeSig);</a>
<a name="ln813">            score-&gt;measures()-&gt;add(secondBar);</a>
<a name="ln814"> </a>
<a name="ln815">            *begBarIndex = 2;</a>
<a name="ln816">            }</a>
<a name="ln817">      }</a>
<a name="ln818"> </a>
<a name="ln819">void createMeasures(const ReducedFraction &amp;firstTick, ReducedFraction &amp;lastTick, Score *score)</a>
<a name="ln820">      {</a>
<a name="ln821">      int barCount, beat, tick;</a>
<a name="ln822">      score-&gt;sigmap()-&gt;tickValues(lastTick.ticks(), &amp;barCount, &amp;beat, &amp;tick);</a>
<a name="ln823">      if (beat &gt; 0 || tick &gt; 0)</a>
<a name="ln824">            ++barCount;           // convert bar index to number of bars</a>
<a name="ln825"> </a>
<a name="ln826">      auto &amp;data = *midiImportOperations.data();</a>
<a name="ln827">      if (data.processingsOfOpenedFile == 0) {</a>
<a name="ln828">            if (!areNextBarsEqual(score, barCount))</a>
<a name="ln829">                  data.trackOpers.searchPickupMeasure.setValue(false);</a>
<a name="ln830">            }</a>
<a name="ln831"> </a>
<a name="ln832">      const bool tryDetectPickupMeasure = data.trackOpers.searchPickupMeasure.value();</a>
<a name="ln833">      int begBarIndex = 0;</a>
<a name="ln834"> </a>
<a name="ln835">      if (tryDetectPickupMeasure &amp;&amp; barCount &gt; 1)</a>
<a name="ln836">            tryCreatePickupMeasure(firstTick, score, &amp;begBarIndex, &amp;barCount);</a>
<a name="ln837"> </a>
<a name="ln838">      for (int i = begBarIndex; i &lt; barCount; ++i) {</a>
<a name="ln839">            Measure* m = new Measure(score);</a>
<a name="ln840">            const int t = score-&gt;sigmap()-&gt;bar2tick(i, 0);</a>
<a name="ln841">            m-&gt;setTick(Fraction::fromTicks(tick));</a>
<a name="ln842">            m-&gt;setNo(i);</a>
<a name="ln843">            const Fraction timeSig = score-&gt;sigmap()-&gt;timesig(t).timesig();</a>
<a name="ln844">            m-&gt;setTimesig(timeSig);</a>
<a name="ln845">            m-&gt;setTicks(timeSig);</a>
<a name="ln846">            score-&gt;measures()-&gt;add(m);</a>
<a name="ln847">            }</a>
<a name="ln848"> </a>
<a name="ln849">      const Measure *m = score-&gt;lastMeasure();</a>
<a name="ln850">      if (m) {</a>
<a name="ln851">            score-&gt;fixTicks();</a>
<a name="ln852">            lastTick = ReducedFraction(m-&gt;endTick());</a>
<a name="ln853">            }</a>
<a name="ln854">      }</a>
<a name="ln855"> </a>
<a name="ln856">void setTrackInfo(MidiType midiType, MTrack &amp;mt)</a>
<a name="ln857">      {</a>
<a name="ln858">      auto &amp;opers = midiImportOperations;</a>
<a name="ln859"> </a>
<a name="ln860">      const int currentTrack = mt.indexOfOperation;</a>
<a name="ln861">      const QString instrName = MidiInstr::instrumentName(midiType, mt.program,</a>
<a name="ln862">                                                          mt.mtrack-&gt;drumTrack());</a>
<a name="ln863">      if (opers.data()-&gt;processingsOfOpenedFile == 0) {</a>
<a name="ln864">            opers.data()-&gt;trackOpers.midiInstrName.setValue(currentTrack, instrName);</a>
<a name="ln865">                        // set channel number (from 1): number = index + 1</a>
<a name="ln866">            opers.data()-&gt;trackOpers.channel.setValue(currentTrack, mt.mtrack-&gt;outChannel() + 1);</a>
<a name="ln867">            }</a>
<a name="ln868"> </a>
<a name="ln869">      const QString msInstrName = MidiInstr::msInstrName(currentTrack);</a>
<a name="ln870">      const QString trackInstrName = (msInstrName.isEmpty()) ? instrName : msInstrName;</a>
<a name="ln871"> </a>
<a name="ln872">      if (mt.staff-&gt;isTop()) {</a>
<a name="ln873">            Part *part  = mt.staff-&gt;part();</a>
<a name="ln874">            part-&gt;setLongName(XmlWriter::xmlString(MidiInstr::concatenateWithComma(trackInstrName, mt.name)));</a>
<a name="ln875">            part-&gt;setPartName(part-&gt;longName());</a>
<a name="ln876">            part-&gt;setMidiChannel(mt.mtrack-&gt;outChannel());</a>
<a name="ln877">            int bank = 0;</a>
<a name="ln878">            if (mt.mtrack-&gt;drumTrack())</a>
<a name="ln879">                  bank = 128;</a>
<a name="ln880">            part-&gt;setMidiProgram(mt.program &amp; 0x7f, bank);  // only GM</a>
<a name="ln881">            }</a>
<a name="ln882"> </a>
<a name="ln883">      if (mt.name.isEmpty() &amp;&amp; !trackInstrName.isEmpty())</a>
<a name="ln884">            mt.name = trackInstrName;</a>
<a name="ln885">      }</a>
<a name="ln886"> </a>
<a name="ln887">void createTimeSignatures(Score *score)</a>
<a name="ln888">      {</a>
<a name="ln889">      for (auto is = score-&gt;sigmap()-&gt;begin(); is != score-&gt;sigmap()-&gt;end(); ++is) {</a>
<a name="ln890">            const SigEvent&amp; se = is-&gt;second;</a>
<a name="ln891">            const int tick = is-&gt;first;</a>
<a name="ln892">            Measure* m = score-&gt;tick2measure(Fraction::fromTicks(tick));</a>
<a name="ln893">            if (!m)</a>
<a name="ln894">                  continue;</a>
<a name="ln895">            Fraction newTimeSig = se.timesig();</a>
<a name="ln896"> </a>
<a name="ln897">            const auto&amp; opers = midiImportOperations;</a>
<a name="ln898">            const bool pickupMeasure = opers.data()-&gt;trackOpers.searchPickupMeasure.value();</a>
<a name="ln899"> </a>
<a name="ln900">            if (pickupMeasure &amp;&amp; is == score-&gt;sigmap()-&gt;begin()) {</a>
<a name="ln901">                  auto next = std::next(is);</a>
<a name="ln902">                  if (next != score-&gt;sigmap()-&gt;end()) {</a>
<a name="ln903">                        Measure* mm = score-&gt;tick2measure(Fraction::fromTicks(next-&gt;first));</a>
<a name="ln904">                        if (m &amp;&amp; mm &amp;&amp; m == barFromIndex(score, 0) &amp;&amp; mm == barFromIndex(score, 1)</a>
<a name="ln905">                                    &amp;&amp; m-&gt;timesig() == mm-&gt;timesig() &amp;&amp; newTimeSig != mm-&gt;timesig())</a>
<a name="ln906">                              {</a>
<a name="ln907">                                          // it's a pickup measure - change timesig to nominal value</a>
<a name="ln908">                                    newTimeSig = mm-&gt;timesig();</a>
<a name="ln909">                              }</a>
<a name="ln910">                        }</a>
<a name="ln911">                  }</a>
<a name="ln912">            for (int staffIdx = 0; staffIdx &lt; score-&gt;nstaves(); ++staffIdx) {</a>
<a name="ln913">                  TimeSig* ts = new TimeSig(score);</a>
<a name="ln914">                  ts-&gt;setSig(newTimeSig);</a>
<a name="ln915">                  ts-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln916">                  Segment* seg = m-&gt;getSegment(SegmentType::TimeSig, Fraction::fromTicks(tick));</a>
<a name="ln917">                  seg-&gt;add(ts);</a>
<a name="ln918">                  }</a>
<a name="ln919">            if (newTimeSig != se.timesig())   // was a pickup measure - skip next timesig</a>
<a name="ln920">                  ++is;</a>
<a name="ln921">            }</a>
<a name="ln922">      }</a>
<a name="ln923"> </a>
<a name="ln924">void processMeta(MTrack &amp;mt, bool isLyric)</a>
<a name="ln925">      {</a>
<a name="ln926">      for (const auto &amp;ie : mt.mtrack-&gt;events()) {</a>
<a name="ln927">            const MidiEvent &amp;e = ie.second;</a>
<a name="ln928">            const auto tick = toMuseScoreTicks(ie.first, mt.division, mt.isDivisionInTps);</a>
<a name="ln929">            if ((e.type() == ME_META) &amp;&amp; ((e.metaType() == META_LYRIC) == isLyric))</a>
<a name="ln930">                  mt.processMeta(tick.ticks(), e);</a>
<a name="ln931">            }</a>
<a name="ln932">      }</a>
<a name="ln933"> </a>
<a name="ln934">// key list with key signatures of all tracks</a>
<a name="ln935">//   to assign it to tracks without any specified key signature</a>
<a name="ln936">KeyList findAllKeyList(const QList&lt;MTrack&gt; &amp;tracks)</a>
<a name="ln937">      {</a>
<a name="ln938">      KeyList kl;</a>
<a name="ln939">      for (int i = 0; i &lt; tracks.size(); ++i) {</a>
<a name="ln940">            if (tracks[i].hasKey) {</a>
<a name="ln941">                  for (const auto &amp;key: *tracks[i].staff-&gt;keyList())</a>
<a name="ln942">                        kl.setKey(key.first, key.second);</a>
<a name="ln943">                  }</a>
<a name="ln944">            }</a>
<a name="ln945">      return kl;</a>
<a name="ln946">      }</a>
<a name="ln947"> </a>
<a name="ln948">void createNotes(const ReducedFraction &amp;lastTick, QList&lt;MTrack&gt; &amp;tracks)</a>
<a name="ln949">      {</a>
<a name="ln950">      for (int i = 0; i &lt; tracks.size(); ++i) {</a>
<a name="ln951">            MTrack &amp;mt = tracks[i];</a>
<a name="ln952">            mt.createNotes(lastTick);</a>
<a name="ln953">            MidiTuplet::createTupletNotes(mt.staff, mt.tuplets);</a>
<a name="ln954">            }</a>
<a name="ln955">      }</a>
<a name="ln956"> </a>
<a name="ln957">void processNonLyricMeta(QList&lt;MTrack&gt; &amp;tracks)</a>
<a name="ln958">      {</a>
<a name="ln959">      for (int i = 0; i &lt; tracks.size(); ++i) {</a>
<a name="ln960">            MTrack &amp;mt = tracks[i];</a>
<a name="ln961">            processMeta(mt, false);</a>
<a name="ln962">            }</a>
<a name="ln963">      }</a>
<a name="ln964"> </a>
<a name="ln965">void setTrackInfo(QList&lt;MTrack&gt; &amp;tracks, MidiType midiType)</a>
<a name="ln966">      {</a>
<a name="ln967">      for (int i = 0; i &lt; tracks.size(); ++i) {</a>
<a name="ln968">            MTrack &amp;mt = tracks[i];</a>
<a name="ln969">            if (midiType == MidiType::UNKNOWN)</a>
<a name="ln970">                  midiType = MidiType::GM;</a>
<a name="ln971">            setTrackInfo(midiType, mt);</a>
<a name="ln972">            }</a>
<a name="ln973">      }</a>
<a name="ln974"> </a>
<a name="ln975">void processLyricMeta(QList&lt;MTrack&gt; &amp;tracks)</a>
<a name="ln976">      {</a>
<a name="ln977">      for (int i = 0; i &lt; tracks.size(); ++i) {</a>
<a name="ln978">            MTrack &amp;mt = tracks[i];</a>
<a name="ln979">            processMeta(mt, true);</a>
<a name="ln980">            }</a>
<a name="ln981">      }</a>
<a name="ln982"> </a>
<a name="ln983">void createKeys(QList&lt;MTrack&gt; &amp;tracks)</a>
<a name="ln984">      {</a>
<a name="ln985">      const Key defaultKey = Key::C;     // TODO-LIB findKey(mtrack, score-&gt;sigmap());</a>
<a name="ln986">      const KeyList &amp;allKeyList = findAllKeyList(tracks);</a>
<a name="ln987"> </a>
<a name="ln988">      for (int i = 0; i &lt; tracks.size(); ++i) {</a>
<a name="ln989">            MTrack &amp;mt = tracks[i];</a>
<a name="ln990">            mt.createKeys(defaultKey, allKeyList);</a>
<a name="ln991">            }</a>
<a name="ln992">      }</a>
<a name="ln993"> </a>
<a name="ln994">void applySwing(QList&lt;MTrack&gt; &amp;tracks)</a>
<a name="ln995">      {</a>
<a name="ln996">      for (int i = 0; i &lt; tracks.size(); ++i) {</a>
<a name="ln997">            MTrack &amp;mt = tracks[i];</a>
<a name="ln998"> </a>
<a name="ln999">            const auto&amp; opers = midiImportOperations.data()-&gt;trackOpers;</a>
<a name="ln1000">            const auto swingType = opers.swing.value(mt.indexOfOperation);</a>
<a name="ln1001">            Swing::detectSwing(mt.staff, swingType);</a>
<a name="ln1002"> </a>
<a name="ln1003">            Q_ASSERT_X(MidiTie::areTiesConsistent(mt.staff),</a>
<a name="ln1004">                       &quot;applySwing&quot;, &quot;Ties are inconsistent&quot;);</a>
<a name="ln1005"> </a>
<a name="ln1006">            Q_ASSERT_X(MidiTuplet::haveTupletsEnoughElements(mt.staff),</a>
<a name="ln1007">                       &quot;MTrack::convertTrack&quot;,</a>
<a name="ln1008">                       &quot;Tuplet has less than 2 elements or all elements are rests&quot;);</a>
<a name="ln1009">            }</a>
<a name="ln1010">      }</a>
<a name="ln1011"> </a>
<a name="ln1012">void createClefs(QList&lt;MTrack&gt; &amp;tracks)</a>
<a name="ln1013">      {</a>
<a name="ln1014">      for (int i = 0; i &lt; tracks.size(); ++i) {</a>
<a name="ln1015">            MTrack &amp;mt = tracks[i];</a>
<a name="ln1016">            MidiClef::createClefs(mt.staff, mt.indexOfOperation, mt.mtrack-&gt;drumTrack());</a>
<a name="ln1017">            }</a>
<a name="ln1018">      }</a>
<a name="ln1019"> </a>
<a name="ln1020">void setLeftRightHandSplit(const std::multimap&lt;int, MTrack&gt; &amp;tracks)</a>
<a name="ln1021">      {</a>
<a name="ln1022">      for (auto it = tracks.begin(); it != tracks.end(); ++it) {</a>
<a name="ln1023">            int trackIndex = it-&gt;first;</a>
<a name="ln1024">            const MTrack &amp;mtrack = it-&gt;second;</a>
<a name="ln1025">            if (mtrack.mtrack-&gt;drumTrack() || mtrack.chords.empty())</a>
<a name="ln1026">                  continue;</a>
<a name="ln1027"> </a>
<a name="ln1028">                        // don't split staff if it is already in Grand Staff</a>
<a name="ln1029">            const auto nextIt = std::next(it);</a>
<a name="ln1030">            if (nextIt != tracks.end()) {</a>
<a name="ln1031">                  if (MidiInstr::isGrandStaff(mtrack, nextIt-&gt;second)) {</a>
<a name="ln1032">                        ++it;</a>
<a name="ln1033">                        continue;</a>
<a name="ln1034">                        }</a>
<a name="ln1035">                  }</a>
<a name="ln1036"> </a>
<a name="ln1037">            if (LRHand::needToSplit(mtrack.chords, mtrack.program, mtrack.mtrack-&gt;drumTrack())) {</a>
<a name="ln1038">                  midiImportOperations.data()-&gt;trackOpers.doStaffSplit.setValue(</a>
<a name="ln1039">                                                                              trackIndex, true);</a>
<a name="ln1040">                  }</a>
<a name="ln1041">            }</a>
<a name="ln1042">      }</a>
<a name="ln1043"> </a>
<a name="ln1044">ReducedFraction findFirstChordTick(const QList&lt;MTrack&gt; &amp;tracks)</a>
<a name="ln1045">      {</a>
<a name="ln1046">      ReducedFraction firstTick(0, 1);</a>
<a name="ln1047">      for (const auto &amp;track: tracks) {</a>
<a name="ln1048">            if (track.chords.empty())</a>
<a name="ln1049">                  continue;</a>
<a name="ln1050">            const auto &amp;chordTick = track.chords.begin()-&gt;first;</a>
<a name="ln1051"> </a>
<a name="ln1052">            Q_ASSERT(chordTick &gt;= ReducedFraction(0, 1));</a>
<a name="ln1053"> </a>
<a name="ln1054">            if (firstTick == ReducedFraction(0, 1) || chordTick &lt; firstTick)</a>
<a name="ln1055">                  firstTick = chordTick;</a>
<a name="ln1056">            }</a>
<a name="ln1057">      return firstTick;</a>
<a name="ln1058">      }</a>
<a name="ln1059"> </a>
<a name="ln1060">ReducedFraction findLastChordTick(const std::multimap&lt;int, MTrack&gt; &amp;tracks)</a>
<a name="ln1061">      {</a>
<a name="ln1062">      ReducedFraction lastTick(0, 1);</a>
<a name="ln1063">      for (const auto &amp;track: tracks) {</a>
<a name="ln1064">            for (const auto &amp;chord: track.second.chords) {</a>
<a name="ln1065">                  const auto offTime = MChord::maxNoteOffTime(chord.second.notes);</a>
<a name="ln1066">                  if (offTime &gt; lastTick)</a>
<a name="ln1067">                        lastTick = offTime;</a>
<a name="ln1068">                  }</a>
<a name="ln1069">            }</a>
<a name="ln1070">      return lastTick;</a>
<a name="ln1071">      }</a>
<a name="ln1072"> </a>
<a name="ln1073">QList&lt;MTrack&gt; convertMidi(Score *score, const MidiFile *mf)</a>
<a name="ln1074">      {</a>
<a name="ln1075">      auto *sigmap = score-&gt;sigmap();</a>
<a name="ln1076"> </a>
<a name="ln1077">      auto tracks = createMTrackList(sigmap, mf);</a>
<a name="ln1078"> </a>
<a name="ln1079">      auto &amp;opers = midiImportOperations;</a>
<a name="ln1080">      if (opers.data()-&gt;processingsOfOpenedFile == 0)         // for newly opened MIDI file</a>
<a name="ln1081">            MidiChordName::findChordNames(tracks);</a>
<a name="ln1082"> </a>
<a name="ln1083">      lengthenTooShortNotes(tracks);</a>
<a name="ln1084"> </a>
<a name="ln1085">      if (opers.data()-&gt;processingsOfOpenedFile == 0) {       // for newly opened MIDI file</a>
<a name="ln1086">            opers.data()-&gt;trackCount = 0;</a>
<a name="ln1087">            for (const auto &amp;track: tracks) {</a>
<a name="ln1088">                  if (track.first != -1)</a>
<a name="ln1089">                        ++opers.data()-&gt;trackCount;</a>
<a name="ln1090">                  }</a>
<a name="ln1091">            MidiLyrics::extractLyricsToMidiData(mf);</a>
<a name="ln1092">            }</a>
<a name="ln1093">                  // for newly opened MIDI file - detect if it is a human performance</a>
<a name="ln1094">                  // if so - detect beats and set initial time signature</a>
<a name="ln1095">      if (opers.data()-&gt;processingsOfOpenedFile == 0)</a>
<a name="ln1096">            Quantize::setIfHumanPerformance(tracks, sigmap);</a>
<a name="ln1097">      else        // user value</a>
<a name="ln1098">            MidiBeat::setTimeSignature(sigmap);</a>
<a name="ln1099"> </a>
<a name="ln1100">      Q_ASSERT_X((opers.data()-&gt;trackOpers.isHumanPerformance.value())</a>
<a name="ln1101">                        ? Meter::userTimeSigToFraction(opers.data()-&gt;trackOpers.timeSigNumerator.value(),</a>
<a name="ln1102">                                                       opers.data()-&gt;trackOpers.timeSigDenominator.value())</a>
<a name="ln1103">                          != ReducedFraction(0, 1) : true,</a>
<a name="ln1104">                 &quot;convertMidi&quot;, &quot;Null time signature for human-performed MIDI file&quot;);</a>
<a name="ln1105"> </a>
<a name="ln1106">      MChord::collectChords(tracks, {2, 1}, {1, 2});</a>
<a name="ln1107">      MidiBeat::adjustChordsToBeats(tracks);</a>
<a name="ln1108">      MChord::mergeChordsWithEqualOnTimeAndVoice(tracks);</a>
<a name="ln1109"> </a>
<a name="ln1110">                  // for newly opened MIDI file</a>
<a name="ln1111">      if (opers.data()-&gt;processingsOfOpenedFile == 0</a>
<a name="ln1112">                  &amp;&amp; opers.data()-&gt;trackOpers.doStaffSplit.canRedefineDefaultLater()) {</a>
<a name="ln1113">            setLeftRightHandSplit(tracks);</a>
<a name="ln1114">            }</a>
<a name="ln1115"> </a>
<a name="ln1116">      MChord::removeOverlappingNotes(tracks);</a>
<a name="ln1117"> </a>
<a name="ln1118">      Q_ASSERT_X(!doNotesOverlap(tracks),</a>
<a name="ln1119">                 &quot;convertMidi&quot;, &quot;There are overlapping notes of the same voice that is incorrect&quot;);</a>
<a name="ln1120"> </a>
<a name="ln1121">      LRHand::splitIntoLeftRightHands(tracks);</a>
<a name="ln1122">      MidiDrum::splitDrumVoices(tracks);</a>
<a name="ln1123">      MidiDrum::splitDrumTracks(tracks);</a>
<a name="ln1124">      ReducedFraction lastTick = findLastChordTick(tracks);</a>
<a name="ln1125">      quantizeAllTracks(tracks, sigmap, lastTick);</a>
<a name="ln1126">      MChord::removeOverlappingNotes(tracks);</a>
<a name="ln1127"> </a>
<a name="ln1128">      Q_ASSERT_X(!doNotesOverlap(tracks),</a>
<a name="ln1129">                 &quot;convertMidi&quot;, &quot;There are overlapping notes of the same voice that is incorrect&quot;);</a>
<a name="ln1130">      Q_ASSERT_X(noTooShortNotes(tracks),</a>
<a name="ln1131">                 &quot;convertMidi&quot;, &quot;There are notes of length &lt; min allowed duration&quot;);</a>
<a name="ln1132"> </a>
<a name="ln1133">      MChord::mergeChordsWithEqualOnTimeAndVoice(tracks);</a>
<a name="ln1134">      Simplify::simplifyDurationsNotDrums(tracks, sigmap);</a>
<a name="ln1135">      if (MidiVoice::separateVoices(tracks, sigmap))</a>
<a name="ln1136">            Simplify::simplifyDurationsNotDrums(tracks, sigmap);    // again</a>
<a name="ln1137">      Simplify::simplifyDurationsForDrums(tracks, sigmap);</a>
<a name="ln1138">      MChord::splitUnequalChords(tracks);</a>
<a name="ln1139">                  // no more track insertion/reordering/deletion from now</a>
<a name="ln1140">      QList&lt;MTrack&gt; trackList = prepareTrackList(tracks);</a>
<a name="ln1141">      MidiInstr::setGrandStaffProgram(trackList);</a>
<a name="ln1142">      MidiInstr::findInstrumentsForAllTracks(trackList);</a>
<a name="ln1143">      MidiInstr::createInstruments(score, trackList);</a>
<a name="ln1144">      MidiDrum::setStaffBracketForDrums(trackList);</a>
<a name="ln1145"> </a>
<a name="ln1146">      const auto firstTick = findFirstChordTick(trackList);</a>
<a name="ln1147"> </a>
<a name="ln1148">      createMeasures(firstTick, lastTick, score);</a>
<a name="ln1149">      processNonLyricMeta(trackList);</a>
<a name="ln1150">      setTrackInfo(trackList, mf-&gt;midiType());</a>
<a name="ln1151">      createKeys(trackList);</a>
<a name="ln1152">      MidiKey::recognizeMainKeySig(trackList);</a>
<a name="ln1153">      createNotes(lastTick, trackList);</a>
<a name="ln1154">      processLyricMeta(trackList);</a>
<a name="ln1155">      applySwing(trackList);</a>
<a name="ln1156">      createClefs(trackList);</a>
<a name="ln1157">      createTimeSignatures(score);</a>
<a name="ln1158">      score-&gt;connectTies();</a>
<a name="ln1159"> </a>
<a name="ln1160">      MidiLyrics::setLyricsToScore(trackList);</a>
<a name="ln1161">      MidiTempo::setTempo(tracks, score);</a>
<a name="ln1162">      MidiChordName::setChordNames(trackList);</a>
<a name="ln1163"> </a>
<a name="ln1164">      return trackList;</a>
<a name="ln1165">      }</a>
<a name="ln1166"> </a>
<a name="ln1167">void loadMidiData(MidiFile &amp;mf)</a>
<a name="ln1168">      {</a>
<a name="ln1169">      mf.separateChannel();</a>
<a name="ln1170">      MidiType mt = MidiType::UNKNOWN;</a>
<a name="ln1171">      for (auto &amp;track: mf.tracks())</a>
<a name="ln1172">            track.mergeNoteOnOffAndFindMidiType(&amp;mt);</a>
<a name="ln1173">      mf.setMidiType(mt);</a>
<a name="ln1174">      }</a>
<a name="ln1175"> </a>
<a name="ln1176">Score::FileError importMidi(MasterScore *score, const QString &amp;name)</a>
<a name="ln1177">      {</a>
<a name="ln1178">      if (name.isEmpty())</a>
<a name="ln1179">            return Score::FileError::FILE_NOT_FOUND;</a>
<a name="ln1180"> </a>
<a name="ln1181">      auto &amp;opers = midiImportOperations;</a>
<a name="ln1182"> </a>
<a name="ln1183">      MidiOperations::CurrentMidiFileSetter setCurrentMidiFile(opers, name);</a>
<a name="ln1184">      if (!opers.hasMidiFile(name))</a>
<a name="ln1185">            opers.addNewMidiFile(name);</a>
<a name="ln1186"> </a>
<a name="ln1187">      if (opers.data()-&gt;processingsOfOpenedFile == 0) {</a>
<a name="ln1188"> </a>
<a name="ln1189">            QFile fp(name);</a>
<a name="ln1190">            if (!fp.open(QIODevice::ReadOnly)) {</a>
<a name="ln1191">                  qDebug(&quot;importMidi: file open error &lt;%s&gt;&quot;, qPrintable(name));</a>
<a name="ln1192">                  return Score::FileError::FILE_OPEN_ERROR;</a>
<a name="ln1193">                  }</a>
<a name="ln1194">            MidiFile mf;</a>
<a name="ln1195">            try {</a>
<a name="ln1196">                  mf.read(&amp;fp);</a>
<a name="ln1197">                  }</a>
<a name="ln1198">            catch (QString errorText) {</a>
<a name="ln1199">                  if (!MScore::noGui) {</a>
<a name="ln1200">                        QMessageBox::warning(0,</a>
<a name="ln1201">                           QWidget::tr(&quot;Load MIDI&quot;),</a>
<a name="ln1202">                           QWidget::tr(&quot;Load failed: %1&quot;).arg(errorText),</a>
<a name="ln1203">                           QString(), QWidget::tr(&quot;Quit&quot;), QString(), 0, 1);</a>
<a name="ln1204">                        }</a>
<a name="ln1205">                  fp.close();</a>
<a name="ln1206">                  qDebug(&quot;importMidi: bad file format&quot;);</a>
<a name="ln1207">                  return Score::FileError::FILE_BAD_FORMAT;</a>
<a name="ln1208">                  }</a>
<a name="ln1209">            fp.close();</a>
<a name="ln1210"> </a>
<a name="ln1211">            loadMidiData(mf);</a>
<a name="ln1212">            opers.setMidiFileData(name, mf);</a>
<a name="ln1213">            }</a>
<a name="ln1214"> </a>
<a name="ln1215">      opers.data()-&gt;tracks = convertMidi(score, opers.midiFile(name));</a>
<a name="ln1216">      ++opers.data()-&gt;processingsOfOpenedFile;</a>
<a name="ln1217"> </a>
<a name="ln1218">      return Score::FileError::FILE_NO_ERROR;</a>
<a name="ln1219">      }</a>
<a name="ln1220">}</a>
<a name="ln1221"> </a>

</code></pre>
<div class="balloon" rel="904"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: m.</p></div>
<div class="balloon" rel="1191"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
