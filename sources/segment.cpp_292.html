
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>segment.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;mscore.h&quot;</a>
<a name="ln14">#include &quot;segment.h&quot;</a>
<a name="ln15">#include &quot;element.h&quot;</a>
<a name="ln16">#include &quot;chord.h&quot;</a>
<a name="ln17">#include &quot;note.h&quot;</a>
<a name="ln18">#include &quot;score.h&quot;</a>
<a name="ln19">#include &quot;beam.h&quot;</a>
<a name="ln20">#include &quot;tuplet.h&quot;</a>
<a name="ln21">#include &quot;text.h&quot;</a>
<a name="ln22">#include &quot;measure.h&quot;</a>
<a name="ln23">#include &quot;barline.h&quot;</a>
<a name="ln24">#include &quot;part.h&quot;</a>
<a name="ln25">#include &quot;repeat.h&quot;</a>
<a name="ln26">#include &quot;staff.h&quot;</a>
<a name="ln27">#include &quot;line.h&quot;</a>
<a name="ln28">#include &quot;hairpin.h&quot;</a>
<a name="ln29">#include &quot;ottava.h&quot;</a>
<a name="ln30">#include &quot;sig.h&quot;</a>
<a name="ln31">#include &quot;keysig.h&quot;</a>
<a name="ln32">#include &quot;staffstate.h&quot;</a>
<a name="ln33">#include &quot;instrchange.h&quot;</a>
<a name="ln34">#include &quot;clef.h&quot;</a>
<a name="ln35">#include &quot;timesig.h&quot;</a>
<a name="ln36">#include &quot;system.h&quot;</a>
<a name="ln37">#include &quot;xml.h&quot;</a>
<a name="ln38">#include &quot;undo.h&quot;</a>
<a name="ln39">#include &quot;harmony.h&quot;</a>
<a name="ln40"> </a>
<a name="ln41">namespace Ms {</a>
<a name="ln42"> </a>
<a name="ln43">//---------------------------------------------------------</a>
<a name="ln44">//   subTypeName</a>
<a name="ln45">//---------------------------------------------------------</a>
<a name="ln46"> </a>
<a name="ln47">const char* Segment::subTypeName() const</a>
<a name="ln48">      {</a>
<a name="ln49">      return subTypeName(_segmentType);</a>
<a name="ln50">      }</a>
<a name="ln51"> </a>
<a name="ln52">const char* Segment::subTypeName(SegmentType t)</a>
<a name="ln53">      {</a>
<a name="ln54">      switch(t) {</a>
<a name="ln55">            case SegmentType::Invalid:              return &quot;Invalid&quot;;</a>
<a name="ln56">            case SegmentType::BeginBarLine:         return &quot;BeginBarLine&quot;;</a>
<a name="ln57">            case SegmentType::HeaderClef:           return &quot;HeaderClef&quot;;</a>
<a name="ln58">            case SegmentType::Clef:                 return &quot;Clef&quot;;</a>
<a name="ln59">            case SegmentType::KeySig:               return &quot;Key Signature&quot;;</a>
<a name="ln60">            case SegmentType::Ambitus:              return &quot;Ambitus&quot;;</a>
<a name="ln61">            case SegmentType::TimeSig:              return &quot;Time Signature&quot;;</a>
<a name="ln62">            case SegmentType::StartRepeatBarLine:   return &quot;Begin Repeat&quot;;</a>
<a name="ln63">            case SegmentType::BarLine:              return &quot;BarLine&quot;;</a>
<a name="ln64">            case SegmentType::Breath:               return &quot;Breath&quot;;</a>
<a name="ln65">            case SegmentType::ChordRest:            return &quot;ChordRest&quot;;</a>
<a name="ln66">            case SegmentType::EndBarLine:           return &quot;EndBarLine&quot;;</a>
<a name="ln67">            case SegmentType::KeySigAnnounce:       return &quot;Key Sig Precaution&quot;;</a>
<a name="ln68">            case SegmentType::TimeSigAnnounce:      return &quot;Time Sig Precaution&quot;;</a>
<a name="ln69">            default:</a>
<a name="ln70">                  return &quot;??&quot;;</a>
<a name="ln71">            }</a>
<a name="ln72">      }</a>
<a name="ln73"> </a>
<a name="ln74">//---------------------------------------------------------</a>
<a name="ln75">//   setElement</a>
<a name="ln76">//---------------------------------------------------------</a>
<a name="ln77"> </a>
<a name="ln78">void Segment::setElement(int track, Element* el)</a>
<a name="ln79">      {</a>
<a name="ln80">      if (el) {</a>
<a name="ln81">            el-&gt;setParent(this);</a>
<a name="ln82">            _elist[track] = el;</a>
<a name="ln83">            setEmpty(false);</a>
<a name="ln84">            }</a>
<a name="ln85">      else {</a>
<a name="ln86">            _elist[track] = 0;</a>
<a name="ln87">            checkEmpty();</a>
<a name="ln88">            }</a>
<a name="ln89">      }</a>
<a name="ln90"> </a>
<a name="ln91">//---------------------------------------------------------</a>
<a name="ln92">//   remove</a>
<a name="ln93">//---------------------------------------------------------</a>
<a name="ln94"> </a>
<a name="ln95">void Segment::removeElement(int track)</a>
<a name="ln96">      {</a>
<a name="ln97">      Element* el = element(track);</a>
<a name="ln98">      if (el-&gt;isChordRest()) {</a>
<a name="ln99">            ChordRest* cr = (ChordRest*)el;</a>
<a name="ln100">            Beam* beam = cr-&gt;beam();</a>
<a name="ln101">            if (beam)</a>
<a name="ln102">                  beam-&gt;remove(cr);</a>
<a name="ln103">            Tuplet* tuplet = cr-&gt;tuplet();</a>
<a name="ln104">            if (tuplet)</a>
<a name="ln105">                  tuplet-&gt;remove(cr);</a>
<a name="ln106">            }</a>
<a name="ln107">      }</a>
<a name="ln108"> </a>
<a name="ln109">//---------------------------------------------------------</a>
<a name="ln110">//   Segment</a>
<a name="ln111">//---------------------------------------------------------</a>
<a name="ln112"> </a>
<a name="ln113">Segment::Segment(Measure* m)</a>
<a name="ln114">   : Element(m-&gt;score(), ElementFlag::EMPTY | ElementFlag::ENABLED | ElementFlag::NOT_SELECTABLE)</a>
<a name="ln115">      {</a>
<a name="ln116">      setParent(m);</a>
<a name="ln117">      init();</a>
<a name="ln118">      }</a>
<a name="ln119"> </a>
<a name="ln120">Segment::Segment(Measure* m, SegmentType st, const Fraction&amp; t)</a>
<a name="ln121">   : Element(m-&gt;score(), ElementFlag::EMPTY | ElementFlag::ENABLED | ElementFlag::NOT_SELECTABLE)</a>
<a name="ln122">      {</a>
<a name="ln123">      setParent(m);</a>
<a name="ln124">//      Q_ASSERT(t &gt;= Fraction(0,1));</a>
<a name="ln125">//      Q_ASSERT(t &lt;= m-&gt;ticks());</a>
<a name="ln126">      _segmentType = st;</a>
<a name="ln127">      _tick = t;</a>
<a name="ln128">      init();</a>
<a name="ln129">      }</a>
<a name="ln130"> </a>
<a name="ln131">//---------------------------------------------------------</a>
<a name="ln132">//   Segment</a>
<a name="ln133">//---------------------------------------------------------</a>
<a name="ln134"> </a>
<a name="ln135">Segment::Segment(const Segment&amp; s)</a>
<a name="ln136">   : Element(s)</a>
<a name="ln137">      {</a>
<a name="ln138">      _segmentType        = s._segmentType;</a>
<a name="ln139">      _tick               = s._tick;</a>
<a name="ln140">      _extraLeadingSpace  = s._extraLeadingSpace;</a>
<a name="ln141"> </a>
<a name="ln142">      for (Element* e : s._annotations)</a>
<a name="ln143">            add(e-&gt;clone());</a>
<a name="ln144"> </a>
<a name="ln145">      _elist.reserve(s._elist.size());</a>
<a name="ln146">      for (Element* e : s._elist) {</a>
<a name="ln147">            Element* ne = 0;</a>
<a name="ln148">            if (e) {</a>
<a name="ln149">                  ne = e-&gt;clone();</a>
<a name="ln150">                  ne-&gt;setParent(this);</a>
<a name="ln151">                  }</a>
<a name="ln152">            _elist.push_back(ne);</a>
<a name="ln153">            }</a>
<a name="ln154">      _dotPosX = s._dotPosX;</a>
<a name="ln155">      _shapes  = s._shapes;</a>
<a name="ln156">      }</a>
<a name="ln157"> </a>
<a name="ln158">//---------------------------------------------------------</a>
<a name="ln159">//   setSegmentType</a>
<a name="ln160">//---------------------------------------------------------</a>
<a name="ln161"> </a>
<a name="ln162">void Segment::setSegmentType(SegmentType t)</a>
<a name="ln163">      {</a>
<a name="ln164">      Q_ASSERT(_segmentType != SegmentType::Clef || t != SegmentType::ChordRest);</a>
<a name="ln165">      _segmentType = t;</a>
<a name="ln166">      }</a>
<a name="ln167"> </a>
<a name="ln168">//---------------------------------------------------------</a>
<a name="ln169">//   setScore</a>
<a name="ln170">//---------------------------------------------------------</a>
<a name="ln171"> </a>
<a name="ln172">void Segment::setScore(Score* score)</a>
<a name="ln173">      {</a>
<a name="ln174">      Element::setScore(score);</a>
<a name="ln175">      for (Element* e : _elist) {</a>
<a name="ln176">            if (e)</a>
<a name="ln177">                  e-&gt;setScore(score);</a>
<a name="ln178">            }</a>
<a name="ln179">      for (Element* e : _annotations)</a>
<a name="ln180">            e-&gt;setScore(score);</a>
<a name="ln181">      }</a>
<a name="ln182"> </a>
<a name="ln183">Segment::~Segment()</a>
<a name="ln184">      {</a>
<a name="ln185">      for (Element* e : _elist) {</a>
<a name="ln186">            if (!e)</a>
<a name="ln187">                  continue;</a>
<a name="ln188">            if (e-&gt;isTimeSig())</a>
<a name="ln189">                  e-&gt;staff()-&gt;removeTimeSig(toTimeSig(e));</a>
<a name="ln190">            delete e;</a>
<a name="ln191">            }</a>
<a name="ln192">      qDeleteAll(_annotations);</a>
<a name="ln193">      }</a>
<a name="ln194"> </a>
<a name="ln195">//---------------------------------------------------------</a>
<a name="ln196">//   init</a>
<a name="ln197">//---------------------------------------------------------</a>
<a name="ln198"> </a>
<a name="ln199">void Segment::init()</a>
<a name="ln200">      {</a>
<a name="ln201">      int staves = score()-&gt;nstaves();</a>
<a name="ln202">      int tracks = staves * VOICES;</a>
<a name="ln203">      _elist.assign(tracks, 0);</a>
<a name="ln204">      _dotPosX.assign(staves, 0.0);</a>
<a name="ln205">      _shapes.assign(staves, Shape());</a>
<a name="ln206">      }</a>
<a name="ln207"> </a>
<a name="ln208">//---------------------------------------------------------</a>
<a name="ln209">//   tick</a>
<a name="ln210">//---------------------------------------------------------</a>
<a name="ln211"> </a>
<a name="ln212">Fraction Segment::tick() const</a>
<a name="ln213">      {</a>
<a name="ln214">      return _tick + measure()-&gt;tick();</a>
<a name="ln215">      }</a>
<a name="ln216"> </a>
<a name="ln217">//---------------------------------------------------------</a>
<a name="ln218">//   next1</a>
<a name="ln219">///   return next \a Segment, don’t stop searching at end</a>
<a name="ln220">///   of \a Measure</a>
<a name="ln221">//---------------------------------------------------------</a>
<a name="ln222"> </a>
<a name="ln223">Segment* Segment::next1() const</a>
<a name="ln224">      {</a>
<a name="ln225">      if (next())</a>
<a name="ln226">            return next();</a>
<a name="ln227">      Measure* m = measure()-&gt;nextMeasure();</a>
<a name="ln228">      return m ? m-&gt;first() : 0;</a>
<a name="ln229">      }</a>
<a name="ln230"> </a>
<a name="ln231">//---------------------------------------------------------</a>
<a name="ln232">//   next1enabled</a>
<a name="ln233">//---------------------------------------------------------</a>
<a name="ln234"> </a>
<a name="ln235">Segment* Segment::next1enabled() const</a>
<a name="ln236">      {</a>
<a name="ln237">      Segment* s = next1();</a>
<a name="ln238">      while (s &amp;&amp; !s-&gt;enabled())</a>
<a name="ln239">            s = s-&gt;next1();</a>
<a name="ln240">      return s;</a>
<a name="ln241">      }</a>
<a name="ln242"> </a>
<a name="ln243">//---------------------------------------------------------</a>
<a name="ln244">//   next1MM</a>
<a name="ln245">//---------------------------------------------------------</a>
<a name="ln246"> </a>
<a name="ln247">Segment* Segment::next1MM() const</a>
<a name="ln248">      {</a>
<a name="ln249">      if (next())</a>
<a name="ln250">            return next();</a>
<a name="ln251">      Measure* m = measure()-&gt;nextMeasureMM();</a>
<a name="ln252">      return m ? m-&gt;first() : 0;</a>
<a name="ln253">      }</a>
<a name="ln254"> </a>
<a name="ln255">Segment* Segment::next1(SegmentType types) const</a>
<a name="ln256">      {</a>
<a name="ln257">      for (Segment* s = next1(); s; s = s-&gt;next1()) {</a>
<a name="ln258">            if (s-&gt;segmentType() &amp; types)</a>
<a name="ln259">                  return s;</a>
<a name="ln260">            }</a>
<a name="ln261">      return 0;</a>
<a name="ln262">      }</a>
<a name="ln263"> </a>
<a name="ln264">Segment* Segment::next1MM(SegmentType types) const</a>
<a name="ln265">      {</a>
<a name="ln266">      for (Segment* s = next1MM(); s; s = s-&gt;next1MM()) {</a>
<a name="ln267">            if (s-&gt;segmentType() &amp; types)</a>
<a name="ln268">                  return s;</a>
<a name="ln269">            }</a>
<a name="ln270">      return 0;</a>
<a name="ln271">      }</a>
<a name="ln272"> </a>
<a name="ln273">Segment* Segment::next1MMenabled() const</a>
<a name="ln274">      {</a>
<a name="ln275">      Segment* s = next1MM();</a>
<a name="ln276">      while (s &amp;&amp; !s-&gt;enabled())</a>
<a name="ln277">            s = s-&gt;next1MM();</a>
<a name="ln278">      return s;</a>
<a name="ln279">      }</a>
<a name="ln280"> </a>
<a name="ln281">//---------------------------------------------------------</a>
<a name="ln282">//   next</a>
<a name="ln283">//    got to next segment which has subtype in types</a>
<a name="ln284">//---------------------------------------------------------</a>
<a name="ln285"> </a>
<a name="ln286">Segment* Segment::next(SegmentType types) const</a>
<a name="ln287">      {</a>
<a name="ln288">      for (Segment* s = next(); s; s = s-&gt;next()) {</a>
<a name="ln289">            if (s-&gt;segmentType() &amp; types)</a>
<a name="ln290">                  return s;</a>
<a name="ln291">            }</a>
<a name="ln292">      return 0;</a>
<a name="ln293">      }</a>
<a name="ln294"> </a>
<a name="ln295">//---------------------------------------------------------</a>
<a name="ln296">//   prev</a>
<a name="ln297">//    got to previous segment which has subtype in types</a>
<a name="ln298">//---------------------------------------------------------</a>
<a name="ln299"> </a>
<a name="ln300">Segment* Segment::prev(SegmentType types) const</a>
<a name="ln301">      {</a>
<a name="ln302">      for (Segment* s = prev(); s; s = s-&gt;prev()) {</a>
<a name="ln303">            if (s-&gt;segmentType() &amp; types)</a>
<a name="ln304">                  return s;</a>
<a name="ln305">            }</a>
<a name="ln306">      return 0;</a>
<a name="ln307">      }</a>
<a name="ln308"> </a>
<a name="ln309">//---------------------------------------------------------</a>
<a name="ln310">//   prev1</a>
<a name="ln311">///   return previous \a Segment, don’t stop searching at</a>
<a name="ln312">///   \a Measure begin</a>
<a name="ln313">//---------------------------------------------------------</a>
<a name="ln314"> </a>
<a name="ln315">Segment* Segment::prev1() const</a>
<a name="ln316">      {</a>
<a name="ln317">      if (prev())</a>
<a name="ln318">            return prev();</a>
<a name="ln319">      Measure* m = measure()-&gt;prevMeasure();</a>
<a name="ln320">      return m ? m-&gt;last() : 0;</a>
<a name="ln321">      }</a>
<a name="ln322"> </a>
<a name="ln323">Segment* Segment::prev1enabled() const</a>
<a name="ln324">      {</a>
<a name="ln325">      Segment* s = prev1();</a>
<a name="ln326">      while (s &amp;&amp; !s-&gt;enabled())</a>
<a name="ln327">            s = s-&gt;prev1();</a>
<a name="ln328">      return s;</a>
<a name="ln329">      }</a>
<a name="ln330"> </a>
<a name="ln331">Segment* Segment::prev1MM() const</a>
<a name="ln332">      {</a>
<a name="ln333">      if (prev())</a>
<a name="ln334">            return prev();</a>
<a name="ln335">      Measure* m = measure()-&gt;prevMeasureMM();</a>
<a name="ln336">      return m ? m-&gt;last() : 0;</a>
<a name="ln337">      }</a>
<a name="ln338"> </a>
<a name="ln339">Segment* Segment::prev1MMenabled() const</a>
<a name="ln340">      {</a>
<a name="ln341">      Segment* s = prev1MM();</a>
<a name="ln342">      while (s &amp;&amp; !s-&gt;enabled())</a>
<a name="ln343">            s = s-&gt;prev1MM();</a>
<a name="ln344">      return s;</a>
<a name="ln345">      }</a>
<a name="ln346"> </a>
<a name="ln347">Segment* Segment::prev1(SegmentType types) const</a>
<a name="ln348">      {</a>
<a name="ln349">      for (Segment* s = prev1(); s; s = s-&gt;prev1()) {</a>
<a name="ln350">            if (s-&gt;segmentType() &amp; types)</a>
<a name="ln351">                  return s;</a>
<a name="ln352">            }</a>
<a name="ln353">      return 0;</a>
<a name="ln354">      }</a>
<a name="ln355"> </a>
<a name="ln356">Segment* Segment::prev1MM(SegmentType types) const</a>
<a name="ln357">      {</a>
<a name="ln358">      for (Segment* s = prev1MM(); s; s = s-&gt;prev1MM()) {</a>
<a name="ln359">            if (s-&gt;segmentType() &amp; types)</a>
<a name="ln360">                  return s;</a>
<a name="ln361">            }</a>
<a name="ln362">      return 0;</a>
<a name="ln363">      }</a>
<a name="ln364"> </a>
<a name="ln365">//---------------------------------------------------------</a>
<a name="ln366">//   nextCR</a>
<a name="ln367">//    get next ChordRest Segment</a>
<a name="ln368">//---------------------------------------------------------</a>
<a name="ln369"> </a>
<a name="ln370">Segment* Segment::nextCR(int track, bool sameStaff) const</a>
<a name="ln371">      {</a>
<a name="ln372">      int strack = track;</a>
<a name="ln373">      int etrack;</a>
<a name="ln374">      if (sameStaff) {</a>
<a name="ln375">            strack &amp;= ~(VOICES-1);</a>
<a name="ln376">            etrack = strack + VOICES;</a>
<a name="ln377">            }</a>
<a name="ln378">      else {</a>
<a name="ln379">            etrack = strack + 1;</a>
<a name="ln380">            }</a>
<a name="ln381">      for (Segment* seg = next1(); seg; seg = seg-&gt;next1()) {</a>
<a name="ln382">            if (seg-&gt;isChordRestType()) {</a>
<a name="ln383">                  if (track == -1)</a>
<a name="ln384">                        return seg;</a>
<a name="ln385">                  for (int t = strack; t &lt; etrack; ++t) {</a>
<a name="ln386">                        if (seg-&gt;element(t))</a>
<a name="ln387">                              return seg;</a>
<a name="ln388">                        }</a>
<a name="ln389">                  }</a>
<a name="ln390">            }</a>
<a name="ln391">      return 0;</a>
<a name="ln392">      }</a>
<a name="ln393"> </a>
<a name="ln394">//---------------------------------------------------------</a>
<a name="ln395">//   nextChordRest</a>
<a name="ln396">//    get the next ChordRest, start at this segment</a>
<a name="ln397">//---------------------------------------------------------</a>
<a name="ln398"> </a>
<a name="ln399">ChordRest* Segment::nextChordRest(int track, bool backwards) const</a>
<a name="ln400">      {</a>
<a name="ln401">      for (const Segment* seg = this; seg; seg = backwards ? seg-&gt;prev1() : seg-&gt;next1()) {</a>
<a name="ln402">            Element* el = seg-&gt;element(track);</a>
<a name="ln403">            if (el &amp;&amp; el-&gt;isChordRest())</a>
<a name="ln404">                  return toChordRest(el);</a>
<a name="ln405">            }</a>
<a name="ln406">      return 0;</a>
<a name="ln407">      }</a>
<a name="ln408"> </a>
<a name="ln409">//---------------------------------------------------------</a>
<a name="ln410">//   insertStaff</a>
<a name="ln411">//---------------------------------------------------------</a>
<a name="ln412"> </a>
<a name="ln413">void Segment::insertStaff(int staff)</a>
<a name="ln414">      {</a>
<a name="ln415">      int track = staff * VOICES;</a>
<a name="ln416">      for (int voice = 0; voice &lt; VOICES; ++voice)</a>
<a name="ln417">            _elist.insert(_elist.begin() + track, 0);</a>
<a name="ln418">      _dotPosX.insert(_dotPosX.begin()+staff, 0.0);</a>
<a name="ln419">      _shapes.insert(_shapes.begin()+staff, Shape());</a>
<a name="ln420"> </a>
<a name="ln421">      for (Element* e : _annotations) {</a>
<a name="ln422">            int staffIdx = e-&gt;staffIdx();</a>
<a name="ln423">            if (staffIdx &gt;= staff &amp;&amp; !e-&gt;systemFlag())</a>
<a name="ln424">                  e-&gt;setTrack(e-&gt;track() + VOICES);</a>
<a name="ln425">            }</a>
<a name="ln426">      fixStaffIdx();</a>
<a name="ln427">      }</a>
<a name="ln428"> </a>
<a name="ln429">//---------------------------------------------------------</a>
<a name="ln430">//   removeStaff</a>
<a name="ln431">//---------------------------------------------------------</a>
<a name="ln432"> </a>
<a name="ln433">void Segment::removeStaff(int staff)</a>
<a name="ln434">      {</a>
<a name="ln435">      int track = staff * VOICES;</a>
<a name="ln436">      _elist.erase(_elist.begin() + track, _elist.begin() + track + VOICES);</a>
<a name="ln437">      _dotPosX.erase(_dotPosX.begin() + staff);</a>
<a name="ln438">      _shapes.erase(_shapes.begin()+staff);</a>
<a name="ln439"> </a>
<a name="ln440">      for (Element* e : _annotations) {</a>
<a name="ln441">            int staffIdx = e-&gt;staffIdx();</a>
<a name="ln442">            if (staffIdx &gt; staff &amp;&amp; !e-&gt;systemFlag())</a>
<a name="ln443">                  e-&gt;setTrack(e-&gt;track() - VOICES);</a>
<a name="ln444">            }</a>
<a name="ln445"> </a>
<a name="ln446">      fixStaffIdx();</a>
<a name="ln447">      }</a>
<a name="ln448"> </a>
<a name="ln449">//---------------------------------------------------------</a>
<a name="ln450">//   checkElement</a>
<a name="ln451">//---------------------------------------------------------</a>
<a name="ln452"> </a>
<a name="ln453">void Segment::checkElement(Element* el, int track)</a>
<a name="ln454">      {</a>
<a name="ln455">      // generated elements can be overwritten</a>
<a name="ln456">      if (_elist[track] &amp;&amp; !_elist[track]-&gt;generated()) {</a>
<a name="ln457">            qDebug(&quot;add(%s): there is already a %s at track %d tick %d&quot;,</a>
<a name="ln458">               el-&gt;name(),</a>
<a name="ln459">               _elist[track]-&gt;name(),</a>
<a name="ln460">               track,</a>
<a name="ln461">               tick().ticks()</a>
<a name="ln462">               );</a>
<a name="ln463">//            abort();</a>
<a name="ln464">            }</a>
<a name="ln465">      }</a>
<a name="ln466"> </a>
<a name="ln467">//---------------------------------------------------------</a>
<a name="ln468">//   add</a>
<a name="ln469">//---------------------------------------------------------</a>
<a name="ln470"> </a>
<a name="ln471">void Segment::add(Element* el)</a>
<a name="ln472">      {</a>
<a name="ln473">//      qDebug(&quot;%p segment %s add(%d, %d, %s)&quot;, this, subTypeName(), tick(), el-&gt;track(), el-&gt;name());</a>
<a name="ln474"> </a>
<a name="ln475">      el-&gt;setParent(this);</a>
<a name="ln476"> </a>
<a name="ln477">      int track = el-&gt;track();</a>
<a name="ln478">      Q_ASSERT(track != -1);</a>
<a name="ln479">      Q_ASSERT(el-&gt;score() == score());</a>
<a name="ln480">      Q_ASSERT(score()-&gt;nstaves() * VOICES == int(_elist.size()));</a>
<a name="ln481">      // make sure offset is correct for staff</a>
<a name="ln482">      if (el-&gt;isStyled(Pid::OFFSET))</a>
<a name="ln483">            el-&gt;setOffset(el-&gt;propertyDefault(Pid::OFFSET).toPointF());</a>
<a name="ln484"> </a>
<a name="ln485">      switch (el-&gt;type()) {</a>
<a name="ln486">            case ElementType::REPEAT_MEASURE:</a>
<a name="ln487">                  _elist[track] = el;</a>
<a name="ln488">                  setEmpty(false);</a>
<a name="ln489">                  break;</a>
<a name="ln490"> </a>
<a name="ln491">            case ElementType::TEMPO_TEXT:</a>
<a name="ln492">            case ElementType::DYNAMIC:</a>
<a name="ln493">            case ElementType::HARMONY:</a>
<a name="ln494">            case ElementType::SYMBOL:</a>
<a name="ln495">            case ElementType::FRET_DIAGRAM:</a>
<a name="ln496">            case ElementType::STAFF_TEXT:</a>
<a name="ln497">            case ElementType::SYSTEM_TEXT:</a>
<a name="ln498">            case ElementType::REHEARSAL_MARK:</a>
<a name="ln499">            case ElementType::MARKER:</a>
<a name="ln500">            case ElementType::IMAGE:</a>
<a name="ln501">            case ElementType::TEXT:</a>
<a name="ln502">            case ElementType::TREMOLOBAR:</a>
<a name="ln503">            case ElementType::TAB_DURATION_SYMBOL:</a>
<a name="ln504">            case ElementType::FIGURED_BASS:</a>
<a name="ln505">            case ElementType::FERMATA:</a>
<a name="ln506">            case ElementType::STICKING:</a>
<a name="ln507">                  _annotations.push_back(el);</a>
<a name="ln508">                  break;</a>
<a name="ln509"> </a>
<a name="ln510">            case ElementType::STAFF_STATE:</a>
<a name="ln511">                  if (toStaffState(el)-&gt;staffStateType() == StaffStateType::INSTRUMENT) {</a>
<a name="ln512">                        StaffState* ss = toStaffState(el);</a>
<a name="ln513">                        Part* part = el-&gt;part();</a>
<a name="ln514">                        part-&gt;setInstrument(ss-&gt;instrument(), tick());</a>
<a name="ln515">                        }</a>
<a name="ln516">                  _annotations.push_back(el);</a>
<a name="ln517">                  break;</a>
<a name="ln518"> </a>
<a name="ln519">            case ElementType::INSTRUMENT_CHANGE: {</a>
<a name="ln520">                  InstrumentChange* is = toInstrumentChange(el);</a>
<a name="ln521">                  Part* part = is-&gt;part();</a>
<a name="ln522">                  part-&gt;setInstrument(is-&gt;instrument(), tick());</a>
<a name="ln523">                  _annotations.push_back(el);</a>
<a name="ln524">                  break;</a>
<a name="ln525">                  }</a>
<a name="ln526"> </a>
<a name="ln527">            case ElementType::CLEF:</a>
<a name="ln528">                  Q_ASSERT(_segmentType == SegmentType::Clef || _segmentType == SegmentType::HeaderClef);</a>
<a name="ln529">                  checkElement(el, track);</a>
<a name="ln530">                  _elist[track] = el;</a>
<a name="ln531">                  if (!el-&gt;generated()) {</a>
<a name="ln532">                        el-&gt;staff()-&gt;setClef(toClef(el));</a>
<a name="ln533">//                        updateNoteLines(this, el-&gt;track());   TODO::necessary?</a>
<a name="ln534">                        }</a>
<a name="ln535">                  setEmpty(false);</a>
<a name="ln536">                  break;</a>
<a name="ln537"> </a>
<a name="ln538">            case ElementType::TIMESIG:</a>
<a name="ln539">                  Q_ASSERT(segmentType() == SegmentType::TimeSig || segmentType() == SegmentType::TimeSigAnnounce);</a>
<a name="ln540">                  checkElement(el, track);</a>
<a name="ln541">                  _elist[track] = el;</a>
<a name="ln542">                  el-&gt;staff()-&gt;addTimeSig(toTimeSig(el));</a>
<a name="ln543">                  setEmpty(false);</a>
<a name="ln544">                  break;</a>
<a name="ln545"> </a>
<a name="ln546">            case ElementType::KEYSIG:</a>
<a name="ln547">                  Q_ASSERT(_segmentType == SegmentType::KeySig || _segmentType == SegmentType::KeySigAnnounce);</a>
<a name="ln548">                  checkElement(el, track);</a>
<a name="ln549">                  _elist[track] = el;</a>
<a name="ln550">                  if (!el-&gt;generated())</a>
<a name="ln551">                        el-&gt;staff()-&gt;setKey(tick(), toKeySig(el)-&gt;keySigEvent());</a>
<a name="ln552">                  setEmpty(false);</a>
<a name="ln553">                  break;</a>
<a name="ln554"> </a>
<a name="ln555">            case ElementType::CHORD:</a>
<a name="ln556">            case ElementType::REST:</a>
<a name="ln557">                  Q_ASSERT(_segmentType == SegmentType::ChordRest);</a>
<a name="ln558">                  {</a>
<a name="ln559">                  if (track % VOICES) {</a>
<a name="ln560">                        bool v;</a>
<a name="ln561">                        if (el-&gt;isChord()) {</a>
<a name="ln562">                              v = false;</a>
<a name="ln563">                              // consider chord visible if any note is visible</a>
<a name="ln564">                              Chord* c = toChord(el);</a>
<a name="ln565">                              for (Note* n : c-&gt;notes()) {</a>
<a name="ln566">                                    if (n-&gt;visible()) {</a>
<a name="ln567">                                          v = true;</a>
<a name="ln568">                                          break;</a>
<a name="ln569">                                          }</a>
<a name="ln570">                                    }</a>
<a name="ln571">                              }</a>
<a name="ln572">                        else</a>
<a name="ln573">                              v = el-&gt;visible();</a>
<a name="ln574"> </a>
<a name="ln575">                        if (v &amp;&amp; measure()-&gt;score()-&gt;ntracks() &gt; track)</a>
<a name="ln576">                              measure()-&gt;setHasVoices(track / VOICES, true);</a>
<a name="ln577">                        }</a>
<a name="ln578">                  // the tick position of a tuplet is the tick position of its</a>
<a name="ln579">                  // first element:</a>
<a name="ln580">//                  ChordRest* cr = toChordRest(el);</a>
<a name="ln581">//                  if (cr-&gt;tuplet() &amp;&amp; !cr-&gt;tuplet()-&gt;elements().empty() &amp;&amp; cr-&gt;tuplet()-&gt;elements().front() == cr &amp;&amp; cr-&gt;tuplet()-&gt;tick() &lt; 0)</a>
<a name="ln582">//                        cr-&gt;tuplet()-&gt;setTick(cr-&gt;tick());</a>
<a name="ln583">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln584">                  }</a>
<a name="ln585">                  // fall through</a>
<a name="ln586"> </a>
<a name="ln587">            case ElementType::BAR_LINE:</a>
<a name="ln588">            case ElementType::BREATH:</a>
<a name="ln589">                  if (track &lt; score()-&gt;nstaves() * VOICES) {</a>
<a name="ln590">                        checkElement(el, track);</a>
<a name="ln591">                        _elist[track] = el;</a>
<a name="ln592">                        }</a>
<a name="ln593">                  setEmpty(false);</a>
<a name="ln594">                  break;</a>
<a name="ln595"> </a>
<a name="ln596">            case ElementType::AMBITUS:</a>
<a name="ln597">                  Q_ASSERT(_segmentType == SegmentType::Ambitus);</a>
<a name="ln598">                  checkElement(el, track);</a>
<a name="ln599">                  _elist[track] = el;</a>
<a name="ln600">                  setEmpty(false);</a>
<a name="ln601">                  break;</a>
<a name="ln602"> </a>
<a name="ln603">            default:</a>
<a name="ln604">                  qFatal(&quot;Segment::add() unknown %s&quot;, el-&gt;name());</a>
<a name="ln605">            }</a>
<a name="ln606">      }</a>
<a name="ln607"> </a>
<a name="ln608">//---------------------------------------------------------</a>
<a name="ln609">//   remove</a>
<a name="ln610">//---------------------------------------------------------</a>
<a name="ln611"> </a>
<a name="ln612">void Segment::remove(Element* el)</a>
<a name="ln613">      {</a>
<a name="ln614">// qDebug(&quot;%p Segment::remove %s %p&quot;, this, el-&gt;name(), el);</a>
<a name="ln615"> </a>
<a name="ln616">      int track = el-&gt;track();</a>
<a name="ln617"> </a>
<a name="ln618">      switch(el-&gt;type()) {</a>
<a name="ln619">            case ElementType::CHORD:</a>
<a name="ln620">            case ElementType::REST:</a>
<a name="ln621">                  {</a>
<a name="ln622">                  _elist[track] = 0;</a>
<a name="ln623">                  int staffIdx = el-&gt;staffIdx();</a>
<a name="ln624">                  measure()-&gt;checkMultiVoices(staffIdx);</a>
<a name="ln625">                  // spanners with this cr as start or end element will need relayout</a>
<a name="ln626">                  SpannerMap&amp; smap = score()-&gt;spannerMap();</a>
<a name="ln627">                  auto spanners = smap.findOverlapping(tick().ticks(), tick().ticks());</a>
<a name="ln628">                  for (auto interval : spanners) {</a>
<a name="ln629">                        Spanner* s = interval.value;</a>
<a name="ln630">                        Element* start = s-&gt;startElement();</a>
<a name="ln631">                        Element* end = s-&gt;endElement();</a>
<a name="ln632">                        if (s-&gt;startElement() == el)</a>
<a name="ln633">                              start = nullptr;</a>
<a name="ln634">                        if (s-&gt;endElement() == el)</a>
<a name="ln635">                              end = nullptr;</a>
<a name="ln636">                        if (start != s-&gt;startElement() || end != s-&gt;endElement())</a>
<a name="ln637">                              score()-&gt;undo(new ChangeStartEndSpanner(s, start, end));</a>
<a name="ln638">                        }</a>
<a name="ln639">                  score()-&gt;setPlaylistDirty();</a>
<a name="ln640">                  }</a>
<a name="ln641">                  break;</a>
<a name="ln642"> </a>
<a name="ln643">            case ElementType::REPEAT_MEASURE:</a>
<a name="ln644">                  _elist[track] = 0;</a>
<a name="ln645">                  break;</a>
<a name="ln646"> </a>
<a name="ln647">            case ElementType::DYNAMIC:</a>
<a name="ln648">            case ElementType::FIGURED_BASS:</a>
<a name="ln649">            case ElementType::FRET_DIAGRAM:</a>
<a name="ln650">            case ElementType::HARMONY:</a>
<a name="ln651">            case ElementType::IMAGE:</a>
<a name="ln652">            case ElementType::MARKER:</a>
<a name="ln653">            case ElementType::REHEARSAL_MARK:</a>
<a name="ln654">            case ElementType::STAFF_TEXT:</a>
<a name="ln655">            case ElementType::SYSTEM_TEXT:</a>
<a name="ln656">            case ElementType::SYMBOL:</a>
<a name="ln657">            case ElementType::TAB_DURATION_SYMBOL:</a>
<a name="ln658">            case ElementType::TEMPO_TEXT:</a>
<a name="ln659">            case ElementType::TEXT:</a>
<a name="ln660">            case ElementType::TREMOLOBAR:</a>
<a name="ln661">            case ElementType::FERMATA:</a>
<a name="ln662">            case ElementType::STICKING:</a>
<a name="ln663">                  removeAnnotation(el);</a>
<a name="ln664">                  break;</a>
<a name="ln665"> </a>
<a name="ln666">            case ElementType::STAFF_STATE:</a>
<a name="ln667">                  if (toStaffState(el)-&gt;staffStateType() == StaffStateType::INSTRUMENT) {</a>
<a name="ln668">                        Part* part = el-&gt;part();</a>
<a name="ln669">                        part-&gt;removeInstrument(tick());</a>
<a name="ln670">                        }</a>
<a name="ln671">                  removeAnnotation(el);</a>
<a name="ln672">                  break;</a>
<a name="ln673"> </a>
<a name="ln674">            case ElementType::INSTRUMENT_CHANGE:</a>
<a name="ln675">                  {</a>
<a name="ln676">                  InstrumentChange* is = toInstrumentChange(el);</a>
<a name="ln677">                  Part* part = is-&gt;part();</a>
<a name="ln678">                  part-&gt;removeInstrument(tick());</a>
<a name="ln679">                  }</a>
<a name="ln680">                  removeAnnotation(el);</a>
<a name="ln681">                  break;</a>
<a name="ln682"> </a>
<a name="ln683">            case ElementType::TIMESIG:</a>
<a name="ln684">                  _elist[track] = 0;</a>
<a name="ln685">                  el-&gt;staff()-&gt;removeTimeSig(toTimeSig(el));</a>
<a name="ln686">                  break;</a>
<a name="ln687"> </a>
<a name="ln688">            case ElementType::KEYSIG:</a>
<a name="ln689">                  Q_ASSERT(_elist[track] == el);</a>
<a name="ln690"> </a>
<a name="ln691">                  _elist[track] = 0;</a>
<a name="ln692">                  if (!el-&gt;generated())</a>
<a name="ln693">                        el-&gt;staff()-&gt;removeKey(tick());</a>
<a name="ln694">                  break;</a>
<a name="ln695"> </a>
<a name="ln696">            case ElementType::CLEF:</a>
<a name="ln697">                  el-&gt;staff()-&gt;removeClef(toClef(el));</a>
<a name="ln698">                  // updateNoteLines(this, el-&gt;track());</a>
<a name="ln699">                  // fall through</a>
<a name="ln700"> </a>
<a name="ln701">            case ElementType::BAR_LINE:</a>
<a name="ln702">            case ElementType::AMBITUS:</a>
<a name="ln703">                  _elist[track] = 0;</a>
<a name="ln704">                  break;</a>
<a name="ln705"> </a>
<a name="ln706">            case ElementType::BREATH:</a>
<a name="ln707">                  _elist[track] = 0;</a>
<a name="ln708">                  score()-&gt;setPause(tick(), 0);</a>
<a name="ln709">                  break;</a>
<a name="ln710"> </a>
<a name="ln711">            default:</a>
<a name="ln712">                  qFatal(&quot;Segment::remove() unknown %s&quot;, el-&gt;name());</a>
<a name="ln713"> </a>
<a name="ln714">            }</a>
<a name="ln715">      triggerLayout();</a>
<a name="ln716">      checkEmpty();</a>
<a name="ln717">      }</a>
<a name="ln718"> </a>
<a name="ln719">//---------------------------------------------------------</a>
<a name="ln720">//   segmentType</a>
<a name="ln721">//    returns segment type suitable for storage of Element</a>
<a name="ln722">//---------------------------------------------------------</a>
<a name="ln723"> </a>
<a name="ln724">SegmentType Segment::segmentType(ElementType type)</a>
<a name="ln725">      {</a>
<a name="ln726">      switch (type) {</a>
<a name="ln727">            case ElementType::CHORD:</a>
<a name="ln728">            case ElementType::REST:</a>
<a name="ln729">            case ElementType::REPEAT_MEASURE:</a>
<a name="ln730">            case ElementType::JUMP:</a>
<a name="ln731">            case ElementType::MARKER:</a>
<a name="ln732">                  return SegmentType::ChordRest;</a>
<a name="ln733">            case ElementType::CLEF:</a>
<a name="ln734">                  return SegmentType::Clef;</a>
<a name="ln735">            case ElementType::KEYSIG:</a>
<a name="ln736">                  return SegmentType::KeySig;</a>
<a name="ln737">            case ElementType::TIMESIG:</a>
<a name="ln738">                  return SegmentType::TimeSig;</a>
<a name="ln739">            case ElementType::BAR_LINE:</a>
<a name="ln740">                  return SegmentType::StartRepeatBarLine;</a>
<a name="ln741">            case ElementType::BREATH:</a>
<a name="ln742">                  return SegmentType::Breath;</a>
<a name="ln743">            default:</a>
<a name="ln744">                  qDebug(&quot;Segment:segmentType():  bad type: &lt;%s&gt;&quot;, Element::name(type));</a>
<a name="ln745">                  return SegmentType::Invalid;</a>
<a name="ln746">            }</a>
<a name="ln747">      }</a>
<a name="ln748"> </a>
<a name="ln749">//---------------------------------------------------------</a>
<a name="ln750">//   sortStaves</a>
<a name="ln751">//---------------------------------------------------------</a>
<a name="ln752"> </a>
<a name="ln753">void Segment::sortStaves(QList&lt;int&gt;&amp; dst)</a>
<a name="ln754">      {</a>
<a name="ln755">      std::vector&lt;Element*&gt; dl;</a>
<a name="ln756">      dl.reserve(dst.size());</a>
<a name="ln757"> </a>
<a name="ln758">      for (int i = 0; i &lt; dst.size(); ++i) {</a>
<a name="ln759">            int startTrack = dst[i] * VOICES;</a>
<a name="ln760">            int endTrack   = startTrack + VOICES;</a>
<a name="ln761">            for (int k = startTrack; k &lt; endTrack; ++k)</a>
<a name="ln762">                  dl.push_back(_elist[k]);</a>
<a name="ln763">            }</a>
<a name="ln764">      std::swap(_elist, dl);</a>
<a name="ln765">      QMap&lt;int, int&gt; map;</a>
<a name="ln766">      for (int k = 0; k &lt; dst.size(); ++k) {</a>
<a name="ln767">            map.insert(dst[k], k);</a>
<a name="ln768">            }</a>
<a name="ln769">      for (Element* e : _annotations) {</a>
<a name="ln770">            if (!e-&gt;systemFlag())</a>
<a name="ln771">                  e-&gt;setTrack(map[e-&gt;staffIdx()] * VOICES + e-&gt;voice());</a>
<a name="ln772">            }</a>
<a name="ln773">      fixStaffIdx();</a>
<a name="ln774">      }</a>
<a name="ln775"> </a>
<a name="ln776">//---------------------------------------------------------</a>
<a name="ln777">//   fixStaffIdx</a>
<a name="ln778">//---------------------------------------------------------</a>
<a name="ln779"> </a>
<a name="ln780">void Segment::fixStaffIdx()</a>
<a name="ln781">      {</a>
<a name="ln782">      int track = 0;</a>
<a name="ln783">      for (Element* e : _elist) {</a>
<a name="ln784">            if (e)</a>
<a name="ln785">                  e-&gt;setTrack(track);</a>
<a name="ln786">            ++track;</a>
<a name="ln787">            }</a>
<a name="ln788">      }</a>
<a name="ln789"> </a>
<a name="ln790">//---------------------------------------------------------</a>
<a name="ln791">//   checkEmpty</a>
<a name="ln792">//---------------------------------------------------------</a>
<a name="ln793"> </a>
<a name="ln794">void Segment::checkEmpty() const</a>
<a name="ln795">      {</a>
<a name="ln796">      if (!_annotations.empty()) {</a>
<a name="ln797">            setEmpty(false);</a>
<a name="ln798">            return;</a>
<a name="ln799">            }</a>
<a name="ln800">      setEmpty(true);</a>
<a name="ln801">      for (const Element* e : _elist) {</a>
<a name="ln802">            if (e) {</a>
<a name="ln803">                  setEmpty(false);</a>
<a name="ln804">                  break;</a>
<a name="ln805">                  }</a>
<a name="ln806">            }</a>
<a name="ln807">      }</a>
<a name="ln808"> </a>
<a name="ln809">//---------------------------------------------------------</a>
<a name="ln810">//   swapElements</a>
<a name="ln811">//---------------------------------------------------------</a>
<a name="ln812"> </a>
<a name="ln813">void Segment::swapElements(int i1, int i2)</a>
<a name="ln814">      {</a>
<a name="ln815">      std::iter_swap(_elist.begin() + i1, _elist.begin() + i2);</a>
<a name="ln816">      if (_elist[i1])</a>
<a name="ln817">            _elist[i1]-&gt;setTrack(i1);</a>
<a name="ln818">      if (_elist[i2])</a>
<a name="ln819">            _elist[i2]-&gt;setTrack(i2);</a>
<a name="ln820">      triggerLayout();</a>
<a name="ln821">      }</a>
<a name="ln822"> </a>
<a name="ln823">//---------------------------------------------------------</a>
<a name="ln824">//   write</a>
<a name="ln825">//---------------------------------------------------------</a>
<a name="ln826"> </a>
<a name="ln827">void Segment::write(XmlWriter&amp; xml) const</a>
<a name="ln828">      {</a>
<a name="ln829">      if (written())</a>
<a name="ln830">            return;</a>
<a name="ln831">      setWritten(true);</a>
<a name="ln832">      if (_extraLeadingSpace.isZero())</a>
<a name="ln833">            return;</a>
<a name="ln834">      xml.stag(this);</a>
<a name="ln835">      xml.tag(&quot;leadingSpace&quot;, _extraLeadingSpace.val());</a>
<a name="ln836">      xml.etag();</a>
<a name="ln837">      }</a>
<a name="ln838"> </a>
<a name="ln839">//---------------------------------------------------------</a>
<a name="ln840">//   read</a>
<a name="ln841">//---------------------------------------------------------</a>
<a name="ln842"> </a>
<a name="ln843">void Segment::read(XmlReader&amp; e)</a>
<a name="ln844">      {</a>
<a name="ln845">      while (e.readNextStartElement()) {</a>
<a name="ln846">            const QStringRef&amp; tag(e.name());</a>
<a name="ln847"> </a>
<a name="ln848">            if (tag == &quot;subtype&quot;)</a>
<a name="ln849">                  e.skipCurrentElement();</a>
<a name="ln850">            else if (tag == &quot;leadingSpace&quot;)</a>
<a name="ln851">                  _extraLeadingSpace = Spatium(e.readDouble());</a>
<a name="ln852">            else if (tag == &quot;trailingSpace&quot;)          // obsolete</a>
<a name="ln853">                  e.readDouble();</a>
<a name="ln854">            else</a>
<a name="ln855">                  e.unknown();</a>
<a name="ln856">            }</a>
<a name="ln857">      }</a>
<a name="ln858"> </a>
<a name="ln859">//---------------------------------------------------------</a>
<a name="ln860">//   getProperty</a>
<a name="ln861">//---------------------------------------------------------</a>
<a name="ln862"> </a>
<a name="ln863">QVariant Segment::getProperty(Pid propertyId) const</a>
<a name="ln864">      {</a>
<a name="ln865">      switch (propertyId) {</a>
<a name="ln866">            case Pid::TICK:</a>
<a name="ln867">                  return _tick;</a>
<a name="ln868">            case Pid::LEADING_SPACE:</a>
<a name="ln869">                  return extraLeadingSpace();</a>
<a name="ln870">            default:</a>
<a name="ln871">                  return Element::getProperty(propertyId);</a>
<a name="ln872">            }</a>
<a name="ln873">      }</a>
<a name="ln874"> </a>
<a name="ln875">//---------------------------------------------------------</a>
<a name="ln876">//   propertyDefault</a>
<a name="ln877">//---------------------------------------------------------</a>
<a name="ln878"> </a>
<a name="ln879">QVariant Segment::propertyDefault(Pid propertyId) const</a>
<a name="ln880">      {</a>
<a name="ln881">      switch (propertyId) {</a>
<a name="ln882">            case Pid::LEADING_SPACE:</a>
<a name="ln883">                  return Spatium(0.0);</a>
<a name="ln884">            default:</a>
<a name="ln885">                  return Element::getProperty(propertyId);</a>
<a name="ln886">            }</a>
<a name="ln887">      }</a>
<a name="ln888"> </a>
<a name="ln889">//---------------------------------------------------------</a>
<a name="ln890">//   setProperty</a>
<a name="ln891">//---------------------------------------------------------</a>
<a name="ln892"> </a>
<a name="ln893">bool Segment::setProperty(Pid propertyId, const QVariant&amp; v)</a>
<a name="ln894">      {</a>
<a name="ln895">      switch (propertyId) {</a>
<a name="ln896">            case Pid::TICK:</a>
<a name="ln897">                  setRtick(v.value&lt;Fraction&gt;());</a>
<a name="ln898">                  break;</a>
<a name="ln899">            case Pid::LEADING_SPACE:</a>
<a name="ln900">                  setExtraLeadingSpace(v.value&lt;Spatium&gt;());</a>
<a name="ln901">                  for (Element* e : _elist) {</a>
<a name="ln902">                        if(e) </a>
<a name="ln903">                              e-&gt;setGenerated(false);</a>
<a name="ln904">                        }</a>
<a name="ln905">                  break;</a>
<a name="ln906">            default:</a>
<a name="ln907">                  return Element::setProperty(propertyId, v);</a>
<a name="ln908">            }</a>
<a name="ln909">      triggerLayout();</a>
<a name="ln910">      return true;</a>
<a name="ln911">      }</a>
<a name="ln912"> </a>
<a name="ln913">//---------------------------------------------------------</a>
<a name="ln914">//   splitsTuplet</a>
<a name="ln915">//---------------------------------------------------------</a>
<a name="ln916"> </a>
<a name="ln917">bool Segment::splitsTuplet() const</a>
<a name="ln918">      {</a>
<a name="ln919">      for (Element* e : _elist) {</a>
<a name="ln920">            if (!(e &amp;&amp; e-&gt;isChordRest()))</a>
<a name="ln921">                  continue;</a>
<a name="ln922">            ChordRest* cr = toChordRest(e);</a>
<a name="ln923">            Tuplet* t = cr-&gt;tuplet();</a>
<a name="ln924">            while (t) {</a>
<a name="ln925">                  if (cr != t-&gt;elements().front())</a>
<a name="ln926">                        return true;</a>
<a name="ln927">                  t = t-&gt;tuplet();</a>
<a name="ln928">                  }</a>
<a name="ln929">            }</a>
<a name="ln930">      return false;</a>
<a name="ln931">      }</a>
<a name="ln932"> </a>
<a name="ln933">//---------------------------------------------------------</a>
<a name="ln934">//   operator&lt;</a>
<a name="ln935">///   return true if segment is before s in list</a>
<a name="ln936">//---------------------------------------------------------</a>
<a name="ln937"> </a>
<a name="ln938">bool Segment::operator&lt;(const Segment&amp; s) const</a>
<a name="ln939">      {</a>
<a name="ln940">      if (tick() &lt; s.tick())</a>
<a name="ln941">            return true;</a>
<a name="ln942">      if (tick() &gt; s.tick())</a>
<a name="ln943">            return false;</a>
<a name="ln944">      for (Segment* ns = next1(); ns &amp;&amp; (ns-&gt;tick() == s.tick()); ns = ns-&gt;next1()) {</a>
<a name="ln945">            if (ns == &amp;s)</a>
<a name="ln946">                  return true;</a>
<a name="ln947">            }</a>
<a name="ln948">      return false;</a>
<a name="ln949">      }</a>
<a name="ln950"> </a>
<a name="ln951">//---------------------------------------------------------</a>
<a name="ln952">//   operator&gt;</a>
<a name="ln953">///   return true if segment is after s in list</a>
<a name="ln954">//---------------------------------------------------------</a>
<a name="ln955"> </a>
<a name="ln956">bool Segment::operator&gt;(const Segment&amp; s) const</a>
<a name="ln957">      {</a>
<a name="ln958">      if (tick() &gt; s.tick())</a>
<a name="ln959">            return true;</a>
<a name="ln960">      if (tick() &lt; s.tick())</a>
<a name="ln961">            return false;</a>
<a name="ln962">      for (Segment* ns = prev1(); ns &amp;&amp; (ns-&gt;tick() == s.tick()); ns = ns-&gt;prev1()) {</a>
<a name="ln963">            if (ns == &amp;s)</a>
<a name="ln964">                  return true;</a>
<a name="ln965">            }</a>
<a name="ln966">      return false;</a>
<a name="ln967">      }</a>
<a name="ln968"> </a>
<a name="ln969">//---------------------------------------------------------</a>
<a name="ln970">//   hasElements</a>
<a name="ln971">///  Returns true if the segment has at least one element.</a>
<a name="ln972">///  Annotations are not considered.</a>
<a name="ln973">//---------------------------------------------------------</a>
<a name="ln974"> </a>
<a name="ln975">bool Segment::hasElements() const</a>
<a name="ln976">      {</a>
<a name="ln977">      for (const Element* e : _elist) {</a>
<a name="ln978">            if (e)</a>
<a name="ln979">                  return true;</a>
<a name="ln980">            }</a>
<a name="ln981">      return false;</a>
<a name="ln982">      }</a>
<a name="ln983"> </a>
<a name="ln984">//---------------------------------------------------------</a>
<a name="ln985">//   hasAnnotationOrElement</a>
<a name="ln986">///  return true if an annotation of type type or and element is found in the track range</a>
<a name="ln987">//---------------------------------------------------------</a>
<a name="ln988"> </a>
<a name="ln989">bool Segment::hasAnnotationOrElement(ElementType type, int minTrack, int maxTrack) const</a>
<a name="ln990">      {</a>
<a name="ln991">      for (const Element* e : _annotations)</a>
<a name="ln992">            if (e-&gt;type() == type &amp;&amp; e-&gt;track() &gt;= minTrack &amp;&amp; e-&gt;track() &lt;= maxTrack)</a>
<a name="ln993">                  return true;</a>
<a name="ln994">      for (int curTrack = minTrack; curTrack &lt;= maxTrack; curTrack++)</a>
<a name="ln995">            if (element(curTrack))</a>
<a name="ln996">                  return true;</a>
<a name="ln997">      return false;</a>
<a name="ln998">      }</a>
<a name="ln999"> </a>
<a name="ln1000">//---------------------------------------------------------</a>
<a name="ln1001">//   findAnnotation</a>
<a name="ln1002">///  Returns the first found annotation of type type</a>
<a name="ln1003">///  or nullptr if nothing was found.</a>
<a name="ln1004">//---------------------------------------------------------</a>
<a name="ln1005"> </a>
<a name="ln1006">Element* Segment::findAnnotation(ElementType type, int minTrack, int maxTrack)</a>
<a name="ln1007">      {</a>
<a name="ln1008">      for (Element* e : _annotations)</a>
<a name="ln1009">            if (e-&gt;type() == type &amp;&amp; e-&gt;track() &gt;= minTrack &amp;&amp; e-&gt;track() &lt;= maxTrack)</a>
<a name="ln1010">                  return e;</a>
<a name="ln1011">      return nullptr;</a>
<a name="ln1012">      }</a>
<a name="ln1013"> </a>
<a name="ln1014">//---------------------------------------------------------</a>
<a name="ln1015">//   findAnnotations</a>
<a name="ln1016">///  Returns the list of found annotations</a>
<a name="ln1017">///  or nullptr if nothing was found.</a>
<a name="ln1018">//---------------------------------------------------------</a>
<a name="ln1019"> </a>
<a name="ln1020">std::vector&lt;Element*&gt; Segment::findAnnotations(ElementType type, int minTrack, int maxTrack)</a>
<a name="ln1021">      {</a>
<a name="ln1022">      std::vector&lt;Element*&gt; found;</a>
<a name="ln1023">      for (Element* e : _annotations)</a>
<a name="ln1024">            if (e-&gt;type() == type &amp;&amp; e-&gt;track() &gt;= minTrack &amp;&amp; e-&gt;track() &lt;= maxTrack)</a>
<a name="ln1025">                  found.push_back(e);</a>
<a name="ln1026">      return found;</a>
<a name="ln1027">      }</a>
<a name="ln1028"> </a>
<a name="ln1029">//---------------------------------------------------------</a>
<a name="ln1030">//   removeAnnotation</a>
<a name="ln1031">//---------------------------------------------------------</a>
<a name="ln1032"> </a>
<a name="ln1033">void Segment::removeAnnotation(Element* e)</a>
<a name="ln1034">      {</a>
<a name="ln1035">      for (auto i = _annotations.begin(); i != _annotations.end(); ++i) {</a>
<a name="ln1036">            if (*i == e) {</a>
<a name="ln1037">                  _annotations.erase(i);</a>
<a name="ln1038">                  break;</a>
<a name="ln1039">                  }</a>
<a name="ln1040">            }</a>
<a name="ln1041">      }</a>
<a name="ln1042"> </a>
<a name="ln1043">//---------------------------------------------------------</a>
<a name="ln1044">//   clearAnnotations</a>
<a name="ln1045">//---------------------------------------------------------</a>
<a name="ln1046"> </a>
<a name="ln1047">void Segment::clearAnnotations()</a>
<a name="ln1048">      {</a>
<a name="ln1049">      _annotations.clear();</a>
<a name="ln1050">      }</a>
<a name="ln1051"> </a>
<a name="ln1052">//---------------------------------------------------------</a>
<a name="ln1053">//   elementAt</a>
<a name="ln1054">//    A variant of the element(int) function,</a>
<a name="ln1055">//    specifically intended to be called from QML plugins</a>
<a name="ln1056">//---------------------------------------------------------</a>
<a name="ln1057"> </a>
<a name="ln1058">Ms::Element* Segment::elementAt(int track) const</a>
<a name="ln1059">      {</a>
<a name="ln1060">      Element* e = track &lt; int(_elist.size()) ? _elist[track] : 0;</a>
<a name="ln1061">      return e;</a>
<a name="ln1062">      }</a>
<a name="ln1063"> </a>
<a name="ln1064">//---------------------------------------------------------</a>
<a name="ln1065">//   scanElements</a>
<a name="ln1066">//---------------------------------------------------------</a>
<a name="ln1067"> </a>
<a name="ln1068">void Segment::scanElements(void* data, void (*func)(void*, Element*), bool all)</a>
<a name="ln1069">      {</a>
<a name="ln1070">      for (int track = 0; track &lt; score()-&gt;nstaves() * VOICES; ++track) {</a>
<a name="ln1071">            int staffIdx = track/VOICES;</a>
<a name="ln1072">            if (!all &amp;&amp; !(measure()-&gt;visible(staffIdx) &amp;&amp; score()-&gt;staff(staffIdx)-&gt;show())) {</a>
<a name="ln1073">                  track += VOICES - 1;</a>
<a name="ln1074">                  continue;</a>
<a name="ln1075">                  }</a>
<a name="ln1076">            Element* e = element(track);</a>
<a name="ln1077">            if (e == 0)</a>
<a name="ln1078">                  continue;</a>
<a name="ln1079">            e-&gt;scanElements(data, func, all);</a>
<a name="ln1080">            }</a>
<a name="ln1081">      for (Element* e : annotations()) {</a>
<a name="ln1082">            if (all || e-&gt;systemFlag() || measure()-&gt;visible(e-&gt;staffIdx()))</a>
<a name="ln1083">                  e-&gt;scanElements(data,  func, all);</a>
<a name="ln1084">            }</a>
<a name="ln1085">      }</a>
<a name="ln1086"> </a>
<a name="ln1087">//---------------------------------------------------------</a>
<a name="ln1088">//   firstElement</a>
<a name="ln1089">//   This function returns the first main element from a</a>
<a name="ln1090">//   segment, or a barline if it spanns in the staff</a>
<a name="ln1091">//---------------------------------------------------------</a>
<a name="ln1092"> </a>
<a name="ln1093">Element* Segment::firstElement(int staff)</a>
<a name="ln1094">      {</a>
<a name="ln1095">      if (isChordRestType()) {</a>
<a name="ln1096">            int strack = staff * VOICES;</a>
<a name="ln1097">            int etrack = strack + VOICES;</a>
<a name="ln1098">            for (int v = strack; v &lt; etrack; ++v) {</a>
<a name="ln1099">                  Element* el = element(v);</a>
<a name="ln1100">                  if (!el)</a>
<a name="ln1101">                        continue;</a>
<a name="ln1102">                  return el-&gt;isChord() ? toChord(el)-&gt;notes().back() : el;</a>
<a name="ln1103">                  }</a>
<a name="ln1104">            }</a>
<a name="ln1105">      else</a>
<a name="ln1106">            return getElement(staff);</a>
<a name="ln1107">      return 0;</a>
<a name="ln1108">      }</a>
<a name="ln1109"> </a>
<a name="ln1110">//---------------------------------------------------------</a>
<a name="ln1111">//   lastElement</a>
<a name="ln1112">//   This function returns the last main element from a</a>
<a name="ln1113">//   segment, or a barline if it spanns in the staff</a>
<a name="ln1114">//---------------------------------------------------------</a>
<a name="ln1115"> </a>
<a name="ln1116">Element* Segment::lastElement(int staff)</a>
<a name="ln1117">      {</a>
<a name="ln1118">      if (segmentType() == SegmentType::ChordRest) {</a>
<a name="ln1119">            for (int voice = staff * VOICES + (VOICES - 1); voice/VOICES == staff; voice--) {</a>
<a name="ln1120">                  Element* el = element(voice);</a>
<a name="ln1121">                  if (!el) {      //there is no chord or rest on this voice</a>
<a name="ln1122">                        continue;</a>
<a name="ln1123">                        }</a>
<a name="ln1124">                  if (el-&gt;isChord()) {</a>
<a name="ln1125">                        return toChord(el)-&gt;notes().front();</a>
<a name="ln1126">                        }</a>
<a name="ln1127">                  else {</a>
<a name="ln1128">                        return el;</a>
<a name="ln1129">                        }</a>
<a name="ln1130">                 }</a>
<a name="ln1131">            }</a>
<a name="ln1132">      else {</a>
<a name="ln1133">            return getElement(staff);</a>
<a name="ln1134">            }</a>
<a name="ln1135"> </a>
<a name="ln1136">      return 0;</a>
<a name="ln1137">      }</a>
<a name="ln1138"> </a>
<a name="ln1139">//---------------------------------------------------------</a>
<a name="ln1140">//   getElement</a>
<a name="ln1141">//   protected because it is used by the firstElement and</a>
<a name="ln1142">//   lastElement functions when segment types that have</a>
<a name="ln1143">//   just one element to avoid duplicated code</a>
<a name="ln1144">//</a>
<a name="ln1145">//   Use firstElement, or lastElement instead of this</a>
<a name="ln1146">//---------------------------------------------------------</a>
<a name="ln1147"> </a>
<a name="ln1148">Element* Segment::getElement(int staff)</a>
<a name="ln1149">      {</a>
<a name="ln1150">      segmentType();</a>
<a name="ln1151">      if (segmentType() == SegmentType::ChordRest) {</a>
<a name="ln1152">            return firstElement(staff);</a>
<a name="ln1153">      }</a>
<a name="ln1154">      else if (segmentType() &amp; (SegmentType::EndBarLine | SegmentType::BarLine | SegmentType::StartRepeatBarLine)) {</a>
<a name="ln1155">            for (int i = staff; i &gt;= 0; i--) {</a>
<a name="ln1156">                  if (!element(i * VOICES))</a>
<a name="ln1157">                        continue;</a>
<a name="ln1158">                  BarLine* b = toBarLine(element(i*VOICES));</a>
<a name="ln1159">                  if (i + b-&gt;spanStaff() &gt;= staff)</a>
<a name="ln1160">                        return element(i*VOICES);</a>
<a name="ln1161">                  }</a>
<a name="ln1162">            }</a>
<a name="ln1163">      else</a>
<a name="ln1164">            return element(staff * VOICES);</a>
<a name="ln1165">      return 0;</a>
<a name="ln1166">      }</a>
<a name="ln1167"> </a>
<a name="ln1168">//---------------------------------------------------------</a>
<a name="ln1169">//   nextAnnotation</a>
<a name="ln1170">//   return next element in _annotations</a>
<a name="ln1171">//---------------------------------------------------------</a>
<a name="ln1172"> </a>
<a name="ln1173">Element* Segment::nextAnnotation(Element* e)</a>
<a name="ln1174">      {</a>
<a name="ln1175">      if (_annotations.empty() || e == _annotations.back())</a>
<a name="ln1176">            return nullptr;</a>
<a name="ln1177">      auto ei = std::find(_annotations.begin(), _annotations.end(), e);</a>
<a name="ln1178">      if (ei == _annotations.end())</a>
<a name="ln1179">            return nullptr;               // element not found</a>
<a name="ln1180"> </a>
<a name="ln1181">      // TODO: firstVisibleStaff() for system elements? see Spanner::nextSpanner()</a>
<a name="ln1182">      auto resIt = std::find_if(ei + 1, _annotations.end(), [e](Element* nextElem){</a>
<a name="ln1183">            return nextElem &amp;&amp; nextElem-&gt;staffIdx() == e-&gt;staffIdx();</a>
<a name="ln1184">            });</a>
<a name="ln1185">      </a>
<a name="ln1186">      return _annotations.end() == resIt ? nullptr : *resIt;</a>
<a name="ln1187">      }</a>
<a name="ln1188"> </a>
<a name="ln1189">//---------------------------------------------------------</a>
<a name="ln1190">//   prevAnnotation</a>
<a name="ln1191">//   return previous element in _annotations</a>
<a name="ln1192">//---------------------------------------------------------</a>
<a name="ln1193"> </a>
<a name="ln1194">Element* Segment::prevAnnotation(Element* e)</a>
<a name="ln1195">      {</a>
<a name="ln1196">      if (e == _annotations.front())</a>
<a name="ln1197">          return nullptr;</a>
<a name="ln1198">      auto reverseIt = std::find(_annotations.rbegin(), _annotations.rend(), e);</a>
<a name="ln1199">      if (reverseIt == _annotations.rend())</a>
<a name="ln1200">            return nullptr;               // element not found</a>
<a name="ln1201"> </a>
<a name="ln1202">      // TODO: firstVisibleStaff() for system elements? see Spanner::nextSpanner()</a>
<a name="ln1203">      auto resIt = std::find_if(reverseIt + 1, _annotations.rend(), [e](Element* prevElem){</a>
<a name="ln1204">            return prevElem &amp;&amp; prevElem-&gt;staffIdx() == e-&gt;staffIdx();</a>
<a name="ln1205">            });</a>
<a name="ln1206">      </a>
<a name="ln1207">      return _annotations.rend() == resIt ? nullptr : *resIt;</a>
<a name="ln1208">      }</a>
<a name="ln1209"> </a>
<a name="ln1210">//---------------------------------------------------------</a>
<a name="ln1211">//   firstAnnotation</a>
<a name="ln1212">//---------------------------------------------------------</a>
<a name="ln1213"> </a>
<a name="ln1214">Element* Segment::firstAnnotation(Segment* s, int activeStaff)</a>
<a name="ln1215">      {</a>
<a name="ln1216">      for (auto i = s-&gt;annotations().begin(); i != s-&gt;annotations().end(); ++i) {</a>
<a name="ln1217">            // TODO: firstVisibleStaff() for system elements? see Spanner::nextSpanner()</a>
<a name="ln1218">            if ((*i)-&gt;staffIdx() == activeStaff)</a>
<a name="ln1219">                  return *i;</a>
<a name="ln1220">            }</a>
<a name="ln1221">      return nullptr;</a>
<a name="ln1222">      }</a>
<a name="ln1223"> </a>
<a name="ln1224">//---------------------------------------------------------</a>
<a name="ln1225">//   lastAnnotation</a>
<a name="ln1226">//---------------------------------------------------------</a>
<a name="ln1227"> </a>
<a name="ln1228">Element* Segment::lastAnnotation(Segment* s, int activeStaff)</a>
<a name="ln1229">      {</a>
<a name="ln1230">      for (auto i = --s-&gt;annotations().end(); i != s-&gt;annotations().begin(); --i) {</a>
<a name="ln1231">            // TODO: firstVisibleStaff() for system elements? see Spanner::nextSpanner()</a>
<a name="ln1232">            if ((*i)-&gt;staffIdx() == activeStaff)</a>
<a name="ln1233">                  return *i;</a>
<a name="ln1234">            }</a>
<a name="ln1235">      auto i = s-&gt;annotations().begin();</a>
<a name="ln1236">      if ((*i)-&gt;staffIdx() == activeStaff)</a>
<a name="ln1237">            return *i;</a>
<a name="ln1238">      return nullptr;</a>
<a name="ln1239">      }</a>
<a name="ln1240"> </a>
<a name="ln1241">//--------------------------------------------------------</a>
<a name="ln1242">//   firstInNextSegments</a>
<a name="ln1243">//   Searches for the next segment that has elements on the</a>
<a name="ln1244">//   active staff and returns its first element</a>
<a name="ln1245">//</a>
<a name="ln1246">//   Uses firstElement so it also returns a barline if it</a>
<a name="ln1247">//   spans into the active staff</a>
<a name="ln1248">//--------------------------------------------------------</a>
<a name="ln1249"> </a>
<a name="ln1250">Element* Segment::firstInNextSegments(int activeStaff)</a>
<a name="ln1251">      {</a>
<a name="ln1252">      Element* re = 0;</a>
<a name="ln1253">      Segment* seg = this;</a>
<a name="ln1254">      while (!re) {</a>
<a name="ln1255">            seg = seg-&gt;next1MMenabled();</a>
<a name="ln1256">            if (!seg) //end of staff, or score</a>
<a name="ln1257">                  break;</a>
<a name="ln1258"> </a>
<a name="ln1259">            re = seg-&gt;firstElement(activeStaff);</a>
<a name="ln1260">            }</a>
<a name="ln1261"> </a>
<a name="ln1262">      if (re)</a>
<a name="ln1263">            return re;</a>
<a name="ln1264"> </a>
<a name="ln1265">      if (!seg) { //end of staff</a>
<a name="ln1266">            if (activeStaff + 1 &gt;= score()-&gt;nstaves()) //end of score</a>
<a name="ln1267">                  return 0;</a>
<a name="ln1268">            seg = score()-&gt;firstSegmentMM(SegmentType::All);</a>
<a name="ln1269">            return seg-&gt;element((activeStaff + 1) * VOICES);</a>
<a name="ln1270">            }</a>
<a name="ln1271">      return 0;</a>
<a name="ln1272">      }</a>
<a name="ln1273"> </a>
<a name="ln1274">//---------------------------------------------------------</a>
<a name="ln1275">//   firstElementOfSegment</a>
<a name="ln1276">//   returns the first non null element in the given segment</a>
<a name="ln1277">//---------------------------------------------------------</a>
<a name="ln1278"> </a>
<a name="ln1279">Element* Segment::firstElementOfSegment(Segment* s, int activeStaff)</a>
<a name="ln1280">      {</a>
<a name="ln1281">      for (auto i: s-&gt;elist()) {</a>
<a name="ln1282">            if (i &amp;&amp; i-&gt;staffIdx() == activeStaff) {</a>
<a name="ln1283">                  if (i-&gt;type() == ElementType::CHORD)</a>
<a name="ln1284">                        return toChord(i)-&gt;notes().back();</a>
<a name="ln1285">                  else</a>
<a name="ln1286">                        return i;</a>
<a name="ln1287">                  }</a>
<a name="ln1288">            }</a>
<a name="ln1289">      return nullptr;</a>
<a name="ln1290">      }</a>
<a name="ln1291"> </a>
<a name="ln1292">//---------------------------------------------------------</a>
<a name="ln1293">//   nextElementOfSegment</a>
<a name="ln1294">//   returns the next element in the given segment</a>
<a name="ln1295">//---------------------------------------------------------</a>
<a name="ln1296"> </a>
<a name="ln1297">Element* Segment::nextElementOfSegment(Segment* s, Element* e, int activeStaff)</a>
<a name="ln1298">      {</a>
<a name="ln1299">      for (int track = 0; track &lt; score()-&gt;nstaves() * VOICES - 1; ++track) {</a>
<a name="ln1300">            if (s-&gt;element(track) == 0)</a>
<a name="ln1301">                  continue;</a>
<a name="ln1302">             Element* el = s-&gt;element(track);</a>
<a name="ln1303">             if (el == e) {</a>
<a name="ln1304">                 Element* next = s-&gt;element(track+1);</a>
<a name="ln1305">                 while (track &lt; score()-&gt;nstaves() * VOICES - 1 &amp;&amp;</a>
<a name="ln1306">                        (!next || next-&gt;staffIdx() != activeStaff)) {</a>
<a name="ln1307">                       next = s-&gt;element(++track);</a>
<a name="ln1308">                       }</a>
<a name="ln1309">                 if (!next)</a>
<a name="ln1310">                       return nullptr;</a>
<a name="ln1311">                 if (next-&gt;isChord())</a>
<a name="ln1312">                       return toChord(next)-&gt;notes().back();</a>
<a name="ln1313">                 else</a>
<a name="ln1314">                       return next;</a>
<a name="ln1315">             }</a>
<a name="ln1316">             if (el-&gt;type() == ElementType::CHORD) {</a>
<a name="ln1317">                   std::vector&lt;Note*&gt; notes = toChord(el)-&gt;notes();</a>
<a name="ln1318">                   auto i = std::find(notes.begin(), notes.end(), e);</a>
<a name="ln1319">                   if (i == notes.end())</a>
<a name="ln1320">                         continue;</a>
<a name="ln1321">                   if (i!= notes.begin()) {</a>
<a name="ln1322">                         return *(i-1);</a>
<a name="ln1323">                         }</a>
<a name="ln1324">                   else {</a>
<a name="ln1325">                         Element* nextEl = s-&gt;element(++track);</a>
<a name="ln1326">                         while (track &lt; score()-&gt;nstaves() * VOICES - 1 &amp;&amp;</a>
<a name="ln1327">                                (!nextEl || nextEl-&gt;staffIdx() != activeStaff)) {</a>
<a name="ln1328">                               nextEl = s-&gt;element(++track);</a>
<a name="ln1329">                               }</a>
<a name="ln1330">                         if (!nextEl || nextEl-&gt;staffIdx() != activeStaff)</a>
<a name="ln1331">                               return nullptr;</a>
<a name="ln1332">                         if (nextEl-&gt;isChord())</a>
<a name="ln1333">                               return toChord(nextEl)-&gt;notes().back();</a>
<a name="ln1334">                         return nextEl;</a>
<a name="ln1335">                         }</a>
<a name="ln1336">                   }</a>
<a name="ln1337">            }</a>
<a name="ln1338">      return nullptr;</a>
<a name="ln1339">      }</a>
<a name="ln1340"> </a>
<a name="ln1341">//---------------------------------------------------------</a>
<a name="ln1342">//   prevElementOfSegment</a>
<a name="ln1343">//   returns the previous element in the given segment</a>
<a name="ln1344">//---------------------------------------------------------</a>
<a name="ln1345"> </a>
<a name="ln1346">Element* Segment::prevElementOfSegment(Segment* s, Element* e, int activeStaff)</a>
<a name="ln1347">      {</a>
<a name="ln1348">      for (int track = score()-&gt;nstaves() * VOICES - 1; track &gt; 0; --track) {</a>
<a name="ln1349">            if (s-&gt;element(track) == 0)</a>
<a name="ln1350">                  continue;</a>
<a name="ln1351">             Element* el = s-&gt;element(track);</a>
<a name="ln1352">             if (el == e) {</a>
<a name="ln1353">                 Element* prev = s-&gt;element(track-1);</a>
<a name="ln1354">                 while (track &gt; 0 &amp;&amp;</a>
<a name="ln1355">                        (!prev || prev-&gt;staffIdx() != activeStaff)) {</a>
<a name="ln1356">                       prev = s-&gt;element(--track);</a>
<a name="ln1357">                       }</a>
<a name="ln1358">                 if (!prev)</a>
<a name="ln1359">                       return nullptr;</a>
<a name="ln1360">                 if (prev-&gt;staffIdx() == e-&gt;staffIdx()) {</a>
<a name="ln1361">                 if (prev-&gt;isChord())</a>
<a name="ln1362">                       return toChord(prev)-&gt;notes().front();</a>
<a name="ln1363">                 else</a>
<a name="ln1364">                       return prev;</a>
<a name="ln1365">                       }</a>
<a name="ln1366">                 return nullptr;</a>
<a name="ln1367">             }</a>
<a name="ln1368">             if (el-&gt;isChord()) {</a>
<a name="ln1369">                   std::vector&lt;Note*&gt; notes = toChord(el)-&gt;notes();</a>
<a name="ln1370">                   auto i = std::find(notes.begin(), notes.end(), e);</a>
<a name="ln1371">                   if (i == notes.end())</a>
<a name="ln1372">                         continue;</a>
<a name="ln1373">                   if (i!= --notes.end()) {</a>
<a name="ln1374">                         return *(i+1);</a>
<a name="ln1375">                         }</a>
<a name="ln1376">                   else {</a>
<a name="ln1377">                         Element* prevEl = s-&gt;element(--track);</a>
<a name="ln1378">                         while (track &gt; 0 &amp;&amp;</a>
<a name="ln1379">                                (!prevEl || prevEl-&gt;staffIdx() != activeStaff)) {</a>
<a name="ln1380">                               prevEl = s-&gt;element(--track);</a>
<a name="ln1381">                               }</a>
<a name="ln1382">                         if (!prevEl)</a>
<a name="ln1383">                               return nullptr;</a>
<a name="ln1384">                         if (prevEl-&gt;staffIdx() == e-&gt;staffIdx()) {</a>
<a name="ln1385">                         if (prevEl-&gt;isChord())</a>
<a name="ln1386">                               return toChord(prevEl)-&gt;notes().front();</a>
<a name="ln1387">                         return prevEl;</a>
<a name="ln1388">                               }</a>
<a name="ln1389">                         return nullptr;</a>
<a name="ln1390">                         }</a>
<a name="ln1391">                   }</a>
<a name="ln1392">            }</a>
<a name="ln1393">      return nullptr;</a>
<a name="ln1394">      }</a>
<a name="ln1395"> </a>
<a name="ln1396">//---------------------------------------------------------</a>
<a name="ln1397">//   lastElementOfSegment</a>
<a name="ln1398">//   returns the last element in the given segment</a>
<a name="ln1399">//---------------------------------------------------------</a>
<a name="ln1400"> </a>
<a name="ln1401">Element* Segment::lastElementOfSegment(Segment* s, int activeStaff)</a>
<a name="ln1402">      {</a>
<a name="ln1403">      std::vector&lt;Element*&gt; elements = s-&gt;elist();</a>
<a name="ln1404">      for (auto i = --elements.end(); i != elements.begin(); --i) {</a>
<a name="ln1405">            if (*i &amp;&amp; (*i)-&gt;staffIdx() == activeStaff) {</a>
<a name="ln1406">                  if ((*i)-&gt;isChord())</a>
<a name="ln1407">                      return toChord(*i)-&gt;notes().front();</a>
<a name="ln1408">                  else</a>
<a name="ln1409">                        return *i;</a>
<a name="ln1410">                  }</a>
<a name="ln1411">            }</a>
<a name="ln1412">      auto i = elements.begin();</a>
<a name="ln1413">      if (*i &amp;&amp; (*i)-&gt;staffIdx() == activeStaff) {</a>
<a name="ln1414">            if ((*i)-&gt;type() == ElementType::CHORD)</a>
<a name="ln1415">                  return toChord(*i)-&gt;notes().front();</a>
<a name="ln1416">            else</a>
<a name="ln1417">                  return *i;</a>
<a name="ln1418">            }</a>
<a name="ln1419">      return nullptr;</a>
<a name="ln1420">      }</a>
<a name="ln1421"> </a>
<a name="ln1422">//---------------------------------------------------------</a>
<a name="ln1423">//   firstSpanner</a>
<a name="ln1424">//---------------------------------------------------------</a>
<a name="ln1425"> </a>
<a name="ln1426">Spanner* Segment::firstSpanner(int activeStaff)</a>
<a name="ln1427">      {</a>
<a name="ln1428">      std::multimap&lt;int, Spanner*&gt; mmap = score()-&gt;spanner();</a>
<a name="ln1429">      auto range = mmap.equal_range(tick().ticks());</a>
<a name="ln1430">      if (range.first != range.second){ // range not empty</a>
<a name="ln1431">            for (auto i = range.first; i != range.second; ++i) {</a>
<a name="ln1432">                  Spanner* s = i-&gt;second;</a>
<a name="ln1433">                  Element* e = s-&gt;startElement();</a>
<a name="ln1434">                  if (!e)</a>
<a name="ln1435">                        continue;</a>
<a name="ln1436">                  if (s-&gt;startSegment() == this) {</a>
<a name="ln1437">                        if (e-&gt;staffIdx() == activeStaff)</a>
<a name="ln1438">                              return s;</a>
<a name="ln1439">#if 1</a>
<a name="ln1440">                        else if (e-&gt;isMeasure() &amp;&amp; activeStaff == 0)</a>
<a name="ln1441">                              return s;</a>
<a name="ln1442">#else</a>
<a name="ln1443">                        // TODO: see Spanner::nextSpanner()</a>
<a name="ln1444">                        else if (e-&gt;isMeasure()) {</a>
<a name="ln1445">                              SpannerSegment* ss = s-&gt;frontSegment();</a>
<a name="ln1446">                              int top = ss &amp;&amp; ss-&gt;system() ? ss-&gt;system()-&gt;firstVisibleStaff() : 0;</a>
<a name="ln1447">                              if (activeStaff == top)</a>
<a name="ln1448">                                    return s;</a>
<a name="ln1449">                              }</a>
<a name="ln1450">#endif</a>
<a name="ln1451">                        }</a>
<a name="ln1452">                  }</a>
<a name="ln1453">            }</a>
<a name="ln1454">      return nullptr;</a>
<a name="ln1455">      }</a>
<a name="ln1456"> </a>
<a name="ln1457">//---------------------------------------------------------</a>
<a name="ln1458">//   lastSpanner</a>
<a name="ln1459">//---------------------------------------------------------</a>
<a name="ln1460"> </a>
<a name="ln1461">Spanner* Segment::lastSpanner(int activeStaff)</a>
<a name="ln1462">      {</a>
<a name="ln1463">      std::multimap&lt;int, Spanner*&gt; mmap = score()-&gt;spanner();</a>
<a name="ln1464">      auto range = mmap.equal_range(tick().ticks());</a>
<a name="ln1465">      if (range.first != range.second){ // range not empty</a>
<a name="ln1466">            for (auto i = --range.second; ; --i) {</a>
<a name="ln1467">                  Spanner* s = i-&gt;second;</a>
<a name="ln1468">                  Element* e = s-&gt;startElement();</a>
<a name="ln1469">                  if (!e)</a>
<a name="ln1470">                        continue;</a>
<a name="ln1471">                  if (s-&gt;startSegment() == this) {</a>
<a name="ln1472">                        if (e-&gt;staffIdx() == activeStaff)</a>
<a name="ln1473">                              return s;</a>
<a name="ln1474">#if 1</a>
<a name="ln1475">                        else if (e-&gt;isMeasure() &amp;&amp; activeStaff == 0)</a>
<a name="ln1476">                              return s;</a>
<a name="ln1477">#else</a>
<a name="ln1478">                        // TODO: see Spanner::nextSpanner()</a>
<a name="ln1479">                        else if (e-&gt;isMeasure()) {</a>
<a name="ln1480">                              SpannerSegment* ss = s-&gt;frontSegment();</a>
<a name="ln1481">                              int top = ss &amp;&amp; ss-&gt;system() ? ss-&gt;system()-&gt;firstVisibleStaff() : 0;</a>
<a name="ln1482">                              if (activeStaff == top)</a>
<a name="ln1483">                                    return s;</a>
<a name="ln1484">                              }</a>
<a name="ln1485">#endif</a>
<a name="ln1486">                        }</a>
<a name="ln1487">                  if (i == range.first)</a>
<a name="ln1488">                        break;</a>
<a name="ln1489">                  }</a>
<a name="ln1490">            }</a>
<a name="ln1491">      return nullptr;</a>
<a name="ln1492">      }</a>
<a name="ln1493"> </a>
<a name="ln1494"> </a>
<a name="ln1495"> </a>
<a name="ln1496">//---------------------------------------------------------</a>
<a name="ln1497">//   notChordRestType</a>
<a name="ln1498">//---------------------------------------------------------</a>
<a name="ln1499"> </a>
<a name="ln1500">bool Segment::notChordRestType(Segment* s)</a>
<a name="ln1501">      {</a>
<a name="ln1502">      if (s-&gt;segmentType() == SegmentType::KeySig ||</a>
<a name="ln1503">          s-&gt;segmentType() == SegmentType::TimeSig ||</a>
<a name="ln1504">          s-&gt;segmentType() == SegmentType::Clef ||</a>
<a name="ln1505">          s-&gt;segmentType() == SegmentType::HeaderClef ||</a>
<a name="ln1506">          s-&gt;segmentType() == SegmentType::BeginBarLine ||</a>
<a name="ln1507">          s-&gt;segmentType() == SegmentType::EndBarLine ||</a>
<a name="ln1508">          s-&gt;segmentType() == SegmentType::BarLine ||</a>
<a name="ln1509">          s-&gt;segmentType() == SegmentType::KeySigAnnounce ||</a>
<a name="ln1510">          s-&gt;segmentType() == SegmentType::TimeSigAnnounce) {</a>
<a name="ln1511">            return true;</a>
<a name="ln1512">            }</a>
<a name="ln1513">      else {</a>
<a name="ln1514">            return false;</a>
<a name="ln1515">            }</a>
<a name="ln1516">      }</a>
<a name="ln1517"> </a>
<a name="ln1518">//---------------------------------------------------------</a>
<a name="ln1519">//   nextElement</a>
<a name="ln1520">//---------------------------------------------------------</a>
<a name="ln1521"> </a>
<a name="ln1522">Element* Segment::nextElement(int activeStaff)</a>
<a name="ln1523">      {</a>
<a name="ln1524">      Element* e = score()-&gt;selection().element();</a>
<a name="ln1525">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty() )</a>
<a name="ln1526">            e = score()-&gt;selection().elements().first();</a>
<a name="ln1527">      switch (e-&gt;type()) {</a>
<a name="ln1528">            case ElementType::DYNAMIC:</a>
<a name="ln1529">            case ElementType::HARMONY:</a>
<a name="ln1530">            case ElementType::SYMBOL:</a>
<a name="ln1531">            case ElementType::FERMATA:</a>
<a name="ln1532">            case ElementType::FRET_DIAGRAM:</a>
<a name="ln1533">            case ElementType::TEMPO_TEXT:</a>
<a name="ln1534">            case ElementType::STAFF_TEXT:</a>
<a name="ln1535">            case ElementType::SYSTEM_TEXT:</a>
<a name="ln1536">            case ElementType::REHEARSAL_MARK:</a>
<a name="ln1537">            case ElementType::MARKER:</a>
<a name="ln1538">            case ElementType::IMAGE:</a>
<a name="ln1539">            case ElementType::TEXT:</a>
<a name="ln1540">            case ElementType::TREMOLOBAR:</a>
<a name="ln1541">            case ElementType::TAB_DURATION_SYMBOL:</a>
<a name="ln1542">            case ElementType::FIGURED_BASS:</a>
<a name="ln1543">            case ElementType::STAFF_STATE:</a>
<a name="ln1544">            case ElementType::INSTRUMENT_CHANGE:</a>
<a name="ln1545">            case ElementType::STICKING: {</a>
<a name="ln1546">                  Element* next = nullptr;</a>
<a name="ln1547">                  if (e-&gt;parent() == this)</a>
<a name="ln1548">                        next = nextAnnotation(e);</a>
<a name="ln1549">                  if (next)</a>
<a name="ln1550">                        return next;</a>
<a name="ln1551">                  else {</a>
<a name="ln1552">                        Spanner* s = firstSpanner(activeStaff);</a>
<a name="ln1553">                        if (s)</a>
<a name="ln1554">                              return s-&gt;spannerSegments().front();</a>
<a name="ln1555">                        }</a>
<a name="ln1556">                  Segment* nextSegment = this-&gt;next1MMenabled();</a>
<a name="ln1557">                  while (nextSegment) {</a>
<a name="ln1558">                        Element* nextEl = nextSegment-&gt;firstElementOfSegment(nextSegment, activeStaff);</a>
<a name="ln1559">                        if (nextEl)</a>
<a name="ln1560">                              return nextEl;</a>
<a name="ln1561">                        nextSegment = nextSegment-&gt;next1MMenabled();</a>
<a name="ln1562">                        }</a>
<a name="ln1563">                  break;</a>
<a name="ln1564">                  }</a>
<a name="ln1565">            case ElementType::SEGMENT: {</a>
<a name="ln1566">                  if (!_annotations.empty()) {</a>
<a name="ln1567">                        Element* next = firstAnnotation(this, activeStaff);</a>
<a name="ln1568">                        if (next)</a>
<a name="ln1569">                              return next;</a>
<a name="ln1570">                        }</a>
<a name="ln1571">                  Spanner* sp = firstSpanner(activeStaff);</a>
<a name="ln1572">                  if (sp)</a>
<a name="ln1573">                        return sp-&gt;spannerSegments().front();</a>
<a name="ln1574"> </a>
<a name="ln1575">                  Segment* nextSegment = this-&gt;next1MMenabled();</a>
<a name="ln1576">                  while (nextSegment) {</a>
<a name="ln1577">                        Element* nextEl = nextSegment-&gt;firstElementOfSegment(nextSegment, activeStaff);</a>
<a name="ln1578">                        if (nextEl)</a>
<a name="ln1579">                              return nextEl;</a>
<a name="ln1580">                        nextSegment = nextSegment-&gt;next1MMenabled();</a>
<a name="ln1581">                        }</a>
<a name="ln1582">                  break;</a>
<a name="ln1583">                  }</a>
<a name="ln1584">            default: {</a>
<a name="ln1585">                  Element* p;</a>
<a name="ln1586">                  if (e-&gt;isTieSegment() || e-&gt;isGlissandoSegment()) {</a>
<a name="ln1587">                        SpannerSegment* s = toSpannerSegment(e);</a>
<a name="ln1588">                        Spanner* sp = s-&gt;spanner();</a>
<a name="ln1589">                        p = sp-&gt;startElement();</a>
<a name="ln1590">                        }</a>
<a name="ln1591">                  else {</a>
<a name="ln1592">                        p = e;</a>
<a name="ln1593">                        Element* pp = p-&gt;parent();</a>
<a name="ln1594">                        if (pp-&gt;isNote() || pp-&gt;isRest() || (pp-&gt;isChord() &amp;&amp; !p-&gt;isNote()))</a>
<a name="ln1595">                              p = pp;</a>
<a name="ln1596">                        }</a>
<a name="ln1597">                  Element* el = p;</a>
<a name="ln1598">                  for (; p &amp;&amp; p-&gt;type() != ElementType::SEGMENT; p = p-&gt;parent()) {</a>
<a name="ln1599">                        ;</a>
<a name="ln1600">                       }</a>
<a name="ln1601">                  Segment* seg = toSegment(p);</a>
<a name="ln1602">                  // next in _elist</a>
<a name="ln1603">                  Element* nextEl = nextElementOfSegment(seg, el, activeStaff);</a>
<a name="ln1604">                  if (nextEl)</a>
<a name="ln1605">                        return nextEl;</a>
<a name="ln1606">                  if (!_annotations.empty()) {</a>
<a name="ln1607">                        Element* next = firstAnnotation(seg, activeStaff);</a>
<a name="ln1608">                        if (next)</a>
<a name="ln1609">                              return next;</a>
<a name="ln1610">                        }</a>
<a name="ln1611">                  Spanner* s = firstSpanner(activeStaff);</a>
<a name="ln1612">                  if (s)</a>
<a name="ln1613">                        return s-&gt;spannerSegments().front();</a>
<a name="ln1614">                  Segment* nextSegment =  seg-&gt;next1MMenabled();</a>
<a name="ln1615">                  if (!nextSegment) {</a>
<a name="ln1616">                        MeasureBase* mb = measure()-&gt;next();</a>
<a name="ln1617">                        return mb &amp;&amp; mb-&gt;isBox() ? mb : score()-&gt;lastElement();</a>
<a name="ln1618">                        }</a>
<a name="ln1619"> </a>
<a name="ln1620">                  Measure* nsm = nextSegment-&gt;measure();</a>
<a name="ln1621">                  if (nsm != measure()) {</a>
<a name="ln1622">                        // check for frame, measure elements</a>
<a name="ln1623">                        MeasureBase* nmb = measure()-&gt;nextMM();</a>
<a name="ln1624">                        Element* nme = nsm-&gt;el().empty() ? nullptr : nsm-&gt;el().front();</a>
<a name="ln1625">                        if (nsm != nmb)</a>
<a name="ln1626">                              return nmb;</a>
<a name="ln1627">                        else if (nme &amp;&amp; nme-&gt;isTextBase() &amp;&amp; nme-&gt;staffIdx() == e-&gt;staffIdx())</a>
<a name="ln1628">                              return nme;</a>
<a name="ln1629">                        }</a>
<a name="ln1630"> </a>
<a name="ln1631">                  while (nextSegment) {</a>
<a name="ln1632">                        nextEl = nextSegment-&gt;firstElementOfSegment(nextSegment, activeStaff);</a>
<a name="ln1633">                        if (nextEl)</a>
<a name="ln1634">                              return nextEl;</a>
<a name="ln1635">                        nextSegment = nextSegment-&gt;next1MMenabled();</a>
<a name="ln1636">                        }</a>
<a name="ln1637">                  }</a>
<a name="ln1638">                  break;</a>
<a name="ln1639">            }</a>
<a name="ln1640">            return nullptr;</a>
<a name="ln1641">      }</a>
<a name="ln1642"> </a>
<a name="ln1643">//---------------------------------------------------------</a>
<a name="ln1644">//   prevElement</a>
<a name="ln1645">//---------------------------------------------------------</a>
<a name="ln1646"> </a>
<a name="ln1647">Element* Segment::prevElement(int activeStaff)</a>
<a name="ln1648">      {</a>
<a name="ln1649">      Element* e = score()-&gt;selection().element();</a>
<a name="ln1650">      if (!e &amp;&amp; !score()-&gt;selection().elements().isEmpty() )</a>
<a name="ln1651">            e = score()-&gt;selection().elements().last();</a>
<a name="ln1652">      switch (e-&gt;type()) {</a>
<a name="ln1653">            case ElementType::DYNAMIC:</a>
<a name="ln1654">            case ElementType::HARMONY:</a>
<a name="ln1655">            case ElementType::SYMBOL:</a>
<a name="ln1656">            case ElementType::FERMATA:</a>
<a name="ln1657">            case ElementType::FRET_DIAGRAM:</a>
<a name="ln1658">            case ElementType::TEMPO_TEXT:</a>
<a name="ln1659">            case ElementType::STAFF_TEXT:</a>
<a name="ln1660">            case ElementType::SYSTEM_TEXT:</a>
<a name="ln1661">            case ElementType::REHEARSAL_MARK:</a>
<a name="ln1662">            case ElementType::MARKER:</a>
<a name="ln1663">            case ElementType::IMAGE:</a>
<a name="ln1664">            case ElementType::TEXT:</a>
<a name="ln1665">            case ElementType::TREMOLOBAR:</a>
<a name="ln1666">            case ElementType::TAB_DURATION_SYMBOL:</a>
<a name="ln1667">            case ElementType::FIGURED_BASS:</a>
<a name="ln1668">            case ElementType::STAFF_STATE:</a>
<a name="ln1669">            case ElementType::INSTRUMENT_CHANGE:</a>
<a name="ln1670">            case ElementType::STICKING: {</a>
<a name="ln1671">                  Element* prev = nullptr;</a>
<a name="ln1672">                  if (e-&gt;parent() == this)</a>
<a name="ln1673">                        prev = prevAnnotation(e);</a>
<a name="ln1674">                  if (prev)</a>
<a name="ln1675">                        return prev;</a>
<a name="ln1676">                  if (notChordRestType(this)) {</a>
<a name="ln1677">                        Element* lastEl = lastElementOfSegment(this, activeStaff);</a>
<a name="ln1678">                        if (lastEl)</a>
<a name="ln1679">                              return lastEl;</a>
<a name="ln1680">                        }</a>
<a name="ln1681">                   int track = score()-&gt;nstaves() * VOICES - 1;</a>
<a name="ln1682">                   Segment* s = this;</a>
<a name="ln1683">                   Element* el = s-&gt;element(track);</a>
<a name="ln1684">                   while (track &gt; 0 &amp;&amp; (!el || el-&gt;staffIdx() != activeStaff)) {</a>
<a name="ln1685">                         el = s-&gt;element(--track);</a>
<a name="ln1686">                         if (track == 0) {</a>
<a name="ln1687">                               track = score()-&gt;nstaves() * VOICES - 1;</a>
<a name="ln1688">                               s = s-&gt;prev1MMenabled();</a>
<a name="ln1689">                               }</a>
<a name="ln1690">                         }</a>
<a name="ln1691">                   if (el-&gt;staffIdx() != activeStaff)</a>
<a name="ln1692">                         return nullptr;</a>
<a name="ln1693">                   if (el-&gt;type() == ElementType::CHORD || el-&gt;type() == ElementType::REST</a>
<a name="ln1694">                            || el-&gt;type() == ElementType::REPEAT_MEASURE) {</a>
<a name="ln1695">                         ChordRest* cr = this-&gt;cr(el-&gt;track());</a>
<a name="ln1696">                         if (cr) {</a>
<a name="ln1697">                               Element* elCr = cr-&gt;lastElementBeforeSegment();</a>
<a name="ln1698">                               if (elCr) {</a>
<a name="ln1699">                                     return elCr;</a>
<a name="ln1700">                                     }</a>
<a name="ln1701">                               }</a>
<a name="ln1702">                          }</a>
<a name="ln1703">                   if (el-&gt;type() == ElementType::CHORD) {</a>
<a name="ln1704">                         return toChord(el)-&gt;lastElementBeforeSegment();</a>
<a name="ln1705">                         }</a>
<a name="ln1706">                   else if (el-&gt;type() == ElementType::NOTE) {</a>
<a name="ln1707">                         Chord* c = toNote(el)-&gt;chord();</a>
<a name="ln1708">                         return c-&gt;lastElementBeforeSegment();</a>
<a name="ln1709">                         }</a>
<a name="ln1710">                   else {</a>
<a name="ln1711">                         return el;</a>
<a name="ln1712">                         }</a>
<a name="ln1713">                  }</a>
<a name="ln1714">            case ElementType::ARPEGGIO:</a>
<a name="ln1715">            case ElementType::TREMOLO: {</a>
<a name="ln1716">                  Element* el = this-&gt;element(e-&gt;track());</a>
<a name="ln1717">                  Q_ASSERT(el-&gt;type() == ElementType::CHORD);</a>
<a name="ln1718">                  return toChord(el)-&gt;prevElement();</a>
<a name="ln1719">                  }</a>
<a name="ln1720">            default: {</a>
<a name="ln1721">                  Element* el = e;</a>
<a name="ln1722">                  Segment* seg = this;</a>
<a name="ln1723">                  if (e-&gt;type() == ElementType::TIE_SEGMENT ||</a>
<a name="ln1724">                      e-&gt;type() == ElementType::GLISSANDO_SEGMENT) {</a>
<a name="ln1725">                        SpannerSegment* s = toSpannerSegment(e);</a>
<a name="ln1726">                        Spanner* sp = s-&gt;spanner();</a>
<a name="ln1727">                        el = sp-&gt;startElement();</a>
<a name="ln1728">                        seg = sp-&gt;startSegment();</a>
<a name="ln1729">                        }</a>
<a name="ln1730">                  else {</a>
<a name="ln1731">                        Element* ep = e-&gt;parent();</a>
<a name="ln1732">                        if (ep-&gt;isNote() || ep-&gt;isRest() || (ep-&gt;isChord() &amp;&amp; !e-&gt;isNote()))</a>
<a name="ln1733">                              el = e-&gt;parent();</a>
<a name="ln1734">                        }</a>
<a name="ln1735"> </a>
<a name="ln1736">                 Element* prev = seg-&gt;prevElementOfSegment(seg, el, activeStaff);</a>
<a name="ln1737">                  if (prev) {</a>
<a name="ln1738">                        if (prev-&gt;type() == ElementType::CHORD || prev-&gt;type() == ElementType::REST</a>
<a name="ln1739">                               || prev-&gt;type() == ElementType::REPEAT_MEASURE) {</a>
<a name="ln1740">                              ChordRest* cr = seg-&gt;cr(prev-&gt;track());</a>
<a name="ln1741">                              if (cr) {</a>
<a name="ln1742">                                    Element* elCr = cr-&gt;lastElementBeforeSegment();</a>
<a name="ln1743">                                    if (elCr) {</a>
<a name="ln1744">                                          return elCr;</a>
<a name="ln1745">                                          }</a>
<a name="ln1746">                                    }</a>
<a name="ln1747">                              }</a>
<a name="ln1748">                        if (prev-&gt;type() == ElementType::CHORD) {</a>
<a name="ln1749">                              return toChord(prev)-&gt;lastElementBeforeSegment();</a>
<a name="ln1750">                              }</a>
<a name="ln1751">                        else if (prev-&gt;type() == ElementType::NOTE) {</a>
<a name="ln1752">                              Chord* c = toNote(prev)-&gt;chord();</a>
<a name="ln1753">                              return c-&gt;lastElementBeforeSegment();</a>
<a name="ln1754">                              }</a>
<a name="ln1755">                        else {</a>
<a name="ln1756">                              return prev;</a>
<a name="ln1757">                              }</a>
<a name="ln1758">                        }</a>
<a name="ln1759">                   Segment* prevSeg = seg-&gt;prev1MMenabled();</a>
<a name="ln1760">                   if (!prevSeg) {</a>
<a name="ln1761">                         MeasureBase* mb = measure()-&gt;prev();</a>
<a name="ln1762">                         return mb &amp;&amp; mb-&gt;isBox() ? mb : score()-&gt;firstElement();</a>
<a name="ln1763">                         }</a>
<a name="ln1764"> </a>
<a name="ln1765">                   Measure* psm = prevSeg-&gt;measure();</a>
<a name="ln1766">                   if (psm != measure()) {</a>
<a name="ln1767">                         // check for frame, measure elements</a>
<a name="ln1768">                         MeasureBase* pmb = measure()-&gt;prevMM();</a>
<a name="ln1769">                         Element* me = measure()-&gt;el().empty() ? nullptr : measure()-&gt;el().back();</a>
<a name="ln1770">                         if (me &amp;&amp; me-&gt;isTextBase() &amp;&amp; me-&gt;staffIdx() == e-&gt;staffIdx())</a>
<a name="ln1771">                               return me;</a>
<a name="ln1772">                         else if (psm != pmb)</a>
<a name="ln1773">                              return pmb;</a>
<a name="ln1774">                         }</a>
<a name="ln1775"> </a>
<a name="ln1776">                   prev = lastElementOfSegment(prevSeg, activeStaff);</a>
<a name="ln1777">                   while (!prev &amp;&amp; prevSeg) {</a>
<a name="ln1778">                         prevSeg = prevSeg-&gt;prev1MMenabled();</a>
<a name="ln1779">                         prev = lastElementOfSegment(prevSeg, activeStaff);</a>
<a name="ln1780">                         }</a>
<a name="ln1781">                   if (!prevSeg)</a>
<a name="ln1782">                         return score()-&gt;firstElement();</a>
<a name="ln1783"> </a>
<a name="ln1784">                   if (notChordRestType(prevSeg)) {</a>
<a name="ln1785">                         Element* lastEl = lastElementOfSegment(prevSeg, activeStaff);</a>
<a name="ln1786">                         if (lastEl)</a>
<a name="ln1787">                               return lastEl;</a>
<a name="ln1788">                         }</a>
<a name="ln1789">                   Spanner* s1 = prevSeg-&gt;lastSpanner(activeStaff);</a>
<a name="ln1790">                   if (s1) {</a>
<a name="ln1791">                         return s1-&gt;spannerSegments().front();</a>
<a name="ln1792">                         }</a>
<a name="ln1793">                   else if (!prevSeg-&gt;annotations().empty()) {</a>
<a name="ln1794">                         Element* next = lastAnnotation(prevSeg, activeStaff);</a>
<a name="ln1795">                         if (next)</a>
<a name="ln1796">                               return next;</a>
<a name="ln1797">                         }</a>
<a name="ln1798">                   if (prev-&gt;type() == ElementType::CHORD || prev-&gt;type() == ElementType::REST</a>
<a name="ln1799">                            || prev-&gt;type() == ElementType::REPEAT_MEASURE || prev-&gt;type() == ElementType::NOTE) {</a>
<a name="ln1800">                         ChordRest* cr = prevSeg-&gt;cr(prev-&gt;track());</a>
<a name="ln1801">                         if (cr) {</a>
<a name="ln1802">                               Element* elCr = cr-&gt;lastElementBeforeSegment();</a>
<a name="ln1803">                               if (elCr) {</a>
<a name="ln1804">                                     return elCr;</a>
<a name="ln1805">                                     }</a>
<a name="ln1806">                               }</a>
<a name="ln1807">                         }</a>
<a name="ln1808">                   if (prev-&gt;type() == ElementType::CHORD) {</a>
<a name="ln1809">                         return toChord(prev)-&gt;lastElementBeforeSegment();</a>
<a name="ln1810">                         }</a>
<a name="ln1811">                   else if (prev-&gt;type() == ElementType::NOTE) {</a>
<a name="ln1812">                         Chord* c = toNote(prev)-&gt;chord();</a>
<a name="ln1813">                         return c-&gt;lastElementBeforeSegment();</a>
<a name="ln1814">                         }</a>
<a name="ln1815">                   else {</a>
<a name="ln1816">                         return prev;</a>
<a name="ln1817">                         }</a>
<a name="ln1818">                  }</a>
<a name="ln1819">            }</a>
<a name="ln1820">      }</a>
<a name="ln1821"> </a>
<a name="ln1822">//--------------------------------------------------------</a>
<a name="ln1823">//   lastInPrevSegments</a>
<a name="ln1824">//   Searches for the previous segment that has elements on</a>
<a name="ln1825">//   the active staff and returns its last element</a>
<a name="ln1826">//</a>
<a name="ln1827">//   Uses lastElement so it also returns a barline if it</a>
<a name="ln1828">//   spans into the active staff</a>
<a name="ln1829">//--------------------------------------------------------</a>
<a name="ln1830"> </a>
<a name="ln1831">Element* Segment::lastInPrevSegments(int activeStaff)</a>
<a name="ln1832">      {</a>
<a name="ln1833">      Element* re = 0;</a>
<a name="ln1834">      Segment* seg = this;</a>
<a name="ln1835"> </a>
<a name="ln1836">      while (!re) {</a>
<a name="ln1837">            seg = seg-&gt;prev1MMenabled();</a>
<a name="ln1838">            if (!seg) //end of staff, or score</a>
<a name="ln1839">                  break;</a>
<a name="ln1840"> </a>
<a name="ln1841">            re = seg-&gt;lastElementOfSegment(seg, activeStaff);</a>
<a name="ln1842">            }</a>
<a name="ln1843"> </a>
<a name="ln1844">      if (re)</a>
<a name="ln1845">            return re;</a>
<a name="ln1846"> </a>
<a name="ln1847">      if (!seg) { //end of staff</a>
<a name="ln1848">            if (activeStaff - 1 &lt; 0) //end of score</a>
<a name="ln1849">                  return 0;</a>
<a name="ln1850"> </a>
<a name="ln1851">            re = 0;</a>
<a name="ln1852">            seg = score()-&gt;lastSegmentMM();</a>
<a name="ln1853">            while (true) {</a>
<a name="ln1854">                  //if (seg-&gt;segmentType() == SegmentType::EndBarLine)</a>
<a name="ln1855">                  //      score()-&gt;inputState().setTrack((activeStaff - 1) * VOICES ); //correction</a>
<a name="ln1856"> </a>
<a name="ln1857">                  if ((re = seg-&gt;lastElement(activeStaff - 1)) != 0)</a>
<a name="ln1858">                        return re;</a>
<a name="ln1859"> </a>
<a name="ln1860">                  seg = seg-&gt;prev1MMenabled();</a>
<a name="ln1861">                  }</a>
<a name="ln1862">            }</a>
<a name="ln1863"> </a>
<a name="ln1864">      return 0;</a>
<a name="ln1865">      }</a>
<a name="ln1866"> </a>
<a name="ln1867">//---------------------------------------------------------</a>
<a name="ln1868">//   accessibleExtraInfo</a>
<a name="ln1869">//---------------------------------------------------------</a>
<a name="ln1870"> </a>
<a name="ln1871">QString Segment::accessibleExtraInfo() const</a>
<a name="ln1872">      {</a>
<a name="ln1873">      QString rez = &quot;&quot;;</a>
<a name="ln1874">      if (!annotations().empty()) {</a>
<a name="ln1875">            QString temp = &quot;&quot;;</a>
<a name="ln1876">            for (const Element* a : annotations()) {</a>
<a name="ln1877">                  if (!score()-&gt;selectionFilter().canSelect(a)) continue;</a>
<a name="ln1878">                  switch(a-&gt;type()) {</a>
<a name="ln1879">                        case ElementType::DYNAMIC:</a>
<a name="ln1880">                              //they are added in the chordrest, because they are for only one staff</a>
<a name="ln1881">                               break;</a>
<a name="ln1882">                        default:</a>
<a name="ln1883">                               temp = temp + &quot; &quot; + a-&gt;accessibleInfo();</a>
<a name="ln1884">                        }</a>
<a name="ln1885">                  }</a>
<a name="ln1886">            if(!temp.isEmpty())</a>
<a name="ln1887">                  rez = rez + QObject::tr(&quot;Annotations:&quot;) + temp;</a>
<a name="ln1888">            }</a>
<a name="ln1889"> </a>
<a name="ln1890">      QString startSpanners = &quot;&quot;;</a>
<a name="ln1891">      QString endSpanners = &quot;&quot;;</a>
<a name="ln1892"> </a>
<a name="ln1893">      auto spanners = score()-&gt;spannerMap().findOverlapping(tick().ticks(), tick().ticks());</a>
<a name="ln1894">      for (auto interval : spanners) {</a>
<a name="ln1895">            Spanner* s = interval.value;</a>
<a name="ln1896">            if (!score()-&gt;selectionFilter().canSelect(s)) continue;</a>
<a name="ln1897">            if (segmentType() == SegmentType::EndBarLine       ||</a>
<a name="ln1898">               segmentType() == SegmentType::BarLine           ||</a>
<a name="ln1899">               segmentType() == SegmentType::StartRepeatBarLine) {</a>
<a name="ln1900">                  if (s-&gt;isVolta())</a>
<a name="ln1901">                        continue;</a>
<a name="ln1902">                  }</a>
<a name="ln1903">            else {</a>
<a name="ln1904">                  if (s-&gt;isVolta() || s-&gt;isTie()) //ties are added in Note</a>
<a name="ln1905">                        continue;</a>
<a name="ln1906">                  }</a>
<a name="ln1907"> </a>
<a name="ln1908">            if (s-&gt;tick() == tick())</a>
<a name="ln1909">                  startSpanners += QObject::tr(&quot;Start of %1&quot;).arg(s-&gt;accessibleInfo());</a>
<a name="ln1910"> </a>
<a name="ln1911">            const Segment* seg = 0;</a>
<a name="ln1912">            switch (s-&gt;type()) {</a>
<a name="ln1913">                  case ElementType::VOLTA:</a>
<a name="ln1914">                  case ElementType::SLUR:</a>
<a name="ln1915">                        seg = this;</a>
<a name="ln1916">                        break;</a>
<a name="ln1917">                  default:</a>
<a name="ln1918">                        seg = next1MM(SegmentType::ChordRest);</a>
<a name="ln1919">                        break;</a>
<a name="ln1920">                  }</a>
<a name="ln1921"> </a>
<a name="ln1922">            if (seg &amp;&amp; s-&gt;tick2() == seg-&gt;tick())</a>
<a name="ln1923">                  endSpanners += QObject::tr(&quot;End of %1&quot;).arg(s-&gt;accessibleInfo());</a>
<a name="ln1924">            }</a>
<a name="ln1925">      return rez + &quot; &quot; + startSpanners + &quot; &quot; + endSpanners;</a>
<a name="ln1926">      }</a>
<a name="ln1927"> </a>
<a name="ln1928">//---------------------------------------------------------</a>
<a name="ln1929">//   createShapes</a>
<a name="ln1930">//---------------------------------------------------------</a>
<a name="ln1931"> </a>
<a name="ln1932">void Segment::createShapes()</a>
<a name="ln1933">      {</a>
<a name="ln1934">      setVisible(false);</a>
<a name="ln1935">      for (int staffIdx = 0; staffIdx &lt; score()-&gt;nstaves(); ++staffIdx)</a>
<a name="ln1936">            createShape(staffIdx);</a>
<a name="ln1937">      }</a>
<a name="ln1938"> </a>
<a name="ln1939">//---------------------------------------------------------</a>
<a name="ln1940">//   createShape</a>
<a name="ln1941">//---------------------------------------------------------</a>
<a name="ln1942"> </a>
<a name="ln1943">void Segment::createShape(int staffIdx)</a>
<a name="ln1944">      {</a>
<a name="ln1945">      Shape&amp; s = _shapes[staffIdx];</a>
<a name="ln1946">      s.clear();</a>
<a name="ln1947"> </a>
<a name="ln1948">      if (segmentType() &amp; (SegmentType::BarLine | SegmentType::EndBarLine | SegmentType::StartRepeatBarLine | SegmentType::BeginBarLine)) {</a>
<a name="ln1949">            setVisible(true);</a>
<a name="ln1950">            BarLine* bl = toBarLine(element(staffIdx * VOICES));</a>
<a name="ln1951">            if (bl) {</a>
<a name="ln1952">                  QRectF r = bl-&gt;layoutRect();</a>
<a name="ln1953">#ifndef NDEBUG</a>
<a name="ln1954">                  s.add(r.translated(bl-&gt;pos()), bl-&gt;name());</a>
<a name="ln1955">#else</a>
<a name="ln1956">                  s.add(r.translated(bl-&gt;pos()));</a>
<a name="ln1957">#endif</a>
<a name="ln1958">                  }</a>
<a name="ln1959">            s.addHorizontalSpacing(Shape::SPACING_GENERAL, 0, 0);</a>
<a name="ln1960">            s.addHorizontalSpacing(Shape::SPACING_LYRICS, 0, 0);</a>
<a name="ln1961">            return;</a>
<a name="ln1962">            }</a>
<a name="ln1963">#if 0</a>
<a name="ln1964">      for (int track = staffIdx * VOICES; track &lt; (staffIdx + 1) * VOICES; ++track) {</a>
<a name="ln1965">            Element* e = _elist[track];</a>
<a name="ln1966">            if (e)</a>
<a name="ln1967">                  s.add(e-&gt;shape().translated(e-&gt;pos()));</a>
<a name="ln1968">            }</a>
<a name="ln1969">#endif</a>
<a name="ln1970"> </a>
<a name="ln1971">      if (!score()-&gt;staff(staffIdx)-&gt;show())</a>
<a name="ln1972">            return;</a>
<a name="ln1973"> </a>
<a name="ln1974">      int strack = staffIdx * VOICES;</a>
<a name="ln1975">      int etrack = strack + VOICES;</a>
<a name="ln1976">      for (Element* e : _elist) {</a>
<a name="ln1977">            if (!e)</a>
<a name="ln1978">                  continue;</a>
<a name="ln1979">            int effectiveTrack = e-&gt;vStaffIdx() * VOICES + e-&gt;voice();</a>
<a name="ln1980">            if (effectiveTrack &gt;= strack &amp;&amp; effectiveTrack &lt; etrack) {</a>
<a name="ln1981">                  setVisible(true);</a>
<a name="ln1982">                  if (e-&gt;addToSkyline())</a>
<a name="ln1983">                        s.add(e-&gt;shape().translated(e-&gt;pos()));</a>
<a name="ln1984">                  }</a>
<a name="ln1985">            }</a>
<a name="ln1986"> </a>
<a name="ln1987">      for (Element* e : _annotations) {</a>
<a name="ln1988">            if (!e || e-&gt;staffIdx() != staffIdx)</a>
<a name="ln1989">                  continue;</a>
<a name="ln1990">            setVisible(true);</a>
<a name="ln1991">            if (!e-&gt;addToSkyline())</a>
<a name="ln1992">                  continue;</a>
<a name="ln1993"> </a>
<a name="ln1994">            if (e-&gt;isHarmony()) {</a>
<a name="ln1995">                  // use same spacing calculation as for chordrest</a>
<a name="ln1996">                  toHarmony(e)-&gt;layout1();</a>
<a name="ln1997">                  const qreal margin = styleP(Sid::minHarmonyDistance) * 0.5;</a>
<a name="ln1998">                  qreal x1 = e-&gt;bbox().x() - margin + e-&gt;pos().x();</a>
<a name="ln1999">                  qreal x2 = e-&gt;bbox().x() + e-&gt;bbox().width() + margin + e-&gt;pos().x();</a>
<a name="ln2000">                  s.addHorizontalSpacing(Shape::SPACING_HARMONY, x1, x2);</a>
<a name="ln2001">                  }</a>
<a name="ln2002">            else if (!e-&gt;isRehearsalMark()</a>
<a name="ln2003">               &amp;&amp; !e-&gt;isFretDiagram()</a>
<a name="ln2004">               &amp;&amp; !e-&gt;isHarmony()</a>
<a name="ln2005">               &amp;&amp; !e-&gt;isTempoText()</a>
<a name="ln2006">               &amp;&amp; !e-&gt;isDynamic()</a>
<a name="ln2007">               &amp;&amp; !e-&gt;isFiguredBass()</a>
<a name="ln2008">               &amp;&amp; !e-&gt;isSymbol()</a>
<a name="ln2009">               &amp;&amp; !e-&gt;isFSymbol()</a>
<a name="ln2010">               &amp;&amp; !e-&gt;isSystemText()</a>
<a name="ln2011">               &amp;&amp; !e-&gt;isInstrumentChange()</a>
<a name="ln2012">               &amp;&amp; !e-&gt;isArticulation()</a>
<a name="ln2013">               &amp;&amp; !e-&gt;isFermata()</a>
<a name="ln2014">               &amp;&amp; !e-&gt;isStaffText()) {</a>
<a name="ln2015">                  // annotations added here are candidates for collision detection</a>
<a name="ln2016">                  // lyrics, ...</a>
<a name="ln2017">                  s.add(e-&gt;shape().translated(e-&gt;pos()));</a>
<a name="ln2018">                  }</a>
<a name="ln2019">            }</a>
<a name="ln2020">      }</a>
<a name="ln2021"> </a>
<a name="ln2022">//---------------------------------------------------------</a>
<a name="ln2023">//   minRight</a>
<a name="ln2024">//    calculate minimum distance needed to the right</a>
<a name="ln2025">//---------------------------------------------------------</a>
<a name="ln2026"> </a>
<a name="ln2027">qreal Segment::minRight() const</a>
<a name="ln2028">      {</a>
<a name="ln2029">      qreal distance = 0.0;</a>
<a name="ln2030">      for (const Shape&amp; sh : shapes())</a>
<a name="ln2031">            distance = qMax(distance, sh.right());</a>
<a name="ln2032">      if (isClefType())</a>
<a name="ln2033">            distance += score()-&gt;styleP(Sid::clefBarlineDistance);</a>
<a name="ln2034">      return distance;</a>
<a name="ln2035">      }</a>
<a name="ln2036"> </a>
<a name="ln2037">//---------------------------------------------------------</a>
<a name="ln2038">//   minLeft</a>
<a name="ln2039">//    Calculate minimum distance needed to the left shape</a>
<a name="ln2040">//    sl. Sl is the same for all staves.</a>
<a name="ln2041">//---------------------------------------------------------</a>
<a name="ln2042"> </a>
<a name="ln2043">qreal Segment::minLeft(const Shape&amp; sl) const</a>
<a name="ln2044">      {</a>
<a name="ln2045">      qreal distance = 0.0;</a>
<a name="ln2046">      for (const Shape&amp; sh : shapes()) {</a>
<a name="ln2047">            qreal d = sl.minHorizontalDistance(sh);</a>
<a name="ln2048">            if (d &gt; distance)</a>
<a name="ln2049">                  distance = d;</a>
<a name="ln2050">            }</a>
<a name="ln2051">      return distance;</a>
<a name="ln2052">      }</a>
<a name="ln2053"> </a>
<a name="ln2054">qreal Segment::minLeft() const</a>
<a name="ln2055">      {</a>
<a name="ln2056">      qreal distance = 0.0;</a>
<a name="ln2057">      for (const Shape&amp; sh : shapes()) {</a>
<a name="ln2058">            qreal l = sh.left();</a>
<a name="ln2059">            if (l &gt; distance)</a>
<a name="ln2060">                  distance = l;</a>
<a name="ln2061">            }</a>
<a name="ln2062">      return distance;</a>
<a name="ln2063">      }</a>
<a name="ln2064"> </a>
<a name="ln2065">//---------------------------------------------------------</a>
<a name="ln2066">//   minHorizontalCollidingDistance</a>
<a name="ln2067">//    calculate the minimum distance to ns avoiding collisions</a>
<a name="ln2068">//---------------------------------------------------------</a>
<a name="ln2069"> </a>
<a name="ln2070">qreal Segment::minHorizontalCollidingDistance(Segment* ns) const</a>
<a name="ln2071">      {</a>
<a name="ln2072">      qreal w = 0.0;</a>
<a name="ln2073">      for (unsigned staffIdx = 0; staffIdx &lt; _shapes.size(); ++staffIdx) {</a>
<a name="ln2074">            qreal d = staffShape(staffIdx).minHorizontalDistance(ns-&gt;staffShape(staffIdx));</a>
<a name="ln2075">            w       = qMax(w, d);</a>
<a name="ln2076">            }</a>
<a name="ln2077">      return w;</a>
<a name="ln2078">      }</a>
<a name="ln2079"> </a>
<a name="ln2080">//---------------------------------------------------------</a>
<a name="ln2081">//   minHorizontalDistance</a>
<a name="ln2082">//    calculate the minimum layout distance to Segment ns</a>
<a name="ln2083">//---------------------------------------------------------</a>
<a name="ln2084"> </a>
<a name="ln2085">qreal Segment::minHorizontalDistance(Segment* ns, bool systemHeaderGap) const</a>
<a name="ln2086">      {</a>
<a name="ln2087">      qreal ww = -1000000.0;        // can remain negative</a>
<a name="ln2088">      for (unsigned staffIdx = 0; staffIdx &lt; _shapes.size(); ++staffIdx) {</a>
<a name="ln2089">            qreal d = staffShape(staffIdx).minHorizontalDistance(ns-&gt;staffShape(staffIdx));</a>
<a name="ln2090">            // first chordrest of a staff should clear the widest header for any staff</a>
<a name="ln2091">            // so make sure segment is as wide as it needs to be</a>
<a name="ln2092">            if (systemHeaderGap)</a>
<a name="ln2093">                  d = qMax(d, staffShape(staffIdx).right());</a>
<a name="ln2094">            ww      = qMax(ww, d);</a>
<a name="ln2095">            }</a>
<a name="ln2096">      qreal w = qMax(ww, 0.0);      // non-negative</a>
<a name="ln2097"> </a>
<a name="ln2098">      SegmentType st  = segmentType();</a>
<a name="ln2099">      SegmentType nst = ns ? ns-&gt;segmentType() : SegmentType::Invalid;</a>
<a name="ln2100"> </a>
<a name="ln2101">      if (isChordRestType()) {</a>
<a name="ln2102">            if (nst == SegmentType::EndBarLine) {</a>
<a name="ln2103">                  w = qMax(w, score()-&gt;noteHeadWidth());</a>
<a name="ln2104">                  w += score()-&gt;styleP(Sid::noteBarDistance);</a>
<a name="ln2105">                  }</a>
<a name="ln2106">            else if (nst == SegmentType::Clef) {</a>
<a name="ln2107">                  // clef likely does not exist on all staves</a>
<a name="ln2108">                  // and can cause very uneven spacing</a>
<a name="ln2109">                  // so use ww to avoid forcing margin except as necessary</a>
<a name="ln2110">                  w = ww + score()-&gt;styleP(Sid::clefLeftMargin);</a>
<a name="ln2111">                  }</a>
<a name="ln2112">            else {</a>
<a name="ln2113">                  bool isGap = false;</a>
<a name="ln2114">                  for (int i = 0; i &lt; score()-&gt;nstaves() * VOICES; i++) {</a>
<a name="ln2115">                        Element* el = element(i);</a>
<a name="ln2116">                        if (!el)</a>
<a name="ln2117">                              continue;</a>
<a name="ln2118">                        if (el-&gt;isRest() &amp;&amp; toRest(el)-&gt;isGap())</a>
<a name="ln2119">                              isGap = true;</a>
<a name="ln2120">                        else {</a>
<a name="ln2121">                              isGap = false;</a>
<a name="ln2122">                              break;</a>
<a name="ln2123">                              }</a>
<a name="ln2124">                        }</a>
<a name="ln2125">                  if (isGap)</a>
<a name="ln2126">                        return 0.0;</a>
<a name="ln2127">                  // minimum distance between notes is one note head width</a>
<a name="ln2128">                  w = qMax(w, score()-&gt;noteHeadWidth()) + score()-&gt;styleP(Sid::minNoteDistance);</a>
<a name="ln2129">                  }</a>
<a name="ln2130">            }</a>
<a name="ln2131">      else if (nst == SegmentType::ChordRest) {</a>
<a name="ln2132">            // &lt;non ChordRest&gt; - &lt;ChordRest&gt;</a>
<a name="ln2133">            if (systemHeaderGap) {</a>
<a name="ln2134">                  if (st == SegmentType::TimeSig)</a>
<a name="ln2135">                        w += score()-&gt;styleP(Sid::systemHeaderTimeSigDistance);</a>
<a name="ln2136">                  else</a>
<a name="ln2137">                        w += score()-&gt;styleP(Sid::systemHeaderDistance);</a>
<a name="ln2138">                  }</a>
<a name="ln2139">            else {</a>
<a name="ln2140">//                  qreal d = score()-&gt;styleP(Sid::barNoteDistance);</a>
<a name="ln2141">//                  qreal dd = minRight() + ns-&gt;minLeft() + spatium();</a>
<a name="ln2142">//                  w = qMax(d, dd);</a>
<a name="ln2143">                  // not header</a>
<a name="ln2144">                  if (st == SegmentType::Clef)</a>
<a name="ln2145">                        w = ww + score()-&gt;styleP(Sid::midClefKeyRightMargin);</a>
<a name="ln2146">                  else if (st == SegmentType::KeySig)</a>
<a name="ln2147">                        w += score()-&gt;styleP(Sid::midClefKeyRightMargin);</a>
<a name="ln2148">                  else</a>
<a name="ln2149">                        w += score()-&gt;styleP(Sid::barNoteDistance);</a>
<a name="ln2150"> </a>
<a name="ln2151">                  if (st == SegmentType::StartRepeatBarLine) {</a>
<a name="ln2152">                        if (Element* barLine = element(0)) {</a>
<a name="ln2153">                              const qreal blWidth = barLine-&gt;width();</a>
<a name="ln2154">                              if (w &lt; blWidth)</a>
<a name="ln2155">                                    w += blWidth;</a>
<a name="ln2156">                              }</a>
<a name="ln2157">                        }</a>
<a name="ln2158">                  }</a>
<a name="ln2159">            // d -= ns-&gt;minLeft() * .7;      // hack</a>
<a name="ln2160">            // d = qMax(d, ns-&gt;minLeft());</a>
<a name="ln2161">            // d = qMax(d, spatium());       // minimum distance is one spatium</a>
<a name="ln2162">            // w = qMax(w, minRight()) + d;</a>
<a name="ln2163">            }</a>
<a name="ln2164">      else if (systemHeaderGap) {</a>
<a name="ln2165">            // first segment after header is *not* a chordrest</a>
<a name="ln2166">            // could be a clef</a>
<a name="ln2167">            if (st == SegmentType::TimeSig)</a>
<a name="ln2168">                  w += score()-&gt;styleP(Sid::systemHeaderTimeSigDistance);</a>
<a name="ln2169">            else</a>
<a name="ln2170">                  w += score()-&gt;styleP(Sid::systemHeaderDistance);</a>
<a name="ln2171">            }</a>
<a name="ln2172">      else if (st &amp; (SegmentType::Clef | SegmentType::HeaderClef)) {</a>
<a name="ln2173">            if (nst == SegmentType::KeySig || nst == SegmentType::KeySigAnnounce)</a>
<a name="ln2174">                  w += score()-&gt;styleP(Sid::clefKeyDistance);</a>
<a name="ln2175">            else if (nst == SegmentType::TimeSig || nst == SegmentType::TimeSigAnnounce)</a>
<a name="ln2176">                  w += score()-&gt;styleP(Sid::clefTimesigDistance);</a>
<a name="ln2177">            else if (nst &amp; (SegmentType::EndBarLine | SegmentType::StartRepeatBarLine))</a>
<a name="ln2178">                  w += score()-&gt;styleP(Sid::clefBarlineDistance);</a>
<a name="ln2179">            else if (nst == SegmentType::Ambitus)</a>
<a name="ln2180">                  w += score()-&gt;styleP(Sid::ambitusMargin);</a>
<a name="ln2181">            }</a>
<a name="ln2182">      else if ((st &amp; (SegmentType::KeySig | SegmentType::KeySigAnnounce))</a>
<a name="ln2183">         &amp;&amp; (nst &amp; (SegmentType::TimeSig | SegmentType::TimeSigAnnounce))) {</a>
<a name="ln2184">            w += score()-&gt;styleP(Sid::keyTimesigDistance);</a>
<a name="ln2185">            }</a>
<a name="ln2186">      else if (st == SegmentType::KeySig &amp;&amp; nst == SegmentType::StartRepeatBarLine)</a>
<a name="ln2187">            w += score()-&gt;styleP(Sid::keyBarlineDistance);</a>
<a name="ln2188">      else if (st == SegmentType::StartRepeatBarLine)</a>
<a name="ln2189">            w += score()-&gt;styleP(Sid::noteBarDistance);</a>
<a name="ln2190">      else if (st == SegmentType::BeginBarLine &amp;&amp; (nst &amp; (SegmentType::HeaderClef | SegmentType::Clef)))</a>
<a name="ln2191">            w += score()-&gt;styleP(Sid::clefLeftMargin);</a>
<a name="ln2192">      else if (st == SegmentType::BeginBarLine &amp;&amp; nst == SegmentType::KeySig)</a>
<a name="ln2193">            w += score()-&gt;styleP(Sid::keysigLeftMargin);</a>
<a name="ln2194">      else if (st == SegmentType::EndBarLine) {</a>
<a name="ln2195">            if (nst == SegmentType::KeySigAnnounce)</a>
<a name="ln2196">                  w += score()-&gt;styleP(Sid::keysigLeftMargin);</a>
<a name="ln2197">            else if (nst == SegmentType::TimeSigAnnounce)</a>
<a name="ln2198">                  w += score()-&gt;styleP(Sid::timesigLeftMargin);</a>
<a name="ln2199">            else if (nst == SegmentType::Clef)</a>
<a name="ln2200">                  w += score()-&gt;styleP(Sid::clefLeftMargin);</a>
<a name="ln2201">            }</a>
<a name="ln2202">      else if (st == SegmentType::TimeSig &amp;&amp; nst == SegmentType::StartRepeatBarLine)</a>
<a name="ln2203">            w += score()-&gt;styleP(Sid::timesigBarlineDistance);</a>
<a name="ln2204">      else if (st == SegmentType::Breath)</a>
<a name="ln2205">            w += spatium() * 1.5;</a>
<a name="ln2206">      else if (st == SegmentType::Ambitus)</a>
<a name="ln2207">            w += score()-&gt;styleP(Sid::ambitusMargin);</a>
<a name="ln2208"> </a>
<a name="ln2209">      if (w &lt; 0.0)</a>
<a name="ln2210">            w = 0.0;</a>
<a name="ln2211">      if (ns)</a>
<a name="ln2212">            w += ns-&gt;extraLeadingSpace().val() * spatium();</a>
<a name="ln2213">      return w;</a>
<a name="ln2214">      }</a>
<a name="ln2215"> </a>
<a name="ln2216">}           // namespace Ms</a>

</code></pre>
<div class="balloon" rel="644"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 644, 703</p></div>
<div class="balloon" rel="744"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="2089"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'ns' pointer was utilized before it was verified against nullptr. Check lines: 2089, 2099.</p></div>
<div class="balloon" rel="113"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: _stretch.</p></div>
<div class="balloon" rel="120"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> It is possible that not all members of a class are initialized inside the constructor. Consider inspecting: _stretch.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
