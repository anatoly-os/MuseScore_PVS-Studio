
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>bb.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2008-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;libmscore/mscore.h&quot;</a>
<a name="ln14">#include &quot;bb.h&quot;</a>
<a name="ln15">#include &quot;libmscore/score.h&quot;</a>
<a name="ln16">#include &quot;libmscore/part.h&quot;</a>
<a name="ln17">#include &quot;libmscore/staff.h&quot;</a>
<a name="ln18">#include &quot;libmscore/text.h&quot;</a>
<a name="ln19">#include &quot;libmscore/box.h&quot;</a>
<a name="ln20">#include &quot;libmscore/slur.h&quot;</a>
<a name="ln21">#include &quot;libmscore/tie.h&quot;</a>
<a name="ln22">#include &quot;libmscore/note.h&quot;</a>
<a name="ln23">#include &quot;libmscore/chord.h&quot;</a>
<a name="ln24">#include &quot;libmscore/rest.h&quot;</a>
<a name="ln25">#include &quot;libmscore/drumset.h&quot;</a>
<a name="ln26">#include &quot;libmscore/utils.h&quot;</a>
<a name="ln27">#include &quot;libmscore/chordlist.h&quot;</a>
<a name="ln28">#include &quot;libmscore/harmony.h&quot;</a>
<a name="ln29">#include &quot;libmscore/layoutbreak.h&quot;</a>
<a name="ln30">#include &quot;libmscore/key.h&quot;</a>
<a name="ln31">#include &quot;libmscore/pitchspelling.h&quot;</a>
<a name="ln32">#include &quot;libmscore/measure.h&quot;</a>
<a name="ln33">#include &quot;libmscore/segment.h&quot;</a>
<a name="ln34">#include &quot;libmscore/keysig.h&quot;</a>
<a name="ln35"> </a>
<a name="ln36">namespace Ms {</a>
<a name="ln37"> </a>
<a name="ln38">//---------------------------------------------------------</a>
<a name="ln39">//   BBTrack</a>
<a name="ln40">//---------------------------------------------------------</a>
<a name="ln41"> </a>
<a name="ln42">BBTrack::BBTrack(BBFile* f)</a>
<a name="ln43">      {</a>
<a name="ln44">      bb          = f;</a>
<a name="ln45">      _outChannel = -1;</a>
<a name="ln46">      _drumTrack  = false;</a>
<a name="ln47">      }</a>
<a name="ln48"> </a>
<a name="ln49">BBTrack::~BBTrack()</a>
<a name="ln50">      {</a>
<a name="ln51">      }</a>
<a name="ln52"> </a>
<a name="ln53">//---------------------------------------------------------</a>
<a name="ln54">//   MNote</a>
<a name="ln55">//    special Midi Note</a>
<a name="ln56">//---------------------------------------------------------</a>
<a name="ln57"> </a>
<a name="ln58">struct MNote {</a>
<a name="ln59">      Event mc;</a>
<a name="ln60">      QList&lt;Tie*&gt; ties;</a>
<a name="ln61"> </a>
<a name="ln62">      MNote(const Event&amp; _mc) : mc(_mc) {</a>
<a name="ln63">            for (int i = 0; i &lt; mc.notes().size(); ++i)</a>
<a name="ln64">                  ties.append(0);</a>
<a name="ln65">            }</a>
<a name="ln66">      };</a>
<a name="ln67"> </a>
<a name="ln68">//---------------------------------------------------------</a>
<a name="ln69">//   BBFile</a>
<a name="ln70">//---------------------------------------------------------</a>
<a name="ln71"> </a>
<a name="ln72">BBFile::BBFile()</a>
<a name="ln73">      {</a>
<a name="ln74">      for (int i = 0; i &lt; MAX_BARS; ++i)</a>
<a name="ln75">            _barType[i]  = 0;</a>
<a name="ln76">      bbDivision = 120;</a>
<a name="ln77">      }</a>
<a name="ln78"> </a>
<a name="ln79">//---------------------------------------------------------</a>
<a name="ln80">//   BBFile</a>
<a name="ln81">//---------------------------------------------------------</a>
<a name="ln82"> </a>
<a name="ln83">BBFile::~BBFile()</a>
<a name="ln84">      {</a>
<a name="ln85">      }</a>
<a name="ln86"> </a>
<a name="ln87">//---------------------------------------------------------</a>
<a name="ln88">//   read</a>
<a name="ln89">//    return false on error</a>
<a name="ln90">//---------------------------------------------------------</a>
<a name="ln91"> </a>
<a name="ln92">bool BBFile::read(const QString&amp; name)</a>
<a name="ln93">      {</a>
<a name="ln94">      _siglist.clear();</a>
<a name="ln95">      _siglist.add(0, Fraction(4, 4));        // debug</a>
<a name="ln96"> </a>
<a name="ln97">      _path = name;</a>
<a name="ln98">      QFile f(name);</a>
<a name="ln99">      if (!f.open(QIODevice::ReadOnly)) {</a>
<a name="ln100">            return false;</a>
<a name="ln101">            }</a>
<a name="ln102">      ba = f.readAll();</a>
<a name="ln103">      f.close();</a>
<a name="ln104"> </a>
<a name="ln105">      a    = (const unsigned char*) ba.data();</a>
<a name="ln106">      size = ba.size();</a>
<a name="ln107"> </a>
<a name="ln108">      //---------------------------------------------------</a>
<a name="ln109">      //    read version</a>
<a name="ln110">      //---------------------------------------------------</a>
<a name="ln111"> </a>
<a name="ln112">      int idx = 0;</a>
<a name="ln113">      _version = a[idx++];</a>
<a name="ln114">      switch(_version) {</a>
<a name="ln115">            case 0x43:</a>
<a name="ln116">            case 0x44:</a>
<a name="ln117">            case 0x45:</a>
<a name="ln118">            case 0x46:</a>
<a name="ln119">            case 0x47:</a>
<a name="ln120">            case 0x48:</a>
<a name="ln121">            case 0x49:</a>
<a name="ln122">                  break;</a>
<a name="ln123">            default:</a>
<a name="ln124">                  qDebug(&quot;BB: unknown file version %02x&quot;, _version);</a>
<a name="ln125">                  return false;</a>
<a name="ln126">            }</a>
<a name="ln127"> </a>
<a name="ln128">      qDebug(&quot;read &lt;%s&gt; version 0x%02x&quot;, qPrintable(name), _version);</a>
<a name="ln129"> </a>
<a name="ln130">      //---------------------------------------------------</a>
<a name="ln131">      //    read title</a>
<a name="ln132">      //---------------------------------------------------</a>
<a name="ln133"> </a>
<a name="ln134">      int len = a[idx++];</a>
<a name="ln135">      _title  = new char[len+1];</a>
<a name="ln136">      for (int i = 0; i &lt; len; ++i)</a>
<a name="ln137">            _title[i] = a[idx++];</a>
<a name="ln138">      _title[len] = 0;</a>
<a name="ln139"> </a>
<a name="ln140">      //---------------------------------------------------</a>
<a name="ln141">      //    read style(timesig), key and bpm</a>
<a name="ln142">      //---------------------------------------------------</a>
<a name="ln143"> </a>
<a name="ln144">      ++idx;</a>
<a name="ln145">      ++idx;</a>
<a name="ln146">      _style = a[idx++] - 1;</a>
<a name="ln147">      if (_style &lt; 0 || _style &gt;= int(sizeof(styles)/sizeof(*styles))) {</a>
<a name="ln148">            qDebug(&quot;Import bb: unknown style %d&quot;, _style + 1);</a>
<a name="ln149">            return false;</a>
<a name="ln150">            }</a>
<a name="ln151">      _key = a[idx++];</a>
<a name="ln152"> </a>
<a name="ln153">      // map D# G# A#   to Eb Ab Db</a>
<a name="ln154">      // major   C, Db,  D, Eb,  E,  F, Gb,  G, Ab,  A, Bb,  B, C#, D#, F#, G#, A#</a>
<a name="ln155">      // minor   C, Db,  D, Eb,  E,  F, Gb,  G, Ab,  A, Bb,  B, C#, D#, F#, G#, A#</a>
<a name="ln156">      static int kt[] = {</a>
<a name="ln157">           0,    0, -5,  2, -3,  4, -1, -6,  1, -4,  3, -2,  5,  7, -3,  6, -4, -2,</a>
<a name="ln158">                -3, 4,  -1, -6,  1, -4,  3, -2,  5,  0, -5,  2,  4,  6,  3,  5, 7</a>
<a name="ln159">           };</a>
<a name="ln160">      if (_key &gt;= int (sizeof(kt)/sizeof(*kt))) {</a>
<a name="ln161">            qDebug(&quot;bad key %d&quot;, _key);</a>
<a name="ln162">            return false;</a>
<a name="ln163">            }</a>
<a name="ln164">      _key = kt[_key];</a>
<a name="ln165"> </a>
<a name="ln166">      _bpm = a[idx] + (a[idx+1] &lt;&lt; 8);</a>
<a name="ln167">      idx += 2;</a>
<a name="ln168"> </a>
<a name="ln169">      qDebug(&quot;Title &lt;%s&gt;&quot;, _title);</a>
<a name="ln170">      qDebug(&quot;style %d&quot;,   _style);</a>
<a name="ln171">      qDebug(&quot;key   %d&quot;,   _key);</a>
<a name="ln172">      qDebug(&quot;sig   %d/%d&quot;, timesigZ(), timesigN());</a>
<a name="ln173">      qDebug(&quot;bpm   %d&quot;, _bpm);</a>
<a name="ln174"> </a>
<a name="ln175">      //---------------------------------------------------</a>
<a name="ln176">      //    read bar types</a>
<a name="ln177">      //---------------------------------------------------</a>
<a name="ln178"> </a>
<a name="ln179">      int bar = a[idx++];           // starting bar number</a>
<a name="ln180">      while (bar &lt; 255) {</a>
<a name="ln181">            int val = a[idx++];</a>
<a name="ln182">            if (val == 0)</a>
<a name="ln183">                  bar += a[idx++];</a>
<a name="ln184">            else {</a>
<a name="ln185">                  qDebug(&quot;bar type: bar %d val %d&quot;, bar, val);</a>
<a name="ln186">                  _barType[bar++] = val;</a>
<a name="ln187">                  }</a>
<a name="ln188">            }</a>
<a name="ln189"> </a>
<a name="ln190">      //---------------------------------------------------</a>
<a name="ln191">      //    read chord extensions</a>
<a name="ln192">      //---------------------------------------------------</a>
<a name="ln193"> </a>
<a name="ln194">      int beat;</a>
<a name="ln195">      for (beat = 0; beat &lt; MAX_BARS * 4;) {</a>
<a name="ln196">            int val = a[idx++];</a>
<a name="ln197">            if (val == 0)</a>
<a name="ln198">                  beat += a[idx++];</a>
<a name="ln199">            else {</a>
<a name="ln200">                  BBChord c;</a>
<a name="ln201">                  c.extension = val;</a>
<a name="ln202">                  c.beat      = beat * (timesigZ() / timesigN());</a>
<a name="ln203">                  ++beat;</a>
<a name="ln204">                  _chords.append(c);</a>
<a name="ln205">                  }</a>
<a name="ln206">            }</a>
<a name="ln207"> </a>
<a name="ln208">      //---------------------------------------------------</a>
<a name="ln209">      //    read chord root</a>
<a name="ln210">      //---------------------------------------------------</a>
<a name="ln211"> </a>
<a name="ln212">      int roots = 0;</a>
<a name="ln213">      int maxbeat = 0;</a>
<a name="ln214">      for (beat = 0; beat &lt; MAX_BARS * 4;) {</a>
<a name="ln215">            int val = a[idx++];</a>
<a name="ln216">            if (val == 0)</a>
<a name="ln217">                  beat += a[idx++];</a>
<a name="ln218">            else {</a>
<a name="ln219">                  int root = val % 18;</a>
<a name="ln220">                  int bass = (root - 1 + val / 18) % 18 + 1;</a>
<a name="ln221">                  if (root == bass)</a>
<a name="ln222">                        bass = 0;</a>
<a name="ln223">                  int ibeat = beat * (timesigZ() / timesigN());</a>
<a name="ln224">                  if (ibeat != _chords[roots].beat) {</a>
<a name="ln225">                        qDebug(&quot;import bb: inconsistent chord type and root beat&quot;);</a>
<a name="ln226">                        return false;</a>
<a name="ln227">                        }</a>
<a name="ln228">                  _chords[roots].root = root;</a>
<a name="ln229">                  _chords[roots].bass = bass;</a>
<a name="ln230">                  if (maxbeat &lt; beat)</a>
<a name="ln231">                        maxbeat = beat;</a>
<a name="ln232">                  ++roots;</a>
<a name="ln233">                  ++beat;</a>
<a name="ln234">                  }</a>
<a name="ln235">            }</a>
<a name="ln236"> </a>
<a name="ln237">      _measures = ((maxbeat + timesigZ() - 1) / timesigZ()) + 1;</a>
<a name="ln238"> </a>
<a name="ln239">      if (roots != _chords.size()) {</a>
<a name="ln240">            qDebug(&quot;import bb: roots %d != extensions %d&quot;, roots, _chords.size());</a>
<a name="ln241">            return false;</a>
<a name="ln242">            }</a>
<a name="ln243">      qDebug(&quot;Measures %d&quot;, _measures);</a>
<a name="ln244"> </a>
<a name="ln245">#if 0</a>
<a name="ln246">      qDebug(&quot;================chords=======================&quot;);</a>
<a name="ln247">      foreach(BBChord c, _chords) {</a>
<a name="ln248">            qDebug(&quot;chord beat %3d bass %d root %d extension %d&quot;,</a>
<a name="ln249">               c.beat, c.bass, c.root, c.extension);</a>
<a name="ln250">            }</a>
<a name="ln251">      qDebug(&quot;================chords=======================&quot;);</a>
<a name="ln252">#endif</a>
<a name="ln253"> </a>
<a name="ln254">      if (a[idx] == 1) {            //??</a>
<a name="ln255">            qDebug(&quot;Skip 0x%02x at 0x%04x&quot;, a[idx], idx);</a>
<a name="ln256">            ++idx;</a>
<a name="ln257">            }</a>
<a name="ln258"> </a>
<a name="ln259">      _startChorus = a[idx++];</a>
<a name="ln260">      _endChorus   = a[idx++];</a>
<a name="ln261">      _repeats     = a[idx++];</a>
<a name="ln262"> </a>
<a name="ln263">      qDebug(&quot;start chorus %d  end chorus %d repeats %d, pos now 0x%x&quot;,</a>
<a name="ln264">         _startChorus, _endChorus, _repeats, idx);</a>
<a name="ln265"> </a>
<a name="ln266">      if (_startChorus &gt;= _endChorus) {</a>
<a name="ln267">            _startChorus = 0;</a>
<a name="ln268">            _endChorus = 0;</a>
<a name="ln269">            _repeats = 1;</a>
<a name="ln270">            }</a>
<a name="ln271"> </a>
<a name="ln272">      //---------------------------------------------------</a>
<a name="ln273">      //    read style file</a>
<a name="ln274">      //---------------------------------------------------</a>
<a name="ln275"> </a>
<a name="ln276">      bool found = false;</a>
<a name="ln277">      for (int i = idx; i &lt; size; ++i) {</a>
<a name="ln278">            if (a[i] == 0x42) {</a>
<a name="ln279">                  if (a[i+1] &lt; 16) {</a>
<a name="ln280">                        for (int k = i+2; k &lt; (i+18); ++k) {</a>
<a name="ln281">                              if (a[k] == '.' &amp;&amp; a[k+1] == 'S' &amp;&amp; a[k+2] == 'T' &amp;&amp; a[k+3] == 'Y') {</a>
<a name="ln282">                                    found = true;</a>
<a name="ln283">                                    break;</a>
<a name="ln284">                                    }</a>
<a name="ln285">                              }</a>
<a name="ln286">                        }</a>
<a name="ln287">                  if (found) {</a>
<a name="ln288">                        idx = i + 1;</a>
<a name="ln289">                        break;</a>
<a name="ln290">                        }</a>
<a name="ln291">                  }</a>
<a name="ln292">            }</a>
<a name="ln293">      if (!found) {</a>
<a name="ln294">            qDebug(&quot;import bb: style file not found&quot;);</a>
<a name="ln295">            return false;</a>
<a name="ln296">            }</a>
<a name="ln297"> </a>
<a name="ln298">      qDebug(&quot;read styleName at 0x%x&quot;, idx);</a>
<a name="ln299">      len = a[idx++];</a>
<a name="ln300">      _styleName = new char[len+1];</a>
<a name="ln301"> </a>
<a name="ln302">      for (int i = 0; i &lt; len; ++i)</a>
<a name="ln303">            _styleName[i] = a[idx++];</a>
<a name="ln304">      _styleName[len] = 0;</a>
<a name="ln305"> </a>
<a name="ln306">      qDebug(&quot;style name &lt;%s&gt;&quot;, _styleName);</a>
<a name="ln307"> </a>
<a name="ln308">      // read midi events</a>
<a name="ln309">      int eventStart = a[size-4] + a[size-3] * 256;</a>
<a name="ln310">      int eventCount = a[size-2] + a[size-1] * 256;</a>
<a name="ln311"> </a>
<a name="ln312">      Fraction endTick = Fraction::fromTicks(_measures * bbDivision * 4 * timesigZ() / timesigN());</a>
<a name="ln313"> </a>
<a name="ln314">      if (eventCount == 0) {</a>
<a name="ln315">            qDebug(&quot;no melody&quot;);</a>
<a name="ln316">            return true;</a>
<a name="ln317">            }</a>
<a name="ln318">      else {</a>
<a name="ln319">            idx = eventStart;</a>
<a name="ln320">            qDebug(&quot;melody found at 0x%x&quot;, idx);</a>
<a name="ln321">            int i = 0;</a>
<a name="ln322">            int lastLen = 0;</a>
<a name="ln323">            for (i = 0; i &lt; eventCount; ++i, idx+=12) {</a>
<a name="ln324">                  int type = a[idx + 4] &amp; 0xf0;</a>
<a name="ln325">                  if (type == 0x90) {</a>
<a name="ln326">                        int channel = a[idx + 7];</a>
<a name="ln327">                        BBTrack* track = 0;</a>
<a name="ln328">                        foreach (BBTrack* t, _tracks) {</a>
<a name="ln329">                              if (t-&gt;outChannel() == channel) {</a>
<a name="ln330">                                    track = t;</a>
<a name="ln331">                                    break;</a>
<a name="ln332">                                    }</a>
<a name="ln333">                              }</a>
<a name="ln334">                        if (track == 0) {</a>
<a name="ln335">                              track = new BBTrack(this);</a>
<a name="ln336">                              track-&gt;setOutChannel(channel);</a>
<a name="ln337">                              _tracks.append(track);</a>
<a name="ln338">                              }</a>
<a name="ln339">                        Fraction tick = Fraction::fromTicks(a[idx] + (a[idx+1]&lt;&lt;8) + (a[idx+2]&lt;&lt;16) + (a[idx+3]&lt;&lt;24));</a>
<a name="ln340">                        tick -= Fraction::fromTicks(4 * bbDivision);</a>
<a name="ln341">                        if (tick &gt;= endTick) {</a>
<a name="ln342">                              qDebug(&quot;event tick %d &gt; %d&quot;, tick.ticks(), endTick.ticks());</a>
<a name="ln343">                              continue;</a>
<a name="ln344">                              }</a>
<a name="ln345">                        Event note(ME_NOTE);</a>
<a name="ln346">                        note.setOntime((tick.ticks() * MScore::division) / bbDivision);</a>
<a name="ln347">                        note.setPitch(a[idx + 5]);</a>
<a name="ln348">                        note.setVelo(a[idx + 6]);</a>
<a name="ln349">                        note.setChannel(channel);</a>
<a name="ln350">                        int len1 = a[idx+8] + (a[idx+9]&lt;&lt;8) + (a[idx+10]&lt;&lt;16) + (a[idx+11]&lt;&lt;24);</a>
<a name="ln351">                        if (len1 == 0) {</a>
<a name="ln352">                              if (lastLen == 0) {</a>
<a name="ln353">                                    qDebug(&quot;note event of len 0 at idx %04x&quot;, idx);</a>
<a name="ln354">                                    continue;</a>
<a name="ln355">                                    }</a>
<a name="ln356">                              len1 = lastLen;</a>
<a name="ln357">                              }</a>
<a name="ln358">                        lastLen = len1;</a>
<a name="ln359">                        note.setDuration((len1 * MScore::division) / bbDivision);</a>
<a name="ln360">                        track-&gt;append(note);</a>
<a name="ln361">                        }</a>
<a name="ln362">                  else if (type == 0xb0 || type == 0xc0) {</a>
<a name="ln363">                        // ignore controller</a>
<a name="ln364">                        }</a>
<a name="ln365">                  else if (type == 0)</a>
<a name="ln366">                        break;</a>
<a name="ln367">                  else {</a>
<a name="ln368">                        qDebug(&quot;unknown event type 0x%02x at x%04x&quot;, a[idx + 4], idx);</a>
<a name="ln369">                        break;</a>
<a name="ln370">                        }</a>
<a name="ln371">                  }</a>
<a name="ln372">            qDebug(&quot;Events found x%02x (%d)&quot;, i, i);</a>
<a name="ln373">            }</a>
<a name="ln374">      return true;</a>
<a name="ln375">      }</a>
<a name="ln376"> </a>
<a name="ln377">//---------------------------------------------------------</a>
<a name="ln378">//   importBB</a>
<a name="ln379">//    return true on success</a>
<a name="ln380">//---------------------------------------------------------</a>
<a name="ln381"> </a>
<a name="ln382">Score::FileError importBB(MasterScore* score, const QString&amp; name)</a>
<a name="ln383">      {</a>
<a name="ln384">      BBFile bb;</a>
<a name="ln385">      if(!QFileInfo(name).exists())</a>
<a name="ln386">            return Score::FileError::FILE_NOT_FOUND;</a>
<a name="ln387">      if (!bb.read(name)) {</a>
<a name="ln388">            qDebug(&quot;Cannot open file &lt;%s&gt;&quot;, qPrintable(name));</a>
<a name="ln389">            return Score::FileError::FILE_OPEN_ERROR;</a>
<a name="ln390">            }</a>
<a name="ln391">      score-&gt;style().set(Sid::chordsXmlFile, true);</a>
<a name="ln392">      score-&gt;style().chordList()-&gt;read(&quot;chords.xml&quot;);</a>
<a name="ln393">      *(score-&gt;sigmap()) = bb.siglist();</a>
<a name="ln394"> </a>
<a name="ln395">      QList&lt;BBTrack*&gt;* tracks = bb.tracks();</a>
<a name="ln396">      int ntracks = tracks-&gt;size();</a>
<a name="ln397">      if (ntracks == 0)             // no events?</a>
<a name="ln398">            ntracks = 1;</a>
<a name="ln399">      for (int i = 0; i &lt; ntracks; ++i) {</a>
<a name="ln400">            Part* part = new Part(score);</a>
<a name="ln401">            Staff* s   = new Staff(score);</a>
<a name="ln402">            s-&gt;setPart(part);</a>
<a name="ln403">            part-&gt;insertStaff(s, 0);</a>
<a name="ln404">            score-&gt;staves().append(s);</a>
<a name="ln405">            score-&gt;appendPart(part);</a>
<a name="ln406">            }</a>
<a name="ln407"> </a>
<a name="ln408">      //---------------------------------------------------</a>
<a name="ln409">      //  create measures</a>
<a name="ln410">      //---------------------------------------------------</a>
<a name="ln411"> </a>
<a name="ln412">      for (int i = 0; i &lt; bb.measures(); ++i) {</a>
<a name="ln413">            Measure* measure  = new Measure(score);</a>
<a name="ln414">            Fraction tick = Fraction::fromTicks(score-&gt;sigmap()-&gt;bar2tick(i, 0));</a>
<a name="ln415">            measure-&gt;setTick(tick);</a>
<a name="ln416">            Fraction ts = score-&gt;sigmap()-&gt;timesig(tick.ticks()).timesig();</a>
<a name="ln417">            measure-&gt;setTimesig(ts);</a>
<a name="ln418">            measure-&gt;setTicks(ts);</a>
<a name="ln419">            score-&gt;measures()-&gt;add(measure);</a>
<a name="ln420">            }</a>
<a name="ln421"> </a>
<a name="ln422">      //---------------------------------------------------</a>
<a name="ln423">      //  create notes</a>
<a name="ln424">      //---------------------------------------------------</a>
<a name="ln425"> </a>
<a name="ln426">      foreach (BBTrack* track, *tracks)</a>
<a name="ln427">            track-&gt;cleanup();</a>
<a name="ln428"> </a>
<a name="ln429">      if (tracks-&gt;isEmpty()) {</a>
<a name="ln430">            for (MeasureBase* mb = score-&gt;first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln431">                  if (mb-&gt;type() != ElementType::MEASURE)</a>
<a name="ln432">                        continue;</a>
<a name="ln433">                  Measure* measure = (Measure*)mb;</a>
<a name="ln434">                  Rest* rest = new Rest(score, TDuration(TDuration::DurationType::V_MEASURE));</a>
<a name="ln435">                  rest-&gt;setTicks(measure-&gt;ticks());</a>
<a name="ln436">                  rest-&gt;setTrack(0);</a>
<a name="ln437">                  Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln438">                  s-&gt;add(rest);</a>
<a name="ln439">                  }</a>
<a name="ln440">            }</a>
<a name="ln441">      else {</a>
<a name="ln442">            int staffIdx = 0;</a>
<a name="ln443">            foreach (BBTrack* track, *tracks)</a>
<a name="ln444">                  bb.convertTrack(score, track, staffIdx++);</a>
<a name="ln445">            }</a>
<a name="ln446"> </a>
<a name="ln447">      for (MeasureBase* mb = score-&gt;first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln448">            if (mb-&gt;type() != ElementType::MEASURE)</a>
<a name="ln449">                  continue;</a>
<a name="ln450">            Measure* measure = (Measure*)mb;</a>
<a name="ln451">            Segment* s = measure-&gt;findSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln452">            if (s == 0) {</a>
<a name="ln453">                  Rest* rest = new Rest(score, TDuration(TDuration::DurationType::V_MEASURE));</a>
<a name="ln454">                  rest-&gt;setTicks(measure-&gt;ticks());</a>
<a name="ln455">                  rest-&gt;setTrack(0);</a>
<a name="ln456">                  Segment* s1 = measure-&gt;getSegment(SegmentType::ChordRest, measure-&gt;tick());</a>
<a name="ln457">                  s1-&gt;add(rest);</a>
<a name="ln458">                  }</a>
<a name="ln459">            }</a>
<a name="ln460"> </a>
<a name="ln461">      score-&gt;spell();</a>
<a name="ln462"> </a>
<a name="ln463">      //---------------------------------------------------</a>
<a name="ln464">      //    create title</a>
<a name="ln465">      //---------------------------------------------------</a>
<a name="ln466"> </a>
<a name="ln467">      Text* text = new Text(score, Tid::TITLE);</a>
<a name="ln468">      text-&gt;setPlainText(bb.title());</a>
<a name="ln469"> </a>
<a name="ln470">      MeasureBase* measureB = score-&gt;first();</a>
<a name="ln471">      if (measureB-&gt;type() != ElementType::VBOX) {</a>
<a name="ln472">            measureB = new VBox(score);</a>
<a name="ln473">            measureB-&gt;setTick(Fraction(0,1));</a>
<a name="ln474">            measureB-&gt;setNext(score-&gt;first());</a>
<a name="ln475">            score-&gt;measures()-&gt;add(measureB);</a>
<a name="ln476">            }</a>
<a name="ln477">      measureB-&gt;add(text);</a>
<a name="ln478"> </a>
<a name="ln479">      //---------------------------------------------------</a>
<a name="ln480">      //    create chord symbols</a>
<a name="ln481">      //---------------------------------------------------</a>
<a name="ln482"> </a>
<a name="ln483">      static const int table[] = {</a>
<a name="ln484">          //C  Db, D,  Eb,  E, F, Gb, G,  Ab, A,  Bb, B,  C#, D#, F#  G#  A#</a>
<a name="ln485">            14, 9, 16, 11, 18, 13, 8, 15, 10, 17, 12, 19, 21, 23, 20, 22, 24</a>
<a name="ln486">            };</a>
<a name="ln487">      foreach(const BBChord&amp; c, bb.chords()) {</a>
<a name="ln488">            Fraction tick = Fraction(c.beat, 4);      // c.beat  * MScore::division;</a>
<a name="ln489">// qDebug(&quot;CHORD %d %d&quot;, c.beat, tick);</a>
<a name="ln490">            Measure* m = score-&gt;tick2measure(tick);</a>
<a name="ln491">            if (m == 0) {</a>
<a name="ln492">                  qDebug(&quot;import BB: measure for tick %d not found&quot;, tick.ticks());</a>
<a name="ln493">                  continue;</a>
<a name="ln494">                  }</a>
<a name="ln495">            Segment* s = m-&gt;getSegment(SegmentType::ChordRest, tick);</a>
<a name="ln496">            Harmony* h = new Harmony(score);</a>
<a name="ln497">            h-&gt;setTrack(0);</a>
<a name="ln498">            h-&gt;setRootTpc(table[c.root-1]);</a>
<a name="ln499">            if (c.bass &gt; 0)</a>
<a name="ln500">                  h-&gt;setBaseTpc(table[c.bass-1]);</a>
<a name="ln501">            else</a>
<a name="ln502">                  h-&gt;setBaseTpc(Tpc::TPC_INVALID);</a>
<a name="ln503">            h-&gt;setId(c.extension);</a>
<a name="ln504">            h-&gt;getDescription();</a>
<a name="ln505">            h-&gt;render();</a>
<a name="ln506">            s-&gt;add(h);</a>
<a name="ln507">            }</a>
<a name="ln508"> </a>
<a name="ln509">      //---------------------------------------------------</a>
<a name="ln510">      //    insert layout breaks</a>
<a name="ln511">      //    add chorus repeat</a>
<a name="ln512">      //---------------------------------------------------</a>
<a name="ln513"> </a>
<a name="ln514">      int startChorus = bb.startChorus() - 1;</a>
<a name="ln515">      int endChorus   = bb.endChorus() - 1;</a>
<a name="ln516"> </a>
<a name="ln517">      int n = 0;</a>
<a name="ln518">      for (MeasureBase* mb = score-&gt;first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln519">            if (mb-&gt;type() != ElementType::MEASURE)</a>
<a name="ln520">                  continue;</a>
<a name="ln521">            Measure* measure = (Measure*)mb;</a>
<a name="ln522">            if (n &amp;&amp; (n % 4) == 0) {</a>
<a name="ln523">                  LayoutBreak* lb = new LayoutBreak(score);</a>
<a name="ln524">                  lb-&gt;setLayoutBreakType(LayoutBreak::Type::LINE);</a>
<a name="ln525">                  measure-&gt;add(lb);</a>
<a name="ln526">                  }</a>
<a name="ln527">            if (startChorus == n)</a>
<a name="ln528">                  measure-&gt;setRepeatStart(true);</a>
<a name="ln529">            else if (endChorus == n) {</a>
<a name="ln530">                  measure-&gt;setRepeatEnd(true);</a>
<a name="ln531">                  measure-&gt;setRepeatCount(bb.repeats());</a>
<a name="ln532">                  }</a>
<a name="ln533">            ++n;</a>
<a name="ln534">            }</a>
<a name="ln535"> </a>
<a name="ln536">      foreach(Staff* staff, score-&gt;staves()) {</a>
<a name="ln537">            Fraction tick = Fraction(0,1);</a>
<a name="ln538">            KeySigEvent ke;</a>
<a name="ln539">            ke.setKey(Key(bb.key()));</a>
<a name="ln540">            staff-&gt;setKey(tick, ke);</a>
<a name="ln541">            KeySig* keysig = new KeySig(score);</a>
<a name="ln542">            keysig-&gt;setTrack((score-&gt;staffIdx(staff-&gt;part()) + staff-&gt;rstaff()) * VOICES);</a>
<a name="ln543">            keysig-&gt;setKey(Key(bb.key()));</a>
<a name="ln544">            Measure* mks = score-&gt;tick2measure(tick);</a>
<a name="ln545">            Segment* sks = mks-&gt;getSegment(SegmentType::KeySig, tick);</a>
<a name="ln546">            sks-&gt;add(keysig);</a>
<a name="ln547">            }</a>
<a name="ln548">      score-&gt;fixTicks();</a>
<a name="ln549">      return Score::FileError::FILE_NO_ERROR;</a>
<a name="ln550">      }</a>
<a name="ln551"> </a>
<a name="ln552">//---------------------------------------------------------</a>
<a name="ln553">//   processPendingNotes</a>
<a name="ln554">//---------------------------------------------------------</a>
<a name="ln555"> </a>
<a name="ln556">Fraction BBFile::processPendingNotes(Score* score, QList&lt;MNote*&gt;* notes, const Fraction&amp; l, int track)</a>
<a name="ln557">      {</a>
<a name="ln558">      Fraction len(l);</a>
<a name="ln559">      Staff* cstaff                = score-&gt;staff(track/VOICES);</a>
<a name="ln560">      const Instrument* instrument = cstaff-&gt;part()-&gt;instrument();</a>
<a name="ln561">      const Drumset* drumset       = instrument-&gt;drumset();</a>
<a name="ln562">      bool useDrumset              = instrument-&gt;useDrumset();</a>
<a name="ln563">      Fraction tick                = Fraction::fromTicks(notes-&gt;at(0)-&gt;mc.ontime());</a>
<a name="ln564"> </a>
<a name="ln565">      //</a>
<a name="ln566">      // look for len of shortest note</a>
<a name="ln567">      //</a>
<a name="ln568">      foreach (const MNote* n, *notes) {</a>
<a name="ln569">            if (n-&gt;mc.duration() &lt; len.ticks())</a>
<a name="ln570">                  len = Fraction::fromTicks(n-&gt;mc.duration());</a>
<a name="ln571">            }</a>
<a name="ln572"> </a>
<a name="ln573">      //</a>
<a name="ln574">      // split notes on measure boundary</a>
<a name="ln575">      //</a>
<a name="ln576">      Measure* measure = score-&gt;tick2measure(tick);</a>
<a name="ln577">      if (measure == 0 || (tick &gt;= measure-&gt;endTick())) {</a>
<a name="ln578">            qDebug(&quot;no measure found for tick %d&quot;, tick.ticks());</a>
<a name="ln579">            notes-&gt;clear();</a>
<a name="ln580">            return len;</a>
<a name="ln581">            }</a>
<a name="ln582">      if ((tick + len) &gt; measure-&gt;endTick())</a>
<a name="ln583">            len = measure-&gt;endTick() - tick;</a>
<a name="ln584"> </a>
<a name="ln585">      Chord* chord = new Chord(score);</a>
<a name="ln586">      chord-&gt;setTrack(track);</a>
<a name="ln587">      TDuration d;</a>
<a name="ln588">      d.setVal(len.ticks());</a>
<a name="ln589">      chord-&gt;setDurationType(d);</a>
<a name="ln590">      chord-&gt;setTicks(d.fraction());</a>
<a name="ln591">      Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, tick);</a>
<a name="ln592">      s-&gt;add(chord);</a>
<a name="ln593"> </a>
<a name="ln594">      foreach (MNote* n, *notes) {</a>
<a name="ln595">            QList&lt;Event&gt;&amp; nl = n-&gt;mc.notes();</a>
<a name="ln596">            for (int i = 0; i &lt; nl.size(); ++i) {</a>
<a name="ln597">                  const Event&amp; mn = nl[i];</a>
<a name="ln598">                  Note* note = new Note(score);</a>
<a name="ln599">                  note-&gt;setPitch(mn.pitch(), mn.tpc(), mn.tpc());</a>
<a name="ln600">                  note-&gt;setTrack(track);</a>
<a name="ln601">                  chord-&gt;add(note);</a>
<a name="ln602"> </a>
<a name="ln603">                  if (useDrumset) {</a>
<a name="ln604">                        if (!drumset-&gt;isValid(mn.pitch())) {</a>
<a name="ln605">                              qDebug(&quot;unmapped drum note 0x%02x %d&quot;, mn.pitch(), mn.pitch());</a>
<a name="ln606">                              }</a>
<a name="ln607">                        else {</a>
<a name="ln608">                              chord-&gt;setStemDirection(drumset-&gt;stemDirection(mn.pitch()));</a>
<a name="ln609">                              }</a>
<a name="ln610">                        }</a>
<a name="ln611">                  if (n-&gt;ties[i]) {</a>
<a name="ln612">                        n-&gt;ties[i]-&gt;setEndNote(note);</a>
<a name="ln613">                        n-&gt;ties[i]-&gt;setTrack(note-&gt;track());</a>
<a name="ln614">                        note-&gt;setTieBack(n-&gt;ties[i]);</a>
<a name="ln615">                        }</a>
<a name="ln616">                  }</a>
<a name="ln617">            if (n-&gt;mc.duration() &lt;= len.ticks()) {</a>
<a name="ln618">                  notes-&gt;removeAt(notes-&gt;indexOf(n));</a>
<a name="ln619">                  continue;</a>
<a name="ln620">                  }</a>
<a name="ln621">            for (int i = 0; i &lt; nl.size(); ++i) {</a>
<a name="ln622">                  const Event&amp; mn = nl[i];</a>
<a name="ln623">                  Note* note = chord-&gt;findNote(mn.pitch());</a>
<a name="ln624">                  n-&gt;ties[i] = new Tie(score);</a>
<a name="ln625">                  n-&gt;ties[i]-&gt;setStartNote(note);</a>
<a name="ln626">                  note-&gt;setTieFor(n-&gt;ties[i]);</a>
<a name="ln627">                  }</a>
<a name="ln628">            n-&gt;mc.setOntime(n-&gt;mc.ontime() + len.ticks());</a>
<a name="ln629">            n-&gt;mc.setLen(n-&gt;mc.duration() - len.ticks());</a>
<a name="ln630">            }</a>
<a name="ln631">      return len;</a>
<a name="ln632">      }</a>
<a name="ln633"> </a>
<a name="ln634">//---------------------------------------------------------</a>
<a name="ln635">//   collectNotes</a>
<a name="ln636">//---------------------------------------------------------</a>
<a name="ln637"> </a>
<a name="ln638">static ciEvent collectNotes(const Fraction&amp; tick, int voice, ciEvent i, const EventList* el, QList&lt;MNote*&gt;* notes)</a>
<a name="ln639">      {</a>
<a name="ln640">      for (;i != el-&gt;end(); ++i) {</a>
<a name="ln641">            const Event&amp; e = *i;</a>
<a name="ln642">            if (e.type() != ME_CHORD)</a>
<a name="ln643">                  continue;</a>
<a name="ln644">            if (e.voice() != voice)</a>
<a name="ln645">                  continue;</a>
<a name="ln646">            if (e.ontime() &gt; tick.ticks())</a>
<a name="ln647">                  break;</a>
<a name="ln648">            if (e.ontime() &lt; tick.ticks())</a>
<a name="ln649">                  continue;</a>
<a name="ln650">            MNote* n = new MNote(e);</a>
<a name="ln651">            notes-&gt;append(n);</a>
<a name="ln652">            }</a>
<a name="ln653">      return i;</a>
<a name="ln654">      }</a>
<a name="ln655"> </a>
<a name="ln656">//---------------------------------------------------------</a>
<a name="ln657">//   convertTrack</a>
<a name="ln658">//---------------------------------------------------------</a>
<a name="ln659"> </a>
<a name="ln660">void BBFile::convertTrack(Score* score, BBTrack* track, int staffIdx)</a>
<a name="ln661">      {</a>
<a name="ln662">      track-&gt;findChords();</a>
<a name="ln663">      int voices         = track-&gt;separateVoices(2);</a>
<a name="ln664">      const EventList el = track-&gt;events();</a>
<a name="ln665"> </a>
<a name="ln666">      for (int voice = 0; voice &lt; voices; ++voice) {</a>
<a name="ln667">            int tr = staffIdx * VOICES + voice;</a>
<a name="ln668">            QList&lt;MNote*&gt; notes;</a>
<a name="ln669"> </a>
<a name="ln670">            Fraction ctick = Fraction(0,1);</a>
<a name="ln671">            ciEvent i = collectNotes(ctick, voice, el.begin(), &amp;el, &amp;notes);</a>
<a name="ln672"> </a>
<a name="ln673">            for (; i != el.end();) {</a>
<a name="ln674">                  const Event&amp; e = *i;</a>
<a name="ln675">                  if (e.type() != ME_CHORD || e.voice() != voice) {</a>
<a name="ln676">                        ++i;</a>
<a name="ln677">                        continue;</a>
<a name="ln678">                        }</a>
<a name="ln679">                  //</a>
<a name="ln680">                  // process pending notes</a>
<a name="ln681">                  //</a>
<a name="ln682">                  Fraction restLen = Fraction::fromTicks(e.ontime()) - ctick;</a>
<a name="ln683">// qDebug(&quot;ctick %d  rest %d ontick %d size %d&quot;, ctick, restLen, e.ontime(), notes.size());</a>
<a name="ln684"> </a>
<a name="ln685">                  if (restLen &lt;= Fraction(0,1))</a>
<a name="ln686">                        qFatal(&quot;bad restlen ontime %d - ctick %d&quot;, e.ontime(), ctick.ticks());</a>
<a name="ln687"> </a>
<a name="ln688">                  while (!notes.isEmpty()) {</a>
<a name="ln689">                        Fraction len = processPendingNotes(score, &amp;notes, restLen, tr);</a>
<a name="ln690">                        if (len.isZero()) {</a>
<a name="ln691">                              qDebug(&quot;processPendingNotes returns zero, restlen %d, track %d&quot;, restLen.ticks(), tr);</a>
<a name="ln692">                              ctick += restLen;</a>
<a name="ln693">                              restLen = Fraction(0,1);</a>
<a name="ln694">                              break;</a>
<a name="ln695">                              }</a>
<a name="ln696">                        ctick += len;</a>
<a name="ln697">                        restLen -= len;</a>
<a name="ln698">                        }</a>
<a name="ln699">// qDebug(&quot;  1.ctick %d  rest %d&quot;, ctick, restLen);</a>
<a name="ln700">                  //</a>
<a name="ln701">                  // check for gap and fill with rest</a>
<a name="ln702">                  //</a>
<a name="ln703">                  if (voice == 0) {</a>
<a name="ln704">                        while (restLen &gt; Fraction(0,1)) {</a>
<a name="ln705">                              Fraction len = restLen;</a>
<a name="ln706">                              Measure* measure = score-&gt;tick2measure(ctick);</a>
<a name="ln707">                              if (measure == 0 || (ctick &gt;= measure-&gt;endTick())) {       // at end?</a>
<a name="ln708">                                    ctick += len;</a>
<a name="ln709">                                    restLen -= len;</a>
<a name="ln710">                                    break;</a>
<a name="ln711">                                    }</a>
<a name="ln712">                              // split rest on measure boundary</a>
<a name="ln713">                              if ((ctick + len) &gt; measure-&gt;endTick()) {</a>
<a name="ln714">                                    len = measure-&gt;endTick() - ctick;</a>
<a name="ln715">                                    if (len &lt;= Fraction(0,1)) {</a>
<a name="ln716">                                          qDebug(&quot;bad len %d&quot;, len.ticks());</a>
<a name="ln717">                                          break;</a>
<a name="ln718">                                          }</a>
<a name="ln719">                                    }</a>
<a name="ln720">                              TDuration d;</a>
<a name="ln721">                              d.setVal(len.ticks());</a>
<a name="ln722">                              Rest* rest = new Rest(score, d);</a>
<a name="ln723">                              rest-&gt;setTicks(d.fraction());</a>
<a name="ln724">                              rest-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln725">                              Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, ctick);</a>
<a name="ln726">                              s-&gt;add(rest);</a>
<a name="ln727">// qDebug(&quot;   add rest %d&quot;, len);</a>
<a name="ln728"> </a>
<a name="ln729">                              ctick   += len;</a>
<a name="ln730">                              restLen -= len;</a>
<a name="ln731">                              }</a>
<a name="ln732">                        }</a>
<a name="ln733">                  else</a>
<a name="ln734">                        ctick += restLen;</a>
<a name="ln735"> </a>
<a name="ln736">// qDebug(&quot;  2.ctick %d  rest %d&quot;, ctick, restLen);</a>
<a name="ln737">                  //</a>
<a name="ln738">                  // collect all notes at ctick</a>
<a name="ln739">                  //</a>
<a name="ln740">                  i = collectNotes(ctick, voice, i, &amp;el, &amp;notes);</a>
<a name="ln741">                  }</a>
<a name="ln742"> </a>
<a name="ln743">            //</a>
<a name="ln744">            // process pending notes</a>
<a name="ln745">            //</a>
<a name="ln746">            while (!notes.isEmpty()) {</a>
<a name="ln747">                  Fraction len = processPendingNotes(score, &amp;notes, Fraction(0x7fffffff,1), tr);</a>
<a name="ln748">                  ctick += len;</a>
<a name="ln749">                  }</a>
<a name="ln750">            if (voice == 0) {</a>
<a name="ln751">                  Measure* measure = score-&gt;tick2measure(ctick);</a>
<a name="ln752">                  if (measure &amp;&amp; (ctick &lt; measure-&gt;endTick())) {       // at end?</a>
<a name="ln753">                        TDuration d;</a>
<a name="ln754">                        d.setVal((measure-&gt;endTick() - ctick).ticks());</a>
<a name="ln755">                        Rest* rest = new Rest(score, d);</a>
<a name="ln756">                        rest-&gt;setTicks(d.fraction());</a>
<a name="ln757">                        rest-&gt;setTrack(staffIdx * VOICES);</a>
<a name="ln758">                        Segment* s = measure-&gt;getSegment(SegmentType::ChordRest, ctick);</a>
<a name="ln759">                        s-&gt;add(rest);</a>
<a name="ln760">                        }</a>
<a name="ln761">                  }</a>
<a name="ln762">            }</a>
<a name="ln763">      }</a>
<a name="ln764"> </a>
<a name="ln765">//---------------------------------------------------------</a>
<a name="ln766">//   quantize</a>
<a name="ln767">//    process one segment (measure)</a>
<a name="ln768">//---------------------------------------------------------</a>
<a name="ln769"> </a>
<a name="ln770">void BBTrack::quantize(int startTick, int endTick, EventList* dst)</a>
<a name="ln771">      {</a>
<a name="ln772">      int mintick = MScore::division * 64;</a>
<a name="ln773">      iEvent i = _events.begin();</a>
<a name="ln774">      for (; i != _events.end(); ++i) {</a>
<a name="ln775">            if (i-&gt;ontime() &gt;= startTick)</a>
<a name="ln776">                  break;</a>
<a name="ln777">            }</a>
<a name="ln778">      iEvent si = i;</a>
<a name="ln779">      for (; i != _events.end(); ++i) {</a>
<a name="ln780">            const Event&amp; e = *i;</a>
<a name="ln781">            if (e.ontime() &gt;= endTick)</a>
<a name="ln782">                  break;</a>
<a name="ln783">            if (e.type() == ME_NOTE &amp;&amp; (e.duration() &lt; mintick))</a>
<a name="ln784">                  mintick = e.duration();</a>
<a name="ln785">            }</a>
<a name="ln786">      if (mintick &lt;= MScore::division / 16)        // minimum duration is 1/64</a>
<a name="ln787">            mintick = MScore::division / 16;</a>
<a name="ln788">      else if (mintick &lt;= MScore::division / 8)</a>
<a name="ln789">            mintick = MScore::division / 8;</a>
<a name="ln790">      else if (mintick &lt;= MScore::division / 4)</a>
<a name="ln791">            mintick = MScore::division / 4;</a>
<a name="ln792">      else if (mintick &lt;= MScore::division / 2)</a>
<a name="ln793">            mintick = MScore::division / 2;</a>
<a name="ln794">      else if (mintick &lt;= MScore::division)</a>
<a name="ln795">            mintick = MScore::division;</a>
<a name="ln796">      else if (mintick &lt;= MScore::division * 2)</a>
<a name="ln797">            mintick = MScore::division * 2;</a>
<a name="ln798">      else if (mintick &lt;= MScore::division * 4)</a>
<a name="ln799">            mintick = MScore::division * 4;</a>
<a name="ln800">      else if (mintick &lt;= MScore::division * 8)</a>
<a name="ln801">            mintick = MScore::division * 8;</a>
<a name="ln802">      int raster;</a>
<a name="ln803">      if (mintick &gt; MScore::division)</a>
<a name="ln804">            raster = MScore::division;</a>
<a name="ln805">      else</a>
<a name="ln806">            raster = mintick;</a>
<a name="ln807"> </a>
<a name="ln808">      //</a>
<a name="ln809">      //  quantize onset</a>
<a name="ln810">      //</a>
<a name="ln811">      for (i = si; i != _events.end(); ++i) {</a>
<a name="ln812">            Event e = *i;</a>
<a name="ln813">            if (e.ontime() &gt;= endTick)</a>
<a name="ln814">                  break;</a>
<a name="ln815">            if (e.type() == ME_NOTE) {</a>
<a name="ln816">                  // prefer moving note to the right</a>
<a name="ln817">                  int tick = ((e.ontime() + raster/2) / raster) * raster;</a>
<a name="ln818">                  int diff = tick - e.ontime();</a>
<a name="ln819">                  int len  = e.duration() - diff;</a>
<a name="ln820">                  e.setOntime(tick);</a>
<a name="ln821">                  e.setLen(len);</a>
<a name="ln822">                  }</a>
<a name="ln823">            dst-&gt;insert(e);</a>
<a name="ln824">            }</a>
<a name="ln825">      //</a>
<a name="ln826">      //  quantize duration</a>
<a name="ln827">      //</a>
<a name="ln828">      for (i = dst-&gt;begin(); i != dst-&gt;end(); ++i) {</a>
<a name="ln829">            Event&amp; e = *i;</a>
<a name="ln830">            if (e.type() != ME_NOTE)</a>
<a name="ln831">                  continue;</a>
<a name="ln832">            int tick   = e.ontime();</a>
<a name="ln833">            int len    = e.duration();</a>
<a name="ln834">            int ntick  = tick + len;</a>
<a name="ln835">            int nntick = -1;</a>
<a name="ln836">            for (iEvent ii = (i+1); ii != dst-&gt;end(); ++ii) {</a>
<a name="ln837">                  if (ii-&gt;type() == ME_NOTE) {</a>
<a name="ln838">                        const Event&amp; ee = *ii;</a>
<a name="ln839">                        if (ee.ontime() == tick)</a>
<a name="ln840">                              continue;</a>
<a name="ln841">                        nntick = ee.ontime();</a>
<a name="ln842">                        break;</a>
<a name="ln843">                        }</a>
<a name="ln844">                  }</a>
<a name="ln845">            if (nntick == -1)</a>
<a name="ln846">                  len = quantizeLen(len, raster);</a>
<a name="ln847">            else {</a>
<a name="ln848">                  int diff = nntick - ntick;</a>
<a name="ln849">                  if (diff &gt; 0) {</a>
<a name="ln850">                        // insert rest?</a>
<a name="ln851">                        if (diff &lt;= raster)</a>
<a name="ln852">                              len = nntick - tick;</a>
<a name="ln853">                        else</a>
<a name="ln854">                              len = quantizeLen(len, raster);</a>
<a name="ln855">                        }</a>
<a name="ln856">                  else {</a>
<a name="ln857">                        if (diff &gt; -raster)</a>
<a name="ln858">                              len = nntick - tick;</a>
<a name="ln859">                        else</a>
<a name="ln860">                              len = quantizeLen(len, raster);</a>
<a name="ln861">                        }</a>
<a name="ln862">                  }</a>
<a name="ln863">            e.setLen(len);</a>
<a name="ln864">            }</a>
<a name="ln865">      }</a>
<a name="ln866"> </a>
<a name="ln867">//---------------------------------------------------------</a>
<a name="ln868">//   cleanup</a>
<a name="ln869">//    - quantize</a>
<a name="ln870">//    - remove overlaps</a>
<a name="ln871">//---------------------------------------------------------</a>
<a name="ln872"> </a>
<a name="ln873">void BBTrack::cleanup()</a>
<a name="ln874">      {</a>
<a name="ln875">      EventList dl;</a>
<a name="ln876"> </a>
<a name="ln877">      //</a>
<a name="ln878">      // quantize</a>
<a name="ln879">      //</a>
<a name="ln880">      int lastTick = 0;</a>
<a name="ln881">      foreach (const Event&amp; e, _events) {</a>
<a name="ln882">            if (e.type() != ME_NOTE)</a>
<a name="ln883">                  continue;</a>
<a name="ln884">            int offtime  = e.offtime();</a>
<a name="ln885">            if (offtime &gt; lastTick)</a>
<a name="ln886">                  lastTick = offtime;</a>
<a name="ln887">            }</a>
<a name="ln888">      int startTick = 0;</a>
<a name="ln889">      for (int i = 1;; ++i) {</a>
<a name="ln890">            int endTick = bb-&gt;siglist().bar2tick(i, 0);</a>
<a name="ln891">            quantize(startTick, endTick, &amp;dl);</a>
<a name="ln892">            if (endTick &gt; lastTick)</a>
<a name="ln893">                  break;</a>
<a name="ln894">            startTick = endTick;</a>
<a name="ln895">            }</a>
<a name="ln896"> </a>
<a name="ln897">      //</a>
<a name="ln898">      //</a>
<a name="ln899">      //</a>
<a name="ln900">      _events.clear();</a>
<a name="ln901"> </a>
<a name="ln902">      for(iEvent i = dl.begin(); i != dl.end(); ++i) {</a>
<a name="ln903">            Event&amp; e = *i;</a>
<a name="ln904">            if (e.type() == ME_NOTE) {</a>
<a name="ln905">                  iEvent ii = i;</a>
<a name="ln906">                  ++ii;</a>
<a name="ln907">                  for (; ii != dl.end(); ++ii) {</a>
<a name="ln908">                        const Event&amp; ee = *ii;</a>
<a name="ln909">                        if (ee.type() != ME_NOTE || ee.pitch() != e.pitch())</a>
<a name="ln910">                              continue;</a>
<a name="ln911">                        if (ee.ontime() &gt;= e.ontime() + e.duration())</a>
<a name="ln912">                              break;</a>
<a name="ln913">                        e.setLen(ee.ontime() - e.ontime());</a>
<a name="ln914">                        break;</a>
<a name="ln915">                        }</a>
<a name="ln916">                  if (e.duration() &lt;= 0)</a>
<a name="ln917">                        continue;</a>
<a name="ln918">                  }</a>
<a name="ln919">            _events.insert(e);</a>
<a name="ln920">            }</a>
<a name="ln921">      }</a>
<a name="ln922"> </a>
<a name="ln923">//---------------------------------------------------------</a>
<a name="ln924">//   findChords</a>
<a name="ln925">//---------------------------------------------------------</a>
<a name="ln926"> </a>
<a name="ln927">void BBTrack::findChords()</a>
<a name="ln928">      {</a>
<a name="ln929">      EventList dl;</a>
<a name="ln930">      int n = _events.size();</a>
<a name="ln931"> </a>
<a name="ln932">      Drumset* drumset;</a>
<a name="ln933">      if (_drumTrack)</a>
<a name="ln934">            drumset = smDrumset;</a>
<a name="ln935">      else</a>
<a name="ln936">            drumset = 0;</a>
<a name="ln937">      int jitter = 3;   // tick tolerance for note on/off</a>
<a name="ln938"> </a>
<a name="ln939">      for (int i = 0; i &lt; n; ++i) {</a>
<a name="ln940">            Event e = _events[i];</a>
<a name="ln941">            if (e.type() == ME_INVALID)</a>
<a name="ln942">                  continue;</a>
<a name="ln943">            if (e.type() != ME_NOTE) {</a>
<a name="ln944">                  dl.append(e);</a>
<a name="ln945">                  continue;</a>
<a name="ln946">                  }</a>
<a name="ln947"> </a>
<a name="ln948">            Event note(e);</a>
<a name="ln949">            int ontime       = note.ontime();</a>
<a name="ln950">            int offtime      = note.offtime();</a>
<a name="ln951">            Event chord(ME_CHORD);</a>
<a name="ln952">            chord.setOntime(ontime);</a>
<a name="ln953">            chord.setLen(note.duration());</a>
<a name="ln954">            chord.notes().append(note);</a>
<a name="ln955">            int voice = 0;</a>
<a name="ln956">            chord.setVoice(voice);</a>
<a name="ln957">            dl.append(chord);</a>
<a name="ln958">            _events[i].setType(ME_INVALID);</a>
<a name="ln959"> </a>
<a name="ln960">            bool useDrumset = false;</a>
<a name="ln961">            if (drumset) {</a>
<a name="ln962">                  int pitch = note.pitch();</a>
<a name="ln963">                  if (drumset-&gt;isValid(pitch)) {</a>
<a name="ln964">                        useDrumset = true;</a>
<a name="ln965">                        voice = drumset-&gt;voice(pitch);</a>
<a name="ln966">                        chord.setVoice(voice);</a>
<a name="ln967">                        }</a>
<a name="ln968">                  }</a>
<a name="ln969">            for (int k = i + 1; k &lt; n; ++k) {</a>
<a name="ln970">                  if (_events[k].type() != ME_NOTE)</a>
<a name="ln971">                        continue;</a>
<a name="ln972">                  Event nn = _events[k];</a>
<a name="ln973">                  if (nn.ontime() - jitter &gt; ontime)</a>
<a name="ln974">                        break;</a>
<a name="ln975">                  if (qAbs(nn.ontime() - ontime) &gt; jitter || qAbs(nn.offtime() - offtime) &gt; jitter)</a>
<a name="ln976">                        continue;</a>
<a name="ln977">                  int pitch = nn.pitch();</a>
<a name="ln978">                  if (useDrumset) {</a>
<a name="ln979">                        if (drumset-&gt;isValid(pitch) &amp;&amp; drumset-&gt;voice(pitch) == voice) {</a>
<a name="ln980">                              chord.notes().append(nn);</a>
<a name="ln981">                              _events[k].setType(ME_INVALID);</a>
<a name="ln982">                              }</a>
<a name="ln983">                        }</a>
<a name="ln984">                  else {</a>
<a name="ln985">                        chord.notes().append(nn);</a>
<a name="ln986">                        _events[k].setType(ME_INVALID);</a>
<a name="ln987">                        }</a>
<a name="ln988">                  }</a>
<a name="ln989">            }</a>
<a name="ln990">      _events = dl;</a>
<a name="ln991">      }</a>
<a name="ln992"> </a>
<a name="ln993"> </a>
<a name="ln994">//---------------------------------------------------------</a>
<a name="ln995">//   separateVoices</a>
<a name="ln996">//---------------------------------------------------------</a>
<a name="ln997"> </a>
<a name="ln998">int BBTrack::separateVoices(int /*maxVoices*/)</a>
<a name="ln999">      {</a>
<a name="ln1000">      return 1;</a>
<a name="ln1001">      }</a>
<a name="ln1002">}</a>
<a name="ln1003"> </a>

</code></pre>
<div class="balloon" rel="169"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="306"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="388"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
