
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>svggenerator.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/****************************************************************************</a>
<a name="ln2">**</a>
<a name="ln3">** Copyright (C) 2011 Nokia Corporation and/or its subsidiary(-ies).</a>
<a name="ln4">** All rights reserved.</a>
<a name="ln5">** Contact: Nokia Corporation (qt-info@nokia.com)</a>
<a name="ln6">**</a>
<a name="ln7">** This file is part of the QtSvg module of the Qt Toolkit.</a>
<a name="ln8">**</a>
<a name="ln9">** $QT_BEGIN_LICENSE:LGPL$</a>
<a name="ln10">** GNU Lesser General Public License Usage</a>
<a name="ln11">** This file may be used under the terms of the GNU Lesser General Public</a>
<a name="ln12">** License version 2.1 as published by the Free Software Foundation and</a>
<a name="ln13">** appearing in the file LICENSE.LGPL included in the packaging of this</a>
<a name="ln14">** file. Please review the following information to ensure the GNU Lesser</a>
<a name="ln15">** General Public License version 2.1 requirements will be met:</a>
<a name="ln16">** http://www.gnu.org/licenses/old-licenses/lgpl-2.1.html.</a>
<a name="ln17">**</a>
<a name="ln18">** In addition, as a special exception, Nokia gives you certain additional</a>
<a name="ln19">** rights. These rights are described in the Nokia Qt LGPL Exception</a>
<a name="ln20">** version 1.1, included in the file LGPL_EXCEPTION.txt in this package.</a>
<a name="ln21">**</a>
<a name="ln22">** GNU General Public License Usage</a>
<a name="ln23">** Alternatively, this file may be used under the terms of the GNU General</a>
<a name="ln24">** Public License version 3.0 as published by the Free Software Foundation</a>
<a name="ln25">** and appearing in the file LICENSE.GPL included in the packaging of this</a>
<a name="ln26">** file. Please review the following information to ensure the GNU General</a>
<a name="ln27">** Public License version 3.0 requirements will be met:</a>
<a name="ln28">** http://www.gnu.org/copyleft/gpl.html.</a>
<a name="ln29">**</a>
<a name="ln30">** Other Usage</a>
<a name="ln31">** Alternatively, this file may be used in accordance with the terms and</a>
<a name="ln32">** conditions contained in a signed written agreement between you and Nokia.</a>
<a name="ln33">**</a>
<a name="ln34">**</a>
<a name="ln35">**</a>
<a name="ln36">**</a>
<a name="ln37">**</a>
<a name="ln38">** $QT_END_LICENSE$</a>
<a name="ln39">**</a>
<a name="ln40">****************************************************************************/</a>
<a name="ln41"> </a>
<a name="ln42">#include &quot;svggenerator.h&quot;</a>
<a name="ln43">#include &quot;libmscore/element.h&quot;</a>
<a name="ln44">#include &quot;libmscore/image.h&quot;</a>
<a name="ln45">#include &quot;libmscore/imageStore.h&quot;</a>
<a name="ln46">#include &quot;libmscore/mscore.h&quot;</a>
<a name="ln47"> </a>
<a name="ln48">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln49">// FOR GRADIENT FUNCTIONALITY THAT IS NOT IMPLEMENTED (YET):</a>
<a name="ln50">//</a>
<a name="ln51">//#if QT_POINTER_SIZE == 8 // 64-bit versions</a>
<a name="ln52">//</a>
<a name="ln53">//static uint INTERPOLATE_PIXEL_256(uint x, uint a, uint y, uint b) {</a>
<a name="ln54">//    quint64 t = (((quint64(x)) | ((quint64(x)) &lt;&lt; 24)) &amp; 0x00ff00ff00ff00ff) * a;</a>
<a name="ln55">//    t += (((quint64(y)) | ((quint64(y)) &lt;&lt; 24)) &amp; 0x00ff00ff00ff00ff) * b;</a>
<a name="ln56">//    t &gt;&gt;= 8;</a>
<a name="ln57">//    t &amp;= 0x00ff00ff00ff00ff;</a>
<a name="ln58">//    return (uint(t)) | (uint(t &gt;&gt; 24));</a>
<a name="ln59">//}</a>
<a name="ln60">//</a>
<a name="ln61">//static uint PREMUL(uint x) {</a>
<a name="ln62">//    uint a = x &gt;&gt; 24;</a>
<a name="ln63">//    quint64 t = (((quint64(x)) | ((quint64(x)) &lt;&lt; 24)) &amp; 0x00ff00ff00ff00ff) * a;</a>
<a name="ln64">//    t = (t + ((t &gt;&gt; 8) &amp; 0xff00ff00ff00ff) + 0x80008000800080) &gt;&gt; 8;</a>
<a name="ln65">//    t &amp;= 0x000000ff00ff00ff;</a>
<a name="ln66">//    return (uint(t)) | (uint(t &gt;&gt; 24)) | (a &lt;&lt; 24);</a>
<a name="ln67">//}</a>
<a name="ln68">//</a>
<a name="ln69">//#else // 32-bit versions</a>
<a name="ln70">//</a>
<a name="ln71">//static uint INTERPOLATE_PIXEL_256(uint x, uint a, uint y, uint b) {</a>
<a name="ln72">//    uint t = (x &amp; 0xff00ff) * a + (y &amp; 0xff00ff) * b;</a>
<a name="ln73">//    t &gt;&gt;= 8;</a>
<a name="ln74">//    t &amp;= 0xff00ff;</a>
<a name="ln75">//</a>
<a name="ln76">//    x = ((x &gt;&gt; 8) &amp; 0xff00ff) * a + ((y &gt;&gt; 8) &amp; 0xff00ff) * b;</a>
<a name="ln77">//    x &amp;= 0xff00ff00;</a>
<a name="ln78">//    x |= t;</a>
<a name="ln79">//    return x;</a>
<a name="ln80">//}</a>
<a name="ln81">//</a>
<a name="ln82">//#if defined(Q_CC_RVCT)</a>
<a name="ln83">//#  pragma push</a>
<a name="ln84">//#  pragma arm</a>
<a name="ln85">//#endif</a>
<a name="ln86">//</a>
<a name="ln87">//#if defined(Q_CC_RVCT)</a>
<a name="ln88">//#  pragma pop</a>
<a name="ln89">//#endif</a>
<a name="ln90">//</a>
<a name="ln91">//static uint PREMUL(uint x) {</a>
<a name="ln92">//    uint a = x &gt;&gt; 24;</a>
<a name="ln93">//    uint t = (x &amp; 0xff00ff) * a;</a>
<a name="ln94">//    t = (t + ((t &gt;&gt; 8) &amp; 0xff00ff) + 0x800080) &gt;&gt; 8;</a>
<a name="ln95">//    t &amp;= 0xff00ff;</a>
<a name="ln96">//</a>
<a name="ln97">//    x = ((x &gt;&gt; 8) &amp; 0xff) * a;</a>
<a name="ln98">//    x = (x + ((x &gt;&gt; 8) &amp; 0xff) + 0x80);</a>
<a name="ln99">//    x &amp;= 0xff00;</a>
<a name="ln100">//    x |= t | (a &lt;&lt; 24);</a>
<a name="ln101">//    return x;</a>
<a name="ln102">//}</a>
<a name="ln103">//#endif</a>
<a name="ln104">//</a>
<a name="ln105">/*#define INV_PREMUL(p)                                   \</a>
<a name="ln106">    (qAlpha(p) == 0 ? 0 :                               \</a>
<a name="ln107">    ((qAlpha(p) &lt;&lt; 24)                                  \</a>
<a name="ln108">     | (((255*qRed(p))/ qAlpha(p)) &lt;&lt; 16)               \</a>
<a name="ln109">     | (((255*qGreen(p)) / qAlpha(p))  &lt;&lt; 8)            \</a>
<a name="ln110">     | ((255*qBlue(p)) / qAlpha(p))))</a>
<a name="ln111">*/</a>
<a name="ln112">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln113"> </a>
<a name="ln114"> </a>
<a name="ln115">static void translate_color(const QColor &amp;color, QString *color_string,</a>
<a name="ln116">                            QString *opacity_string)</a>
<a name="ln117">{</a>
<a name="ln118">    Q_ASSERT(color_string);</a>
<a name="ln119">    Q_ASSERT(opacity_string);</a>
<a name="ln120"> </a>
<a name="ln121">    *color_string =</a>
<a name="ln122">        QString::fromLatin1(&quot;#%1%2%3&quot;)</a>
<a name="ln123">        .arg(color.red(), 2, 16, QLatin1Char('0'))</a>
<a name="ln124">        .arg(color.green(), 2, 16, QLatin1Char('0'))</a>
<a name="ln125">        .arg(color.blue(), 2, 16, QLatin1Char('0'));</a>
<a name="ln126">    *opacity_string = QString::number(color.alphaF());</a>
<a name="ln127">}</a>
<a name="ln128"> </a>
<a name="ln129">static void translate_dashPattern(QVector&lt;qreal&gt; pattern, const qreal&amp; width, QString *pattern_string)</a>
<a name="ln130">{</a>
<a name="ln131">    Q_ASSERT(pattern_string);</a>
<a name="ln132"> </a>
<a name="ln133">    // Note that SVG operates in absolute lengths, whereas Qt uses a length/width ratio.</a>
<a name="ln134">    foreach (qreal entry, pattern)</a>
<a name="ln135">        *pattern_string += QString::fromLatin1(&quot;%1,&quot;).arg(entry * width);</a>
<a name="ln136"> </a>
<a name="ln137">    pattern_string-&gt;chop(1);</a>
<a name="ln138">}</a>
<a name="ln139"> </a>
<a name="ln140">// Gets the contents of the SVG class attribute, based on element type/name</a>
<a name="ln141">static QString getClass(const Ms::Element *e)</a>
<a name="ln142">{</a>
<a name="ln143">    Ms::ElementType eType;</a>
<a name="ln144">              QString eName;</a>
<a name="ln145"> </a>
<a name="ln146">    // Add element type as &quot;class&quot;</a>
<a name="ln147">    if (e == NULL)</a>
<a name="ln148">        return eName; // e should never be null, this is extra-cautious</a>
<a name="ln149"> </a>
<a name="ln150">    eType = e-&gt;type();</a>
<a name="ln151">    eName = e-&gt;name(eType);</a>
<a name="ln152"> </a>
<a name="ln153">    // Future sub-typing code goes here</a>
<a name="ln154"> </a>
<a name="ln155">    return eName;</a>
<a name="ln156">}</a>
<a name="ln157"> </a>
<a name="ln158">class SvgPaintEnginePrivate</a>
<a name="ln159">{</a>
<a name="ln160">public:</a>
<a name="ln161">    SvgPaintEnginePrivate()</a>
<a name="ln162">    {</a>
<a name="ln163">        size = QSize();</a>
<a name="ln164">        viewBox = QRectF();</a>
<a name="ln165">        outputDevice = 0;</a>
<a name="ln166">        resolution = Ms::DPI;</a>
<a name="ln167"> </a>
<a name="ln168">        attributes.title = QLatin1String(&quot;MuseScore SVG Document&quot;);</a>
<a name="ln169">        attributes.description = QString(&quot;Generated by MuseScore %1&quot;).arg(VERSION);</a>
<a name="ln170">// UNUSED</a>
<a name="ln171">//        attributes.font_family = QLatin1String(&quot;serif&quot;);</a>
<a name="ln172">//        attributes.font_size = QLatin1String(&quot;10pt&quot;);</a>
<a name="ln173">//        attributes.font_style = QLatin1String(&quot;normal&quot;);</a>
<a name="ln174">//        attributes.font_weight = QLatin1String(&quot;normal&quot;);</a>
<a name="ln175">//</a>
<a name="ln176">//        numGradients = 0;</a>
<a name="ln177">    }</a>
<a name="ln178"> </a>
<a name="ln179">    QSize size;</a>
<a name="ln180">    QRectF viewBox;</a>
<a name="ln181">    QIODevice *outputDevice;</a>
<a name="ln182">    QTextStream *stream;</a>
<a name="ln183">    int resolution;</a>
<a name="ln184"> </a>
<a name="ln185">    QString header;</a>
<a name="ln186">//    QString defs; // NEEDED FOR GRADIENTS</a>
<a name="ln187">    QString body;</a>
<a name="ln188"> </a>
<a name="ln189">    QBrush brush;</a>
<a name="ln190">    QPen pen;</a>
<a name="ln191">    QMatrix matrix;</a>
<a name="ln192">//    QFont font;  // UNUSED</a>
<a name="ln193"> </a>
<a name="ln194">// GRADIENTS NOT IMPLEMENTED (YET)</a>
<a name="ln195">//    QString generateGradientName() {</a>
<a name="ln196">//        ++numGradients;</a>
<a name="ln197">//        currentGradientName = QString::fromLatin1(&quot;gradient%1&quot;).arg(numGradients);</a>
<a name="ln198">//        return currentGradientName;</a>
<a name="ln199">//    }</a>
<a name="ln200">//</a>
<a name="ln201">//    QString currentGradientName;</a>
<a name="ln202">//    int numGradients;</a>
<a name="ln203"> </a>
<a name="ln204">    struct _attributes {</a>
<a name="ln205">        QString title;</a>
<a name="ln206">        QString description;</a>
<a name="ln207">// UNUSED STRUCT MEMBERS:</a>
<a name="ln208">//        QString font_weight;</a>
<a name="ln209">//        QString font_size;</a>
<a name="ln210">//        QString font_family;</a>
<a name="ln211">//        QString font_style;</a>
<a name="ln212">//        QString stroke, strokeOpacity;</a>
<a name="ln213">//        QString dashPattern, dashOffset;</a>
<a name="ln214">//        QString fill, fillOpacity;</a>
<a name="ln215">    } attributes;</a>
<a name="ln216">};</a>
<a name="ln217"> </a>
<a name="ln218">static inline QPaintEngine::PaintEngineFeatures svgEngineFeatures()</a>
<a name="ln219">{</a>
<a name="ln220">    return QPaintEngine::PaintEngineFeatures(</a>
<a name="ln221">           QPaintEngine::AllFeatures</a>
<a name="ln222">        &amp; ~QPaintEngine::PatternBrush</a>
<a name="ln223">        &amp; ~QPaintEngine::PerspectiveTransform</a>
<a name="ln224">        &amp; ~QPaintEngine::ConicalGradientFill</a>
<a name="ln225">        &amp; ~QPaintEngine::PorterDuff);</a>
<a name="ln226">}</a>
<a name="ln227"> </a>
<a name="ln228">class SvgPaintEngine : public QPaintEngine</a>
<a name="ln229">{</a>
<a name="ln230">    friend class SvgGenerator; // for setElement()</a>
<a name="ln231"> </a>
<a name="ln232">    Q_DECLARE_PRIVATE(SvgPaintEngine)</a>
<a name="ln233"> </a>
<a name="ln234">private:</a>
<a name="ln235">    QString     stateString;</a>
<a name="ln236">    QTextStream stateStream;</a>
<a name="ln237">    SvgPaintEnginePrivate *d_ptr;</a>
<a name="ln238"> </a>
<a name="ln239">// Qt translates everything. These help avoid SVG transform=&quot;translate()&quot;.</a>
<a name="ln240">    qreal _dx;</a>
<a name="ln241">    qreal _dy;</a>
<a name="ln242"> </a>
<a name="ln243">protected:</a>
<a name="ln244">// The Ms::Element being generated right now</a>
<a name="ln245">    const Ms::Element* _element = NULL;</a>
<a name="ln246"> </a>
<a name="ln247">    void writeImage(const QRectF&amp; r, const QByteArray&amp; imageData, const QString&amp; mimeFormat);</a>
<a name="ln248"> </a>
<a name="ln249">// SVG strings as constants</a>
<a name="ln250">#define SVG_SPACE    ' '</a>
<a name="ln251">#define SVG_QUOTE    &quot;\&quot;&quot;</a>
<a name="ln252">#define SVG_COMMA    &quot;,&quot;</a>
<a name="ln253">#define SVG_GT       &quot;&gt;&quot;</a>
<a name="ln254">#define SVG_PX       &quot;px&quot;</a>
<a name="ln255">#define SVG_NONE     &quot;none&quot;</a>
<a name="ln256">#define SVG_EVENODD  &quot;evenodd&quot;</a>
<a name="ln257">#define SVG_BUTT     &quot;butt&quot;</a>
<a name="ln258">#define SVG_SQUARE   &quot;square&quot;</a>
<a name="ln259">#define SVG_ROUND    &quot;round&quot;</a>
<a name="ln260">#define SVG_MITER    &quot;miter&quot;</a>
<a name="ln261">#define SVG_BEVEL    &quot;bevel&quot;</a>
<a name="ln262">#define SVG_ONE      &quot;1&quot;</a>
<a name="ln263">#define SVG_BLACK    &quot;#000000&quot;</a>
<a name="ln264"> </a>
<a name="ln265">#define SVG_BEGIN    &quot;&lt;svg&quot;</a>
<a name="ln266">#define SVG_END      &quot;&lt;/svg&gt;&quot;</a>
<a name="ln267"> </a>
<a name="ln268">#define SVG_WIDTH    &quot; width=\&quot;&quot;</a>
<a name="ln269">#define SVG_HEIGHT   &quot; height=\&quot;&quot;</a>
<a name="ln270">#define SVG_VIEW_BOX &quot; viewBox=\&quot;&quot;</a>
<a name="ln271"> </a>
<a name="ln272">#define SVG_X        &quot; x=&quot;</a>
<a name="ln273">#define SVG_Y        &quot; y=&quot;</a>
<a name="ln274"> </a>
<a name="ln275">#define SVG_POINTS   &quot; points=\&quot;&quot;</a>
<a name="ln276">#define SVG_D        &quot; d=\&quot;&quot;</a>
<a name="ln277">#define SVG_MOVE     'M'</a>
<a name="ln278">#define SVG_LINE     'L'</a>
<a name="ln279">#define SVG_CURVE    'C'</a>
<a name="ln280"> </a>
<a name="ln281">#define SVG_CLASS    &quot; class=\&quot;&quot;</a>
<a name="ln282"> </a>
<a name="ln283">#define SVG_ELEMENT_END  &quot;/&gt;&quot;</a>
<a name="ln284">#define SVG_RPAREN_QUOTE &quot;)\&quot;&quot;</a>
<a name="ln285"> </a>
<a name="ln286">#define SVG_TITLE_BEGIN &quot;&lt;title&gt;&quot;</a>
<a name="ln287">#define SVG_TITLE_END   &quot;&lt;/title&gt;&quot;</a>
<a name="ln288">#define SVG_DESC_BEGIN  &quot;&lt;desc&gt;&quot;</a>
<a name="ln289">#define SVG_DESC_END    &quot;&lt;/desc&gt;&quot;</a>
<a name="ln290"> </a>
<a name="ln291">#define SVG_IMAGE       &quot;&lt;image&quot;</a>
<a name="ln292">#define SVG_PATH        &quot;&lt;path&quot;</a>
<a name="ln293">#define SVG_POLYLINE    &quot;&lt;polyline&quot;</a>
<a name="ln294"> </a>
<a name="ln295">#define SVG_PRESERVE_ASPECT &quot; preserveAspectRatio=\&quot;&quot;</a>
<a name="ln296"> </a>
<a name="ln297">#define SVG_FILL            &quot; fill=\&quot;&quot;</a>
<a name="ln298">#define SVG_STROKE          &quot; stroke=\&quot;&quot;</a>
<a name="ln299">#define SVG_STROKE_WIDTH    &quot; stroke-width=\&quot;&quot;</a>
<a name="ln300">#define SVG_STROKE_LINECAP  &quot; stroke-linecap=\&quot;&quot;</a>
<a name="ln301">#define SVG_STROKE_LINEJOIN &quot; stroke-linejoin=\&quot;&quot;</a>
<a name="ln302">#define SVG_STROKE_DASHARRAY &quot; stroke-dasharray=\&quot;&quot;</a>
<a name="ln303">#define SVG_STROKE_DASHOFFSET &quot; stroke-dashoffset=\&quot;&quot;</a>
<a name="ln304">#define SVG_STROKE_MITERLIMIT &quot; stroke-miterlimit=\&quot;&quot;</a>
<a name="ln305"> </a>
<a name="ln306">#define SVG_OPACITY         &quot; opacity=\&quot;&quot;</a>
<a name="ln307">#define SVG_FILL_OPACITY    &quot; fill-opacity=\&quot;&quot;</a>
<a name="ln308">#define SVG_STROKE_OPACITY  &quot; stroke-opacity=\&quot;&quot;</a>
<a name="ln309"> </a>
<a name="ln310">#define SVG_FONT_FAMILY     &quot; font-family=\&quot;&quot;</a>
<a name="ln311">#define SVG_FONT_SIZE       &quot; font-size=\&quot;&quot;</a>
<a name="ln312"> </a>
<a name="ln313">#define SVG_FILL_RULE       &quot; fill-rule=\&quot;evenodd\&quot;&quot;</a>
<a name="ln314">#define SVG_VECTOR_EFFECT   &quot; vector-effect=\&quot;non-scaling-stroke\&quot;&quot;</a>
<a name="ln315"> </a>
<a name="ln316">#define SVG_MATRIX    &quot; transform=\&quot;matrix(&quot;</a>
<a name="ln317"> </a>
<a name="ln318">public:</a>
<a name="ln319">    SvgPaintEngine()</a>
<a name="ln320">        : QPaintEngine(svgEngineFeatures()),</a>
<a name="ln321">          stateStream(&amp;stateString)</a>
<a name="ln322">    {</a>
<a name="ln323">        d_ptr = new SvgPaintEnginePrivate;</a>
<a name="ln324">    }</a>
<a name="ln325"> </a>
<a name="ln326">    bool begin(QPaintDevice *device);</a>
<a name="ln327">    bool end();</a>
<a name="ln328"> </a>
<a name="ln329">    void updateState(const QPaintEngineState &amp;state);</a>
<a name="ln330">    void popGroup();</a>
<a name="ln331"> </a>
<a name="ln332">    void drawPath(const QPainterPath &amp;path);</a>
<a name="ln333">    void drawPixmap(const QRectF &amp;r, const QPixmap &amp;pm, const QRectF &amp;sr);</a>
<a name="ln334">    void drawPolygon(const QPointF *points, int pointCount, PolygonDrawMode mode);</a>
<a name="ln335">    void drawImage(const QRectF &amp;r, const QImage &amp;pm, const QRectF &amp;sr,</a>
<a name="ln336">                   Qt::ImageConversionFlag = Qt::AutoColor);</a>
<a name="ln337"> </a>
<a name="ln338">    QPaintEngine::Type type() const { return QPaintEngine::SVG; }</a>
<a name="ln339"> </a>
<a name="ln340">    QSize size() const { return d_func()-&gt;size; }</a>
<a name="ln341">    void setSize(const QSize &amp;size) {</a>
<a name="ln342">        Q_ASSERT(!isActive());</a>
<a name="ln343">        d_func()-&gt;size = size;</a>
<a name="ln344">    }</a>
<a name="ln345"> </a>
<a name="ln346">    QRectF viewBox() const { return d_func()-&gt;viewBox; }</a>
<a name="ln347">    void setViewBox(const QRectF &amp;viewBox) {</a>
<a name="ln348">        Q_ASSERT(!isActive());</a>
<a name="ln349">        d_func()-&gt;viewBox = viewBox;</a>
<a name="ln350">    }</a>
<a name="ln351"> </a>
<a name="ln352">    QString documentTitle() const { return d_func()-&gt;attributes.title; }</a>
<a name="ln353">    void setDocumentTitle(const QString &amp;title) {</a>
<a name="ln354">        d_func()-&gt;attributes.title = title;</a>
<a name="ln355">    }</a>
<a name="ln356"> </a>
<a name="ln357">    QString documentDescription() const { return d_func()-&gt;attributes.description; }</a>
<a name="ln358">    void setDocumentDescription(const QString &amp;description) {</a>
<a name="ln359">        d_func()-&gt;attributes.description = description;</a>
<a name="ln360">    }</a>
<a name="ln361"> </a>
<a name="ln362">    QIODevice *outputDevice() const { return d_func()-&gt;outputDevice; }</a>
<a name="ln363">    void setOutputDevice(QIODevice *device) {</a>
<a name="ln364">        Q_ASSERT(!isActive());</a>
<a name="ln365">        d_func()-&gt;outputDevice = device;</a>
<a name="ln366">    }</a>
<a name="ln367"> </a>
<a name="ln368">    int resolution() { return d_func()-&gt;resolution; }</a>
<a name="ln369">    void setResolution(int resolution) {</a>
<a name="ln370">        Q_ASSERT(!isActive());</a>
<a name="ln371">        d_func()-&gt;resolution = resolution;</a>
<a name="ln372">    }</a>
<a name="ln373"> </a>
<a name="ln374">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln375">// UNUSED GRADIENT CODE:</a>
<a name="ln376">//    void saveLinearGradientBrush(const QGradient *g)</a>
<a name="ln377">//    {</a>
<a name="ln378">//        QTextStream str(&amp;d_func()-&gt;defs, QIODevice::Append);</a>
<a name="ln379">//        const QLinearGradient *grad = static_cast&lt;const QLinearGradient*&gt;(g);</a>
<a name="ln380">//        str &lt;&lt; QLatin1String(&quot;&lt;linearGradient &quot;);</a>
<a name="ln381">//        saveGradientUnits(str, g);</a>
<a name="ln382">//        if (grad) {</a>
<a name="ln383">//            str &lt;&lt; QLatin1String(&quot;x1=\&quot;&quot;) &lt;&lt;grad-&gt;start().x()&lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln384">//                &lt;&lt; QLatin1String(&quot;y1=\&quot;&quot;) &lt;&lt;grad-&gt;start().y()&lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln385">//                &lt;&lt; QLatin1String(&quot;x2=\&quot;&quot;) &lt;&lt;grad-&gt;finalStop().x() &lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln386">//                &lt;&lt; QLatin1String(&quot;y2=\&quot;&quot;) &lt;&lt;grad-&gt;finalStop().y() &lt;&lt; QLatin1String(&quot;\&quot; &quot;);</a>
<a name="ln387">//        }</a>
<a name="ln388">//</a>
<a name="ln389">//        str &lt;&lt; QLatin1String(&quot;id=\&quot;&quot;) &lt;&lt; d_func()-&gt;generateGradientName() &lt;&lt; QLatin1String(&quot;\&quot;&gt;\n&quot;);</a>
<a name="ln390">//        saveGradientStops(str, g);</a>
<a name="ln391">//        str &lt;&lt; QLatin1String(&quot;&lt;/linearGradient&gt;&quot;) &lt;&lt;endl;</a>
<a name="ln392">//    }</a>
<a name="ln393">//    void saveRadialGradientBrush(const QGradient *g)</a>
<a name="ln394">//    {</a>
<a name="ln395">//        QTextStream str(&amp;d_func()-&gt;defs, QIODevice::Append);</a>
<a name="ln396">//        const QRadialGradient *grad = static_cast&lt;const QRadialGradient*&gt;(g);</a>
<a name="ln397">//        str &lt;&lt; QLatin1String(&quot;&lt;radialGradient &quot;);</a>
<a name="ln398">//        saveGradientUnits(str, g);</a>
<a name="ln399">//        if (grad) {</a>
<a name="ln400">//            str &lt;&lt; QLatin1String(&quot;cx=\&quot;&quot;) &lt;&lt;grad-&gt;center().x()&lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln401">//                &lt;&lt; QLatin1String(&quot;cy=\&quot;&quot;) &lt;&lt;grad-&gt;center().y()&lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln402">//                &lt;&lt; QLatin1String(&quot;r=\&quot;&quot;) &lt;&lt;grad-&gt;radius() &lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln403">//                &lt;&lt; QLatin1String(&quot;fx=\&quot;&quot;) &lt;&lt;grad-&gt;focalPoint().x() &lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln404">//                &lt;&lt; QLatin1String(&quot;fy=\&quot;&quot;) &lt;&lt;grad-&gt;focalPoint().y() &lt;&lt; QLatin1String(&quot;\&quot; &quot;);</a>
<a name="ln405">//        }</a>
<a name="ln406">//        str &lt;&lt; QLatin1String(&quot;xml:id=\&quot;&quot;) &lt;&lt;d_func()-&gt;generateGradientName()&lt;&lt; QLatin1String(&quot;\&quot;&gt;\n&quot;);</a>
<a name="ln407">//        saveGradientStops(str, g);</a>
<a name="ln408">//        str &lt;&lt; QLatin1String(&quot;&lt;/radialGradient&gt;&quot;) &lt;&lt; endl;</a>
<a name="ln409">//    }</a>
<a name="ln410">//    void saveConicalGradientBrush(const QGradient *)</a>
<a name="ln411">//    {</a>
<a name="ln412">//        qWarning(&quot;svg's don't support conical gradients!&quot;);</a>
<a name="ln413">//    }</a>
<a name="ln414">//</a>
<a name="ln415">//    void saveGradientStops(QTextStream &amp;str, const QGradient *g) {</a>
<a name="ln416">//        QGradientStops stops = g-&gt;stops();</a>
<a name="ln417">//</a>
<a name="ln418">//        if (g-&gt;interpolationMode() == QGradient::ColorInterpolation) {</a>
<a name="ln419">//            bool constantAlpha = true;</a>
<a name="ln420">//            int alpha = stops.at(0).second.alpha();</a>
<a name="ln421">//            for (int i = 1; i &lt; stops.size(); ++i)</a>
<a name="ln422">//                constantAlpha &amp;= (stops.at(i).second.alpha() == alpha);</a>
<a name="ln423">//</a>
<a name="ln424">//            if (!constantAlpha) {</a>
<a name="ln425">//                const qreal spacing = qreal(0.02);</a>
<a name="ln426">//                QGradientStops newStops;</a>
<a name="ln427">//                QRgb fromColor = PREMUL(stops.at(0).second.rgba());</a>
<a name="ln428">//                QRgb toColor;</a>
<a name="ln429">//                for (int i = 0; i + 1 &lt; stops.size(); ++i) {</a>
<a name="ln430">//                    int parts = qCeil((stops.at(i + 1).first - stops.at(i).first) / spacing);</a>
<a name="ln431">//                    newStops.append(stops.at(i));</a>
<a name="ln432">//                    toColor = PREMUL(stops.at(i + 1).second.rgba());</a>
<a name="ln433">//</a>
<a name="ln434">//                    if (parts &gt; 1) {</a>
<a name="ln435">//                        qreal step = (stops.at(i + 1).first - stops.at(i).first) / parts;</a>
<a name="ln436">//                        for (int j = 1; j &lt; parts; ++j) {</a>
<a name="ln437">//                            QRgb color = INV_PREMUL(INTERPOLATE_PIXEL_256(fromColor, 256 - 256 * j / parts, toColor, 256 * j / parts));</a>
<a name="ln438">//                            newStops.append(QGradientStop(stops.at(i).first + j * step, QColor::fromRgba(color)));</a>
<a name="ln439">//                        }</a>
<a name="ln440">//                    }</a>
<a name="ln441">//                    fromColor = toColor;</a>
<a name="ln442">//                }</a>
<a name="ln443">//                newStops.append(stops.back());</a>
<a name="ln444">//                stops = newStops;</a>
<a name="ln445">//            }</a>
<a name="ln446">//        }</a>
<a name="ln447">//</a>
<a name="ln448">//        foreach(QGradientStop stop, stops) {</a>
<a name="ln449">//            QString color =</a>
<a name="ln450">//                QString::fromLatin1(&quot;#%1%2%3&quot;)</a>
<a name="ln451">//                .arg(stop.second.red(), 2, 16, QLatin1Char('0'))</a>
<a name="ln452">//                .arg(stop.second.green(), 2, 16, QLatin1Char('0'))</a>
<a name="ln453">//                .arg(stop.second.blue(), 2, 16, QLatin1Char('0'));</a>
<a name="ln454">//            str &lt;&lt; QLatin1String(&quot;    &lt;stop offset=\&quot;&quot;)&lt;&lt; stop.first &lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln455">//                &lt;&lt; QLatin1String(&quot;stop-color=\&quot;&quot;) &lt;&lt; color &lt;&lt; QLatin1String(&quot;\&quot; &quot;)</a>
<a name="ln456">//                &lt;&lt; QLatin1String(&quot;stop-opacity=\&quot;&quot;) &lt;&lt; stop.second.alphaF() &lt;&lt;QLatin1String(&quot;\&quot; /&gt;\n&quot;);</a>
<a name="ln457">//        }</a>
<a name="ln458">//    }</a>
<a name="ln459">//</a>
<a name="ln460">//    void saveGradientUnits(QTextStream &amp;str, const QGradient *gradient)</a>
<a name="ln461">//    {</a>
<a name="ln462">//        str &lt;&lt; QLatin1String(&quot;gradientUnits=\&quot;&quot;);</a>
<a name="ln463">//        if (gradient &amp;&amp; gradient-&gt;coordinateMode() == QGradient::ObjectBoundingMode)</a>
<a name="ln464">//            str &lt;&lt; QLatin1String(&quot;objectBoundingBox&quot;);</a>
<a name="ln465">//        else</a>
<a name="ln466">//            str &lt;&lt; QLatin1String(&quot;userSpaceOnUse&quot;);</a>
<a name="ln467">//        str &lt;&lt; QLatin1String(&quot;\&quot; &quot;);</a>
<a name="ln468">//    }</a>
<a name="ln469">// END UNUSED GRADIENT CODE</a>
<a name="ln470">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln471"> </a>
<a name="ln472">    inline QTextStream &amp;stream()</a>
<a name="ln473">    {</a>
<a name="ln474">        return *d_func()-&gt;stream;</a>
<a name="ln475">    }</a>
<a name="ln476"> </a>
<a name="ln477">    //////////////////////////////</a>
<a name="ln478">    // SvgPaintEngine::qpenToSVG()</a>
<a name="ln479">    //////////////////////////////</a>
<a name="ln480">    const QString qpenToSvg(const QPen &amp;spen)</a>
<a name="ln481">    {</a>
<a name="ln482">        QString     qs;</a>
<a name="ln483">        QTextStream qts(&amp;qs);</a>
<a name="ln484"> </a>
<a name="ln485">        QString color, colorOpacity;</a>
<a name="ln486"> </a>
<a name="ln487">        // Set stroke, stroke-dasharray, stroke-dashoffset attributes</a>
<a name="ln488">        switch (spen.style()) {</a>
<a name="ln489">        case Qt::NoPen:</a>
<a name="ln490">            return qs; // Default value for stroke = &quot;none&quot; = Qt::NoPen = NOOP;</a>
<a name="ln491">            break;</a>
<a name="ln492"> </a>
<a name="ln493">        case Qt::SolidLine:</a>
<a name="ln494">        case Qt::DashLine:</a>
<a name="ln495">        case Qt::DotLine:</a>
<a name="ln496">        case Qt::DashDotLine:</a>
<a name="ln497">        case Qt::DashDotDotLine:</a>
<a name="ln498">        case Qt::CustomDashLine: {</a>
<a name="ln499">            // These values are class variables because they are needed by</a>
<a name="ln500">            // drawTextItem(). This is the fill color/opacity for text.</a>
<a name="ln501">            translate_color(spen.color(), &amp;color, &amp;colorOpacity);</a>
<a name="ln502"> </a>
<a name="ln503">            // default stroke=&quot;none&quot; is handled by case Qt::NoPen above</a>
<a name="ln504">            qts &lt;&lt; SVG_STROKE &lt;&lt; color &lt;&lt; SVG_QUOTE;</a>
<a name="ln505"> </a>
<a name="ln506">            // stroke-opacity is seldom used, usually set to default 1</a>
<a name="ln507">            if (colorOpacity != SVG_ONE)</a>
<a name="ln508">                qts &lt;&lt; SVG_STROKE_OPACITY &lt;&lt; colorOpacity &lt;&lt; SVG_QUOTE;</a>
<a name="ln509"> </a>
<a name="ln510">            // If it's a solid line, were done for now</a>
<a name="ln511">            if (spen.style() == Qt::SolidLine)</a>
<a name="ln512">                break;</a>
<a name="ln513"> </a>
<a name="ln514">            // It's a dashed line</a>
<a name="ln515">            qreal penWidth = spen.width() == 0 ? qreal(1) : spen.widthF();</a>
<a name="ln516"> </a>
<a name="ln517">            QString dashPattern, dashOffset;</a>
<a name="ln518">            translate_dashPattern(spen.dashPattern(), penWidth, &amp;dashPattern);</a>
<a name="ln519">            dashOffset = QString::number(spen.dashOffset() * penWidth); // SVG uses absolute offset</a>
<a name="ln520"> </a>
<a name="ln521">            qts &lt;&lt; SVG_STROKE_DASHARRAY  &lt;&lt; dashPattern &lt;&lt; SVG_QUOTE;</a>
<a name="ln522">            qts &lt;&lt; SVG_STROKE_DASHOFFSET &lt;&lt; dashOffset  &lt;&lt; SVG_QUOTE;</a>
<a name="ln523">            break; }</a>
<a name="ln524">        default:</a>
<a name="ln525">            qWarning(&quot;Unsupported pen style&quot;);</a>
<a name="ln526">            break;</a>
<a name="ln527">        }</a>
<a name="ln528">        // Set stroke-width attribute, unless it's zero or 1 (default is 1)</a>
<a name="ln529">        if (spen.widthF() &gt; 0 &amp;&amp; spen.widthF() != 1) {</a>
<a name="ln530">            // Formatting for vertical alignment of elements</a>
<a name="ln531">            qts.setRealNumberPrecision(2); // with DPI=72 only 2 decimals necessary</a>
<a name="ln532">            qts.setRealNumberNotation(QTextStream::FixedNotation);</a>
<a name="ln533">            qts &lt;&lt; SVG_STROKE_WIDTH &lt;&lt; spen.widthF() &lt;&lt; SVG_QUOTE;</a>
<a name="ln534">            qts.setRealNumberNotation(QTextStream::SmartNotation);</a>
<a name="ln535">        }</a>
<a name="ln536">        // Set stroke-linecap attribute</a>
<a name="ln537">        switch (spen.capStyle()) {</a>
<a name="ln538">        case Qt::FlatCap:</a>
<a name="ln539">            // This is the default stroke-linecap value</a>
<a name="ln540">            //qts &lt;&lt; SVG_STROKE_LINECAP &lt;&lt; SVG_BUTT &lt;&lt; SVG_QUOTE;</a>
<a name="ln541">            break;</a>
<a name="ln542">        case Qt::SquareCap:</a>
<a name="ln543">            qts &lt;&lt; SVG_STROKE_LINECAP &lt;&lt; SVG_SQUARE &lt;&lt; SVG_QUOTE;</a>
<a name="ln544">            break;</a>
<a name="ln545">        case Qt::RoundCap:</a>
<a name="ln546">            qts &lt;&lt; SVG_STROKE_LINECAP &lt;&lt; SVG_ROUND &lt;&lt; SVG_QUOTE;</a>
<a name="ln547">            break;</a>
<a name="ln548">        default:</a>
<a name="ln549">            qWarning(&quot;Unhandled cap style&quot;);</a>
<a name="ln550">            break;</a>
<a name="ln551">        }</a>
<a name="ln552">        // Set stroke-linejoin, stroke-miterlimit attributes</a>
<a name="ln553">        switch (spen.joinStyle()) {</a>
<a name="ln554">        case Qt::MiterJoin:</a>
<a name="ln555">        case Qt::SvgMiterJoin:</a>
<a name="ln556">            qts &lt;&lt; SVG_STROKE_LINEJOIN   &lt;&lt; SVG_MITER         &lt;&lt; SVG_QUOTE</a>
<a name="ln557">                &lt;&lt; SVG_STROKE_MITERLIMIT &lt;&lt; spen.miterLimit() &lt;&lt; SVG_QUOTE;</a>
<a name="ln558">            break;</a>
<a name="ln559">        case Qt::BevelJoin:</a>
<a name="ln560">            qts &lt;&lt; SVG_STROKE_LINEJOIN   &lt;&lt; SVG_BEVEL &lt;&lt; SVG_QUOTE;</a>
<a name="ln561">            break;</a>
<a name="ln562">        case Qt::RoundJoin:</a>
<a name="ln563">            qts &lt;&lt; SVG_STROKE_LINEJOIN   &lt;&lt; SVG_ROUND &lt;&lt; SVG_QUOTE;</a>
<a name="ln564">            break;</a>
<a name="ln565">        default:</a>
<a name="ln566">            qWarning(&quot;Unhandled join style&quot;);</a>
<a name="ln567">            break;</a>
<a name="ln568">        }</a>
<a name="ln569">        // An uncommon, possibly non-existent in MuseScore, effect</a>
<a name="ln570">        if (spen.isCosmetic())</a>
<a name="ln571">            qts &lt;&lt; SVG_VECTOR_EFFECT;</a>
<a name="ln572"> </a>
<a name="ln573">        return qs;</a>
<a name="ln574">    }</a>
<a name="ln575"> </a>
<a name="ln576">    /////////////////////////////////</a>
<a name="ln577">    // SvgPaintEngine::qbrushToSVG()</a>
<a name="ln578">    /////////////////////////////////</a>
<a name="ln579">    const QString  qbrushToSvg(const QBrush &amp;sbrush)</a>
<a name="ln580">    {</a>
<a name="ln581">        QString     qs;</a>
<a name="ln582">        QTextStream qts(&amp;qs);</a>
<a name="ln583"> </a>
<a name="ln584">        QString color, colorOpacity;</a>
<a name="ln585"> </a>
<a name="ln586">        switch (sbrush.style()) {</a>
<a name="ln587">        case Qt::SolidPattern:</a>
<a name="ln588">            translate_color(sbrush.color(), &amp;color, &amp;colorOpacity);</a>
<a name="ln589"> </a>
<a name="ln590">            // Default fill color is black</a>
<a name="ln591">            if (color != SVG_BLACK)</a>
<a name="ln592">                qts &lt;&lt; SVG_FILL &lt;&lt; color &lt;&lt; SVG_QUOTE;</a>
<a name="ln593"> </a>
<a name="ln594">            // Default fill-opacity is 100%</a>
<a name="ln595">            if (colorOpacity != SVG_ONE)</a>
<a name="ln596">                qts &lt;&lt; SVG_FILL_OPACITY &lt;&lt; colorOpacity &lt;&lt; SVG_QUOTE;</a>
<a name="ln597"> </a>
<a name="ln598">            break;</a>
<a name="ln599"> </a>
<a name="ln600">        case Qt::NoBrush:</a>
<a name="ln601">            qts &lt;&lt; SVG_FILL &lt;&lt; SVG_NONE &lt;&lt;  SVG_QUOTE;</a>
<a name="ln602">            break;</a>
<a name="ln603"> </a>
<a name="ln604">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln605">// OLD GRADIENT CODE: MuseScore does not support gradients (yet)</a>
<a name="ln606">//</a>
<a name="ln607">//      case Qt::LinearGradientPattern:</a>
<a name="ln608">//          saveLinearGradientBrush(sbrush.gradient());</a>
<a name="ln609">//          d_func()-&gt;attributes.fill = QString::fromLatin1(&quot;url(#%1)&quot;).arg(d_func()-&gt;currentGradientName);</a>
<a name="ln610">//          d_func()-&gt;attributes.fillOpacity = QString();</a>
<a name="ln611">//          stateStream &lt;&lt; QLatin1String(&quot;fill=\&quot;url(#&quot;) &lt;&lt; d_func()-&gt;currentGradientName &lt;&lt; QLatin1String(&quot;)\&quot; &quot;);</a>
<a name="ln612">//          break;</a>
<a name="ln613">//      case Qt::RadialGradientPattern:</a>
<a name="ln614">//          saveRadialGradientBrush(sbrush.gradient());</a>
<a name="ln615">//          d_func()-&gt;attributes.fill = QString::fromLatin1(&quot;url(#%1)&quot;).arg(d_func()-&gt;currentGradientName);</a>
<a name="ln616">//          d_func()-&gt;attributes.fillOpacity = QString();</a>
<a name="ln617">//          stateStream &lt;&lt; QLatin1String(&quot;fill=\&quot;url(#&quot;) &lt;&lt; d_func()-&gt;currentGradientName &lt;&lt; QLatin1String(&quot;)\&quot; &quot;);</a>
<a name="ln618">//          break;</a>
<a name="ln619">//      case Qt::ConicalGradientPattern:</a>
<a name="ln620">//          saveConicalGradientBrush(sbrush.gradient());</a>
<a name="ln621">//          d_func()-&gt;attributes.fill = QString::fromLatin1(&quot;url(#%1)&quot;).arg(d_func()-&gt;currentGradientName);</a>
<a name="ln622">//          d_func()-&gt;attributes.fillOpacity = QString();</a>
<a name="ln623">//          stateStream &lt;&lt; QLatin1String(&quot;fill=\&quot;url(#&quot;) &lt;&lt; d_func()-&gt;currentGradientName &lt;&lt; QLatin1String(&quot;)\&quot; &quot;);</a>
<a name="ln624">//          break;</a>
<a name="ln625">//      case Qt::NoBrush:</a>
<a name="ln626">//          stateStream &lt;&lt; QLatin1String(&quot;fill=\&quot;none\&quot; &quot;);</a>
<a name="ln627">//          d_func()-&gt;attributes.fill = QLatin1String(&quot;none&quot;);</a>
<a name="ln628">//          d_func()-&gt;attributes.fillOpacity = QString();</a>
<a name="ln629">//          return;</a>
<a name="ln630">//          break;</a>
<a name="ln631">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln632"> </a>
<a name="ln633">        default:</a>
<a name="ln634">           break;</a>
<a name="ln635">        }</a>
<a name="ln636">        return qs;</a>
<a name="ln637">    }</a>
<a name="ln638"> </a>
<a name="ln639">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln640">// THIS FUNCTION IS NEVER USED and in the future should probably be replaced by</a>
<a name="ln641">// a drawTextItem() override instead</a>
<a name="ln642">//</a>
<a name="ln643">//    void qfontToSvg(const QFont &amp;sfont)</a>
<a name="ln644">//    {</a>
<a name="ln645">//        Q_D(SvgPaintEngine);</a>
<a name="ln646">//</a>
<a name="ln647">//        d-&gt;font = sfont;</a>
<a name="ln648">//</a>
<a name="ln649">//        if (d-&gt;font.pixelSize() == -1)</a>
<a name="ln650">//            d-&gt;attributes.font_size = QString::number(d-&gt;font.pointSizeF() * d-&gt;resolution / 72);</a>
<a name="ln651">//        else</a>
<a name="ln652">//            d-&gt;attributes.font_size = QString::number(d-&gt;font.pixelSize());</a>
<a name="ln653">//</a>
<a name="ln654">//        int svgWeight = d-&gt;font.weight();</a>
<a name="ln655">//        switch (svgWeight) {</a>
<a name="ln656">//        case QFont::Light:</a>
<a name="ln657">//            svgWeight = 100;</a>
<a name="ln658">//            break;</a>
<a name="ln659">//        case QFont::Normal:</a>
<a name="ln660">//            svgWeight = 400;</a>
<a name="ln661">//            break;</a>
<a name="ln662">//        case QFont::Bold:</a>
<a name="ln663">//            svgWeight = 700;</a>
<a name="ln664">//            break;</a>
<a name="ln665">//        default:</a>
<a name="ln666">//            svgWeight *= 10;</a>
<a name="ln667">//        }</a>
<a name="ln668">//</a>
<a name="ln669">//        d-&gt;attributes.font_weight = QString::number(svgWeight);</a>
<a name="ln670">//        d-&gt;attributes.font_family = d-&gt;font.family();</a>
<a name="ln671">//        d-&gt;attributes.font_style = d-&gt;font.italic() ? QLatin1String(&quot;italic&quot;) : QLatin1String(&quot;normal&quot;);</a>
<a name="ln672">//</a>
<a name="ln673">//        stateStream &lt;&lt; &quot;font-family=\&quot;&quot; &lt;&lt; d-&gt;attributes.font_family &lt;&lt; &quot;\&quot; &quot;</a>
<a name="ln674">//                       &quot;font-size=\&quot;&quot; &lt;&lt; d-&gt;attributes.font_size &lt;&lt; &quot;\&quot; &quot;</a>
<a name="ln675">//                       &quot;font-weight=\&quot;&quot; &lt;&lt; d-&gt;attributes.font_weight &lt;&lt; &quot;\&quot; &quot;</a>
<a name="ln676">//                       &quot;font-style=\&quot;&quot; &lt;&lt; d-&gt;attributes.font_style &lt;&lt; &quot;\&quot; &quot;</a>
<a name="ln677">//                    &lt;&lt; endl;</a>
<a name="ln678">//    }</a>
<a name="ln679">///////////////////////////////////////////////////////////////////////////////</a>
<a name="ln680">};</a>
<a name="ln681"> </a>
<a name="ln682">class SvgGeneratorPrivate</a>
<a name="ln683">{</a>
<a name="ln684">public:</a>
<a name="ln685">    SvgPaintEngine *engine;</a>
<a name="ln686"> </a>
<a name="ln687">    uint owns_iodevice : 1;</a>
<a name="ln688">    QString fileName;</a>
<a name="ln689">};</a>
<a name="ln690"> </a>
<a name="ln691">/*!</a>
<a name="ln692">    \class SvgGenerator</a>
<a name="ln693">    \ingroup painting</a>
<a name="ln694">    \since 4.3</a>
<a name="ln695">    \brief The SvgGenerator class provides a paint device that is used to create SVG drawings.</a>
<a name="ln696">    \reentrant</a>
<a name="ln697"> </a>
<a name="ln698">    This paint device represents a Scalable Vector Graphics (SVG) drawing. Like QPrinter, it is</a>
<a name="ln699">    designed as a write-only device that generates output in a specific format.</a>
<a name="ln700"> </a>
<a name="ln701">    To write an SVG file, you first need to configure the output by setting the \l fileName</a>
<a name="ln702">    or \l outputDevice properties. It is usually necessary to specify the size of the drawing</a>
<a name="ln703">    by setting the \l size property, and in some cases where the drawing will be included in</a>
<a name="ln704">    another, the \l viewBox property also needs to be set.</a>
<a name="ln705"> </a>
<a name="ln706">    \snippet examples/painting/svggenerator/window.cpp configure SVG generator</a>
<a name="ln707"> </a>
<a name="ln708">    Other meta-data can be specified by setting the \a title, \a description and \a resolution</a>
<a name="ln709">    properties.</a>
<a name="ln710"> </a>
<a name="ln711">    As with other QPaintDevice subclasses, a QPainter object is used to paint onto an instance</a>
<a name="ln712">    of this class:</a>
<a name="ln713"> </a>
<a name="ln714">    \snippet examples/painting/svggenerator/window.cpp begin painting</a>
<a name="ln715">    \dots</a>
<a name="ln716">    \snippet examples/painting/svggenerator/window.cpp end painting</a>
<a name="ln717"> </a>
<a name="ln718">    Painting is performed in the same way as for any other paint device. However,</a>
<a name="ln719">    it is necessary to use the QPainter::begin() and \l{QPainter::}{end()} to</a>
<a name="ln720">    explicitly begin and end painting on the device.</a>
<a name="ln721"> </a>
<a name="ln722">    The \l{SVG Generator Example} shows how the same painting commands can be used</a>
<a name="ln723">    for painting a widget and writing an SVG file.</a>
<a name="ln724"> </a>
<a name="ln725">    \sa SvgRenderer, SvgWidget, {About SVG}</a>
<a name="ln726">*/</a>
<a name="ln727"> </a>
<a name="ln728">/*!</a>
<a name="ln729">    Constructs a new generator.</a>
<a name="ln730">*/</a>
<a name="ln731">SvgGenerator::SvgGenerator()</a>
<a name="ln732">    : d_ptr(new SvgGeneratorPrivate)</a>
<a name="ln733">{</a>
<a name="ln734">    Q_D(SvgGenerator);</a>
<a name="ln735"> </a>
<a name="ln736">    d-&gt;engine = new SvgPaintEngine;</a>
<a name="ln737">    d-&gt;owns_iodevice = false;</a>
<a name="ln738">}</a>
<a name="ln739"> </a>
<a name="ln740">/*!</a>
<a name="ln741">    Destroys the generator.</a>
<a name="ln742">*/</a>
<a name="ln743">SvgGenerator::~SvgGenerator()</a>
<a name="ln744">{</a>
<a name="ln745">    Q_D(SvgGenerator);</a>
<a name="ln746">    if (d-&gt;owns_iodevice)</a>
<a name="ln747">        delete d-&gt;engine-&gt;outputDevice();</a>
<a name="ln748">    delete d-&gt;engine;</a>
<a name="ln749">}</a>
<a name="ln750"> </a>
<a name="ln751">/*!</a>
<a name="ln752">    \property SvgGenerator::title</a>
<a name="ln753">    \brief the title of the generated SVG drawing</a>
<a name="ln754">    \since 4.5</a>
<a name="ln755">    \sa description</a>
<a name="ln756">*/</a>
<a name="ln757">QString SvgGenerator::title() const</a>
<a name="ln758">{</a>
<a name="ln759">    Q_D(const SvgGenerator);</a>
<a name="ln760"> </a>
<a name="ln761">    return d-&gt;engine-&gt;documentTitle();</a>
<a name="ln762">}</a>
<a name="ln763"> </a>
<a name="ln764">void SvgGenerator::setTitle(const QString &amp;title)</a>
<a name="ln765">{</a>
<a name="ln766">    Q_D(SvgGenerator);</a>
<a name="ln767"> </a>
<a name="ln768">    d-&gt;engine-&gt;setDocumentTitle(title);</a>
<a name="ln769">}</a>
<a name="ln770"> </a>
<a name="ln771">/*!</a>
<a name="ln772">    \property SvgGenerator::description</a>
<a name="ln773">    \brief the description of the generated SVG drawing</a>
<a name="ln774">    \since 4.5</a>
<a name="ln775">    \sa title</a>
<a name="ln776">*/</a>
<a name="ln777">QString SvgGenerator::description() const</a>
<a name="ln778">{</a>
<a name="ln779">    Q_D(const SvgGenerator);</a>
<a name="ln780"> </a>
<a name="ln781">    return d-&gt;engine-&gt;documentDescription();</a>
<a name="ln782">}</a>
<a name="ln783"> </a>
<a name="ln784">void SvgGenerator::setDescription(const QString &amp;description)</a>
<a name="ln785">{</a>
<a name="ln786">    Q_D(SvgGenerator);</a>
<a name="ln787"> </a>
<a name="ln788">    d-&gt;engine-&gt;setDocumentDescription(description);</a>
<a name="ln789">}</a>
<a name="ln790"> </a>
<a name="ln791">/*!</a>
<a name="ln792">    \property SvgGenerator::size</a>
<a name="ln793">    \brief the size of the generated SVG drawing</a>
<a name="ln794">    \since 4.5</a>
<a name="ln795"> </a>
<a name="ln796">    By default this property is set to \c{QSize(-1, -1)}, which</a>
<a name="ln797">    indicates that the generator should not output the width and</a>
<a name="ln798">    height attributes of the \c&lt;svg&gt; element.</a>
<a name="ln799"> </a>
<a name="ln800">    \note It is not possible to change this property while a</a>
<a name="ln801">    QPainter is active on the generator.</a>
<a name="ln802"> </a>
<a name="ln803">    \sa viewBox, resolution</a>
<a name="ln804">*/</a>
<a name="ln805">QSize SvgGenerator::size() const</a>
<a name="ln806">{</a>
<a name="ln807">    Q_D(const SvgGenerator);</a>
<a name="ln808">    return d-&gt;engine-&gt;size();</a>
<a name="ln809">}</a>
<a name="ln810"> </a>
<a name="ln811">void SvgGenerator::setSize(const QSize &amp;size)</a>
<a name="ln812">{</a>
<a name="ln813">    Q_D(SvgGenerator);</a>
<a name="ln814">    if (d-&gt;engine-&gt;isActive()) {</a>
<a name="ln815">        qWarning(&quot;SvgGenerator::setSize(), cannot set size while SVG is being generated&quot;);</a>
<a name="ln816">        return;</a>
<a name="ln817">    }</a>
<a name="ln818">    d-&gt;engine-&gt;setSize(size);</a>
<a name="ln819">}</a>
<a name="ln820"> </a>
<a name="ln821">/*!</a>
<a name="ln822">    \property SvgGenerator::viewBox</a>
<a name="ln823">    \brief the viewBox of the generated SVG drawing</a>
<a name="ln824">    \since 4.5</a>
<a name="ln825"> </a>
<a name="ln826">    By default this property is set to \c{QRect(0, 0, -1, -1)}, which</a>
<a name="ln827">    indicates that the generator should not output the viewBox attribute</a>
<a name="ln828">    of the \c&lt;svg&gt; element.</a>
<a name="ln829"> </a>
<a name="ln830">    \note It is not possible to change this property while a</a>
<a name="ln831">    QPainter is active on the generator.</a>
<a name="ln832"> </a>
<a name="ln833">    \sa viewBox(), size, resolution</a>
<a name="ln834">*/</a>
<a name="ln835">QRectF SvgGenerator::viewBoxF() const</a>
<a name="ln836">{</a>
<a name="ln837">    Q_D(const SvgGenerator);</a>
<a name="ln838">    return d-&gt;engine-&gt;viewBox();</a>
<a name="ln839">}</a>
<a name="ln840"> </a>
<a name="ln841">/*!</a>
<a name="ln842">    \since 4.5</a>
<a name="ln843"> </a>
<a name="ln844">    Returns viewBoxF().toRect().</a>
<a name="ln845"> </a>
<a name="ln846">    \sa viewBoxF()</a>
<a name="ln847">*/</a>
<a name="ln848">QRect SvgGenerator::viewBox() const</a>
<a name="ln849">{</a>
<a name="ln850">    Q_D(const SvgGenerator);</a>
<a name="ln851">    return d-&gt;engine-&gt;viewBox().toRect();</a>
<a name="ln852">}</a>
<a name="ln853"> </a>
<a name="ln854">void SvgGenerator::setViewBox(const QRectF &amp;viewBox)</a>
<a name="ln855">{</a>
<a name="ln856">    Q_D(SvgGenerator);</a>
<a name="ln857">    if (d-&gt;engine-&gt;isActive()) {</a>
<a name="ln858">        qWarning(&quot;SvgGenerator::setViewBox(), cannot set viewBox while SVG is being generated&quot;);</a>
<a name="ln859">        return;</a>
<a name="ln860">    }</a>
<a name="ln861">    d-&gt;engine-&gt;setViewBox(viewBox);</a>
<a name="ln862">}</a>
<a name="ln863"> </a>
<a name="ln864">void SvgGenerator::setViewBox(const QRect &amp;viewBox)</a>
<a name="ln865">{</a>
<a name="ln866">    setViewBox(QRectF(viewBox));</a>
<a name="ln867">}</a>
<a name="ln868"> </a>
<a name="ln869">/*!</a>
<a name="ln870">    \property SvgGenerator::fileName</a>
<a name="ln871">    \brief the target filename for the generated SVG drawing</a>
<a name="ln872">    \since 4.5</a>
<a name="ln873"> </a>
<a name="ln874">    \sa outputDevice</a>
<a name="ln875">*/</a>
<a name="ln876">QString SvgGenerator::fileName() const</a>
<a name="ln877">{</a>
<a name="ln878">    Q_D(const SvgGenerator);</a>
<a name="ln879">    return d-&gt;fileName;</a>
<a name="ln880">}</a>
<a name="ln881"> </a>
<a name="ln882">void SvgGenerator::setFileName(const QString &amp;fileName)</a>
<a name="ln883">{</a>
<a name="ln884">    Q_D(SvgGenerator);</a>
<a name="ln885">    if (d-&gt;engine-&gt;isActive()) {</a>
<a name="ln886">        qWarning(&quot;SvgGenerator::setFileName(), cannot set file name while SVG is being generated&quot;);</a>
<a name="ln887">        return;</a>
<a name="ln888">    }</a>
<a name="ln889"> </a>
<a name="ln890">    if (d-&gt;owns_iodevice)</a>
<a name="ln891">        delete d-&gt;engine-&gt;outputDevice();</a>
<a name="ln892"> </a>
<a name="ln893">    d-&gt;owns_iodevice = true;</a>
<a name="ln894"> </a>
<a name="ln895">    d-&gt;fileName = fileName;</a>
<a name="ln896">    QFile *file = new QFile(fileName);</a>
<a name="ln897">    d-&gt;engine-&gt;setOutputDevice(file);</a>
<a name="ln898">}</a>
<a name="ln899"> </a>
<a name="ln900">/*!</a>
<a name="ln901">    \property SvgGenerator::outputDevice</a>
<a name="ln902">    \brief the output device for the generated SVG drawing</a>
<a name="ln903">    \since 4.5</a>
<a name="ln904"> </a>
<a name="ln905">    If both output device and file name are specified, the output device</a>
<a name="ln906">    will have precedence.</a>
<a name="ln907"> </a>
<a name="ln908">    \sa fileName</a>
<a name="ln909">*/</a>
<a name="ln910">QIODevice *SvgGenerator::outputDevice() const</a>
<a name="ln911">{</a>
<a name="ln912">    Q_D(const SvgGenerator);</a>
<a name="ln913">    return d-&gt;engine-&gt;outputDevice();</a>
<a name="ln914">}</a>
<a name="ln915"> </a>
<a name="ln916">void SvgGenerator::setOutputDevice(QIODevice *outputDevice)</a>
<a name="ln917">{</a>
<a name="ln918">    Q_D(SvgGenerator);</a>
<a name="ln919">    if (d-&gt;engine-&gt;isActive()) {</a>
<a name="ln920">        qWarning(&quot;SvgGenerator::setOutputDevice(), cannot set output device while SVG is being generated&quot;);</a>
<a name="ln921">        return;</a>
<a name="ln922">    }</a>
<a name="ln923">    d-&gt;owns_iodevice = false;</a>
<a name="ln924">    d-&gt;engine-&gt;setOutputDevice(outputDevice);</a>
<a name="ln925">    d-&gt;fileName = QString();</a>
<a name="ln926">}</a>
<a name="ln927"> </a>
<a name="ln928">/*!</a>
<a name="ln929">    \property SvgGenerator::resolution</a>
<a name="ln930">    \brief the resolution of the generated output</a>
<a name="ln931">    \since 4.5</a>
<a name="ln932"> </a>
<a name="ln933">    The resolution is specified in dots per inch, and is used to</a>
<a name="ln934">    calculate the physical size of an SVG drawing.</a>
<a name="ln935"> </a>
<a name="ln936">    \sa size, viewBox</a>
<a name="ln937">*/</a>
<a name="ln938">int SvgGenerator::resolution() const</a>
<a name="ln939">{</a>
<a name="ln940">    Q_D(const SvgGenerator);</a>
<a name="ln941">    return d-&gt;engine-&gt;resolution();</a>
<a name="ln942">}</a>
<a name="ln943"> </a>
<a name="ln944">void SvgGenerator::setResolution(int dpi)</a>
<a name="ln945">{</a>
<a name="ln946">    Q_D(SvgGenerator);</a>
<a name="ln947">    d-&gt;engine-&gt;setResolution(dpi);</a>
<a name="ln948">}</a>
<a name="ln949"> </a>
<a name="ln950">/*!</a>
<a name="ln951">    Returns the paint engine used to render graphics to be converted to SVG</a>
<a name="ln952">    format information.</a>
<a name="ln953">*/</a>
<a name="ln954">QPaintEngine *SvgGenerator::paintEngine() const</a>
<a name="ln955">{</a>
<a name="ln956">    Q_D(const SvgGenerator);</a>
<a name="ln957">    return d-&gt;engine;</a>
<a name="ln958">}</a>
<a name="ln959"> </a>
<a name="ln960">/*!</a>
<a name="ln961">    \reimp</a>
<a name="ln962">*/</a>
<a name="ln963">int SvgGenerator::metric(QPaintDevice::PaintDeviceMetric metric) const</a>
<a name="ln964">{</a>
<a name="ln965">    Q_D(const SvgGenerator);</a>
<a name="ln966">    switch (metric) {</a>
<a name="ln967">    case QPaintDevice::PdmDepth:</a>
<a name="ln968">        return 32;</a>
<a name="ln969">    case QPaintDevice::PdmWidth:</a>
<a name="ln970">        return d-&gt;engine-&gt;size().width();</a>
<a name="ln971">    case QPaintDevice::PdmHeight:</a>
<a name="ln972">        return d-&gt;engine-&gt;size().height();</a>
<a name="ln973">    case QPaintDevice::PdmDpiX:</a>
<a name="ln974">        return d-&gt;engine-&gt;resolution();</a>
<a name="ln975">    case QPaintDevice::PdmDpiY:</a>
<a name="ln976">        return d-&gt;engine-&gt;resolution();</a>
<a name="ln977">    case QPaintDevice::PdmHeightMM:</a>
<a name="ln978">        return qRound(d-&gt;engine-&gt;size().height() / Ms::DPMM);</a>
<a name="ln979">    case QPaintDevice::PdmWidthMM:</a>
<a name="ln980">        return qRound(d-&gt;engine-&gt;size().width()  / Ms::DPMM);</a>
<a name="ln981">    case QPaintDevice::PdmNumColors:</a>
<a name="ln982">        return 0xffffffff;</a>
<a name="ln983">    case QPaintDevice::PdmPhysicalDpiX:</a>
<a name="ln984">        return d-&gt;engine-&gt;resolution();</a>
<a name="ln985">    case QPaintDevice::PdmPhysicalDpiY:</a>
<a name="ln986">        return d-&gt;engine-&gt;resolution();</a>
<a name="ln987">    case QPaintDevice::PdmDevicePixelRatio:</a>
<a name="ln988">    case QPaintDevice::PdmDevicePixelRatioScaled:</a>
<a name="ln989">        return 1;</a>
<a name="ln990">    default:</a>
<a name="ln991">        qWarning(&quot;SvgGenerator::metric(), unhandled metric %d\n&quot;, metric);</a>
<a name="ln992">        break;</a>
<a name="ln993">    }</a>
<a name="ln994">    return 0;</a>
<a name="ln995">}</a>
<a name="ln996"> </a>
<a name="ln997">/*!</a>
<a name="ln998">    setElement() function</a>
<a name="ln999">    Sets the _element variable in SvgPaintEngine.</a>
<a name="ln1000">    Called by saveSVG() in mscore/file.cpp.</a>
<a name="ln1001">*/</a>
<a name="ln1002">void SvgGenerator::setElement(const Ms::Element* e) {</a>
<a name="ln1003">    static_cast&lt;SvgPaintEngine*&gt;(paintEngine())-&gt;_element = e;</a>
<a name="ln1004">}</a>
<a name="ln1005"> </a>
<a name="ln1006">/*****************************************************************************</a>
<a name="ln1007"> * class SvgPaintEngine</a>
<a name="ln1008"> */</a>
<a name="ln1009"> </a>
<a name="ln1010">bool SvgPaintEngine::begin(QPaintDevice *)</a>
<a name="ln1011">{</a>
<a name="ln1012">    Q_D(SvgPaintEngine);</a>
<a name="ln1013"> </a>
<a name="ln1014">    // Check for errors</a>
<a name="ln1015">    if (!d-&gt;outputDevice) {</a>
<a name="ln1016">        qWarning(&quot;SvgPaintEngine::begin(), no output device&quot;);</a>
<a name="ln1017">        return false;</a>
<a name="ln1018">    }</a>
<a name="ln1019">    if (!d-&gt;outputDevice-&gt;isOpen()) {</a>
<a name="ln1020">        if (!d-&gt;outputDevice-&gt;open(QIODevice::WriteOnly | QIODevice::Text)) {</a>
<a name="ln1021">            qWarning(&quot;SvgPaintEngine::begin(), could not open output device: '%s'&quot;,</a>
<a name="ln1022">                     qPrintable(d-&gt;outputDevice-&gt;errorString()));</a>
<a name="ln1023">            return false;</a>
<a name="ln1024">        }</a>
<a name="ln1025">    } else if (!d-&gt;outputDevice-&gt;isWritable()) {</a>
<a name="ln1026">        qWarning(&quot;SvgPaintEngine::begin(), could not write to read-only output device: '%s'&quot;,</a>
<a name="ln1027">                 qPrintable(d-&gt;outputDevice-&gt;errorString()));</a>
<a name="ln1028">        return false;</a>
<a name="ln1029">    }</a>
<a name="ln1030"> </a>
<a name="ln1031">    // Stream the headers</a>
<a name="ln1032">    d-&gt;stream = new QTextStream(&amp;d-&gt;header);</a>
<a name="ln1033">    stream() &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot; standalone=\&quot;no\&quot;?&gt;&quot; &lt;&lt; endl &lt;&lt; SVG_BEGIN;</a>
<a name="ln1034">    if (d-&gt;viewBox.isValid()) {</a>
<a name="ln1035">        // viewBox has floating point values, size width/height is integer</a>
<a name="ln1036">        stream() &lt;&lt; SVG_WIDTH    &lt;&lt; d-&gt;viewBox.width()  &lt;&lt; SVG_PX &lt;&lt; SVG_QUOTE</a>
<a name="ln1037">                 &lt;&lt; SVG_HEIGHT   &lt;&lt; d-&gt;viewBox.height() &lt;&lt; SVG_PX &lt;&lt; SVG_QUOTE;</a>
<a name="ln1038"> </a>
<a name="ln1039">        stream() &lt;&lt; SVG_VIEW_BOX &lt;&lt; d-&gt;viewBox.left()</a>
<a name="ln1040">                 &lt;&lt; SVG_SPACE    &lt;&lt; d-&gt;viewBox.top()</a>
<a name="ln1041">                 &lt;&lt; SVG_SPACE    &lt;&lt; d-&gt;viewBox.width()</a>
<a name="ln1042">                 &lt;&lt; SVG_SPACE    &lt;&lt; d-&gt;viewBox.height() &lt;&lt; SVG_QUOTE &lt;&lt; endl;</a>
<a name="ln1043">    }</a>
<a name="ln1044">    stream() &lt;&lt; &quot; xmlns=\&quot;http://www.w3.org/2000/svg\&quot;&quot;</a>
<a name="ln1045">                &quot; xmlns:xlink=\&quot;http://www.w3.org/1999/xlink\&quot;&quot;</a>
<a name="ln1046">                &quot; version=\&quot;1.2\&quot; baseProfile=\&quot;tiny\&quot;&gt;&quot; &lt;&lt; endl;</a>
<a name="ln1047">    if (!d-&gt;attributes.title.isEmpty()) {</a>
<a name="ln1048">        stream() &lt;&lt; SVG_TITLE_BEGIN &lt;&lt; d-&gt;attributes.title.toHtmlEscaped() &lt;&lt; SVG_TITLE_END &lt;&lt; endl;</a>
<a name="ln1049">    }</a>
<a name="ln1050">    if (!d-&gt;attributes.description.isEmpty()) {</a>
<a name="ln1051">        stream() &lt;&lt; SVG_DESC_BEGIN  &lt;&lt; d-&gt;attributes.description.toHtmlEscaped() &lt;&lt; SVG_DESC_END &lt;&lt; endl;</a>
<a name="ln1052">    }</a>
<a name="ln1053"> </a>
<a name="ln1054">// &lt;defs&gt; is currently empty. It's necessary for gradients.</a>
<a name="ln1055">//    d-&gt;stream-&gt;setString(&amp;d-&gt;defs);</a>
<a name="ln1056">//    *d-&gt;stream &lt;&lt; &quot;&lt;defs&gt;\n&quot;;</a>
<a name="ln1057"> </a>
<a name="ln1058">    // Point the stream at the body string, for other functions to populate</a>
<a name="ln1059">    d-&gt;stream-&gt;setString(&amp;d-&gt;body);</a>
<a name="ln1060">    return true;</a>
<a name="ln1061">}</a>
<a name="ln1062"> </a>
<a name="ln1063">bool SvgPaintEngine::end()</a>
<a name="ln1064">{</a>
<a name="ln1065">    Q_D(SvgPaintEngine);</a>
<a name="ln1066"> </a>
<a name="ln1067">// &lt;defs&gt; is currently empty</a>
<a name="ln1068">//    d-&gt;stream-&gt;setString(&amp;d-&gt;defs);</a>
<a name="ln1069">//    stream() &lt;&lt; &quot;&lt;/defs&gt;\n&quot;;</a>
<a name="ln1070"> </a>
<a name="ln1071">    // Point the stream at the real output device (the .svg file)</a>
<a name="ln1072">    d-&gt;stream-&gt;setDevice(d-&gt;outputDevice);</a>
<a name="ln1073"> </a>
<a name="ln1074">#ifndef QT_NO_TEXTCODEC</a>
<a name="ln1075">    d-&gt;stream-&gt;setCodec(QTextCodec::codecForName(&quot;UTF-8&quot;));</a>
<a name="ln1076">#endif</a>
<a name="ln1077"> </a>
<a name="ln1078">    // Stream our strings out to the device, in order</a>
<a name="ln1079">    stream() &lt;&lt; d-&gt;header;</a>
<a name="ln1080">//    stream() &lt;&lt; d-&gt;defs;</a>
<a name="ln1081">    stream() &lt;&lt; d-&gt;body;</a>
<a name="ln1082">    stream() &lt;&lt; SVG_END &lt;&lt; endl;</a>
<a name="ln1083"> </a>
<a name="ln1084">    delete d-&gt;stream;</a>
<a name="ln1085">    return true;</a>
<a name="ln1086">}</a>
<a name="ln1087"> </a>
<a name="ln1088">void SvgPaintEngine::drawPixmap(const QRectF &amp;r, const QPixmap &amp;pm,</a>
<a name="ln1089">                                 const QRectF &amp;sr)</a>
<a name="ln1090">{</a>
<a name="ln1091">    drawImage(r, pm.toImage(), sr);</a>
<a name="ln1092">}</a>
<a name="ln1093"> </a>
<a name="ln1094">void SvgPaintEngine::drawImage(const QRectF  &amp;r, const QImage &amp;image,</a>
<a name="ln1095">                               const QRectF &amp;sr, Qt::ImageConversionFlag flags)</a>
<a name="ln1096">{</a>
<a name="ln1097">    Q_UNUSED(sr);</a>
<a name="ln1098">    Q_UNUSED(flags);</a>
<a name="ln1099"> </a>
<a name="ln1100">    QByteArray      data;</a>
<a name="ln1101">    QBuffer buffer(&amp;data);</a>
<a name="ln1102"> </a>
<a name="ln1103">    buffer.open(QBuffer::ReadWrite);</a>
<a name="ln1104">    image.save(&amp;buffer, &quot;PNG&quot;);</a>
<a name="ln1105">    buffer.close();</a>
<a name="ln1106"> </a>
<a name="ln1107"> </a>
<a name="ln1108">    // check whether we can just use the original raster image</a>
<a name="ln1109">    // to reduce the resulting file size</a>
<a name="ln1110">    if (_element &amp;&amp; _element-&gt;isImage()) {</a>
<a name="ln1111">        static const QList&lt;QString&gt; allowedImageTypes {</a>
<a name="ln1112">            &quot;image/jpeg&quot;,</a>
<a name="ln1113">            &quot;image/png&quot;</a>
<a name="ln1114">        };</a>
<a name="ln1115"> </a>
<a name="ln1116">        const Ms::Image* img = Ms::toImage(_element);</a>
<a name="ln1117">        const Ms::ImageStoreItem* storeItem = img-&gt;storeItem(); // holds the original image file content</a>
<a name="ln1118">        if (img-&gt;getImageType() == Ms::ImageType::RASTER &amp;&amp; storeItem) {</a>
<a name="ln1119">            const QByteArray&amp; imgData = storeItem-&gt;buffer();</a>
<a name="ln1120">            const QMimeType type = QMimeDatabase().mimeTypeForData(imgData);</a>
<a name="ln1121">            if (type.isValid() &amp;&amp; allowedImageTypes.contains(type.name())</a>
<a name="ln1122">                &amp;&amp; imgData.size() &lt; data.size()) {</a>
<a name="ln1123">                // this really can save space, save the original image</a>
<a name="ln1124">                writeImage(r, imgData, type.name());</a>
<a name="ln1125">                return;</a>
<a name="ln1126">            }</a>
<a name="ln1127">        }</a>
<a name="ln1128">    }</a>
<a name="ln1129"> </a>
<a name="ln1130">    writeImage(r, data, &quot;image/png&quot;);</a>
<a name="ln1131">}</a>
<a name="ln1132"> </a>
<a name="ln1133">void SvgPaintEngine::writeImage(const QRectF&amp; r, const QByteArray&amp; imageData, const QString&amp; mimeFormat)</a>
<a name="ln1134">{</a>
<a name="ln1135">    stream() &lt;&lt; SVG_IMAGE           &lt;&lt; stateString</a>
<a name="ln1136">             &lt;&lt; SVG_X &lt;&lt; SVG_QUOTE  &lt;&lt; r.x() + _dx &lt;&lt; SVG_QUOTE</a>
<a name="ln1137">             &lt;&lt; SVG_Y &lt;&lt; SVG_QUOTE  &lt;&lt; r.y() + _dy &lt;&lt; SVG_QUOTE</a>
<a name="ln1138">             &lt;&lt; SVG_WIDTH           &lt;&lt; r.width()   &lt;&lt; SVG_QUOTE</a>
<a name="ln1139">             &lt;&lt; SVG_HEIGHT          &lt;&lt; r.height()  &lt;&lt; SVG_QUOTE</a>
<a name="ln1140">             &lt;&lt; SVG_PRESERVE_ASPECT &lt;&lt; SVG_NONE    &lt;&lt; SVG_QUOTE;</a>
<a name="ln1141"> </a>
<a name="ln1142">    stream() &lt;&lt; &quot; xlink:href=\&quot;data:&quot; &lt;&lt; mimeFormat &lt;&lt; &quot;;base64,&quot;</a>
<a name="ln1143">             &lt;&lt; imageData.toBase64() &lt;&lt; SVG_QUOTE &lt;&lt; SVG_ELEMENT_END &lt;&lt; endl;</a>
<a name="ln1144">}</a>
<a name="ln1145"> </a>
<a name="ln1146">void SvgPaintEngine::updateState(const QPaintEngineState &amp;s)</a>
<a name="ln1147">{</a>
<a name="ln1148">    // Always start fresh</a>
<a name="ln1149">    stateString.clear();</a>
<a name="ln1150"> </a>
<a name="ln1151">    // stateString = Attribute Settings</a>
<a name="ln1152"> </a>
<a name="ln1153">    // SVG class attribute, based on Ms::ElementType</a>
<a name="ln1154">    stateStream &lt;&lt; SVG_CLASS &lt;&lt; getClass(_element) &lt;&lt; SVG_QUOTE;</a>
<a name="ln1155"> </a>
<a name="ln1156">    // Brush and Pen attributes</a>
<a name="ln1157">    stateStream &lt;&lt; qbrushToSvg(s.brush());</a>
<a name="ln1158">    stateStream &lt;&lt;   qpenToSvg(s.pen());</a>
<a name="ln1159"> </a>
<a name="ln1160">// TBD:  &quot;opacity&quot; attribute: Is it ever used?</a>
<a name="ln1161">//       Or is opacity determined by fill-opacity &amp; stroke-opacity instead?</a>
<a name="ln1162">// PLUS: qFuzzyIsNull() is not officially supported in Qt.</a>
<a name="ln1163">//       Should probably use QFuzzyCompare() instead.</a>
<a name="ln1164">    if (!qFuzzyIsNull(s.opacity() - 1))</a>
<a name="ln1165">        stateStream &lt;&lt; SVG_OPACITY &lt;&lt; s.opacity() &lt;&lt; SVG_QUOTE;</a>
<a name="ln1166"> </a>
<a name="ln1167">    // Translations, SVG transform=&quot;translate()&quot;, are handled separately from</a>
<a name="ln1168">    // other transformations such as rotation. Qt translates everything, but</a>
<a name="ln1169">    // other transformations do occur, and must be handled here.</a>
<a name="ln1170">    QTransform t = s.transform();</a>
<a name="ln1171"> </a>
<a name="ln1172">    // Tablature Note Text:</a>
<a name="ln1173">    // m11 and m22 have floating point flotsam, for example: 1.000000629</a>
<a name="ln1174">    // Both values should be == integer 1, because no scaling is intended.</a>
<a name="ln1175">    // So round them to three decimal places, as MuseScore does elsewhere.</a>
<a name="ln1176">    const qreal m11 = qRound(t.m11() * 1000) / 1000.0;</a>
<a name="ln1177">    const qreal m22 = qRound(t.m22() * 1000) / 1000.0;</a>
<a name="ln1178"> </a>
<a name="ln1179">    if (m11 == 1 &amp;&amp; m22 == 1   // No scaling</a>
<a name="ln1180">      &amp;&amp; t.m12() == t.m21()) { // No rotation, etc.</a>
<a name="ln1181">          // No transformation except translation</a>
<a name="ln1182">          _dx = t.m31();</a>
<a name="ln1183">          _dy = t.m32();</a>
<a name="ln1184">    }</a>
<a name="ln1185">    else {</a>
<a name="ln1186">          // Other transformations are more straightforward with a full matrix</a>
<a name="ln1187">          _dx = 0;</a>
<a name="ln1188">          _dy = 0;</a>
<a name="ln1189">          stateStream &lt;&lt; SVG_MATRIX &lt;&lt; t.m11() &lt;&lt; SVG_COMMA</a>
<a name="ln1190">                                    &lt;&lt; t.m12() &lt;&lt; SVG_COMMA</a>
<a name="ln1191">                                    &lt;&lt; t.m21() &lt;&lt; SVG_COMMA</a>
<a name="ln1192">                                    &lt;&lt; t.m22() &lt;&lt; SVG_COMMA</a>
<a name="ln1193">                                    &lt;&lt; t.m31() &lt;&lt; SVG_COMMA</a>
<a name="ln1194">                                    &lt;&lt; t.m32() &lt;&lt; SVG_RPAREN_QUOTE;</a>
<a name="ln1195">    }</a>
<a name="ln1196"> </a>
<a name="ln1197">}</a>
<a name="ln1198"> </a>
<a name="ln1199">void SvgPaintEngine::drawPath(const QPainterPath &amp;p)</a>
<a name="ln1200">{</a>
<a name="ln1201">    stream() &lt;&lt; SVG_PATH &lt;&lt; stateString;</a>
<a name="ln1202"> </a>
<a name="ln1203">    // fill-rule is here because UpdateState() doesn't have a QPainterPath arg</a>
<a name="ln1204">    // Majority of &lt;path&gt;s use the default value: fill-rule=&quot;nonzero&quot;</a>
<a name="ln1205">    if (p.fillRule() == Qt::OddEvenFill)</a>
<a name="ln1206">        stream() &lt;&lt; SVG_FILL_RULE;</a>
<a name="ln1207"> </a>
<a name="ln1208">    // Path data</a>
<a name="ln1209">    stream() &lt;&lt; SVG_D;</a>
<a name="ln1210">    for (int i = 0; i &lt; p.elementCount(); ++i) {</a>
<a name="ln1211">        const QPainterPath::Element &amp;e = p.elementAt(i);</a>
<a name="ln1212">                               qreal x = e.x + _dx;</a>
<a name="ln1213">                               qreal y = e.y + _dy;</a>
<a name="ln1214">        switch (e.type) {</a>
<a name="ln1215">        case QPainterPath::MoveToElement:</a>
<a name="ln1216">            stream() &lt;&lt; SVG_MOVE  &lt;&lt; x &lt;&lt; SVG_COMMA &lt;&lt; y;</a>
<a name="ln1217">            break;</a>
<a name="ln1218">        case QPainterPath::LineToElement:</a>
<a name="ln1219">            stream() &lt;&lt; SVG_LINE  &lt;&lt; x &lt;&lt; SVG_COMMA &lt;&lt; y;</a>
<a name="ln1220">            break;</a>
<a name="ln1221">        case QPainterPath::CurveToElement:</a>
<a name="ln1222">            stream() &lt;&lt; SVG_CURVE &lt;&lt; x &lt;&lt; SVG_COMMA &lt;&lt; y;</a>
<a name="ln1223">            ++i;</a>
<a name="ln1224">            while (i &lt; p.elementCount()) {</a>
<a name="ln1225">                const QPainterPath::Element &amp;ee = p.elementAt(i);</a>
<a name="ln1226">                if (ee.type == QPainterPath::CurveToDataElement) {</a>
<a name="ln1227">                    stream() &lt;&lt; SVG_SPACE &lt;&lt; ee.x + _dx</a>
<a name="ln1228">                             &lt;&lt; SVG_COMMA &lt;&lt; ee.y + _dy;</a>
<a name="ln1229">                    ++i;</a>
<a name="ln1230">                }</a>
<a name="ln1231">                else {</a>
<a name="ln1232">                    --i;</a>
<a name="ln1233">                    break;</a>
<a name="ln1234">                }</a>
<a name="ln1235">            }</a>
<a name="ln1236">            break;</a>
<a name="ln1237">        default:</a>
<a name="ln1238">            break;</a>
<a name="ln1239">        }</a>
<a name="ln1240">        if (i &lt;= p.elementCount() - 1)</a>
<a name="ln1241">            stream() &lt;&lt; SVG_SPACE;</a>
<a name="ln1242">    }</a>
<a name="ln1243">    stream() &lt;&lt; SVG_QUOTE &lt;&lt; SVG_ELEMENT_END &lt;&lt; endl;</a>
<a name="ln1244">}</a>
<a name="ln1245"> </a>
<a name="ln1246">void SvgPaintEngine::drawPolygon(const QPointF *points, int pointCount,</a>
<a name="ln1247">                                  PolygonDrawMode mode)</a>
<a name="ln1248">{</a>
<a name="ln1249">    Q_ASSERT(pointCount &gt;= 2);</a>
<a name="ln1250"> </a>
<a name="ln1251">    QPainterPath path(points[0]);</a>
<a name="ln1252">    for (int i=1; i&lt;pointCount; ++i)</a>
<a name="ln1253">        path.lineTo(points[i]);</a>
<a name="ln1254"> </a>
<a name="ln1255">    if (mode == PolylineMode) {</a>
<a name="ln1256">        stream() &lt;&lt; SVG_POLYLINE &lt;&lt; stateString</a>
<a name="ln1257">                 &lt;&lt; SVG_POINTS;</a>
<a name="ln1258">        for (int i = 0; i &lt; pointCount; ++i) {</a>
<a name="ln1259">            const QPointF &amp;pt = points[i];</a>
<a name="ln1260">            stream() &lt;&lt; pt.x() + _dx &lt;&lt; SVG_COMMA &lt;&lt; pt.y() + _dy;</a>
<a name="ln1261">            if (i != pointCount - 1)</a>
<a name="ln1262">                stream() &lt;&lt; SVG_SPACE;</a>
<a name="ln1263">        }</a>
<a name="ln1264">        stream() &lt;&lt; SVG_QUOTE &lt;&lt; SVG_ELEMENT_END &lt;&lt;endl;</a>
<a name="ln1265">    }</a>
<a name="ln1266">    else {</a>
<a name="ln1267">        path.closeSubpath();</a>
<a name="ln1268">        drawPath(path);</a>
<a name="ln1269">    }</a>
<a name="ln1270">}</a>

</code></pre>
<div class="balloon" rel="1021"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'warning' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1026"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'warning' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="319"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: _dx, _dy.</p></div>
<div class="balloon" rel="9"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
