
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>exportxml.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MusE Score</a>
<a name="ln3">//  Linux Music Score Editor</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2020 Werner Schweer and others</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2.</a>
<a name="ln9">//</a>
<a name="ln10">//  This program is distributed in the hope that it will be useful,</a>
<a name="ln11">//  but WITHOUT ANY WARRANTY; without even the implied warranty of</a>
<a name="ln12">//  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</a>
<a name="ln13">//  GNU General Public License for more details.</a>
<a name="ln14">//</a>
<a name="ln15">//  You should have received a copy of the GNU General Public License</a>
<a name="ln16">//  along with this program; if not, write to the Free Software</a>
<a name="ln17">//  Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.</a>
<a name="ln18">//=============================================================================</a>
<a name="ln19"> </a>
<a name="ln20">/**</a>
<a name="ln21"> MusicXML export.</a>
<a name="ln22"> */</a>
<a name="ln23"> </a>
<a name="ln24">// TODO: trill lines need to be handled the same way as slurs</a>
<a name="ln25">// in MuseScore they are measure level elements, while in MusicXML</a>
<a name="ln26">// they are attached to notes (as ornaments)</a>
<a name="ln27"> </a>
<a name="ln28">//=========================================================</a>
<a name="ln29">//  LVI FIXME</a>
<a name="ln30">//</a>
<a name="ln31">//  Evaluate paramenter handling between the various classes, could be simplified</a>
<a name="ln32">//=========================================================</a>
<a name="ln33"> </a>
<a name="ln34">// TODO LVI 2011-10-30: determine how to report export errors.</a>
<a name="ln35">// Currently all output (both debug and error reports) are done using qDebug.</a>
<a name="ln36"> </a>
<a name="ln37">#include &lt;math.h&gt;</a>
<a name="ln38">#include &quot;config.h&quot;</a>
<a name="ln39">//#include &quot;musescore.h&quot;</a>
<a name="ln40">#include &quot;file.h&quot;</a>
<a name="ln41">#include &quot;libmscore/score.h&quot;</a>
<a name="ln42">#include &quot;libmscore/rest.h&quot;</a>
<a name="ln43">#include &quot;libmscore/chord.h&quot;</a>
<a name="ln44">#include &quot;libmscore/sig.h&quot;</a>
<a name="ln45">#include &quot;libmscore/key.h&quot;</a>
<a name="ln46">#include &quot;libmscore/clef.h&quot;</a>
<a name="ln47">#include &quot;libmscore/note.h&quot;</a>
<a name="ln48">#include &quot;libmscore/segment.h&quot;</a>
<a name="ln49">#include &quot;libmscore/xml.h&quot;</a>
<a name="ln50">#include &quot;libmscore/beam.h&quot;</a>
<a name="ln51">#include &quot;libmscore/staff.h&quot;</a>
<a name="ln52">#include &quot;libmscore/part.h&quot;</a>
<a name="ln53">#include &quot;libmscore/measure.h&quot;</a>
<a name="ln54">#include &quot;libmscore/style.h&quot;</a>
<a name="ln55">#include &quot;musicxml.h&quot;</a>
<a name="ln56">#include &quot;libmscore/slur.h&quot;</a>
<a name="ln57">#include &quot;libmscore/hairpin.h&quot;</a>
<a name="ln58">#include &quot;libmscore/dynamic.h&quot;</a>
<a name="ln59">#include &quot;libmscore/barline.h&quot;</a>
<a name="ln60">#include &quot;libmscore/timesig.h&quot;</a>
<a name="ln61">#include &quot;libmscore/ottava.h&quot;</a>
<a name="ln62">#include &quot;libmscore/pedal.h&quot;</a>
<a name="ln63">#include &quot;libmscore/text.h&quot;</a>
<a name="ln64">#include &quot;libmscore/tuplet.h&quot;</a>
<a name="ln65">#include &quot;libmscore/lyrics.h&quot;</a>
<a name="ln66">#include &quot;libmscore/volta.h&quot;</a>
<a name="ln67">#include &quot;libmscore/keysig.h&quot;</a>
<a name="ln68">#include &quot;libmscore/bracket.h&quot;</a>
<a name="ln69">#include &quot;libmscore/arpeggio.h&quot;</a>
<a name="ln70">#include &quot;libmscore/jump.h&quot;</a>
<a name="ln71">#include &quot;libmscore/marker.h&quot;</a>
<a name="ln72">#include &quot;libmscore/tremolo.h&quot;</a>
<a name="ln73">#include &quot;libmscore/trill.h&quot;</a>
<a name="ln74">#include &quot;libmscore/harmony.h&quot;</a>
<a name="ln75">#include &quot;libmscore/tempotext.h&quot;</a>
<a name="ln76">#include &quot;libmscore/sym.h&quot;</a>
<a name="ln77">#include &quot;libmscore/pitchspelling.h&quot;</a>
<a name="ln78">#include &quot;libmscore/utils.h&quot;</a>
<a name="ln79">#include &quot;libmscore/articulation.h&quot;</a>
<a name="ln80">#include &quot;libmscore/page.h&quot;</a>
<a name="ln81">#include &quot;libmscore/system.h&quot;</a>
<a name="ln82">#include &quot;libmscore/element.h&quot;</a>
<a name="ln83">#include &quot;libmscore/glissando.h&quot;</a>
<a name="ln84">#include &quot;libmscore/navigate.h&quot;</a>
<a name="ln85">#include &quot;libmscore/spanner.h&quot;</a>
<a name="ln86">#include &quot;libmscore/drumset.h&quot;</a>
<a name="ln87">#include &quot;preferences.h&quot;</a>
<a name="ln88">#include &quot;libmscore/mscore.h&quot;</a>
<a name="ln89">#include &quot;libmscore/accidental.h&quot;</a>
<a name="ln90">#include &quot;libmscore/breath.h&quot;</a>
<a name="ln91">#include &quot;libmscore/chordline.h&quot;</a>
<a name="ln92">#include &quot;libmscore/figuredbass.h&quot;</a>
<a name="ln93">#include &quot;libmscore/stringdata.h&quot;</a>
<a name="ln94">#include &quot;libmscore/rehearsalmark.h&quot;</a>
<a name="ln95">#include &quot;thirdparty/qzip/qzipwriter_p.h&quot;</a>
<a name="ln96">#include &quot;libmscore/fret.h&quot;</a>
<a name="ln97">#include &quot;libmscore/tie.h&quot;</a>
<a name="ln98">#include &quot;libmscore/undo.h&quot;</a>
<a name="ln99">#include &quot;libmscore/textline.h&quot;</a>
<a name="ln100">#include &quot;libmscore/fermata.h&quot;</a>
<a name="ln101">#include &quot;musicxmlfonthandler.h&quot;</a>
<a name="ln102">#include &quot;libmscore/textframe.h&quot;</a>
<a name="ln103">#include &quot;libmscore/instrchange.h&quot;</a>
<a name="ln104"> </a>
<a name="ln105">namespace Ms {</a>
<a name="ln106"> </a>
<a name="ln107">//---------------------------------------------------------</a>
<a name="ln108">//   local defines for debug output</a>
<a name="ln109">//---------------------------------------------------------</a>
<a name="ln110"> </a>
<a name="ln111">// #define DEBUG_CLEF true</a>
<a name="ln112">// #define DEBUG_REPEATS true</a>
<a name="ln113">// #define DEBUG_TICK true</a>
<a name="ln114"> </a>
<a name="ln115">#ifdef DEBUG_CLEF</a>
<a name="ln116">#define clefDebug(...) qDebug(__VA_ARGS__)</a>
<a name="ln117">#else</a>
<a name="ln118">#define clefDebug(...) {}</a>
<a name="ln119">#endif</a>
<a name="ln120"> </a>
<a name="ln121">//---------------------------------------------------------</a>
<a name="ln122">//   typedefs</a>
<a name="ln123">//---------------------------------------------------------</a>
<a name="ln124"> </a>
<a name="ln125">typedef QMap&lt;int, const FiguredBass*&gt; FigBassMap;</a>
<a name="ln126"> </a>
<a name="ln127">//---------------------------------------------------------</a>
<a name="ln128">//   attributes -- prints &lt;attributes&gt; tag when necessary</a>
<a name="ln129">//---------------------------------------------------------</a>
<a name="ln130"> </a>
<a name="ln131">class Attributes {</a>
<a name="ln132">      bool inAttributes;</a>
<a name="ln133"> </a>
<a name="ln134">public:</a>
<a name="ln135">      Attributes() { start(); }</a>
<a name="ln136">      void doAttr(XmlWriter&amp; xml, bool attr);</a>
<a name="ln137">      void start();</a>
<a name="ln138">      void stop(XmlWriter&amp; xml);</a>
<a name="ln139">      };</a>
<a name="ln140"> </a>
<a name="ln141">//---------------------------------------------------------</a>
<a name="ln142">//   doAttr - when necessary change state and print &lt;attributes&gt; tag</a>
<a name="ln143">//---------------------------------------------------------</a>
<a name="ln144"> </a>
<a name="ln145">void Attributes::doAttr(XmlWriter&amp; xml, bool attr)</a>
<a name="ln146">      {</a>
<a name="ln147">      if (!inAttributes &amp;&amp; attr) {</a>
<a name="ln148">            xml.stag(&quot;attributes&quot;);</a>
<a name="ln149">            inAttributes = true;</a>
<a name="ln150">            }</a>
<a name="ln151">      else if (inAttributes &amp;&amp; !attr) {</a>
<a name="ln152">            xml.etag();</a>
<a name="ln153">            inAttributes = false;</a>
<a name="ln154">            }</a>
<a name="ln155">      }</a>
<a name="ln156"> </a>
<a name="ln157">//---------------------------------------------------------</a>
<a name="ln158">//   start -- initialize</a>
<a name="ln159">//---------------------------------------------------------</a>
<a name="ln160"> </a>
<a name="ln161">void Attributes::start()</a>
<a name="ln162">      {</a>
<a name="ln163">      inAttributes = false;</a>
<a name="ln164">      }</a>
<a name="ln165"> </a>
<a name="ln166">//---------------------------------------------------------</a>
<a name="ln167">//   stop -- print &lt;/attributes&gt; tag when necessary</a>
<a name="ln168">//---------------------------------------------------------</a>
<a name="ln169"> </a>
<a name="ln170">void Attributes::stop(XmlWriter&amp; xml)</a>
<a name="ln171">      {</a>
<a name="ln172">      if (inAttributes) {</a>
<a name="ln173">            xml.etag();</a>
<a name="ln174">            inAttributes = false;</a>
<a name="ln175">            }</a>
<a name="ln176">      }</a>
<a name="ln177"> </a>
<a name="ln178">//---------------------------------------------------------</a>
<a name="ln179">//   notations -- prints &lt;notations&gt; tag when necessary</a>
<a name="ln180">//---------------------------------------------------------</a>
<a name="ln181"> </a>
<a name="ln182">class Notations {</a>
<a name="ln183">      bool notationsPrinted;</a>
<a name="ln184"> </a>
<a name="ln185">public:</a>
<a name="ln186">      Notations() { notationsPrinted = false; }</a>
<a name="ln187">      void tag(XmlWriter&amp; xml);</a>
<a name="ln188">      void etag(XmlWriter&amp; xml);</a>
<a name="ln189">      };</a>
<a name="ln190"> </a>
<a name="ln191">//---------------------------------------------------------</a>
<a name="ln192">//   articulations -- prints &lt;articulations&gt; tag when necessary</a>
<a name="ln193">//---------------------------------------------------------</a>
<a name="ln194"> </a>
<a name="ln195">class Articulations {</a>
<a name="ln196">      bool articulationsPrinted;</a>
<a name="ln197"> </a>
<a name="ln198">public:</a>
<a name="ln199">      Articulations() { articulationsPrinted = false; }</a>
<a name="ln200">      void tag(XmlWriter&amp; xml);</a>
<a name="ln201">      void etag(XmlWriter&amp; xml);</a>
<a name="ln202">      };</a>
<a name="ln203"> </a>
<a name="ln204">//---------------------------------------------------------</a>
<a name="ln205">//   ornaments -- prints &lt;ornaments&gt; tag when necessary</a>
<a name="ln206">//---------------------------------------------------------</a>
<a name="ln207"> </a>
<a name="ln208">class Ornaments {</a>
<a name="ln209">      bool ornamentsPrinted;</a>
<a name="ln210"> </a>
<a name="ln211">public:</a>
<a name="ln212">      Ornaments() { ornamentsPrinted = false; }</a>
<a name="ln213">      void tag(XmlWriter&amp; xml);</a>
<a name="ln214">      void etag(XmlWriter&amp; xml);</a>
<a name="ln215">      };</a>
<a name="ln216"> </a>
<a name="ln217">//---------------------------------------------------------</a>
<a name="ln218">//   technical -- prints &lt;technical&gt; tag when necessary</a>
<a name="ln219">//---------------------------------------------------------</a>
<a name="ln220"> </a>
<a name="ln221">class Technical {</a>
<a name="ln222">      bool technicalPrinted;</a>
<a name="ln223"> </a>
<a name="ln224">public:</a>
<a name="ln225">      Technical() { technicalPrinted = false; }</a>
<a name="ln226">      void tag(XmlWriter&amp; xml);</a>
<a name="ln227">      void etag(XmlWriter&amp; xml);</a>
<a name="ln228">      };</a>
<a name="ln229"> </a>
<a name="ln230">//---------------------------------------------------------</a>
<a name="ln231">//   slur handler -- prints &lt;slur&gt; tags</a>
<a name="ln232">//---------------------------------------------------------</a>
<a name="ln233"> </a>
<a name="ln234">class SlurHandler {</a>
<a name="ln235">      const Slur* slur[MAX_NUMBER_LEVEL];</a>
<a name="ln236">      bool started[MAX_NUMBER_LEVEL];</a>
<a name="ln237">      int findSlur(const Slur* s) const;</a>
<a name="ln238"> </a>
<a name="ln239">public:</a>
<a name="ln240">      SlurHandler();</a>
<a name="ln241">      void doSlurs(const ChordRest* chordRest, Notations&amp; notations, XmlWriter&amp; xml);</a>
<a name="ln242"> </a>
<a name="ln243">private:</a>
<a name="ln244">      void doSlurStart(const Slur* s, Notations&amp; notations, XmlWriter&amp; xml);</a>
<a name="ln245">      void doSlurStop(const Slur* s, Notations&amp; notations, XmlWriter&amp; xml);</a>
<a name="ln246">      };</a>
<a name="ln247"> </a>
<a name="ln248">//---------------------------------------------------------</a>
<a name="ln249">//   glissando handler -- prints &lt;glissando&gt; tags</a>
<a name="ln250">//---------------------------------------------------------</a>
<a name="ln251"> </a>
<a name="ln252">class GlissandoHandler {</a>
<a name="ln253">      const Note* glissNote[MAX_NUMBER_LEVEL];</a>
<a name="ln254">      const Note* slideNote[MAX_NUMBER_LEVEL];</a>
<a name="ln255">      int findNote(const Note* note, int type) const;</a>
<a name="ln256"> </a>
<a name="ln257">public:</a>
<a name="ln258">      GlissandoHandler();</a>
<a name="ln259">      void doGlissandoStart(Glissando* gliss, Notations&amp; notations, XmlWriter&amp; xml);</a>
<a name="ln260">      void doGlissandoStop(Glissando* gliss, Notations&amp; notations, XmlWriter&amp; xml);</a>
<a name="ln261">      };</a>
<a name="ln262"> </a>
<a name="ln263">//---------------------------------------------------------</a>
<a name="ln264">//  MeasureNumberStateHandler</a>
<a name="ln265">//---------------------------------------------------------</a>
<a name="ln266"> </a>
<a name="ln267">/**</a>
<a name="ln268"> State handler used to calculate measure number including implicit flag.</a>
<a name="ln269"> To be called once at the start of each measure in a part.</a>
<a name="ln270"> */</a>
<a name="ln271"> </a>
<a name="ln272">class MeasureNumberStateHandler final</a>
<a name="ln273">      {</a>
<a name="ln274">public:</a>
<a name="ln275">      MeasureNumberStateHandler();</a>
<a name="ln276">      void updateForMeasure(const Measure* const m);</a>
<a name="ln277">      QString measureNumber() const;</a>
<a name="ln278">      bool isFirstActualMeasure() const;</a>
<a name="ln279">private:</a>
<a name="ln280">      void init();</a>
<a name="ln281">      int _measureNo;                           // number of next regular measure</a>
<a name="ln282">      int _irregularMeasureNo;                  // number of next irregular measure</a>
<a name="ln283">      int _pickupMeasureNo;                     // number of next pickup measure</a>
<a name="ln284">      QString _cachedAttributes;                // attributes calculated by updateForMeasure()</a>
<a name="ln285">      };</a>
<a name="ln286"> </a>
<a name="ln287">//---------------------------------------------------------</a>
<a name="ln288">//   MeasurePrintContext</a>
<a name="ln289">//---------------------------------------------------------</a>
<a name="ln290"> </a>
<a name="ln291">struct MeasurePrintContext final</a>
<a name="ln292">      {</a>
<a name="ln293">      void measureWritten(const Measure* m);</a>
<a name="ln294">      bool scoreStart = true;</a>
<a name="ln295">      bool pageStart = true;</a>
<a name="ln296">      bool systemStart = true;</a>
<a name="ln297">      const Measure* prevMeasure = nullptr;</a>
<a name="ln298">      const System* prevSystem = nullptr;</a>
<a name="ln299">      const System* lastSystemPrevPage = nullptr;</a>
<a name="ln300">      };</a>
<a name="ln301"> </a>
<a name="ln302">//---------------------------------------------------------</a>
<a name="ln303">//   ExportMusicXml</a>
<a name="ln304">//---------------------------------------------------------</a>
<a name="ln305"> </a>
<a name="ln306">typedef QHash&lt;const ChordRest* const, const Trill*&gt; TrillHash;</a>
<a name="ln307">typedef QMap&lt;const Instrument*, int&gt; MxmlInstrumentMap;</a>
<a name="ln308"> </a>
<a name="ln309">class ExportMusicXml {</a>
<a name="ln310">      Score* _score;</a>
<a name="ln311">      XmlWriter _xml;</a>
<a name="ln312">      SlurHandler sh;</a>
<a name="ln313">      GlissandoHandler gh;</a>
<a name="ln314">      Fraction _tick;</a>
<a name="ln315">      Attributes _attr;</a>
<a name="ln316">      TextLine const* brackets[MAX_NUMBER_LEVEL];</a>
<a name="ln317">      TextLineBase const* dashes[MAX_NUMBER_LEVEL];</a>
<a name="ln318">      Hairpin const* hairpins[MAX_NUMBER_LEVEL];</a>
<a name="ln319">      Ottava const* ottavas[MAX_NUMBER_LEVEL];</a>
<a name="ln320">      Trill const* trills[MAX_NUMBER_LEVEL];</a>
<a name="ln321">      int div;</a>
<a name="ln322">      double millimeters;</a>
<a name="ln323">      int tenths;</a>
<a name="ln324">      TrillHash _trillStart;</a>
<a name="ln325">      TrillHash _trillStop;</a>
<a name="ln326">      MxmlInstrumentMap instrMap;</a>
<a name="ln327"> </a>
<a name="ln328">      int findBracket(const TextLine* tl) const;</a>
<a name="ln329">      int findDashes(const TextLineBase* tl) const;</a>
<a name="ln330">      int findHairpin(const Hairpin* tl) const;</a>
<a name="ln331">      int findOttava(const Ottava* tl) const;</a>
<a name="ln332">      int findTrill(const Trill* tl) const;</a>
<a name="ln333">      void chord(Chord* chord, int staff, const std::vector&lt;Lyrics*&gt;* ll, bool useDrumset);</a>
<a name="ln334">      void rest(Rest* chord, int staff);</a>
<a name="ln335">      void clef(int staff, const ClefType ct, const QString&amp; extraAttributes = &quot;&quot;);</a>
<a name="ln336">      void timesig(TimeSig* tsig);</a>
<a name="ln337">      void keysig(const KeySig* ks, ClefType ct, int staff = 0, bool visible = true);</a>
<a name="ln338">      void barlineLeft(const Measure* const m);</a>
<a name="ln339">      void barlineMiddle(const BarLine* bl);</a>
<a name="ln340">      void barlineRight(const Measure* const m);</a>
<a name="ln341">      void lyrics(const std::vector&lt;Lyrics*&gt;* ll, const int trk);</a>
<a name="ln342">      void work(const MeasureBase* measure);</a>
<a name="ln343">      void calcDivMoveToTick(const Fraction&amp; t);</a>
<a name="ln344">      void calcDivisions();</a>
<a name="ln345">      void keysigTimesig(const Measure* m, const Part* p);</a>
<a name="ln346">      void chordAttributes(Chord* chord, Notations&amp; notations, Technical&amp; technical,</a>
<a name="ln347">                           TrillHash&amp; trillStart, TrillHash&amp; trillStop);</a>
<a name="ln348">      void wavyLineStartStop(const ChordRest* const cr, Notations&amp; notations, Ornaments&amp; ornaments,</a>
<a name="ln349">                             TrillHash&amp; trillStart, TrillHash&amp; trillStop);</a>
<a name="ln350">      void print(const Measure* const m, const int partNr, const int firstStaffOfPart, const int nrStavesInPart, const MeasurePrintContext&amp; mpc);</a>
<a name="ln351">      void findAndExportClef(const Measure* const m, const int staves, const int strack, const int etrack);</a>
<a name="ln352">      void exportDefaultClef(const Part* const part, const Measure* const m);</a>
<a name="ln353">      void writeElement(Element* el, const Measure* m, int sstaff, bool useDrumset);</a>
<a name="ln354">      void writeMeasureTracks(const Measure* const m, const int partIndex, const int strack, const int staves, const bool useDrumset, FigBassMap&amp; fbMap);</a>
<a name="ln355">      void writeMeasure(const Measure* const m, const int idx, const int staffCount, MeasureNumberStateHandler&amp; mnsh, FigBassMap&amp; fbMap, const MeasurePrintContext&amp; mpc);</a>
<a name="ln356">      void writeParts();</a>
<a name="ln357"> </a>
<a name="ln358">public:</a>
<a name="ln359">      ExportMusicXml(Score* s)</a>
<a name="ln360">            : _xml(s)</a>
<a name="ln361">            {</a>
<a name="ln362">            _score = s; _tick = { 0,1 }; div = 1; tenths = 40;</a>
<a name="ln363">            millimeters = _score-&gt;spatium() * tenths / (10 * DPMM);</a>
<a name="ln364">            }</a>
<a name="ln365">      void write(QIODevice* dev);</a>
<a name="ln366">      void credits(XmlWriter&amp; xml);</a>
<a name="ln367">      void moveToTick(const Fraction&amp; t);</a>
<a name="ln368">      void words(TextBase const* const text, int staff);</a>
<a name="ln369">      void tboxTextAsWords(TextBase const* const text, int staff, QPointF position);</a>
<a name="ln370">      void rehearsal(RehearsalMark const* const rmk, int staff);</a>
<a name="ln371">      void hairpin(Hairpin const* const hp, int staff, const Fraction&amp; tick);</a>
<a name="ln372">      void ottava(Ottava const* const ot, int staff, const Fraction&amp; tick);</a>
<a name="ln373">      void pedal(Pedal const* const pd, int staff, const Fraction&amp; tick);</a>
<a name="ln374">      void textLine(TextLine const* const tl, int staff, const Fraction&amp; tick);</a>
<a name="ln375">      void dynamic(Dynamic const* const dyn, int staff);</a>
<a name="ln376">      void symbol(Symbol const* const sym, int staff);</a>
<a name="ln377">      void tempoText(TempoText const* const text, int staff);</a>
<a name="ln378">      void harmony(Harmony const* const, FretDiagram const* const fd, int offset = 0);</a>
<a name="ln379">      Score* score() const { return _score; };</a>
<a name="ln380">      double getTenthsFromInches(double) const;</a>
<a name="ln381">      double getTenthsFromDots(double) const;</a>
<a name="ln382">      Fraction tick() const { return _tick; }</a>
<a name="ln383">      void writeInstrumentDetails(const Instrument* instrument);</a>
<a name="ln384">      };</a>
<a name="ln385"> </a>
<a name="ln386">//---------------------------------------------------------</a>
<a name="ln387">//   positionToQString</a>
<a name="ln388">//---------------------------------------------------------</a>
<a name="ln389"> </a>
<a name="ln390">static QString positionToQString(const QPointF def, const QPointF rel, const float spatium)</a>
<a name="ln391">      {</a>
<a name="ln392">      // minimum value to export</a>
<a name="ln393">      const float positionElipson = 0.1f;</a>
<a name="ln394"> </a>
<a name="ln395">      // convert into tenths for MusicXML</a>
<a name="ln396">      const float defaultX =  10 * def.x() / spatium;</a>
<a name="ln397">      const float defaultY =  -10 * def.y()  / spatium;</a>
<a name="ln398">      const float relativeX =  10 * rel.x() / spatium;</a>
<a name="ln399">      const float relativeY =  -10 * rel.y() / spatium;</a>
<a name="ln400"> </a>
<a name="ln401">      // generate string representation</a>
<a name="ln402">      QString res;</a>
<a name="ln403">      if (fabsf(defaultX) &gt; positionElipson)</a>
<a name="ln404">            res += QString(&quot; default-x=\&quot;%1\&quot;&quot;).arg(QString::number(defaultX, 'f', 2));</a>
<a name="ln405">      if (fabsf(defaultY) &gt; positionElipson)</a>
<a name="ln406">            res += QString(&quot; default-y=\&quot;%1\&quot;&quot;).arg(QString::number(defaultY, 'f', 2));</a>
<a name="ln407">      if (fabsf(relativeX) &gt; positionElipson)</a>
<a name="ln408">            res += QString(&quot; relative-x=\&quot;%1\&quot;&quot;).arg(QString::number(relativeX, 'f', 2));</a>
<a name="ln409">      if (fabsf(relativeY) &gt; positionElipson)</a>
<a name="ln410">            res += QString(&quot; relative-y=\&quot;%1\&quot;&quot;).arg(QString::number(relativeY, 'f', 2));</a>
<a name="ln411"> </a>
<a name="ln412">      return res;</a>
<a name="ln413">      }</a>
<a name="ln414"> </a>
<a name="ln415">//---------------------------------------------------------</a>
<a name="ln416">//   positioningAttributes</a>
<a name="ln417">//   According to the specs (common.dtd), all direction-type and note elements must be relative to the measure</a>
<a name="ln418">//   while all other elements are relative to their position or the nearest note.</a>
<a name="ln419">//---------------------------------------------------------</a>
<a name="ln420"> </a>
<a name="ln421">static QString positioningAttributes(Element const* const el, bool isSpanStart = true)</a>
<a name="ln422">      {</a>
<a name="ln423">      if (!preferences.getBool(PREF_EXPORT_MUSICXML_EXPORTLAYOUT))</a>
<a name="ln424">            return &quot;&quot;;</a>
<a name="ln425"> </a>
<a name="ln426">      //qDebug(&quot;single el %p _pos x,y %f %f _userOff x,y %f %f spatium %f&quot;,</a>
<a name="ln427">      //       el, el-&gt;ipos().x(), el-&gt;ipos().y(), el-&gt;offset().x(), el-&gt;offset().y(), el-&gt;spatium());</a>
<a name="ln428"> </a>
<a name="ln429">      QPointF def;</a>
<a name="ln430">      QPointF rel;</a>
<a name="ln431">      float spatium = el-&gt;spatium();</a>
<a name="ln432"> </a>
<a name="ln433">      const SLine* span = nullptr;</a>
<a name="ln434">      if (el-&gt;isSLine())</a>
<a name="ln435">            span = static_cast&lt;const SLine*&gt;(el);</a>
<a name="ln436"> </a>
<a name="ln437">      if (span &amp;&amp; !span-&gt;segmentsEmpty()) {</a>
<a name="ln438">            if (isSpanStart) {</a>
<a name="ln439">                  const auto seg = span-&gt;frontSegment();</a>
<a name="ln440">                  const auto offset = seg-&gt;offset();</a>
<a name="ln441">                  const auto p = seg-&gt;pos();</a>
<a name="ln442">                  rel.setX(offset.x());</a>
<a name="ln443">                  def.setY(p.y());</a>
<a name="ln444"> </a>
<a name="ln445">                  //qDebug(&quot;sline start seg %p seg-&gt;pos x,y %f %f seg-&gt;userOff x,y %f %f spatium %f&quot;,</a>
<a name="ln446">                  //       seg, p.x(), p.y(), seg-&gt;offset().x(), seg-&gt;offset().y(), seg-&gt;spatium());</a>
<a name="ln447"> </a>
<a name="ln448">                  }</a>
<a name="ln449">            else {</a>
<a name="ln450">                  const auto seg = span-&gt;backSegment();</a>
<a name="ln451">                  const auto userOff = seg-&gt;offset(); // This is the offset accessible from the inspector</a>
<a name="ln452">                  const auto userOff2 = seg-&gt;userOff2(); // Offset of the actual dragged anchor, which doesn't affect the inspector offset</a>
<a name="ln453">                  //auto pos = seg-&gt;pos();</a>
<a name="ln454">                  //auto pos2 = seg-&gt;pos2();</a>
<a name="ln455"> </a>
<a name="ln456">                  //qDebug(&quot;sline stop seg %p seg-&gt;pos2 x,y %f %f seg-&gt;userOff2 x,y %f %f spatium %f&quot;,</a>
<a name="ln457">                  //       seg, pos2.x(), pos2.y(), seg-&gt;userOff2().x(), seg-&gt;userOff2().y(), seg-&gt;spatium());</a>
<a name="ln458"> </a>
<a name="ln459">                  // For an SLine, the actual offset equals the sum of userOff and userOff2,</a>
<a name="ln460">                  // as userOff moves the SLine as a whole</a>
<a name="ln461">                  rel.setX(userOff.x() + userOff2.x());</a>
<a name="ln462"> </a>
<a name="ln463">                  // Following would probably required for non-horizontal SLines:</a>
<a name="ln464">                  //defaultY = pos.y() + pos2.y();</a>
<a name="ln465">                  }</a>
<a name="ln466">            }</a>
<a name="ln467">      else {</a>
<a name="ln468">            def = el-&gt;ipos();   // Note: for some elements, Finale Notepad seems to work slightly better w/o default-x</a>
<a name="ln469">            rel = el-&gt;offset();</a>
<a name="ln470">            }</a>
<a name="ln471"> </a>
<a name="ln472">      return positionToQString(def, rel, spatium);</a>
<a name="ln473">      }</a>
<a name="ln474"> </a>
<a name="ln475">//---------------------------------------------------------</a>
<a name="ln476">//   tag</a>
<a name="ln477">//---------------------------------------------------------</a>
<a name="ln478"> </a>
<a name="ln479">void Notations::tag(XmlWriter&amp; xml)</a>
<a name="ln480">      {</a>
<a name="ln481">      if (!notationsPrinted)</a>
<a name="ln482">            xml.stag(&quot;notations&quot;);</a>
<a name="ln483">      notationsPrinted = true;</a>
<a name="ln484">      }</a>
<a name="ln485"> </a>
<a name="ln486">//---------------------------------------------------------</a>
<a name="ln487">//   etag</a>
<a name="ln488">//---------------------------------------------------------</a>
<a name="ln489"> </a>
<a name="ln490">void Notations::etag(XmlWriter&amp; xml)</a>
<a name="ln491">      {</a>
<a name="ln492">      if (notationsPrinted)</a>
<a name="ln493">            xml.etag();</a>
<a name="ln494">      notationsPrinted = false;</a>
<a name="ln495">      }</a>
<a name="ln496"> </a>
<a name="ln497">//---------------------------------------------------------</a>
<a name="ln498">//   tag</a>
<a name="ln499">//---------------------------------------------------------</a>
<a name="ln500"> </a>
<a name="ln501">void Articulations::tag(XmlWriter&amp; xml)</a>
<a name="ln502">      {</a>
<a name="ln503">      if (!articulationsPrinted)</a>
<a name="ln504">            xml.stag(&quot;articulations&quot;);</a>
<a name="ln505">      articulationsPrinted = true;</a>
<a name="ln506">      }</a>
<a name="ln507"> </a>
<a name="ln508">//---------------------------------------------------------</a>
<a name="ln509">//   etag</a>
<a name="ln510">//---------------------------------------------------------</a>
<a name="ln511"> </a>
<a name="ln512">void Articulations::etag(XmlWriter&amp; xml)</a>
<a name="ln513">      {</a>
<a name="ln514">      if (articulationsPrinted)</a>
<a name="ln515">            xml.etag();</a>
<a name="ln516">      articulationsPrinted = false;</a>
<a name="ln517">      }</a>
<a name="ln518"> </a>
<a name="ln519">//---------------------------------------------------------</a>
<a name="ln520">//   tag</a>
<a name="ln521">//---------------------------------------------------------</a>
<a name="ln522"> </a>
<a name="ln523">void Ornaments::tag(XmlWriter&amp; xml)</a>
<a name="ln524">      {</a>
<a name="ln525">      if (!ornamentsPrinted)</a>
<a name="ln526">            xml.stag(&quot;ornaments&quot;);</a>
<a name="ln527">      ornamentsPrinted = true;</a>
<a name="ln528">      }</a>
<a name="ln529"> </a>
<a name="ln530">//---------------------------------------------------------</a>
<a name="ln531">//   etag</a>
<a name="ln532">//---------------------------------------------------------</a>
<a name="ln533"> </a>
<a name="ln534">void Ornaments::etag(XmlWriter&amp; xml)</a>
<a name="ln535">      {</a>
<a name="ln536">      if (ornamentsPrinted)</a>
<a name="ln537">            xml.etag();</a>
<a name="ln538">      ornamentsPrinted = false;</a>
<a name="ln539">      }</a>
<a name="ln540"> </a>
<a name="ln541">//---------------------------------------------------------</a>
<a name="ln542">//   tag</a>
<a name="ln543">//---------------------------------------------------------</a>
<a name="ln544"> </a>
<a name="ln545">void Technical::tag(XmlWriter&amp; xml)</a>
<a name="ln546">      {</a>
<a name="ln547">      if (!technicalPrinted)</a>
<a name="ln548">            xml.stag(&quot;technical&quot;);</a>
<a name="ln549">      technicalPrinted = true;</a>
<a name="ln550">      }</a>
<a name="ln551"> </a>
<a name="ln552">//---------------------------------------------------------</a>
<a name="ln553">//   etag</a>
<a name="ln554">//---------------------------------------------------------</a>
<a name="ln555"> </a>
<a name="ln556">void Technical::etag(XmlWriter&amp; xml)</a>
<a name="ln557">      {</a>
<a name="ln558">      if (technicalPrinted)</a>
<a name="ln559">            xml.etag();</a>
<a name="ln560">      technicalPrinted = false;</a>
<a name="ln561">      }</a>
<a name="ln562"> </a>
<a name="ln563">//---------------------------------------------------------</a>
<a name="ln564">//   color2xml</a>
<a name="ln565">//---------------------------------------------------------</a>
<a name="ln566"> </a>
<a name="ln567">/**</a>
<a name="ln568"> Return \a el color.</a>
<a name="ln569"> */</a>
<a name="ln570"> </a>
<a name="ln571">static QString color2xml(const Element* el)</a>
<a name="ln572">      {</a>
<a name="ln573">      if (el-&gt;color() != MScore::defaultColor)</a>
<a name="ln574">            return QString(&quot; color=\&quot;%1\&quot;&quot;).arg(el-&gt;color().name().toUpper());</a>
<a name="ln575">      else</a>
<a name="ln576">            return &quot;&quot;;</a>
<a name="ln577">      }</a>
<a name="ln578"> </a>
<a name="ln579">//---------------------------------------------------------</a>
<a name="ln580">//   slurHandler</a>
<a name="ln581">//---------------------------------------------------------</a>
<a name="ln582"> </a>
<a name="ln583">SlurHandler::SlurHandler()</a>
<a name="ln584">      {</a>
<a name="ln585">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i) {</a>
<a name="ln586">            slur[i] = 0;</a>
<a name="ln587">            started[i] = false;</a>
<a name="ln588">            }</a>
<a name="ln589">      }</a>
<a name="ln590"> </a>
<a name="ln591">static QString slurTieLineStyle(const SlurTie* s)</a>
<a name="ln592">      {</a>
<a name="ln593">      QString lineType;</a>
<a name="ln594">      QString rest;</a>
<a name="ln595">      switch (s-&gt;lineType()) {</a>
<a name="ln596">            case 1:</a>
<a name="ln597">                  lineType = &quot;dotted&quot;;</a>
<a name="ln598">                  break;</a>
<a name="ln599">            case 2:</a>
<a name="ln600">                  lineType = &quot;dashed&quot;;</a>
<a name="ln601">                  break;</a>
<a name="ln602">            default:</a>
<a name="ln603">                  lineType = &quot;&quot;;</a>
<a name="ln604">            }</a>
<a name="ln605">      if (!lineType.isEmpty())</a>
<a name="ln606">            rest = QString(&quot; line-type=\&quot;%1\&quot;&quot;).arg(lineType);</a>
<a name="ln607">      return rest;</a>
<a name="ln608">      }</a>
<a name="ln609"> </a>
<a name="ln610">//---------------------------------------------------------</a>
<a name="ln611">//   findSlur -- get index of slur in slur table</a>
<a name="ln612">//   return -1 if not found</a>
<a name="ln613">//---------------------------------------------------------</a>
<a name="ln614"> </a>
<a name="ln615">int SlurHandler::findSlur(const Slur* s) const</a>
<a name="ln616">      {</a>
<a name="ln617">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln618">            if (slur[i] == s) return i;</a>
<a name="ln619">      return -1;</a>
<a name="ln620">      }</a>
<a name="ln621"> </a>
<a name="ln622">//---------------------------------------------------------</a>
<a name="ln623">//   findFirstChordRest -- find first chord or rest (in musical order) for slur s</a>
<a name="ln624">//   note that this is not necessarily the same as s-&gt;startElement()</a>
<a name="ln625">//---------------------------------------------------------</a>
<a name="ln626"> </a>
<a name="ln627">static const ChordRest* findFirstChordRest(const Slur* s)</a>
<a name="ln628">      {</a>
<a name="ln629">      const Element* e1 = s-&gt;startElement();</a>
<a name="ln630">      if (!e1 || !(e1-&gt;isChordRest())) {</a>
<a name="ln631">            qDebug(&quot;no valid start element for slur %p&quot;, s);</a>
<a name="ln632">            return nullptr;</a>
<a name="ln633">            }</a>
<a name="ln634"> </a>
<a name="ln635">      const Element* e2 = s-&gt;endElement();</a>
<a name="ln636">      if (!e2 || !(e2-&gt;isChordRest())) {</a>
<a name="ln637">            qDebug(&quot;no valid end element for slur %p&quot;, s);</a>
<a name="ln638">            return nullptr;</a>
<a name="ln639">            }</a>
<a name="ln640"> </a>
<a name="ln641">      if (e1-&gt;tick() &lt; e2-&gt;tick())</a>
<a name="ln642">            return static_cast&lt;const ChordRest*&gt;(e1);</a>
<a name="ln643">      else if (e1-&gt;tick() &gt; e2-&gt;tick())</a>
<a name="ln644">            return static_cast&lt;const ChordRest*&gt;(e2);</a>
<a name="ln645"> </a>
<a name="ln646">      if (e1-&gt;isRest() || e2-&gt;isRest()) {</a>
<a name="ln647">            return nullptr;</a>
<a name="ln648">            }</a>
<a name="ln649"> </a>
<a name="ln650">      const auto c1 = static_cast&lt;const Chord*&gt;(e1);</a>
<a name="ln651">      const auto c2 = static_cast&lt;const Chord*&gt;(e2);</a>
<a name="ln652"> </a>
<a name="ln653">      // c1-&gt;tick() == c2-&gt;tick()</a>
<a name="ln654">      if (!c1-&gt;isGrace() &amp;&amp; !c2-&gt;isGrace()) {</a>
<a name="ln655">            // slur between two regular notes at the same tick</a>
<a name="ln656">            // probably shouldn't happen but handle just in case</a>
<a name="ln657">            qDebug(&quot;invalid slur between chords %p and %p at tick %d&quot;, c1, c2, c1-&gt;tick().ticks());</a>
<a name="ln658">            return 0;</a>
<a name="ln659">            }</a>
<a name="ln660">      else if (c1-&gt;isGraceBefore() &amp;&amp; !c2-&gt;isGraceBefore())</a>
<a name="ln661">            return c1;        // easy case: c1 first</a>
<a name="ln662">      else if (c1-&gt;isGraceAfter() &amp;&amp; !c2-&gt;isGraceAfter())</a>
<a name="ln663">            return c2;        // easy case: c2 first</a>
<a name="ln664">      else if (c2-&gt;isGraceBefore() &amp;&amp; !c1-&gt;isGraceBefore())</a>
<a name="ln665">            return c2;        // easy case: c2 first</a>
<a name="ln666">      else if (c2-&gt;isGraceAfter() &amp;&amp; !c1-&gt;isGraceAfter())</a>
<a name="ln667">            return c1;        // easy case: c1 first</a>
<a name="ln668">      else {</a>
<a name="ln669">            // both are grace before or both are grace after -&gt; compare grace indexes</a>
<a name="ln670">            // (note: higher means closer to the non-grace chord it is attached to)</a>
<a name="ln671">            if ((c1-&gt;isGraceBefore() &amp;&amp; c1-&gt;graceIndex() &lt; c2-&gt;graceIndex())</a>
<a name="ln672">                || (c1-&gt;isGraceAfter() &amp;&amp; c1-&gt;graceIndex() &gt; c2-&gt;graceIndex()))</a>
<a name="ln673">                  return c1;</a>
<a name="ln674">            else</a>
<a name="ln675">                  return c2;</a>
<a name="ln676">            }</a>
<a name="ln677">      }</a>
<a name="ln678"> </a>
<a name="ln679">//---------------------------------------------------------</a>
<a name="ln680">//   doSlurs</a>
<a name="ln681">//---------------------------------------------------------</a>
<a name="ln682"> </a>
<a name="ln683">void SlurHandler::doSlurs(const ChordRest* chordRest, Notations&amp; notations, XmlWriter&amp; xml)</a>
<a name="ln684">      {</a>
<a name="ln685">      // loop over all slurs twice, first to handle the stops, then the starts</a>
<a name="ln686">      for (int i = 0; i &lt; 2; ++i) {</a>
<a name="ln687">            // search for slur(s) starting or stopping at this chord</a>
<a name="ln688">            for (const auto it : chordRest-&gt;score()-&gt;spanner()) {</a>
<a name="ln689">                  auto sp = it.second;</a>
<a name="ln690">                  if (sp-&gt;generated() || sp-&gt;type() != ElementType::SLUR)</a>
<a name="ln691">                        continue;</a>
<a name="ln692">                  if (chordRest == sp-&gt;startElement() || chordRest == sp-&gt;endElement()) {</a>
<a name="ln693">                        const auto s = static_cast&lt;const Slur*&gt;(sp);</a>
<a name="ln694">                        const auto firstChordRest = findFirstChordRest(s);</a>
<a name="ln695">                        if (firstChordRest) {</a>
<a name="ln696">                              if (i == 0) {</a>
<a name="ln697">                                    // first time: do slur stops</a>
<a name="ln698">                                    if (firstChordRest != chordRest)</a>
<a name="ln699">                                          doSlurStop(s, notations, xml);</a>
<a name="ln700">                                    }</a>
<a name="ln701">                              else {</a>
<a name="ln702">                                    // second time: do slur starts</a>
<a name="ln703">                                    if (firstChordRest == chordRest)</a>
<a name="ln704">                                          doSlurStart(s, notations, xml);</a>
<a name="ln705">                                    }</a>
<a name="ln706">                              }</a>
<a name="ln707">                        }</a>
<a name="ln708">                  }</a>
<a name="ln709">            }</a>
<a name="ln710">      }</a>
<a name="ln711"> </a>
<a name="ln712">//---------------------------------------------------------</a>
<a name="ln713">//   doSlurStart</a>
<a name="ln714">//---------------------------------------------------------</a>
<a name="ln715"> </a>
<a name="ln716">void SlurHandler::doSlurStart(const Slur* s, Notations&amp; notations, XmlWriter&amp; xml)</a>
<a name="ln717">      {</a>
<a name="ln718">      // check if on slur list (i.e. stop already seen)</a>
<a name="ln719">      int i = findSlur(s);</a>
<a name="ln720">      // compose tag</a>
<a name="ln721">      QString tagName = &quot;slur&quot;;</a>
<a name="ln722">      tagName += slurTieLineStyle(s); // define line type</a>
<a name="ln723">      tagName += color2xml(s);</a>
<a name="ln724">      tagName += QString(&quot; type=\&quot;start\&quot; placement=\&quot;%1\&quot;&quot;)</a>
<a name="ln725">            .arg(s-&gt;up() ? &quot;above&quot; : &quot;below&quot;);</a>
<a name="ln726">      tagName += positioningAttributes(s, true);</a>
<a name="ln727"> </a>
<a name="ln728">      if (i &gt;= 0) {</a>
<a name="ln729">            // remove from list and print start</a>
<a name="ln730">            slur[i] = 0;</a>
<a name="ln731">            started[i] = false;</a>
<a name="ln732">            notations.tag(xml);</a>
<a name="ln733">            tagName += QString(&quot; number=\&quot;%1\&quot;&quot;).arg(i + 1);</a>
<a name="ln734">            xml.tagE(tagName);</a>
<a name="ln735">            }</a>
<a name="ln736">      else {</a>
<a name="ln737">            // find free slot to store it</a>
<a name="ln738">            i = findSlur(0);</a>
<a name="ln739">            if (i &gt;= 0) {</a>
<a name="ln740">                  slur[i] = s;</a>
<a name="ln741">                  started[i] = true;</a>
<a name="ln742">                  notations.tag(xml);</a>
<a name="ln743">                  tagName += QString(&quot; number=\&quot;%1\&quot;&quot;).arg(i + 1);</a>
<a name="ln744">                  xml.tagE(tagName);</a>
<a name="ln745">                  }</a>
<a name="ln746">            else</a>
<a name="ln747">                  qDebug(&quot;no free slur slot&quot;);</a>
<a name="ln748">            }</a>
<a name="ln749">      }</a>
<a name="ln750"> </a>
<a name="ln751">//---------------------------------------------------------</a>
<a name="ln752">//   doSlurStop</a>
<a name="ln753">//---------------------------------------------------------</a>
<a name="ln754"> </a>
<a name="ln755">// Note: a slur may start in a higher voice in the same measure.</a>
<a name="ln756">// In that case it is not yet started (i.e. on the active slur list)</a>
<a name="ln757">// when doSlurStop() is executed. Handle this slur as follows:</a>
<a name="ln758">// - generate stop anyway and put it on the slur list</a>
<a name="ln759">// - doSlurStart() starts slur but doesn't store it</a>
<a name="ln760"> </a>
<a name="ln761">void SlurHandler::doSlurStop(const Slur* s, Notations&amp; notations, XmlWriter&amp; xml)</a>
<a name="ln762">      {</a>
<a name="ln763">      // check if on slur list</a>
<a name="ln764">      int i = findSlur(s);</a>
<a name="ln765">      if (i &lt; 0) {</a>
<a name="ln766">            // if not, find free slot to store it</a>
<a name="ln767">            i = findSlur(0);</a>
<a name="ln768">            if (i &gt;= 0) {</a>
<a name="ln769">                  slur[i] = s;</a>
<a name="ln770">                  started[i] = false;</a>
<a name="ln771">                  notations.tag(xml);</a>
<a name="ln772">                  QString tagName = QString(&quot;slur type=\&quot;stop\&quot; number=\&quot;%1\&quot;&quot;).arg(i + 1);</a>
<a name="ln773">                  tagName += positioningAttributes(s, false);</a>
<a name="ln774">                  xml.tagE(tagName);</a>
<a name="ln775">                  }</a>
<a name="ln776">            else</a>
<a name="ln777">                  qDebug(&quot;no free slur slot&quot;);</a>
<a name="ln778">            }</a>
<a name="ln779">      else {</a>
<a name="ln780">            // found (already started), stop it and remove from list</a>
<a name="ln781">            slur[i] = 0;</a>
<a name="ln782">            started[i] = false;</a>
<a name="ln783">            notations.tag(xml);</a>
<a name="ln784">            QString tagName = QString(&quot;slur type=\&quot;stop\&quot; number=\&quot;%1\&quot;&quot;).arg(i + 1);</a>
<a name="ln785">            tagName += positioningAttributes(s, false);</a>
<a name="ln786">            xml.tagE(tagName);</a>
<a name="ln787">            }</a>
<a name="ln788">      }</a>
<a name="ln789"> </a>
<a name="ln790">//---------------------------------------------------------</a>
<a name="ln791">//   glissando</a>
<a name="ln792">//---------------------------------------------------------</a>
<a name="ln793"> </a>
<a name="ln794">// &lt;notations&gt;</a>
<a name="ln795">//   &lt;slide line-type=&quot;solid&quot; number=&quot;1&quot; type=&quot;start&quot;/&gt;</a>
<a name="ln796">//   &lt;/notations&gt;</a>
<a name="ln797"> </a>
<a name="ln798">// &lt;notations&gt;</a>
<a name="ln799">//   &lt;glissando line-type=&quot;wavy&quot; number=&quot;1&quot; type=&quot;start&quot;/&gt;</a>
<a name="ln800">//   &lt;/notations&gt;</a>
<a name="ln801"> </a>
<a name="ln802">static void glissando(const Glissando* gli, int number, bool start, Notations&amp; notations, XmlWriter&amp; xml)</a>
<a name="ln803">      {</a>
<a name="ln804">      GlissandoType st = gli-&gt;glissandoType();</a>
<a name="ln805">      QString tagName;</a>
<a name="ln806">      switch (st) {</a>
<a name="ln807">            case GlissandoType::STRAIGHT:</a>
<a name="ln808">                  tagName = &quot;slide line-type=\&quot;solid\&quot;&quot;;</a>
<a name="ln809">                  break;</a>
<a name="ln810">            case GlissandoType::WAVY:</a>
<a name="ln811">                  tagName = &quot;glissando line-type=\&quot;wavy\&quot;&quot;;</a>
<a name="ln812">                  break;</a>
<a name="ln813">            default:</a>
<a name="ln814">                  qDebug(&quot;unknown glissando subtype %d&quot;, int(st));</a>
<a name="ln815">                  return;</a>
<a name="ln816">                  break;</a>
<a name="ln817">            }</a>
<a name="ln818">      tagName += QString(&quot; number=\&quot;%1\&quot; type=\&quot;%2\&quot;&quot;).arg(number).arg(start ? &quot;start&quot; : &quot;stop&quot;);</a>
<a name="ln819">      tagName += color2xml(gli);</a>
<a name="ln820">      tagName += positioningAttributes(gli, start);</a>
<a name="ln821">      notations.tag(xml);</a>
<a name="ln822">      if (start &amp;&amp; gli-&gt;showText() &amp;&amp; gli-&gt;text() != &quot;&quot;)</a>
<a name="ln823">            xml.tag(tagName, gli-&gt;text());</a>
<a name="ln824">      else</a>
<a name="ln825">            xml.tagE(tagName);</a>
<a name="ln826">      }</a>
<a name="ln827"> </a>
<a name="ln828">//---------------------------------------------------------</a>
<a name="ln829">//   GlissandoHandler</a>
<a name="ln830">//---------------------------------------------------------</a>
<a name="ln831"> </a>
<a name="ln832">GlissandoHandler::GlissandoHandler()</a>
<a name="ln833">      {</a>
<a name="ln834">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i) {</a>
<a name="ln835">            glissNote[i] = 0;</a>
<a name="ln836">            slideNote[i] = 0;</a>
<a name="ln837">            }</a>
<a name="ln838">      }</a>
<a name="ln839"> </a>
<a name="ln840">//---------------------------------------------------------</a>
<a name="ln841">//   findNote -- get index of Note in note table for subtype type</a>
<a name="ln842">//   return -1 if not found</a>
<a name="ln843">//---------------------------------------------------------</a>
<a name="ln844"> </a>
<a name="ln845">int GlissandoHandler::findNote(const Note* note, int type) const</a>
<a name="ln846">      {</a>
<a name="ln847">      if (type != 0 &amp;&amp; type != 1) {</a>
<a name="ln848">            qDebug(&quot;GlissandoHandler::findNote: unknown glissando subtype %d&quot;, type);</a>
<a name="ln849">            return -1;</a>
<a name="ln850">            }</a>
<a name="ln851">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i) {</a>
<a name="ln852">            if (type == 0 &amp;&amp; slideNote[i] == note) return i;</a>
<a name="ln853">            if (type == 1 &amp;&amp; glissNote[i] == note) return i;</a>
<a name="ln854">            }</a>
<a name="ln855">      return -1;</a>
<a name="ln856">      }</a>
<a name="ln857"> </a>
<a name="ln858">//---------------------------------------------------------</a>
<a name="ln859">//   doGlissandoStart</a>
<a name="ln860">//---------------------------------------------------------</a>
<a name="ln861"> </a>
<a name="ln862">void GlissandoHandler::doGlissandoStart(Glissando* gliss, Notations&amp; notations, XmlWriter&amp; xml)</a>
<a name="ln863">      {</a>
<a name="ln864">      GlissandoType type = gliss-&gt;glissandoType();</a>
<a name="ln865">      if (type != GlissandoType::STRAIGHT &amp;&amp; type != GlissandoType::WAVY) {</a>
<a name="ln866">            qDebug(&quot;doGlissandoStart: unknown glissando subtype %d&quot;, int(type));</a>
<a name="ln867">            return;</a>
<a name="ln868">            }</a>
<a name="ln869">      Note* note = static_cast&lt;Note*&gt;(gliss-&gt;startElement());</a>
<a name="ln870">      // check if on chord list</a>
<a name="ln871">      int i = findNote(note, int(type));</a>
<a name="ln872">      if (i &gt;= 0) {</a>
<a name="ln873">            // print error and remove from list</a>
<a name="ln874">            qDebug(&quot;doGlissandoStart: note for glissando/slide %p already on list&quot;, gliss);</a>
<a name="ln875">            if (type == GlissandoType::STRAIGHT) slideNote[i] = 0;</a>
<a name="ln876">            if (type == GlissandoType::WAVY) glissNote[i] = 0;</a>
<a name="ln877">            }</a>
<a name="ln878">      // find free slot to store it</a>
<a name="ln879">      i = findNote(0, int(type));</a>
<a name="ln880">      if (i &gt;= 0) {</a>
<a name="ln881">            if (type == GlissandoType::STRAIGHT) slideNote[i] = note;</a>
<a name="ln882">            if (type == GlissandoType::WAVY) glissNote[i] = note;</a>
<a name="ln883">            glissando(gliss, i + 1, true, notations, xml);</a>
<a name="ln884">            }</a>
<a name="ln885">      else</a>
<a name="ln886">            qDebug(&quot;doGlissandoStart: no free slot&quot;);</a>
<a name="ln887">      }</a>
<a name="ln888"> </a>
<a name="ln889">//---------------------------------------------------------</a>
<a name="ln890">//   doGlissandoStop</a>
<a name="ln891">//---------------------------------------------------------</a>
<a name="ln892"> </a>
<a name="ln893">void GlissandoHandler::doGlissandoStop(Glissando* gliss, Notations&amp; notations, XmlWriter&amp; xml)</a>
<a name="ln894">      {</a>
<a name="ln895">      GlissandoType type = gliss-&gt;glissandoType();</a>
<a name="ln896">      if (type != GlissandoType::STRAIGHT &amp;&amp; type != GlissandoType::WAVY) {</a>
<a name="ln897">            qDebug(&quot;doGlissandoStart: unknown glissando subtype %d&quot;, int(type));</a>
<a name="ln898">            return;</a>
<a name="ln899">            }</a>
<a name="ln900">      Note* note = static_cast&lt;Note*&gt;(gliss-&gt;startElement());</a>
<a name="ln901">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i) {</a>
<a name="ln902">            if (type == GlissandoType::STRAIGHT &amp;&amp; slideNote[i] == note) {</a>
<a name="ln903">                  slideNote[i] = 0;</a>
<a name="ln904">                  glissando(gliss, i + 1, false, notations, xml);</a>
<a name="ln905">                  return;</a>
<a name="ln906">                  }</a>
<a name="ln907">            if (type == GlissandoType::WAVY &amp;&amp; glissNote[i] == note) {</a>
<a name="ln908">                  glissNote[i] = 0;</a>
<a name="ln909">                  glissando(gliss, i + 1, false, notations, xml);</a>
<a name="ln910">                  return;</a>
<a name="ln911">                  }</a>
<a name="ln912">            }</a>
<a name="ln913">      qDebug(&quot;doGlissandoStop: glissando note %p not found&quot;, note);</a>
<a name="ln914">      }</a>
<a name="ln915"> </a>
<a name="ln916">//---------------------------------------------------------</a>
<a name="ln917">//   directions anchor -- anchor directions at another element or a specific tick</a>
<a name="ln918">//---------------------------------------------------------</a>
<a name="ln919"> </a>
<a name="ln920">class DirectionsAnchor {</a>
<a name="ln921">      Element* direct;        // the element containing the direction</a>
<a name="ln922">      Element* anchor;        // the element it is attached to</a>
<a name="ln923">      bool start;             // whether it is attached to start or end</a>
<a name="ln924">      Fraction tick;          // the timestamp</a>
<a name="ln925"> </a>
<a name="ln926">public:</a>
<a name="ln927">      DirectionsAnchor(Element* a, bool s, const Fraction&amp; t) { direct = 0; anchor = a; start = s; tick = t; }</a>
<a name="ln928">      DirectionsAnchor(const Fraction&amp; t) { direct = 0; anchor = 0; start = true; tick = t; }</a>
<a name="ln929">      Element* getDirect() { return direct; }</a>
<a name="ln930">      Element* getAnchor() { return anchor; }</a>
<a name="ln931">      bool getStart() { return start; }</a>
<a name="ln932">      Fraction getTick() { return tick; }</a>
<a name="ln933">      void setDirect(Element* d) { direct = d; }</a>
<a name="ln934">      };</a>
<a name="ln935"> </a>
<a name="ln936">//---------------------------------------------------------</a>
<a name="ln937">// trill handling</a>
<a name="ln938">//---------------------------------------------------------</a>
<a name="ln939"> </a>
<a name="ln940">// find all trills in this measure and this part</a>
<a name="ln941"> </a>
<a name="ln942">static void findTrills(const Measure* const measure, int strack, int etrack, TrillHash&amp; trillStart, TrillHash&amp; trillStop)</a>
<a name="ln943">      {</a>
<a name="ln944">      // loop over all spanners in this measure</a>
<a name="ln945">      auto stick = measure-&gt;tick();</a>
<a name="ln946">      auto etick = measure-&gt;tick() + measure-&gt;ticks();</a>
<a name="ln947">      for (auto it = measure-&gt;score()-&gt;spanner().lower_bound(stick.ticks()); it != measure-&gt;score()-&gt;spanner().upper_bound(etick.ticks()); ++it) {</a>
<a name="ln948">            auto e = it-&gt;second;</a>
<a name="ln949">            //qDebug(&quot;1 trill %p type %d track %d tick %s&quot;, e, e-&gt;type(), e-&gt;track(), qPrintable(e-&gt;tick().print()));</a>
<a name="ln950">            if (e-&gt;isTrill() &amp;&amp; strack &lt;= e-&gt;track() &amp;&amp; e-&gt;track() &lt; etrack</a>
<a name="ln951">                &amp;&amp; e-&gt;tick() &gt;= measure-&gt;tick() &amp;&amp; e-&gt;tick() &lt; (measure-&gt;tick() + measure-&gt;ticks()))</a>
<a name="ln952">                  {</a>
<a name="ln953">                  //qDebug(&quot;2 trill %p&quot;, e);</a>
<a name="ln954">                  // a trill is found starting in this segment, trill end time is known</a>
<a name="ln955">                  // determine notes to write trill start and stop</a>
<a name="ln956"> </a>
<a name="ln957">                  const auto tr = toTrill(e);</a>
<a name="ln958">                  auto elem1 = tr-&gt;startElement();</a>
<a name="ln959">                  auto elem2 = tr-&gt;endElement();</a>
<a name="ln960"> </a>
<a name="ln961">                  if (elem1 &amp;&amp; elem1-&gt;isChordRest() &amp;&amp; elem2 &amp;&amp; elem2-&gt;isChordRest()) {</a>
<a name="ln962">                        trillStart.insert(toChordRest(elem1), tr);</a>
<a name="ln963">                        trillStop.insert(toChordRest(elem2), tr);</a>
<a name="ln964">                        }</a>
<a name="ln965">                  }</a>
<a name="ln966">            }</a>
<a name="ln967">      }</a>
<a name="ln968"> </a>
<a name="ln969">//---------------------------------------------------------</a>
<a name="ln970">// helpers for ::calcDivisions</a>
<a name="ln971">//---------------------------------------------------------</a>
<a name="ln972"> </a>
<a name="ln973">typedef QList&lt;int&gt; IntVector;</a>
<a name="ln974">static IntVector integers;</a>
<a name="ln975">static IntVector primes;</a>
<a name="ln976"> </a>
<a name="ln977">// check if all integers can be divided by d</a>
<a name="ln978"> </a>
<a name="ln979">static bool canDivideBy(int d)</a>
<a name="ln980">      {</a>
<a name="ln981">      bool res = true;</a>
<a name="ln982">      for (int i = 0; i &lt; integers.count(); i++) {</a>
<a name="ln983">            if ((integers[i] &lt;= 1) || ((integers[i] % d) != 0)) {</a>
<a name="ln984">                  res = false;</a>
<a name="ln985">                  }</a>
<a name="ln986">            }</a>
<a name="ln987">      return res;</a>
<a name="ln988">      }</a>
<a name="ln989"> </a>
<a name="ln990">// divide all integers by d</a>
<a name="ln991"> </a>
<a name="ln992">static void divideBy(int d)</a>
<a name="ln993">      {</a>
<a name="ln994">      for (int i = 0; i &lt; integers.count(); i++) {</a>
<a name="ln995">            integers[i] /= d;</a>
<a name="ln996">            }</a>
<a name="ln997">      }</a>
<a name="ln998"> </a>
<a name="ln999">static void addInteger(int len)</a>
<a name="ln1000">      {</a>
<a name="ln1001">      if (!integers.contains(len)) {</a>
<a name="ln1002">            integers.append(len);</a>
<a name="ln1003">            }</a>
<a name="ln1004">      }</a>
<a name="ln1005"> </a>
<a name="ln1006">//---------------------------------------------------------</a>
<a name="ln1007">//   calcDivMoveToTick</a>
<a name="ln1008">//---------------------------------------------------------</a>
<a name="ln1009"> </a>
<a name="ln1010">void ExportMusicXml::calcDivMoveToTick(const Fraction&amp; t)</a>
<a name="ln1011">      {</a>
<a name="ln1012">      if (t &lt; _tick) {</a>
<a name="ln1013">#ifdef DEBUG_TICK</a>
<a name="ln1014">            qDebug(&quot;backup %d&quot;, (tick - t).ticks());</a>
<a name="ln1015">#endif</a>
<a name="ln1016">            addInteger((_tick - t).ticks());</a>
<a name="ln1017">            }</a>
<a name="ln1018">      else if (t &gt; _tick) {</a>
<a name="ln1019">#ifdef DEBUG_TICK</a>
<a name="ln1020">            qDebug(&quot;forward %d&quot;, (t - tick).ticks());;</a>
<a name="ln1021">#endif</a>
<a name="ln1022">            addInteger((t - _tick).ticks());</a>
<a name="ln1023">            }</a>
<a name="ln1024">      _tick = t;</a>
<a name="ln1025">      }</a>
<a name="ln1026"> </a>
<a name="ln1027">//---------------------------------------------------------</a>
<a name="ln1028">// isTwoNoteTremolo - determine is chord is part of two note tremolo</a>
<a name="ln1029">//---------------------------------------------------------</a>
<a name="ln1030"> </a>
<a name="ln1031">static bool isTwoNoteTremolo(Chord* chord)</a>
<a name="ln1032">      {</a>
<a name="ln1033">      return (chord-&gt;tremolo() &amp;&amp; chord-&gt;tremolo()-&gt;twoNotes());</a>
<a name="ln1034">      }</a>
<a name="ln1035"> </a>
<a name="ln1036">//---------------------------------------------------------</a>
<a name="ln1037">//  calcDivisions</a>
<a name="ln1038">//---------------------------------------------------------</a>
<a name="ln1039"> </a>
<a name="ln1040">// Loop over all voices in all staffs and determine a suitable value for divisions.</a>
<a name="ln1041"> </a>
<a name="ln1042">// Length of time in MusicXML is expressed in &quot;units&quot;, which should allow expressing all time values</a>
<a name="ln1043">// as an integral number of units. Divisions contains the number of units in a quarter note.</a>
<a name="ln1044">// MuseScore uses division (480) midi ticks to represent a quarter note, which expresses all note values</a>
<a name="ln1045">// plus triplets and quintuplets as integer values. Solution is to collect all time values required,</a>
<a name="ln1046">// and divide them by the highest common denominator, which is implemented as a series of</a>
<a name="ln1047">// divisions by prime factors. Initialize the list with division to make sure a quarter note can always</a>
<a name="ln1048">// be written as an integral number of units.</a>
<a name="ln1049"> </a>
<a name="ln1050">/**</a>
<a name="ln1051"> */</a>
<a name="ln1052"> </a>
<a name="ln1053">void ExportMusicXml::calcDivisions()</a>
<a name="ln1054">      {</a>
<a name="ln1055">      // init</a>
<a name="ln1056">      integers.clear();</a>
<a name="ln1057">      primes.clear();</a>
<a name="ln1058">      integers.append(MScore::division);</a>
<a name="ln1059">      primes.append(2);</a>
<a name="ln1060">      primes.append(3);</a>
<a name="ln1061">      primes.append(5);</a>
<a name="ln1062"> </a>
<a name="ln1063">      const QList&lt;Part*&gt;&amp; il = _score-&gt;parts();</a>
<a name="ln1064"> </a>
<a name="ln1065">      for (int idx = 0; idx &lt; il.size(); ++idx) {</a>
<a name="ln1066"> </a>
<a name="ln1067">            Part* part = il.at(idx);</a>
<a name="ln1068">            _tick = { 0,1 };</a>
<a name="ln1069"> </a>
<a name="ln1070">            int staves = part-&gt;nstaves();</a>
<a name="ln1071">            int strack = _score-&gt;staffIdx(part) * VOICES;</a>
<a name="ln1072">            int etrack = strack + staves * VOICES;</a>
<a name="ln1073"> </a>
<a name="ln1074">            for (MeasureBase* mb = _score-&gt;measures()-&gt;first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln1075"> </a>
<a name="ln1076">                  if (mb-&gt;type() != ElementType::MEASURE)</a>
<a name="ln1077">                        continue;</a>
<a name="ln1078">                  Measure* m = (Measure*)mb;</a>
<a name="ln1079"> </a>
<a name="ln1080">                  for (int st = strack; st &lt; etrack; ++st) {</a>
<a name="ln1081">                        // sstaff - xml staff number, counting from 1 for this</a>
<a name="ln1082">                        // instrument</a>
<a name="ln1083">                        // special number 0 -&gt; dont show staff number in</a>
<a name="ln1084">                        // xml output (because there is only one staff)</a>
<a name="ln1085"> </a>
<a name="ln1086">                        int sstaff = (staves &gt; 1) ? st - strack + VOICES : 0;</a>
<a name="ln1087">                        sstaff /= VOICES;</a>
<a name="ln1088"> </a>
<a name="ln1089">                        for (Segment* seg = m-&gt;first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln1090"> </a>
<a name="ln1091">                              Element* el = seg-&gt;element(st);</a>
<a name="ln1092">                              if (!el)</a>
<a name="ln1093">                                    continue;</a>
<a name="ln1094"> </a>
<a name="ln1095">                              // must ignore start repeat to prevent spurious backup/forward</a>
<a name="ln1096">                              if (el-&gt;type() == ElementType::BAR_LINE &amp;&amp; static_cast&lt;BarLine*&gt;(el)-&gt;barLineType() == BarLineType::START_REPEAT)</a>
<a name="ln1097">                                    continue;</a>
<a name="ln1098"> </a>
<a name="ln1099">                              if (_tick != seg-&gt;tick())</a>
<a name="ln1100">                                    calcDivMoveToTick(seg-&gt;tick());</a>
<a name="ln1101"> </a>
<a name="ln1102">                              if (el-&gt;isChordRest()) {</a>
<a name="ln1103">                                    Fraction l = toChordRest(el)-&gt;actualTicks();</a>
<a name="ln1104">                                    if (el-&gt;isChord()) {</a>
<a name="ln1105">                                          if (isTwoNoteTremolo(toChord(el)))</a>
<a name="ln1106">                                                l = l * Fraction(1,2);</a>
<a name="ln1107">                                          }</a>
<a name="ln1108">#ifdef DEBUG_TICK</a>
<a name="ln1109">                                    qDebug(&quot;chordrest %d&quot;, l);</a>
<a name="ln1110">#endif</a>
<a name="ln1111">                                    addInteger(l.ticks());</a>
<a name="ln1112">                                    _tick += l;</a>
<a name="ln1113">                                    }</a>
<a name="ln1114">                              }</a>
<a name="ln1115">                        }</a>
<a name="ln1116">                  // move to end of measure (in case of incomplete last voice)</a>
<a name="ln1117">                  calcDivMoveToTick(m-&gt;endTick());</a>
<a name="ln1118">                  }</a>
<a name="ln1119">            }</a>
<a name="ln1120"> </a>
<a name="ln1121">      // do it: divide by all primes as often as possible</a>
<a name="ln1122">      for (int u = 0; u &lt; primes.count(); u++)</a>
<a name="ln1123">            while (canDivideBy(primes[u]))</a>
<a name="ln1124">                  divideBy(primes[u]);</a>
<a name="ln1125"> </a>
<a name="ln1126">      div = MScore::division / integers[0];</a>
<a name="ln1127">#ifdef DEBUG_TICK</a>
<a name="ln1128">      qDebug(&quot;divisions=%d div=%d&quot;, integers[0], div);</a>
<a name="ln1129">#endif</a>
<a name="ln1130">      }</a>
<a name="ln1131"> </a>
<a name="ln1132">//---------------------------------------------------------</a>
<a name="ln1133">//   writePageFormat</a>
<a name="ln1134">//---------------------------------------------------------</a>
<a name="ln1135"> </a>
<a name="ln1136">static void writePageFormat(const Score* const s, XmlWriter&amp; xml, double conversion)</a>
<a name="ln1137">      {</a>
<a name="ln1138">      xml.stag(&quot;page-layout&quot;);</a>
<a name="ln1139"> </a>
<a name="ln1140">      xml.tag(&quot;page-height&quot;, s-&gt;styleD(Sid::pageHeight) * conversion);</a>
<a name="ln1141">      xml.tag(&quot;page-width&quot;, s-&gt;styleD(Sid::pageWidth) * conversion);</a>
<a name="ln1142"> </a>
<a name="ln1143">      QString type(&quot;both&quot;);</a>
<a name="ln1144">      if (s-&gt;styleB(Sid::pageTwosided)) {</a>
<a name="ln1145">            type = &quot;even&quot;;</a>
<a name="ln1146">            xml.stag(QString(&quot;page-margins type=\&quot;%1\&quot;&quot;).arg(type));</a>
<a name="ln1147">            xml.tag(&quot;left-margin&quot;,   s-&gt;styleD(Sid::pageEvenLeftMargin) * conversion);</a>
<a name="ln1148">            xml.tag(&quot;right-margin&quot;,  s-&gt;styleD(Sid::pageOddLeftMargin) * conversion);</a>
<a name="ln1149">            xml.tag(&quot;top-margin&quot;,    s-&gt;styleD(Sid::pageEvenTopMargin)  * conversion);</a>
<a name="ln1150">            xml.tag(&quot;bottom-margin&quot;, s-&gt;styleD(Sid::pageEvenBottomMargin) * conversion);</a>
<a name="ln1151">            xml.etag();</a>
<a name="ln1152">            type = &quot;odd&quot;;</a>
<a name="ln1153">            }</a>
<a name="ln1154">      xml.stag(QString(&quot;page-margins type=\&quot;%1\&quot;&quot;).arg(type));</a>
<a name="ln1155">      xml.tag(&quot;left-margin&quot;,   s-&gt;styleD(Sid::pageOddLeftMargin) * conversion);</a>
<a name="ln1156">      xml.tag(&quot;right-margin&quot;,  s-&gt;styleD(Sid::pageEvenLeftMargin) * conversion);</a>
<a name="ln1157">      xml.tag(&quot;top-margin&quot;,    s-&gt;styleD(Sid::pageOddTopMargin) * conversion);</a>
<a name="ln1158">      xml.tag(&quot;bottom-margin&quot;, s-&gt;styleD(Sid::pageOddBottomMargin) * conversion);</a>
<a name="ln1159">      xml.etag();</a>
<a name="ln1160"> </a>
<a name="ln1161">      xml.etag();</a>
<a name="ln1162">      }</a>
<a name="ln1163"> </a>
<a name="ln1164">//---------------------------------------------------------</a>
<a name="ln1165">//   defaults</a>
<a name="ln1166">//---------------------------------------------------------</a>
<a name="ln1167"> </a>
<a name="ln1168">// _spatium = DPMM * (millimeter * 10.0 / tenths);</a>
<a name="ln1169"> </a>
<a name="ln1170">static void defaults(XmlWriter&amp; xml, const Score* const s, double&amp; millimeters, const int&amp; tenths)</a>
<a name="ln1171">      {</a>
<a name="ln1172">      xml.stag(&quot;defaults&quot;);</a>
<a name="ln1173">      xml.stag(&quot;scaling&quot;);</a>
<a name="ln1174">      xml.tag(&quot;millimeters&quot;, millimeters);</a>
<a name="ln1175">      xml.tag(&quot;tenths&quot;, tenths);</a>
<a name="ln1176">      xml.etag();</a>
<a name="ln1177"> </a>
<a name="ln1178">      writePageFormat(s, xml, INCH / millimeters * tenths);</a>
<a name="ln1179"> </a>
<a name="ln1180">      // TODO: also write default system layout here</a>
<a name="ln1181">      // when exporting only manual or no breaks, system-distance is not written at all</a>
<a name="ln1182"> </a>
<a name="ln1183">      // font defaults</a>
<a name="ln1184">      // as MuseScore supports dozens of different styles, while MusicXML only has defaults</a>
<a name="ln1185">      // for music (TODO), words and lyrics, use Tid STAFF (typically used for words)</a>
<a name="ln1186">      // and LYRIC1 to get MusicXML defaults</a>
<a name="ln1187"> </a>
<a name="ln1188">      // TODO xml.tagE(&quot;music-font font-family=\&quot;TBD\&quot; font-size=\&quot;TBD\&quot;&quot;);</a>
<a name="ln1189">      xml.tagE(QString(&quot;word-font font-family=\&quot;%1\&quot; font-size=\&quot;%2\&quot;&quot;).arg(s-&gt;styleSt(Sid::staffTextFontFace)).arg(s-&gt;styleD(Sid::staffTextFontSize)));</a>
<a name="ln1190">      xml.tagE(QString(&quot;lyric-font font-family=\&quot;%1\&quot; font-size=\&quot;%2\&quot;&quot;).arg(s-&gt;styleSt(Sid::lyricsOddFontFace)).arg(s-&gt;styleD(Sid::lyricsOddFontSize)));</a>
<a name="ln1191">      xml.etag();</a>
<a name="ln1192">      }</a>
<a name="ln1193"> </a>
<a name="ln1194">//---------------------------------------------------------</a>
<a name="ln1195">//   formatForWords</a>
<a name="ln1196">//---------------------------------------------------------</a>
<a name="ln1197"> </a>
<a name="ln1198">static CharFormat formatForWords(const Score* const s)</a>
<a name="ln1199">      {</a>
<a name="ln1200">      CharFormat defFmt;</a>
<a name="ln1201">      defFmt.setFontFamily(s-&gt;styleSt(Sid::staffTextFontFace));</a>
<a name="ln1202">      defFmt.setFontSize(s-&gt;styleD(Sid::staffTextFontSize));</a>
<a name="ln1203">      return defFmt;</a>
<a name="ln1204">      }</a>
<a name="ln1205"> </a>
<a name="ln1206">//---------------------------------------------------------</a>
<a name="ln1207">//   creditWords</a>
<a name="ln1208">//---------------------------------------------------------</a>
<a name="ln1209"> </a>
<a name="ln1210">static void creditWords(XmlWriter&amp; xml, const Score* const s, const int pageNr,</a>
<a name="ln1211">                        const double x, const double y, const QString&amp; just, const QString&amp; val,</a>
<a name="ln1212">                        const QList&lt;TextFragment&gt;&amp; words)</a>
<a name="ln1213">      {</a>
<a name="ln1214">      // prevent incorrect MusicXML for empty text</a>
<a name="ln1215">      if (words.isEmpty())</a>
<a name="ln1216">            return;</a>
<a name="ln1217"> </a>
<a name="ln1218">      const QString mtf = s-&gt;styleSt(Sid::MusicalTextFont);</a>
<a name="ln1219">      const CharFormat defFmt = formatForWords(s);</a>
<a name="ln1220"> </a>
<a name="ln1221">      // export formatted</a>
<a name="ln1222">      xml.stag(QString(&quot;credit page=\&quot;%1\&quot;&quot;).arg(pageNr));</a>
<a name="ln1223">      QString attr = QString(&quot; default-x=\&quot;%1\&quot;&quot;).arg(x);</a>
<a name="ln1224">      attr += QString(&quot; default-y=\&quot;%1\&quot;&quot;).arg(y);</a>
<a name="ln1225">      attr += &quot; justify=\&quot;&quot; + just + &quot;\&quot;&quot;;</a>
<a name="ln1226">      attr += &quot; valign=\&quot;&quot; + val + &quot;\&quot;&quot;;</a>
<a name="ln1227">      MScoreTextToMXML mttm(&quot;credit-words&quot;, attr, defFmt, mtf);</a>
<a name="ln1228">      mttm.writeTextFragments(words, xml);</a>
<a name="ln1229">      xml.etag();</a>
<a name="ln1230">      }</a>
<a name="ln1231"> </a>
<a name="ln1232">//---------------------------------------------------------</a>
<a name="ln1233">//   parentHeight</a>
<a name="ln1234">//---------------------------------------------------------</a>
<a name="ln1235"> </a>
<a name="ln1236">static double parentHeight(const Element* element)</a>
<a name="ln1237">      {</a>
<a name="ln1238">      const Element* parent = element-&gt;parent();</a>
<a name="ln1239"> </a>
<a name="ln1240">      if (!parent)</a>
<a name="ln1241">            return 0;</a>
<a name="ln1242"> </a>
<a name="ln1243">      if (parent-&gt;type() == ElementType::VBOX) {</a>
<a name="ln1244">            return parent-&gt;height();</a>
<a name="ln1245">            }</a>
<a name="ln1246"> </a>
<a name="ln1247">      return 0;</a>
<a name="ln1248">      }</a>
<a name="ln1249"> </a>
<a name="ln1250">//---------------------------------------------------------</a>
<a name="ln1251">//   textAsCreditWords</a>
<a name="ln1252">//---------------------------------------------------------</a>
<a name="ln1253"> </a>
<a name="ln1254">// Refactor suggestion: make getTenthsFromInches static instead of ExportMusicXml member function</a>
<a name="ln1255"> </a>
<a name="ln1256">static void textAsCreditWords(const ExportMusicXml* const expMxml, XmlWriter&amp; xml, const Score* const s, const int pageNr, const Text* const text)</a>
<a name="ln1257">      {</a>
<a name="ln1258">      // determine page formatting</a>
<a name="ln1259">      const double h  = expMxml-&gt;getTenthsFromInches(s-&gt;styleD(Sid::pageHeight));</a>
<a name="ln1260">      const double w  = expMxml-&gt;getTenthsFromInches(s-&gt;styleD(Sid::pageWidth));</a>
<a name="ln1261">      const double lm = expMxml-&gt;getTenthsFromInches(s-&gt;styleD(Sid::pageOddLeftMargin));</a>
<a name="ln1262">      const double rm = expMxml-&gt;getTenthsFromInches(s-&gt;styleD(Sid::pageEvenLeftMargin));</a>
<a name="ln1263">      const double ph = expMxml-&gt;getTenthsFromDots(parentHeight(text));</a>
<a name="ln1264"> </a>
<a name="ln1265">      double tx = w / 2;</a>
<a name="ln1266">      double ty = h - expMxml-&gt;getTenthsFromDots(text-&gt;pagePos().y());</a>
<a name="ln1267"> </a>
<a name="ln1268">      Align al = text-&gt;align();</a>
<a name="ln1269">      QString just;</a>
<a name="ln1270">      QString val;</a>
<a name="ln1271"> </a>
<a name="ln1272">      if (al &amp; Align::RIGHT) {</a>
<a name="ln1273">            just = &quot;right&quot;;</a>
<a name="ln1274">            tx   = w - rm;</a>
<a name="ln1275">            }</a>
<a name="ln1276">      else if (al &amp; Align::HCENTER) {</a>
<a name="ln1277">            just = &quot;center&quot;;</a>
<a name="ln1278">            // tx already set correctly</a>
<a name="ln1279">            }</a>
<a name="ln1280">      else {</a>
<a name="ln1281">            just = &quot;left&quot;;</a>
<a name="ln1282">            tx   = lm;</a>
<a name="ln1283">            }</a>
<a name="ln1284"> </a>
<a name="ln1285">      if (al &amp; Align::BOTTOM) {</a>
<a name="ln1286">            val = &quot;bottom&quot;;</a>
<a name="ln1287">            ty -= ph;</a>
<a name="ln1288">            }</a>
<a name="ln1289">      else if (al &amp; Align::VCENTER) {</a>
<a name="ln1290">            val = &quot;middle&quot;;</a>
<a name="ln1291">            ty -= ph / 2;</a>
<a name="ln1292">            }</a>
<a name="ln1293">      else if (al &amp; Align::BASELINE) {</a>
<a name="ln1294">            val = &quot;baseline&quot;;</a>
<a name="ln1295">            ty -= ph / 2;</a>
<a name="ln1296">            }</a>
<a name="ln1297">      else {</a>
<a name="ln1298">            val = &quot;top&quot;;</a>
<a name="ln1299">            // ty already set correctly</a>
<a name="ln1300">            }</a>
<a name="ln1301"> </a>
<a name="ln1302">      creditWords(xml, s, pageNr, tx, ty, just, val, text-&gt;fragmentList());</a>
<a name="ln1303">      }</a>
<a name="ln1304"> </a>
<a name="ln1305">//---------------------------------------------------------</a>
<a name="ln1306">//   credits</a>
<a name="ln1307">//---------------------------------------------------------</a>
<a name="ln1308"> </a>
<a name="ln1309">void ExportMusicXml::credits(XmlWriter&amp; xml)</a>
<a name="ln1310">      {</a>
<a name="ln1311">      // find the vboxes in every page and write their elements as credit-words</a>
<a name="ln1312">      for (const auto page : _score-&gt;pages()) {</a>
<a name="ln1313">            const auto pageIdx = _score-&gt;pageIdx(page);</a>
<a name="ln1314">            for (const auto system : page-&gt;systems()) {</a>
<a name="ln1315">                  for (const auto mb : system-&gt;measures()) {</a>
<a name="ln1316">                        if (mb-&gt;isVBox()) {</a>
<a name="ln1317">                              for (const Element* element : mb-&gt;el()) {</a>
<a name="ln1318">                                    if (element-&gt;isText()) {</a>
<a name="ln1319">                                          const Text* text = toText(element);</a>
<a name="ln1320">                                          textAsCreditWords(this, xml, _score, pageIdx + 1, text);</a>
<a name="ln1321">                                          }</a>
<a name="ln1322">                                    }</a>
<a name="ln1323">                              }</a>
<a name="ln1324">                        }</a>
<a name="ln1325">                  }</a>
<a name="ln1326">            }</a>
<a name="ln1327"> </a>
<a name="ln1328">      // put copyright at the bottom center of every page</a>
<a name="ln1329">      // note: as the copyright metatag contains plain text, special XML characters must be escaped</a>
<a name="ln1330">      // determine page formatting</a>
<a name="ln1331">      const QString rights = _score-&gt;metaTag(&quot;copyright&quot;);</a>
<a name="ln1332">      if (!rights.isEmpty()) {</a>
<a name="ln1333">            const double bm = getTenthsFromInches(_score-&gt;styleD(Sid::pageOddBottomMargin));</a>
<a name="ln1334">            const double w  = getTenthsFromInches(_score-&gt;styleD(Sid::pageWidth));</a>
<a name="ln1335">            /*</a>
<a name="ln1336">            const double h  = getTenthsFromInches(_score-&gt;styleD(Sid::pageHeight));</a>
<a name="ln1337">            const double lm = getTenthsFromInches(_score-&gt;styleD(Sid::pageOddLeftMargin));</a>
<a name="ln1338">            const double rm = getTenthsFromInches(_score-&gt;styleD(Sid::pageEvenLeftMargin));</a>
<a name="ln1339">            const double tm = getTenthsFromInches(_score-&gt;styleD(Sid::pageOddTopMargin));</a>
<a name="ln1340">            qDebug(&quot;page h=%g w=%g lm=%g rm=%g tm=%g bm=%g&quot;, h, w, lm, rm, tm, bm);</a>
<a name="ln1341">            */</a>
<a name="ln1342">            TextFragment f(XmlWriter::xmlString(rights));</a>
<a name="ln1343">            f.changeFormat(FormatId::FontFamily, _score-&gt;styleSt(Sid::footerFontFace));</a>
<a name="ln1344">            f.changeFormat(FormatId::FontSize, _score-&gt;styleD(Sid::footerFontSize));</a>
<a name="ln1345">            QList&lt;TextFragment&gt; list;</a>
<a name="ln1346">            list.append(f);</a>
<a name="ln1347">            for (int pageIdx = 0; pageIdx &lt; _score-&gt;npages(); ++pageIdx)</a>
<a name="ln1348">                  creditWords(xml, _score, pageIdx + 1, w / 2, bm, &quot;center&quot;, &quot;bottom&quot;, list);</a>
<a name="ln1349">            }</a>
<a name="ln1350">      }</a>
<a name="ln1351"> </a>
<a name="ln1352">//---------------------------------------------------------</a>
<a name="ln1353">//   midipitch2xml</a>
<a name="ln1354">//---------------------------------------------------------</a>
<a name="ln1355"> </a>
<a name="ln1356">static int alterTab[12] = { 0,   1,   0,   1,   0,  0,   1,   0,   1,   0,   1,   0 };</a>
<a name="ln1357">static char noteTab[12] = { 'C', 'C', 'D', 'D', 'E', 'F', 'F', 'G', 'G', 'A', 'A', 'B' };</a>
<a name="ln1358"> </a>
<a name="ln1359">static void midipitch2xml(int pitch, char&amp; c, int&amp; alter, int&amp; octave)</a>
<a name="ln1360">      {</a>
<a name="ln1361">      // 60 = C 4</a>
<a name="ln1362">      c      = noteTab[pitch % 12];</a>
<a name="ln1363">      alter  = alterTab[pitch % 12];</a>
<a name="ln1364">      octave = pitch / 12 - 1;</a>
<a name="ln1365">      //qDebug(&quot;midipitch2xml(pitch %d) step %c, alter %d, octave %d&quot;, pitch, c, alter, octave);</a>
<a name="ln1366">      }</a>
<a name="ln1367"> </a>
<a name="ln1368">//---------------------------------------------------------</a>
<a name="ln1369">//   tabpitch2xml</a>
<a name="ln1370">//---------------------------------------------------------</a>
<a name="ln1371"> </a>
<a name="ln1372">static void tabpitch2xml(const int pitch, const int tpc, QString&amp; s, int&amp; alter, int&amp; octave)</a>
<a name="ln1373">      {</a>
<a name="ln1374">      s      = tpc2stepName(tpc);</a>
<a name="ln1375">      alter  = tpc2alterByKey(tpc, Key::C);</a>
<a name="ln1376">      octave = (pitch - alter) / 12 - 1;</a>
<a name="ln1377">      if (alter &lt; -2 || 2 &lt; alter)</a>
<a name="ln1378">            qDebug(&quot;tabpitch2xml(pitch %d, tpc %d) problem:  step %s, alter %d, octave %d&quot;,</a>
<a name="ln1379">                   pitch, tpc, qPrintable(s), alter, octave);</a>
<a name="ln1380">      /*</a>
<a name="ln1381">      else</a>
<a name="ln1382">            qDebug(&quot;tabpitch2xml(pitch %d, tpc %d) step %s, alter %d, octave %d&quot;,</a>
<a name="ln1383">                   pitch, tpc, qPrintable(s), alter, octave);</a>
<a name="ln1384">       */</a>
<a name="ln1385">      }</a>
<a name="ln1386"> </a>
<a name="ln1387">//---------------------------------------------------------</a>
<a name="ln1388">//   pitch2xml</a>
<a name="ln1389">//---------------------------------------------------------</a>
<a name="ln1390"> </a>
<a name="ln1391">// TODO validation</a>
<a name="ln1392"> </a>
<a name="ln1393">static void pitch2xml(const Note* note, QString&amp; s, int&amp; alter, int&amp; octave)</a>
<a name="ln1394">      {</a>
<a name="ln1395">      const auto st = note-&gt;staff();</a>
<a name="ln1396">      const auto tick = note-&gt;tick();</a>
<a name="ln1397">      const auto instr = st-&gt;part()-&gt;instrument(tick);</a>
<a name="ln1398">      const auto intval = instr-&gt;transpose();</a>
<a name="ln1399"> </a>
<a name="ln1400">      s      = tpc2stepName(note-&gt;tpc());</a>
<a name="ln1401">      alter  = tpc2alterByKey(note-&gt;tpc(), Key::C);</a>
<a name="ln1402">      // note that pitch must be converted to concert pitch</a>
<a name="ln1403">      // in order to calculate the correct octave</a>
<a name="ln1404">      octave = (note-&gt;pitch() - intval.chromatic - alter) / 12 - 1;</a>
<a name="ln1405"> </a>
<a name="ln1406">      //</a>
<a name="ln1407">      // HACK:</a>
<a name="ln1408">      // On percussion clefs there is no relationship between</a>
<a name="ln1409">      // note-&gt;pitch() and note-&gt;line()</a>
<a name="ln1410">      // note-&gt;line() is determined by drumMap</a>
<a name="ln1411">      //</a>
<a name="ln1412">      ClefType ct     = st-&gt;clef(tick);</a>
<a name="ln1413">      if (ct == ClefType::PERC || ct == ClefType::PERC2) {</a>
<a name="ln1414">            alter = 0;</a>
<a name="ln1415">            octave = line2pitch(note-&gt;line(), ct, Key::C) / 12 - 1;</a>
<a name="ln1416">            }</a>
<a name="ln1417"> </a>
<a name="ln1418">      // correct for ottava lines</a>
<a name="ln1419">      int ottava = 0;</a>
<a name="ln1420">      switch (note-&gt;ppitch() - note-&gt;pitch()) {</a>
<a name="ln1421">            case  24: ottava =  2; break;</a>
<a name="ln1422">            case  12: ottava =  1; break;</a>
<a name="ln1423">            case   0: ottava =  0; break;</a>
<a name="ln1424">            case -12: ottava = -1; break;</a>
<a name="ln1425">            case -24: ottava = -2; break;</a>
<a name="ln1426">            default:  qDebug(&quot;pitch2xml() tick=%d pitch()=%d ppitch()=%d&quot;,</a>
<a name="ln1427">                             tick.ticks(), note-&gt;pitch(), note-&gt;ppitch());</a>
<a name="ln1428">            }</a>
<a name="ln1429">      octave += ottava;</a>
<a name="ln1430"> </a>
<a name="ln1431">      //qDebug(&quot;pitch2xml(pitch %d, tpc %d, ottava %d clef %hhd) step    %s, alter    %d, octave    %d&quot;,</a>
<a name="ln1432">      //       note-&gt;pitch(), note-&gt;tpc(), ottava, clef, qPrintable(s), alter, octave);</a>
<a name="ln1433">      }</a>
<a name="ln1434"> </a>
<a name="ln1435">// unpitch2xml -- calculate display-step and display-octave for an unpitched note</a>
<a name="ln1436">// note:</a>
<a name="ln1437">// even though this produces the correct step/octave according to Recordare's tutorial</a>
<a name="ln1438">// Finale Notepad 2012 does not import a three line staff with percussion clef correctly</a>
<a name="ln1439">// Same goes for Sibelius 6 in case of three or five line staff with percussion clef</a>
<a name="ln1440"> </a>
<a name="ln1441">static void unpitch2xml(const Note* note, QString&amp; s, int&amp; octave)</a>
<a name="ln1442">      {</a>
<a name="ln1443">      static char table1[]  = &quot;FEDCBAG&quot;;</a>
<a name="ln1444"> </a>
<a name="ln1445">      Fraction tick        = note-&gt;chord()-&gt;tick();</a>
<a name="ln1446">      Staff* st       = note-&gt;staff();</a>
<a name="ln1447">      ClefType ct     = st-&gt;clef(tick);</a>
<a name="ln1448">      // offset in lines between staff with current clef and with G clef</a>
<a name="ln1449">      int clefOffset  = ClefInfo::pitchOffset(ct) - ClefInfo::pitchOffset(ClefType::G);</a>
<a name="ln1450">      // line note would be on on a five line staff with G clef</a>
<a name="ln1451">      // note top line is line 0, bottom line is line 8</a>
<a name="ln1452">      int line5g      = note-&gt;line() - clefOffset;</a>
<a name="ln1453">      // in MusicXML with percussion clef, step and octave are determined as if G clef is used</a>
<a name="ln1454">      // when stafflines is not equal to five, in MusicXML the bottom line is still E4.</a>
<a name="ln1455">      // in MuseScore assumes line 0 is F5</a>
<a name="ln1456">      // MS line numbers (top to bottom) plus correction to get lowest line at E4 (line 8)</a>
<a name="ln1457">      // 1 line staff: 0             -&gt; correction 8</a>
<a name="ln1458">      // 3 line staff: 2, 4, 6       -&gt; correction 2</a>
<a name="ln1459">      // 5 line staff: 0, 2, 4, 6, 8 -&gt; correction 0</a>
<a name="ln1460">      // TODO handle other # staff lines ?</a>
<a name="ln1461">      if (st-&gt;lines(Fraction(0,1)) == 1) line5g += 8;</a>
<a name="ln1462">      if (st-&gt;lines(Fraction(0,1)) == 3) line5g += 2;</a>
<a name="ln1463">      // index in table1 to get step</a>
<a name="ln1464">      int stepIdx     = (line5g + 700) % 7;</a>
<a name="ln1465">      // get step</a>
<a name="ln1466">      s               = table1[stepIdx];</a>
<a name="ln1467">      // calculate octave, offset &quot;3&quot; correcting for the fact that an octave starts</a>
<a name="ln1468">      // with C instead of F</a>
<a name="ln1469">      octave =(3 - line5g + 700) / 7 + 5 - 100;</a>
<a name="ln1470">      // qDebug(&quot;ExportMusicXml::unpitch2xml(%p) clef %d clef.po %d clefOffset %d staff.lines %d note.line %d line5g %d step %c oct %d&quot;,</a>
<a name="ln1471">      //        note, ct, clefTable[ct].pitchOffset, clefOffset, st-&gt;lines(), note-&gt;line(), line5g, step, octave);</a>
<a name="ln1472">      }</a>
<a name="ln1473"> </a>
<a name="ln1474">//---------------------------------------------------------</a>
<a name="ln1475">//   tick2xml</a>
<a name="ln1476">//    set type + dots depending on tick len</a>
<a name="ln1477">//---------------------------------------------------------</a>
<a name="ln1478"> </a>
<a name="ln1479">static QString tick2xml(const Fraction&amp; ticks, int* dots)</a>
<a name="ln1480">      {</a>
<a name="ln1481">      TDuration t;</a>
<a name="ln1482">      t.setVal(ticks.ticks());</a>
<a name="ln1483">      *dots = t.dots();</a>
<a name="ln1484">      return t.name();</a>
<a name="ln1485">      }</a>
<a name="ln1486"> </a>
<a name="ln1487">//---------------------------------------------------------</a>
<a name="ln1488">//   findVolta -- find volta starting in measure m</a>
<a name="ln1489">//---------------------------------------------------------</a>
<a name="ln1490"> </a>
<a name="ln1491">static Volta* findVolta(const Measure* const m, bool left)</a>
<a name="ln1492">      {</a>
<a name="ln1493">      Fraction stick = m-&gt;tick();</a>
<a name="ln1494">      Fraction etick = m-&gt;tick() + m-&gt;ticks();</a>
<a name="ln1495">      auto spanners = m-&gt;score()-&gt;spannerMap().findOverlapping(stick.ticks(), etick.ticks());</a>
<a name="ln1496">      for (auto i : spanners) {</a>
<a name="ln1497">            Spanner* el = i.value;</a>
<a name="ln1498">            if (el-&gt;type() != ElementType::VOLTA)</a>
<a name="ln1499">                  continue;</a>
<a name="ln1500">            if (left &amp;&amp; el-&gt;tick() == stick)</a>
<a name="ln1501">                  return (Volta*) el;</a>
<a name="ln1502">            if (!left &amp;&amp; el-&gt;tick2() == etick)</a>
<a name="ln1503">                  return (Volta*) el;</a>
<a name="ln1504">            }</a>
<a name="ln1505">      return 0;</a>
<a name="ln1506">      }</a>
<a name="ln1507"> </a>
<a name="ln1508">//---------------------------------------------------------</a>
<a name="ln1509">//   ending</a>
<a name="ln1510">//---------------------------------------------------------</a>
<a name="ln1511"> </a>
<a name="ln1512">static void ending(XmlWriter&amp; xml, Volta* v, bool left)</a>
<a name="ln1513">      {</a>
<a name="ln1514">      QString number = &quot;&quot;;</a>
<a name="ln1515">      QString type = &quot;&quot;;</a>
<a name="ln1516">      for (int i : v-&gt;endings()) {</a>
<a name="ln1517">            if (!number.isEmpty())</a>
<a name="ln1518">                  number += &quot;, &quot;;</a>
<a name="ln1519">            number += QString(&quot;%1&quot;).arg(i);</a>
<a name="ln1520">            }</a>
<a name="ln1521">      if (left) {</a>
<a name="ln1522">            type = &quot;start&quot;;</a>
<a name="ln1523">            }</a>
<a name="ln1524">      else {</a>
<a name="ln1525">            Volta::Type st = v-&gt;voltaType();</a>
<a name="ln1526">            switch (st) {</a>
<a name="ln1527">                  case Volta::Type::OPEN:</a>
<a name="ln1528">                        type = &quot;discontinue&quot;;</a>
<a name="ln1529">                        break;</a>
<a name="ln1530">                  case Volta::Type::CLOSED:</a>
<a name="ln1531">                        type = &quot;stop&quot;;</a>
<a name="ln1532">                        break;</a>
<a name="ln1533">                  default:</a>
<a name="ln1534">                        qDebug(&quot;unknown volta subtype %d&quot;, int(st));</a>
<a name="ln1535">                        return;</a>
<a name="ln1536">                  }</a>
<a name="ln1537">            }</a>
<a name="ln1538">      QString voltaXml = QString(&quot;ending number=\&quot;%1\&quot; type=\&quot;%2\&quot;&quot;).arg(number).arg(type);</a>
<a name="ln1539">      voltaXml += positioningAttributes(v, left);</a>
<a name="ln1540">      xml.tagE(voltaXml);</a>
<a name="ln1541">      }</a>
<a name="ln1542"> </a>
<a name="ln1543">//---------------------------------------------------------</a>
<a name="ln1544">//   barlineLeft -- search for and handle barline left</a>
<a name="ln1545">//---------------------------------------------------------</a>
<a name="ln1546"> </a>
<a name="ln1547">void ExportMusicXml::barlineLeft(const Measure* const m)</a>
<a name="ln1548">      {</a>
<a name="ln1549">      bool rs = m-&gt;repeatStart();</a>
<a name="ln1550">      Volta* volta = findVolta(m, true);</a>
<a name="ln1551">      if (!rs &amp;&amp; !volta) return;</a>
<a name="ln1552">      _attr.doAttr(_xml, false);</a>
<a name="ln1553">      _xml.stag(QString(&quot;barline location=\&quot;left\&quot;&quot;));</a>
<a name="ln1554">      if (rs)</a>
<a name="ln1555">            _xml.tag(&quot;bar-style&quot;, QString(&quot;heavy-light&quot;));</a>
<a name="ln1556">      if (volta)</a>
<a name="ln1557">            ending(_xml, volta, true);</a>
<a name="ln1558">      if (rs)</a>
<a name="ln1559">            _xml.tagE(&quot;repeat direction=\&quot;forward\&quot;&quot;);</a>
<a name="ln1560">      _xml.etag();</a>
<a name="ln1561">      }</a>
<a name="ln1562"> </a>
<a name="ln1563">//---------------------------------------------------------</a>
<a name="ln1564">//   shortBarlineStyle -- recognize normal but shorter barline styles</a>
<a name="ln1565">//---------------------------------------------------------</a>
<a name="ln1566"> </a>
<a name="ln1567">static QString shortBarlineStyle(const BarLine* bl)</a>
<a name="ln1568">      {</a>
<a name="ln1569">      if (bl-&gt;barLineType() == BarLineType::NORMAL &amp;&amp; !bl-&gt;spanStaff()) {</a>
<a name="ln1570">            if (bl-&gt;spanTo() &lt; 0) {</a>
<a name="ln1571">                  // lowest point of barline above lowest staff line</a>
<a name="ln1572">                  if (bl-&gt;spanFrom() &lt; 0) {</a>
<a name="ln1573">                        return &quot;tick&quot;;       // highest point of barline above highest staff line</a>
<a name="ln1574">                        }</a>
<a name="ln1575">                  else</a>
<a name="ln1576">                        return &quot;short&quot;;       // highest point of barline below highest staff line</a>
<a name="ln1577">                  }</a>
<a name="ln1578">            }</a>
<a name="ln1579"> </a>
<a name="ln1580">      return &quot;&quot;;</a>
<a name="ln1581">      }</a>
<a name="ln1582"> </a>
<a name="ln1583">//---------------------------------------------------------</a>
<a name="ln1584">//   normalBarlineStyle -- recognize other barline styles</a>
<a name="ln1585">//---------------------------------------------------------</a>
<a name="ln1586"> </a>
<a name="ln1587">static QString normalBarlineStyle(const BarLine* bl)</a>
<a name="ln1588">      {</a>
<a name="ln1589">      const auto bst = bl-&gt;barLineType();</a>
<a name="ln1590"> </a>
<a name="ln1591">      switch (bst) {</a>
<a name="ln1592">            case BarLineType::NORMAL:</a>
<a name="ln1593">                  return &quot;regular&quot;;</a>
<a name="ln1594">            case BarLineType::DOUBLE:</a>
<a name="ln1595">                  return &quot;light-light&quot;;</a>
<a name="ln1596">            case BarLineType::END_REPEAT:</a>
<a name="ln1597">                  return &quot;light-heavy&quot;;</a>
<a name="ln1598">            case BarLineType::BROKEN:</a>
<a name="ln1599">                  return &quot;dashed&quot;;</a>
<a name="ln1600">            case BarLineType::DOTTED:</a>
<a name="ln1601">                  return &quot;dotted&quot;;</a>
<a name="ln1602">            case BarLineType::END:</a>
<a name="ln1603">            case BarLineType::END_START_REPEAT:</a>
<a name="ln1604">                  return &quot;light-heavy&quot;;</a>
<a name="ln1605">            default:</a>
<a name="ln1606">                  qDebug(&quot;bar subtype %d not supported&quot;, int(bst));</a>
<a name="ln1607">            }</a>
<a name="ln1608"> </a>
<a name="ln1609">      return &quot;&quot;;</a>
<a name="ln1610">      }</a>
<a name="ln1611"> </a>
<a name="ln1612">//---------------------------------------------------------</a>
<a name="ln1613">//   barlineMiddle -- handle barline middle</a>
<a name="ln1614">//---------------------------------------------------------</a>
<a name="ln1615"> </a>
<a name="ln1616">void ExportMusicXml::barlineMiddle(const BarLine* bl)</a>
<a name="ln1617">      {</a>
<a name="ln1618">      auto vis = bl-&gt;visible();</a>
<a name="ln1619">      auto shortStyle = shortBarlineStyle(bl);</a>
<a name="ln1620">      auto normalStyle = normalBarlineStyle(bl);</a>
<a name="ln1621">      QString barStyle;</a>
<a name="ln1622">      if (!vis)</a>
<a name="ln1623">            barStyle = &quot;none&quot;;</a>
<a name="ln1624">      else if (shortStyle != &quot;&quot;)</a>
<a name="ln1625">            barStyle = shortStyle;</a>
<a name="ln1626">      else</a>
<a name="ln1627">            barStyle = normalStyle;</a>
<a name="ln1628"> </a>
<a name="ln1629">      if (barStyle != &quot;&quot;) {</a>
<a name="ln1630">            _xml.stag(QString(&quot;barline location=\&quot;middle\&quot;&quot;));</a>
<a name="ln1631">            _xml.tag(&quot;bar-style&quot;, barStyle);</a>
<a name="ln1632">            _xml.etag();</a>
<a name="ln1633">            }</a>
<a name="ln1634">      }</a>
<a name="ln1635"> </a>
<a name="ln1636">//---------------------------------------------------------</a>
<a name="ln1637">//   barlineRight -- search for and handle barline right</a>
<a name="ln1638">//---------------------------------------------------------</a>
<a name="ln1639"> </a>
<a name="ln1640">void ExportMusicXml::barlineRight(const Measure* const m)</a>
<a name="ln1641">      {</a>
<a name="ln1642">      const Measure* mmR1 = m-&gt;mmRest1(); // the multi measure rest this measure is covered by</a>
<a name="ln1643">      const Measure* mmRLst = mmR1-&gt;isMMRest() ? mmR1-&gt;mmRestLast() : 0; // last measure of replaced sequence of empty measures</a>
<a name="ln1644">      // note: use barlinetype as found in multi measure rest for last measure of replaced sequence</a>
<a name="ln1645">      BarLineType bst = m == mmRLst ? mmR1-&gt;endBarLineType() : m-&gt;endBarLineType();</a>
<a name="ln1646">      bool visible = m-&gt;endBarLineVisible();</a>
<a name="ln1647"> </a>
<a name="ln1648">      bool needBarStyle = (bst != BarLineType::NORMAL &amp;&amp; bst != BarLineType::START_REPEAT) || !visible;</a>
<a name="ln1649">      Volta* volta = findVolta(m, false);</a>
<a name="ln1650">      // detect short and tick barlines</a>
<a name="ln1651">      QString special = &quot;&quot;;</a>
<a name="ln1652">      if (bst == BarLineType::NORMAL) {</a>
<a name="ln1653">            const BarLine* bl = m-&gt;endBarLine();</a>
<a name="ln1654">            if (bl &amp;&amp; !bl-&gt;spanStaff()) {</a>
<a name="ln1655">                  if (bl-&gt;spanFrom() == BARLINE_SPAN_TICK1_FROM &amp;&amp; bl-&gt;spanTo() == BARLINE_SPAN_TICK1_TO)</a>
<a name="ln1656">                        special = &quot;tick&quot;;</a>
<a name="ln1657">                  if (bl-&gt;spanFrom() == BARLINE_SPAN_TICK2_FROM &amp;&amp; bl-&gt;spanTo() == BARLINE_SPAN_TICK2_TO)</a>
<a name="ln1658">                        special = &quot;tick&quot;;</a>
<a name="ln1659">                  if (bl-&gt;spanFrom() == BARLINE_SPAN_SHORT1_FROM &amp;&amp; bl-&gt;spanTo() == BARLINE_SPAN_SHORT1_TO)</a>
<a name="ln1660">                        special = &quot;short&quot;;</a>
<a name="ln1661">                  if (bl-&gt;spanFrom() == BARLINE_SPAN_SHORT2_FROM &amp;&amp; bl-&gt;spanTo() == BARLINE_SPAN_SHORT2_FROM)</a>
<a name="ln1662">                        special = &quot;short&quot;;</a>
<a name="ln1663">                  }</a>
<a name="ln1664">            }</a>
<a name="ln1665">      if (!needBarStyle &amp;&amp; !volta &amp;&amp; special.isEmpty())</a>
<a name="ln1666">            return;</a>
<a name="ln1667"> </a>
<a name="ln1668">      _xml.stag(QString(&quot;barline location=\&quot;right\&quot;&quot;));</a>
<a name="ln1669">      if (needBarStyle) {</a>
<a name="ln1670">            if (!visible) {</a>
<a name="ln1671">                  _xml.tag(&quot;bar-style&quot;, QString(&quot;none&quot;));</a>
<a name="ln1672">                  }</a>
<a name="ln1673">            else {</a>
<a name="ln1674">                  switch (bst) {</a>
<a name="ln1675">                        case BarLineType::DOUBLE:</a>
<a name="ln1676">                              _xml.tag(&quot;bar-style&quot;, QString(&quot;light-light&quot;));</a>
<a name="ln1677">                              break;</a>
<a name="ln1678">                        case BarLineType::END_REPEAT:</a>
<a name="ln1679">                              _xml.tag(&quot;bar-style&quot;, QString(&quot;light-heavy&quot;));</a>
<a name="ln1680">                              break;</a>
<a name="ln1681">                        case BarLineType::BROKEN:</a>
<a name="ln1682">                              _xml.tag(&quot;bar-style&quot;, QString(&quot;dashed&quot;));</a>
<a name="ln1683">                              break;</a>
<a name="ln1684">                        case BarLineType::DOTTED:</a>
<a name="ln1685">                              _xml.tag(&quot;bar-style&quot;, QString(&quot;dotted&quot;));</a>
<a name="ln1686">                              break;</a>
<a name="ln1687">                        case BarLineType::END:</a>
<a name="ln1688">                        case BarLineType::END_START_REPEAT:</a>
<a name="ln1689">                              _xml.tag(&quot;bar-style&quot;, QString(&quot;light-heavy&quot;));</a>
<a name="ln1690">                              break;</a>
<a name="ln1691">                        default:</a>
<a name="ln1692">                              qDebug(&quot;ExportMusicXml::bar(): bar subtype %d not supported&quot;, int(bst));</a>
<a name="ln1693">                              break;</a>
<a name="ln1694">                        }</a>
<a name="ln1695">                  }</a>
<a name="ln1696">            }</a>
<a name="ln1697">      else if (!special.isEmpty()) {</a>
<a name="ln1698">            _xml.tag(&quot;bar-style&quot;, special);</a>
<a name="ln1699">            }</a>
<a name="ln1700"> </a>
<a name="ln1701">      if (volta) {</a>
<a name="ln1702">            ending(_xml, volta, false);</a>
<a name="ln1703">            }</a>
<a name="ln1704"> </a>
<a name="ln1705">      if (bst == BarLineType::END_REPEAT || bst == BarLineType::END_START_REPEAT) {</a>
<a name="ln1706">            if (m-&gt;repeatCount() &gt; 2) {</a>
<a name="ln1707">                  _xml.tagE(QString(&quot;repeat direction=\&quot;backward\&quot; times=\&quot;%1\&quot;&quot;).arg(m-&gt;repeatCount()));</a>
<a name="ln1708">                  } else {</a>
<a name="ln1709">                  _xml.tagE(&quot;repeat direction=\&quot;backward\&quot;&quot;);</a>
<a name="ln1710">                  }</a>
<a name="ln1711">            }</a>
<a name="ln1712"> </a>
<a name="ln1713">      _xml.etag();</a>
<a name="ln1714">      }</a>
<a name="ln1715"> </a>
<a name="ln1716">//---------------------------------------------------------</a>
<a name="ln1717">//   calculateTimeDeltaInDivisions</a>
<a name="ln1718">//---------------------------------------------------------</a>
<a name="ln1719"> </a>
<a name="ln1720">static int calculateTimeDeltaInDivisions(const Fraction&amp; t1, const Fraction&amp; t2, const int divisions)</a>
<a name="ln1721">      {</a>
<a name="ln1722">      return (t1 - t2).ticks() / divisions;</a>
<a name="ln1723">      }</a>
<a name="ln1724"> </a>
<a name="ln1725">//---------------------------------------------------------</a>
<a name="ln1726">//   moveToTick</a>
<a name="ln1727">//---------------------------------------------------------</a>
<a name="ln1728"> </a>
<a name="ln1729">void ExportMusicXml::moveToTick(const Fraction&amp; t)</a>
<a name="ln1730">      {</a>
<a name="ln1731">      //qDebug(&quot;ExportMusicXml::moveToTick(t=%s) _tick=%s&quot;, qPrintable(t.print()), qPrintable(_tick.print()));</a>
<a name="ln1732">      if (t &lt; _tick) {</a>
<a name="ln1733">#ifdef DEBUG_TICK</a>
<a name="ln1734">            qDebug(&quot; -&gt; backup&quot;);</a>
<a name="ln1735">#endif</a>
<a name="ln1736">            _attr.doAttr(_xml, false);</a>
<a name="ln1737">            _xml.stag(&quot;backup&quot;);</a>
<a name="ln1738">            _xml.tag(&quot;duration&quot;, calculateTimeDeltaInDivisions(_tick, t, div));</a>
<a name="ln1739">            _xml.etag();</a>
<a name="ln1740">            }</a>
<a name="ln1741">      else if (t &gt; _tick) {</a>
<a name="ln1742">#ifdef DEBUG_TICK</a>
<a name="ln1743">            qDebug(&quot; -&gt; forward&quot;);</a>
<a name="ln1744">#endif</a>
<a name="ln1745">            _attr.doAttr(_xml, false);</a>
<a name="ln1746">            _xml.stag(&quot;forward&quot;);</a>
<a name="ln1747">            _xml.tag(&quot;duration&quot;, calculateTimeDeltaInDivisions(t, _tick, div));</a>
<a name="ln1748">            _xml.etag();</a>
<a name="ln1749">            }</a>
<a name="ln1750">      _tick = t;</a>
<a name="ln1751">      }</a>
<a name="ln1752"> </a>
<a name="ln1753">//---------------------------------------------------------</a>
<a name="ln1754">//   timesig</a>
<a name="ln1755">//---------------------------------------------------------</a>
<a name="ln1756"> </a>
<a name="ln1757">void ExportMusicXml::timesig(TimeSig* tsig)</a>
<a name="ln1758">      {</a>
<a name="ln1759">      TimeSigType st = tsig-&gt;timeSigType();</a>
<a name="ln1760">      Fraction ts = tsig-&gt;sig();</a>
<a name="ln1761">      int z = ts.numerator();</a>
<a name="ln1762">      int n = ts.denominator();</a>
<a name="ln1763">      QString ns = tsig-&gt;numeratorString();</a>
<a name="ln1764"> </a>
<a name="ln1765">      _attr.doAttr(_xml, true);</a>
<a name="ln1766">      QString tagName = &quot;time&quot;;</a>
<a name="ln1767">      if (st == TimeSigType::FOUR_FOUR)</a>
<a name="ln1768">            tagName += &quot; symbol=\&quot;common\&quot;&quot;;</a>
<a name="ln1769">      else if (st == TimeSigType::ALLA_BREVE)</a>
<a name="ln1770">            tagName += &quot; symbol=\&quot;cut\&quot;&quot;;</a>
<a name="ln1771">      if (!tsig-&gt;visible())</a>
<a name="ln1772">            tagName += &quot; print-object=\&quot;no\&quot;&quot;;</a>
<a name="ln1773">      tagName += color2xml(tsig);</a>
<a name="ln1774">      _xml.stag(tagName);</a>
<a name="ln1775"> </a>
<a name="ln1776">      QRegExp rx(&quot;^\\d+(\\+\\d+)+$&quot;); // matches a compound numerator</a>
<a name="ln1777">      if (rx.exactMatch(ns))</a>
<a name="ln1778">            // if compound numerator, exported as is</a>
<a name="ln1779">            _xml.tag(&quot;beats&quot;, ns);</a>
<a name="ln1780">      else</a>
<a name="ln1781">            // else fall back and use the numerator as integer</a>
<a name="ln1782">            _xml.tag(&quot;beats&quot;, z);</a>
<a name="ln1783">      _xml.tag(&quot;beat-type&quot;, n);</a>
<a name="ln1784">      _xml.etag();</a>
<a name="ln1785">      }</a>
<a name="ln1786"> </a>
<a name="ln1787">//---------------------------------------------------------</a>
<a name="ln1788">//   accSymId2alter</a>
<a name="ln1789">//---------------------------------------------------------</a>
<a name="ln1790"> </a>
<a name="ln1791">static double accSymId2alter(SymId id)</a>
<a name="ln1792">      {</a>
<a name="ln1793">      double res = 0;</a>
<a name="ln1794">      switch (id) {</a>
<a name="ln1795">            case SymId::accidentalDoubleFlat:                      res = -2;   break;</a>
<a name="ln1796">            case SymId::accidentalThreeQuarterTonesFlatZimmermann: res = -1.5; break;</a>
<a name="ln1797">            case SymId::accidentalFlat:                            res = -1;   break;</a>
<a name="ln1798">            case SymId::accidentalQuarterToneFlatStein:            res = -0.5; break;</a>
<a name="ln1799">            case SymId::accidentalNatural:                         res =  0;   break;</a>
<a name="ln1800">            case SymId::accidentalQuarterToneSharpStein:           res =  0.5; break;</a>
<a name="ln1801">            case SymId::accidentalSharp:                           res =  1;   break;</a>
<a name="ln1802">            case SymId::accidentalThreeQuarterTonesSharpStein:     res =  1.5; break;</a>
<a name="ln1803">            case SymId::accidentalDoubleSharp:                     res =  2;   break;</a>
<a name="ln1804">            default: qDebug(&quot;accSymId2alter: unsupported sym %s&quot;, Sym::id2name(id));</a>
<a name="ln1805">            }</a>
<a name="ln1806">      return res;</a>
<a name="ln1807">      }</a>
<a name="ln1808"> </a>
<a name="ln1809">//---------------------------------------------------------</a>
<a name="ln1810">//   keysig</a>
<a name="ln1811">//---------------------------------------------------------</a>
<a name="ln1812"> </a>
<a name="ln1813">void ExportMusicXml::keysig(const KeySig* ks, ClefType ct, int staff, bool visible)</a>
<a name="ln1814">      {</a>
<a name="ln1815">      static char table2[]  = &quot;CDEFGAB&quot;;</a>
<a name="ln1816">      int po = ClefInfo::pitchOffset(ct); // actually 7 * oct + step for topmost staff line</a>
<a name="ln1817">      //qDebug(&quot;keysig st %d key %d custom %d ct %hhd st %d&quot;, staff, kse.key(), kse.custom(), ct, staff);</a>
<a name="ln1818">      //qDebug(&quot; pitch offset clef %d stp %d oct %d &quot;, po, po % 7, po / 7);</a>
<a name="ln1819"> </a>
<a name="ln1820">      QString tagName = &quot;key&quot;;</a>
<a name="ln1821">      if (staff)</a>
<a name="ln1822">            tagName += QString(&quot; number=\&quot;%1\&quot;&quot;).arg(staff);</a>
<a name="ln1823">      if (!visible)</a>
<a name="ln1824">            tagName += &quot; print-object=\&quot;no\&quot;&quot;;</a>
<a name="ln1825">      tagName += color2xml(ks);</a>
<a name="ln1826">      _attr.doAttr(_xml, true);</a>
<a name="ln1827">      _xml.stag(tagName);</a>
<a name="ln1828"> </a>
<a name="ln1829">      const KeySigEvent kse = ks-&gt;keySigEvent();</a>
<a name="ln1830">      const QList&lt;KeySym&gt; keysyms = kse.keySymbols();</a>
<a name="ln1831">      if (kse.custom() &amp;&amp; !kse.isAtonal() &amp;&amp; keysyms.size() &gt; 0) {</a>
<a name="ln1832"> </a>
<a name="ln1833">            // non-traditional key signature</a>
<a name="ln1834">            // MusicXML order is left-to-right order, while KeySims in keySymbols()</a>
<a name="ln1835">            // are in insertion order -&gt; sorting required</a>
<a name="ln1836"> </a>
<a name="ln1837">            // first put the KeySyms in a map</a>
<a name="ln1838">            QMap&lt;qreal, KeySym&gt; map;</a>
<a name="ln1839">            for (const KeySym&amp; ksym : keysyms) {</a>
<a name="ln1840">                  map.insert(ksym.spos.x(), ksym);</a>
<a name="ln1841">                  }</a>
<a name="ln1842">            // then write them (automatically sorted on key)</a>
<a name="ln1843">            for (const KeySym&amp; ksym : map) {</a>
<a name="ln1844">                  int line = static_cast&lt;int&gt;(round(2 * ksym.spos.y()));</a>
<a name="ln1845">                  int step = (po - line) % 7;</a>
<a name="ln1846">                  //qDebug(&quot; keysym sym %d spos %g,%g pos %g,%g -&gt; line %d step %d&quot;,</a>
<a name="ln1847">                  //       ksym.sym, ksym.spos.x(), ksym.spos.y(), ksym.pos.x(), ksym.pos.y(), line, step);</a>
<a name="ln1848">                  _xml.tag(&quot;key-step&quot;, QString(QChar(table2[step])));</a>
<a name="ln1849">                  _xml.tag(&quot;key-alter&quot;, accSymId2alter(ksym.sym));</a>
<a name="ln1850">                  _xml.tag(&quot;key-accidental&quot;, accSymId2MxmlString(ksym.sym));</a>
<a name="ln1851">                  }</a>
<a name="ln1852">            }</a>
<a name="ln1853">      else {</a>
<a name="ln1854">            // traditional key signature</a>
<a name="ln1855">            _xml.tag(&quot;fifths&quot;, static_cast&lt;int&gt;(kse.key()));</a>
<a name="ln1856">            switch (kse.mode()) {</a>
<a name="ln1857">                  case KeyMode::NONE:       _xml.tag(&quot;mode&quot;, &quot;none&quot;); break;</a>
<a name="ln1858">                  case KeyMode::MAJOR:      _xml.tag(&quot;mode&quot;, &quot;major&quot;); break;</a>
<a name="ln1859">                  case KeyMode::MINOR:      _xml.tag(&quot;mode&quot;, &quot;minor&quot;); break;</a>
<a name="ln1860">                  case KeyMode::DORIAN:     _xml.tag(&quot;mode&quot;, &quot;dorian&quot;); break;</a>
<a name="ln1861">                  case KeyMode::PHRYGIAN:   _xml.tag(&quot;mode&quot;, &quot;phrygian&quot;); break;</a>
<a name="ln1862">                  case KeyMode::LYDIAN:     _xml.tag(&quot;mode&quot;, &quot;lydian&quot;); break;</a>
<a name="ln1863">                  case KeyMode::MIXOLYDIAN: _xml.tag(&quot;mode&quot;, &quot;mixolydian&quot;); break;</a>
<a name="ln1864">                  case KeyMode::AEOLIAN:    _xml.tag(&quot;mode&quot;, &quot;aeolian&quot;); break;</a>
<a name="ln1865">                  case KeyMode::IONIAN:     _xml.tag(&quot;mode&quot;, &quot;ionian&quot;); break;</a>
<a name="ln1866">                  case KeyMode::LOCRIAN:    _xml.tag(&quot;mode&quot;, &quot;locrian&quot;); break;</a>
<a name="ln1867">                  case KeyMode::UNKNOWN:    // fall thru</a>
<a name="ln1868">                  default:</a>
<a name="ln1869">                        if (kse.custom())</a>
<a name="ln1870">                              _xml.tag(&quot;mode&quot;, &quot;none&quot;);</a>
<a name="ln1871">                  }</a>
<a name="ln1872">            }</a>
<a name="ln1873">      _xml.etag();</a>
<a name="ln1874">      }</a>
<a name="ln1875"> </a>
<a name="ln1876">//---------------------------------------------------------</a>
<a name="ln1877">//   clef</a>
<a name="ln1878">//---------------------------------------------------------</a>
<a name="ln1879"> </a>
<a name="ln1880">void ExportMusicXml::clef(int staff, const ClefType ct, const QString&amp; extraAttributes)</a>
<a name="ln1881">      {</a>
<a name="ln1882">      clefDebug(&quot;ExportMusicXml::clef(staff %d, clef %hhd)&quot;, staff, ct);</a>
<a name="ln1883"> </a>
<a name="ln1884">      QString tagName = &quot;clef&quot;;</a>
<a name="ln1885">      if (staff)</a>
<a name="ln1886">            tagName += QString(&quot; number=\&quot;%1\&quot;&quot;).arg(staff);</a>
<a name="ln1887">      tagName += extraAttributes;</a>
<a name="ln1888">      _attr.doAttr(_xml, true);</a>
<a name="ln1889">      _xml.stag(tagName);</a>
<a name="ln1890"> </a>
<a name="ln1891">      QString sign = ClefInfo::sign(ct);</a>
<a name="ln1892">      int line   = ClefInfo::line(ct);</a>
<a name="ln1893">      _xml.tag(&quot;sign&quot;, sign);</a>
<a name="ln1894">      _xml.tag(&quot;line&quot;, line);</a>
<a name="ln1895">      if (ClefInfo::octChng(ct))</a>
<a name="ln1896">            _xml.tag(&quot;clef-octave-change&quot;, ClefInfo::octChng(ct));</a>
<a name="ln1897">      _xml.etag();</a>
<a name="ln1898">      }</a>
<a name="ln1899"> </a>
<a name="ln1900">//---------------------------------------------------------</a>
<a name="ln1901">//   tupletStartStop</a>
<a name="ln1902">//---------------------------------------------------------</a>
<a name="ln1903"> </a>
<a name="ln1904">// LVIFIX: add placement to tuplet support</a>
<a name="ln1905">// &lt;notations&gt;</a>
<a name="ln1906">//   &lt;tuplet type=&quot;start&quot; placement=&quot;above&quot; bracket=&quot;no&quot;/&gt;</a>
<a name="ln1907">// &lt;/notations&gt;</a>
<a name="ln1908"> </a>
<a name="ln1909">static void tupletStartStop(ChordRest* cr, Notations&amp; notations, XmlWriter&amp; xml)</a>
<a name="ln1910">      {</a>
<a name="ln1911">      Tuplet* t = cr-&gt;tuplet();</a>
<a name="ln1912">      if (!t) return;</a>
<a name="ln1913">      if (cr == t-&gt;elements().front()) {</a>
<a name="ln1914">            notations.tag(xml);</a>
<a name="ln1915">            QString tupletTag = &quot;tuplet type=\&quot;start\&quot;&quot;;</a>
<a name="ln1916">            tupletTag += &quot; bracket=&quot;;</a>
<a name="ln1917">            tupletTag += t-&gt;hasBracket() ? &quot;\&quot;yes\&quot;&quot; : &quot;\&quot;no\&quot;&quot;;</a>
<a name="ln1918">            if (t-&gt;numberType() == TupletNumberType::SHOW_RELATION)</a>
<a name="ln1919">                  tupletTag += &quot; show-number=\&quot;both\&quot;&quot;;</a>
<a name="ln1920">            if (t-&gt;numberType() == TupletNumberType::NO_TEXT)</a>
<a name="ln1921">                  tupletTag += &quot; show-number=\&quot;none\&quot;&quot;;</a>
<a name="ln1922">            xml.tagE(tupletTag);</a>
<a name="ln1923">            }</a>
<a name="ln1924">      if (cr == t-&gt;elements().back()) {</a>
<a name="ln1925">            notations.tag(xml);</a>
<a name="ln1926">            xml.tagE(&quot;tuplet type=\&quot;stop\&quot;&quot;);</a>
<a name="ln1927">            }</a>
<a name="ln1928">      }</a>
<a name="ln1929"> </a>
<a name="ln1930">//---------------------------------------------------------</a>
<a name="ln1931">//   findTrill -- get index of trill in trill table</a>
<a name="ln1932">//   return -1 if not found</a>
<a name="ln1933">//---------------------------------------------------------</a>
<a name="ln1934"> </a>
<a name="ln1935">int ExportMusicXml::findTrill(const Trill* tr) const</a>
<a name="ln1936">      {</a>
<a name="ln1937">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln1938">            if (trills[i] == tr) return i;</a>
<a name="ln1939">      return -1;</a>
<a name="ln1940">      }</a>
<a name="ln1941"> </a>
<a name="ln1942">//---------------------------------------------------------</a>
<a name="ln1943">//   writeAccidental</a>
<a name="ln1944">//---------------------------------------------------------</a>
<a name="ln1945"> </a>
<a name="ln1946">static void writeAccidental(XmlWriter&amp; xml, const QString&amp; tagName, const Accidental* const acc)</a>
<a name="ln1947">      {</a>
<a name="ln1948">      if (acc) {</a>
<a name="ln1949">            QString s = accidentalType2MxmlString(acc-&gt;accidentalType());</a>
<a name="ln1950">            if (s != &quot;&quot;) {</a>
<a name="ln1951">                  QString tag = tagName;</a>
<a name="ln1952">                  if (acc-&gt;bracket() != AccidentalBracket::NONE)</a>
<a name="ln1953">                        tag += &quot; parentheses=\&quot;yes\&quot;&quot;;</a>
<a name="ln1954">                  xml.tag(tag, s);</a>
<a name="ln1955">                  }</a>
<a name="ln1956">            }</a>
<a name="ln1957">      }</a>
<a name="ln1958"> </a>
<a name="ln1959">//---------------------------------------------------------</a>
<a name="ln1960">//   wavyLineStart</a>
<a name="ln1961">//---------------------------------------------------------</a>
<a name="ln1962"> </a>
<a name="ln1963">static void wavyLineStart(const Trill* tr, const int number, Notations&amp; notations, Ornaments&amp; ornaments, XmlWriter&amp; xml)</a>
<a name="ln1964">      {</a>
<a name="ln1965">      // mscore only supports wavy-line with trill-mark</a>
<a name="ln1966">      notations.tag(xml);</a>
<a name="ln1967">      ornaments.tag(xml);</a>
<a name="ln1968">      xml.tagE(&quot;trill-mark&quot;);</a>
<a name="ln1969">      writeAccidental(xml, &quot;accidental-mark&quot;, tr-&gt;accidental());</a>
<a name="ln1970">      QString tagName = &quot;wavy-line type=\&quot;start\&quot;&quot;;</a>
<a name="ln1971">      tagName += QString(&quot; number=\&quot;%1\&quot;&quot;).arg(number + 1);</a>
<a name="ln1972">      tagName += color2xml(tr);</a>
<a name="ln1973">      tagName += positioningAttributes(tr, true);</a>
<a name="ln1974">      xml.tagE(tagName);</a>
<a name="ln1975">      }</a>
<a name="ln1976"> </a>
<a name="ln1977">//---------------------------------------------------------</a>
<a name="ln1978">//   wavyLineStop</a>
<a name="ln1979">//---------------------------------------------------------</a>
<a name="ln1980"> </a>
<a name="ln1981">static void wavyLineStop(const Trill* tr, const int number, Notations&amp; notations, Ornaments&amp; ornaments, XmlWriter&amp; xml)</a>
<a name="ln1982">      {</a>
<a name="ln1983">      notations.tag(xml);</a>
<a name="ln1984">      ornaments.tag(xml);</a>
<a name="ln1985">      QString trillXml = QString(&quot;wavy-line type=\&quot;stop\&quot; number=\&quot;%1\&quot;&quot;).arg(number + 1);</a>
<a name="ln1986">      trillXml += positioningAttributes(tr, false);</a>
<a name="ln1987">      xml.tagE(trillXml);</a>
<a name="ln1988">      }</a>
<a name="ln1989"> </a>
<a name="ln1990">//---------------------------------------------------------</a>
<a name="ln1991">//   wavyLineStartStop</a>
<a name="ln1992">//---------------------------------------------------------</a>
<a name="ln1993"> </a>
<a name="ln1994">void ExportMusicXml::wavyLineStartStop(const ChordRest* const cr, Notations&amp; notations, Ornaments&amp; ornaments,</a>
<a name="ln1995">                                       TrillHash&amp; trillStart, TrillHash&amp; trillStop)</a>
<a name="ln1996">      {</a>
<a name="ln1997">      if (trillStart.contains(cr) &amp;&amp; trillStop.contains(cr)) {</a>
<a name="ln1998">            const auto tr = trillStart.value(cr);</a>
<a name="ln1999">            auto n = findTrill(0);</a>
<a name="ln2000">            if (n &gt;= 0) {</a>
<a name="ln2001">                  wavyLineStart(tr, n, notations, ornaments, _xml);</a>
<a name="ln2002">                  wavyLineStop(tr, n, notations, ornaments, _xml);</a>
<a name="ln2003">                  }</a>
<a name="ln2004">            else</a>
<a name="ln2005">                  qDebug(&quot;too many overlapping trills (cr %p staff %d tick %d)&quot;,</a>
<a name="ln2006">                         cr, cr-&gt;staffIdx(), cr-&gt;tick().ticks());</a>
<a name="ln2007">            }</a>
<a name="ln2008">      else {</a>
<a name="ln2009">            if (trillStop.contains(cr)) {</a>
<a name="ln2010">                  const auto tr = trillStop.value(cr);</a>
<a name="ln2011">                  auto n = findTrill(tr);</a>
<a name="ln2012">                  if (n &gt;= 0)</a>
<a name="ln2013">                        // trill stop after trill start</a>
<a name="ln2014">                        trills[n] = 0;</a>
<a name="ln2015">                  else {</a>
<a name="ln2016">                        // trill stop before trill start</a>
<a name="ln2017">                        n = findTrill(0);</a>
<a name="ln2018">                        if (n &gt;= 0)</a>
<a name="ln2019">                              trills[n] = tr;</a>
<a name="ln2020">                        else</a>
<a name="ln2021">                              qDebug(&quot;too many overlapping trills (cr %p staff %d tick %d)&quot;,</a>
<a name="ln2022">                                     cr, cr-&gt;staffIdx(), cr-&gt;tick().ticks());</a>
<a name="ln2023">                        }</a>
<a name="ln2024">                  if (n &gt;= 0) {</a>
<a name="ln2025">                        wavyLineStop(tr, n, notations, ornaments, _xml);</a>
<a name="ln2026">                        }</a>
<a name="ln2027">                  trillStop.remove(cr);</a>
<a name="ln2028">                  }</a>
<a name="ln2029">            if (trillStart.contains(cr)) {</a>
<a name="ln2030">                  const auto tr = trillStart.value(cr);</a>
<a name="ln2031">                  auto n = findTrill(tr);</a>
<a name="ln2032">                  if (n &gt;= 0)</a>
<a name="ln2033">                        qDebug(&quot;wavyLineStartStop error&quot;);</a>
<a name="ln2034">                  else {</a>
<a name="ln2035">                        n = findTrill(0);</a>
<a name="ln2036">                        if (n &gt;= 0) {</a>
<a name="ln2037">                              trills[n] = tr;</a>
<a name="ln2038">                              wavyLineStart(tr, n, notations, ornaments, _xml);</a>
<a name="ln2039">                              }</a>
<a name="ln2040">                        else</a>
<a name="ln2041">                              qDebug(&quot;too many overlapping trills (cr %p staff %d tick %d)&quot;,</a>
<a name="ln2042">                                     cr, cr-&gt;staffIdx(), cr-&gt;tick().ticks());</a>
<a name="ln2043">                        trillStart.remove(cr);</a>
<a name="ln2044">                        }</a>
<a name="ln2045">                  }</a>
<a name="ln2046">            }</a>
<a name="ln2047">      }</a>
<a name="ln2048"> </a>
<a name="ln2049">//---------------------------------------------------------</a>
<a name="ln2050">//   hasBreathMark - determine if chord has breath-mark</a>
<a name="ln2051">//---------------------------------------------------------</a>
<a name="ln2052"> </a>
<a name="ln2053">static Breath* hasBreathMark(Chord* ch)</a>
<a name="ln2054">      {</a>
<a name="ln2055">      Fraction tick = ch-&gt;tick() + ch-&gt;actualTicks();</a>
<a name="ln2056">      Segment* s = ch-&gt;measure()-&gt;findSegment(SegmentType::Breath, tick);</a>
<a name="ln2057">      return s ? toBreath(s-&gt;element(ch-&gt;track())) : 0;</a>
<a name="ln2058">      }</a>
<a name="ln2059"> </a>
<a name="ln2060">//---------------------------------------------------------</a>
<a name="ln2061">//   tremoloSingleStartStop</a>
<a name="ln2062">//---------------------------------------------------------</a>
<a name="ln2063"> </a>
<a name="ln2064">static void tremoloSingleStartStop(Chord* chord, Notations&amp; notations, Ornaments&amp; ornaments, XmlWriter&amp; xml)</a>
<a name="ln2065">      {</a>
<a name="ln2066">      if (chord-&gt;tremolo()) {</a>
<a name="ln2067">            Tremolo* tr = chord-&gt;tremolo();</a>
<a name="ln2068">            int count = 0;</a>
<a name="ln2069">            TremoloType st = tr-&gt;tremoloType();</a>
<a name="ln2070">            QString type = &quot;&quot;;</a>
<a name="ln2071"> </a>
<a name="ln2072">            if (chord-&gt;tremoloChordType() == TremoloChordType::TremoloSingle) {</a>
<a name="ln2073">                  type = &quot;single&quot;;</a>
<a name="ln2074">                  switch (st) {</a>
<a name="ln2075">                        case TremoloType::R8:  count = 1; break;</a>
<a name="ln2076">                        case TremoloType::R16: count = 2; break;</a>
<a name="ln2077">                        case TremoloType::R32: count = 3; break;</a>
<a name="ln2078">                        case TremoloType::R64: count = 4; break;</a>
<a name="ln2079">                        default: qDebug(&quot;unknown tremolo single %d&quot;, int(st)); break;</a>
<a name="ln2080">                        }</a>
<a name="ln2081">                  }</a>
<a name="ln2082">            else if (chord-&gt;tremoloChordType() == TremoloChordType::TremoloFirstNote) {</a>
<a name="ln2083">                  type = &quot;start&quot;;</a>
<a name="ln2084">                  switch (st) {</a>
<a name="ln2085">                        case TremoloType::C8:  count = 1; break;</a>
<a name="ln2086">                        case TremoloType::C16: count = 2; break;</a>
<a name="ln2087">                        case TremoloType::C32: count = 3; break;</a>
<a name="ln2088">                        case TremoloType::C64: count = 4; break;</a>
<a name="ln2089">                        default: qDebug(&quot;unknown tremolo double %d&quot;, int(st)); break;</a>
<a name="ln2090">                        }</a>
<a name="ln2091">                  }</a>
<a name="ln2092">            else if (chord-&gt;tremoloChordType() == TremoloChordType::TremoloSecondNote) {</a>
<a name="ln2093">                  type = &quot;stop&quot;;</a>
<a name="ln2094">                  switch (st) {</a>
<a name="ln2095">                        case TremoloType::C8:  count = 1; break;</a>
<a name="ln2096">                        case TremoloType::C16: count = 2; break;</a>
<a name="ln2097">                        case TremoloType::C32: count = 3; break;</a>
<a name="ln2098">                        case TremoloType::C64: count = 4; break;</a>
<a name="ln2099">                        default: qDebug(&quot;unknown tremolo double %d&quot;, int(st)); break;</a>
<a name="ln2100">                        }</a>
<a name="ln2101">                  }</a>
<a name="ln2102">            else qDebug(&quot;unknown tremolo subtype %d&quot;, int(st));</a>
<a name="ln2103"> </a>
<a name="ln2104"> </a>
<a name="ln2105">            if (type != &quot;&quot; &amp;&amp; count &gt; 0) {</a>
<a name="ln2106">                  notations.tag(xml);</a>
<a name="ln2107">                  ornaments.tag(xml);</a>
<a name="ln2108">                  QString tagName = &quot;tremolo&quot;;</a>
<a name="ln2109">                  tagName += QString(&quot; type=\&quot;%1\&quot;&quot;).arg(type);</a>
<a name="ln2110">                  if (type == &quot;single&quot; || type == &quot;start&quot;)</a>
<a name="ln2111">                        tagName += color2xml(tr);</a>
<a name="ln2112">                  xml.tag(tagName, count);</a>
<a name="ln2113">                  }</a>
<a name="ln2114">            }</a>
<a name="ln2115">      }</a>
<a name="ln2116"> </a>
<a name="ln2117"> </a>
<a name="ln2118">//---------------------------------------------------------</a>
<a name="ln2119">//   fermatas</a>
<a name="ln2120">//---------------------------------------------------------</a>
<a name="ln2121"> </a>
<a name="ln2122">static void fermatas(const QVector&lt;Element*&gt;&amp; cra, XmlWriter&amp; xml, Notations&amp; notations)</a>
<a name="ln2123">      {</a>
<a name="ln2124">      for (const Element* e : cra) {</a>
<a name="ln2125">            if (!e-&gt;isFermata())</a>
<a name="ln2126">                  continue;</a>
<a name="ln2127">            const Fermata* a = toFermata(e);</a>
<a name="ln2128">            notations.tag(xml);</a>
<a name="ln2129">            QString tagName = &quot;fermata&quot;;</a>
<a name="ln2130">            tagName += QString(&quot; type=\&quot;%1\&quot;&quot;).arg(a-&gt;placement() == Placement::ABOVE ? &quot;upright&quot; : &quot;inverted&quot;);</a>
<a name="ln2131">            tagName += color2xml(a);</a>
<a name="ln2132">            SymId id = a-&gt;symId();</a>
<a name="ln2133">            if (id == SymId::fermataAbove || id == SymId::fermataBelow)</a>
<a name="ln2134">                  xml.tagE(tagName);</a>
<a name="ln2135">            // MusicXML does not support the very short fermata nor short fermata (Henze),</a>
<a name="ln2136">            // export as short fermata (better than not exporting at all)</a>
<a name="ln2137">            else if (id == SymId::fermataShortAbove || id == SymId::fermataShortBelow</a>
<a name="ln2138">                     || id == SymId::fermataShortHenzeAbove || id == SymId::fermataShortHenzeBelow</a>
<a name="ln2139">                     || id == SymId::fermataVeryShortAbove || id == SymId::fermataVeryShortBelow)</a>
<a name="ln2140">                  xml.tag(tagName, &quot;angled&quot;);</a>
<a name="ln2141">            // MusicXML does not support the very long fermata  nor long fermata (Henze),</a>
<a name="ln2142">            // export as long fermata (better than not exporting at all)</a>
<a name="ln2143">            else if (id == SymId::fermataLongAbove || id == SymId::fermataLongBelow</a>
<a name="ln2144">                     || id == SymId::fermataLongHenzeAbove || id == SymId::fermataLongHenzeBelow</a>
<a name="ln2145">                     || id == SymId::fermataVeryLongAbove || id == SymId::fermataVeryLongBelow)</a>
<a name="ln2146">                  xml.tag(tagName, &quot;square&quot;);</a>
<a name="ln2147">            }</a>
<a name="ln2148">      }</a>
<a name="ln2149"> </a>
<a name="ln2150">//---------------------------------------------------------</a>
<a name="ln2151">//   symIdToArtic</a>
<a name="ln2152">//---------------------------------------------------------</a>
<a name="ln2153"> </a>
<a name="ln2154">static QString symIdToArtic(const SymId sid)</a>
<a name="ln2155">      {</a>
<a name="ln2156">      switch (sid) {</a>
<a name="ln2157">            case SymId::articAccentAbove:</a>
<a name="ln2158">            case SymId::articAccentBelow:</a>
<a name="ln2159">                  return &quot;accent&quot;;</a>
<a name="ln2160">                  break;</a>
<a name="ln2161"> </a>
<a name="ln2162">            case SymId::articStaccatoAbove:</a>
<a name="ln2163">            case SymId::articStaccatoBelow:</a>
<a name="ln2164">            case SymId::articAccentStaccatoAbove:</a>
<a name="ln2165">            case SymId::articAccentStaccatoBelow:</a>
<a name="ln2166">            case SymId::articMarcatoStaccatoAbove:</a>
<a name="ln2167">            case SymId::articMarcatoStaccatoBelow:</a>
<a name="ln2168">                  return &quot;staccato&quot;;</a>
<a name="ln2169">                  break;</a>
<a name="ln2170"> </a>
<a name="ln2171">            case SymId::articStaccatissimoAbove:</a>
<a name="ln2172">            case SymId::articStaccatissimoBelow:</a>
<a name="ln2173">            case SymId::articStaccatissimoStrokeAbove:</a>
<a name="ln2174">            case SymId::articStaccatissimoStrokeBelow:</a>
<a name="ln2175">            case SymId::articStaccatissimoWedgeAbove:</a>
<a name="ln2176">            case SymId::articStaccatissimoWedgeBelow:</a>
<a name="ln2177">                  return &quot;staccatissimo&quot;;</a>
<a name="ln2178">                  break;</a>
<a name="ln2179"> </a>
<a name="ln2180">            case SymId::articTenutoAbove:</a>
<a name="ln2181">            case SymId::articTenutoBelow:</a>
<a name="ln2182">                  return &quot;tenuto&quot;;</a>
<a name="ln2183">                  break;</a>
<a name="ln2184"> </a>
<a name="ln2185">            case SymId::articMarcatoAbove:</a>
<a name="ln2186">            case SymId::articMarcatoBelow:</a>
<a name="ln2187">                  return &quot;strong-accent&quot;;</a>
<a name="ln2188">                  break;</a>
<a name="ln2189"> </a>
<a name="ln2190">            case SymId::articTenutoStaccatoAbove:</a>
<a name="ln2191">            case SymId::articTenutoStaccatoBelow:</a>
<a name="ln2192">                  return &quot;detached-legato&quot;;</a>
<a name="ln2193">                  break;</a>
<a name="ln2194"> </a>
<a name="ln2195">            default:</a>
<a name="ln2196">                  ;       // nothing</a>
<a name="ln2197">                  break;</a>
<a name="ln2198">            }</a>
<a name="ln2199"> </a>
<a name="ln2200">      return &quot;&quot;;</a>
<a name="ln2201">      }</a>
<a name="ln2202"> </a>
<a name="ln2203">//---------------------------------------------------------</a>
<a name="ln2204">//   symIdToOrnam</a>
<a name="ln2205">//---------------------------------------------------------</a>
<a name="ln2206"> </a>
<a name="ln2207">static QString symIdToOrnam(const SymId sid)</a>
<a name="ln2208">      {</a>
<a name="ln2209">      switch (sid) {</a>
<a name="ln2210">            case SymId::ornamentTurnInverted:</a>
<a name="ln2211">                  return &quot;inverted-turn&quot;;</a>
<a name="ln2212">                  break;</a>
<a name="ln2213">            case SymId::ornamentTurn:</a>
<a name="ln2214">                  return &quot;turn&quot;;</a>
<a name="ln2215">                  break;</a>
<a name="ln2216">            case SymId::ornamentTrill:</a>
<a name="ln2217">                  return &quot;trill-mark&quot;;</a>
<a name="ln2218">                  break;</a>
<a name="ln2219">            case SymId::ornamentMordentInverted:</a>
<a name="ln2220">                  return &quot;mordent&quot;;</a>
<a name="ln2221">                  // return &quot;inverted-mordent&quot;;</a>
<a name="ln2222">                  break;</a>
<a name="ln2223">            case SymId::ornamentMordent:</a>
<a name="ln2224">                  // return &quot;mordent&quot;;</a>
<a name="ln2225">                  return &quot;inverted-mordent&quot;;</a>
<a name="ln2226">                  break;</a>
<a name="ln2227">            case SymId::ornamentTremblement:</a>
<a name="ln2228">                  return &quot;inverted-mordent long=\&quot;yes\&quot;&quot;;</a>
<a name="ln2229">                  break;</a>
<a name="ln2230">            case SymId::ornamentPrallMordent:</a>
<a name="ln2231">                  return &quot;mordent long=\&quot;yes\&quot;&quot;;</a>
<a name="ln2232">                  break;</a>
<a name="ln2233">            case SymId::ornamentUpPrall:</a>
<a name="ln2234">                  return &quot;inverted-mordent long=\&quot;yes\&quot; approach=\&quot;below\&quot;&quot;;</a>
<a name="ln2235">                  break;</a>
<a name="ln2236">            case SymId::ornamentPrecompMordentUpperPrefix:</a>
<a name="ln2237">                  return &quot;inverted-mordent long=\&quot;yes\&quot; approach=\&quot;above\&quot;&quot;;</a>
<a name="ln2238">                  break;</a>
<a name="ln2239">            case SymId::ornamentUpMordent:</a>
<a name="ln2240">                  return &quot;mordent long=\&quot;yes\&quot; approach=\&quot;below\&quot;&quot;;</a>
<a name="ln2241">                  break;</a>
<a name="ln2242">            case SymId::ornamentDownMordent:</a>
<a name="ln2243">                  return &quot;mordent long=\&quot;yes\&quot; approach=\&quot;above\&quot;&quot;;</a>
<a name="ln2244">                  break;</a>
<a name="ln2245">            case SymId::ornamentPrallDown:</a>
<a name="ln2246">                  return &quot;inverted-mordent long=\&quot;yes\&quot; departure=\&quot;below\&quot;&quot;;</a>
<a name="ln2247">                  break;</a>
<a name="ln2248">            case SymId::ornamentPrallUp:</a>
<a name="ln2249">                  return &quot;inverted-mordent long=\&quot;yes\&quot; departure=\&quot;above\&quot;&quot;;</a>
<a name="ln2250">                  break;</a>
<a name="ln2251">            case SymId::ornamentLinePrall:</a>
<a name="ln2252">                  // MusicXML 3.0 does not distinguish between downprall and lineprall</a>
<a name="ln2253">                  return &quot;inverted-mordent long=\&quot;yes\&quot; approach=\&quot;above\&quot;&quot;;</a>
<a name="ln2254">                  break;</a>
<a name="ln2255">            case SymId::ornamentPrecompSlide:</a>
<a name="ln2256">                  return &quot;schleifer&quot;;</a>
<a name="ln2257">                  break;</a>
<a name="ln2258"> </a>
<a name="ln2259">            default:</a>
<a name="ln2260">                  ; // nothing</a>
<a name="ln2261">                  break;</a>
<a name="ln2262">            }</a>
<a name="ln2263"> </a>
<a name="ln2264">      return &quot;&quot;;</a>
<a name="ln2265">      }</a>
<a name="ln2266"> </a>
<a name="ln2267">//---------------------------------------------------------</a>
<a name="ln2268">//   symIdToTechn</a>
<a name="ln2269">//---------------------------------------------------------</a>
<a name="ln2270"> </a>
<a name="ln2271">static QString symIdToTechn(const SymId sid)</a>
<a name="ln2272">      {</a>
<a name="ln2273">      switch (sid) {</a>
<a name="ln2274">            case SymId::brassMuteClosed:</a>
<a name="ln2275">                  return &quot;stopped&quot;;</a>
<a name="ln2276">                  break;</a>
<a name="ln2277">            case SymId::stringsHarmonic:</a>
<a name="ln2278">                  return &quot;x&quot;; // will be overruled but must be non-empty</a>
<a name="ln2279">                  break;</a>
<a name="ln2280">            case SymId::stringsUpBow:</a>
<a name="ln2281">                  return &quot;up-bow&quot;;</a>
<a name="ln2282">                  break;</a>
<a name="ln2283">            case SymId::stringsDownBow:</a>
<a name="ln2284">                  return &quot;down-bow&quot;;</a>
<a name="ln2285">                  break;</a>
<a name="ln2286">            case SymId::pluckedSnapPizzicatoAbove:</a>
<a name="ln2287">                  return &quot;snap-pizzicato&quot;;</a>
<a name="ln2288">                  break;</a>
<a name="ln2289">            case SymId::brassMuteOpen:</a>
<a name="ln2290">                  return &quot;open-string&quot;;</a>
<a name="ln2291">                  break;</a>
<a name="ln2292">            case SymId::stringsThumbPosition:</a>
<a name="ln2293">                  return &quot;thumb-position&quot;;</a>
<a name="ln2294">                  break;</a>
<a name="ln2295">            default:</a>
<a name="ln2296">                  ; // nothing</a>
<a name="ln2297">                  break;</a>
<a name="ln2298">            }</a>
<a name="ln2299"> </a>
<a name="ln2300">      return &quot;&quot;;</a>
<a name="ln2301">      }</a>
<a name="ln2302"> </a>
<a name="ln2303">//---------------------------------------------------------</a>
<a name="ln2304">//   writeChordLines</a>
<a name="ln2305">//---------------------------------------------------------</a>
<a name="ln2306"> </a>
<a name="ln2307">static void writeChordLines(const Chord* const chord, XmlWriter&amp; xml, Notations&amp; notations, Articulations&amp; articulations)</a>
<a name="ln2308">      {</a>
<a name="ln2309">      for (Element* e : chord-&gt;el()) {</a>
<a name="ln2310">            qDebug(&quot;writeChordLines: el %p type %d (%s)&quot;, e, int(e-&gt;type()), e-&gt;name());</a>
<a name="ln2311">            if (e-&gt;type() == ElementType::CHORDLINE) {</a>
<a name="ln2312">                  ChordLine const* const cl = static_cast&lt;ChordLine*&gt;(e);</a>
<a name="ln2313">                  QString subtype;</a>
<a name="ln2314">                  switch (cl-&gt;chordLineType()) {</a>
<a name="ln2315">                        case ChordLineType::FALL:</a>
<a name="ln2316">                              subtype = &quot;falloff&quot;;</a>
<a name="ln2317">                              break;</a>
<a name="ln2318">                        case ChordLineType::DOIT:</a>
<a name="ln2319">                              subtype = &quot;doit&quot;;</a>
<a name="ln2320">                              break;</a>
<a name="ln2321">                        case ChordLineType::PLOP:</a>
<a name="ln2322">                              subtype = &quot;plop&quot;;</a>
<a name="ln2323">                              break;</a>
<a name="ln2324">                        case ChordLineType::SCOOP:</a>
<a name="ln2325">                              subtype = &quot;scoop&quot;;</a>
<a name="ln2326">                              break;</a>
<a name="ln2327">                        default:</a>
<a name="ln2328">                              qDebug(&quot;unknown ChordLine subtype %d&quot;, int(cl-&gt;chordLineType()));</a>
<a name="ln2329">                        }</a>
<a name="ln2330">                  if (subtype != &quot;&quot;) {</a>
<a name="ln2331">                        notations.tag(xml);</a>
<a name="ln2332">                        articulations.tag(xml);</a>
<a name="ln2333">                        xml.tagE(subtype);</a>
<a name="ln2334">                        }</a>
<a name="ln2335">                  }</a>
<a name="ln2336">            }</a>
<a name="ln2337">      }</a>
<a name="ln2338"> </a>
<a name="ln2339">//---------------------------------------------------------</a>
<a name="ln2340">//   chordAttributes</a>
<a name="ln2341">//---------------------------------------------------------</a>
<a name="ln2342"> </a>
<a name="ln2343">void ExportMusicXml::chordAttributes(Chord* chord, Notations&amp; notations, Technical&amp; technical,</a>
<a name="ln2344">                                     TrillHash&amp; trillStart, TrillHash&amp; trillStop)</a>
<a name="ln2345">      {</a>
<a name="ln2346">      QVector&lt;Element*&gt; fl;</a>
<a name="ln2347">      for (Element* e : chord-&gt;segment()-&gt;annotations()) {</a>
<a name="ln2348">            if (e-&gt;track() == chord-&gt;track() &amp;&amp; e-&gt;isFermata())</a>
<a name="ln2349">                  fl.push_back(e);</a>
<a name="ln2350">            }</a>
<a name="ln2351">      fermatas(fl, _xml, notations);</a>
<a name="ln2352"> </a>
<a name="ln2353">      const QVector&lt;Articulation*&gt; na = chord-&gt;articulations();</a>
<a name="ln2354">      // first the attributes whose elements are children of &lt;articulations&gt;</a>
<a name="ln2355">      Articulations articulations;</a>
<a name="ln2356">      for (const Articulation* a : na) {</a>
<a name="ln2357">            auto sid = a-&gt;symId();</a>
<a name="ln2358">            auto mxmlArtic = symIdToArtic(sid);</a>
<a name="ln2359"> </a>
<a name="ln2360">            if (mxmlArtic != &quot;&quot;) {</a>
<a name="ln2361">                  if (sid == SymId::articMarcatoAbove || sid == SymId::articMarcatoBelow) {</a>
<a name="ln2362">                        if (a-&gt;up())</a>
<a name="ln2363">                              mxmlArtic += &quot; type=\&quot;up\&quot;&quot;;</a>
<a name="ln2364">                        else</a>
<a name="ln2365">                              mxmlArtic += &quot; type=\&quot;down\&quot;&quot;;</a>
<a name="ln2366">                        }</a>
<a name="ln2367"> </a>
<a name="ln2368">                  notations.tag(_xml);</a>
<a name="ln2369">                  articulations.tag(_xml);</a>
<a name="ln2370">                  _xml.tagE(mxmlArtic);</a>
<a name="ln2371">                  }</a>
<a name="ln2372">            }</a>
<a name="ln2373"> </a>
<a name="ln2374">      if (Breath* b = hasBreathMark(chord)) {</a>
<a name="ln2375">            notations.tag(_xml);</a>
<a name="ln2376">            articulations.tag(_xml);</a>
<a name="ln2377">            _xml.tagE(b-&gt;isCaesura() ? &quot;caesura&quot; : &quot;breath-mark&quot;);</a>
<a name="ln2378">            }</a>
<a name="ln2379"> </a>
<a name="ln2380">      writeChordLines(chord, _xml, notations, articulations);</a>
<a name="ln2381"> </a>
<a name="ln2382">      articulations.etag(_xml);</a>
<a name="ln2383"> </a>
<a name="ln2384">      // then the attributes whose elements are children of &lt;ornaments&gt;</a>
<a name="ln2385">      Ornaments ornaments;</a>
<a name="ln2386">      for (const Articulation* a : na) {</a>
<a name="ln2387">            auto sid = a-&gt;symId();</a>
<a name="ln2388">            auto mxmlOrnam = symIdToOrnam(sid);</a>
<a name="ln2389"> </a>
<a name="ln2390">            if (mxmlOrnam != &quot;&quot;) {</a>
<a name="ln2391">                  notations.tag(_xml);</a>
<a name="ln2392">                  ornaments.tag(_xml);</a>
<a name="ln2393">                  _xml.tagE(mxmlOrnam);</a>
<a name="ln2394">                  }</a>
<a name="ln2395">            }</a>
<a name="ln2396"> </a>
<a name="ln2397">      tremoloSingleStartStop(chord, notations, ornaments, _xml);</a>
<a name="ln2398">      wavyLineStartStop(chord, notations, ornaments, trillStart, trillStop);</a>
<a name="ln2399">      ornaments.etag(_xml);</a>
<a name="ln2400"> </a>
<a name="ln2401">      // and finally the attributes whose elements are children of &lt;technical&gt;</a>
<a name="ln2402">      for (const Articulation* a : na) {</a>
<a name="ln2403">            auto sid = a-&gt;symId();</a>
<a name="ln2404"> </a>
<a name="ln2405">            if (sid == SymId::stringsHarmonic) {</a>
<a name="ln2406">                  notations.tag(_xml);</a>
<a name="ln2407">                  technical.tag(_xml);</a>
<a name="ln2408">                  _xml.stag(&quot;harmonic&quot;);</a>
<a name="ln2409">                  _xml.tagE(&quot;natural&quot;);</a>
<a name="ln2410">                  _xml.etag();</a>
<a name="ln2411">                  }</a>
<a name="ln2412">            else {</a>
<a name="ln2413">                  auto mxmlTechn = symIdToTechn(sid);</a>
<a name="ln2414">                  if (mxmlTechn != &quot;&quot;) {</a>
<a name="ln2415">                        notations.tag(_xml);</a>
<a name="ln2416">                        technical.tag(_xml);</a>
<a name="ln2417">                        _xml.tagE(mxmlTechn);</a>
<a name="ln2418">                        }</a>
<a name="ln2419">                  }</a>
<a name="ln2420">            }</a>
<a name="ln2421"> </a>
<a name="ln2422">      // check if all articulations were handled</a>
<a name="ln2423">      for (const Articulation* a : na) {</a>
<a name="ln2424">            auto sid = a-&gt;symId();</a>
<a name="ln2425">            if (symIdToArtic(sid) == &quot;&quot;</a>
<a name="ln2426">                &amp;&amp; symIdToOrnam(sid) == &quot;&quot;</a>
<a name="ln2427">                &amp;&amp; symIdToTechn(sid) == &quot;&quot;) {</a>
<a name="ln2428">                  qDebug(&quot;unknown chord attribute %s&quot;, qPrintable(a-&gt;userName()));</a>
<a name="ln2429">                  }</a>
<a name="ln2430">            }</a>
<a name="ln2431">      }</a>
<a name="ln2432"> </a>
<a name="ln2433">//---------------------------------------------------------</a>
<a name="ln2434">//   arpeggiate</a>
<a name="ln2435">//---------------------------------------------------------</a>
<a name="ln2436"> </a>
<a name="ln2437">// &lt;notations&gt;</a>
<a name="ln2438">//   &lt;arpeggiate direction=&quot;up&quot;/&gt;</a>
<a name="ln2439">//   &lt;/notations&gt;</a>
<a name="ln2440"> </a>
<a name="ln2441">static void arpeggiate(Arpeggio* arp, bool front, bool back, XmlWriter&amp; xml, Notations&amp; notations)</a>
<a name="ln2442">      {</a>
<a name="ln2443">      QString tagName;</a>
<a name="ln2444">      switch (arp-&gt;arpeggioType()) {</a>
<a name="ln2445">            case ArpeggioType::NORMAL:</a>
<a name="ln2446">                  notations.tag(xml);</a>
<a name="ln2447">                  tagName = &quot;arpeggiate&quot;;</a>
<a name="ln2448">                  break;</a>
<a name="ln2449">            case ArpeggioType::UP:          // fall through</a>
<a name="ln2450">            case ArpeggioType::UP_STRAIGHT: // not supported by MusicXML, export as normal arpeggio</a>
<a name="ln2451">                  notations.tag(xml);</a>
<a name="ln2452">                  tagName = &quot;arpeggiate direction=\&quot;up\&quot;&quot;;</a>
<a name="ln2453">                  break;</a>
<a name="ln2454">            case ArpeggioType::DOWN:          // fall through</a>
<a name="ln2455">            case ArpeggioType::DOWN_STRAIGHT: // not supported by MusicXML, export as normal arpeggio</a>
<a name="ln2456">                  notations.tag(xml);</a>
<a name="ln2457">                  tagName = &quot;arpeggiate direction=\&quot;down\&quot;&quot;;</a>
<a name="ln2458">                  break;</a>
<a name="ln2459">            case ArpeggioType::BRACKET:</a>
<a name="ln2460">                  if (front) {</a>
<a name="ln2461">                        notations.tag(xml);</a>
<a name="ln2462">                        tagName = &quot;non-arpeggiate type=\&quot;bottom\&quot;&quot;;</a>
<a name="ln2463">                        }</a>
<a name="ln2464">                  if (back) {</a>
<a name="ln2465">                        notations.tag(xml);</a>
<a name="ln2466">                        tagName = &quot;non-arpeggiate type=\&quot;top\&quot;&quot;;</a>
<a name="ln2467">                        }</a>
<a name="ln2468">                  break;</a>
<a name="ln2469">            default:</a>
<a name="ln2470">                  qDebug(&quot;unknown arpeggio subtype %d&quot;, int(arp-&gt;arpeggioType()));</a>
<a name="ln2471">                  break;</a>
<a name="ln2472">            }</a>
<a name="ln2473"> </a>
<a name="ln2474">      if (tagName != &quot;&quot;) {</a>
<a name="ln2475">            tagName += positioningAttributes(arp);</a>
<a name="ln2476">            xml.tagE(tagName);</a>
<a name="ln2477">            }</a>
<a name="ln2478">      }</a>
<a name="ln2479"> </a>
<a name="ln2480">//---------------------------------------------------------</a>
<a name="ln2481">//   determineTupletNormalTicks</a>
<a name="ln2482">//---------------------------------------------------------</a>
<a name="ln2483"> </a>
<a name="ln2484">/**</a>
<a name="ln2485"> Determine the ticks in the normal type for the tuplet \a chord.</a>
<a name="ln2486"> This is non-zero only if chord if part of a tuplet containing</a>
<a name="ln2487"> different length duration elements.</a>
<a name="ln2488"> TODO determine how to handle baselen with dots and verify correct behaviour.</a>
<a name="ln2489"> TODO verify if baseLen should always be correctly set</a>
<a name="ln2490">      (it seems after MusicXMLimport this is not the case)</a>
<a name="ln2491"> */</a>
<a name="ln2492"> </a>
<a name="ln2493">static int determineTupletNormalTicks(ChordRest const* const chord)</a>
<a name="ln2494">      {</a>
<a name="ln2495">      Tuplet const* const t = chord-&gt;tuplet();</a>
<a name="ln2496">      if (!t)</a>
<a name="ln2497">            return 0;</a>
<a name="ln2498">      /*</a>
<a name="ln2499">      qDebug(&quot;determineTupletNormalTicks t %p baselen %s&quot;, t, qPrintable(t-&gt;baseLen().ticks().print()));</a>
<a name="ln2500">      for (int i = 0; i &lt; t-&gt;elements().size(); ++i)</a>
<a name="ln2501">            qDebug(&quot;determineTupletNormalTicks t %p i %d ticks %s&quot;, t, i, qPrintable(t-&gt;elements().at(i)-&gt;ticks().print()));</a>
<a name="ln2502">            */</a>
<a name="ln2503">      for (unsigned int i = 1; i &lt; t-&gt;elements().size(); ++i)</a>
<a name="ln2504">            if (t-&gt;elements().at(0)-&gt;ticks() != t-&gt;elements().at(i)-&gt;ticks())</a>
<a name="ln2505">                  return t-&gt;baseLen().ticks().ticks();</a>
<a name="ln2506">      if (t-&gt;elements().size() != (unsigned)(t-&gt;ratio().numerator()))</a>
<a name="ln2507">            return t-&gt;baseLen().ticks().ticks();</a>
<a name="ln2508">      return 0;</a>
<a name="ln2509">      }</a>
<a name="ln2510"> </a>
<a name="ln2511">//---------------------------------------------------------</a>
<a name="ln2512">//   beamFanAttribute</a>
<a name="ln2513">//---------------------------------------------------------</a>
<a name="ln2514"> </a>
<a name="ln2515">static QString beamFanAttribute(const Beam* const b)</a>
<a name="ln2516">      {</a>
<a name="ln2517">      const qreal epsilon = 0.1;</a>
<a name="ln2518"> </a>
<a name="ln2519">      QString fan;</a>
<a name="ln2520">      if ((b-&gt;growRight() - b-&gt;growLeft() &gt; epsilon))</a>
<a name="ln2521">            fan = &quot;accel&quot;;</a>
<a name="ln2522"> </a>
<a name="ln2523">      if ((b-&gt;growLeft() - b-&gt;growRight() &gt; epsilon))</a>
<a name="ln2524">            fan = &quot;rit&quot;;</a>
<a name="ln2525"> </a>
<a name="ln2526">      if (fan != &quot;&quot;)</a>
<a name="ln2527">            return QString(&quot; fan=\&quot;%1\&quot;&quot;).arg(fan);</a>
<a name="ln2528"> </a>
<a name="ln2529">      return &quot;&quot;;</a>
<a name="ln2530">      }</a>
<a name="ln2531"> </a>
<a name="ln2532">//---------------------------------------------------------</a>
<a name="ln2533">//   writeBeam</a>
<a name="ln2534">//---------------------------------------------------------</a>
<a name="ln2535"> </a>
<a name="ln2536">//  beaming</a>
<a name="ln2537">//    &lt;beam number=&quot;1&quot;&gt;start&lt;/beam&gt;</a>
<a name="ln2538">//    &lt;beam number=&quot;1&quot;&gt;end&lt;/beam&gt;</a>
<a name="ln2539">//    &lt;beam number=&quot;1&quot;&gt;continue&lt;/beam&gt;</a>
<a name="ln2540">//    &lt;beam number=&quot;1&quot;&gt;backward hook&lt;/beam&gt;</a>
<a name="ln2541">//    &lt;beam number=&quot;1&quot;&gt;forward hook&lt;/beam&gt;</a>
<a name="ln2542"> </a>
<a name="ln2543">static void writeBeam(XmlWriter&amp; xml, ChordRest* const cr, Beam* const b)</a>
<a name="ln2544">      {</a>
<a name="ln2545">      const auto&amp; elements = b-&gt;elements();</a>
<a name="ln2546">      const int idx = elements.indexOf(cr);</a>
<a name="ln2547">      if (idx == -1) {</a>
<a name="ln2548">            qDebug(&quot;Beam::writeMusicXml(): cannot find ChordRest&quot;);</a>
<a name="ln2549">            return;</a>
<a name="ln2550">            }</a>
<a name="ln2551">      int blp = -1; // beam level previous chord</a>
<a name="ln2552">      int blc = -1; // beam level current chord</a>
<a name="ln2553">      int bln = -1; // beam level next chord</a>
<a name="ln2554">      // find beam level previous chord</a>
<a name="ln2555">      for (int i = idx - 1; blp == -1 &amp;&amp; i &gt;= 0; --i) {</a>
<a name="ln2556">            const auto crst = elements[i];</a>
<a name="ln2557">            if (crst-&gt;isChord())</a>
<a name="ln2558">                  blp = toChord(crst)-&gt;beams();</a>
<a name="ln2559">            }</a>
<a name="ln2560">      // find beam level current chord</a>
<a name="ln2561">      if (cr-&gt;isChord())</a>
<a name="ln2562">            blc = toChord(cr)-&gt;beams();</a>
<a name="ln2563">      // find beam level next chord</a>
<a name="ln2564">      for (int i = idx + 1; bln == -1 &amp;&amp; i &lt; elements.size(); ++i) {</a>
<a name="ln2565">            const auto crst = elements[i];</a>
<a name="ln2566">            if (crst-&gt;isChord())</a>
<a name="ln2567">                  bln = toChord(crst)-&gt;beams();</a>
<a name="ln2568">            }</a>
<a name="ln2569">      // find beam type and write</a>
<a name="ln2570">      for (int i = 1; i &lt;= blc; ++i) {</a>
<a name="ln2571">            QString text;</a>
<a name="ln2572">            if (blp &lt; i &amp;&amp; bln &gt;= i) text = &quot;begin&quot;;</a>
<a name="ln2573">            else if (blp &lt; i &amp;&amp; bln &lt; i) {</a>
<a name="ln2574">                  if (bln &gt; 0) text = &quot;forward hook&quot;;</a>
<a name="ln2575">                  else if (blp &gt; 0) text = &quot;backward hook&quot;;</a>
<a name="ln2576">                  }</a>
<a name="ln2577">            else if (blp &gt;= i &amp;&amp; bln &lt; i)</a>
<a name="ln2578">                  text = &quot;end&quot;;</a>
<a name="ln2579">            else if (blp &gt;= i &amp;&amp; bln &gt;= i)</a>
<a name="ln2580">                  text = &quot;continue&quot;;</a>
<a name="ln2581">            if (text != &quot;&quot;) {</a>
<a name="ln2582">                  QString tag = &quot;beam&quot;;</a>
<a name="ln2583">                  tag += QString(&quot; number=\&quot;%1\&quot;&quot;).arg(i);</a>
<a name="ln2584">                  if (text == &quot;begin&quot;)</a>
<a name="ln2585">                        tag += beamFanAttribute(b);</a>
<a name="ln2586">                  xml.tag(tag, text);</a>
<a name="ln2587">                  }</a>
<a name="ln2588">            }</a>
<a name="ln2589">      }</a>
<a name="ln2590"> </a>
<a name="ln2591">//---------------------------------------------------------</a>
<a name="ln2592">//   instrId</a>
<a name="ln2593">//---------------------------------------------------------</a>
<a name="ln2594"> </a>
<a name="ln2595">static QString instrId(int partNr, int instrNr)</a>
<a name="ln2596">      {</a>
<a name="ln2597">      return QString(&quot;id=\&quot;P%1-I%2\&quot;&quot;).arg(partNr).arg(instrNr);</a>
<a name="ln2598">      }</a>
<a name="ln2599"> </a>
<a name="ln2600">//---------------------------------------------------------</a>
<a name="ln2601">//   writeNotehead</a>
<a name="ln2602">//---------------------------------------------------------</a>
<a name="ln2603"> </a>
<a name="ln2604">static void writeNotehead(XmlWriter&amp; xml, const Note* const note)</a>
<a name="ln2605">      {</a>
<a name="ln2606">      QString noteheadTagname = QString(&quot;notehead&quot;);</a>
<a name="ln2607">      noteheadTagname += color2xml(note);</a>
<a name="ln2608">      bool leftParenthesis = false, rightParenthesis = false;</a>
<a name="ln2609">      for (Element* elem : note-&gt;el()) {</a>
<a name="ln2610">            if (elem-&gt;type() == ElementType::SYMBOL) {</a>
<a name="ln2611">                  Symbol* s = static_cast&lt;Symbol*&gt;(elem);</a>
<a name="ln2612">                  if (s-&gt;sym() == SymId::noteheadParenthesisLeft)</a>
<a name="ln2613">                        leftParenthesis = true;</a>
<a name="ln2614">                  else if (s-&gt;sym() == SymId::noteheadParenthesisRight)</a>
<a name="ln2615">                        rightParenthesis = true;</a>
<a name="ln2616">                  }</a>
<a name="ln2617">            }</a>
<a name="ln2618">      if (rightParenthesis &amp;&amp; leftParenthesis)</a>
<a name="ln2619">            noteheadTagname += &quot; parentheses=\&quot;yes\&quot;&quot;;</a>
<a name="ln2620">      if (note-&gt;headType() == NoteHead::Type::HEAD_QUARTER)</a>
<a name="ln2621">            noteheadTagname += &quot; filled=\&quot;yes\&quot;&quot;;</a>
<a name="ln2622">      else if ((note-&gt;headType() == NoteHead::Type::HEAD_HALF) || (note-&gt;headType() == NoteHead::Type::HEAD_WHOLE))</a>
<a name="ln2623">            noteheadTagname += &quot; filled=\&quot;no\&quot;&quot;;</a>
<a name="ln2624">      if (note-&gt;headGroup() == NoteHead::Group::HEAD_SLASH)</a>
<a name="ln2625">            xml.tag(noteheadTagname, &quot;slash&quot;);</a>
<a name="ln2626">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_TRIANGLE_UP)</a>
<a name="ln2627">            xml.tag(noteheadTagname, &quot;triangle&quot;);</a>
<a name="ln2628">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_DIAMOND)</a>
<a name="ln2629">            xml.tag(noteheadTagname, &quot;diamond&quot;);</a>
<a name="ln2630">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_PLUS)</a>
<a name="ln2631">            xml.tag(noteheadTagname, &quot;cross&quot;);</a>
<a name="ln2632">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_CROSS)</a>
<a name="ln2633">            xml.tag(noteheadTagname, &quot;x&quot;);</a>
<a name="ln2634">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_XCIRCLE)</a>
<a name="ln2635">            xml.tag(noteheadTagname, &quot;circle-x&quot;);</a>
<a name="ln2636">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_TRIANGLE_DOWN)</a>
<a name="ln2637">            xml.tag(noteheadTagname, &quot;inverted triangle&quot;);</a>
<a name="ln2638">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_SLASHED1)</a>
<a name="ln2639">            xml.tag(noteheadTagname, &quot;slashed&quot;);</a>
<a name="ln2640">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_SLASHED2)</a>
<a name="ln2641">            xml.tag(noteheadTagname, &quot;back slashed&quot;);</a>
<a name="ln2642">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_DO)</a>
<a name="ln2643">            xml.tag(noteheadTagname, &quot;do&quot;);</a>
<a name="ln2644">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_RE)</a>
<a name="ln2645">            xml.tag(noteheadTagname, &quot;re&quot;);</a>
<a name="ln2646">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_MI)</a>
<a name="ln2647">            xml.tag(noteheadTagname, &quot;mi&quot;);</a>
<a name="ln2648">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_FA &amp;&amp; !note-&gt;chord()-&gt;up())</a>
<a name="ln2649">            xml.tag(noteheadTagname, &quot;fa&quot;);</a>
<a name="ln2650">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_FA &amp;&amp; note-&gt;chord()-&gt;up())</a>
<a name="ln2651">            xml.tag(noteheadTagname, &quot;fa up&quot;);</a>
<a name="ln2652">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_LA)</a>
<a name="ln2653">            xml.tag(noteheadTagname, &quot;la&quot;);</a>
<a name="ln2654">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_TI)</a>
<a name="ln2655">            xml.tag(noteheadTagname, &quot;ti&quot;);</a>
<a name="ln2656">      else if (note-&gt;headGroup() == NoteHead::Group::HEAD_SOL)</a>
<a name="ln2657">            xml.tag(noteheadTagname, &quot;so&quot;);</a>
<a name="ln2658">      else if (note-&gt;color() != MScore::defaultColor)</a>
<a name="ln2659">            xml.tag(noteheadTagname, &quot;normal&quot;);</a>
<a name="ln2660">      else if (rightParenthesis &amp;&amp; leftParenthesis)</a>
<a name="ln2661">            xml.tag(noteheadTagname, &quot;normal&quot;);</a>
<a name="ln2662">      else if (note-&gt;headType() != NoteHead::Type::HEAD_AUTO)</a>
<a name="ln2663">            xml.tag(noteheadTagname, &quot;normal&quot;);</a>
<a name="ln2664">      }</a>
<a name="ln2665"> </a>
<a name="ln2666">//---------------------------------------------------------</a>
<a name="ln2667">//   writeFingering</a>
<a name="ln2668">//---------------------------------------------------------</a>
<a name="ln2669"> </a>
<a name="ln2670">static void writeFingering(XmlWriter&amp; xml, Notations&amp; notations, Technical&amp; technical, const Note* const note)</a>
<a name="ln2671">      {</a>
<a name="ln2672">      for (const Element* e : note-&gt;el()) {</a>
<a name="ln2673">            if (e-&gt;type() == ElementType::FINGERING) {</a>
<a name="ln2674">                  const TextBase* f = toTextBase(e);</a>
<a name="ln2675">                  notations.tag(xml);</a>
<a name="ln2676">                  technical.tag(xml);</a>
<a name="ln2677">                  QString t = MScoreTextToMXML::toPlainText(f-&gt;xmlText());</a>
<a name="ln2678">                  if (f-&gt;tid() == Tid::RH_GUITAR_FINGERING)</a>
<a name="ln2679">                        xml.tag(&quot;pluck&quot;, t);</a>
<a name="ln2680">                  else if (f-&gt;tid() == Tid::LH_GUITAR_FINGERING)</a>
<a name="ln2681">                        xml.tag(&quot;fingering&quot;, t);</a>
<a name="ln2682">                  else if (f-&gt;tid() == Tid::FINGERING) {</a>
<a name="ln2683">                        // for generic fingering, try to detect plucking</a>
<a name="ln2684">                        // (backwards compatibility with MuseScore 1.x)</a>
<a name="ln2685">                        // p, i, m, a, c represent the plucking finger</a>
<a name="ln2686">                        if (t == &quot;p&quot; || t == &quot;i&quot; || t == &quot;m&quot; || t == &quot;a&quot; || t == &quot;c&quot;)</a>
<a name="ln2687">                              xml.tag(&quot;pluck&quot;, t);</a>
<a name="ln2688">                        else</a>
<a name="ln2689">                              xml.tag(&quot;fingering&quot;, t);</a>
<a name="ln2690">                        }</a>
<a name="ln2691">                  else if (f-&gt;tid() == Tid::STRING_NUMBER) {</a>
<a name="ln2692">                        bool ok;</a>
<a name="ln2693">                        int i = t.toInt(&amp;ok);</a>
<a name="ln2694">                        if (ok) {</a>
<a name="ln2695">                              if (i == 0)</a>
<a name="ln2696">                                    xml.tagE(&quot;open-string&quot;);</a>
<a name="ln2697">                              else if (i &gt; 0)</a>
<a name="ln2698">                                    xml.tag(&quot;string&quot;, t);</a>
<a name="ln2699">                              }</a>
<a name="ln2700">                        if (!ok || i &lt; 0)</a>
<a name="ln2701">                              qDebug(&quot;invalid string number '%s'&quot;, qPrintable(t));</a>
<a name="ln2702">                        }</a>
<a name="ln2703">                  else</a>
<a name="ln2704">                        qDebug(&quot;unknown fingering style&quot;);</a>
<a name="ln2705">                  }</a>
<a name="ln2706">            else {</a>
<a name="ln2707">                  // TODO</a>
<a name="ln2708">                  }</a>
<a name="ln2709">            }</a>
<a name="ln2710">      }</a>
<a name="ln2711"> </a>
<a name="ln2712">//---------------------------------------------------------</a>
<a name="ln2713">//   stretchCorrActTicks</a>
<a name="ln2714">//---------------------------------------------------------</a>
<a name="ln2715"> </a>
<a name="ln2716">static int stretchCorrActTicks(const Note* const note)</a>
<a name="ln2717">      {</a>
<a name="ln2718">      // time signature stretch factor</a>
<a name="ln2719">      const Fraction str = note-&gt;chord()-&gt;staff()-&gt;timeStretch(note-&gt;chord()-&gt;tick());</a>
<a name="ln2720">      // chord's actual ticks corrected for stretch</a>
<a name="ln2721">      return (note-&gt;chord()-&gt;actualTicks() * str).ticks();</a>
<a name="ln2722">      }</a>
<a name="ln2723"> </a>
<a name="ln2724">//---------------------------------------------------------</a>
<a name="ln2725">//   tremoloCorrection</a>
<a name="ln2726">//---------------------------------------------------------</a>
<a name="ln2727"> </a>
<a name="ln2728">// duration correction for two note tremolo</a>
<a name="ln2729">static int tremoloCorrection(const Note* const note)</a>
<a name="ln2730">      {</a>
<a name="ln2731">      int tremCorr = 1;</a>
<a name="ln2732">      if (isTwoNoteTremolo(note-&gt;chord())) tremCorr = 2;</a>
<a name="ln2733">      return tremCorr;</a>
<a name="ln2734">      }</a>
<a name="ln2735"> </a>
<a name="ln2736">//---------------------------------------------------------</a>
<a name="ln2737">//   isSmallNote</a>
<a name="ln2738">//---------------------------------------------------------</a>
<a name="ln2739"> </a>
<a name="ln2740">static bool isSmallNote(const Note* const note)</a>
<a name="ln2741">      {</a>
<a name="ln2742">      return note-&gt;small() || note-&gt;chord()-&gt;small();</a>
<a name="ln2743">      }</a>
<a name="ln2744"> </a>
<a name="ln2745">//---------------------------------------------------------</a>
<a name="ln2746">//   isCueNote</a>
<a name="ln2747">//---------------------------------------------------------</a>
<a name="ln2748"> </a>
<a name="ln2749">static bool isCueNote(const Note* const note)</a>
<a name="ln2750">      {</a>
<a name="ln2751">      return (!note-&gt;chord()-&gt;isGrace()) &amp;&amp; isSmallNote(note) &amp;&amp; !note-&gt;play();</a>
<a name="ln2752">      }</a>
<a name="ln2753"> </a>
<a name="ln2754">//---------------------------------------------------------</a>
<a name="ln2755">//   writeTypeAndDots</a>
<a name="ln2756">//---------------------------------------------------------</a>
<a name="ln2757"> </a>
<a name="ln2758">static void writeTypeAndDots(XmlWriter&amp; xml, const Note* const note)</a>
<a name="ln2759">      {</a>
<a name="ln2760">      // type</a>
<a name="ln2761">      int dots = 0;</a>
<a name="ln2762">      Tuplet* t = note-&gt;chord()-&gt;tuplet();</a>
<a name="ln2763">      int actNotes = 1;</a>
<a name="ln2764">      int nrmNotes = 1;</a>
<a name="ln2765">      if (t) {</a>
<a name="ln2766">            actNotes = t-&gt;ratio().numerator();</a>
<a name="ln2767">            nrmNotes = t-&gt;ratio().denominator();</a>
<a name="ln2768">            }</a>
<a name="ln2769"> </a>
<a name="ln2770">      const auto strActTicks = stretchCorrActTicks(note);</a>
<a name="ln2771">      Fraction tt = Fraction::fromTicks(strActTicks * actNotes * tremoloCorrection(note) / nrmNotes);</a>
<a name="ln2772">      QString s = tick2xml(tt, &amp;dots);</a>
<a name="ln2773">      if (s.isEmpty())</a>
<a name="ln2774">            qDebug(&quot;no note type found for ticks %d&quot;, strActTicks);</a>
<a name="ln2775"> </a>
<a name="ln2776">      // small notes are indicated by size=cue, but for grace and cue notes this is implicit</a>
<a name="ln2777">      if (isSmallNote(note) &amp;&amp; !isCueNote(note) &amp;&amp; !note-&gt;chord()-&gt;isGrace())</a>
<a name="ln2778">            xml.tag(&quot;type size=\&quot;cue\&quot;&quot;, s);</a>
<a name="ln2779">      else</a>
<a name="ln2780">            xml.tag(&quot;type&quot;, s);</a>
<a name="ln2781">      for (int ni = dots; ni &gt; 0; ni--)</a>
<a name="ln2782">            xml.tagE(&quot;dot&quot;);</a>
<a name="ln2783">      }</a>
<a name="ln2784"> </a>
<a name="ln2785">//---------------------------------------------------------</a>
<a name="ln2786">//   writeTimeModification</a>
<a name="ln2787">//---------------------------------------------------------</a>
<a name="ln2788"> </a>
<a name="ln2789">static void writeTimeModification(XmlWriter&amp; xml, const Note* const note)</a>
<a name="ln2790">      {</a>
<a name="ln2791">      // time modification for two note tremolo</a>
<a name="ln2792">      // TODO: support tremolo in tuplet ?</a>
<a name="ln2793">      if (tremoloCorrection(note) == 2) {</a>
<a name="ln2794">            xml.stag(&quot;time-modification&quot;);</a>
<a name="ln2795">            xml.tag(&quot;actual-notes&quot;, 2);</a>
<a name="ln2796">            xml.tag(&quot;normal-notes&quot;, 1);</a>
<a name="ln2797">            xml.etag();</a>
<a name="ln2798">            }</a>
<a name="ln2799"> </a>
<a name="ln2800">      // time modification for tuplet</a>
<a name="ln2801">      const auto t = note-&gt;chord()-&gt;tuplet();</a>
<a name="ln2802">      if (t) {</a>
<a name="ln2803">            auto actNotes = t-&gt;ratio().numerator();</a>
<a name="ln2804">            auto nrmNotes = t-&gt;ratio().denominator();</a>
<a name="ln2805">            auto nrmTicks = determineTupletNormalTicks(note-&gt;chord());</a>
<a name="ln2806">            // TODO: remove following duplicated code (present for both notes and rests)</a>
<a name="ln2807">            xml.stag(&quot;time-modification&quot;);</a>
<a name="ln2808">            xml.tag(&quot;actual-notes&quot;, actNotes);</a>
<a name="ln2809">            xml.tag(&quot;normal-notes&quot;, nrmNotes);</a>
<a name="ln2810">            //qDebug(&quot;nrmTicks %d&quot;, nrmTicks);</a>
<a name="ln2811">            if (nrmTicks &gt; 0) {</a>
<a name="ln2812">                  int nrmDots = 0;</a>
<a name="ln2813">                  QString nrmType = tick2xml(Fraction::fromTicks(nrmTicks), &amp;nrmDots);</a>
<a name="ln2814">                  if (nrmType.isEmpty())</a>
<a name="ln2815">                        qDebug(&quot;no note type found for ticks %d&quot;, nrmTicks);</a>
<a name="ln2816">                  else {</a>
<a name="ln2817">                        xml.tag(&quot;normal-type&quot;, nrmType);</a>
<a name="ln2818">                        for (int ni = nrmDots; ni &gt; 0; ni--)</a>
<a name="ln2819">                              xml.tagE(&quot;normal-dot&quot;);</a>
<a name="ln2820">                        }</a>
<a name="ln2821">                  }</a>
<a name="ln2822">            xml.etag();</a>
<a name="ln2823">            }</a>
<a name="ln2824">      }</a>
<a name="ln2825"> </a>
<a name="ln2826">//---------------------------------------------------------</a>
<a name="ln2827">//   writePitch</a>
<a name="ln2828">//---------------------------------------------------------</a>
<a name="ln2829"> </a>
<a name="ln2830">static void writePitch(XmlWriter&amp; xml, const Note* const note, const bool useDrumset)</a>
<a name="ln2831">      {</a>
<a name="ln2832">      // step / alter / octave</a>
<a name="ln2833">      QString step;</a>
<a name="ln2834">      int alter = 0;</a>
<a name="ln2835">      int octave = 0;</a>
<a name="ln2836">      const auto chord = note-&gt;chord();</a>
<a name="ln2837">      if (chord-&gt;staff() &amp;&amp; chord-&gt;staff()-&gt;isTabStaff(Fraction(0,1))) {</a>
<a name="ln2838">            tabpitch2xml(note-&gt;pitch(), note-&gt;tpc(), step, alter, octave);</a>
<a name="ln2839">            }</a>
<a name="ln2840">      else {</a>
<a name="ln2841">            if (!useDrumset) {</a>
<a name="ln2842">                  pitch2xml(note, step, alter, octave);</a>
<a name="ln2843">                  }</a>
<a name="ln2844">            else {</a>
<a name="ln2845">                  unpitch2xml(note, step, octave);</a>
<a name="ln2846">                  }</a>
<a name="ln2847">            }</a>
<a name="ln2848">      xml.stag(useDrumset ? &quot;unpitched&quot; : &quot;pitch&quot;);</a>
<a name="ln2849">      xml.tag(useDrumset  ? &quot;display-step&quot; : &quot;step&quot;, step);</a>
<a name="ln2850">      // Check for microtonal accidentals and overwrite &quot;alter&quot; tag</a>
<a name="ln2851">      auto acc = note-&gt;accidental();</a>
<a name="ln2852">      double alter2 = 0.0;</a>
<a name="ln2853">      if (acc) {</a>
<a name="ln2854">            switch (acc-&gt;accidentalType()) {</a>
<a name="ln2855">                  case AccidentalType::MIRRORED_FLAT:  alter2 = -0.5; break;</a>
<a name="ln2856">                  case AccidentalType::SHARP_SLASH:    alter2 = 0.5;  break;</a>
<a name="ln2857">                  case AccidentalType::MIRRORED_FLAT2: alter2 = -1.5; break;</a>
<a name="ln2858">                  case AccidentalType::SHARP_SLASH4:   alter2 = 1.5;  break;</a>
<a name="ln2859">                  default:                                             break;</a>
<a name="ln2860">                  }</a>
<a name="ln2861">            }</a>
<a name="ln2862">      if (alter &amp;&amp; !alter2)</a>
<a name="ln2863">            xml.tag(&quot;alter&quot;, alter);</a>
<a name="ln2864">      if (!alter &amp;&amp; alter2)</a>
<a name="ln2865">            xml.tag(&quot;alter&quot;, alter2);</a>
<a name="ln2866">      // TODO what if both alter and alter2 are present? For Example: playing with transposing instruments</a>
<a name="ln2867">      xml.tag(useDrumset ? &quot;display-octave&quot; : &quot;octave&quot;, octave);</a>
<a name="ln2868">      xml.etag();</a>
<a name="ln2869">      }</a>
<a name="ln2870"> </a>
<a name="ln2871">//---------------------------------------------------------</a>
<a name="ln2872">//   notePosition</a>
<a name="ln2873">//---------------------------------------------------------</a>
<a name="ln2874"> </a>
<a name="ln2875">static QString notePosition(const ExportMusicXml* const expMxml, const Note* const note)</a>
<a name="ln2876">      {</a>
<a name="ln2877">      QString res;</a>
<a name="ln2878"> </a>
<a name="ln2879">      if (preferences.getBool(PREF_EXPORT_MUSICXML_EXPORTLAYOUT)) {</a>
<a name="ln2880">            const double pageHeight  = expMxml-&gt;getTenthsFromInches(expMxml-&gt;score()-&gt;styleD(Sid::pageHeight));</a>
<a name="ln2881"> </a>
<a name="ln2882">            const auto chord = note-&gt;chord();</a>
<a name="ln2883"> </a>
<a name="ln2884">            double measureX = expMxml-&gt;getTenthsFromDots(chord-&gt;measure()-&gt;pagePos().x());</a>
<a name="ln2885">            double measureY = pageHeight - expMxml-&gt;getTenthsFromDots(chord-&gt;measure()-&gt;pagePos().y());</a>
<a name="ln2886">            double noteX = expMxml-&gt;getTenthsFromDots(note-&gt;pagePos().x());</a>
<a name="ln2887">            double noteY = pageHeight - expMxml-&gt;getTenthsFromDots(note-&gt;pagePos().y());</a>
<a name="ln2888"> </a>
<a name="ln2889">            res += QString(&quot; default-x=\&quot;%1\&quot;&quot;).arg(QString::number(noteX - measureX,'f',2));</a>
<a name="ln2890">            res += QString(&quot; default-y=\&quot;%1\&quot;&quot;).arg(QString::number(noteY - measureY,'f',2));</a>
<a name="ln2891">            }</a>
<a name="ln2892"> </a>
<a name="ln2893">      return res;</a>
<a name="ln2894">      }</a>
<a name="ln2895"> </a>
<a name="ln2896">//---------------------------------------------------------</a>
<a name="ln2897">//   chord</a>
<a name="ln2898">//---------------------------------------------------------</a>
<a name="ln2899"> </a>
<a name="ln2900">/**</a>
<a name="ln2901"> Write \a chord on \a staff with lyriclist \a ll.</a>
<a name="ln2902"> </a>
<a name="ln2903"> For a single-staff part, \a staff equals zero, suppressing the &lt;staff&gt; element.</a>
<a name="ln2904"> */</a>
<a name="ln2905"> </a>
<a name="ln2906">void ExportMusicXml::chord(Chord* chord, int staff, const std::vector&lt;Lyrics*&gt;* ll, bool useDrumset)</a>
<a name="ln2907">      {</a>
<a name="ln2908">      Part* part = chord-&gt;score()-&gt;staff(chord-&gt;track() / VOICES)-&gt;part();</a>
<a name="ln2909">      int partNr = _score-&gt;parts().indexOf(part);</a>
<a name="ln2910">      int instNr = instrMap.value(part-&gt;instrument(_tick), -1);</a>
<a name="ln2911">      /*</a>
<a name="ln2912">      qDebug(&quot;chord() %p parent %p isgrace %d #gracenotes %d graceidx %d&quot;,</a>
<a name="ln2913">             chord, chord-&gt;parent(), chord-&gt;isGrace(), chord-&gt;graceNotes().size(), chord-&gt;graceIndex());</a>
<a name="ln2914">      qDebug(&quot;track %d tick %d part %p nr %d instr %p nr %d&quot;,</a>
<a name="ln2915">             chord-&gt;track(), chord-&gt;tick(), part, partNr, part-&gt;instrument(tick), instNr);</a>
<a name="ln2916">      for (Element* e : chord-&gt;el())</a>
<a name="ln2917">            qDebug(&quot;chord %p el %p&quot;, chord, e);</a>
<a name="ln2918">       */</a>
<a name="ln2919">      std::vector&lt;Note*&gt; nl = chord-&gt;notes();</a>
<a name="ln2920">      bool grace = chord-&gt;isGrace();</a>
<a name="ln2921">      if (!grace) _tick += chord-&gt;actualTicks();</a>
<a name="ln2922">#ifdef DEBUG_TICK</a>
<a name="ln2923">      qDebug(&quot;ExportMusicXml::chord() oldtick=%d&quot;, tick);</a>
<a name="ln2924">      qDebug(&quot;notetype=%d grace=%d&quot;, gracen, grace);</a>
<a name="ln2925">      qDebug(&quot; newtick=%d&quot;, tick);</a>
<a name="ln2926">#endif</a>
<a name="ln2927"> </a>
<a name="ln2928">      for (Note* note : nl) {</a>
<a name="ln2929">            QString val;</a>
<a name="ln2930"> </a>
<a name="ln2931">            _attr.doAttr(_xml, false);</a>
<a name="ln2932">            QString noteTag = QString(&quot;note&quot;);</a>
<a name="ln2933"> </a>
<a name="ln2934">            noteTag += notePosition(this, note);</a>
<a name="ln2935"> </a>
<a name="ln2936">            if (!note-&gt;visible()) {</a>
<a name="ln2937">                  noteTag += QString(&quot; print-object=\&quot;no\&quot;&quot;);</a>
<a name="ln2938">                  }</a>
<a name="ln2939">            //TODO support for OFFSET_VAL</a>
<a name="ln2940">            if (note-&gt;veloType() == Note::ValueType::USER_VAL) {</a>
<a name="ln2941">                  int velo = note-&gt;veloOffset();</a>
<a name="ln2942">                  noteTag += QString(&quot; dynamics=\&quot;%1\&quot;&quot;).arg(QString::number(velo * 100.0 / 90.0,'f',2));</a>
<a name="ln2943">                  }</a>
<a name="ln2944">            _xml.stag(noteTag);</a>
<a name="ln2945"> </a>
<a name="ln2946">            if (grace) {</a>
<a name="ln2947">                  if (note-&gt;noteType() == NoteType::ACCIACCATURA)</a>
<a name="ln2948">                        _xml.tagE(&quot;grace slash=\&quot;yes\&quot;&quot;);</a>
<a name="ln2949">                  else</a>
<a name="ln2950">                        _xml.tagE(&quot;grace&quot;);</a>
<a name="ln2951">                  }</a>
<a name="ln2952">            if (isCueNote(note))</a>
<a name="ln2953">                  _xml.tagE(&quot;cue&quot;);</a>
<a name="ln2954">            if (note != nl.front())</a>
<a name="ln2955">                  _xml.tagE(&quot;chord&quot;);</a>
<a name="ln2956"> </a>
<a name="ln2957">            writePitch(_xml, note, useDrumset);</a>
<a name="ln2958"> </a>
<a name="ln2959">            // duration</a>
<a name="ln2960">            if (!grace)</a>
<a name="ln2961">                  _xml.tag(&quot;duration&quot;, stretchCorrActTicks(note) / div);</a>
<a name="ln2962"> </a>
<a name="ln2963">            if (note-&gt;tieBack())</a>
<a name="ln2964">                  _xml.tagE(&quot;tie type=\&quot;stop\&quot;&quot;);</a>
<a name="ln2965">            if (note-&gt;tieFor())</a>
<a name="ln2966">                  _xml.tagE(&quot;tie type=\&quot;start\&quot;&quot;);</a>
<a name="ln2967"> </a>
<a name="ln2968">            // instrument for multi-instrument or unpitched parts</a>
<a name="ln2969">            if (!useDrumset) {</a>
<a name="ln2970">                  if (instrMap.size() &gt; 1 &amp;&amp; instNr &gt;= 0)</a>
<a name="ln2971">                        _xml.tagE(QString(&quot;instrument %1&quot;).arg(instrId(partNr + 1, instNr + 1)));</a>
<a name="ln2972">                  }</a>
<a name="ln2973">            else</a>
<a name="ln2974">                  _xml.tagE(QString(&quot;instrument %1&quot;).arg(instrId(partNr + 1, note-&gt;pitch() + 1)));</a>
<a name="ln2975"> </a>
<a name="ln2976">            // voice</a>
<a name="ln2977">            // for a single-staff part, staff is 0, which needs to be corrected</a>
<a name="ln2978">            // to calculate the correct voice number</a>
<a name="ln2979">            int voice = (staff-1) * VOICES + note-&gt;chord()-&gt;voice() + 1;</a>
<a name="ln2980">            if (staff == 0)</a>
<a name="ln2981">                  voice += VOICES;</a>
<a name="ln2982"> </a>
<a name="ln2983">            _xml.tag(&quot;voice&quot;, voice);</a>
<a name="ln2984"> </a>
<a name="ln2985">            writeTypeAndDots(_xml, note);</a>
<a name="ln2986">            writeAccidental(_xml, &quot;accidental&quot;, note-&gt;accidental());</a>
<a name="ln2987">            writeTimeModification(_xml, note);</a>
<a name="ln2988"> </a>
<a name="ln2989">            // no stem for whole notes and beyond</a>
<a name="ln2990">            if (chord-&gt;noStem() || chord-&gt;measure()-&gt;stemless(chord-&gt;staffIdx())) {</a>
<a name="ln2991">                  _xml.tag(&quot;stem&quot;, QString(&quot;none&quot;));</a>
<a name="ln2992">                  }</a>
<a name="ln2993">            else if (note-&gt;chord()-&gt;stem()) {</a>
<a name="ln2994">                  _xml.tag(&quot;stem&quot;, QString(note-&gt;chord()-&gt;up() ? &quot;up&quot; : &quot;down&quot;));</a>
<a name="ln2995">                  }</a>
<a name="ln2996"> </a>
<a name="ln2997">            writeNotehead(_xml, note);</a>
<a name="ln2998"> </a>
<a name="ln2999">            // LVIFIX: check move() handling</a>
<a name="ln3000">            if (staff)</a>
<a name="ln3001">                  _xml.tag(&quot;staff&quot;, staff + note-&gt;chord()-&gt;staffMove());</a>
<a name="ln3002"> </a>
<a name="ln3003">            if (note == nl.front() &amp;&amp; chord-&gt;beam())</a>
<a name="ln3004">                  writeBeam(_xml, chord, chord-&gt;beam());</a>
<a name="ln3005"> </a>
<a name="ln3006">            Notations notations;</a>
<a name="ln3007">            Technical technical;</a>
<a name="ln3008"> </a>
<a name="ln3009">            const Tie* tieBack = note-&gt;tieBack();</a>
<a name="ln3010">            if (tieBack) {</a>
<a name="ln3011">                  notations.tag(_xml);</a>
<a name="ln3012">                  _xml.tagE(&quot;tied type=\&quot;stop\&quot;&quot;);</a>
<a name="ln3013">                  }</a>
<a name="ln3014">            const Tie* tieFor = note-&gt;tieFor();</a>
<a name="ln3015">            if (tieFor) {</a>
<a name="ln3016">                  notations.tag(_xml);</a>
<a name="ln3017">                  QString rest = slurTieLineStyle(tieFor);</a>
<a name="ln3018">                  _xml.tagE(QString(&quot;tied type=\&quot;start\&quot;%1&quot;).arg(rest));</a>
<a name="ln3019">                  }</a>
<a name="ln3020"> </a>
<a name="ln3021">            if (note == nl.front()) {</a>
<a name="ln3022">                  if (!grace)</a>
<a name="ln3023">                        tupletStartStop(chord, notations, _xml);</a>
<a name="ln3024"> </a>
<a name="ln3025">                  sh.doSlurs(chord, notations, _xml);</a>
<a name="ln3026"> </a>
<a name="ln3027">                  chordAttributes(chord, notations, technical, _trillStart, _trillStop);</a>
<a name="ln3028">                  }</a>
<a name="ln3029"> </a>
<a name="ln3030">            writeFingering(_xml, notations, technical, note);</a>
<a name="ln3031"> </a>
<a name="ln3032">            // write tablature string / fret</a>
<a name="ln3033">            if (chord-&gt;staff() &amp;&amp; chord-&gt;staff()-&gt;isTabStaff(Fraction(0,1)))</a>
<a name="ln3034">                  if (note-&gt;fret() &gt;= 0 &amp;&amp; note-&gt;string() &gt;= 0) {</a>
<a name="ln3035">                        notations.tag(_xml);</a>
<a name="ln3036">                        technical.tag(_xml);</a>
<a name="ln3037">                        _xml.tag(&quot;string&quot;, note-&gt;string() + 1);</a>
<a name="ln3038">                        _xml.tag(&quot;fret&quot;, note-&gt;fret());</a>
<a name="ln3039">                        }</a>
<a name="ln3040"> </a>
<a name="ln3041">            technical.etag(_xml);</a>
<a name="ln3042">            if (chord-&gt;arpeggio()) {</a>
<a name="ln3043">                  arpeggiate(chord-&gt;arpeggio(), note == nl.front(), note == nl.back(), _xml, notations);</a>
<a name="ln3044">                  }</a>
<a name="ln3045">            for (Spanner* spanner : note-&gt;spannerFor())</a>
<a name="ln3046">                  if (spanner-&gt;type() == ElementType::GLISSANDO) {</a>
<a name="ln3047">                        gh.doGlissandoStart(static_cast&lt;Glissando*&gt;(spanner), notations, _xml);</a>
<a name="ln3048">                        }</a>
<a name="ln3049">            for (Spanner* spanner : note-&gt;spannerBack())</a>
<a name="ln3050">                  if (spanner-&gt;type() == ElementType::GLISSANDO) {</a>
<a name="ln3051">                        gh.doGlissandoStop(static_cast&lt;Glissando*&gt;(spanner), notations, _xml);</a>
<a name="ln3052">                        }</a>
<a name="ln3053">            // write glissando (only for last note)</a>
<a name="ln3054">            /*</a>
<a name="ln3055">            Chord* ch = nextChord(chord);</a>
<a name="ln3056">            if ((note == nl.back()) &amp;&amp; ch &amp;&amp; ch-&gt;glissando()) {</a>
<a name="ln3057">                  gh.doGlissandoStart(ch, notations, xml);</a>
<a name="ln3058">                  }</a>
<a name="ln3059">            if (chord-&gt;glissando()) {</a>
<a name="ln3060">                  gh.doGlissandoStop(chord, notations, xml);</a>
<a name="ln3061">                  }</a>
<a name="ln3062">            */</a>
<a name="ln3063">            notations.etag(_xml);</a>
<a name="ln3064">            // write lyrics (only for first note)</a>
<a name="ln3065">            if (!grace &amp;&amp; (note == nl.front()) &amp;&amp; ll)</a>
<a name="ln3066">                  lyrics(ll, chord-&gt;track());</a>
<a name="ln3067">            _xml.etag();</a>
<a name="ln3068">            }</a>
<a name="ln3069">      }</a>
<a name="ln3070"> </a>
<a name="ln3071">//---------------------------------------------------------</a>
<a name="ln3072">//   rest</a>
<a name="ln3073">//---------------------------------------------------------</a>
<a name="ln3074"> </a>
<a name="ln3075">/**</a>
<a name="ln3076"> Write \a rest on \a staff.</a>
<a name="ln3077"> </a>
<a name="ln3078"> For a single-staff part, \a staff equals zero, suppressing the &lt;staff&gt; element.</a>
<a name="ln3079"> */</a>
<a name="ln3080"> </a>
<a name="ln3081">void ExportMusicXml::rest(Rest* rest, int staff)</a>
<a name="ln3082">      {</a>
<a name="ln3083">      static char table2[]  = &quot;CDEFGAB&quot;;</a>
<a name="ln3084">#ifdef DEBUG_TICK</a>
<a name="ln3085">      qDebug(&quot;ExportMusicXml::rest() oldtick=%d&quot;, tick);</a>
<a name="ln3086">#endif</a>
<a name="ln3087">      _attr.doAttr(_xml, false);</a>
<a name="ln3088"> </a>
<a name="ln3089">      QString noteTag = QString(&quot;note&quot;);</a>
<a name="ln3090">      noteTag += color2xml(rest);</a>
<a name="ln3091">      if (!rest-&gt;visible() ) {</a>
<a name="ln3092">            noteTag += QString(&quot; print-object=\&quot;no\&quot;&quot;);</a>
<a name="ln3093">            }</a>
<a name="ln3094">      _xml.stag(noteTag);</a>
<a name="ln3095"> </a>
<a name="ln3096">      int yOffsSt   = 0;</a>
<a name="ln3097">      int oct       = 0;</a>
<a name="ln3098">      int stp       = 0;</a>
<a name="ln3099">      ClefType clef = rest-&gt;staff()-&gt;clef(rest-&gt;tick());</a>
<a name="ln3100">      int po        = ClefInfo::pitchOffset(clef);</a>
<a name="ln3101"> </a>
<a name="ln3102">      // Determine y position, but leave at zero in case of tablature staff</a>
<a name="ln3103">      // as no display-step or display-octave should be written for a tablature staff,</a>
<a name="ln3104"> </a>
<a name="ln3105">      if (clef != ClefType::TAB &amp;&amp; clef != ClefType::TAB_SERIF &amp;&amp; clef != ClefType::TAB4 &amp;&amp; clef != ClefType::TAB4_SERIF) {</a>
<a name="ln3106">            double yOffsSp = rest-&gt;offset().y() / rest-&gt;spatium();              // y offset in spatium (negative = up)</a>
<a name="ln3107">            yOffsSt = -2 * int(yOffsSp &gt; 0.0 ? yOffsSp + 0.5 : yOffsSp - 0.5); // same rounded to int (positive = up)</a>
<a name="ln3108"> </a>
<a name="ln3109">            po -= 4;    // pitch middle staff line (two lines times two steps lower than top line)</a>
<a name="ln3110">            po += yOffsSt; // rest &quot;pitch&quot;</a>
<a name="ln3111">            oct = po / 7; // octave</a>
<a name="ln3112">            stp = po % 7; // step</a>
<a name="ln3113">            }</a>
<a name="ln3114"> </a>
<a name="ln3115">      // Either &lt;rest/&gt;</a>
<a name="ln3116">      // or &lt;rest&gt;&lt;display-step&gt;F&lt;/display-step&gt;&lt;display-octave&gt;5&lt;/display-octave&gt;&lt;/rest&gt;</a>
<a name="ln3117">      if (yOffsSt == 0) {</a>
<a name="ln3118">            _xml.tagE(&quot;rest&quot;);</a>
<a name="ln3119">            }</a>
<a name="ln3120">      else {</a>
<a name="ln3121">            _xml.stag(&quot;rest&quot;);</a>
<a name="ln3122">            _xml.tag(&quot;display-step&quot;, QString(QChar(table2[stp])));</a>
<a name="ln3123">            _xml.tag(&quot;display-octave&quot;, oct - 1);</a>
<a name="ln3124">            _xml.etag();</a>
<a name="ln3125">            }</a>
<a name="ln3126"> </a>
<a name="ln3127">      TDuration d = rest-&gt;durationType();</a>
<a name="ln3128">      Fraction tickLen = rest-&gt;actualTicks();</a>
<a name="ln3129">      if (d.type() == TDuration::DurationType::V_MEASURE) {</a>
<a name="ln3130">            // to avoid forward since rest-&gt;ticklen=0 in this case.</a>
<a name="ln3131">            tickLen = rest-&gt;measure()-&gt;ticks();</a>
<a name="ln3132">            }</a>
<a name="ln3133">      _tick += tickLen;</a>
<a name="ln3134">#ifdef DEBUG_TICK</a>
<a name="ln3135">      qDebug(&quot; tickLen=%d newtick=%d&quot;, tickLen, tick);</a>
<a name="ln3136">#endif</a>
<a name="ln3137"> </a>
<a name="ln3138">      _xml.tag(&quot;duration&quot;, tickLen.ticks() / div);</a>
<a name="ln3139"> </a>
<a name="ln3140">      // for a single-staff part, staff is 0, which needs to be corrected</a>
<a name="ln3141">      // to calculate the correct voice number</a>
<a name="ln3142">      int voice = (staff-1) * VOICES + rest-&gt;voice() + 1;</a>
<a name="ln3143">      if (staff == 0)</a>
<a name="ln3144">            voice += VOICES;</a>
<a name="ln3145">      _xml.tag(&quot;voice&quot;, voice);</a>
<a name="ln3146"> </a>
<a name="ln3147">      // do not output a &quot;type&quot; element for whole measure rest</a>
<a name="ln3148">      if (d.type() != TDuration::DurationType::V_MEASURE) {</a>
<a name="ln3149">            QString s = d.name();</a>
<a name="ln3150">            int dots  = rest-&gt;dots();</a>
<a name="ln3151">            if (rest-&gt;small())</a>
<a name="ln3152">                  _xml.tag(&quot;type size=\&quot;cue\&quot;&quot;, s);</a>
<a name="ln3153">            else</a>
<a name="ln3154">                  _xml.tag(&quot;type&quot;, s);</a>
<a name="ln3155">            for (int i = dots; i &gt; 0; i--)</a>
<a name="ln3156">                  _xml.tagE(&quot;dot&quot;);</a>
<a name="ln3157">            }</a>
<a name="ln3158"> </a>
<a name="ln3159">      if (rest-&gt;tuplet()) {</a>
<a name="ln3160">            Tuplet* t = rest-&gt;tuplet();</a>
<a name="ln3161">            _xml.stag(&quot;time-modification&quot;);</a>
<a name="ln3162">            _xml.tag(&quot;actual-notes&quot;, t-&gt;ratio().numerator());</a>
<a name="ln3163">            _xml.tag(&quot;normal-notes&quot;, t-&gt;ratio().denominator());</a>
<a name="ln3164">            int nrmTicks = determineTupletNormalTicks(rest);</a>
<a name="ln3165">            if (nrmTicks &gt; 0) {</a>
<a name="ln3166">                  int nrmDots = 0;</a>
<a name="ln3167">                  QString nrmType = tick2xml(Fraction::fromTicks(nrmTicks), &amp;nrmDots);</a>
<a name="ln3168">                  if (nrmType.isEmpty())</a>
<a name="ln3169">                        qDebug(&quot;no note type found for ticks %d&quot;, nrmTicks);</a>
<a name="ln3170">                  else {</a>
<a name="ln3171">                        _xml.tag(&quot;normal-type&quot;, nrmType);</a>
<a name="ln3172">                        for (int ni = nrmDots; ni &gt; 0; ni--)</a>
<a name="ln3173">                              _xml.tagE(&quot;normal-dot&quot;);</a>
<a name="ln3174">                        }</a>
<a name="ln3175">                  }</a>
<a name="ln3176">            _xml.etag();</a>
<a name="ln3177">            }</a>
<a name="ln3178"> </a>
<a name="ln3179">      if (staff)</a>
<a name="ln3180">            _xml.tag(&quot;staff&quot;, staff);</a>
<a name="ln3181"> </a>
<a name="ln3182">      Notations notations;</a>
<a name="ln3183">      QVector&lt;Element*&gt; fl;</a>
<a name="ln3184">      for (Element* e : rest-&gt;segment()-&gt;annotations()) {</a>
<a name="ln3185">            if (e-&gt;isFermata() &amp;&amp; e-&gt;track() == rest-&gt;track())</a>
<a name="ln3186">                  fl.push_back(e);</a>
<a name="ln3187">            }</a>
<a name="ln3188">      fermatas(fl, _xml, notations);</a>
<a name="ln3189"> </a>
<a name="ln3190">      Ornaments ornaments;</a>
<a name="ln3191">      wavyLineStartStop(rest, notations, ornaments, _trillStart, _trillStop);</a>
<a name="ln3192">      ornaments.etag(_xml);</a>
<a name="ln3193"> </a>
<a name="ln3194">      sh.doSlurs(rest, notations, _xml);</a>
<a name="ln3195"> </a>
<a name="ln3196">      tupletStartStop(rest, notations, _xml);</a>
<a name="ln3197">      notations.etag(_xml);</a>
<a name="ln3198"> </a>
<a name="ln3199">      _xml.etag();</a>
<a name="ln3200">      }</a>
<a name="ln3201"> </a>
<a name="ln3202">//---------------------------------------------------------</a>
<a name="ln3203">//   directionTag</a>
<a name="ln3204">//---------------------------------------------------------</a>
<a name="ln3205"> </a>
<a name="ln3206">static void directionTag(XmlWriter&amp; xml, Attributes&amp; attr, Element const* const el = 0)</a>
<a name="ln3207">      {</a>
<a name="ln3208">      attr.doAttr(xml, false);</a>
<a name="ln3209">      QString tagname = QString(&quot;direction&quot;);</a>
<a name="ln3210">      if (el) {</a>
<a name="ln3211">            /*</a>
<a name="ln3212">             qDebug(&quot;directionTag() spatium=%g elem=%p tp=%d (%s)\ndirectionTag()  x=%g y=%g xsp,ysp=%g,%g w=%g h=%g userOff.y=%g&quot;,</a>
<a name="ln3213">                    el-&gt;spatium(),</a>
<a name="ln3214">                    el,</a>
<a name="ln3215">                    el-&gt;type(),</a>
<a name="ln3216">                    el-&gt;name(),</a>
<a name="ln3217">                    el-&gt;x(), el-&gt;y(),</a>
<a name="ln3218">                    el-&gt;x()/el-&gt;spatium(), el-&gt;y()/el-&gt;spatium(),</a>
<a name="ln3219">                    el-&gt;width(), el-&gt;height(),</a>
<a name="ln3220">                    el-&gt;offset().y()</a>
<a name="ln3221">                   );</a>
<a name="ln3222">             */</a>
<a name="ln3223">            const Element* pel = 0;</a>
<a name="ln3224">            const LineSegment* seg = 0;</a>
<a name="ln3225">            if (el-&gt;type() == ElementType::HAIRPIN || el-&gt;type() == ElementType::OTTAVA</a>
<a name="ln3226">                || el-&gt;type() == ElementType::PEDAL || el-&gt;type() == ElementType::TEXTLINE) {</a>
<a name="ln3227">                  // handle elements derived from SLine</a>
<a name="ln3228">                  // find the system containing the first linesegment</a>
<a name="ln3229">                  const SLine* sl = static_cast&lt;const SLine*&gt;(el);</a>
<a name="ln3230">                  if (!sl-&gt;segmentsEmpty()) {</a>
<a name="ln3231">                        seg = toLineSegment(sl-&gt;frontSegment());</a>
<a name="ln3232">                        /*</a>
<a name="ln3233">                         qDebug(&quot;directionTag()  seg=%p x=%g y=%g w=%g h=%g cpx=%g cpy=%g userOff.y=%g&quot;,</a>
<a name="ln3234">                                seg, seg-&gt;x(), seg-&gt;y(),</a>
<a name="ln3235">                                seg-&gt;width(), seg-&gt;height(),</a>
<a name="ln3236">                                seg-&gt;pagePos().x(), seg-&gt;pagePos().y(),</a>
<a name="ln3237">                                seg-&gt;offset().y());</a>
<a name="ln3238">                         */</a>
<a name="ln3239">                        pel = seg-&gt;parent();</a>
<a name="ln3240">                        }</a>
<a name="ln3241">                  }</a>
<a name="ln3242">            else if (el-&gt;type() == ElementType::DYNAMIC</a>
<a name="ln3243">                     || el-&gt;type() == ElementType::INSTRUMENT_CHANGE</a>
<a name="ln3244">                     || el-&gt;type() == ElementType::REHEARSAL_MARK</a>
<a name="ln3245">                     || el-&gt;type() == ElementType::STAFF_TEXT</a>
<a name="ln3246">                     || el-&gt;type() == ElementType::SYMBOL</a>
<a name="ln3247">                     || el-&gt;type() == ElementType::TEXT) {</a>
<a name="ln3248">                  // handle other elements attached (e.g. via Segment / Measure) to a system</a>
<a name="ln3249">                  // find the system containing this element</a>
<a name="ln3250">                  for (const Element* e = el; e; e = e-&gt;parent()) {</a>
<a name="ln3251">                        if (e-&gt;type() == ElementType::SYSTEM) pel = e;</a>
<a name="ln3252">                        }</a>
<a name="ln3253">                  }</a>
<a name="ln3254">            else</a>
<a name="ln3255">                  qDebug(&quot;directionTag() element %p tp=%d (%s) not supported&quot;,</a>
<a name="ln3256">                         el, int(el-&gt;type()), el-&gt;name());</a>
<a name="ln3257"> </a>
<a name="ln3258">            /*</a>
<a name="ln3259">             if (pel) {</a>
<a name="ln3260">             qDebug(&quot;directionTag()  prnt tp=%d (%s) x=%g y=%g w=%g h=%g userOff.y=%g&quot;,</a>
<a name="ln3261">                    pel-&gt;type(),</a>
<a name="ln3262">                    pel-&gt;name(),</a>
<a name="ln3263">                    pel-&gt;x(), pel-&gt;y(),</a>
<a name="ln3264">                    pel-&gt;width(), pel-&gt;height(),</a>
<a name="ln3265">                    pel-&gt;offset().y());</a>
<a name="ln3266">                  }</a>
<a name="ln3267">             */</a>
<a name="ln3268"> </a>
<a name="ln3269">            if (pel &amp;&amp; pel-&gt;type() == ElementType::SYSTEM) {</a>
<a name="ln3270">                  /*</a>
<a name="ln3271">                  const System* sys = static_cast&lt;const System*&gt;(pel);</a>
<a name="ln3272">                  QRectF bb = sys-&gt;staff(el-&gt;staffIdx())-&gt;bbox();</a>
<a name="ln3273">                  qDebug(&quot;directionTag()  syst=%p sys x=%g y=%g cpx=%g cpy=%g&quot;,</a>
<a name="ln3274">                         sys, sys-&gt;pos().x(),  sys-&gt;pos().y(),</a>
<a name="ln3275">                         sys-&gt;pagePos().x(),</a>
<a name="ln3276">                         sys-&gt;pagePos().y()</a>
<a name="ln3277">                        );</a>
<a name="ln3278">                  qDebug(&quot;directionTag()  staf x=%g y=%g w=%g h=%g&quot;,</a>
<a name="ln3279">                         bb.x(), bb.y(),</a>
<a name="ln3280">                         bb.width(), bb.height());</a>
<a name="ln3281">                  // element is above the staff if center of bbox is above center of staff</a>
<a name="ln3282">                  qDebug(&quot;directionTag()  center diff=%g&quot;, el-&gt;y() + el-&gt;height() / 2 - bb.y() - bb.height() / 2);</a>
<a name="ln3283">                   */</a>
<a name="ln3284"> </a>
<a name="ln3285">                  if (el-&gt;isHairpin() || el-&gt;isOttava() || el-&gt;isPedal() || el-&gt;isTextLine()) {</a>
<a name="ln3286">                        // for the line type elements the reference point is vertically centered</a>
<a name="ln3287">                        // actual position info is in the segments</a>
<a name="ln3288">                        // compare the segment's canvas ypos with the staff's center height</a>
<a name="ln3289">                        // if (seg-&gt;pagePos().y() &lt; sys-&gt;pagePos().y() + bb.y() + bb.height() / 2)</a>
<a name="ln3290">                        if (el-&gt;placement() == Placement::ABOVE)</a>
<a name="ln3291">                              tagname += &quot; placement=\&quot;above\&quot;&quot;;</a>
<a name="ln3292">                        else</a>
<a name="ln3293">                              tagname += &quot; placement=\&quot;below\&quot;&quot;;</a>
<a name="ln3294">                        }</a>
<a name="ln3295">                  else if (el-&gt;isDynamic()) {</a>
<a name="ln3296">                        tagname += &quot; placement=\&quot;&quot;;</a>
<a name="ln3297">                        tagname += el-&gt;placement() == Placement::ABOVE ? &quot;above&quot; : &quot;below&quot;;</a>
<a name="ln3298">                        tagname += &quot;\&quot;&quot;;</a>
<a name="ln3299">                        }</a>
<a name="ln3300">                  else {</a>
<a name="ln3301">                        /*</a>
<a name="ln3302">                        qDebug(&quot;directionTag()  staf ely=%g elh=%g bby=%g bbh=%g&quot;,</a>
<a name="ln3303">                               el-&gt;y(), el-&gt;height(),</a>
<a name="ln3304">                               bb.y(), bb.height());</a>
<a name="ln3305">                         */</a>
<a name="ln3306">                        // if (el-&gt;y() + el-&gt;height() / 2 &lt; /*bb.y() +*/ bb.height() / 2)</a>
<a name="ln3307">                        if (el-&gt;placement() == Placement::ABOVE)</a>
<a name="ln3308">                              tagname += &quot; placement=\&quot;above\&quot;&quot;;</a>
<a name="ln3309">                        else</a>
<a name="ln3310">                              tagname += &quot; placement=\&quot;below\&quot;&quot;;</a>
<a name="ln3311">                        }</a>
<a name="ln3312">                  } // if (pel &amp;&amp; ...</a>
<a name="ln3313">            }</a>
<a name="ln3314">      xml.stag(tagname);</a>
<a name="ln3315">      }</a>
<a name="ln3316"> </a>
<a name="ln3317">//---------------------------------------------------------</a>
<a name="ln3318">//   directionETag</a>
<a name="ln3319">//---------------------------------------------------------</a>
<a name="ln3320"> </a>
<a name="ln3321">static void directionETag(XmlWriter&amp; xml, int staff, int offs = 0)</a>
<a name="ln3322">      {</a>
<a name="ln3323">      if (offs)</a>
<a name="ln3324">            xml.tag(&quot;offset&quot;, offs);</a>
<a name="ln3325">      if (staff)</a>
<a name="ln3326">            xml.tag(&quot;staff&quot;, staff);</a>
<a name="ln3327">      xml.etag();</a>
<a name="ln3328">      }</a>
<a name="ln3329"> </a>
<a name="ln3330">//---------------------------------------------------------</a>
<a name="ln3331">//   partGroupStart</a>
<a name="ln3332">//---------------------------------------------------------</a>
<a name="ln3333"> </a>
<a name="ln3334">static void partGroupStart(XmlWriter&amp; xml, int number, BracketType bracket)</a>
<a name="ln3335">      {</a>
<a name="ln3336">      xml.stag(QString(&quot;part-group type=\&quot;start\&quot; number=\&quot;%1\&quot;&quot;).arg(number));</a>
<a name="ln3337">      QString br = &quot;&quot;;</a>
<a name="ln3338">      switch (bracket) {</a>
<a name="ln3339">            case BracketType::NO_BRACKET:</a>
<a name="ln3340">                  br = &quot;none&quot;;</a>
<a name="ln3341">                  break;</a>
<a name="ln3342">            case BracketType::NORMAL:</a>
<a name="ln3343">                  br = &quot;bracket&quot;;</a>
<a name="ln3344">                  break;</a>
<a name="ln3345">            case BracketType::BRACE:</a>
<a name="ln3346">                  br = &quot;brace&quot;;</a>
<a name="ln3347">                  break;</a>
<a name="ln3348">            case BracketType::LINE:</a>
<a name="ln3349">                  br = &quot;line&quot;;</a>
<a name="ln3350">                  break;</a>
<a name="ln3351">            case BracketType::SQUARE:</a>
<a name="ln3352">                  br = &quot;square&quot;;</a>
<a name="ln3353">                  break;</a>
<a name="ln3354">            default:</a>
<a name="ln3355">                  qDebug(&quot;bracket subtype %d not understood&quot;, int(bracket));</a>
<a name="ln3356">            }</a>
<a name="ln3357">      if (br != &quot;&quot;)</a>
<a name="ln3358">            xml.tag(&quot;group-symbol&quot;, br);</a>
<a name="ln3359">      xml.etag();</a>
<a name="ln3360">      }</a>
<a name="ln3361"> </a>
<a name="ln3362">//---------------------------------------------------------</a>
<a name="ln3363">//   findUnit</a>
<a name="ln3364">//---------------------------------------------------------</a>
<a name="ln3365"> </a>
<a name="ln3366">static bool findUnit(TDuration::DurationType val, QString&amp; unit)</a>
<a name="ln3367">      {</a>
<a name="ln3368">      unit = &quot;&quot;;</a>
<a name="ln3369">      switch (val) {</a>
<a name="ln3370">            case TDuration::DurationType::V_HALF: unit = &quot;half&quot;; break;</a>
<a name="ln3371">            case TDuration::DurationType::V_QUARTER: unit = &quot;quarter&quot;; break;</a>
<a name="ln3372">            case TDuration::DurationType::V_EIGHTH: unit = &quot;eighth&quot;; break;</a>
<a name="ln3373">            default: qDebug(&quot;findUnit: unknown DurationType %d&quot;, int(val));</a>
<a name="ln3374">            }</a>
<a name="ln3375">      return true;</a>
<a name="ln3376">      }</a>
<a name="ln3377"> </a>
<a name="ln3378">//---------------------------------------------------------</a>
<a name="ln3379">//   findMetronome</a>
<a name="ln3380">//---------------------------------------------------------</a>
<a name="ln3381"> </a>
<a name="ln3382">static bool findMetronome(const QList&lt;TextFragment&gt;&amp; list,</a>
<a name="ln3383">                          QList&lt;TextFragment&gt;&amp; wordsLeft,  // words left of metronome</a>
<a name="ln3384">                          bool&amp; hasParen,      // parenthesis</a>
<a name="ln3385">                          QString&amp; metroLeft,  // left part of metronome</a>
<a name="ln3386">                          QString&amp; metroRight, // right part of metronome</a>
<a name="ln3387">                          QList&lt;TextFragment&gt;&amp; wordsRight // words right of metronome</a>
<a name="ln3388">                          )</a>
<a name="ln3389">      {</a>
<a name="ln3390">      QString words = MScoreTextToMXML::toPlainTextPlusSymbols(list);</a>
<a name="ln3391">      //qDebug(&quot;findMetronome('%s')&quot;, qPrintable(words));</a>
<a name="ln3392">      hasParen   = false;</a>
<a name="ln3393">      metroLeft  = &quot;&quot;;</a>
<a name="ln3394">      metroRight = &quot;&quot;;</a>
<a name="ln3395">      int metroPos = -1;   // metronome start position</a>
<a name="ln3396">      int metroLen = 0;    // metronome length</a>
<a name="ln3397"> </a>
<a name="ln3398">      int indEq  = words.indexOf('=');</a>
<a name="ln3399">      if (indEq &lt;= 0)</a>
<a name="ln3400">            return false;</a>
<a name="ln3401"> </a>
<a name="ln3402">      int len1 = 0;</a>
<a name="ln3403">      TDuration dur;</a>
<a name="ln3404"> </a>
<a name="ln3405">      // find first note, limiting search to the part left of the first '=',</a>
<a name="ln3406">      // to prevent matching the second note in a &quot;note1 = note2&quot; metronome</a>
<a name="ln3407">      int pos1 = TempoText::findTempoDuration(words.left(indEq), len1, dur);</a>
<a name="ln3408">      QRegExp eq(&quot;\\s*=\\s*&quot;);</a>
<a name="ln3409">      int pos2 = eq.indexIn(words, pos1 + len1);</a>
<a name="ln3410">      if (pos1 != -1 &amp;&amp; pos2 == pos1 + len1) {</a>
<a name="ln3411">            int len2 = eq.matchedLength();</a>
<a name="ln3412">            if (words.length() &gt; pos2 + len2) {</a>
<a name="ln3413">                  QString s1 = words.mid(0, pos1);     // string to the left of metronome</a>
<a name="ln3414">                  QString s2 = words.mid(pos1, len1);  // first note</a>
<a name="ln3415">                  QString s3 = words.mid(pos2, len2);  // equals sign</a>
<a name="ln3416">                  QString s4 = words.mid(pos2 + len2); // string to the right of equals sign</a>
<a name="ln3417">                  /*</a>
<a name="ln3418">                  qDebug(&quot;found note and equals: '%s'%s'%s'%s'&quot;,</a>
<a name="ln3419">                         qPrintable(s1),</a>
<a name="ln3420">                         qPrintable(s2),</a>
<a name="ln3421">                         qPrintable(s3),</a>
<a name="ln3422">                         qPrintable(s4)</a>
<a name="ln3423">                         );</a>
<a name="ln3424">                   */</a>
<a name="ln3425"> </a>
<a name="ln3426">                  // now determine what is to the right of the equals sign</a>
<a name="ln3427">                  // must have either a (dotted) note or a number at start of s4</a>
<a name="ln3428">                  int len3 = 0;</a>
<a name="ln3429">                  QRegExp nmb(&quot;\\d+&quot;);</a>
<a name="ln3430">                  int pos3 = TempoText::findTempoDuration(s4, len3, dur);</a>
<a name="ln3431">                  if (pos3 == -1) {</a>
<a name="ln3432">                        // did not find note, try to find a number</a>
<a name="ln3433">                        pos3 = nmb.indexIn(s4);</a>
<a name="ln3434">                        if (pos3 == 0)</a>
<a name="ln3435">                              len3 = nmb.matchedLength();</a>
<a name="ln3436">                        }</a>
<a name="ln3437">                  if (pos3 == -1)</a>
<a name="ln3438">                        // neither found</a>
<a name="ln3439">                        return false;</a>
<a name="ln3440"> </a>
<a name="ln3441">                  QString s5 = s4.mid(0, len3); // number or second note</a>
<a name="ln3442">                  QString s6 = s4.mid(len3);    // string to the right of metronome</a>
<a name="ln3443">                  /*</a>
<a name="ln3444">                  qDebug(&quot;found right part: '%s'%s'&quot;,</a>
<a name="ln3445">                         qPrintable(s5),</a>
<a name="ln3446">                         qPrintable(s6)</a>
<a name="ln3447">                         );</a>
<a name="ln3448">                   */</a>
<a name="ln3449"> </a>
<a name="ln3450">                  // determine if metronome has parentheses</a>
<a name="ln3451">                  // left part of string must end with parenthesis plus optional spaces</a>
<a name="ln3452">                  // right part of string must have parenthesis (but not in first pos)</a>
<a name="ln3453">                  int lparen = s1.indexOf(&quot;(&quot;);</a>
<a name="ln3454">                  int rparen = s6.indexOf(&quot;)&quot;);</a>
<a name="ln3455">                  hasParen = (lparen == s1.length() - 1 &amp;&amp; rparen == 0);</a>
<a name="ln3456"> </a>
<a name="ln3457">                  metroLeft = s2;</a>
<a name="ln3458">                  metroRight = s5;</a>
<a name="ln3459"> </a>
<a name="ln3460">                  metroPos = pos1;               // metronome position</a>
<a name="ln3461">                  metroLen = len1 + len2 + len3; // metronome length</a>
<a name="ln3462">                  if (hasParen) {</a>
<a name="ln3463">                        metroPos -= 1;           // move left one position</a>
<a name="ln3464">                        metroLen += 2;           // add length of '(' and ')'</a>
<a name="ln3465">                        }</a>
<a name="ln3466"> </a>
<a name="ln3467">                  // calculate starting position corrected for surrogate pairs</a>
<a name="ln3468">                  // (which were ignored by toPlainTextPlusSymbols())</a>
<a name="ln3469">                  int corrPos = metroPos;</a>
<a name="ln3470">                  for (int i = 0; i &lt; metroPos; ++i)</a>
<a name="ln3471">                        if (words.at(i).isHighSurrogate())</a>
<a name="ln3472">                              --corrPos;</a>
<a name="ln3473">                  metroPos = corrPos;</a>
<a name="ln3474"> </a>
<a name="ln3475">                  /*</a>
<a name="ln3476">                  qDebug(&quot;-&gt; found '%s'%s' hasParen %d metro pos %d len %d&quot;,</a>
<a name="ln3477">                         qPrintable(metroLeft),</a>
<a name="ln3478">                         qPrintable(metroRight),</a>
<a name="ln3479">                         hasParen, metroPos, metroLen</a>
<a name="ln3480">                         );</a>
<a name="ln3481">                   */</a>
<a name="ln3482">                  QList&lt;TextFragment&gt; mid; // not used</a>
<a name="ln3483">                  MScoreTextToMXML::split(list, metroPos, metroLen, wordsLeft, mid, wordsRight);</a>
<a name="ln3484">                  return true;</a>
<a name="ln3485">                  }</a>
<a name="ln3486">            }</a>
<a name="ln3487">      return false;</a>
<a name="ln3488">      }</a>
<a name="ln3489"> </a>
<a name="ln3490">//---------------------------------------------------------</a>
<a name="ln3491">//   beatUnit</a>
<a name="ln3492">//---------------------------------------------------------</a>
<a name="ln3493"> </a>
<a name="ln3494">static void beatUnit(XmlWriter&amp; xml, const TDuration dur)</a>
<a name="ln3495">      {</a>
<a name="ln3496">      int dots = dur.dots();</a>
<a name="ln3497">      QString unit;</a>
<a name="ln3498">      findUnit(dur.type(), unit);</a>
<a name="ln3499">      xml.tag(&quot;beat-unit&quot;, unit);</a>
<a name="ln3500">      while (dots &gt; 0) {</a>
<a name="ln3501">            xml.tagE(&quot;beat-unit-dot&quot;);</a>
<a name="ln3502">            --dots;</a>
<a name="ln3503">            }</a>
<a name="ln3504">      }</a>
<a name="ln3505"> </a>
<a name="ln3506">//---------------------------------------------------------</a>
<a name="ln3507">//   wordsMetrome</a>
<a name="ln3508">//---------------------------------------------------------</a>
<a name="ln3509"> </a>
<a name="ln3510">static void wordsMetrome(XmlWriter&amp; xml, Score* s, TextBase const* const text, const int offset)</a>
<a name="ln3511">      {</a>
<a name="ln3512">      //qDebug(&quot;wordsMetrome('%s')&quot;, qPrintable(text-&gt;xmlText()));</a>
<a name="ln3513">      const QList&lt;TextFragment&gt; list = text-&gt;fragmentList();</a>
<a name="ln3514">      QList&lt;TextFragment&gt;       wordsLeft;  // words left of metronome</a>
<a name="ln3515">      bool hasParen;                        // parenthesis</a>
<a name="ln3516">      QString metroLeft;                    // left part of metronome</a>
<a name="ln3517">      QString metroRight;                   // right part of metronome</a>
<a name="ln3518">      QList&lt;TextFragment&gt;       wordsRight; // words right of metronome</a>
<a name="ln3519"> </a>
<a name="ln3520">      // set the default words format</a>
<a name="ln3521">      const QString mtf = s-&gt;styleSt(Sid::MusicalTextFont);</a>
<a name="ln3522">      const CharFormat defFmt = formatForWords(s);</a>
<a name="ln3523"> </a>
<a name="ln3524">      if (findMetronome(list, wordsLeft, hasParen, metroLeft, metroRight, wordsRight)) {</a>
<a name="ln3525">            if (wordsLeft.size() &gt; 0) {</a>
<a name="ln3526">                  xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3527">                  QString attr = positioningAttributes(text);</a>
<a name="ln3528">                  MScoreTextToMXML mttm(&quot;words&quot;, attr, defFmt, mtf);</a>
<a name="ln3529">                  mttm.writeTextFragments(wordsLeft, xml);</a>
<a name="ln3530">                  xml.etag();</a>
<a name="ln3531">                  }</a>
<a name="ln3532"> </a>
<a name="ln3533">            xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3534">            QString tagName = QString(&quot;metronome parentheses=\&quot;%1\&quot;&quot;).arg(hasParen ? &quot;yes&quot; : &quot;no&quot;);</a>
<a name="ln3535">            tagName += positioningAttributes(text);</a>
<a name="ln3536">            xml.stag(tagName);</a>
<a name="ln3537">            int len1 = 0;</a>
<a name="ln3538">            TDuration dur;</a>
<a name="ln3539">            TempoText::findTempoDuration(metroLeft, len1, dur);</a>
<a name="ln3540">            beatUnit(xml, dur);</a>
<a name="ln3541"> </a>
<a name="ln3542">            if (TempoText::findTempoDuration(metroRight, len1, dur) != -1)</a>
<a name="ln3543">                  beatUnit(xml, dur);</a>
<a name="ln3544">            else</a>
<a name="ln3545">                  xml.tag(&quot;per-minute&quot;, metroRight);</a>
<a name="ln3546"> </a>
<a name="ln3547">            xml.etag();</a>
<a name="ln3548">            xml.etag();</a>
<a name="ln3549"> </a>
<a name="ln3550">            if (wordsRight.size() &gt; 0) {</a>
<a name="ln3551">                  xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3552">                  QString attr = positioningAttributes(text);</a>
<a name="ln3553">                  MScoreTextToMXML mttm(&quot;words&quot;, attr, defFmt, mtf);</a>
<a name="ln3554">                  mttm.writeTextFragments(wordsRight, xml);</a>
<a name="ln3555">                  xml.etag();</a>
<a name="ln3556">                  }</a>
<a name="ln3557">            }</a>
<a name="ln3558"> </a>
<a name="ln3559">      else {</a>
<a name="ln3560">            xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3561">            QString attr;</a>
<a name="ln3562">            if (text-&gt;hasFrame()) {</a>
<a name="ln3563">                  if (text-&gt;circle())</a>
<a name="ln3564">                        attr = &quot; enclosure=\&quot;circle\&quot;&quot;;</a>
<a name="ln3565">                  else</a>
<a name="ln3566">                        attr = &quot; enclosure=\&quot;rectangle\&quot;&quot;;</a>
<a name="ln3567">                  }</a>
<a name="ln3568">            attr += positioningAttributes(text);</a>
<a name="ln3569">            MScoreTextToMXML mttm(&quot;words&quot;, attr, defFmt, mtf);</a>
<a name="ln3570">            //qDebug(&quot;words('%s')&quot;, qPrintable(text-&gt;text()));</a>
<a name="ln3571">            mttm.writeTextFragments(text-&gt;fragmentList(), xml);</a>
<a name="ln3572">            xml.etag();</a>
<a name="ln3573">            }</a>
<a name="ln3574"> </a>
<a name="ln3575">      if (offset)</a>
<a name="ln3576">            xml.tag(&quot;offset&quot;, offset);</a>
<a name="ln3577">      }</a>
<a name="ln3578"> </a>
<a name="ln3579">//---------------------------------------------------------</a>
<a name="ln3580">//   tempoText</a>
<a name="ln3581">//---------------------------------------------------------</a>
<a name="ln3582"> </a>
<a name="ln3583">void ExportMusicXml::tempoText(TempoText const* const text, int staff)</a>
<a name="ln3584">      {</a>
<a name="ln3585">      const auto offset = calculateTimeDeltaInDivisions(text-&gt;tick(), tick(), div);</a>
<a name="ln3586">      /*</a>
<a name="ln3587">      qDebug(&quot;tick %s text-&gt;tick %s offset %d xmlText='%s')&quot;,</a>
<a name="ln3588">             qPrintable(tick().print()),</a>
<a name="ln3589">             qPrintable(text-&gt;tick().print()),</a>
<a name="ln3590">             offset,</a>
<a name="ln3591">             qPrintable(text-&gt;xmlText()));</a>
<a name="ln3592">      */</a>
<a name="ln3593">      _attr.doAttr(_xml, false);</a>
<a name="ln3594">      _xml.stag(QString(&quot;direction placement=\&quot;%1\&quot;&quot;).arg((text-&gt;placement() ==Placement::BELOW ) ? &quot;below&quot; : &quot;above&quot;));</a>
<a name="ln3595">      wordsMetrome(_xml, _score, text, offset);</a>
<a name="ln3596"> </a>
<a name="ln3597">      if (staff)</a>
<a name="ln3598">            _xml.tag(&quot;staff&quot;, staff);</a>
<a name="ln3599">      _xml.tagE(QString(&quot;sound tempo=\&quot;%1\&quot;&quot;).arg(QString::number(text-&gt;tempo()*60.0)));</a>
<a name="ln3600">      _xml.etag();</a>
<a name="ln3601">      }</a>
<a name="ln3602"> </a>
<a name="ln3603">//---------------------------------------------------------</a>
<a name="ln3604">//   words</a>
<a name="ln3605">//---------------------------------------------------------</a>
<a name="ln3606"> </a>
<a name="ln3607">void ExportMusicXml::words(TextBase const* const text, int staff)</a>
<a name="ln3608">      {</a>
<a name="ln3609">      const auto offset = calculateTimeDeltaInDivisions(text-&gt;tick(), tick(), div);</a>
<a name="ln3610">      /*</a>
<a name="ln3611">      qDebug(&quot;tick %s text-&gt;tick %s offset %d userOff.x=%f userOff.y=%f xmlText='%s' plainText='%s'&quot;,</a>
<a name="ln3612">             qPrintable(tick().print()),</a>
<a name="ln3613">             qPrintable(text-&gt;tick().print()),</a>
<a name="ln3614">             offset,</a>
<a name="ln3615">             text-&gt;offset().x(), text-&gt;offset().y(),</a>
<a name="ln3616">             qPrintable(text-&gt;xmlText()),</a>
<a name="ln3617">             qPrintable(text-&gt;plainText()));</a>
<a name="ln3618">      */</a>
<a name="ln3619"> </a>
<a name="ln3620">      if (text-&gt;plainText() == &quot;&quot;) {</a>
<a name="ln3621">            // sometimes empty Texts are present, exporting would result</a>
<a name="ln3622">            // in invalid MusicXML (as an empty direction-type would be created)</a>
<a name="ln3623">            return;</a>
<a name="ln3624">            }</a>
<a name="ln3625"> </a>
<a name="ln3626">      directionTag(_xml, _attr, text);</a>
<a name="ln3627">      wordsMetrome(_xml, _score, text, offset);</a>
<a name="ln3628">      directionETag(_xml, staff);</a>
<a name="ln3629">      }</a>
<a name="ln3630"> </a>
<a name="ln3631">//---------------------------------------------------------</a>
<a name="ln3632">//   positioningAttributesForTboxText</a>
<a name="ln3633">//---------------------------------------------------------</a>
<a name="ln3634"> </a>
<a name="ln3635">static QString positioningAttributesForTboxText(const QPointF position, float spatium)</a>
<a name="ln3636">      {</a>
<a name="ln3637">      if (!preferences.getBool(PREF_EXPORT_MUSICXML_EXPORTLAYOUT))</a>
<a name="ln3638">            return &quot;&quot;;</a>
<a name="ln3639"> </a>
<a name="ln3640">      QPointF relative;       // use zero relative position</a>
<a name="ln3641">      return positionToQString(position, relative, spatium);</a>
<a name="ln3642">      }</a>
<a name="ln3643"> </a>
<a name="ln3644">//---------------------------------------------------------</a>
<a name="ln3645">//   tboxTextAsWords</a>
<a name="ln3646">//---------------------------------------------------------</a>
<a name="ln3647"> </a>
<a name="ln3648">void ExportMusicXml::tboxTextAsWords(TextBase const* const text, const int staff, const QPointF relativePosition)</a>
<a name="ln3649">      {</a>
<a name="ln3650">      if (text-&gt;plainText() == &quot;&quot;) {</a>
<a name="ln3651">            // sometimes empty Texts are present, exporting would result</a>
<a name="ln3652">            // in invalid MusicXML (as an empty direction-type would be created)</a>
<a name="ln3653">            return;</a>
<a name="ln3654">            }</a>
<a name="ln3655"> </a>
<a name="ln3656">      // set the default words format</a>
<a name="ln3657">      const QString mtf = _score-&gt;styleSt(Sid::MusicalTextFont);</a>
<a name="ln3658">      const CharFormat defFmt = formatForWords(_score);</a>
<a name="ln3659"> </a>
<a name="ln3660">      QString tagname { &quot;direction&quot; };</a>
<a name="ln3661">      tagname += &quot; placement=&quot;;</a>
<a name="ln3662">      tagname += (relativePosition.y() &lt; 0) ? &quot;\&quot;above\&quot;&quot; : &quot;\&quot;below\&quot;&quot;;</a>
<a name="ln3663">      _xml.stag(tagname);</a>
<a name="ln3664">      _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3665">      QString attr;</a>
<a name="ln3666">      if (text-&gt;hasFrame()) {</a>
<a name="ln3667">            if (text-&gt;circle())</a>
<a name="ln3668">                  attr = &quot; enclosure=\&quot;circle\&quot;&quot;;</a>
<a name="ln3669">            else</a>
<a name="ln3670">                  attr = &quot; enclosure=\&quot;rectangle\&quot;&quot;;</a>
<a name="ln3671">            }</a>
<a name="ln3672">      attr += positioningAttributesForTboxText(relativePosition, text-&gt;spatium());</a>
<a name="ln3673">      attr += &quot; valign=\&quot;top\&quot;&quot;;</a>
<a name="ln3674">      MScoreTextToMXML mttm(&quot;words&quot;, attr, defFmt, mtf);</a>
<a name="ln3675">      mttm.writeTextFragments(text-&gt;fragmentList(), _xml);</a>
<a name="ln3676">      _xml.etag();</a>
<a name="ln3677">      directionETag(_xml, staff);</a>
<a name="ln3678">      }</a>
<a name="ln3679"> </a>
<a name="ln3680">//---------------------------------------------------------</a>
<a name="ln3681">//   rehearsal</a>
<a name="ln3682">//---------------------------------------------------------</a>
<a name="ln3683"> </a>
<a name="ln3684">void ExportMusicXml::rehearsal(RehearsalMark const* const rmk, int staff)</a>
<a name="ln3685">      {</a>
<a name="ln3686">      if (rmk-&gt;plainText() == &quot;&quot;) {</a>
<a name="ln3687">            // sometimes empty Texts are present, exporting would result</a>
<a name="ln3688">            // in invalid MusicXML (as an empty direction-type would be created)</a>
<a name="ln3689">            return;</a>
<a name="ln3690">            }</a>
<a name="ln3691"> </a>
<a name="ln3692">      directionTag(_xml, _attr, rmk);</a>
<a name="ln3693">      _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3694">      QString attr = positioningAttributes(rmk);</a>
<a name="ln3695">      if (!rmk-&gt;hasFrame()) attr = &quot; enclosure=\&quot;none\&quot;&quot;;</a>
<a name="ln3696">      // set the default words format</a>
<a name="ln3697">      const QString mtf = _score-&gt;styleSt(Sid::MusicalTextFont);</a>
<a name="ln3698">      const CharFormat defFmt = formatForWords(_score);</a>
<a name="ln3699">      // write formatted</a>
<a name="ln3700">      MScoreTextToMXML mttm(&quot;rehearsal&quot;, attr, defFmt, mtf);</a>
<a name="ln3701">      mttm.writeTextFragments(rmk-&gt;fragmentList(), _xml);</a>
<a name="ln3702">      _xml.etag();</a>
<a name="ln3703">      const auto offset = calculateTimeDeltaInDivisions(rmk-&gt;tick(), tick(), div);</a>
<a name="ln3704">      if (offset)</a>
<a name="ln3705">            _xml.tag(&quot;offset&quot;, offset);</a>
<a name="ln3706">      directionETag(_xml, staff);</a>
<a name="ln3707">      }</a>
<a name="ln3708"> </a>
<a name="ln3709">//---------------------------------------------------------</a>
<a name="ln3710">//   findDashes -- get index of hairpin in dashes table</a>
<a name="ln3711">//   return -1 if not found</a>
<a name="ln3712">//---------------------------------------------------------</a>
<a name="ln3713"> </a>
<a name="ln3714">int ExportMusicXml::findDashes(const TextLineBase* hp) const</a>
<a name="ln3715">      {</a>
<a name="ln3716">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln3717">            if (dashes[i] == hp) return i;</a>
<a name="ln3718">      return -1;</a>
<a name="ln3719">      }</a>
<a name="ln3720"> </a>
<a name="ln3721">//---------------------------------------------------------</a>
<a name="ln3722">//   findHairpin -- get index of hairpin in hairpin table</a>
<a name="ln3723">//   return -1 if not found</a>
<a name="ln3724">//---------------------------------------------------------</a>
<a name="ln3725"> </a>
<a name="ln3726">int ExportMusicXml::findHairpin(const Hairpin* hp) const</a>
<a name="ln3727">      {</a>
<a name="ln3728">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln3729">            if (hairpins[i] == hp) return i;</a>
<a name="ln3730">      return -1;</a>
<a name="ln3731">      }</a>
<a name="ln3732"> </a>
<a name="ln3733">//---------------------------------------------------------</a>
<a name="ln3734">//   fontSyleToXML</a>
<a name="ln3735">//---------------------------------------------------------</a>
<a name="ln3736"> </a>
<a name="ln3737">static QString fontSyleToXML(const FontStyle style)</a>
<a name="ln3738">      {</a>
<a name="ln3739">      QString res;</a>
<a name="ln3740">      if (style &amp; FontStyle::Bold)</a>
<a name="ln3741">            res += &quot; font-weight=\&quot;bold\&quot;&quot;;</a>
<a name="ln3742">      else if (style &amp; FontStyle::Italic)</a>
<a name="ln3743">            res += &quot; font-style=\&quot;italic\&quot;&quot;;</a>
<a name="ln3744">      else if (style &amp; FontStyle::Underline)</a>
<a name="ln3745">            res += &quot; underline=\&quot;1\&quot;&quot;;</a>
<a name="ln3746">      return res;</a>
<a name="ln3747">      }</a>
<a name="ln3748"> </a>
<a name="ln3749">//---------------------------------------------------------</a>
<a name="ln3750">//   hairpin</a>
<a name="ln3751">//---------------------------------------------------------</a>
<a name="ln3752"> </a>
<a name="ln3753">void ExportMusicXml::hairpin(Hairpin const* const hp, int staff, const Fraction&amp; tick)</a>
<a name="ln3754">      {</a>
<a name="ln3755">      const auto isLineType = hp-&gt;isLineType();</a>
<a name="ln3756">      int n;</a>
<a name="ln3757">      if (isLineType) {</a>
<a name="ln3758">            n = findDashes(hp);</a>
<a name="ln3759">            if (n &gt;= 0)</a>
<a name="ln3760">                  dashes[n] = nullptr;</a>
<a name="ln3761">            else {</a>
<a name="ln3762">                  n = findDashes(nullptr);</a>
<a name="ln3763">                  if (n &gt;= 0)</a>
<a name="ln3764">                        dashes[n] = hp;</a>
<a name="ln3765">                  else {</a>
<a name="ln3766">                        qDebug(&quot;too many overlapping dashes (hp %p staff %d tick %d)&quot;, hp, staff, tick.ticks());</a>
<a name="ln3767">                        return;</a>
<a name="ln3768">                        }</a>
<a name="ln3769">                  }</a>
<a name="ln3770">            }</a>
<a name="ln3771">      else {</a>
<a name="ln3772">            n = findHairpin(hp);</a>
<a name="ln3773">            if (n &gt;= 0)</a>
<a name="ln3774">                  hairpins[n] = nullptr;</a>
<a name="ln3775">            else {</a>
<a name="ln3776">                  n = findHairpin(nullptr);</a>
<a name="ln3777">                  if (n &gt;= 0)</a>
<a name="ln3778">                        hairpins[n] = hp;</a>
<a name="ln3779">                  else {</a>
<a name="ln3780">                        qDebug(&quot;too many overlapping hairpins (hp %p staff %d tick %d)&quot;, hp, staff, tick.ticks());</a>
<a name="ln3781">                        return;</a>
<a name="ln3782">                        }</a>
<a name="ln3783">                  }</a>
<a name="ln3784">            }</a>
<a name="ln3785"> </a>
<a name="ln3786">      directionTag(_xml, _attr, hp);</a>
<a name="ln3787">      if (isLineType) {</a>
<a name="ln3788">            if (hp-&gt;tick() == tick) {</a>
<a name="ln3789">                  _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3790">                  QString tag = &quot;words&quot;;</a>
<a name="ln3791">                  tag += QString(&quot; font-family=\&quot;%1\&quot;&quot;).arg(hp-&gt;getProperty(Pid::BEGIN_FONT_FACE).toString());</a>
<a name="ln3792">                  tag += QString(&quot; font-size=\&quot;%1\&quot;&quot;).arg(hp-&gt;getProperty(Pid::BEGIN_FONT_SIZE).toReal());</a>
<a name="ln3793">                  tag += fontSyleToXML(static_cast&lt;FontStyle&gt;(hp-&gt;getProperty(Pid::BEGIN_FONT_STYLE).toInt()));</a>
<a name="ln3794">                  tag += positioningAttributes(hp, hp-&gt;tick() == tick);</a>
<a name="ln3795">                  _xml.tag(tag, hp-&gt;getProperty(Pid::BEGIN_TEXT));</a>
<a name="ln3796">                  _xml.etag();</a>
<a name="ln3797"> </a>
<a name="ln3798">                  _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3799">                  tag = &quot;dashes type=\&quot;start\&quot;&quot;;</a>
<a name="ln3800">                  tag += QString(&quot; number=\&quot;%1\&quot;&quot;).arg(n + 1);</a>
<a name="ln3801">                  tag += positioningAttributes(hp, hp-&gt;tick() == tick);</a>
<a name="ln3802">                  _xml.tagE(tag);</a>
<a name="ln3803">                  _xml.etag();</a>
<a name="ln3804">                  }</a>
<a name="ln3805">            else {</a>
<a name="ln3806">                  _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3807">                  _xml.tagE(QString(&quot;dashes type=\&quot;stop\&quot; number=\&quot;%1\&quot;&quot;).arg(n + 1));</a>
<a name="ln3808">                  _xml.etag();</a>
<a name="ln3809">                  }</a>
<a name="ln3810">            }</a>
<a name="ln3811">      else {</a>
<a name="ln3812">            _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3813">            QString tag = &quot;wedge type=&quot;;</a>
<a name="ln3814">            if (hp-&gt;tick() == tick) {</a>
<a name="ln3815">                  if (hp-&gt;hairpinType() == HairpinType::CRESC_HAIRPIN) {</a>
<a name="ln3816">                        tag += &quot;\&quot;crescendo\&quot;&quot;;</a>
<a name="ln3817">                        if (hp-&gt;hairpinCircledTip()) {</a>
<a name="ln3818">                              tag += &quot; niente=\&quot;yes\&quot;&quot;;</a>
<a name="ln3819">                              }</a>
<a name="ln3820">                        }</a>
<a name="ln3821">                  else {</a>
<a name="ln3822">                        tag += &quot;\&quot;diminuendo\&quot;&quot;;</a>
<a name="ln3823">                        }</a>
<a name="ln3824">                  }</a>
<a name="ln3825">            else {</a>
<a name="ln3826">                  tag += &quot;\&quot;stop\&quot;&quot;;</a>
<a name="ln3827">                  if (hp-&gt;hairpinCircledTip() &amp;&amp; hp-&gt;hairpinType() == HairpinType::DECRESC_HAIRPIN) {</a>
<a name="ln3828">                        tag += &quot; niente=\&quot;yes\&quot;&quot;;</a>
<a name="ln3829">                        }</a>
<a name="ln3830">                  }</a>
<a name="ln3831">            tag += QString(&quot; number=\&quot;%1\&quot;&quot;).arg(n + 1);</a>
<a name="ln3832">            tag += positioningAttributes(hp, hp-&gt;tick() == tick);</a>
<a name="ln3833">            _xml.tagE(tag);</a>
<a name="ln3834">            _xml.etag();</a>
<a name="ln3835">            }</a>
<a name="ln3836">      directionETag(_xml, staff);</a>
<a name="ln3837">      }</a>
<a name="ln3838"> </a>
<a name="ln3839">//---------------------------------------------------------</a>
<a name="ln3840">//   findOttava -- get index of ottava in ottava table</a>
<a name="ln3841">//   return -1 if not found</a>
<a name="ln3842">//---------------------------------------------------------</a>
<a name="ln3843"> </a>
<a name="ln3844">int ExportMusicXml::findOttava(const Ottava* ot) const</a>
<a name="ln3845">      {</a>
<a name="ln3846">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln3847">            if (ottavas[i] == ot) return i;</a>
<a name="ln3848">      return -1;</a>
<a name="ln3849">      }</a>
<a name="ln3850"> </a>
<a name="ln3851">//---------------------------------------------------------</a>
<a name="ln3852">//   ottava</a>
<a name="ln3853">// &lt;octave-shift type=&quot;down&quot; size=&quot;8&quot; relative-y=&quot;14&quot;/&gt;</a>
<a name="ln3854">// &lt;octave-shift type=&quot;stop&quot; size=&quot;8&quot;/&gt;</a>
<a name="ln3855">//---------------------------------------------------------</a>
<a name="ln3856"> </a>
<a name="ln3857">void ExportMusicXml::ottava(Ottava const* const ot, int staff, const Fraction&amp; tick)</a>
<a name="ln3858">      {</a>
<a name="ln3859">      auto n = findOttava(ot);</a>
<a name="ln3860">      if (n &gt;= 0)</a>
<a name="ln3861">            ottavas[n] = 0;</a>
<a name="ln3862">      else {</a>
<a name="ln3863">            n = findOttava(0);</a>
<a name="ln3864">            if (n &gt;= 0)</a>
<a name="ln3865">                  ottavas[n] = ot;</a>
<a name="ln3866">            else {</a>
<a name="ln3867">                  qDebug(&quot;too many overlapping ottavas (ot %p staff %d tick %d)&quot;, ot, staff, tick.ticks());</a>
<a name="ln3868">                  return;</a>
<a name="ln3869">                  }</a>
<a name="ln3870">            }</a>
<a name="ln3871"> </a>
<a name="ln3872">      QString octaveShiftXml;</a>
<a name="ln3873">      const auto st = ot-&gt;ottavaType();</a>
<a name="ln3874">      if (ot-&gt;tick() == tick) {</a>
<a name="ln3875">            const char* sz = 0;</a>
<a name="ln3876">            const char* tp = 0;</a>
<a name="ln3877">            switch (st) {</a>
<a name="ln3878">                  case OttavaType::OTTAVA_8VA:</a>
<a name="ln3879">                        sz = &quot;8&quot;;</a>
<a name="ln3880">                        tp = &quot;down&quot;;</a>
<a name="ln3881">                        break;</a>
<a name="ln3882">                  case OttavaType::OTTAVA_15MA:</a>
<a name="ln3883">                        sz = &quot;15&quot;;</a>
<a name="ln3884">                        tp = &quot;down&quot;;</a>
<a name="ln3885">                        break;</a>
<a name="ln3886">                  case OttavaType::OTTAVA_8VB:</a>
<a name="ln3887">                        sz = &quot;8&quot;;</a>
<a name="ln3888">                        tp = &quot;up&quot;;</a>
<a name="ln3889">                        break;</a>
<a name="ln3890">                  case OttavaType::OTTAVA_15MB:</a>
<a name="ln3891">                        sz = &quot;15&quot;;</a>
<a name="ln3892">                        tp = &quot;up&quot;;</a>
<a name="ln3893">                        break;</a>
<a name="ln3894">                  default:</a>
<a name="ln3895">                        qDebug(&quot;ottava subtype %d not understood&quot;, int(st));</a>
<a name="ln3896">                  }</a>
<a name="ln3897">            if (sz &amp;&amp; tp)</a>
<a name="ln3898">                  octaveShiftXml = QString(&quot;octave-shift type=\&quot;%1\&quot; size=\&quot;%2\&quot; number=\&quot;%3\&quot;&quot;).arg(tp).arg(sz).arg(n + 1);</a>
<a name="ln3899">            }</a>
<a name="ln3900">      else {</a>
<a name="ln3901">            if (st == OttavaType::OTTAVA_8VA || st == OttavaType::OTTAVA_8VB)</a>
<a name="ln3902">                  octaveShiftXml = QString(&quot;octave-shift type=\&quot;stop\&quot; size=\&quot;8\&quot; number=\&quot;%1\&quot;&quot;).arg(n + 1);</a>
<a name="ln3903">            else if (st == OttavaType::OTTAVA_15MA || st == OttavaType::OTTAVA_15MB)</a>
<a name="ln3904">                  octaveShiftXml = QString(&quot;octave-shift type=\&quot;stop\&quot; size=\&quot;15\&quot; number=\&quot;%1\&quot;&quot;).arg(n + 1);</a>
<a name="ln3905">            else</a>
<a name="ln3906">                  qDebug(&quot;ottava subtype %d not understood&quot;, int(st));</a>
<a name="ln3907">            }</a>
<a name="ln3908"> </a>
<a name="ln3909">      if (octaveShiftXml != &quot;&quot;) {</a>
<a name="ln3910">            directionTag(_xml, _attr, ot);</a>
<a name="ln3911">            _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3912">            octaveShiftXml += positioningAttributes(ot, ot-&gt;tick() == tick);</a>
<a name="ln3913">            _xml.tagE(octaveShiftXml);</a>
<a name="ln3914">            _xml.etag();</a>
<a name="ln3915">            directionETag(_xml, staff);</a>
<a name="ln3916">            }</a>
<a name="ln3917">      }</a>
<a name="ln3918"> </a>
<a name="ln3919">//---------------------------------------------------------</a>
<a name="ln3920">//   pedal</a>
<a name="ln3921">//---------------------------------------------------------</a>
<a name="ln3922"> </a>
<a name="ln3923">void ExportMusicXml::pedal(Pedal const* const pd, int staff, const Fraction&amp; tick)</a>
<a name="ln3924">      {</a>
<a name="ln3925">      directionTag(_xml, _attr, pd);</a>
<a name="ln3926">      _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln3927">      QString pedalXml;</a>
<a name="ln3928">      if (pd-&gt;tick() == tick)</a>
<a name="ln3929">            pedalXml = &quot;pedal type=\&quot;start\&quot; line=\&quot;yes\&quot;&quot;;</a>
<a name="ln3930">      else</a>
<a name="ln3931">            pedalXml = &quot;pedal type=\&quot;stop\&quot; line=\&quot;yes\&quot;&quot;;</a>
<a name="ln3932">      pedalXml += positioningAttributes(pd, pd-&gt;tick() == tick);</a>
<a name="ln3933">      _xml.tagE(pedalXml);</a>
<a name="ln3934">      _xml.etag();</a>
<a name="ln3935">      directionETag(_xml, staff);</a>
<a name="ln3936">      }</a>
<a name="ln3937"> </a>
<a name="ln3938">//---------------------------------------------------------</a>
<a name="ln3939">//   findBracket -- get index of bracket in bracket table</a>
<a name="ln3940">//   return -1 if not found</a>
<a name="ln3941">//---------------------------------------------------------</a>
<a name="ln3942"> </a>
<a name="ln3943">int ExportMusicXml::findBracket(const TextLine* tl) const</a>
<a name="ln3944">      {</a>
<a name="ln3945">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i)</a>
<a name="ln3946">            if (brackets[i] == tl) return i;</a>
<a name="ln3947">      return -1;</a>
<a name="ln3948">      }</a>
<a name="ln3949"> </a>
<a name="ln3950">//---------------------------------------------------------</a>
<a name="ln3951">//   textLine</a>
<a name="ln3952">//---------------------------------------------------------</a>
<a name="ln3953"> </a>
<a name="ln3954">void ExportMusicXml::textLine(TextLine const* const tl, int staff, const Fraction&amp; tick)</a>
<a name="ln3955">      {</a>
<a name="ln3956">      int n;</a>
<a name="ln3957">      // special case: a dashed line w/o hooks is written as dashes</a>
<a name="ln3958">      const auto isDashes = tl-&gt;lineStyle() == Qt::DashLine &amp;&amp; (tl-&gt;beginHookType() == HookType::NONE) &amp;&amp; (tl-&gt;endHookType() == HookType::NONE);</a>
<a name="ln3959"> </a>
<a name="ln3960">      if (isDashes) {</a>
<a name="ln3961">            n = findDashes(tl);</a>
<a name="ln3962">            if (n &gt;= 0)</a>
<a name="ln3963">                  dashes[n] = nullptr;</a>
<a name="ln3964">            else {</a>
<a name="ln3965">                  n = findBracket(nullptr);</a>
<a name="ln3966">                  if (n &gt;= 0)</a>
<a name="ln3967">                        dashes[n] = tl;</a>
<a name="ln3968">                  else {</a>
<a name="ln3969">                        qDebug(&quot;too many overlapping dashes (tl %p staff %d tick %d)&quot;, tl, staff, tick.ticks());</a>
<a name="ln3970">                        return;</a>
<a name="ln3971">                        }</a>
<a name="ln3972">                  }</a>
<a name="ln3973">            }</a>
<a name="ln3974">      else {</a>
<a name="ln3975">            n = findBracket(tl);</a>
<a name="ln3976">            if (n &gt;= 0)</a>
<a name="ln3977">                  brackets[n] = nullptr;</a>
<a name="ln3978">            else {</a>
<a name="ln3979">                  n = findBracket(nullptr);</a>
<a name="ln3980">                  if (n &gt;= 0)</a>
<a name="ln3981">                        brackets[n] = tl;</a>
<a name="ln3982">                  else {</a>
<a name="ln3983">                        qDebug(&quot;too many overlapping textlines (tl %p staff %d tick %d)&quot;, tl, staff, tick.ticks());</a>
<a name="ln3984">                        return;</a>
<a name="ln3985">                        }</a>
<a name="ln3986">                  }</a>
<a name="ln3987">            }</a>
<a name="ln3988"> </a>
<a name="ln3989">      QString rest;</a>
<a name="ln3990">      QPointF p;</a>
<a name="ln3991"> </a>
<a name="ln3992">      QString lineEnd = &quot;none&quot;;</a>
<a name="ln3993">      QString type;</a>
<a name="ln3994">      bool hook = false;</a>
<a name="ln3995">      double hookHeight = 0.0;</a>
<a name="ln3996">      if (tl-&gt;tick() == tick) {</a>
<a name="ln3997">            if (!isDashes) {</a>
<a name="ln3998">                  QString lineType;</a>
<a name="ln3999">                  switch (tl-&gt;lineStyle()) {</a>
<a name="ln4000">                        case Qt::SolidLine:</a>
<a name="ln4001">                              lineType = &quot;solid&quot;;</a>
<a name="ln4002">                              break;</a>
<a name="ln4003">                        case Qt::DashLine:</a>
<a name="ln4004">                              lineType = &quot;dashed&quot;;</a>
<a name="ln4005">                              break;</a>
<a name="ln4006">                        case Qt::DotLine:</a>
<a name="ln4007">                              lineType = &quot;dotted&quot;;</a>
<a name="ln4008">                              break;</a>
<a name="ln4009">                        default:</a>
<a name="ln4010">                              lineType = &quot;solid&quot;;</a>
<a name="ln4011">                        }</a>
<a name="ln4012">                  rest += QString(&quot; line-type=\&quot;%1\&quot;&quot;).arg(lineType);</a>
<a name="ln4013">                  }</a>
<a name="ln4014">            hook       = tl-&gt;beginHookType() != HookType::NONE;</a>
<a name="ln4015">            hookHeight = tl-&gt;beginHookHeight().val();</a>
<a name="ln4016">            if (!tl-&gt;segmentsEmpty())</a>
<a name="ln4017">                  p = tl-&gt;frontSegment()-&gt;offset();</a>
<a name="ln4018">            // offs = tl-&gt;mxmlOff();</a>
<a name="ln4019">            type = &quot;start&quot;;</a>
<a name="ln4020">            }</a>
<a name="ln4021">      else {</a>
<a name="ln4022">            hook = tl-&gt;endHookType() != HookType::NONE;</a>
<a name="ln4023">            hookHeight = tl-&gt;endHookHeight().val();</a>
<a name="ln4024">            if (!tl-&gt;segmentsEmpty())</a>
<a name="ln4025">                  p = (toLineSegment(tl-&gt;backSegment()))-&gt;userOff2();</a>
<a name="ln4026">            // offs = tl-&gt;mxmlOff2();</a>
<a name="ln4027">            type = &quot;stop&quot;;</a>
<a name="ln4028">            }</a>
<a name="ln4029"> </a>
<a name="ln4030">      if (hook) {</a>
<a name="ln4031">            if (hookHeight &lt; 0.0) {</a>
<a name="ln4032">                  lineEnd = &quot;up&quot;;</a>
<a name="ln4033">                  hookHeight *= -1.0;</a>
<a name="ln4034">                  }</a>
<a name="ln4035">            else</a>
<a name="ln4036">                  lineEnd = &quot;down&quot;;</a>
<a name="ln4037">            rest += QString(&quot; end-length=\&quot;%1\&quot;&quot;).arg(hookHeight * 10);</a>
<a name="ln4038">            }</a>
<a name="ln4039"> </a>
<a name="ln4040">      rest += positioningAttributes(tl, tl-&gt;tick() == tick);</a>
<a name="ln4041"> </a>
<a name="ln4042">      directionTag(_xml, _attr, tl);</a>
<a name="ln4043"> </a>
<a name="ln4044">      if (!tl-&gt;beginText().isEmpty() &amp;&amp; tl-&gt;tick() == tick) {</a>
<a name="ln4045">            _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln4046">            _xml.tag(&quot;words&quot;, tl-&gt;beginText());</a>
<a name="ln4047">            _xml.etag();</a>
<a name="ln4048">            }</a>
<a name="ln4049"> </a>
<a name="ln4050">      _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln4051">      if (isDashes)</a>
<a name="ln4052">            _xml.tagE(QString(&quot;dashes type=\&quot;%1\&quot; number=\&quot;%2\&quot;&quot;).arg(type, QString::number(n + 1)));</a>
<a name="ln4053">      else</a>
<a name="ln4054">            _xml.tagE(QString(&quot;bracket type=\&quot;%1\&quot; number=\&quot;%2\&quot; line-end=\&quot;%3\&quot;%4&quot;).arg(type, QString::number(n + 1), lineEnd, rest));</a>
<a name="ln4055">      _xml.etag();</a>
<a name="ln4056"> </a>
<a name="ln4057">      if (!tl-&gt;endText().isEmpty() &amp;&amp; tl-&gt;tick() != tick) {</a>
<a name="ln4058">            _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln4059">            _xml.tag(&quot;words&quot;, tl-&gt;endText());</a>
<a name="ln4060">            _xml.etag();</a>
<a name="ln4061">            }</a>
<a name="ln4062"> </a>
<a name="ln4063">      /*</a>
<a name="ln4064">      if (offs)</a>
<a name="ln4065">            xml.tag(&quot;offset&quot;, offs);</a>
<a name="ln4066">      */</a>
<a name="ln4067"> </a>
<a name="ln4068">      directionETag(_xml, staff);</a>
<a name="ln4069">      }</a>
<a name="ln4070"> </a>
<a name="ln4071">//---------------------------------------------------------</a>
<a name="ln4072">//   dynamic</a>
<a name="ln4073">//---------------------------------------------------------</a>
<a name="ln4074"> </a>
<a name="ln4075">// In MuseScore dynamics are essentially user-defined texts, therefore the ones</a>
<a name="ln4076">// supported by MusicXML need to be filtered out. Everything not recognized</a>
<a name="ln4077">// as MusicXML dynamics is written as other-dynamics.</a>
<a name="ln4078"> </a>
<a name="ln4079">void ExportMusicXml::dynamic(Dynamic const* const dyn, int staff)</a>
<a name="ln4080">      {</a>
<a name="ln4081">      QSet&lt;QString&gt; set; // the valid MusicXML dynamics</a>
<a name="ln4082">      set &lt;&lt; &quot;f&quot; &lt;&lt; &quot;ff&quot; &lt;&lt; &quot;fff&quot; &lt;&lt; &quot;ffff&quot; &lt;&lt; &quot;fffff&quot; &lt;&lt; &quot;ffffff&quot;</a>
<a name="ln4083">          &lt;&lt; &quot;fp&quot; &lt;&lt; &quot;fz&quot;</a>
<a name="ln4084">          &lt;&lt; &quot;mf&quot; &lt;&lt; &quot;mp&quot;</a>
<a name="ln4085">          &lt;&lt; &quot;p&quot; &lt;&lt; &quot;pp&quot; &lt;&lt; &quot;ppp&quot; &lt;&lt; &quot;pppp&quot; &lt;&lt; &quot;ppppp&quot; &lt;&lt; &quot;pppppp&quot;</a>
<a name="ln4086">          &lt;&lt; &quot;rf&quot; &lt;&lt; &quot;rfz&quot;</a>
<a name="ln4087">          &lt;&lt; &quot;sf&quot; &lt;&lt; &quot;sffz&quot; &lt;&lt; &quot;sfp&quot; &lt;&lt; &quot;sfpp&quot; &lt;&lt; &quot;sfz&quot;;</a>
<a name="ln4088"> </a>
<a name="ln4089">      directionTag(_xml, _attr, dyn);</a>
<a name="ln4090"> </a>
<a name="ln4091">      _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln4092"> </a>
<a name="ln4093">      QString tagName = &quot;dynamics&quot;;</a>
<a name="ln4094">      tagName += positioningAttributes(dyn);</a>
<a name="ln4095">      _xml.stag(tagName);</a>
<a name="ln4096">      const QString dynTypeName = dyn-&gt;dynamicTypeName();</a>
<a name="ln4097"> </a>
<a name="ln4098">      if (set.contains(dynTypeName)) {</a>
<a name="ln4099">            _xml.tagE(dynTypeName);</a>
<a name="ln4100">            }</a>
<a name="ln4101">      else if (dynTypeName != &quot;&quot;) {</a>
<a name="ln4102">            std::map&lt;ushort, QChar&gt; map;</a>
<a name="ln4103">            map[0xE520] = 'p';</a>
<a name="ln4104">            map[0xE521] = 'm';</a>
<a name="ln4105">            map[0xE522] = 'f';</a>
<a name="ln4106">            map[0xE523] = 'r';</a>
<a name="ln4107">            map[0xE524] = 's';</a>
<a name="ln4108">            map[0xE525] = 'z';</a>
<a name="ln4109">            map[0xE526] = 'n';</a>
<a name="ln4110"> </a>
<a name="ln4111">            QString dynText = dynTypeName;</a>
<a name="ln4112">            if (dyn-&gt;dynamicType() == Dynamic::Type::OTHER)</a>
<a name="ln4113">                  dynText = dyn-&gt;plainText();</a>
<a name="ln4114"> </a>
<a name="ln4115">            // collect consecutive runs of either dynamics glyphs</a>
<a name="ln4116">            // or other characters and write the runs.</a>
<a name="ln4117">            QString text;</a>
<a name="ln4118">            bool inDynamicsSym = false;</a>
<a name="ln4119">            for (const auto ch : dynText) {</a>
<a name="ln4120">                  const auto it = map.find(ch.unicode());</a>
<a name="ln4121">                  if (it != map.end()) {</a>
<a name="ln4122">                        // found a SMUFL single letter dynamics glyph</a>
<a name="ln4123">                        if (!inDynamicsSym) {</a>
<a name="ln4124">                              if (text != &quot;&quot;) {</a>
<a name="ln4125">                                    _xml.tag(&quot;other-dynamics&quot;, text);</a>
<a name="ln4126">                                    text = &quot;&quot;;</a>
<a name="ln4127">                                    }</a>
<a name="ln4128">                              inDynamicsSym = true;</a>
<a name="ln4129">                              }</a>
<a name="ln4130">                        text += it-&gt;second;</a>
<a name="ln4131">                        }</a>
<a name="ln4132">                  else {</a>
<a name="ln4133">                        // found a non-dynamics character</a>
<a name="ln4134">                        if (inDynamicsSym) {</a>
<a name="ln4135">                              if (text != &quot;&quot;) {</a>
<a name="ln4136">                                    if (set.contains(text))</a>
<a name="ln4137">                                          _xml.tagE(text);</a>
<a name="ln4138">                                    else</a>
<a name="ln4139">                                          _xml.tag(&quot;other-dynamics&quot;, text);</a>
<a name="ln4140">                                    text = &quot;&quot;;</a>
<a name="ln4141">                                    }</a>
<a name="ln4142">                              inDynamicsSym = false;</a>
<a name="ln4143">                              }</a>
<a name="ln4144">                        text += ch;</a>
<a name="ln4145">                        }</a>
<a name="ln4146">                  }</a>
<a name="ln4147">            if (text != &quot;&quot;) {</a>
<a name="ln4148">                  if (inDynamicsSym &amp;&amp; set.contains(text))</a>
<a name="ln4149">                        _xml.tagE(text);</a>
<a name="ln4150">                  else</a>
<a name="ln4151">                        _xml.tag(&quot;other-dynamics&quot;, text);</a>
<a name="ln4152">                  }</a>
<a name="ln4153">            }</a>
<a name="ln4154"> </a>
<a name="ln4155">      _xml.etag();</a>
<a name="ln4156"> </a>
<a name="ln4157">      _xml.etag();</a>
<a name="ln4158"> </a>
<a name="ln4159">      const auto offset = calculateTimeDeltaInDivisions(dyn-&gt;tick(), tick(), div);</a>
<a name="ln4160">      if (offset)</a>
<a name="ln4161">            _xml.tag(&quot;offset&quot;, offset);</a>
<a name="ln4162"> </a>
<a name="ln4163">      if (staff)</a>
<a name="ln4164">            _xml.tag(&quot;staff&quot;, staff);</a>
<a name="ln4165"> </a>
<a name="ln4166">      if (dyn-&gt;velocity() &gt; 0)</a>
<a name="ln4167">            _xml.tagE(QString(&quot;sound dynamics=\&quot;%1\&quot;&quot;).arg(QString::number(dyn-&gt;velocity() * 100.0 / 90.0, 'f', 2)));</a>
<a name="ln4168"> </a>
<a name="ln4169">      _xml.etag();</a>
<a name="ln4170">      }</a>
<a name="ln4171"> </a>
<a name="ln4172">//---------------------------------------------------------</a>
<a name="ln4173">//   symbol</a>
<a name="ln4174">//---------------------------------------------------------</a>
<a name="ln4175"> </a>
<a name="ln4176">// TODO: remove dependency on symbol name and replace by a more stable interface</a>
<a name="ln4177">// changes in sym.cpp r2494 broke MusicXML export of pedals (again)</a>
<a name="ln4178"> </a>
<a name="ln4179">void ExportMusicXml::symbol(Symbol const* const sym, int staff)</a>
<a name="ln4180">      {</a>
<a name="ln4181">      QString name = Sym::id2name(sym-&gt;sym());</a>
<a name="ln4182">      QString mxmlName = &quot;&quot;;</a>
<a name="ln4183">      if (name == &quot;keyboardPedalPed&quot;)</a>
<a name="ln4184">            mxmlName = &quot;pedal type=\&quot;start\&quot;&quot;;</a>
<a name="ln4185">      else if (name == &quot;keyboardPedalUp&quot;)</a>
<a name="ln4186">            mxmlName = &quot;pedal type=\&quot;stop\&quot;&quot;;</a>
<a name="ln4187">      else {</a>
<a name="ln4188">            qDebug(&quot;ExportMusicXml::symbol(): %s not supported&quot;, qPrintable(name));</a>
<a name="ln4189">            return;</a>
<a name="ln4190">            }</a>
<a name="ln4191">      directionTag(_xml, _attr, sym);</a>
<a name="ln4192">      mxmlName += positioningAttributes(sym);</a>
<a name="ln4193">      _xml.stag(&quot;direction-type&quot;);</a>
<a name="ln4194">      _xml.tagE(mxmlName);</a>
<a name="ln4195">      _xml.etag();</a>
<a name="ln4196">      const auto offset = calculateTimeDeltaInDivisions(sym-&gt;tick(), tick(), div);</a>
<a name="ln4197">      if (offset)</a>
<a name="ln4198">            _xml.tag(&quot;offset&quot;, offset);</a>
<a name="ln4199">      directionETag(_xml, staff);</a>
<a name="ln4200">      }</a>
<a name="ln4201"> </a>
<a name="ln4202">//---------------------------------------------------------</a>
<a name="ln4203">//   lyrics</a>
<a name="ln4204">//---------------------------------------------------------</a>
<a name="ln4205"> </a>
<a name="ln4206">void ExportMusicXml::lyrics(const std::vector&lt;Lyrics*&gt;* ll, const int trk)</a>
<a name="ln4207">      {</a>
<a name="ln4208">      for (const Lyrics* l :* ll) {</a>
<a name="ln4209">            if (l &amp;&amp; !l-&gt;xmlText().isEmpty()) {</a>
<a name="ln4210">                  if ((l)-&gt;track() == trk) {</a>
<a name="ln4211">                        QString lyricXml = QString(&quot;lyric number=\&quot;%1\&quot;&quot;).arg((l)-&gt;no() + 1);</a>
<a name="ln4212">                        lyricXml += color2xml(l);</a>
<a name="ln4213">                        lyricXml += positioningAttributes(l);</a>
<a name="ln4214">                        _xml.stag(lyricXml);</a>
<a name="ln4215">                        Lyrics::Syllabic syl = (l)-&gt;syllabic();</a>
<a name="ln4216">                        QString s = &quot;&quot;;</a>
<a name="ln4217">                        switch (syl) {</a>
<a name="ln4218">                              case Lyrics::Syllabic::SINGLE: s = &quot;single&quot;; break;</a>
<a name="ln4219">                              case Lyrics::Syllabic::BEGIN:  s = &quot;begin&quot;;  break;</a>
<a name="ln4220">                              case Lyrics::Syllabic::END:    s = &quot;end&quot;;    break;</a>
<a name="ln4221">                              case Lyrics::Syllabic::MIDDLE: s = &quot;middle&quot;; break;</a>
<a name="ln4222">                              default:</a>
<a name="ln4223">                                    qDebug(&quot;unknown syllabic %d&quot;, int(syl));</a>
<a name="ln4224">                              }</a>
<a name="ln4225">                        _xml.tag(&quot;syllabic&quot;, s);</a>
<a name="ln4226">                        QString attr; // TODO TBD</a>
<a name="ln4227">                        // set the default words format</a>
<a name="ln4228">                        const QString mtf       = _score-&gt;styleSt(Sid::MusicalTextFont);</a>
<a name="ln4229">                        CharFormat defFmt;</a>
<a name="ln4230">                        defFmt.setFontFamily(_score-&gt;styleSt(Sid::lyricsEvenFontFace));</a>
<a name="ln4231">                        defFmt.setFontSize(_score-&gt;styleD(Sid::lyricsOddFontSize));</a>
<a name="ln4232">                        // write formatted</a>
<a name="ln4233">                        MScoreTextToMXML mttm(&quot;text&quot;, attr, defFmt, mtf);</a>
<a name="ln4234">                        mttm.writeTextFragments(l-&gt;fragmentList(), _xml);</a>
<a name="ln4235">#if 0</a>
<a name="ln4236">                        /*</a>
<a name="ln4237">                         Temporarily disabled because it doesn't work yet (and thus breaks the regression test).</a>
<a name="ln4238">                         See MusicXml::xmlLyric: &quot;// TODO-WS      l-&gt;setTick(tick);&quot;</a>
<a name="ln4239">                        if((l)-&gt;endTick() &gt; 0)</a>
<a name="ln4240">                              xml.tagE(&quot;extend&quot;);</a>
<a name="ln4241">                        */</a>
<a name="ln4242">#else</a>
<a name="ln4243">                        if (l-&gt;ticks().isNotZero())</a>
<a name="ln4244">                              _xml.tagE(&quot;extend&quot;);</a>
<a name="ln4245">#endif</a>
<a name="ln4246">                        _xml.etag();</a>
<a name="ln4247">                        }</a>
<a name="ln4248">                  }</a>
<a name="ln4249">            }</a>
<a name="ln4250">      }</a>
<a name="ln4251"> </a>
<a name="ln4252">//---------------------------------------------------------</a>
<a name="ln4253">//   directionJump -- write jump</a>
<a name="ln4254">//---------------------------------------------------------</a>
<a name="ln4255"> </a>
<a name="ln4256">// LVIFIX: TODO coda and segno should be numbered uniquely</a>
<a name="ln4257"> </a>
<a name="ln4258">static void directionJump(XmlWriter&amp; xml, const Jump* const jp)</a>
<a name="ln4259">      {</a>
<a name="ln4260">      Jump::Type jtp = jp-&gt;jumpType();</a>
<a name="ln4261">      QString words = &quot;&quot;;</a>
<a name="ln4262">      QString type  = &quot;&quot;;</a>
<a name="ln4263">      QString sound = &quot;&quot;;</a>
<a name="ln4264">      if (jtp == Jump::Type::DC) {</a>
<a name="ln4265">            if (jp-&gt;xmlText() == &quot;&quot;)</a>
<a name="ln4266">                  words = &quot;D.C.&quot;;</a>
<a name="ln4267">            else</a>
<a name="ln4268">                  words = jp-&gt;xmlText();</a>
<a name="ln4269">            sound = &quot;dacapo=\&quot;yes\&quot;&quot;;</a>
<a name="ln4270">            }</a>
<a name="ln4271">      else if (jtp == Jump::Type::DC_AL_FINE) {</a>
<a name="ln4272">            if (jp-&gt;xmlText() == &quot;&quot;)</a>
<a name="ln4273">                  words = &quot;D.C. al Fine&quot;;</a>
<a name="ln4274">            else</a>
<a name="ln4275">                  words = jp-&gt;xmlText();</a>
<a name="ln4276">            sound = &quot;dacapo=\&quot;yes\&quot;&quot;;</a>
<a name="ln4277">            }</a>
<a name="ln4278">      else if (jtp == Jump::Type::DC_AL_CODA) {</a>
<a name="ln4279">            if (jp-&gt;xmlText() == &quot;&quot;)</a>
<a name="ln4280">                  words = &quot;D.C. al Coda&quot;;</a>
<a name="ln4281">            else</a>
<a name="ln4282">                  words = jp-&gt;xmlText();</a>
<a name="ln4283">            sound = &quot;dacapo=\&quot;yes\&quot;&quot;;</a>
<a name="ln4284">            }</a>
<a name="ln4285">      else if (jtp == Jump::Type::DS_AL_CODA) {</a>
<a name="ln4286">            if (jp-&gt;xmlText() == &quot;&quot;)</a>
<a name="ln4287">                  words = &quot;D.S. al Coda&quot;;</a>
<a name="ln4288">            else</a>
<a name="ln4289">                  words = jp-&gt;xmlText();</a>
<a name="ln4290">            if (jp-&gt;jumpTo() == &quot;&quot;)</a>
<a name="ln4291">                  sound = &quot;dalsegno=\&quot;1\&quot;&quot;;</a>
<a name="ln4292">            else</a>
<a name="ln4293">                  sound = &quot;dalsegno=\&quot;&quot; + jp-&gt;jumpTo() + &quot;\&quot;&quot;;</a>
<a name="ln4294">            }</a>
<a name="ln4295">      else if (jtp == Jump::Type::DS_AL_FINE) {</a>
<a name="ln4296">            if (jp-&gt;xmlText() == &quot;&quot;)</a>
<a name="ln4297">                  words = &quot;D.S. al Fine&quot;;</a>
<a name="ln4298">            else</a>
<a name="ln4299">                  words = jp-&gt;xmlText();</a>
<a name="ln4300">            if (jp-&gt;jumpTo() == &quot;&quot;)</a>
<a name="ln4301">                  sound = &quot;dalsegno=\&quot;1\&quot;&quot;;</a>
<a name="ln4302">            else</a>
<a name="ln4303">                  sound = &quot;dalsegno=\&quot;&quot; + jp-&gt;jumpTo() + &quot;\&quot;&quot;;</a>
<a name="ln4304">            }</a>
<a name="ln4305">      else if (jtp == Jump::Type::DS) {</a>
<a name="ln4306">            words = &quot;D.S.&quot;;</a>
<a name="ln4307">            if (jp-&gt;jumpTo() == &quot;&quot;)</a>
<a name="ln4308">                  sound = &quot;dalsegno=\&quot;1\&quot;&quot;;</a>
<a name="ln4309">            else</a>
<a name="ln4310">                  sound = &quot;dalsegno=\&quot;&quot; + jp-&gt;jumpTo() + &quot;\&quot;&quot;;</a>
<a name="ln4311">            }</a>
<a name="ln4312">      else</a>
<a name="ln4313">            qDebug(&quot;jump type=%d not implemented&quot;, static_cast&lt;int&gt;(jtp));</a>
<a name="ln4314"> </a>
<a name="ln4315">      if (sound != &quot;&quot;) {</a>
<a name="ln4316">            xml.stag(QString(&quot;direction placement=\&quot;%1\&quot;&quot;).arg((jp-&gt;placement() == Placement::BELOW ) ? &quot;below&quot; : &quot;above&quot;));</a>
<a name="ln4317">            xml.stag(&quot;direction-type&quot;);</a>
<a name="ln4318">            QString positioning = positioningAttributes(jp);</a>
<a name="ln4319">            if (type != &quot;&quot;) xml.tagE(type + positioning);</a>
<a name="ln4320">            if (words != &quot;&quot;) xml.tag(&quot;words&quot; + positioning, words);</a>
<a name="ln4321">            xml.etag();</a>
<a name="ln4322">            if (sound != &quot;&quot;) xml.tagE(QString(&quot;sound &quot;) + sound);</a>
<a name="ln4323">            xml.etag();</a>
<a name="ln4324">            }</a>
<a name="ln4325">      }</a>
<a name="ln4326"> </a>
<a name="ln4327">//---------------------------------------------------------</a>
<a name="ln4328">//   directionMarker -- write marker</a>
<a name="ln4329">//---------------------------------------------------------</a>
<a name="ln4330"> </a>
<a name="ln4331">static void directionMarker(XmlWriter&amp; xml, const Marker* const m)</a>
<a name="ln4332">      {</a>
<a name="ln4333">      Marker::Type mtp = m-&gt;markerType();</a>
<a name="ln4334">      QString words = &quot;&quot;;</a>
<a name="ln4335">      QString type  = &quot;&quot;;</a>
<a name="ln4336">      QString sound = &quot;&quot;;</a>
<a name="ln4337">      if (mtp == Marker::Type::CODA) {</a>
<a name="ln4338">            type = &quot;coda&quot;;</a>
<a name="ln4339">            if (m-&gt;label() == &quot;&quot;)</a>
<a name="ln4340">                  sound = &quot;coda=\&quot;1\&quot;&quot;;</a>
<a name="ln4341">            else</a>
<a name="ln4342">                  // LVIFIX hack: force label to &quot;coda&quot; to match to coda label</a>
<a name="ln4343">                  // sound = &quot;coda=\&quot;&quot; + m-&gt;label() + &quot;\&quot;&quot;;</a>
<a name="ln4344">                  sound = &quot;coda=\&quot;coda\&quot;&quot;;</a>
<a name="ln4345">            }</a>
<a name="ln4346">      else if (mtp == Marker::Type::SEGNO) {</a>
<a name="ln4347">            type = &quot;segno&quot;;</a>
<a name="ln4348">            if (m-&gt;label() == &quot;&quot;)</a>
<a name="ln4349">                  sound = &quot;segno=\&quot;1\&quot;&quot;;</a>
<a name="ln4350">            else</a>
<a name="ln4351">                  sound = &quot;segno=\&quot;&quot; + m-&gt;label() + &quot;\&quot;&quot;;</a>
<a name="ln4352">            }</a>
<a name="ln4353">      else if (mtp == Marker::Type::FINE) {</a>
<a name="ln4354">            words = &quot;Fine&quot;;</a>
<a name="ln4355">            sound = &quot;fine=\&quot;yes\&quot;&quot;;</a>
<a name="ln4356">            }</a>
<a name="ln4357">      else if (mtp == Marker::Type::TOCODA) {</a>
<a name="ln4358">            if (m-&gt;xmlText() == &quot;&quot;)</a>
<a name="ln4359">                  words = &quot;To Coda&quot;;</a>
<a name="ln4360">            else</a>
<a name="ln4361">                  words = m-&gt;xmlText();</a>
<a name="ln4362">            if (m-&gt;label() == &quot;&quot;)</a>
<a name="ln4363">                  sound = &quot;tocoda=\&quot;1\&quot;&quot;;</a>
<a name="ln4364">            else</a>
<a name="ln4365">                  sound = &quot;tocoda=\&quot;&quot; + m-&gt;label() + &quot;\&quot;&quot;;</a>
<a name="ln4366">            }</a>
<a name="ln4367">      else</a>
<a name="ln4368">            qDebug(&quot;marker type=%d not implemented&quot;, int(mtp));</a>
<a name="ln4369"> </a>
<a name="ln4370">      if (sound != &quot;&quot;) {</a>
<a name="ln4371">            xml.stag(QString(&quot;direction placement=\&quot;%1\&quot;&quot;).arg((m-&gt;placement() == Placement::BELOW ) ? &quot;below&quot; : &quot;above&quot;));</a>
<a name="ln4372">            xml.stag(&quot;direction-type&quot;);</a>
<a name="ln4373">            QString positioning = positioningAttributes(m);</a>
<a name="ln4374">            if (type != &quot;&quot;) xml.tagE(type + positioning);</a>
<a name="ln4375">            if (words != &quot;&quot;) xml.tag(&quot;words&quot; + positioning, words);</a>
<a name="ln4376">            xml.etag();</a>
<a name="ln4377">            if (sound != &quot;&quot;) xml.tagE(QString(&quot;sound &quot;) + sound);</a>
<a name="ln4378">            xml.etag();</a>
<a name="ln4379">            }</a>
<a name="ln4380">      }</a>
<a name="ln4381"> </a>
<a name="ln4382">//---------------------------------------------------------</a>
<a name="ln4383">//  findTrackForAnnotations</a>
<a name="ln4384">//---------------------------------------------------------</a>
<a name="ln4385"> </a>
<a name="ln4386">// An annotation is attached to the staff, with track set</a>
<a name="ln4387">// to the lowest track in the staff. Find a track for it</a>
<a name="ln4388">// (the lowest track in this staff that has a chord or rest)</a>
<a name="ln4389"> </a>
<a name="ln4390">static int findTrackForAnnotations(int track, Segment* seg)</a>
<a name="ln4391">      {</a>
<a name="ln4392">      if (seg-&gt;segmentType() != SegmentType::ChordRest)</a>
<a name="ln4393">            return -1;</a>
<a name="ln4394"> </a>
<a name="ln4395">      int staff = track / VOICES;</a>
<a name="ln4396">      int strack = staff * VOICES;      // start track of staff containing track</a>
<a name="ln4397">      int etrack = strack + VOICES;     // end track of staff containing track + 1</a>
<a name="ln4398"> </a>
<a name="ln4399">      for (int i = strack; i &lt; etrack; i++)</a>
<a name="ln4400">            if (seg-&gt;element(i))</a>
<a name="ln4401">                  return i;</a>
<a name="ln4402"> </a>
<a name="ln4403">      return -1;</a>
<a name="ln4404">      }</a>
<a name="ln4405"> </a>
<a name="ln4406">//---------------------------------------------------------</a>
<a name="ln4407">//  repeatAtMeasureStart -- write repeats at begin of measure</a>
<a name="ln4408">//---------------------------------------------------------</a>
<a name="ln4409"> </a>
<a name="ln4410">static void repeatAtMeasureStart(XmlWriter&amp; xml, Attributes&amp; attr, const Measure* const m, int strack, int etrack, int track)</a>
<a name="ln4411">      {</a>
<a name="ln4412">      // loop over all segments</a>
<a name="ln4413">      for (Element* e : m-&gt;el()) {</a>
<a name="ln4414">            int wtrack = -1; // track to write jump</a>
<a name="ln4415">            if (strack &lt;= e-&gt;track() &amp;&amp; e-&gt;track() &lt; etrack)</a>
<a name="ln4416">                  wtrack = findTrackForAnnotations(e-&gt;track(), m-&gt;first(SegmentType::ChordRest));</a>
<a name="ln4417">            if (track != wtrack)</a>
<a name="ln4418">                  continue;</a>
<a name="ln4419">            switch (e-&gt;type()) {</a>
<a name="ln4420">                  case ElementType::MARKER:</a>
<a name="ln4421">                        {</a>
<a name="ln4422">                        // filter out the markers at measure Start</a>
<a name="ln4423">                        const Marker* const mk = toMarker(e);</a>
<a name="ln4424">                        Marker::Type mtp = mk-&gt;markerType();</a>
<a name="ln4425">                        if (   mtp == Marker::Type::SEGNO</a>
<a name="ln4426">                               || mtp == Marker::Type::CODA</a>
<a name="ln4427">                               ) {</a>
<a name="ln4428">                              qDebug(&quot; -&gt; handled&quot;);</a>
<a name="ln4429">                              attr.doAttr(xml, false);</a>
<a name="ln4430">                              directionMarker(xml, mk);</a>
<a name="ln4431">                              }</a>
<a name="ln4432">                        else if (   mtp == Marker::Type::FINE</a>
<a name="ln4433">                                    || mtp == Marker::Type::TOCODA</a>
<a name="ln4434">                                    ) {</a>
<a name="ln4435">                              // ignore</a>
<a name="ln4436">                              }</a>
<a name="ln4437">                        else {</a>
<a name="ln4438">                              qDebug(&quot;repeatAtMeasureStart: marker %d not implemented&quot;, int(mtp));</a>
<a name="ln4439">                              }</a>
<a name="ln4440">                        }</a>
<a name="ln4441">                        break;</a>
<a name="ln4442">                  default:</a>
<a name="ln4443">                        qDebug(&quot;repeatAtMeasureStart: direction type %s at tick %d not implemented&quot;,</a>
<a name="ln4444">                               Element::name(e-&gt;type()), m-&gt;tick().ticks());</a>
<a name="ln4445">                        break;</a>
<a name="ln4446">                  }</a>
<a name="ln4447">            }</a>
<a name="ln4448">      }</a>
<a name="ln4449"> </a>
<a name="ln4450">//---------------------------------------------------------</a>
<a name="ln4451">//  repeatAtMeasureStop -- write repeats at end of measure</a>
<a name="ln4452">//---------------------------------------------------------</a>
<a name="ln4453"> </a>
<a name="ln4454">static void repeatAtMeasureStop(XmlWriter&amp; xml, const Measure* const m, int strack, int etrack, int track)</a>
<a name="ln4455">      {</a>
<a name="ln4456">      for (Element* e : m-&gt;el()) {</a>
<a name="ln4457">            int wtrack = -1; // track to write jump</a>
<a name="ln4458">            if (strack &lt;= e-&gt;track() &amp;&amp; e-&gt;track() &lt; etrack)</a>
<a name="ln4459">                  wtrack = findTrackForAnnotations(e-&gt;track(), m-&gt;first(SegmentType::ChordRest));</a>
<a name="ln4460">            if (track != wtrack)</a>
<a name="ln4461">                  continue;</a>
<a name="ln4462">            switch (e-&gt;type()) {</a>
<a name="ln4463">                  case ElementType::MARKER:</a>
<a name="ln4464">                        {</a>
<a name="ln4465">                        // filter out the markers at measure stop</a>
<a name="ln4466">                        const Marker* const mk = toMarker(e);</a>
<a name="ln4467">                        Marker::Type mtp = mk-&gt;markerType();</a>
<a name="ln4468">                        if (mtp == Marker::Type::FINE || mtp == Marker::Type::TOCODA) {</a>
<a name="ln4469">                              directionMarker(xml, mk);</a>
<a name="ln4470">                              }</a>
<a name="ln4471">                        else if (mtp == Marker::Type::SEGNO || mtp == Marker::Type::CODA) {</a>
<a name="ln4472">                              // ignore</a>
<a name="ln4473">                              }</a>
<a name="ln4474">                        else {</a>
<a name="ln4475">                              qDebug(&quot;repeatAtMeasureStop: marker %d not implemented&quot;, int(mtp));</a>
<a name="ln4476">                              }</a>
<a name="ln4477">                        }</a>
<a name="ln4478">                        break;</a>
<a name="ln4479">                  case ElementType::JUMP:</a>
<a name="ln4480">                        directionJump(xml, toJump(e));</a>
<a name="ln4481">                        break;</a>
<a name="ln4482">                  default:</a>
<a name="ln4483">                        qDebug(&quot;repeatAtMeasureStop: direction type %s at tick %d not implemented&quot;,</a>
<a name="ln4484">                               Element::name(e-&gt;type()), m-&gt;tick().ticks());</a>
<a name="ln4485">                        break;</a>
<a name="ln4486">                  }</a>
<a name="ln4487">            }</a>
<a name="ln4488">      }</a>
<a name="ln4489"> </a>
<a name="ln4490">//---------------------------------------------------------</a>
<a name="ln4491">//  work -- write the &lt;work&gt; element</a>
<a name="ln4492">//  note that order must be work-number, work-title</a>
<a name="ln4493">//  also write &lt;movement-number&gt; and &lt;movement-title&gt;</a>
<a name="ln4494">//  data is taken from the score metadata instead of the Text elements</a>
<a name="ln4495">//---------------------------------------------------------</a>
<a name="ln4496"> </a>
<a name="ln4497">void ExportMusicXml::work(const MeasureBase* /*measure*/)</a>
<a name="ln4498">      {</a>
<a name="ln4499">      QString workTitle  = _score-&gt;metaTag(&quot;workTitle&quot;);</a>
<a name="ln4500">      QString workNumber = _score-&gt;metaTag(&quot;workNumber&quot;);</a>
<a name="ln4501">      if (!(workTitle.isEmpty() &amp;&amp; workNumber.isEmpty())) {</a>
<a name="ln4502">            _xml.stag(&quot;work&quot;);</a>
<a name="ln4503">            if (!workNumber.isEmpty())</a>
<a name="ln4504">                  _xml.tag(&quot;work-number&quot;, workNumber);</a>
<a name="ln4505">            if (!workTitle.isEmpty())</a>
<a name="ln4506">                  _xml.tag(&quot;work-title&quot;, workTitle);</a>
<a name="ln4507">            _xml.etag();</a>
<a name="ln4508">            }</a>
<a name="ln4509">      if (!_score-&gt;metaTag(&quot;movementNumber&quot;).isEmpty())</a>
<a name="ln4510">            _xml.tag(&quot;movement-number&quot;, _score-&gt;metaTag(&quot;movementNumber&quot;));</a>
<a name="ln4511">      if (!_score-&gt;metaTag(&quot;movementTitle&quot;).isEmpty())</a>
<a name="ln4512">            _xml.tag(&quot;movement-title&quot;, _score-&gt;metaTag(&quot;movementTitle&quot;));</a>
<a name="ln4513">      }</a>
<a name="ln4514"> </a>
<a name="ln4515">#if 0</a>
<a name="ln4516">//---------------------------------------------------------</a>
<a name="ln4517">//   elementRighter // used for harmony order</a>
<a name="ln4518">//---------------------------------------------------------</a>
<a name="ln4519"> </a>
<a name="ln4520">static bool elementRighter(const Element* e1, const Element* e2)</a>
<a name="ln4521">      {</a>
<a name="ln4522">      return e1-&gt;x() &lt; e2-&gt;x();</a>
<a name="ln4523">      }</a>
<a name="ln4524">#endif</a>
<a name="ln4525"> </a>
<a name="ln4526">//---------------------------------------------------------</a>
<a name="ln4527">//  measureStyle -- write measure-style</a>
<a name="ln4528">//---------------------------------------------------------</a>
<a name="ln4529"> </a>
<a name="ln4530">// this is done at the first measure of a multi-meaure rest</a>
<a name="ln4531">// note: for a normal measure, mmRest1 is the measure itself,</a>
<a name="ln4532">// for a multi-meaure rest, it is the replacing measure</a>
<a name="ln4533"> </a>
<a name="ln4534">static void measureStyle(XmlWriter&amp; xml, Attributes&amp; attr, const Measure* const m)</a>
<a name="ln4535">      {</a>
<a name="ln4536">      const Measure* mmR1 = m-&gt;mmRest1();</a>
<a name="ln4537">      if (m != mmR1 &amp;&amp; m == mmR1-&gt;mmRestFirst()) {</a>
<a name="ln4538">            attr.doAttr(xml, true);</a>
<a name="ln4539">            xml.stag(&quot;measure-style&quot;);</a>
<a name="ln4540">            xml.tag(&quot;multiple-rest&quot;, mmR1-&gt;mmRestCount());</a>
<a name="ln4541">            xml.etag();</a>
<a name="ln4542">            }</a>
<a name="ln4543">      }</a>
<a name="ln4544"> </a>
<a name="ln4545">//---------------------------------------------------------</a>
<a name="ln4546">//  findFretDiagram</a>
<a name="ln4547">//---------------------------------------------------------</a>
<a name="ln4548"> </a>
<a name="ln4549">static const FretDiagram* findFretDiagram(int strack, int etrack, int track, Segment* seg)</a>
<a name="ln4550">      {</a>
<a name="ln4551">      if (seg-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln4552">            for (const Element* e : seg-&gt;annotations()) {</a>
<a name="ln4553"> </a>
<a name="ln4554">                  int wtrack = -1; // track to write annotation</a>
<a name="ln4555"> </a>
<a name="ln4556">                  if (strack &lt;= e-&gt;track() &amp;&amp; e-&gt;track() &lt; etrack)</a>
<a name="ln4557">                        wtrack = findTrackForAnnotations(e-&gt;track(), seg);</a>
<a name="ln4558"> </a>
<a name="ln4559">                  if (track == wtrack &amp;&amp; e-&gt;type() == ElementType::FRET_DIAGRAM)</a>
<a name="ln4560">                        return static_cast&lt;const FretDiagram*&gt;(e);</a>
<a name="ln4561">                  }</a>
<a name="ln4562">            }</a>
<a name="ln4563">      return 0;</a>
<a name="ln4564">      }</a>
<a name="ln4565"> </a>
<a name="ln4566">//---------------------------------------------------------</a>
<a name="ln4567">//  commonAnnotations</a>
<a name="ln4568">//---------------------------------------------------------</a>
<a name="ln4569"> </a>
<a name="ln4570">static bool commonAnnotations(ExportMusicXml* exp, const Element* e, int sstaff)</a>
<a name="ln4571">      {</a>
<a name="ln4572">      bool instrChangeHandled  = false;</a>
<a name="ln4573"> </a>
<a name="ln4574">      // note: write the changed instrument details (transposition) here,</a>
<a name="ln4575">      // optionally writing the associated staff text is done below</a>
<a name="ln4576">      if (e-&gt;isInstrumentChange()) {</a>
<a name="ln4577">            const auto instrChange = toInstrumentChange(e);</a>
<a name="ln4578">            exp-&gt;writeInstrumentDetails(instrChange-&gt;instrument());</a>
<a name="ln4579">            instrChangeHandled = true;</a>
<a name="ln4580">            }</a>
<a name="ln4581"> </a>
<a name="ln4582">      if (e-&gt;isSymbol())</a>
<a name="ln4583">            exp-&gt;symbol(toSymbol(e), sstaff);</a>
<a name="ln4584">      else if (e-&gt;isTempoText())</a>
<a name="ln4585">            exp-&gt;tempoText(toTempoText(e), sstaff);</a>
<a name="ln4586">      else if (e-&gt;isStaffText() || e-&gt;isSystemText() || e-&gt;isText() || (e-&gt;isInstrumentChange() &amp;&amp; e-&gt;visible()))</a>
<a name="ln4587">            exp-&gt;words(toTextBase(e), sstaff);</a>
<a name="ln4588">      else if (e-&gt;isDynamic())</a>
<a name="ln4589">            exp-&gt;dynamic(toDynamic(e), sstaff);</a>
<a name="ln4590">      else if (e-&gt;isRehearsalMark())</a>
<a name="ln4591">            exp-&gt;rehearsal(toRehearsalMark(e), sstaff);</a>
<a name="ln4592">      else</a>
<a name="ln4593">            return instrChangeHandled;</a>
<a name="ln4594"> </a>
<a name="ln4595">      return true;</a>
<a name="ln4596">      }</a>
<a name="ln4597"> </a>
<a name="ln4598">//---------------------------------------------------------</a>
<a name="ln4599">//  annotations</a>
<a name="ln4600">//---------------------------------------------------------</a>
<a name="ln4601"> </a>
<a name="ln4602">/*</a>
<a name="ln4603"> * Write annotations that are attached to chords or rests</a>
<a name="ln4604"> */</a>
<a name="ln4605"> </a>
<a name="ln4606">// In MuseScore, Element::FRET_DIAGRAM and Element::HARMONY are separate annotations,</a>
<a name="ln4607">// in MusicXML they are combined in the harmony element. This means they have to be matched.</a>
<a name="ln4608">// TODO: replace/repair current algorithm (which can only handle one FRET_DIAGRAM and one HARMONY)</a>
<a name="ln4609"> </a>
<a name="ln4610">static void annotations(ExportMusicXml* exp, int strack, int etrack, int track, int sstaff, Segment* seg)</a>
<a name="ln4611">      {</a>
<a name="ln4612">      if (seg-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln4613"> </a>
<a name="ln4614">            const FretDiagram* fd = findFretDiagram(strack, etrack, track, seg);</a>
<a name="ln4615">            // if (fd) qDebug(&quot;annotations seg %p found fretboard diagram %p&quot;, seg, fd);</a>
<a name="ln4616"> </a>
<a name="ln4617">            for (const Element* e : seg-&gt;annotations()) {</a>
<a name="ln4618"> </a>
<a name="ln4619">                  int wtrack = -1; // track to write annotation</a>
<a name="ln4620"> </a>
<a name="ln4621">                  if (strack &lt;= e-&gt;track() &amp;&amp; e-&gt;track() &lt; etrack)</a>
<a name="ln4622">                        wtrack = findTrackForAnnotations(e-&gt;track(), seg);</a>
<a name="ln4623"> </a>
<a name="ln4624">                  if (track == wtrack) {</a>
<a name="ln4625">                        if (commonAnnotations(exp, e, sstaff))</a>
<a name="ln4626">                              ;  // already handled</a>
<a name="ln4627">                        else if (e-&gt;isHarmony()) {</a>
<a name="ln4628">                              // qDebug(&quot;annotations seg %p found harmony %p&quot;, seg, e);</a>
<a name="ln4629">                              exp-&gt;harmony(toHarmony(e), fd);</a>
<a name="ln4630">                              fd = nullptr; // make sure to write only once ...</a>
<a name="ln4631">                              }</a>
<a name="ln4632">                        else if (e-&gt;isFermata() || e-&gt;isFiguredBass() || e-&gt;isFretDiagram() || e-&gt;isJump())</a>
<a name="ln4633">                              ;  // handled separately by chordAttributes(), figuredBass(), findFretDiagram() or ignored</a>
<a name="ln4634">                        else</a>
<a name="ln4635">                              qDebug(&quot;direction type %s at tick %d not implemented&quot;,</a>
<a name="ln4636">                                     Element::name(e-&gt;type()), seg-&gt;tick().ticks());</a>
<a name="ln4637">                        }</a>
<a name="ln4638">                  }</a>
<a name="ln4639">            if (fd)</a>
<a name="ln4640">                  // found fd but no harmony, cannot write (MusicXML would be invalid)</a>
<a name="ln4641">                  qDebug(&quot;seg %p found fretboard diagram %p w/o harmony: cannot write&quot;,</a>
<a name="ln4642">                         seg, fd);</a>
<a name="ln4643">            }</a>
<a name="ln4644">      }</a>
<a name="ln4645"> </a>
<a name="ln4646">//---------------------------------------------------------</a>
<a name="ln4647">//  figuredBass</a>
<a name="ln4648">//---------------------------------------------------------</a>
<a name="ln4649"> </a>
<a name="ln4650">static void figuredBass(XmlWriter&amp; xml, int strack, int etrack, int track, const ChordRest* cr, FigBassMap&amp; fbMap, int divisions)</a>
<a name="ln4651">      {</a>
<a name="ln4652">      Segment* seg = cr-&gt;segment();</a>
<a name="ln4653">      if (seg-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln4654">            for (const Element* e : seg-&gt;annotations()) {</a>
<a name="ln4655"> </a>
<a name="ln4656">                  int wtrack = -1; // track to write annotation</a>
<a name="ln4657"> </a>
<a name="ln4658">                  if (strack &lt;= e-&gt;track() &amp;&amp; e-&gt;track() &lt; etrack)</a>
<a name="ln4659">                        wtrack = findTrackForAnnotations(e-&gt;track(), seg);</a>
<a name="ln4660"> </a>
<a name="ln4661">                  if (track == wtrack) {</a>
<a name="ln4662">                        if (e-&gt;type() == ElementType::FIGURED_BASS) {</a>
<a name="ln4663">                              const FiguredBass* fb = dynamic_cast&lt;const FiguredBass*&gt;(e);</a>
<a name="ln4664">                              //qDebug(&quot;figuredbass() track %d seg %p fb %p seg %p tick %d ticks %d cr %p tick %d ticks %d&quot;,</a>
<a name="ln4665">                              //       track, seg, fb, fb-&gt;segment(), fb-&gt;segment()-&gt;tick(), fb-&gt;ticks(), cr, cr-&gt;tick(), cr-&gt;actualTicks());</a>
<a name="ln4666">                              bool extend = fb-&gt;ticks() &gt; cr-&gt;actualTicks();</a>
<a name="ln4667">                              if (extend) {</a>
<a name="ln4668">                                    //qDebug(&quot;figuredbass() extend to %d + %d = %d&quot;,</a>
<a name="ln4669">                                    //       cr-&gt;tick(), fb-&gt;ticks(), cr-&gt;tick() + fb-&gt;ticks());</a>
<a name="ln4670">                                    fbMap.insert(strack, fb);</a>
<a name="ln4671">                                    }</a>
<a name="ln4672">                              else</a>
<a name="ln4673">                                    fbMap.remove(strack);</a>
<a name="ln4674">                              const Fraction crEndTick = cr-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln4675">                              const Fraction fbEndTick = fb-&gt;segment()-&gt;tick() + fb-&gt;ticks();</a>
<a name="ln4676">                              const bool writeDuration = fb-&gt;ticks() &lt; cr-&gt;actualTicks();</a>
<a name="ln4677">                              fb-&gt;writeMusicXML(xml, true, crEndTick.ticks(), fbEndTick.ticks(),</a>
<a name="ln4678">                                                writeDuration, divisions);</a>
<a name="ln4679"> </a>
<a name="ln4680">                              // Check for changing figures under a single note (each figure stored in a separate segment)</a>
<a name="ln4681">                              for (Segment* segNext = seg-&gt;next(); segNext &amp;&amp; segNext-&gt;element(track) == NULL; segNext = segNext-&gt;next()) {</a>
<a name="ln4682">                                    for (Element* annot : segNext-&gt;annotations()) {</a>
<a name="ln4683">                                          if (annot-&gt;type() == ElementType::FIGURED_BASS &amp;&amp; annot-&gt;track() == track) {</a>
<a name="ln4684">                                                fb = dynamic_cast&lt;const FiguredBass*&gt;(annot);</a>
<a name="ln4685">                                                fb-&gt;writeMusicXML(xml, true, 0, 0, true, divisions);</a>
<a name="ln4686">                                                }</a>
<a name="ln4687">                                          }</a>
<a name="ln4688">                                    }</a>
<a name="ln4689">                              // no extend can be pending</a>
<a name="ln4690">                              return;</a>
<a name="ln4691">                              }</a>
<a name="ln4692">                        }</a>
<a name="ln4693">                  }</a>
<a name="ln4694">            // check for extend pending</a>
<a name="ln4695">            if (fbMap.contains(strack)) {</a>
<a name="ln4696">                  const FiguredBass* fb = fbMap.value(strack);</a>
<a name="ln4697">                  Fraction crEndTick = cr-&gt;tick() + cr-&gt;actualTicks();</a>
<a name="ln4698">                  Fraction fbEndTick = fb-&gt;segment()-&gt;tick() + fb-&gt;ticks();</a>
<a name="ln4699">                  bool writeDuration = fb-&gt;ticks() &lt; cr-&gt;actualTicks();</a>
<a name="ln4700">                  if (cr-&gt;tick() &lt; fbEndTick) {</a>
<a name="ln4701">                        //qDebug(&quot;figuredbass() at tick %d extend only&quot;, cr-&gt;tick());</a>
<a name="ln4702">                        fb-&gt;writeMusicXML(xml, false, crEndTick.ticks(), fbEndTick.ticks(), writeDuration, divisions);</a>
<a name="ln4703">                        }</a>
<a name="ln4704">                  if (fbEndTick &lt;= crEndTick) {</a>
<a name="ln4705">                        //qDebug(&quot;figuredbass() at tick %d extend done&quot;, cr-&gt;tick() + cr-&gt;actualTicks());</a>
<a name="ln4706">                        fbMap.remove(strack);</a>
<a name="ln4707">                        }</a>
<a name="ln4708">                  }</a>
<a name="ln4709">            }</a>
<a name="ln4710">      }</a>
<a name="ln4711"> </a>
<a name="ln4712">//---------------------------------------------------------</a>
<a name="ln4713">//  spannerStart</a>
<a name="ln4714">//---------------------------------------------------------</a>
<a name="ln4715"> </a>
<a name="ln4716">// for each spanner start:</a>
<a name="ln4717">// find start track</a>
<a name="ln4718">// find stop track</a>
<a name="ln4719">// if stop track &lt; start track</a>
<a name="ln4720">//   get data from list of already stopped spanners</a>
<a name="ln4721">// else</a>
<a name="ln4722">//   calculate data</a>
<a name="ln4723">// write start if in right track</a>
<a name="ln4724"> </a>
<a name="ln4725">static void spannerStart(ExportMusicXml* exp, int strack, int etrack, int track, int sstaff, Segment* seg)</a>
<a name="ln4726">      {</a>
<a name="ln4727">      if (seg-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln4728">            Fraction stick = seg-&gt;tick();</a>
<a name="ln4729">            for (auto it = exp-&gt;score()-&gt;spanner().lower_bound(stick.ticks()); it != exp-&gt;score()-&gt;spanner().upper_bound(stick.ticks()); ++it) {</a>
<a name="ln4730">                  Spanner* e = it-&gt;second;</a>
<a name="ln4731"> </a>
<a name="ln4732">                  int wtrack = -1; // track to write spanner</a>
<a name="ln4733">                  if (strack &lt;= e-&gt;track() &amp;&amp; e-&gt;track() &lt; etrack)</a>
<a name="ln4734">                        wtrack = findTrackForAnnotations(e-&gt;track(), seg);</a>
<a name="ln4735"> </a>
<a name="ln4736">                  if (track == wtrack) {</a>
<a name="ln4737">                        switch (e-&gt;type()) {</a>
<a name="ln4738">                              case ElementType::HAIRPIN:</a>
<a name="ln4739">                                    exp-&gt;hairpin(toHairpin(e), sstaff, seg-&gt;tick());</a>
<a name="ln4740">                                    break;</a>
<a name="ln4741">                              case ElementType::OTTAVA:</a>
<a name="ln4742">                                    exp-&gt;ottava(toOttava(e), sstaff, seg-&gt;tick());</a>
<a name="ln4743">                                    break;</a>
<a name="ln4744">                              case ElementType::PEDAL:</a>
<a name="ln4745">                                    exp-&gt;pedal(toPedal(e), sstaff, seg-&gt;tick());</a>
<a name="ln4746">                                    break;</a>
<a name="ln4747">                              case ElementType::TEXTLINE:</a>
<a name="ln4748">                                    exp-&gt;textLine(toTextLine(e), sstaff, seg-&gt;tick());</a>
<a name="ln4749">                                    break;</a>
<a name="ln4750">                              case ElementType::TRILL:</a>
<a name="ln4751">                                    // ignore (written as &lt;note&gt;&lt;notations&gt;&lt;ornaments&gt;&lt;wavy-line&gt;)</a>
<a name="ln4752">                                    break;</a>
<a name="ln4753">                              case ElementType::SLUR:</a>
<a name="ln4754">                                    // ignore (written as &lt;note&gt;&lt;notations&gt;&lt;slur&gt;)</a>
<a name="ln4755">                                    break;</a>
<a name="ln4756">                              default:</a>
<a name="ln4757">                                    qDebug(&quot;spannerStart: direction type %s at tick %d not implemented&quot;,</a>
<a name="ln4758">                                           Element::name(e-&gt;type()), seg-&gt;tick().ticks());</a>
<a name="ln4759">                                    break;</a>
<a name="ln4760">                              }</a>
<a name="ln4761">                        }</a>
<a name="ln4762">                  } // for</a>
<a name="ln4763">            }</a>
<a name="ln4764">      }</a>
<a name="ln4765"> </a>
<a name="ln4766">//---------------------------------------------------------</a>
<a name="ln4767">//  spannerStop</a>
<a name="ln4768">//---------------------------------------------------------</a>
<a name="ln4769"> </a>
<a name="ln4770">// called after writing each chord or rest to check if a spanner must be stopped</a>
<a name="ln4771">// loop over all spanners and find spanners in strack ending at tick2</a>
<a name="ln4772">// note that more than one voice may contains notes ending at tick2,</a>
<a name="ln4773">// remember which spanners have already been stopped (the &quot;stopped&quot; set)</a>
<a name="ln4774"> </a>
<a name="ln4775">static void spannerStop(ExportMusicXml* exp, int strack, int etrack, const Fraction&amp; tick2, int sstaff, QSet&lt;const Spanner*&gt;&amp; stopped)</a>
<a name="ln4776">      {</a>
<a name="ln4777">      for (auto it : exp-&gt;score()-&gt;spanner()) {</a>
<a name="ln4778">            Spanner* e = it.second;</a>
<a name="ln4779"> </a>
<a name="ln4780">            if (e-&gt;tick2() != tick2 || e-&gt;track() &lt; strack || e-&gt;track() &gt;= etrack)</a>
<a name="ln4781">                  continue;</a>
<a name="ln4782"> </a>
<a name="ln4783">            if (!stopped.contains(e)) {</a>
<a name="ln4784">                  stopped.insert(e);</a>
<a name="ln4785">                  switch (e-&gt;type()) {</a>
<a name="ln4786">                        case ElementType::HAIRPIN:</a>
<a name="ln4787">                              exp-&gt;hairpin(toHairpin(e), sstaff, Fraction(-1,1));</a>
<a name="ln4788">                              break;</a>
<a name="ln4789">                        case ElementType::OTTAVA:</a>
<a name="ln4790">                              exp-&gt;ottava(toOttava(e), sstaff, Fraction(-1,1));</a>
<a name="ln4791">                              break;</a>
<a name="ln4792">                        case ElementType::PEDAL:</a>
<a name="ln4793">                              exp-&gt;pedal(toPedal(e), sstaff, Fraction(-1,1));</a>
<a name="ln4794">                              break;</a>
<a name="ln4795">                        case ElementType::TEXTLINE:</a>
<a name="ln4796">                              exp-&gt;textLine(toTextLine(e), sstaff, Fraction(-1,1));</a>
<a name="ln4797">                              break;</a>
<a name="ln4798">                        case ElementType::TRILL:</a>
<a name="ln4799">                              // ignore (written as &lt;note&gt;&lt;notations&gt;&lt;ornaments&gt;&lt;wavy-line&gt;</a>
<a name="ln4800">                              break;</a>
<a name="ln4801">                        case ElementType::SLUR:</a>
<a name="ln4802">                              // ignore (written as &lt;note&gt;&lt;notations&gt;&lt;slur&gt;)</a>
<a name="ln4803">                              break;</a>
<a name="ln4804">                        default:</a>
<a name="ln4805">                              qDebug(&quot;spannerStop: direction type %s at tick2 %d not implemented&quot;,</a>
<a name="ln4806">                                     Element::name(e-&gt;type()), tick2.ticks());</a>
<a name="ln4807">                              break;</a>
<a name="ln4808">                        }</a>
<a name="ln4809">                  }</a>
<a name="ln4810">            } // for</a>
<a name="ln4811">      }</a>
<a name="ln4812"> </a>
<a name="ln4813">//---------------------------------------------------------</a>
<a name="ln4814">//  keysigTimesig</a>
<a name="ln4815">//---------------------------------------------------------</a>
<a name="ln4816"> </a>
<a name="ln4817">/**</a>
<a name="ln4818"> Output attributes at start of measure: key, time</a>
<a name="ln4819"> */</a>
<a name="ln4820"> </a>
<a name="ln4821">void ExportMusicXml::keysigTimesig(const Measure* m, const Part* p)</a>
<a name="ln4822">      {</a>
<a name="ln4823">      int strack = p-&gt;startTrack();</a>
<a name="ln4824">      int etrack = p-&gt;endTrack();</a>
<a name="ln4825">      //qDebug(&quot;keysigTimesig m %p strack %d etrack %d&quot;, m, strack, etrack);</a>
<a name="ln4826"> </a>
<a name="ln4827">      // search all staves for non-generated key signatures</a>
<a name="ln4828">      QMap&lt;int, KeySig*&gt; keysigs; // map staff to key signature</a>
<a name="ln4829">      for (Segment* seg = m-&gt;first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln4830">            if (seg-&gt;tick() &gt; m-&gt;tick())</a>
<a name="ln4831">                  break;</a>
<a name="ln4832">            for (int t = strack; t &lt; etrack; t += VOICES) {</a>
<a name="ln4833">                  Element* el = seg-&gt;element(t);</a>
<a name="ln4834">                  if (!el)</a>
<a name="ln4835">                        continue;</a>
<a name="ln4836">                  if (el-&gt;type() == ElementType::KEYSIG) {</a>
<a name="ln4837">                        //qDebug(&quot; found keysig %p track %d&quot;, el, el-&gt;track());</a>
<a name="ln4838">                        int st = (t - strack) / VOICES;</a>
<a name="ln4839">                        if (!el-&gt;generated())</a>
<a name="ln4840">                              keysigs[st] = static_cast&lt;KeySig*&gt;(el);</a>
<a name="ln4841">                        }</a>
<a name="ln4842">                  }</a>
<a name="ln4843">            }</a>
<a name="ln4844"> </a>
<a name="ln4845">      //ClefType ct = rest-&gt;staff()-&gt;clef(rest-&gt;tick());</a>
<a name="ln4846"> </a>
<a name="ln4847">      // write the key signatues</a>
<a name="ln4848">      if (!keysigs.isEmpty()) {</a>
<a name="ln4849">            // determine if all staves have a keysig and all keysigs are identical</a>
<a name="ln4850">            // in that case a single &lt;key&gt; is written, without number=... attribute</a>
<a name="ln4851">            int nstaves = p-&gt;nstaves();</a>
<a name="ln4852">            bool singleKey = true;</a>
<a name="ln4853">            // check if all staves have a keysig</a>
<a name="ln4854">            for (int i = 0; i &lt; nstaves; i++)</a>
<a name="ln4855">                  if (!keysigs.contains(i))</a>
<a name="ln4856">                        singleKey = false;</a>
<a name="ln4857">            // check if all keysigs are identical</a>
<a name="ln4858">            if (singleKey)</a>
<a name="ln4859">                  for (int i = 1; i &lt; nstaves; i++)</a>
<a name="ln4860">                        if (!(keysigs.value(i)-&gt;key() == keysigs.value(0)-&gt;key()))</a>
<a name="ln4861">                              singleKey = false;</a>
<a name="ln4862"> </a>
<a name="ln4863">            // write the keysigs</a>
<a name="ln4864">            //qDebug(&quot; singleKey %d&quot;, singleKey);</a>
<a name="ln4865">            if (singleKey) {</a>
<a name="ln4866">                  // keysig applies to all staves</a>
<a name="ln4867">                  keysig(keysigs.value(0), p-&gt;staff(0)-&gt;clef(m-&gt;tick()), 0, keysigs.value(0)-&gt;visible());</a>
<a name="ln4868">                  }</a>
<a name="ln4869">            else {</a>
<a name="ln4870">                  // staff-specific keysigs</a>
<a name="ln4871">                  for (int st : keysigs.keys())</a>
<a name="ln4872">                        keysig(keysigs.value(st), p-&gt;staff(st)-&gt;clef(m-&gt;tick()), st + 1, keysigs.value(st)-&gt;visible());</a>
<a name="ln4873">                  }</a>
<a name="ln4874">            }</a>
<a name="ln4875">      else {</a>
<a name="ln4876">            // always write a keysig at tick = 0</a>
<a name="ln4877">            if (m-&gt;tick().isZero()) {</a>
<a name="ln4878">                  //KeySigEvent kse;</a>
<a name="ln4879">                  //kse.setKey(Key::C);</a>
<a name="ln4880">                  KeySig* ks = new KeySig(_score);</a>
<a name="ln4881">                  ks-&gt;setKey(Key::C);</a>
<a name="ln4882">                  keysig(ks, p-&gt;staff(0)-&gt;clef(m-&gt;tick()));</a>
<a name="ln4883">                  delete ks;</a>
<a name="ln4884">                  }</a>
<a name="ln4885">            }</a>
<a name="ln4886"> </a>
<a name="ln4887">      TimeSig* tsig = 0;</a>
<a name="ln4888">      for (Segment* seg = m-&gt;first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln4889">            if (seg-&gt;tick() &gt; m-&gt;tick())</a>
<a name="ln4890">                  break;</a>
<a name="ln4891">            Element* el = seg-&gt;element(strack);</a>
<a name="ln4892">            if (el &amp;&amp; el-&gt;type() == ElementType::TIMESIG)</a>
<a name="ln4893">                  tsig = (TimeSig*) el;</a>
<a name="ln4894">            }</a>
<a name="ln4895">      if (tsig)</a>
<a name="ln4896">            timesig(tsig);</a>
<a name="ln4897">      }</a>
<a name="ln4898"> </a>
<a name="ln4899">//---------------------------------------------------------</a>
<a name="ln4900">//  identification -- write the identification</a>
<a name="ln4901">//---------------------------------------------------------</a>
<a name="ln4902"> </a>
<a name="ln4903">static void identification(XmlWriter&amp; xml, Score const* const score)</a>
<a name="ln4904">      {</a>
<a name="ln4905">      xml.stag(&quot;identification&quot;);</a>
<a name="ln4906"> </a>
<a name="ln4907">      QStringList creators;</a>
<a name="ln4908">      // the creator types commonly found in MusicXML</a>
<a name="ln4909">      creators &lt;&lt; &quot;arranger&quot; &lt;&lt; &quot;composer&quot; &lt;&lt; &quot;lyricist&quot; &lt;&lt; &quot;poet&quot; &lt;&lt; &quot;translator&quot;;</a>
<a name="ln4910">      for (QString type : creators) {</a>
<a name="ln4911">            QString creator = score-&gt;metaTag(type);</a>
<a name="ln4912">            if (!creator.isEmpty())</a>
<a name="ln4913">                  xml.tag(QString(&quot;creator type=\&quot;%1\&quot;&quot;).arg(type), creator);</a>
<a name="ln4914">            }</a>
<a name="ln4915"> </a>
<a name="ln4916">      if (!score-&gt;metaTag(&quot;copyright&quot;).isEmpty())</a>
<a name="ln4917">            xml.tag(&quot;rights&quot;, score-&gt;metaTag(&quot;copyright&quot;));</a>
<a name="ln4918"> </a>
<a name="ln4919">      xml.stag(&quot;encoding&quot;);</a>
<a name="ln4920"> </a>
<a name="ln4921">      if (MScore::debugMode) {</a>
<a name="ln4922">            xml.tag(&quot;software&quot;, QString(&quot;MuseScore 0.7.0&quot;));</a>
<a name="ln4923">            xml.tag(&quot;encoding-date&quot;, QString(&quot;2007-09-10&quot;));</a>
<a name="ln4924">            }</a>
<a name="ln4925">      else {</a>
<a name="ln4926">            xml.tag(&quot;software&quot;, QString(&quot;MuseScore &quot;) + QString(VERSION));</a>
<a name="ln4927">            xml.tag(&quot;encoding-date&quot;, QDate::currentDate().toString(Qt::ISODate));</a>
<a name="ln4928">            }</a>
<a name="ln4929"> </a>
<a name="ln4930">      // specify supported elements</a>
<a name="ln4931">      xml.tagE(&quot;supports element=\&quot;accidental\&quot; type=\&quot;yes\&quot;&quot;);</a>
<a name="ln4932">      xml.tagE(&quot;supports element=\&quot;beam\&quot; type=\&quot;yes\&quot;&quot;);</a>
<a name="ln4933">      // set support for print new-page and new-system to match user preference</a>
<a name="ln4934">      // for MusicxmlExportBreaks::MANUAL support is &quot;no&quot; because &quot;yes&quot; breaks Finale NotePad import</a>
<a name="ln4935">      if (preferences.getBool(PREF_EXPORT_MUSICXML_EXPORTLAYOUT)</a>
<a name="ln4936">          &amp;&amp; preferences.musicxmlExportBreaks() == MusicxmlExportBreaks::ALL) {</a>
<a name="ln4937">            xml.tagE(&quot;supports element=\&quot;print\&quot; attribute=\&quot;new-page\&quot; type=\&quot;yes\&quot; value=\&quot;yes\&quot;&quot;);</a>
<a name="ln4938">            xml.tagE(&quot;supports element=\&quot;print\&quot; attribute=\&quot;new-system\&quot; type=\&quot;yes\&quot; value=\&quot;yes\&quot;&quot;);</a>
<a name="ln4939">            }</a>
<a name="ln4940">      else {</a>
<a name="ln4941">            xml.tagE(&quot;supports element=\&quot;print\&quot; attribute=\&quot;new-page\&quot; type=\&quot;no\&quot;&quot;);</a>
<a name="ln4942">            xml.tagE(&quot;supports element=\&quot;print\&quot; attribute=\&quot;new-system\&quot; type=\&quot;no\&quot;&quot;);</a>
<a name="ln4943">            }</a>
<a name="ln4944">      xml.tagE(&quot;supports element=\&quot;stem\&quot; type=\&quot;yes\&quot;&quot;);</a>
<a name="ln4945"> </a>
<a name="ln4946">      xml.etag();</a>
<a name="ln4947"> </a>
<a name="ln4948">      if (!score-&gt;metaTag(&quot;source&quot;).isEmpty())</a>
<a name="ln4949">            xml.tag(&quot;source&quot;, score-&gt;metaTag(&quot;source&quot;));</a>
<a name="ln4950"> </a>
<a name="ln4951">      xml.etag();</a>
<a name="ln4952">      }</a>
<a name="ln4953"> </a>
<a name="ln4954">//---------------------------------------------------------</a>
<a name="ln4955">//  findPartGroupNumber</a>
<a name="ln4956">//---------------------------------------------------------</a>
<a name="ln4957"> </a>
<a name="ln4958">static int findPartGroupNumber(int* partGroupEnd)</a>
<a name="ln4959">      {</a>
<a name="ln4960">      // find part group number</a>
<a name="ln4961">      for (int number = 0; number &lt; MAX_PART_GROUPS; ++number)</a>
<a name="ln4962">            if (partGroupEnd[number] == -1)</a>
<a name="ln4963">                  return number;</a>
<a name="ln4964">      qDebug(&quot;no free part group number&quot;);</a>
<a name="ln4965">      return MAX_PART_GROUPS;</a>
<a name="ln4966">      }</a>
<a name="ln4967"> </a>
<a name="ln4968">//---------------------------------------------------------</a>
<a name="ln4969">//  scoreInstrument</a>
<a name="ln4970">//---------------------------------------------------------</a>
<a name="ln4971"> </a>
<a name="ln4972">static void scoreInstrument(XmlWriter&amp; xml, const int partNr, const int instrNr, const QString&amp; instrName)</a>
<a name="ln4973">      {</a>
<a name="ln4974">      xml.stag(QString(&quot;score-instrument %1&quot;).arg(instrId(partNr, instrNr)));</a>
<a name="ln4975">      xml.tag(&quot;instrument-name&quot;, instrName);</a>
<a name="ln4976">      xml.etag();</a>
<a name="ln4977">      }</a>
<a name="ln4978"> </a>
<a name="ln4979">//---------------------------------------------------------</a>
<a name="ln4980">//  midiInstrument</a>
<a name="ln4981">//---------------------------------------------------------</a>
<a name="ln4982"> </a>
<a name="ln4983">static void midiInstrument(XmlWriter&amp; xml, const int partNr, const int instrNr,</a>
<a name="ln4984">                           const Instrument* instr, const Score* score, const int unpitched = 0)</a>
<a name="ln4985">      {</a>
<a name="ln4986">      xml.stag(QString(&quot;midi-instrument %1&quot;).arg(instrId(partNr, instrNr)));</a>
<a name="ln4987">      int midiChannel = score-&gt;masterScore()-&gt;midiChannel(instr-&gt;channel(0)-&gt;channel());</a>
<a name="ln4988">      if (midiChannel &gt;= 0 &amp;&amp; midiChannel &lt; 16)</a>
<a name="ln4989">            xml.tag(&quot;midi-channel&quot;, midiChannel + 1);</a>
<a name="ln4990">      int midiProgram = instr-&gt;channel(0)-&gt;program();</a>
<a name="ln4991">      if (midiProgram &gt;= 0 &amp;&amp; midiProgram &lt; 128)</a>
<a name="ln4992">            xml.tag(&quot;midi-program&quot;, midiProgram + 1);</a>
<a name="ln4993">      if (unpitched &gt; 0)</a>
<a name="ln4994">            xml.tag(&quot;midi-unpitched&quot;, unpitched);</a>
<a name="ln4995">      xml.tag(&quot;volume&quot;, (instr-&gt;channel(0)-&gt;volume() / 127.0) * 100);  //percent</a>
<a name="ln4996">      xml.tag(&quot;pan&quot;, int(((instr-&gt;channel(0)-&gt;pan() - 63.5) / 63.5) * 90)); //-90 hard left, +90 hard right      xml.etag();</a>
<a name="ln4997">      xml.etag();</a>
<a name="ln4998">      }</a>
<a name="ln4999"> </a>
<a name="ln5000">//---------------------------------------------------------</a>
<a name="ln5001">//  initInstrMap</a>
<a name="ln5002">//---------------------------------------------------------</a>
<a name="ln5003"> </a>
<a name="ln5004">/**</a>
<a name="ln5005"> Initialize the Instrument* to number map for a Part</a>
<a name="ln5006"> Used to generate instrument numbers for a multi-instrument part</a>
<a name="ln5007"> */</a>
<a name="ln5008"> </a>
<a name="ln5009">static void initInstrMap(MxmlInstrumentMap&amp; im, const InstrumentList* il, const Score* /*score*/)</a>
<a name="ln5010">      {</a>
<a name="ln5011">      im.clear();</a>
<a name="ln5012">      for (auto i = il-&gt;begin(); i != il-&gt;end(); ++i) {</a>
<a name="ln5013">            const Instrument* pinstr = i-&gt;second;</a>
<a name="ln5014">            if (!im.contains(pinstr))</a>
<a name="ln5015">                  im.insert(pinstr, im.size());</a>
<a name="ln5016">            }</a>
<a name="ln5017">      }</a>
<a name="ln5018"> </a>
<a name="ln5019">//---------------------------------------------------------</a>
<a name="ln5020">//  initReverseInstrMap</a>
<a name="ln5021">//---------------------------------------------------------</a>
<a name="ln5022"> </a>
<a name="ln5023">typedef QMap&lt;int, const Instrument*&gt; MxmlReverseInstrumentMap;</a>
<a name="ln5024"> </a>
<a name="ln5025">/**</a>
<a name="ln5026"> Initialize the number t Instrument* map for a Part</a>
<a name="ln5027"> Used to iterate in sequence over instrument numbers for a multi-instrument part</a>
<a name="ln5028"> */</a>
<a name="ln5029"> </a>
<a name="ln5030">static void initReverseInstrMap(MxmlReverseInstrumentMap&amp; rim, const MxmlInstrumentMap&amp; im)</a>
<a name="ln5031">      {</a>
<a name="ln5032">      rim.clear();</a>
<a name="ln5033">      for (const Instrument* i : im.keys()) {</a>
<a name="ln5034">            int instNr = im.value(i);</a>
<a name="ln5035">            rim.insert(instNr, i);</a>
<a name="ln5036">            }</a>
<a name="ln5037">      }</a>
<a name="ln5038"> </a>
<a name="ln5039">//---------------------------------------------------------</a>
<a name="ln5040">//  hasPageBreak</a>
<a name="ln5041">//---------------------------------------------------------</a>
<a name="ln5042"> </a>
<a name="ln5043">static MeasureBase* lastMeasureBase(const System* const system)</a>
<a name="ln5044">      {</a>
<a name="ln5045">      MeasureBase* mb = nullptr;</a>
<a name="ln5046">      if (system) {</a>
<a name="ln5047">            const auto&amp; measures = system-&gt;measures();</a>
<a name="ln5048">            Q_ASSERT(!(measures.empty()));</a>
<a name="ln5049">            mb = measures.back();</a>
<a name="ln5050">            }</a>
<a name="ln5051">      return mb;</a>
<a name="ln5052">      }</a>
<a name="ln5053"> </a>
<a name="ln5054">//---------------------------------------------------------</a>
<a name="ln5055">//  hasPageBreak</a>
<a name="ln5056">//---------------------------------------------------------</a>
<a name="ln5057"> </a>
<a name="ln5058">static bool hasPageBreak(const System* const system)</a>
<a name="ln5059">      {</a>
<a name="ln5060">      const MeasureBase* mb = nullptr;</a>
<a name="ln5061">      if (system) {</a>
<a name="ln5062">            const auto&amp; measures = system-&gt;measures();</a>
<a name="ln5063">            Q_ASSERT(!(measures.empty()));</a>
<a name="ln5064">            mb = measures.back();</a>
<a name="ln5065">            }</a>
<a name="ln5066"> </a>
<a name="ln5067">      return mb &amp;&amp; mb-&gt;pageBreak();</a>
<a name="ln5068">      }</a>
<a name="ln5069"> </a>
<a name="ln5070">//---------------------------------------------------------</a>
<a name="ln5071">//  print</a>
<a name="ln5072">//---------------------------------------------------------</a>
<a name="ln5073"> </a>
<a name="ln5074">/**</a>
<a name="ln5075"> Handle the &lt;print&gt; element.</a>
<a name="ln5076"> When exporting layout and all breaks, a &lt;print&gt; with layout information</a>
<a name="ln5077"> is generated for the first measure in the score, in a system or on a page.</a>
<a name="ln5078"> When exporting layout but only manual or no breaks, a &lt;print&gt; with</a>
<a name="ln5079"> layout information is generated only for the first measure in the score,</a>
<a name="ln5080"> as it is assumed the system layout is broken by the importing application</a>
<a name="ln5081"> anyway and is thus useless.</a>
<a name="ln5082"> </a>
<a name="ln5083"> a page break is explicit (manual) if:</a>
<a name="ln5084"> - the last system on the previous page has a page break</a>
<a name="ln5085"> a system break is explicit (manual) if:</a>
<a name="ln5086"> - the previous system in the score has a system or layout break</a>
<a name="ln5087"> - if the previous system in the score does not have measures</a>
<a name="ln5088">   (i.e. only has (a) frame(s))</a>
<a name="ln5089"> */</a>
<a name="ln5090"> </a>
<a name="ln5091">void ExportMusicXml::print(const Measure* const m, const int partNr, const int firstStaffOfPart, const int nrStavesInPart, const MeasurePrintContext&amp; mpc)</a>
<a name="ln5092">      {</a>
<a name="ln5093">      const MeasureBase* const prevSysMB = lastMeasureBase(mpc.prevSystem);</a>
<a name="ln5094"> </a>
<a name="ln5095">      const bool prevMeasLineBreak = prevSysMB ? prevSysMB-&gt;lineBreak() : false;</a>
<a name="ln5096">      const bool prevMeasSectionBreak = prevSysMB ? prevSysMB-&gt;sectionBreak() : false;</a>
<a name="ln5097">      const bool prevPageBreak = hasPageBreak(mpc.lastSystemPrevPage);</a>
<a name="ln5098"> </a>
<a name="ln5099">      QString newSystemOrPage;             // new-[system|page]=&quot;yes&quot; or empty</a>
<a name="ln5100">      if (!mpc.scoreStart) {</a>
<a name="ln5101">            if (preferences.musicxmlExportBreaks() == MusicxmlExportBreaks::ALL) {</a>
<a name="ln5102">                  if (mpc.pageStart) newSystemOrPage = &quot; new-page=\&quot;yes\&quot;&quot;;</a>
<a name="ln5103">                  else if (mpc.systemStart) newSystemOrPage = &quot; new-system=\&quot;yes\&quot;&quot;;</a>
<a name="ln5104">                  }</a>
<a name="ln5105">            else if (preferences.musicxmlExportBreaks() == MusicxmlExportBreaks::MANUAL) {</a>
<a name="ln5106">                  if (mpc.pageStart &amp;&amp; prevPageBreak)</a>
<a name="ln5107">                        newSystemOrPage = &quot; new-page=\&quot;yes\&quot;&quot;;</a>
<a name="ln5108">                  else if (mpc.systemStart &amp;&amp; (prevMeasLineBreak || prevMeasSectionBreak))</a>
<a name="ln5109">                        newSystemOrPage = &quot; new-system=\&quot;yes\&quot;&quot;;</a>
<a name="ln5110">                  }</a>
<a name="ln5111">            }</a>
<a name="ln5112"> </a>
<a name="ln5113">      bool doBreak = mpc.scoreStart || (newSystemOrPage != &quot;&quot;);</a>
<a name="ln5114">      bool doLayout = preferences.getBool(PREF_EXPORT_MUSICXML_EXPORTLAYOUT);</a>
<a name="ln5115"> </a>
<a name="ln5116">      if (doBreak) {</a>
<a name="ln5117">            if (doLayout) {</a>
<a name="ln5118">                  _xml.stag(QString(&quot;print%1&quot;).arg(newSystemOrPage));</a>
<a name="ln5119">                  const double pageWidth  = getTenthsFromInches(score()-&gt;styleD(Sid::pageWidth));</a>
<a name="ln5120">                  const double lm = getTenthsFromInches(score()-&gt;styleD(Sid::pageOddLeftMargin));</a>
<a name="ln5121">                  const double rm = getTenthsFromInches(score()-&gt;styleD(Sid::pageWidth)</a>
<a name="ln5122">                                                        - score()-&gt;styleD(Sid::pagePrintableWidth) - score()-&gt;styleD(Sid::pageOddLeftMargin));</a>
<a name="ln5123">                  const double tm = getTenthsFromInches(score()-&gt;styleD(Sid::pageOddTopMargin));</a>
<a name="ln5124"> </a>
<a name="ln5125">                  // System Layout</a>
<a name="ln5126"> </a>
<a name="ln5127">                  // For a multi-meaure rest positioning is valid only</a>
<a name="ln5128">                  // in the replacing measure</a>
<a name="ln5129">                  // note: for a normal measure, mmRest1 is the measure itself,</a>
<a name="ln5130">                  // for a multi-meaure rest, it is the replacing measure</a>
<a name="ln5131">                  const Measure* mmR1 = m-&gt;mmRest1();</a>
<a name="ln5132">                  const System* system = mmR1-&gt;system();</a>
<a name="ln5133"> </a>
<a name="ln5134">                  // Put the system print suggestions only for the first part in a score...</a>
<a name="ln5135">                  if (partNr == 0) {</a>
<a name="ln5136"> </a>
<a name="ln5137">                        // Find the right margin of the system.</a>
<a name="ln5138">                        double systemLM = getTenthsFromDots(mmR1-&gt;pagePos().x() - system-&gt;page()-&gt;pagePos().x()) - lm;</a>
<a name="ln5139">                        double systemRM = pageWidth - rm - (getTenthsFromDots(system-&gt;bbox().width()) + lm);</a>
<a name="ln5140"> </a>
<a name="ln5141">                        _xml.stag(&quot;system-layout&quot;);</a>
<a name="ln5142">                        _xml.stag(&quot;system-margins&quot;);</a>
<a name="ln5143">                        _xml.tag(&quot;left-margin&quot;, QString(&quot;%1&quot;).arg(QString::number(systemLM,'f',2)));</a>
<a name="ln5144">                        _xml.tag(&quot;right-margin&quot;, QString(&quot;%1&quot;).arg(QString::number(systemRM,'f',2)) );</a>
<a name="ln5145">                        _xml.etag();</a>
<a name="ln5146"> </a>
<a name="ln5147">                        if (mpc.pageStart || mpc.scoreStart) {</a>
<a name="ln5148">                              const double topSysDist = getTenthsFromDots(mmR1-&gt;pagePos().y()) - tm;</a>
<a name="ln5149">                              _xml.tag(&quot;top-system-distance&quot;, QString(&quot;%1&quot;).arg(QString::number(topSysDist,'f',2)) );</a>
<a name="ln5150">                              }</a>
<a name="ln5151">                        if (mpc.systemStart &amp;&amp; !mpc.scoreStart) {</a>
<a name="ln5152">                              // see System::layout2() for the factor 2 * score()-&gt;spatium()</a>
<a name="ln5153">                              const double sysDist = getTenthsFromDots(mmR1-&gt;pagePos().y()</a>
<a name="ln5154">                                                                       - mpc.prevMeasure-&gt;pagePos().y()</a>
<a name="ln5155">                                                                       - mpc.prevMeasure-&gt;bbox().height()</a>
<a name="ln5156">                                                                       + 2 * score()-&gt;spatium()</a>
<a name="ln5157">                                                                       );</a>
<a name="ln5158">                              _xml.tag(&quot;system-distance&quot;,</a>
<a name="ln5159">                                       QString(&quot;%1&quot;).arg(QString::number(sysDist,'f',2)));</a>
<a name="ln5160">                              }</a>
<a name="ln5161"> </a>
<a name="ln5162">                        _xml.etag();</a>
<a name="ln5163">                        }</a>
<a name="ln5164"> </a>
<a name="ln5165">                  // Staff layout elements.</a>
<a name="ln5166">                  for (int staffIdx = (firstStaffOfPart == 0) ? 1 : 0; staffIdx &lt; nrStavesInPart; staffIdx++) {</a>
<a name="ln5167"> </a>
<a name="ln5168">                        // calculate distance between this and previous staff using the bounding boxes</a>
<a name="ln5169">                        const auto staffNr = firstStaffOfPart + staffIdx;</a>
<a name="ln5170">                        const auto prevBbox = system-&gt;staff(staffNr - 1)-&gt;bbox();</a>
<a name="ln5171">                        const auto staffDist = system-&gt;staff(staffNr)-&gt;bbox().y() - prevBbox.y() - prevBbox.height();</a>
<a name="ln5172"> </a>
<a name="ln5173">                        _xml.stag(QString(&quot;staff-layout number=\&quot;%1\&quot;&quot;).arg(staffIdx + 1));</a>
<a name="ln5174">                        _xml.tag(&quot;staff-distance&quot;, QString(&quot;%1&quot;).arg(QString::number(getTenthsFromDots(staffDist),'f',2)));</a>
<a name="ln5175">                        _xml.etag();</a>
<a name="ln5176">                        }</a>
<a name="ln5177"> </a>
<a name="ln5178">                  _xml.etag();</a>
<a name="ln5179">                  }</a>
<a name="ln5180">            else if (newSystemOrPage != &quot;&quot;) {</a>
<a name="ln5181">                  _xml.tagE(QString(&quot;print%1&quot;).arg(newSystemOrPage));</a>
<a name="ln5182">                  }</a>
<a name="ln5183">            }</a>
<a name="ln5184">      }</a>
<a name="ln5185"> </a>
<a name="ln5186">//---------------------------------------------------------</a>
<a name="ln5187">//  exportDefaultClef</a>
<a name="ln5188">//---------------------------------------------------------</a>
<a name="ln5189"> </a>
<a name="ln5190">/**</a>
<a name="ln5191"> In case no clef is found, export a default clef with type determined by staff type.</a>
<a name="ln5192"> Note that a multi-measure rest starting in the first measure should be handled correctly.</a>
<a name="ln5193"> */</a>
<a name="ln5194"> </a>
<a name="ln5195">void ExportMusicXml::exportDefaultClef(const Part* const part, const Measure* const m)</a>
<a name="ln5196">      {</a>
<a name="ln5197">      const auto staves = part-&gt;nstaves();</a>
<a name="ln5198"> </a>
<a name="ln5199">      if (m-&gt;tick() == Fraction(0,1)) {</a>
<a name="ln5200">            const auto clefSeg = m-&gt;findSegment(SegmentType::HeaderClef, Fraction(0,1));</a>
<a name="ln5201"> </a>
<a name="ln5202">            if (clefSeg) {</a>
<a name="ln5203">                  for (int i = 0; i &lt; staves; ++i) {</a>
<a name="ln5204"> </a>
<a name="ln5205">                        // sstaff - xml staff number, counting from 1 for this</a>
<a name="ln5206">                        // instrument</a>
<a name="ln5207">                        // special number 0 -&gt; dont show staff number in</a>
<a name="ln5208">                        // xml output (because there is only one staff)</a>
<a name="ln5209"> </a>
<a name="ln5210">                        auto sstaff = (staves &gt; 1) ? i + 1 : 0;</a>
<a name="ln5211">                        auto track = part-&gt;startTrack() + VOICES * i;</a>
<a name="ln5212"> </a>
<a name="ln5213">                        if (clefSeg-&gt;element(track) == nullptr) {</a>
<a name="ln5214">                              ClefType ct { ClefType::G };</a>
<a name="ln5215">                              QString stafftype;</a>
<a name="ln5216">                              switch (part-&gt;staff(i)-&gt;staffType(Fraction(0,1))-&gt;group()) {</a>
<a name="ln5217">                                    case StaffGroup::TAB:</a>
<a name="ln5218">                                          ct = ClefType::TAB;</a>
<a name="ln5219">                                          stafftype = &quot;tab&quot;;</a>
<a name="ln5220">                                          break;</a>
<a name="ln5221">                                    case StaffGroup::STANDARD:</a>
<a name="ln5222">                                          ct = ClefType::G;</a>
<a name="ln5223">                                          stafftype = &quot;std&quot;;</a>
<a name="ln5224">                                          break;</a>
<a name="ln5225">                                    case StaffGroup::PERCUSSION:</a>
<a name="ln5226">                                          ct = ClefType::PERC;</a>
<a name="ln5227">                                          stafftype = &quot;perc&quot;;</a>
<a name="ln5228">                                          break;</a>
<a name="ln5229">                                    }</a>
<a name="ln5230">                              qDebug(&quot;no clef found in first measure track %d (stafftype %s)&quot;, track, qPrintable(stafftype));</a>
<a name="ln5231">                              clef(sstaff, ct, &quot; print-object=\&quot;no\&quot;&quot;);</a>
<a name="ln5232">                              }</a>
<a name="ln5233">                        }</a>
<a name="ln5234">                  }</a>
<a name="ln5235">            }</a>
<a name="ln5236">      }</a>
<a name="ln5237"> </a>
<a name="ln5238">//---------------------------------------------------------</a>
<a name="ln5239">//  findAndExportClef</a>
<a name="ln5240">//---------------------------------------------------------</a>
<a name="ln5241"> </a>
<a name="ln5242">/**</a>
<a name="ln5243"> Make sure clefs at end of measure get exported at start of next measure.</a>
<a name="ln5244"> */</a>
<a name="ln5245"> </a>
<a name="ln5246">void ExportMusicXml::findAndExportClef(const Measure* const m, const int staves, const int strack, const int etrack)</a>
<a name="ln5247">      {</a>
<a name="ln5248">      Measure* prevMeasure = m-&gt;prevMeasure();</a>
<a name="ln5249">      Measure* mmR         = m-&gt;mmRest();       // the replacing measure in a multi-measure rest</a>
<a name="ln5250">      Fraction tick        = m-&gt;tick();</a>
<a name="ln5251">      Segment* cs1;</a>
<a name="ln5252">      Segment* cs2         = m-&gt;findSegment(SegmentType::Clef, tick);</a>
<a name="ln5253">      Segment* cs3;</a>
<a name="ln5254">      Segment* seg         = 0;</a>
<a name="ln5255"> </a>
<a name="ln5256">      if (prevMeasure)</a>
<a name="ln5257">            cs1 = prevMeasure-&gt;findSegment(SegmentType::Clef, tick);</a>
<a name="ln5258">      else</a>
<a name="ln5259">            cs1 = m-&gt;findSegment(SegmentType::HeaderClef, tick);</a>
<a name="ln5260"> </a>
<a name="ln5261">      if (mmR) {</a>
<a name="ln5262">            cs3 = mmR-&gt;findSegment(SegmentType::HeaderClef, tick);</a>
<a name="ln5263">            if (!cs3)</a>
<a name="ln5264">                  cs3 = mmR-&gt;findSegment(SegmentType::Clef, tick);</a>
<a name="ln5265">            }</a>
<a name="ln5266">      else</a>
<a name="ln5267">            cs3 = 0;</a>
<a name="ln5268"> </a>
<a name="ln5269">      if (cs1 &amp;&amp; cs2) {</a>
<a name="ln5270">            // should only happen at begin of new system</a>
<a name="ln5271">            // when previous system ends with a non-generated clef</a>
<a name="ln5272">            seg = cs1;</a>
<a name="ln5273">            }</a>
<a name="ln5274">      else if (cs1)</a>
<a name="ln5275">            seg = cs1;</a>
<a name="ln5276">      else if (cs3) {</a>
<a name="ln5277">            // happens when the first measure is a multi-measure rest</a>
<a name="ln5278">            // containing a generated clef</a>
<a name="ln5279">            seg = cs3;</a>
<a name="ln5280">            }</a>
<a name="ln5281">      else</a>
<a name="ln5282">            seg = cs2;</a>
<a name="ln5283">      clefDebug(&quot;exportxml: clef segments cs1=%p cs2=%p cs3=%p seg=%p&quot;, cs1, cs2, cs3, seg);</a>
<a name="ln5284"> </a>
<a name="ln5285">      // output attribute at start of measure: clef</a>
<a name="ln5286">      if (seg) {</a>
<a name="ln5287">            for (int st = strack; st &lt; etrack; st += VOICES) {</a>
<a name="ln5288">                  // sstaff - xml staff number, counting from 1 for this</a>
<a name="ln5289">                  // instrument</a>
<a name="ln5290">                  // special number 0 -&gt; dont show staff number in</a>
<a name="ln5291">                  // xml output (because there is only one staff)</a>
<a name="ln5292"> </a>
<a name="ln5293">                  int sstaff = (staves &gt; 1) ? st - strack + VOICES : 0;</a>
<a name="ln5294">                  sstaff /= VOICES;</a>
<a name="ln5295"> </a>
<a name="ln5296">                  Clef* cle = static_cast&lt;Clef*&gt;(seg-&gt;element(st));</a>
<a name="ln5297">                  if (cle) {</a>
<a name="ln5298">                        clefDebug(&quot;exportxml: clef at start measure ti=%d ct=%d gen=%d&quot;, tick, int(cle-&gt;clefType()), cle-&gt;generated());</a>
<a name="ln5299">                        // output only clef changes, not generated clefs at line beginning</a>
<a name="ln5300">                        // exception: at tick=0, export clef anyway</a>
<a name="ln5301">                        if (tick.isZero() || !cle-&gt;generated()) {</a>
<a name="ln5302">                              clefDebug(&quot;exportxml: clef exported&quot;);</a>
<a name="ln5303">                              clef(sstaff, cle-&gt;clefType(), color2xml(cle));</a>
<a name="ln5304">                              }</a>
<a name="ln5305">                        else {</a>
<a name="ln5306">                              clefDebug(&quot;exportxml: clef not exported&quot;);</a>
<a name="ln5307">                              }</a>
<a name="ln5308">                        }</a>
<a name="ln5309">                  }</a>
<a name="ln5310">            }</a>
<a name="ln5311">      }</a>
<a name="ln5312"> </a>
<a name="ln5313">//---------------------------------------------------------</a>
<a name="ln5314">//  findPitchesUsed</a>
<a name="ln5315">//---------------------------------------------------------</a>
<a name="ln5316"> </a>
<a name="ln5317">/**</a>
<a name="ln5318"> Find the set of pitches actually used in a part.</a>
<a name="ln5319"> */</a>
<a name="ln5320"> </a>
<a name="ln5321">typedef QSet&lt;int&gt; pitchSet;       // the set of pitches used</a>
<a name="ln5322"> </a>
<a name="ln5323">static void addChordPitchesToSet(const Chord* c, pitchSet&amp; set)</a>
<a name="ln5324">      {</a>
<a name="ln5325">      for (const Note* note : c-&gt;notes()) {</a>
<a name="ln5326">            qDebug(&quot;chord %p note %p pitch %d&quot;, c, note, note-&gt;pitch() + 1);</a>
<a name="ln5327">            set.insert(note-&gt;pitch());</a>
<a name="ln5328">            }</a>
<a name="ln5329">      }</a>
<a name="ln5330"> </a>
<a name="ln5331">static void findPitchesUsed(const Part* part, pitchSet&amp; set)</a>
<a name="ln5332">      {</a>
<a name="ln5333">      int strack = part-&gt;startTrack();</a>
<a name="ln5334">      int etrack = part-&gt;endTrack();</a>
<a name="ln5335"> </a>
<a name="ln5336">      // loop over all chords in the part</a>
<a name="ln5337">      for (const MeasureBase* mb = part-&gt;score()-&gt;measures()-&gt;first(); mb; mb = mb-&gt;next()) {</a>
<a name="ln5338">            if (mb-&gt;type() != ElementType::MEASURE)</a>
<a name="ln5339">                  continue;</a>
<a name="ln5340">            const Measure* m = static_cast&lt;const Measure*&gt;(mb);</a>
<a name="ln5341">            for (int st = strack; st &lt; etrack; ++st) {</a>
<a name="ln5342">                  for (Segment* seg = m-&gt;first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln5343">                        const Element* el = seg-&gt;element(st);</a>
<a name="ln5344">                        if (!el)</a>
<a name="ln5345">                              continue;</a>
<a name="ln5346">                        if (el-&gt;type() == ElementType::CHORD)</a>
<a name="ln5347">                              {</a>
<a name="ln5348">                              // add grace and non-grace note pitches to the result set</a>
<a name="ln5349">                              const Chord* c = static_cast&lt;const Chord*&gt;(el);</a>
<a name="ln5350">                              if (c) {</a>
<a name="ln5351">                                    for (const Chord* g : c-&gt;graceNotesBefore()) {</a>
<a name="ln5352">                                          addChordPitchesToSet(g, set);</a>
<a name="ln5353">                                          }</a>
<a name="ln5354">                                    addChordPitchesToSet(c, set);</a>
<a name="ln5355">                                    for (const Chord* g : c-&gt;graceNotesAfter()) {</a>
<a name="ln5356">                                          addChordPitchesToSet(g, set);</a>
<a name="ln5357">                                          }</a>
<a name="ln5358">                                    }</a>
<a name="ln5359">                              }</a>
<a name="ln5360">                        }</a>
<a name="ln5361">                  }</a>
<a name="ln5362">            }</a>
<a name="ln5363">      }</a>
<a name="ln5364"> </a>
<a name="ln5365">//---------------------------------------------------------</a>
<a name="ln5366">//  partList</a>
<a name="ln5367">//---------------------------------------------------------</a>
<a name="ln5368"> </a>
<a name="ln5369">/**</a>
<a name="ln5370"> Write the part list to \a xml.</a>
<a name="ln5371"> */</a>
<a name="ln5372"> </a>
<a name="ln5373">static void partList(XmlWriter&amp; xml, Score* score, MxmlInstrumentMap&amp; instrMap)</a>
<a name="ln5374">      {</a>
<a name="ln5375">      xml.stag(&quot;part-list&quot;);</a>
<a name="ln5376">      int staffCount = 0;                             // count sum of # staves in parts</a>
<a name="ln5377">      const auto&amp; parts = score-&gt;parts();</a>
<a name="ln5378">      int partGroupEnd[MAX_PART_GROUPS];              // staff where part group ends (bracketSpan is in staves, not parts)</a>
<a name="ln5379">      for (int i = 0; i &lt; MAX_PART_GROUPS; i++)</a>
<a name="ln5380">            partGroupEnd[i] = -1;</a>
<a name="ln5381">      for (int idx = 0; idx &lt; parts.size(); ++idx) {</a>
<a name="ln5382">            const auto part = parts.at(idx);</a>
<a name="ln5383">            bool bracketFound = false;</a>
<a name="ln5384">            // handle brackets</a>
<a name="ln5385">            for (int i = 0; i &lt; part-&gt;nstaves(); i++) {</a>
<a name="ln5386">                  Staff* st = part-&gt;staff(i);</a>
<a name="ln5387">                  if (st) {</a>
<a name="ln5388">                        for (int j = 0; j &lt; st-&gt;bracketLevels() + 1; j++) {</a>
<a name="ln5389">                              if (st-&gt;bracketType(j) != BracketType::NO_BRACKET) {</a>
<a name="ln5390">                                    bracketFound = true;</a>
<a name="ln5391">                                    if (i == 0) {</a>
<a name="ln5392">                                          // OK, found bracket in first staff of part</a>
<a name="ln5393">                                          // filter out implicit brackets</a>
<a name="ln5394">                                          if (!(st-&gt;bracketSpan(j) == part-&gt;nstaves()</a>
<a name="ln5395">                                                &amp;&amp; st-&gt;bracketType(j) == BracketType::BRACE)) {</a>
<a name="ln5396">                                                // add others</a>
<a name="ln5397">                                                int number = findPartGroupNumber(partGroupEnd);</a>
<a name="ln5398">                                                if (number &lt; MAX_PART_GROUPS) {</a>
<a name="ln5399">                                                      partGroupStart(xml, number + 1, st-&gt;bracketType(j));</a>
<a name="ln5400">                                                      partGroupEnd[number] = staffCount + st-&gt;bracketSpan(j);</a>
<a name="ln5401">                                                      }</a>
<a name="ln5402">                                                }</a>
<a name="ln5403">                                          }</a>
<a name="ln5404">                                    else {</a>
<a name="ln5405">                                          // bracket in other staff not supported in MusicXML</a>
<a name="ln5406">                                          qDebug(&quot;bracket starting in staff %d not supported&quot;, i + 1);</a>
<a name="ln5407">                                          }</a>
<a name="ln5408">                                    }</a>
<a name="ln5409">                              }</a>
<a name="ln5410">                        }</a>
<a name="ln5411">                  }</a>
<a name="ln5412">            // handle bracket none</a>
<a name="ln5413">            if (!bracketFound &amp;&amp; part-&gt;nstaves() &gt; 1) {</a>
<a name="ln5414">                  int number = findPartGroupNumber(partGroupEnd);</a>
<a name="ln5415">                  if (number &lt; MAX_PART_GROUPS) {</a>
<a name="ln5416">                        partGroupStart(xml, number + 1, BracketType::NO_BRACKET);</a>
<a name="ln5417">                        partGroupEnd[number] = idx + part-&gt;nstaves();</a>
<a name="ln5418">                        }</a>
<a name="ln5419">                  }</a>
<a name="ln5420"> </a>
<a name="ln5421">            xml.stag(QString(&quot;score-part id=\&quot;P%1\&quot;&quot;).arg(idx+1));</a>
<a name="ln5422">            initInstrMap(instrMap, part-&gt;instruments(), score);</a>
<a name="ln5423">            // by default export the parts long name as part-name</a>
<a name="ln5424">            if (part-&gt;longName() != &quot;&quot;)</a>
<a name="ln5425">                  xml.tag(&quot;part-name&quot;, MScoreTextToMXML::toPlainText(part-&gt;longName()));</a>
<a name="ln5426">            else {</a>
<a name="ln5427">                  if (part-&gt;partName() != &quot;&quot;) {</a>
<a name="ln5428">                        // use the track name if no part long name</a>
<a name="ln5429">                        // to prevent an empty track name on import</a>
<a name="ln5430">                        xml.tag(&quot;part-name print-object=\&quot;no\&quot;&quot;, MScoreTextToMXML::toPlainText(part-&gt;partName()));</a>
<a name="ln5431">                        }</a>
<a name="ln5432">                  else</a>
<a name="ln5433">                        // part-name is required</a>
<a name="ln5434">                        xml.tag(&quot;part-name&quot;, &quot;&quot;);</a>
<a name="ln5435">                  }</a>
<a name="ln5436">            if (!part-&gt;shortName().isEmpty())</a>
<a name="ln5437">                  xml.tag(&quot;part-abbreviation&quot;, MScoreTextToMXML::toPlainText(part-&gt;shortName()));</a>
<a name="ln5438"> </a>
<a name="ln5439">            if (part-&gt;instrument()-&gt;useDrumset()) {</a>
<a name="ln5440">                  const Drumset* drumset = part-&gt;instrument()-&gt;drumset();</a>
<a name="ln5441">                  pitchSet pitches;</a>
<a name="ln5442">                  findPitchesUsed(part, pitches);</a>
<a name="ln5443">                  for (int i = 0; i &lt; 128; ++i) {</a>
<a name="ln5444">                        DrumInstrument di = drumset-&gt;drum(i);</a>
<a name="ln5445">                        if (di.notehead != NoteHead::Group::HEAD_INVALID)</a>
<a name="ln5446">                              scoreInstrument(xml, idx + 1, i + 1, di.name);</a>
<a name="ln5447">                        else if (pitches.contains(i))</a>
<a name="ln5448">                              scoreInstrument(xml, idx + 1, i + 1, QString(&quot;Instrument %1&quot;).arg(i + 1));</a>
<a name="ln5449">                        }</a>
<a name="ln5450">                  int midiPort = part-&gt;midiPort() + 1;</a>
<a name="ln5451">                  if (midiPort &gt;= 1 &amp;&amp; midiPort &lt;= 16)</a>
<a name="ln5452">                        xml.tag(QString(&quot;midi-device port=\&quot;%1\&quot;&quot;).arg(midiPort), &quot;&quot;);</a>
<a name="ln5453"> </a>
<a name="ln5454">                  for (int i = 0; i &lt; 128; ++i) {</a>
<a name="ln5455">                        DrumInstrument di = drumset-&gt;drum(i);</a>
<a name="ln5456">                        if (di.notehead != NoteHead::Group::HEAD_INVALID || pitches.contains(i))</a>
<a name="ln5457">                              midiInstrument(xml, idx + 1, i + 1, part-&gt;instrument(), score, i + 1);</a>
<a name="ln5458">                        }</a>
<a name="ln5459">                  }</a>
<a name="ln5460">            else {</a>
<a name="ln5461">                  MxmlReverseInstrumentMap rim;</a>
<a name="ln5462">                  initReverseInstrMap(rim, instrMap);</a>
<a name="ln5463">                  for (int instNr : rim.keys()) {</a>
<a name="ln5464">                        scoreInstrument(xml, idx + 1, instNr + 1, MScoreTextToMXML::toPlainText(rim.value(instNr)-&gt;trackName()));</a>
<a name="ln5465">                        }</a>
<a name="ln5466">                  for (auto ii = rim.constBegin(); ii != rim.constEnd(); ii++) {</a>
<a name="ln5467">                        int instNr = ii.key();</a>
<a name="ln5468">                        int midiPort = part-&gt;midiPort() + 1;</a>
<a name="ln5469">                        if (ii.value()-&gt;channel().size() &gt; 0)</a>
<a name="ln5470">                              midiPort = score-&gt;masterScore()-&gt;midiMapping(ii.value()-&gt;channel(0)-&gt;channel())-&gt;port() + 1;</a>
<a name="ln5471">                        if (midiPort &gt;= 1 &amp;&amp; midiPort &lt;= 16)</a>
<a name="ln5472">                              xml.tag(QString(&quot;midi-device %1 port=\&quot;%2\&quot;&quot;).arg(instrId(idx+1, instNr + 1)).arg(midiPort), &quot;&quot;);</a>
<a name="ln5473">                        else</a>
<a name="ln5474">                              xml.tag(QString(&quot;midi-device %1&quot;).arg(instrId(idx+1, instNr + 1)), &quot;&quot;);</a>
<a name="ln5475">                        midiInstrument(xml, idx + 1, instNr + 1, rim.value(instNr), score);</a>
<a name="ln5476">                        }</a>
<a name="ln5477">                  }</a>
<a name="ln5478"> </a>
<a name="ln5479">            xml.etag();</a>
<a name="ln5480">            staffCount += part-&gt;nstaves();</a>
<a name="ln5481">            for (int i = MAX_PART_GROUPS - 1; i &gt;= 0; i--) {</a>
<a name="ln5482">                  int end = partGroupEnd[i];</a>
<a name="ln5483">                  if (end &gt;= 0) {</a>
<a name="ln5484">                        if (staffCount &gt;= end) {</a>
<a name="ln5485">                              xml.tagE(QString(&quot;part-group type=\&quot;stop\&quot; number=\&quot;%1\&quot;&quot;).arg(i + 1));</a>
<a name="ln5486">                              partGroupEnd[i] = -1;</a>
<a name="ln5487">                              }</a>
<a name="ln5488">                        }</a>
<a name="ln5489">                  }</a>
<a name="ln5490">            }</a>
<a name="ln5491">      xml.etag();</a>
<a name="ln5492"> </a>
<a name="ln5493">      }</a>
<a name="ln5494"> </a>
<a name="ln5495">//---------------------------------------------------------</a>
<a name="ln5496">//  tickIsInMiddleOfMeasure</a>
<a name="ln5497">//---------------------------------------------------------</a>
<a name="ln5498"> </a>
<a name="ln5499">static bool tickIsInMiddleOfMeasure(const Fraction ti, const Measure* m)</a>
<a name="ln5500">      {</a>
<a name="ln5501">      return ti != m-&gt;tick() &amp;&amp; ti != m-&gt;endTick();</a>
<a name="ln5502">      }</a>
<a name="ln5503"> </a>
<a name="ln5504">//---------------------------------------------------------</a>
<a name="ln5505">//  writeElement</a>
<a name="ln5506">//---------------------------------------------------------</a>
<a name="ln5507"> </a>
<a name="ln5508">/**</a>
<a name="ln5509"> Write \a el.</a>
<a name="ln5510"> */</a>
<a name="ln5511"> </a>
<a name="ln5512">void ExportMusicXml::writeElement(Element* el, const Measure* m, int sstaff, bool useDrumset)</a>
<a name="ln5513">      {</a>
<a name="ln5514">      if (el-&gt;isClef()) {</a>
<a name="ln5515">            // output only clef changes, not generated clefs</a>
<a name="ln5516">            // at line beginning</a>
<a name="ln5517">            // also ignore clefs at the start of a measure,</a>
<a name="ln5518">            // these have already been output</a>
<a name="ln5519">            // also ignore clefs at the end of a measure</a>
<a name="ln5520">            // these will be output at the start of the next measure</a>
<a name="ln5521">            const auto cle = toClef(el);</a>
<a name="ln5522">            const auto ti = cle-&gt;segment()-&gt;tick();</a>
<a name="ln5523">            clefDebug(&quot;exportxml: clef in measure ti=%d ct=%d gen=%d&quot;, ti, int(cle-&gt;clefType()), el-&gt;generated());</a>
<a name="ln5524">            if (el-&gt;generated()) {</a>
<a name="ln5525">                  clefDebug(&quot;exportxml: generated clef not exported&quot;);</a>
<a name="ln5526">                  }</a>
<a name="ln5527">            else if (!el-&gt;generated() &amp;&amp; tickIsInMiddleOfMeasure(ti, m))</a>
<a name="ln5528">                  clef(sstaff, cle-&gt;clefType(), color2xml(cle));</a>
<a name="ln5529">            else</a>
<a name="ln5530">                  clefDebug(&quot;exportxml: clef not exported&quot;);</a>
<a name="ln5531">            }</a>
<a name="ln5532">      else if (el-&gt;isChord()) {</a>
<a name="ln5533">            const auto c = toChord(el);</a>
<a name="ln5534">            const auto ll = &amp;c-&gt;lyrics();</a>
<a name="ln5535">            // ise grace after</a>
<a name="ln5536">            if (c) {</a>
<a name="ln5537">                  for (const auto g : c-&gt;graceNotesBefore()) {</a>
<a name="ln5538">                        chord(g, sstaff, ll, useDrumset);</a>
<a name="ln5539">                        }</a>
<a name="ln5540">                  chord(c, sstaff, ll, useDrumset);</a>
<a name="ln5541">                  for (const auto g : c-&gt;graceNotesAfter()) {</a>
<a name="ln5542">                        chord(g, sstaff, ll, useDrumset);</a>
<a name="ln5543">                        }</a>
<a name="ln5544">                  }</a>
<a name="ln5545">            }</a>
<a name="ln5546">      else if (el-&gt;isRest()) {</a>
<a name="ln5547">            const auto r = toRest(el);</a>
<a name="ln5548">            if (!(r-&gt;isGap()))</a>
<a name="ln5549">                  rest(r, sstaff);</a>
<a name="ln5550">            }</a>
<a name="ln5551">      else if (el-&gt;isBarLine()) {</a>
<a name="ln5552">            const auto barln = toBarLine(el);</a>
<a name="ln5553">            if (tickIsInMiddleOfMeasure(barln-&gt;tick(), m))</a>
<a name="ln5554">                  barlineMiddle(barln);</a>
<a name="ln5555">            }</a>
<a name="ln5556">      else if (el-&gt;isKeySig() || el-&gt;isTimeSig() || el-&gt;isBreath()) {</a>
<a name="ln5557">            // handled elsewhere</a>
<a name="ln5558">            }</a>
<a name="ln5559">      else</a>
<a name="ln5560">            qDebug(&quot;ExportMusicXml::write unknown segment type %s&quot;, el-&gt;name());</a>
<a name="ln5561">      }</a>
<a name="ln5562"> </a>
<a name="ln5563">//---------------------------------------------------------</a>
<a name="ln5564">//  writeStaffDetails</a>
<a name="ln5565">//---------------------------------------------------------</a>
<a name="ln5566"> </a>
<a name="ln5567">/**</a>
<a name="ln5568"> Write the staff details for \a part to \a xml.</a>
<a name="ln5569"> */</a>
<a name="ln5570"> </a>
<a name="ln5571">static void writeStaffDetails(XmlWriter&amp; xml, const Part* part)</a>
<a name="ln5572">      {</a>
<a name="ln5573">      const Instrument* instrument = part-&gt;instrument();</a>
<a name="ln5574">      int staves = part-&gt;nstaves();</a>
<a name="ln5575"> </a>
<a name="ln5576">      // staff details</a>
<a name="ln5577">      // TODO: decide how to handle linked regular / TAB staff</a>
<a name="ln5578">      //       currently exported as a two staff part ...</a>
<a name="ln5579">      for (int i = 0; i &lt; staves; i++) {</a>
<a name="ln5580">            Staff* st = part-&gt;staff(i);</a>
<a name="ln5581">            if (st-&gt;lines(Fraction(0,1)) != 5 || st-&gt;isTabStaff(Fraction(0,1))) {</a>
<a name="ln5582">                  if (staves &gt; 1)</a>
<a name="ln5583">                        xml.stag(QString(&quot;staff-details number=\&quot;%1\&quot;&quot;).arg(i+1));</a>
<a name="ln5584">                  else</a>
<a name="ln5585">                        xml.stag(&quot;staff-details&quot;);</a>
<a name="ln5586">                  xml.tag(&quot;staff-lines&quot;, st-&gt;lines(Fraction(0,1)));</a>
<a name="ln5587">                  if (st-&gt;isTabStaff(Fraction(0,1)) &amp;&amp; instrument-&gt;stringData()) {</a>
<a name="ln5588">                        QList&lt;instrString&gt; l = instrument-&gt;stringData()-&gt;stringList();</a>
<a name="ln5589">                        for (int ii = 0; ii &lt; l.size(); ii++) {</a>
<a name="ln5590">                              char step  = ' ';</a>
<a name="ln5591">                              int alter  = 0;</a>
<a name="ln5592">                              int octave = 0;</a>
<a name="ln5593">                              midipitch2xml(l.at(ii).pitch, step, alter, octave);</a>
<a name="ln5594">                              xml.stag(QString(&quot;staff-tuning line=\&quot;%1\&quot;&quot;).arg(ii+1));</a>
<a name="ln5595">                              xml.tag(&quot;tuning-step&quot;, QString(&quot;%1&quot;).arg(step));</a>
<a name="ln5596">                              if (alter)</a>
<a name="ln5597">                                    xml.tag(&quot;tuning-alter&quot;, alter);</a>
<a name="ln5598">                              xml.tag(&quot;tuning-octave&quot;, octave);</a>
<a name="ln5599">                              xml.etag();</a>
<a name="ln5600">                              }</a>
<a name="ln5601">                        }</a>
<a name="ln5602">                  xml.etag();</a>
<a name="ln5603">                  }</a>
<a name="ln5604">            }</a>
<a name="ln5605">      }</a>
<a name="ln5606"> </a>
<a name="ln5607">//---------------------------------------------------------</a>
<a name="ln5608">//  writeInstrumentDetails</a>
<a name="ln5609">//---------------------------------------------------------</a>
<a name="ln5610"> </a>
<a name="ln5611">/**</a>
<a name="ln5612"> Write the instrument details for \a instrument.</a>
<a name="ln5613"> */</a>
<a name="ln5614"> </a>
<a name="ln5615">void ExportMusicXml::writeInstrumentDetails(const Instrument* instrument)</a>
<a name="ln5616">      {</a>
<a name="ln5617">      if (instrument-&gt;transpose().chromatic) {</a>
<a name="ln5618">            _attr.doAttr(_xml, true);</a>
<a name="ln5619">            _xml.stag(&quot;transpose&quot;);</a>
<a name="ln5620">            _xml.tag(&quot;diatonic&quot;,  instrument-&gt;transpose().diatonic % 7);</a>
<a name="ln5621">            _xml.tag(&quot;chromatic&quot;, instrument-&gt;transpose().chromatic % 12);</a>
<a name="ln5622">            int octaveChange = instrument-&gt;transpose().chromatic / 12;</a>
<a name="ln5623">            if (octaveChange != 0)</a>
<a name="ln5624">                  _xml.tag(&quot;octave-change&quot;, octaveChange);</a>
<a name="ln5625">            _xml.etag();</a>
<a name="ln5626">            _attr.doAttr(_xml, false);</a>
<a name="ln5627">            }</a>
<a name="ln5628">      }</a>
<a name="ln5629"> </a>
<a name="ln5630">//---------------------------------------------------------</a>
<a name="ln5631">//  annotationsWithoutNote</a>
<a name="ln5632">//---------------------------------------------------------</a>
<a name="ln5633"> </a>
<a name="ln5634">/**</a>
<a name="ln5635"> Write the annotations that could not be attached to notes.</a>
<a name="ln5636"> */</a>
<a name="ln5637"> </a>
<a name="ln5638">static void annotationsWithoutNote(ExportMusicXml* exp, const int strack, const int staves, const Measure* const measure)</a>
<a name="ln5639">      {</a>
<a name="ln5640">      for (auto segment = measure-&gt;first(); segment; segment = segment-&gt;next()) {</a>
<a name="ln5641">            if (segment-&gt;segmentType() == SegmentType::ChordRest) {</a>
<a name="ln5642">                  for (const auto element : segment-&gt;annotations()) {</a>
<a name="ln5643">                        if (!element-&gt;isFiguredBass() &amp;&amp; !element-&gt;isHarmony()) {       // handled elsewhere</a>
<a name="ln5644">                              const auto wtrack = findTrackForAnnotations(element-&gt;track(), segment); // track to write annotation</a>
<a name="ln5645">                              if (strack &lt;= element-&gt;track() &amp;&amp; element-&gt;track() &lt; (strack + VOICES * staves) &amp;&amp; wtrack &lt; 0)</a>
<a name="ln5646">                                    commonAnnotations(exp, element, staves &gt; 1 ? 1 : 0);</a>
<a name="ln5647">                              }</a>
<a name="ln5648">                        }</a>
<a name="ln5649">                  }</a>
<a name="ln5650"> </a>
<a name="ln5651">            }</a>
<a name="ln5652">      }</a>
<a name="ln5653"> </a>
<a name="ln5654">//---------------------------------------------------------</a>
<a name="ln5655">//  MeasureNumberStateHandler</a>
<a name="ln5656">//---------------------------------------------------------</a>
<a name="ln5657"> </a>
<a name="ln5658">MeasureNumberStateHandler::MeasureNumberStateHandler()</a>
<a name="ln5659">      {</a>
<a name="ln5660">      init();</a>
<a name="ln5661">      }</a>
<a name="ln5662"> </a>
<a name="ln5663">void MeasureNumberStateHandler::init()</a>
<a name="ln5664">      {</a>
<a name="ln5665">      _measureNo = 1;</a>
<a name="ln5666">      _irregularMeasureNo = 1;</a>
<a name="ln5667">      _pickupMeasureNo = 1;</a>
<a name="ln5668">      }</a>
<a name="ln5669"> </a>
<a name="ln5670"> </a>
<a name="ln5671">void MeasureNumberStateHandler::updateForMeasure(const Measure* const m)</a>
<a name="ln5672">      {</a>
<a name="ln5673">      // restart measure numbering after a section break if startWithMeasureOne is set</a>
<a name="ln5674">      // check the previous MeasureBase instead of Measure to catch breaks in frames too</a>
<a name="ln5675">      const auto previousMB = m-&gt;prev();</a>
<a name="ln5676">      if (previousMB) {</a>
<a name="ln5677">            const auto layoutSectionBreak = previousMB-&gt;sectionBreakElement();</a>
<a name="ln5678">            if (layoutSectionBreak &amp;&amp; layoutSectionBreak-&gt;startWithMeasureOne())</a>
<a name="ln5679">                  init();</a>
<a name="ln5680">            }</a>
<a name="ln5681"> </a>
<a name="ln5682">      // update measure numbers and cache result</a>
<a name="ln5683">      _cachedAttributes = &quot; number=&quot;;</a>
<a name="ln5684">      if ((_irregularMeasureNo + _measureNo) == 2 &amp;&amp; m-&gt;irregular()) {</a>
<a name="ln5685">            _cachedAttributes += &quot;\&quot;0\&quot; implicit=\&quot;yes\&quot;&quot;;</a>
<a name="ln5686">            _pickupMeasureNo++;</a>
<a name="ln5687">            }</a>
<a name="ln5688">      else if (m-&gt;irregular())</a>
<a name="ln5689">            _cachedAttributes += QString(&quot;\&quot;X%1\&quot; implicit=\&quot;yes\&quot;&quot;).arg(_irregularMeasureNo++);</a>
<a name="ln5690">      else</a>
<a name="ln5691">            _cachedAttributes += QString(&quot;\&quot;%1\&quot;&quot;).arg(_measureNo++);</a>
<a name="ln5692">      }</a>
<a name="ln5693"> </a>
<a name="ln5694">QString MeasureNumberStateHandler::measureNumber() const</a>
<a name="ln5695">      {</a>
<a name="ln5696">      return _cachedAttributes;</a>
<a name="ln5697">      }</a>
<a name="ln5698"> </a>
<a name="ln5699">bool MeasureNumberStateHandler::isFirstActualMeasure() const</a>
<a name="ln5700">      {</a>
<a name="ln5701">      return (_irregularMeasureNo + _measureNo + _pickupMeasureNo) == 4;</a>
<a name="ln5702">      }</a>
<a name="ln5703"> </a>
<a name="ln5704">//---------------------------------------------------------</a>
<a name="ln5705">//  findLastSystemWithMeasures</a>
<a name="ln5706">//---------------------------------------------------------</a>
<a name="ln5707"> </a>
<a name="ln5708">static System* findLastSystemWithMeasures(const Page* const page)</a>
<a name="ln5709">      {</a>
<a name="ln5710">      for (int i = page-&gt;systems().size() - 1; i &gt;= 0; --i) {</a>
<a name="ln5711">            const auto s = page-&gt;systems().at(i);</a>
<a name="ln5712">            const auto m = s-&gt;firstMeasure();</a>
<a name="ln5713">            if (m)</a>
<a name="ln5714">                  return s;</a>
<a name="ln5715">            }</a>
<a name="ln5716">      return nullptr;</a>
<a name="ln5717">      }</a>
<a name="ln5718"> </a>
<a name="ln5719">//---------------------------------------------------------</a>
<a name="ln5720">//  isFirstMeasureInSystem</a>
<a name="ln5721">//---------------------------------------------------------</a>
<a name="ln5722"> </a>
<a name="ln5723">static bool isFirstMeasureInSystem(const Measure* const measure)</a>
<a name="ln5724">      {</a>
<a name="ln5725">      const auto system = measure-&gt;mmRest1()-&gt;system();</a>
<a name="ln5726">      const auto firstMeasureInSystem = system-&gt;firstMeasure();</a>
<a name="ln5727">      const auto realFirstMeasureInSystem = firstMeasureInSystem-&gt;isMMRest() ? firstMeasureInSystem-&gt;mmRestFirst() : firstMeasureInSystem;</a>
<a name="ln5728">      return measure == realFirstMeasureInSystem;</a>
<a name="ln5729">      }</a>
<a name="ln5730">//---------------------------------------------------------</a>
<a name="ln5731">//  isFirstMeasureInLastSystem</a>
<a name="ln5732">//---------------------------------------------------------</a>
<a name="ln5733"> </a>
<a name="ln5734">static bool isFirstMeasureInLastSystem(const Measure* const measure)</a>
<a name="ln5735">      {</a>
<a name="ln5736">      const auto system = measure-&gt;mmRest1()-&gt;system();</a>
<a name="ln5737">      const auto page = system-&gt;page();</a>
<a name="ln5738"> </a>
<a name="ln5739">      /*</a>
<a name="ln5740">       Notes on multi-measure rest handling:</a>
<a name="ln5741">       Function mmRest1() returns either the measure itself (if not part of multi-measure rest)</a>
<a name="ln5742">       or the replacing multi-measure rest measure.</a>
<a name="ln5743">       Using this is required as a measure that is covered by a multi-measure rest has no system.</a>
<a name="ln5744">       Furthermore, the first measure in a system starting with a multi-measure rest is the a multi-</a>
<a name="ln5745">       measure rest itself instead of the first covered measure.</a>
<a name="ln5746">       */</a>
<a name="ln5747"> </a>
<a name="ln5748">      const auto lastSystem = findLastSystemWithMeasures(page);</a>
<a name="ln5749">      if (!lastSystem)</a>
<a name="ln5750">            return false;       // degenerate case: no system with measures found</a>
<a name="ln5751">      const auto firstMeasureInLastSystem = lastSystem-&gt;firstMeasure();</a>
<a name="ln5752">      const auto realFirstMeasureInLastSystem = firstMeasureInLastSystem-&gt;isMMRest() ? firstMeasureInLastSystem-&gt;mmRestFirst() : firstMeasureInLastSystem;</a>
<a name="ln5753">      return measure == realFirstMeasureInLastSystem;</a>
<a name="ln5754">      }</a>
<a name="ln5755"> </a>
<a name="ln5756">//---------------------------------------------------------</a>
<a name="ln5757">//  systemHasMeasures</a>
<a name="ln5758">//---------------------------------------------------------</a>
<a name="ln5759"> </a>
<a name="ln5760">static bool systemHasMeasures(const System* const system)</a>
<a name="ln5761">      {</a>
<a name="ln5762">      return system-&gt;firstMeasure();</a>
<a name="ln5763">      }</a>
<a name="ln5764"> </a>
<a name="ln5765">//---------------------------------------------------------</a>
<a name="ln5766">//  findTextFramesToWriteAsWordsAbove</a>
<a name="ln5767">//---------------------------------------------------------</a>
<a name="ln5768"> </a>
<a name="ln5769">static std::vector&lt;TBox*&gt; findTextFramesToWriteAsWordsAbove(const Measure* const measure)</a>
<a name="ln5770">      {</a>
<a name="ln5771">      const auto system = measure-&gt;mmRest1()-&gt;system();</a>
<a name="ln5772">      const auto page = system-&gt;page();</a>
<a name="ln5773">      const auto systemIndex = page-&gt;systems().indexOf(system);</a>
<a name="ln5774">      std::vector&lt;TBox*&gt; tboxes;</a>
<a name="ln5775">      if (isFirstMeasureInSystem(measure)) {</a>
<a name="ln5776">            for (auto idx = systemIndex - 1; idx &gt;= 0 &amp;&amp; !systemHasMeasures(page-&gt;system(idx)); --idx) {</a>
<a name="ln5777">                  const auto sys = page-&gt;system(idx);</a>
<a name="ln5778">                  for (const auto mb : sys-&gt;measures()) {</a>
<a name="ln5779">                        if (mb-&gt;isTBox()) {</a>
<a name="ln5780">                              auto tbox = toTBox(mb);</a>
<a name="ln5781">                              tboxes.insert(tboxes.begin(), tbox);</a>
<a name="ln5782">                              }</a>
<a name="ln5783">                        }</a>
<a name="ln5784">                  }</a>
<a name="ln5785">            }</a>
<a name="ln5786">      return tboxes;</a>
<a name="ln5787">      }</a>
<a name="ln5788"> </a>
<a name="ln5789">//---------------------------------------------------------</a>
<a name="ln5790">//  findTextFramesToWriteAsWordsBelow</a>
<a name="ln5791">//---------------------------------------------------------</a>
<a name="ln5792"> </a>
<a name="ln5793">static std::vector&lt;TBox*&gt; findTextFramesToWriteAsWordsBelow(const Measure* const measure)</a>
<a name="ln5794">      {</a>
<a name="ln5795">      const auto system = measure-&gt;mmRest1()-&gt;system();</a>
<a name="ln5796">      const auto page = system-&gt;page();</a>
<a name="ln5797">      const auto systemIndex = page-&gt;systems().indexOf(system);</a>
<a name="ln5798">      std::vector&lt;TBox*&gt; tboxes;</a>
<a name="ln5799">      if (isFirstMeasureInLastSystem(measure)) {</a>
<a name="ln5800">            for (auto idx = systemIndex + 1; idx &lt; page-&gt;systems().size() /* &amp;&amp; !systemHasMeasures(page-&gt;system(idx))*/; ++idx) {</a>
<a name="ln5801">                  const auto sys = page-&gt;system(idx);</a>
<a name="ln5802">                  for (const auto mb : sys-&gt;measures()) {</a>
<a name="ln5803">                        if (mb-&gt;isTBox()) {</a>
<a name="ln5804">                              auto tbox = toTBox(mb);</a>
<a name="ln5805">                              tboxes.insert(tboxes.begin(), tbox);</a>
<a name="ln5806">                              }</a>
<a name="ln5807">                        }</a>
<a name="ln5808">                  }</a>
<a name="ln5809">            }</a>
<a name="ln5810">      return tboxes;</a>
<a name="ln5811">      }</a>
<a name="ln5812"> </a>
<a name="ln5813">//---------------------------------------------------------</a>
<a name="ln5814">//  writeMeasureTracks</a>
<a name="ln5815">//---------------------------------------------------------</a>
<a name="ln5816"> </a>
<a name="ln5817">/**</a>
<a name="ln5818"> Write data contained in the measure's tracks.</a>
<a name="ln5819"> */</a>
<a name="ln5820"> </a>
<a name="ln5821">void ExportMusicXml::writeMeasureTracks(const Measure* const m,</a>
<a name="ln5822">                                        const int partIndex,</a>
<a name="ln5823">                                        const int strack, const int staves, // TODO remove ??</a>
<a name="ln5824">                                        const bool useDrumset,</a>
<a name="ln5825">                                        FigBassMap&amp; fbMap)</a>
<a name="ln5826">      {</a>
<a name="ln5827">      bool tboxesAboveWritten = false;</a>
<a name="ln5828">      const auto tboxesAbove = findTextFramesToWriteAsWordsAbove(m);</a>
<a name="ln5829"> </a>
<a name="ln5830">      bool tboxesBelowWritten = false;</a>
<a name="ln5831">      const auto tboxesBelow = findTextFramesToWriteAsWordsBelow(m);</a>
<a name="ln5832"> </a>
<a name="ln5833">      const int etrack = strack + VOICES * staves;</a>
<a name="ln5834">      // set of spanners already stopped in this measure</a>
<a name="ln5835">      // required to prevent multiple spanner stops for the same spanner</a>
<a name="ln5836">      QSet&lt;const Spanner*&gt; spannersStopped;</a>
<a name="ln5837"> </a>
<a name="ln5838">      for (int st = strack; st &lt; etrack; ++st) {</a>
<a name="ln5839">            // sstaff - xml staff number, counting from 1 for this</a>
<a name="ln5840">            // instrument</a>
<a name="ln5841">            // special number 0 -&gt; dont show staff number in</a>
<a name="ln5842">            // xml output (because there is only one staff)</a>
<a name="ln5843"> </a>
<a name="ln5844">            int sstaff = (staves &gt; 1) ? st - strack + VOICES : 0;</a>
<a name="ln5845">            sstaff /= VOICES;</a>
<a name="ln5846">            for (auto seg = m-&gt;first(); seg; seg = seg-&gt;next()) {</a>
<a name="ln5847">                  const auto el = seg-&gt;element(st);</a>
<a name="ln5848">                  if (!el) {</a>
<a name="ln5849">                        continue;</a>
<a name="ln5850">                        }</a>
<a name="ln5851">                  // must ignore start repeat to prevent spurious backup/forward</a>
<a name="ln5852">                  if (el-&gt;isBarLine() &amp;&amp; toBarLine(el)-&gt;barLineType() == BarLineType::START_REPEAT)</a>
<a name="ln5853">                        continue;</a>
<a name="ln5854"> </a>
<a name="ln5855">                  // generate backup or forward to the start time of the element</a>
<a name="ln5856">                  if (_tick != seg-&gt;tick()) {</a>
<a name="ln5857">                        _attr.doAttr(_xml, false);</a>
<a name="ln5858">                        moveToTick(seg-&gt;tick());</a>
<a name="ln5859">                        }</a>
<a name="ln5860"> </a>
<a name="ln5861">                  // handle annotations and spanners (directions attached to this note or rest)</a>
<a name="ln5862">                  if (el-&gt;isChordRest()) {</a>
<a name="ln5863">                        _attr.doAttr(_xml, false);</a>
<a name="ln5864">                        const bool isFirstPart = (partIndex == 0);</a>
<a name="ln5865">                        const bool isLastPart = (partIndex == (_score-&gt;parts().size() - 1));</a>
<a name="ln5866">                        if (!tboxesAboveWritten &amp;&amp; isFirstPart) {</a>
<a name="ln5867">                              for (const auto tbox : tboxesAbove) {</a>
<a name="ln5868">                                    // note: use mmRest1() to get at a possible multi-measure rest,</a>
<a name="ln5869">                                    // as the covered measure would be positioned at 0,0.</a>
<a name="ln5870">                                    tboxTextAsWords(tbox-&gt;text(), 0, tbox-&gt;text()-&gt;canvasPos() - m-&gt;mmRest1()-&gt;canvasPos());</a>
<a name="ln5871">                                    }</a>
<a name="ln5872">                              tboxesAboveWritten = true;</a>
<a name="ln5873">                              }</a>
<a name="ln5874">                        if (!tboxesBelowWritten &amp;&amp; isLastPart &amp;&amp; (etrack - VOICES) &lt;= st) {</a>
<a name="ln5875">                              for (const auto tbox : tboxesBelow) {</a>
<a name="ln5876">                                    const auto lastStaffNr = st / VOICES;</a>
<a name="ln5877">                                    const auto sys = m-&gt;mmRest1()-&gt;system();</a>
<a name="ln5878">                                    auto textPos = tbox-&gt;text()-&gt;canvasPos() - m-&gt;mmRest1()-&gt;canvasPos();</a>
<a name="ln5879">                                    if (lastStaffNr &lt; sys-&gt;staves()-&gt;size()) {</a>
<a name="ln5880">                                          // convert to position relative to last staff of system</a>
<a name="ln5881">                                          textPos.setY(textPos.y() - (sys-&gt;staffCanvasYpage(lastStaffNr) - sys-&gt;staffCanvasYpage(0)));</a>
<a name="ln5882">                                          }</a>
<a name="ln5883">                                    tboxTextAsWords(tbox-&gt;text(), sstaff, textPos);</a>
<a name="ln5884">                                    }</a>
<a name="ln5885">                              tboxesBelowWritten = true;</a>
<a name="ln5886">                              }</a>
<a name="ln5887">                        annotations(this, strack, etrack, st, sstaff, seg);</a>
<a name="ln5888">                        // look for more harmony</a>
<a name="ln5889">                        for (auto seg1 = seg-&gt;next(); seg1; seg1 = seg1-&gt;next()) {</a>
<a name="ln5890">                              if (seg1-&gt;isChordRestType()) {</a>
<a name="ln5891">                                    const auto el1 = seg1-&gt;element(st);</a>
<a name="ln5892">                                    if (el1) // found a ChordRest, next harmony will be attach to this one</a>
<a name="ln5893">                                          break;</a>
<a name="ln5894">                                    for (auto annot : seg1-&gt;annotations()) {</a>
<a name="ln5895">                                          if (annot-&gt;isHarmony() &amp;&amp; annot-&gt;track() == st)</a>
<a name="ln5896">                                                harmony(toHarmony(annot), 0, (seg1-&gt;tick() - seg-&gt;tick()).ticks() / div);</a>
<a name="ln5897">                                          }</a>
<a name="ln5898">                                    }</a>
<a name="ln5899">                              }</a>
<a name="ln5900">                        figuredBass(_xml, strack, etrack, st, static_cast&lt;const ChordRest*&gt;(el), fbMap, div);</a>
<a name="ln5901">                        spannerStart(this, strack, etrack, st, sstaff, seg);</a>
<a name="ln5902">                        }</a>
<a name="ln5903"> </a>
<a name="ln5904">                  // write element el if necessary</a>
<a name="ln5905">                  writeElement(el, m, sstaff, useDrumset);</a>
<a name="ln5906"> </a>
<a name="ln5907">                  // handle annotations and spanners (directions attached to this note or rest)</a>
<a name="ln5908">                  if (el-&gt;isChordRest()) {</a>
<a name="ln5909">                        const int spannerStaff = st / VOICES;</a>
<a name="ln5910">                        const int starttrack = spannerStaff * VOICES;</a>
<a name="ln5911">                        const int endtrack = (spannerStaff + 1) * VOICES;</a>
<a name="ln5912">                        spannerStop(this, starttrack, endtrack, _tick, sstaff, spannersStopped);</a>
<a name="ln5913">                        }</a>
<a name="ln5914"> </a>
<a name="ln5915">                  } // for (Segment* seg = ...</a>
<a name="ln5916">            _attr.stop(_xml);</a>
<a name="ln5917">            } // for (int st = ...</a>
<a name="ln5918">      }</a>
<a name="ln5919"> </a>
<a name="ln5920">//---------------------------------------------------------</a>
<a name="ln5921">//  writeMeasure</a>
<a name="ln5922">//---------------------------------------------------------</a>
<a name="ln5923"> </a>
<a name="ln5924">/**</a>
<a name="ln5925"> Write a measure.</a>
<a name="ln5926"> */</a>
<a name="ln5927"> </a>
<a name="ln5928">void ExportMusicXml::writeMeasure(const Measure* const m,</a>
<a name="ln5929">                                  const int partIndex,</a>
<a name="ln5930">                                  const int staffCount,</a>
<a name="ln5931">                                  MeasureNumberStateHandler&amp; mnsh,</a>
<a name="ln5932">                                  FigBassMap&amp; fbMap,</a>
<a name="ln5933">                                  const MeasurePrintContext&amp; mpc)</a>
<a name="ln5934">      {</a>
<a name="ln5935">      const auto part = _score-&gt;parts().at(partIndex);</a>
<a name="ln5936">      const int staves = part-&gt;nstaves();</a>
<a name="ln5937">      const int strack = part-&gt;startTrack();</a>
<a name="ln5938">      const int etrack = part-&gt;endTrack();</a>
<a name="ln5939"> </a>
<a name="ln5940">      // pickup and other irregular measures need special care</a>
<a name="ln5941">      QString measureTag = &quot;measure&quot;;</a>
<a name="ln5942">      mnsh.updateForMeasure(m);</a>
<a name="ln5943">      measureTag += mnsh.measureNumber();</a>
<a name="ln5944">      const bool isFirstActualMeasure = mnsh.isFirstActualMeasure();</a>
<a name="ln5945"> </a>
<a name="ln5946">      if (preferences.getBool(PREF_EXPORT_MUSICXML_EXPORTLAYOUT))</a>
<a name="ln5947">            measureTag += QString(&quot; width=\&quot;%1\&quot;&quot;).arg(QString::number(m-&gt;bbox().width() / DPMM / millimeters * tenths,'f',2));</a>
<a name="ln5948"> </a>
<a name="ln5949">      _xml.stag(measureTag);</a>
<a name="ln5950"> </a>
<a name="ln5951">      print(m, partIndex, staffCount, staves, mpc);</a>
<a name="ln5952"> </a>
<a name="ln5953">      _attr.start();</a>
<a name="ln5954"> </a>
<a name="ln5955">      findTrills(m, strack, etrack, _trillStart, _trillStop);</a>
<a name="ln5956"> </a>
<a name="ln5957">      // barline left must be the first element in a measure</a>
<a name="ln5958">      barlineLeft(m);</a>
<a name="ln5959"> </a>
<a name="ln5960">      // output attributes with the first actual measure (pickup or regular)</a>
<a name="ln5961">      if (isFirstActualMeasure) {</a>
<a name="ln5962">            _attr.doAttr(_xml, true);</a>
<a name="ln5963">            _xml.tag(&quot;divisions&quot;, MScore::division / div);</a>
<a name="ln5964">            }</a>
<a name="ln5965"> </a>
<a name="ln5966">      // output attributes at start of measure: key, time</a>
<a name="ln5967">      keysigTimesig(m, part);</a>
<a name="ln5968"> </a>
<a name="ln5969">      // output attributes with the first actual measure (pickup or regular) only</a>
<a name="ln5970">      if (isFirstActualMeasure) {</a>
<a name="ln5971">            if (staves &gt; 1)</a>
<a name="ln5972">                  _xml.tag(&quot;staves&quot;, staves);</a>
<a name="ln5973">            if (instrMap.size() &gt; 1)</a>
<a name="ln5974">                  _xml.tag(&quot;instruments&quot;, instrMap.size());</a>
<a name="ln5975">            }</a>
<a name="ln5976"> </a>
<a name="ln5977">      // make sure clefs at end of measure get exported at start of next measure</a>
<a name="ln5978">      findAndExportClef(m, staves, strack, etrack);</a>
<a name="ln5979"> </a>
<a name="ln5980">      // make sure a clef gets exported if none is found</a>
<a name="ln5981">      exportDefaultClef(part, m);</a>
<a name="ln5982"> </a>
<a name="ln5983">      // output attributes with the first actual measure (pickup or regular) only</a>
<a name="ln5984">      if (isFirstActualMeasure) {</a>
<a name="ln5985">            writeStaffDetails(_xml, part);</a>
<a name="ln5986">            writeInstrumentDetails(part-&gt;instrument());</a>
<a name="ln5987">            }</a>
<a name="ln5988"> </a>
<a name="ln5989">      // output attribute at start of measure: measure-style</a>
<a name="ln5990">      measureStyle(_xml, _attr, m);</a>
<a name="ln5991"> </a>
<a name="ln5992">      // MuseScore limitation: repeats are always in the first part</a>
<a name="ln5993">      // and are implicitly placed at either measure start or stop</a>
<a name="ln5994">      if (partIndex == 0)</a>
<a name="ln5995">            repeatAtMeasureStart(_xml, _attr, m, strack, etrack, strack);</a>
<a name="ln5996"> </a>
<a name="ln5997">      // write data in the tracks</a>
<a name="ln5998">      writeMeasureTracks(m, partIndex, strack, staves, part-&gt;instrument()-&gt;useDrumset(), fbMap);</a>
<a name="ln5999"> </a>
<a name="ln6000">      // write the annotations that could not be attached to notes</a>
<a name="ln6001">      annotationsWithoutNote(this, strack, staves, m);</a>
<a name="ln6002"> </a>
<a name="ln6003">      // move to end of measure (in case of incomplete last voice)</a>
<a name="ln6004">       #ifdef DEBUG_TICK</a>
<a name="ln6005">      qDebug(&quot;end of measure&quot;);</a>
<a name="ln6006">       #endif</a>
<a name="ln6007">      moveToTick(m-&gt;endTick());</a>
<a name="ln6008">      if (partIndex == 0)</a>
<a name="ln6009">            repeatAtMeasureStop(_xml, m, strack, etrack, strack);</a>
<a name="ln6010">      // note: don't use &quot;m-&gt;repeatFlags() &amp; Repeat::END&quot; here, because more</a>
<a name="ln6011">      // barline types need to be handled besides repeat end (&quot;light-heavy&quot;)</a>
<a name="ln6012">      barlineRight(m);</a>
<a name="ln6013">      _xml.etag();</a>
<a name="ln6014">      }</a>
<a name="ln6015"> </a>
<a name="ln6016">//---------------------------------------------------------</a>
<a name="ln6017">//  measureWritten</a>
<a name="ln6018">//---------------------------------------------------------</a>
<a name="ln6019"> </a>
<a name="ln6020">void MeasurePrintContext::measureWritten(const Measure* m)</a>
<a name="ln6021">      {</a>
<a name="ln6022">      scoreStart = false;</a>
<a name="ln6023">      pageStart = false;</a>
<a name="ln6024">      systemStart = false;</a>
<a name="ln6025">      prevMeasure = m;</a>
<a name="ln6026">      }</a>
<a name="ln6027"> </a>
<a name="ln6028">//---------------------------------------------------------</a>
<a name="ln6029">//  writeParts</a>
<a name="ln6030">//---------------------------------------------------------</a>
<a name="ln6031"> </a>
<a name="ln6032">/**</a>
<a name="ln6033"> Write all parts.</a>
<a name="ln6034"> */</a>
<a name="ln6035"> </a>
<a name="ln6036">void ExportMusicXml::writeParts()</a>
<a name="ln6037">      {</a>
<a name="ln6038">      int staffCount = 0;</a>
<a name="ln6039">      const auto&amp; parts = _score-&gt;parts();</a>
<a name="ln6040"> </a>
<a name="ln6041">      for (int partIndex = 0; partIndex &lt; parts.size(); ++partIndex) {</a>
<a name="ln6042">            const auto part = parts.at(partIndex);</a>
<a name="ln6043">            _tick = { 0,1 };</a>
<a name="ln6044">            _xml.stag(QString(&quot;part id=\&quot;P%1\&quot;&quot;).arg(partIndex+1));</a>
<a name="ln6045"> </a>
<a name="ln6046">            _trillStart.clear();</a>
<a name="ln6047">            _trillStop.clear();</a>
<a name="ln6048">            initInstrMap(instrMap, part-&gt;instruments(), _score);</a>
<a name="ln6049"> </a>
<a name="ln6050">            MeasureNumberStateHandler mnsh;</a>
<a name="ln6051">            FigBassMap fbMap;                 // pending figured bass extends</a>
<a name="ln6052"> </a>
<a name="ln6053">            const auto&amp; pages = _score-&gt;pages();</a>
<a name="ln6054">            MeasurePrintContext mpc;</a>
<a name="ln6055"> </a>
<a name="ln6056">            for (int pageIndex = 0; pageIndex &lt; pages.size(); ++pageIndex) {</a>
<a name="ln6057">                  const auto page = pages.at(pageIndex);</a>
<a name="ln6058">                  mpc.pageStart = true;</a>
<a name="ln6059">                  const auto&amp; systems = page-&gt;systems();</a>
<a name="ln6060"> </a>
<a name="ln6061">                  for (int systemIndex = 0; systemIndex &lt; systems.size(); ++systemIndex) {</a>
<a name="ln6062">                        const auto system = systems.at(systemIndex);</a>
<a name="ln6063">                        mpc.systemStart = true;</a>
<a name="ln6064"> </a>
<a name="ln6065">                        for (const auto mb : system-&gt;measures()) {</a>
<a name="ln6066">                              if (!mb-&gt;isMeasure())</a>
<a name="ln6067">                                    continue;</a>
<a name="ln6068">                              const auto m = toMeasure(mb);</a>
<a name="ln6069"> </a>
<a name="ln6070">                              // write the measure or, in case of a multi measure rest,</a>
<a name="ln6071">                              // the measure range it replaces</a>
<a name="ln6072">                              if (m-&gt;isMMRest()) {</a>
<a name="ln6073">                                    auto m1 = m-&gt;mmRestFirst();</a>
<a name="ln6074">                                    const auto m2 = m-&gt;mmRestLast();</a>
<a name="ln6075">                                    for (;; ) {</a>
<a name="ln6076">                                          if (m1-&gt;isMeasure()) {</a>
<a name="ln6077">                                                writeMeasure(m1, partIndex, staffCount, mnsh, fbMap, mpc);</a>
<a name="ln6078">                                                mpc.measureWritten(m1);</a>
<a name="ln6079">                                                }</a>
<a name="ln6080">                                          if (m1 == m2)</a>
<a name="ln6081">                                                break;</a>
<a name="ln6082">                                          m1 = m1-&gt;nextMeasure();</a>
<a name="ln6083">                                          }</a>
<a name="ln6084">                                    }</a>
<a name="ln6085">                              else {</a>
<a name="ln6086">                                    writeMeasure(m, partIndex, staffCount, mnsh, fbMap, mpc);</a>
<a name="ln6087">                                    mpc.measureWritten(m);</a>
<a name="ln6088">                                    }</a>
<a name="ln6089"> </a>
<a name="ln6090">                              }</a>
<a name="ln6091">                        mpc.prevSystem = system;</a>
<a name="ln6092">                        }</a>
<a name="ln6093">                  mpc.lastSystemPrevPage = mpc.prevSystem;</a>
<a name="ln6094">                  }</a>
<a name="ln6095"> </a>
<a name="ln6096">            staffCount += part-&gt;nstaves();</a>
<a name="ln6097">            _xml.etag();</a>
<a name="ln6098">            }</a>
<a name="ln6099">      }</a>
<a name="ln6100"> </a>
<a name="ln6101">//---------------------------------------------------------</a>
<a name="ln6102">//  write</a>
<a name="ln6103">//---------------------------------------------------------</a>
<a name="ln6104"> </a>
<a name="ln6105">/**</a>
<a name="ln6106"> Write the score to \a dev in MusicXML format.</a>
<a name="ln6107"> */</a>
<a name="ln6108"> </a>
<a name="ln6109">void ExportMusicXml::write(QIODevice* dev)</a>
<a name="ln6110">      {</a>
<a name="ln6111">      // must export in transposed pitch to prevent</a>
<a name="ln6112">      // losing the transposition information</a>
<a name="ln6113">      // if necessary, switch concert pitch mode off</a>
<a name="ln6114">      // before export and restore it after export</a>
<a name="ln6115">      bool concertPitch = score()-&gt;styleB(Sid::concertPitch);</a>
<a name="ln6116">      if (concertPitch) {</a>
<a name="ln6117">            score()-&gt;startCmd();</a>
<a name="ln6118">            score()-&gt;undo(new ChangeStyleVal(score(), Sid::concertPitch, false));</a>
<a name="ln6119">            score()-&gt;doLayout();    // this is only allowed in a cmd context to not corrupt the undo/redo stack</a>
<a name="ln6120">            }</a>
<a name="ln6121"> </a>
<a name="ln6122">      calcDivisions();</a>
<a name="ln6123"> </a>
<a name="ln6124">      for (int i = 0; i &lt; MAX_NUMBER_LEVEL; ++i) {</a>
<a name="ln6125">            brackets[i] = nullptr;</a>
<a name="ln6126">            dashes[i] = nullptr;</a>
<a name="ln6127">            hairpins[i] = nullptr;</a>
<a name="ln6128">            ottavas[i] = nullptr;</a>
<a name="ln6129">            trills[i] = nullptr;</a>
<a name="ln6130">            }</a>
<a name="ln6131"> </a>
<a name="ln6132">      _xml.setDevice(dev);</a>
<a name="ln6133">      _xml.setCodec(&quot;UTF-8&quot;);</a>
<a name="ln6134">      _xml &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;</a>
<a name="ln6135">      _xml &lt;&lt; &quot;&lt;!DOCTYPE score-partwise PUBLIC \&quot;-//Recordare//DTD MusicXML 3.1 Partwise//EN\&quot; \&quot;http://www.musicxml.org/dtds/partwise.dtd\&quot;&gt;\n&quot;;</a>
<a name="ln6136"> </a>
<a name="ln6137">      _xml.stag(&quot;score-partwise version=\&quot;3.1\&quot;&quot;);</a>
<a name="ln6138"> </a>
<a name="ln6139">      work(_score-&gt;measures()-&gt;first());</a>
<a name="ln6140">      identification(_xml, _score);</a>
<a name="ln6141"> </a>
<a name="ln6142">      if (preferences.getBool(PREF_EXPORT_MUSICXML_EXPORTLAYOUT)) {</a>
<a name="ln6143">            defaults(_xml, _score, millimeters, tenths);</a>
<a name="ln6144">            credits(_xml);</a>
<a name="ln6145">            }</a>
<a name="ln6146"> </a>
<a name="ln6147">      partList(_xml, _score, instrMap);</a>
<a name="ln6148">      writeParts();</a>
<a name="ln6149"> </a>
<a name="ln6150">      _xml.etag();</a>
<a name="ln6151"> </a>
<a name="ln6152">      if (concertPitch) {</a>
<a name="ln6153">            // restore concert pitch</a>
<a name="ln6154">            score()-&gt;endCmd(true);        // rollback</a>
<a name="ln6155">            }</a>
<a name="ln6156">      }</a>
<a name="ln6157"> </a>
<a name="ln6158">//---------------------------------------------------------</a>
<a name="ln6159">//   saveXml</a>
<a name="ln6160">//    return false on error</a>
<a name="ln6161">//---------------------------------------------------------</a>
<a name="ln6162"> </a>
<a name="ln6163">/**</a>
<a name="ln6164"> Save Score as MusicXML file \a name.</a>
<a name="ln6165"> </a>
<a name="ln6166"> Return false on error.</a>
<a name="ln6167"> */</a>
<a name="ln6168"> </a>
<a name="ln6169">bool saveXml(Score* score, QIODevice* device)</a>
<a name="ln6170">      {</a>
<a name="ln6171">      ExportMusicXml em(score);</a>
<a name="ln6172">      em.write(device);</a>
<a name="ln6173">      return true;</a>
<a name="ln6174">      }</a>
<a name="ln6175"> </a>
<a name="ln6176">bool saveXml(Score* score, const QString&amp; name)</a>
<a name="ln6177">      {</a>
<a name="ln6178">      QFile f(name);</a>
<a name="ln6179">      if (!f.open(QIODevice::WriteOnly))</a>
<a name="ln6180">            return false;</a>
<a name="ln6181"> </a>
<a name="ln6182">      bool res = saveXml(score, &amp;f) &amp;&amp; (f.error() == QFile::NoError);</a>
<a name="ln6183">      f.close();</a>
<a name="ln6184">      return res;</a>
<a name="ln6185">      }</a>
<a name="ln6186"> </a>
<a name="ln6187">//---------------------------------------------------------</a>
<a name="ln6188">//   saveMxl</a>
<a name="ln6189">//    return false on error</a>
<a name="ln6190">//---------------------------------------------------------</a>
<a name="ln6191"> </a>
<a name="ln6192">/**</a>
<a name="ln6193"> Save Score as compressed MusicXML file \a name.</a>
<a name="ln6194"> </a>
<a name="ln6195"> Return false on error.</a>
<a name="ln6196"> */</a>
<a name="ln6197"> </a>
<a name="ln6198">// META-INF/container.xml:</a>
<a name="ln6199">// &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</a>
<a name="ln6200">// &lt;container&gt;</a>
<a name="ln6201">//     &lt;rootfiles&gt;</a>
<a name="ln6202">//         &lt;rootfile full-path=&quot;testHello.xml&quot;/&gt;</a>
<a name="ln6203">//     &lt;/rootfiles&gt;</a>
<a name="ln6204">// &lt;/container&gt;</a>
<a name="ln6205"> </a>
<a name="ln6206">static void writeMxlArchive(Score* score, MQZipWriter&amp; zipwriter, const QString&amp; filename)</a>
<a name="ln6207">      {</a>
<a name="ln6208">      QBuffer cbuf;</a>
<a name="ln6209">      cbuf.open(QIODevice::ReadWrite);</a>
<a name="ln6210"> </a>
<a name="ln6211">      XmlWriter xml(score);</a>
<a name="ln6212">      xml.setDevice(&amp;cbuf);</a>
<a name="ln6213">      xml.setCodec(&quot;UTF-8&quot;);</a>
<a name="ln6214">      xml &lt;&lt; &quot;&lt;?xml version=\&quot;1.0\&quot; encoding=\&quot;UTF-8\&quot;?&gt;\n&quot;;</a>
<a name="ln6215">      xml.stag(&quot;container&quot;);</a>
<a name="ln6216">      xml.stag(&quot;rootfiles&quot;);</a>
<a name="ln6217">      xml.stag(QString(&quot;rootfile full-path=\&quot;%1\&quot;&quot;).arg(filename));</a>
<a name="ln6218">      xml.etag();</a>
<a name="ln6219">      xml.etag();</a>
<a name="ln6220">      xml.etag();</a>
<a name="ln6221">      cbuf.seek(0);</a>
<a name="ln6222"> </a>
<a name="ln6223">      //uz.addDirectory(&quot;META-INF&quot;);</a>
<a name="ln6224">      zipwriter.addFile(&quot;META-INF/container.xml&quot;, cbuf.data());</a>
<a name="ln6225"> </a>
<a name="ln6226">      QBuffer dbuf;</a>
<a name="ln6227">      dbuf.open(QIODevice::ReadWrite);</a>
<a name="ln6228">      ExportMusicXml em(score);</a>
<a name="ln6229">      em.write(&amp;dbuf);</a>
<a name="ln6230">      dbuf.seek(0);</a>
<a name="ln6231">      zipwriter.addFile(filename, dbuf.data());</a>
<a name="ln6232">      }</a>
<a name="ln6233"> </a>
<a name="ln6234">bool saveMxl(Score* score, QIODevice* device)</a>
<a name="ln6235">      {</a>
<a name="ln6236">      MQZipWriter uz(device);</a>
<a name="ln6237"> </a>
<a name="ln6238">      //anonymized filename since we don't know the actual one here</a>
<a name="ln6239">      QString fn = &quot;score.xml&quot;;</a>
<a name="ln6240">      writeMxlArchive(score, uz, fn);</a>
<a name="ln6241">      uz.close();</a>
<a name="ln6242"> </a>
<a name="ln6243">      return true;</a>
<a name="ln6244">      }</a>
<a name="ln6245"> </a>
<a name="ln6246">bool saveMxl(Score* score, const QString&amp; name)</a>
<a name="ln6247">      {</a>
<a name="ln6248">      MQZipWriter uz(name);</a>
<a name="ln6249"> </a>
<a name="ln6250">      QFileInfo fi(name);</a>
<a name="ln6251">      QString fn = fi.completeBaseName() + &quot;.xml&quot;;</a>
<a name="ln6252">      writeMxlArchive(score, uz, fn);</a>
<a name="ln6253"> </a>
<a name="ln6254">      return true;</a>
<a name="ln6255">      }</a>
<a name="ln6256"> </a>
<a name="ln6257">double ExportMusicXml::getTenthsFromInches(double inches) const</a>
<a name="ln6258">      {</a>
<a name="ln6259">      return inches * INCH / millimeters * tenths;</a>
<a name="ln6260">      }</a>
<a name="ln6261"> </a>
<a name="ln6262">double ExportMusicXml::getTenthsFromDots(double dots) const</a>
<a name="ln6263">      {</a>
<a name="ln6264">      return dots / DPMM / millimeters * tenths;</a>
<a name="ln6265">      }</a>
<a name="ln6266"> </a>
<a name="ln6267">//---------------------------------------------------------</a>
<a name="ln6268">//   harmony</a>
<a name="ln6269">//---------------------------------------------------------</a>
<a name="ln6270"> </a>
<a name="ln6271">void ExportMusicXml::harmony(Harmony const* const h, FretDiagram const* const fd, int offset)</a>
<a name="ln6272">      {</a>
<a name="ln6273">      // this code was probably in place to allow chord symbols shifted *right* to export with offset</a>
<a name="ln6274">      // since this was at once time the only way to get a chord to appear over beat 3 in an empty 4/4 measure</a>
<a name="ln6275">      // but the value was calculated incorrectly (should be divided by spatium) and would be better off using offset anyhow</a>
<a name="ln6276">      // since we now support placement of chord symbols over &quot;empty&quot; beats directly,</a>
<a name="ln6277">      // and we don't generally export position info for other elements</a>
<a name="ln6278">      // it's just as well to not bother doing so here</a>
<a name="ln6279">      //double rx = h-&gt;offset().x()*10;</a>
<a name="ln6280">      //QString relative;</a>
<a name="ln6281">      //if (rx &gt; 0) {</a>
<a name="ln6282">      //      relative = QString(&quot; relative-x=\&quot;%1\&quot;&quot;).arg(QString::number(rx,'f',2));</a>
<a name="ln6283">      //      }</a>
<a name="ln6284">      int rootTpc = h-&gt;rootTpc();</a>
<a name="ln6285">      if (rootTpc != Tpc::TPC_INVALID) {</a>
<a name="ln6286">            QString tagName = &quot;harmony&quot;;</a>
<a name="ln6287">            bool frame = h-&gt;hasFrame();</a>
<a name="ln6288">            tagName += QString(&quot; print-frame=\&quot;%1\&quot;&quot;).arg(frame ? &quot;yes&quot; : &quot;no&quot;); // .append(relative));</a>
<a name="ln6289">            tagName += color2xml(h);</a>
<a name="ln6290">            _xml.stag(tagName);</a>
<a name="ln6291">            _xml.stag(&quot;root&quot;);</a>
<a name="ln6292">            _xml.tag(&quot;root-step&quot;, tpc2stepName(rootTpc));</a>
<a name="ln6293">            int alter = int(tpc2alter(rootTpc));</a>
<a name="ln6294">            if (alter)</a>
<a name="ln6295">                  _xml.tag(&quot;root-alter&quot;, alter);</a>
<a name="ln6296">            _xml.etag();</a>
<a name="ln6297"> </a>
<a name="ln6298">            if (!h-&gt;xmlKind().isEmpty()) {</a>
<a name="ln6299">                  QString s = &quot;kind&quot;;</a>
<a name="ln6300">                  QString kindText = h-&gt;musicXmlText();</a>
<a name="ln6301">                  if (h-&gt;musicXmlText() != &quot;&quot;)</a>
<a name="ln6302">                        s += &quot; text=\&quot;&quot; + kindText + &quot;\&quot;&quot;;</a>
<a name="ln6303">                  if (h-&gt;xmlSymbols() == &quot;yes&quot;)</a>
<a name="ln6304">                        s += &quot; use-symbols=\&quot;yes\&quot;&quot;;</a>
<a name="ln6305">                  if (h-&gt;xmlParens() == &quot;yes&quot;)</a>
<a name="ln6306">                        s += &quot; parentheses-degrees=\&quot;yes\&quot;&quot;;</a>
<a name="ln6307">                  _xml.tag(s, h-&gt;xmlKind());</a>
<a name="ln6308">                  QStringList l = h-&gt;xmlDegrees();</a>
<a name="ln6309">                  if (!l.isEmpty()) {</a>
<a name="ln6310">                        for (QString tag : l) {</a>
<a name="ln6311">                              QString degreeText;</a>
<a name="ln6312">                              if (h-&gt;xmlKind().startsWith(&quot;suspended&quot;)</a>
<a name="ln6313">                                  &amp;&amp; tag.startsWith(&quot;add&quot;) &amp;&amp; tag[3].isDigit()</a>
<a name="ln6314">                                  &amp;&amp; !kindText.isEmpty() &amp;&amp; kindText[0].isDigit()) {</a>
<a name="ln6315">                                    // hack to correct text for suspended chords whose kind text has degree information baked in</a>
<a name="ln6316">                                    // (required by some other applications)</a>
<a name="ln6317">                                    int tagDegree = tag.mid(3).toInt();</a>
<a name="ln6318">                                    QString kindTextExtension;</a>
<a name="ln6319">                                    for (int i = 0; i &lt; kindText.length() &amp;&amp; kindText[i].isDigit(); ++i)</a>
<a name="ln6320">                                          kindTextExtension[i] = kindText[i];</a>
<a name="ln6321">                                    int kindExtension = kindTextExtension.toInt();</a>
<a name="ln6322">                                    if (tagDegree &lt;= kindExtension &amp;&amp; (tagDegree &amp; 1) &amp;&amp; (kindExtension &amp; 1))</a>
<a name="ln6323">                                          degreeText = &quot; text=\&quot;\&quot;&quot;;</a>
<a name="ln6324">                                    }</a>
<a name="ln6325">                              _xml.stag(&quot;degree&quot;);</a>
<a name="ln6326">                              alter = 0;</a>
<a name="ln6327">                              int idx = 3;</a>
<a name="ln6328">                              if (tag[idx] == '#') {</a>
<a name="ln6329">                                    alter = 1;</a>
<a name="ln6330">                                    ++idx;</a>
<a name="ln6331">                                    }</a>
<a name="ln6332">                              else if (tag[idx] == 'b') {</a>
<a name="ln6333">                                    alter = -1;</a>
<a name="ln6334">                                    ++idx;</a>
<a name="ln6335">                                    }</a>
<a name="ln6336">                              _xml.tag(QString(&quot;degree-value%1&quot;).arg(degreeText), tag.mid(idx));</a>
<a name="ln6337">                              _xml.tag(&quot;degree-alter&quot;, alter);     // finale insists on this even if 0</a>
<a name="ln6338">                              if (tag.startsWith(&quot;add&quot;))</a>
<a name="ln6339">                                    _xml.tag(QString(&quot;degree-type%1&quot;).arg(degreeText), &quot;add&quot;);</a>
<a name="ln6340">                              else if (tag.startsWith(&quot;sub&quot;))</a>
<a name="ln6341">                                    _xml.tag(&quot;degree-type&quot;, &quot;subtract&quot;);</a>
<a name="ln6342">                              else if (tag.startsWith(&quot;alt&quot;))</a>
<a name="ln6343">                                    _xml.tag(&quot;degree-type&quot;, &quot;alter&quot;);</a>
<a name="ln6344">                              _xml.etag();</a>
<a name="ln6345">                              }</a>
<a name="ln6346">                        }</a>
<a name="ln6347">                  }</a>
<a name="ln6348">            else {</a>
<a name="ln6349">                  if (h-&gt;extensionName() == 0)</a>
<a name="ln6350">                        _xml.tag(&quot;kind&quot;, &quot;&quot;);</a>
<a name="ln6351">                  else</a>
<a name="ln6352">                        _xml.tag(QString(&quot;kind text=\&quot;%1\&quot;&quot;).arg(h-&gt;extensionName()), &quot;&quot;);</a>
<a name="ln6353">                  }</a>
<a name="ln6354"> </a>
<a name="ln6355">            int baseTpc = h-&gt;baseTpc();</a>
<a name="ln6356">            if (baseTpc != Tpc::TPC_INVALID) {</a>
<a name="ln6357">                  _xml.stag(&quot;bass&quot;);</a>
<a name="ln6358">                  _xml.tag(&quot;bass-step&quot;, tpc2stepName(baseTpc));</a>
<a name="ln6359">                  alter = int(tpc2alter(baseTpc));</a>
<a name="ln6360">                  if (alter) {</a>
<a name="ln6361">                        _xml.tag(&quot;bass-alter&quot;, alter);</a>
<a name="ln6362">                        }</a>
<a name="ln6363">                  _xml.etag();</a>
<a name="ln6364">                  }</a>
<a name="ln6365">            if (offset &gt; 0)</a>
<a name="ln6366">                  _xml.tag(&quot;offset&quot;, offset);</a>
<a name="ln6367">            if (fd)</a>
<a name="ln6368">                  fd-&gt;writeMusicXML(_xml);</a>
<a name="ln6369"> </a>
<a name="ln6370">            _xml.etag();</a>
<a name="ln6371">            }</a>
<a name="ln6372">      else {</a>
<a name="ln6373">            //</a>
<a name="ln6374">            // export an unrecognized Chord</a>
<a name="ln6375">            // which may contain arbitrary text</a>
<a name="ln6376">            //</a>
<a name="ln6377">            if (h-&gt;hasFrame())</a>
<a name="ln6378">                  _xml.stag(QString(&quot;harmony print-frame=\&quot;yes\&quot;&quot;));     // .append(relative));</a>
<a name="ln6379">            else</a>
<a name="ln6380">                  _xml.stag(QString(&quot;harmony print-frame=\&quot;no\&quot;&quot;));      // .append(relative));</a>
<a name="ln6381">            switch (h-&gt;harmonyType()) {</a>
<a name="ln6382">                  case HarmonyType::NASHVILLE: {</a>
<a name="ln6383">                        _xml.tag(&quot;function&quot;, h-&gt;hFunction());</a>
<a name="ln6384">                        QString k = &quot;kind text=\&quot;&quot; + h-&gt;hTextName() + &quot;\&quot;&quot;;</a>
<a name="ln6385">                        _xml.tag(k, &quot;none&quot;);</a>
<a name="ln6386">                        }</a>
<a name="ln6387">                        break;</a>
<a name="ln6388">                  case HarmonyType::ROMAN: {</a>
<a name="ln6389">                        // TODO: parse?</a>
<a name="ln6390">                        _xml.tag(&quot;function&quot;, h-&gt;hTextName());</a>
<a name="ln6391">                        QString k = &quot;kind text=\&quot;\&quot;&quot;;</a>
<a name="ln6392">                        _xml.tag(k, &quot;none&quot;);</a>
<a name="ln6393">                        }</a>
<a name="ln6394">                        break;</a>
<a name="ln6395">                  case HarmonyType::STANDARD:</a>
<a name="ln6396">                  default: {</a>
<a name="ln6397">                        _xml.stag(&quot;root&quot;);</a>
<a name="ln6398">                        _xml.tag(&quot;root-step text=\&quot;\&quot;&quot;, &quot;C&quot;);</a>
<a name="ln6399">                        _xml.etag();       // root</a>
<a name="ln6400">                        QString k = &quot;kind text=\&quot;&quot; + h-&gt;hTextName() + &quot;\&quot;&quot;;</a>
<a name="ln6401">                        _xml.tag(k, &quot;none&quot;);</a>
<a name="ln6402">                        }</a>
<a name="ln6403">                        break;</a>
<a name="ln6404">                  }</a>
<a name="ln6405">            _xml.etag();       // harmony</a>
<a name="ln6406">#if 0</a>
<a name="ln6407">            // prior to 2.0, MuseScore exported unrecognized chords as plain text</a>
<a name="ln6408">            xml.stag(&quot;direction&quot;);</a>
<a name="ln6409">            xml.stag(&quot;direction-type&quot;);</a>
<a name="ln6410">            xml.tag(&quot;words&quot;, h-&gt;text());</a>
<a name="ln6411">            xml.etag();</a>
<a name="ln6412">            xml.etag();</a>
<a name="ln6413">#endif</a>
<a name="ln6414">            }</a>
<a name="ln6415">#if 0</a>
<a name="ln6416">      // this is very old code that may never have actually been used</a>
<a name="ln6417">      xml.tag(QString(&quot;kind text=\&quot;%1\&quot;&quot;).arg(h-&gt;extensionName()), extension);</a>
<a name="ln6418">      for (int i = 0; i &lt; h-&gt;numberOfDegrees(); i++) {</a>
<a name="ln6419">            HDegree hd = h-&gt;degree(i);</a>
<a name="ln6420">            HDegreeType tp = hd.type();</a>
<a name="ln6421">            if (tp == HDegreeType::ADD || tp == HDegreeType::ALTER || tp == HDegreeType::SUBTRACT) {</a>
<a name="ln6422">                  xml.stag(&quot;degree&quot;);</a>
<a name="ln6423">                  xml.tag(&quot;degree-value&quot;, hd.value());</a>
<a name="ln6424">                  xml.tag(&quot;degree-alter&quot;, hd.alter());</a>
<a name="ln6425">                  switch (tp) {</a>
<a name="ln6426">                        case HDegreeType::ADD:</a>
<a name="ln6427">                              xml.tag(&quot;degree-type&quot;, &quot;add&quot;);</a>
<a name="ln6428">                              break;</a>
<a name="ln6429">                        case HDegreeType::ALTER:</a>
<a name="ln6430">                              xml.tag(&quot;degree-type&quot;, &quot;alter&quot;);</a>
<a name="ln6431">                              break;</a>
<a name="ln6432">                        case HDegreeType::SUBTRACT:</a>
<a name="ln6433">                              xml.tag(&quot;degree-type&quot;, &quot;subtract&quot;);</a>
<a name="ln6434">                              break;</a>
<a name="ln6435">                        default:</a>
<a name="ln6436">                              break;</a>
<a name="ln6437">                        }</a>
<a name="ln6438">                  xml.etag();</a>
<a name="ln6439">                  }</a>
<a name="ln6440">            }</a>
<a name="ln6441">#endif</a>
<a name="ln6442">      }</a>
<a name="ln6443"> </a>
<a name="ln6444">}</a>
<a name="ln6445"> </a>

</code></pre>
<div class="balloon" rel="1679"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 1679, 1689</p></div>
<div class="balloon" rel="1804"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="2237"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1037/" target="_blank">V1037</a> Two or more case-branches perform the same actions. Check lines: 2237, 2253</p></div>
<div class="balloon" rel="2428"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="2701"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="4188"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="4666"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v522/" target="_blank">V522</a> There might be dereferencing of a potential null pointer 'fb'.</p></div>
<div class="balloon" rel="5350"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v547/" target="_blank">V547</a> Expression 'c' is always true.</p></div>
<div class="balloon" rel="5534"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v595/" target="_blank">V595</a> The 'c' pointer was utilized before it was verified against nullptr. Check lines: 5534, 5536.</p></div>
<div class="balloon" rel="5560"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="5587"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v560/" target="_blank">V560</a> A part of conditional expression is always true: instrument->stringData().</p></div>
<div class="balloon" rel="359"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v730/" target="_blank">V730</a> Not all members of a class are initialized inside the constructor. Consider inspecting: brackets, dashes, hairpins, ottavas, trills.</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
