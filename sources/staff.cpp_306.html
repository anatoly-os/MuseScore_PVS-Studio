
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>staff.cpp</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">//=============================================================================</a>
<a name="ln2">//  MuseScore</a>
<a name="ln3">//  Music Composition &amp; Notation</a>
<a name="ln4">//</a>
<a name="ln5">//  Copyright (C) 2002-2011 Werner Schweer</a>
<a name="ln6">//</a>
<a name="ln7">//  This program is free software; you can redistribute it and/or modify</a>
<a name="ln8">//  it under the terms of the GNU General Public License version 2</a>
<a name="ln9">//  as published by the Free Software Foundation and appearing in</a>
<a name="ln10">//  the file LICENCE.GPL</a>
<a name="ln11">//=============================================================================</a>
<a name="ln12"> </a>
<a name="ln13">#include &quot;mscore.h&quot;</a>
<a name="ln14">#include &quot;staff.h&quot;</a>
<a name="ln15">#include &quot;part.h&quot;</a>
<a name="ln16">#include &quot;clef.h&quot;</a>
<a name="ln17">#include &quot;xml.h&quot;</a>
<a name="ln18">#include &quot;score.h&quot;</a>
<a name="ln19">#include &quot;bracket.h&quot;</a>
<a name="ln20">#include &quot;keysig.h&quot;</a>
<a name="ln21">#include &quot;segment.h&quot;</a>
<a name="ln22">#include &quot;style.h&quot;</a>
<a name="ln23">#include &quot;measure.h&quot;</a>
<a name="ln24">#include &quot;stringdata.h&quot;</a>
<a name="ln25">#include &quot;stafftype.h&quot;</a>
<a name="ln26">#include &quot;undo.h&quot;</a>
<a name="ln27">#include &quot;cleflist.h&quot;</a>
<a name="ln28">#include &quot;timesig.h&quot;</a>
<a name="ln29">#include &quot;instrtemplate.h&quot;</a>
<a name="ln30">#include &quot;barline.h&quot;</a>
<a name="ln31">#include &quot;ottava.h&quot;</a>
<a name="ln32">#include &quot;harmony.h&quot;</a>
<a name="ln33">#include &quot;bracketItem.h&quot;</a>
<a name="ln34"> </a>
<a name="ln35">// #define DEBUG_CLEFS</a>
<a name="ln36"> </a>
<a name="ln37">#ifdef DEBUG_CLEFS</a>
<a name="ln38">#define DUMP_CLEFS(s) dumpClefs(s)</a>
<a name="ln39">#else</a>
<a name="ln40">#define DUMP_CLEFS(s)</a>
<a name="ln41">#endif</a>
<a name="ln42"> </a>
<a name="ln43">namespace Ms {</a>
<a name="ln44"> </a>
<a name="ln45">//---------------------------------------------------------</a>
<a name="ln46">//   Staff</a>
<a name="ln47">//---------------------------------------------------------</a>
<a name="ln48"> </a>
<a name="ln49">Staff::Staff(Score* score)</a>
<a name="ln50">   : ScoreElement(score)</a>
<a name="ln51">      {</a>
<a name="ln52">      initFromStaffType(0);</a>
<a name="ln53">      }</a>
<a name="ln54"> </a>
<a name="ln55">//---------------------------------------------------------</a>
<a name="ln56">//   idx</a>
<a name="ln57">//---------------------------------------------------------</a>
<a name="ln58"> </a>
<a name="ln59">int Staff::idx() const</a>
<a name="ln60">      {</a>
<a name="ln61">      return score()-&gt;staves().indexOf((Staff*)this, 0);</a>
<a name="ln62">      }</a>
<a name="ln63"> </a>
<a name="ln64">//---------------------------------------------------------</a>
<a name="ln65">//   triggerLayout</a>
<a name="ln66">//---------------------------------------------------------</a>
<a name="ln67"> </a>
<a name="ln68">void Staff::triggerLayout()</a>
<a name="ln69">      {</a>
<a name="ln70">      score()-&gt;setLayoutAll(idx());</a>
<a name="ln71">      }</a>
<a name="ln72"> </a>
<a name="ln73">void Staff::triggerLayout(const Fraction&amp; tick)</a>
<a name="ln74">      {</a>
<a name="ln75">      score()-&gt;setLayout(tick, idx());</a>
<a name="ln76">      }</a>
<a name="ln77"> </a>
<a name="ln78">//---------------------------------------------------------</a>
<a name="ln79">//   fillBrackets</a>
<a name="ln80">//    make sure index idx is valid</a>
<a name="ln81">//---------------------------------------------------------</a>
<a name="ln82"> </a>
<a name="ln83">void Staff::fillBrackets(int idx)</a>
<a name="ln84">      {</a>
<a name="ln85">      for (int i = _brackets.size(); i &lt;= idx; ++i) {</a>
<a name="ln86">            BracketItem* bi = new BracketItem(score());</a>
<a name="ln87">            bi-&gt;setStaff(this);</a>
<a name="ln88">            bi-&gt;setColumn(i);</a>
<a name="ln89">            _brackets.append(bi);</a>
<a name="ln90">            }</a>
<a name="ln91">      }</a>
<a name="ln92"> </a>
<a name="ln93">//---------------------------------------------------------</a>
<a name="ln94">//   cleanBrackets</a>
<a name="ln95">//    remove NO_BRACKET entries from the end of list</a>
<a name="ln96">//---------------------------------------------------------</a>
<a name="ln97"> </a>
<a name="ln98">void Staff::cleanBrackets()</a>
<a name="ln99">      {</a>
<a name="ln100">      while (!_brackets.empty() &amp;&amp; (_brackets.last()-&gt;bracketType() == BracketType::NO_BRACKET)) {</a>
<a name="ln101">            BracketItem* bi = _brackets.takeLast();</a>
<a name="ln102">            delete bi;</a>
<a name="ln103">            }</a>
<a name="ln104">      }</a>
<a name="ln105"> </a>
<a name="ln106">//---------------------------------------------------------</a>
<a name="ln107">//   bracket</a>
<a name="ln108">//---------------------------------------------------------</a>
<a name="ln109"> </a>
<a name="ln110">BracketType Staff::bracketType(int idx) const</a>
<a name="ln111">      {</a>
<a name="ln112">      if (idx &lt; _brackets.size())</a>
<a name="ln113">            return _brackets[idx]-&gt;bracketType();</a>
<a name="ln114">      return BracketType::NO_BRACKET;</a>
<a name="ln115">      }</a>
<a name="ln116"> </a>
<a name="ln117">//---------------------------------------------------------</a>
<a name="ln118">//   bracketSpan</a>
<a name="ln119">//---------------------------------------------------------</a>
<a name="ln120"> </a>
<a name="ln121">int Staff::bracketSpan(int idx) const</a>
<a name="ln122">      {</a>
<a name="ln123">      if (idx &lt; _brackets.size())</a>
<a name="ln124">            return _brackets[idx]-&gt;bracketSpan();</a>
<a name="ln125">      return 0;</a>
<a name="ln126">      }</a>
<a name="ln127"> </a>
<a name="ln128">//---------------------------------------------------------</a>
<a name="ln129">//   setBracket</a>
<a name="ln130">//---------------------------------------------------------</a>
<a name="ln131"> </a>
<a name="ln132">void Staff::setBracketType(int idx, BracketType val)</a>
<a name="ln133">      {</a>
<a name="ln134">      fillBrackets(idx);</a>
<a name="ln135">      _brackets[idx]-&gt;setBracketType(val);</a>
<a name="ln136">      cleanBrackets();</a>
<a name="ln137">      }</a>
<a name="ln138"> </a>
<a name="ln139">//---------------------------------------------------------</a>
<a name="ln140">//   swapBracket</a>
<a name="ln141">//---------------------------------------------------------</a>
<a name="ln142"> </a>
<a name="ln143">void Staff::swapBracket(int oldIdx, int newIdx)</a>
<a name="ln144">      {</a>
<a name="ln145">      int idx = qMax(oldIdx, newIdx);</a>
<a name="ln146">      fillBrackets(idx);</a>
<a name="ln147">      _brackets[oldIdx]-&gt;setColumn(newIdx);</a>
<a name="ln148">      _brackets[newIdx]-&gt;setColumn(oldIdx);</a>
<a name="ln149">      _brackets.swap(oldIdx, newIdx);</a>
<a name="ln150">      cleanBrackets();</a>
<a name="ln151">      }</a>
<a name="ln152"> </a>
<a name="ln153">//---------------------------------------------------------</a>
<a name="ln154">//   changeBracketColumn</a>
<a name="ln155">//---------------------------------------------------------</a>
<a name="ln156"> </a>
<a name="ln157">void Staff::changeBracketColumn(int oldColumn, int newColumn)</a>
<a name="ln158">      {</a>
<a name="ln159">      int idx = qMax(oldColumn, newColumn);</a>
<a name="ln160">      fillBrackets(idx);</a>
<a name="ln161">      int step = newColumn &gt; oldColumn ? 1 : -1;</a>
<a name="ln162">      for (int i = oldColumn; i != newColumn; i += step) {</a>
<a name="ln163">            int oldIdx = i;</a>
<a name="ln164">            int newIdx = i + step;</a>
<a name="ln165">            _brackets[oldIdx]-&gt;setColumn(newIdx);</a>
<a name="ln166">            _brackets[newIdx]-&gt;setColumn(oldIdx);</a>
<a name="ln167">            _brackets.swap(oldIdx, newIdx);</a>
<a name="ln168">            }</a>
<a name="ln169">      cleanBrackets();</a>
<a name="ln170">      }</a>
<a name="ln171"> </a>
<a name="ln172">//---------------------------------------------------------</a>
<a name="ln173">//   setBracketSpan</a>
<a name="ln174">//---------------------------------------------------------</a>
<a name="ln175"> </a>
<a name="ln176">void Staff::setBracketSpan(int idx, int val)</a>
<a name="ln177">      {</a>
<a name="ln178">      Q_ASSERT(idx &gt;= 0);</a>
<a name="ln179">      Q_ASSERT(val &gt;= 0);</a>
<a name="ln180">      fillBrackets(idx);</a>
<a name="ln181">      _brackets[idx]-&gt;setBracketSpan(val);</a>
<a name="ln182">      }</a>
<a name="ln183"> </a>
<a name="ln184">//---------------------------------------------------------</a>
<a name="ln185">//   addBracket</a>
<a name="ln186">//---------------------------------------------------------</a>
<a name="ln187"> </a>
<a name="ln188">void Staff::addBracket(BracketItem* b)</a>
<a name="ln189">      {</a>
<a name="ln190">      b-&gt;setStaff(this);</a>
<a name="ln191">      if (!_brackets.empty() &amp;&amp; _brackets[0]-&gt;bracketType() == BracketType::NO_BRACKET)</a>
<a name="ln192">            _brackets[0] = b;</a>
<a name="ln193">      else {</a>
<a name="ln194">            //</a>
<a name="ln195">            // create new bracket level</a>
<a name="ln196">            //</a>
<a name="ln197">            for (Staff* s : score()-&gt;staves()) {</a>
<a name="ln198">                  if (s == this)</a>
<a name="ln199">                        s-&gt;_brackets.append(b);</a>
<a name="ln200">                  else {</a>
<a name="ln201">                        BracketItem* bi = new BracketItem(score());</a>
<a name="ln202">                        bi-&gt;setStaff(this);</a>
<a name="ln203">                        s-&gt;_brackets.append(bi);</a>
<a name="ln204">                        }</a>
<a name="ln205">                  }</a>
<a name="ln206">            }</a>
<a name="ln207">      }</a>
<a name="ln208"> </a>
<a name="ln209">//---------------------------------------------------------</a>
<a name="ln210">//   innerBracket</a>
<a name="ln211">//    Return type inner bracket.</a>
<a name="ln212">//    The bracket type determines the staff distance.</a>
<a name="ln213">//---------------------------------------------------------</a>
<a name="ln214"> </a>
<a name="ln215">BracketType Staff::innerBracket() const</a>
<a name="ln216">      {</a>
<a name="ln217">      int staffIdx = idx();</a>
<a name="ln218"> </a>
<a name="ln219">      BracketType t = BracketType::NO_BRACKET;</a>
<a name="ln220">      int level = 1000;</a>
<a name="ln221">      for (int i = 0; i &lt; score()-&gt;nstaves(); ++i) {</a>
<a name="ln222">            Staff* staff = score()-&gt;staff(i);</a>
<a name="ln223">            for (int k = 0; k &lt; staff-&gt;brackets().size(); ++k) {</a>
<a name="ln224">                  const BracketItem* bi = staff-&gt;brackets().at(k);</a>
<a name="ln225">                  if (bi-&gt;bracketType() != BracketType::NO_BRACKET) {</a>
<a name="ln226">                        if (i &lt; staffIdx &amp;&amp; ((i + bi-&gt;bracketSpan()) &gt; staffIdx) &amp;&amp; k &lt; level) {</a>
<a name="ln227">                              t = bi-&gt;bracketType();</a>
<a name="ln228">                              level = k;</a>
<a name="ln229">                              break;</a>
<a name="ln230">                              }</a>
<a name="ln231">                        }</a>
<a name="ln232">                  }</a>
<a name="ln233">            }</a>
<a name="ln234">      return t;</a>
<a name="ln235">      }</a>
<a name="ln236"> </a>
<a name="ln237">//---------------------------------------------------------</a>
<a name="ln238">//   cleanupBrackets</a>
<a name="ln239">//---------------------------------------------------------</a>
<a name="ln240"> </a>
<a name="ln241">void Staff::cleanupBrackets()</a>
<a name="ln242">      {</a>
<a name="ln243">      int index = idx();</a>
<a name="ln244">      int n = score()-&gt;nstaves();</a>
<a name="ln245">      for (int i = 0; i &lt; _brackets.size(); ++i) {</a>
<a name="ln246">            if (_brackets[i]-&gt;bracketType() == BracketType::NO_BRACKET)</a>
<a name="ln247">                  continue;</a>
<a name="ln248">            int span = _brackets[i]-&gt;bracketSpan();</a>
<a name="ln249">            if (span &gt; (n - index)) {</a>
<a name="ln250">                  span = n - index;</a>
<a name="ln251">                  _brackets[i]-&gt;setBracketSpan(span);</a>
<a name="ln252">                  }</a>
<a name="ln253">            }</a>
<a name="ln254">      for (int i = 0; i &lt; _brackets.size(); ++i) {</a>
<a name="ln255">            if (_brackets[i]-&gt;bracketType() == BracketType::NO_BRACKET)</a>
<a name="ln256">                  continue;</a>
<a name="ln257">            int span = _brackets[i]-&gt;bracketSpan();</a>
<a name="ln258">            if (span &lt;= 1) {</a>
<a name="ln259">                  _brackets[i] = new BracketItem(score());</a>
<a name="ln260">                  _brackets[i]-&gt;setStaff(this);</a>
<a name="ln261">                  }</a>
<a name="ln262">            else {</a>
<a name="ln263">                  // delete all other brackets with same span</a>
<a name="ln264">                  for (int k = i + 1; k &lt; _brackets.size(); ++k) {</a>
<a name="ln265">                        if (span == _brackets[k]-&gt;bracketSpan()) {</a>
<a name="ln266">                              _brackets[k] = new BracketItem(score());</a>
<a name="ln267">                              _brackets[k]-&gt;setStaff(this);</a>
<a name="ln268">                              }</a>
<a name="ln269">                        }</a>
<a name="ln270">                  }</a>
<a name="ln271">            }</a>
<a name="ln272">      }</a>
<a name="ln273"> </a>
<a name="ln274">//---------------------------------------------------------</a>
<a name="ln275">//   bracketLevels</a>
<a name="ln276">//---------------------------------------------------------</a>
<a name="ln277"> </a>
<a name="ln278">int Staff::bracketLevels() const</a>
<a name="ln279">      {</a>
<a name="ln280">      int columns = 0;</a>
<a name="ln281">      for (auto bi : _brackets)</a>
<a name="ln282">           columns = qMax(columns, bi-&gt;column());</a>
<a name="ln283">      return columns;</a>
<a name="ln284">      }</a>
<a name="ln285"> </a>
<a name="ln286">//---------------------------------------------------------</a>
<a name="ln287">//   partName</a>
<a name="ln288">//---------------------------------------------------------</a>
<a name="ln289"> </a>
<a name="ln290">QString Staff::partName() const</a>
<a name="ln291">      {</a>
<a name="ln292">      return _part-&gt;partName();</a>
<a name="ln293">      }</a>
<a name="ln294"> </a>
<a name="ln295">//---------------------------------------------------------</a>
<a name="ln296">//   Staff::clefType</a>
<a name="ln297">//---------------------------------------------------------</a>
<a name="ln298"> </a>
<a name="ln299">ClefTypeList Staff::clefType(const Fraction&amp; tick) const</a>
<a name="ln300">      {</a>
<a name="ln301">      ClefTypeList ct = clefs.clef(tick.ticks());</a>
<a name="ln302">      if (ct._concertClef == ClefType::INVALID) {</a>
<a name="ln303">            switch (staffType(tick)-&gt;group()) {</a>
<a name="ln304">                  case StaffGroup::TAB:</a>
<a name="ln305">                        {</a>
<a name="ln306">                        ClefType sct = ClefType(score()-&gt;styleI(Sid::tabClef));</a>
<a name="ln307">                        ct = staffType(tick)-&gt;lines() &lt;= 4 ?  ClefTypeList(sct == ClefType::TAB ? ClefType::TAB4 : ClefType::TAB4_SERIF) : ClefTypeList(sct == ClefType::TAB ? ClefType::TAB : ClefType::TAB_SERIF);</a>
<a name="ln308">                        }</a>
<a name="ln309">                        break;</a>
<a name="ln310">                  case StaffGroup::STANDARD:</a>
<a name="ln311">                        ct = defaultClefType();</a>
<a name="ln312">                        break;</a>
<a name="ln313">                  case StaffGroup::PERCUSSION:</a>
<a name="ln314">                        ct = ClefTypeList(ClefType::PERC);</a>
<a name="ln315">                        break;</a>
<a name="ln316">                  }</a>
<a name="ln317">            }</a>
<a name="ln318">      return ct;</a>
<a name="ln319">      }</a>
<a name="ln320"> </a>
<a name="ln321">//---------------------------------------------------------</a>
<a name="ln322">//   Staff::clef</a>
<a name="ln323">//---------------------------------------------------------</a>
<a name="ln324"> </a>
<a name="ln325">ClefType Staff::clef(const Fraction&amp; tick) const</a>
<a name="ln326">      {</a>
<a name="ln327">      ClefTypeList c = clefType(tick);</a>
<a name="ln328">      return score()-&gt;styleB(Sid::concertPitch) ? c._concertClef : c._transposingClef;</a>
<a name="ln329">      }</a>
<a name="ln330"> </a>
<a name="ln331">//---------------------------------------------------------</a>
<a name="ln332">//   Staff::nextClefTick</a>
<a name="ln333">//</a>
<a name="ln334">//    return the tick of next clef after tick</a>
<a name="ln335">//    return last tick of score if not found</a>
<a name="ln336">//---------------------------------------------------------</a>
<a name="ln337"> </a>
<a name="ln338">Fraction Staff::nextClefTick(const Fraction&amp; tick) const</a>
<a name="ln339">      {</a>
<a name="ln340">      Fraction t = Fraction::fromTicks(clefs.nextClefTick(tick.ticks()));</a>
<a name="ln341">      return t != Fraction(-1,1) ? t : score()-&gt;endTick();</a>
<a name="ln342">      }</a>
<a name="ln343"> </a>
<a name="ln344">//---------------------------------------------------------</a>
<a name="ln345">//   Staff::currentClefTick</a>
<a name="ln346">//</a>
<a name="ln347">//    return the tick position of the clef currently</a>
<a name="ln348">//    in effect at tick</a>
<a name="ln349">//    return 0, if no such clef</a>
<a name="ln350">//---------------------------------------------------------</a>
<a name="ln351"> </a>
<a name="ln352">Fraction Staff::currentClefTick(const Fraction&amp; tick) const</a>
<a name="ln353">      {</a>
<a name="ln354">      return Fraction::fromTicks(clefs.currentClefTick(tick.ticks()));</a>
<a name="ln355">      }</a>
<a name="ln356"> </a>
<a name="ln357"> </a>
<a name="ln358">#ifndef NDEBUG</a>
<a name="ln359">//---------------------------------------------------------</a>
<a name="ln360">//   dumpClef</a>
<a name="ln361">//---------------------------------------------------------</a>
<a name="ln362"> </a>
<a name="ln363">void Staff::dumpClefs(const char* title) const</a>
<a name="ln364">      {</a>
<a name="ln365">      qDebug(&quot;(%zd): %s&quot;, clefs.size(), title);</a>
<a name="ln366">      for (auto&amp; i : clefs) {</a>
<a name="ln367">            qDebug(&quot;  %d: %d %d&quot;, i.first, int(i.second._concertClef), int(i.second._transposingClef));</a>
<a name="ln368">            }</a>
<a name="ln369">      }</a>
<a name="ln370"> </a>
<a name="ln371">//---------------------------------------------------------</a>
<a name="ln372">//   dumpKeys</a>
<a name="ln373">//---------------------------------------------------------</a>
<a name="ln374"> </a>
<a name="ln375">void Staff::dumpKeys(const char* title) const</a>
<a name="ln376">      {</a>
<a name="ln377">      qDebug(&quot;(%zd): %s&quot;, _keys.size(), title);</a>
<a name="ln378">      for (auto&amp; i : _keys) {</a>
<a name="ln379">            qDebug(&quot;  %d: %d&quot;, i.first, int(i.second.key()));</a>
<a name="ln380">            }</a>
<a name="ln381">      }</a>
<a name="ln382"> </a>
<a name="ln383">//---------------------------------------------------------</a>
<a name="ln384">//   dumpTimeSigs</a>
<a name="ln385">//---------------------------------------------------------</a>
<a name="ln386"> </a>
<a name="ln387">void Staff::dumpTimeSigs(const char* title) const</a>
<a name="ln388">      {</a>
<a name="ln389">      qDebug(&quot;size (%zd) staffIdx %d: %s&quot;, timesigs.size(), idx(), title);</a>
<a name="ln390">      for (auto&amp; i : timesigs) {</a>
<a name="ln391">            qDebug(&quot;  %d: %d/%d&quot;, i.first, i.second-&gt;sig().numerator(), i.second-&gt;sig().denominator());</a>
<a name="ln392">            }</a>
<a name="ln393">      }</a>
<a name="ln394">#endif</a>
<a name="ln395"> </a>
<a name="ln396">//---------------------------------------------------------</a>
<a name="ln397">//   setClef</a>
<a name="ln398">//---------------------------------------------------------</a>
<a name="ln399"> </a>
<a name="ln400">void Staff::setClef(Clef* clef)</a>
<a name="ln401">      {</a>
<a name="ln402">      if (clef-&gt;generated())</a>
<a name="ln403">            return;</a>
<a name="ln404">      Fraction tick = clef-&gt;segment()-&gt;tick();</a>
<a name="ln405">      for (Segment* s = clef-&gt;segment()-&gt;next1(); s &amp;&amp; s-&gt;tick() == tick; s = s-&gt;next1()) {</a>
<a name="ln406">            if ((s-&gt;segmentType() == SegmentType::Clef || s-&gt;segmentType() == SegmentType::HeaderClef)</a>
<a name="ln407">                &amp;&amp; s-&gt;element(clef-&gt;track())</a>
<a name="ln408">                &amp;&amp; !s-&gt;element(clef-&gt;track())-&gt;generated()) {</a>
<a name="ln409">                  // adding this clef has no effect on the clefs list</a>
<a name="ln410">                  return;</a>
<a name="ln411">                  }</a>
<a name="ln412">            }</a>
<a name="ln413">      clefs.setClef(clef-&gt;segment()-&gt;tick().ticks(), clef-&gt;clefTypeList());</a>
<a name="ln414">      DUMP_CLEFS(&quot;setClef&quot;);</a>
<a name="ln415">      }</a>
<a name="ln416"> </a>
<a name="ln417">//---------------------------------------------------------</a>
<a name="ln418">//   removeClef</a>
<a name="ln419">//---------------------------------------------------------</a>
<a name="ln420"> </a>
<a name="ln421">void Staff::removeClef(const Clef* clef)</a>
<a name="ln422">      {</a>
<a name="ln423">      if (clef-&gt;generated())</a>
<a name="ln424">            return;</a>
<a name="ln425">      Fraction tick = clef-&gt;segment()-&gt;tick();</a>
<a name="ln426">      for (Segment* s = clef-&gt;segment()-&gt;next1(); s &amp;&amp; s-&gt;tick() == tick; s = s-&gt;next1()) {</a>
<a name="ln427">            if ((s-&gt;segmentType() == SegmentType::Clef || s-&gt;segmentType() == SegmentType::HeaderClef)</a>
<a name="ln428">                &amp;&amp; s-&gt;element(clef-&gt;track())</a>
<a name="ln429">                &amp;&amp; !s-&gt;element(clef-&gt;track())-&gt;generated()) {</a>
<a name="ln430">                  // removal of this clef has no effect on the clefs list</a>
<a name="ln431">                  return;</a>
<a name="ln432">                  }</a>
<a name="ln433">            }</a>
<a name="ln434">      clefs.erase(clef-&gt;segment()-&gt;tick().ticks());</a>
<a name="ln435">      for (Segment* s = clef-&gt;segment()-&gt;prev1(); s &amp;&amp; s-&gt;tick() == tick; s = s-&gt;prev1()) {</a>
<a name="ln436">            if ((s-&gt;segmentType() == SegmentType::Clef || s-&gt;segmentType() == SegmentType::HeaderClef)</a>
<a name="ln437">               &amp;&amp; s-&gt;element(clef-&gt;track())</a>
<a name="ln438">               &amp;&amp; !s-&gt;element(clef-&gt;track())-&gt;generated()) {</a>
<a name="ln439">                  // a previous clef at the same tick position gets valid</a>
<a name="ln440">                  clefs.setClef(tick.ticks(), toClef(s-&gt;element(clef-&gt;track()))-&gt;clefTypeList());</a>
<a name="ln441">                  break;</a>
<a name="ln442">                  }</a>
<a name="ln443">            }</a>
<a name="ln444">      DUMP_CLEFS(&quot;removeClef&quot;);</a>
<a name="ln445">      }</a>
<a name="ln446"> </a>
<a name="ln447">//---------------------------------------------------------</a>
<a name="ln448">//   timeStretch</a>
<a name="ln449">//---------------------------------------------------------</a>
<a name="ln450"> </a>
<a name="ln451">Fraction Staff::timeStretch(const Fraction&amp; tick) const</a>
<a name="ln452">      {</a>
<a name="ln453">      TimeSig* timesig = timeSig(tick);</a>
<a name="ln454">      return timesig ? timesig-&gt;stretch() : Fraction(1,1);</a>
<a name="ln455">      }</a>
<a name="ln456"> </a>
<a name="ln457">//---------------------------------------------------------</a>
<a name="ln458">//   timeSig</a>
<a name="ln459">//    lookup time signature before or at tick</a>
<a name="ln460">//---------------------------------------------------------</a>
<a name="ln461"> </a>
<a name="ln462">TimeSig* Staff::timeSig(const Fraction&amp; tick) const</a>
<a name="ln463">      {</a>
<a name="ln464">      auto i = timesigs.upper_bound(tick.ticks());</a>
<a name="ln465">      if (i != timesigs.begin())</a>
<a name="ln466">            --i;</a>
<a name="ln467">      if (i == timesigs.end())</a>
<a name="ln468">            return 0;</a>
<a name="ln469">      else if (tick &lt; Fraction::fromTicks(i-&gt;first))</a>
<a name="ln470">            return 0;</a>
<a name="ln471">      return i-&gt;second;</a>
<a name="ln472">      }</a>
<a name="ln473"> </a>
<a name="ln474">//---------------------------------------------------------</a>
<a name="ln475">//   nextTimeSig</a>
<a name="ln476">//    lookup time signature at tick or after</a>
<a name="ln477">//---------------------------------------------------------</a>
<a name="ln478"> </a>
<a name="ln479">TimeSig* Staff::nextTimeSig(const Fraction&amp; tick) const</a>
<a name="ln480">      {</a>
<a name="ln481">      auto i = timesigs.lower_bound(tick.ticks());</a>
<a name="ln482">      return (i == timesigs.end()) ? 0 : i-&gt;second;</a>
<a name="ln483">      }</a>
<a name="ln484"> </a>
<a name="ln485"> </a>
<a name="ln486">//---------------------------------------------------------</a>
<a name="ln487">//   currentTimeSigTick</a>
<a name="ln488">//</a>
<a name="ln489">//    return the tick position of the time sig currently</a>
<a name="ln490">//    in effect at tick</a>
<a name="ln491">//---------------------------------------------------------</a>
<a name="ln492"> </a>
<a name="ln493">Fraction Staff::currentTimeSigTick(const Fraction&amp; tick) const</a>
<a name="ln494">      {</a>
<a name="ln495">      if (timesigs.empty())</a>
<a name="ln496">            return Fraction(0, 1);</a>
<a name="ln497">      auto i = timesigs.upper_bound(tick.ticks());</a>
<a name="ln498">      if (i == timesigs.begin())</a>
<a name="ln499">            return Fraction(0, 1);</a>
<a name="ln500">      --i;</a>
<a name="ln501">      return Fraction::fromTicks(i-&gt;first);</a>
<a name="ln502">      }</a>
<a name="ln503"> </a>
<a name="ln504">//---------------------------------------------------------</a>
<a name="ln505">//   group</a>
<a name="ln506">//---------------------------------------------------------</a>
<a name="ln507"> </a>
<a name="ln508">const Groups&amp; Staff::group(const Fraction&amp; tick) const</a>
<a name="ln509">      {</a>
<a name="ln510">      TimeSig* ts = timeSig(tick);</a>
<a name="ln511">      if (ts) {</a>
<a name="ln512">            if (!ts-&gt;groups().empty())</a>
<a name="ln513">                  return ts-&gt;groups();</a>
<a name="ln514">            return Groups::endings(ts-&gt;sig());</a>
<a name="ln515">            }</a>
<a name="ln516">      Measure* m = score()-&gt;tick2measure(tick);</a>
<a name="ln517">      return Groups::endings(m ? m-&gt;timesig() : Fraction(4,4));</a>
<a name="ln518">      }</a>
<a name="ln519"> </a>
<a name="ln520">//---------------------------------------------------------</a>
<a name="ln521">//   addTimeSig</a>
<a name="ln522">//---------------------------------------------------------</a>
<a name="ln523"> </a>
<a name="ln524">void Staff::addTimeSig(TimeSig* timesig)</a>
<a name="ln525">      {</a>
<a name="ln526">      if (timesig-&gt;segment()-&gt;segmentType() == SegmentType::TimeSig)</a>
<a name="ln527">            timesigs[timesig-&gt;segment()-&gt;tick().ticks()] = timesig;</a>
<a name="ln528">//      dumpTimeSigs(&quot;after addTimeSig&quot;);</a>
<a name="ln529">      }</a>
<a name="ln530"> </a>
<a name="ln531">//---------------------------------------------------------</a>
<a name="ln532">//   removeTimeSig</a>
<a name="ln533">//---------------------------------------------------------</a>
<a name="ln534"> </a>
<a name="ln535">void Staff::removeTimeSig(TimeSig* timesig)</a>
<a name="ln536">      {</a>
<a name="ln537">      if (timesig-&gt;segment()-&gt;segmentType() == SegmentType::TimeSig)</a>
<a name="ln538">            timesigs.erase(timesig-&gt;segment()-&gt;tick().ticks());</a>
<a name="ln539">//      dumpTimeSigs(&quot;after removeTimeSig&quot;);</a>
<a name="ln540">      }</a>
<a name="ln541"> </a>
<a name="ln542">//---------------------------------------------------------</a>
<a name="ln543">//   clearTimeSig</a>
<a name="ln544">//---------------------------------------------------------</a>
<a name="ln545"> </a>
<a name="ln546">void Staff::clearTimeSig()</a>
<a name="ln547">      {</a>
<a name="ln548">      timesigs.clear();</a>
<a name="ln549">      }</a>
<a name="ln550"> </a>
<a name="ln551">//---------------------------------------------------------</a>
<a name="ln552">//   Staff::keySigEvent</a>
<a name="ln553">//</a>
<a name="ln554">//    locates the key sig currently in effect at tick</a>
<a name="ln555">//---------------------------------------------------------</a>
<a name="ln556"> </a>
<a name="ln557">KeySigEvent Staff::keySigEvent(const Fraction&amp; tick) const</a>
<a name="ln558">      {</a>
<a name="ln559">      return _keys.key(tick.ticks());</a>
<a name="ln560">      }</a>
<a name="ln561"> </a>
<a name="ln562">//---------------------------------------------------------</a>
<a name="ln563">//   setKey</a>
<a name="ln564">//---------------------------------------------------------</a>
<a name="ln565"> </a>
<a name="ln566">void Staff::setKey(const Fraction&amp; tick, KeySigEvent k)</a>
<a name="ln567">      {</a>
<a name="ln568">      _keys.setKey(tick.ticks(), k);</a>
<a name="ln569">      }</a>
<a name="ln570"> </a>
<a name="ln571">//---------------------------------------------------------</a>
<a name="ln572">//   removeKey</a>
<a name="ln573">//---------------------------------------------------------</a>
<a name="ln574"> </a>
<a name="ln575">void Staff::removeKey(const Fraction&amp; tick)</a>
<a name="ln576">      {</a>
<a name="ln577">      _keys.erase(tick.ticks());</a>
<a name="ln578">      }</a>
<a name="ln579"> </a>
<a name="ln580">//---------------------------------------------------------</a>
<a name="ln581">//   prevkey</a>
<a name="ln582">//---------------------------------------------------------</a>
<a name="ln583"> </a>
<a name="ln584">KeySigEvent Staff::prevKey(const Fraction&amp; tick) const</a>
<a name="ln585">      {</a>
<a name="ln586">      return _keys.prevKey(tick.ticks());</a>
<a name="ln587">      }</a>
<a name="ln588"> </a>
<a name="ln589">//---------------------------------------------------------</a>
<a name="ln590">//   Staff::nextKeyTick</a>
<a name="ln591">//</a>
<a name="ln592">//    return the tick at which the key sig after tick is located</a>
<a name="ln593">//    return 0, if no such a key sig</a>
<a name="ln594">//---------------------------------------------------------</a>
<a name="ln595"> </a>
<a name="ln596">Fraction Staff::nextKeyTick(const Fraction&amp; tick) const</a>
<a name="ln597">      {</a>
<a name="ln598">      Fraction t = Fraction::fromTicks(_keys.nextKeyTick(tick.ticks()));</a>
<a name="ln599">      return t != Fraction(-1,1) ? t : score()-&gt;endTick();</a>
<a name="ln600">      }</a>
<a name="ln601"> </a>
<a name="ln602">//---------------------------------------------------------</a>
<a name="ln603">//   Staff::currentKeyTick</a>
<a name="ln604">//</a>
<a name="ln605">//    return the tick position of the key currently</a>
<a name="ln606">//    in effect at tick</a>
<a name="ln607">//    return 0, if no such a key sig</a>
<a name="ln608">//---------------------------------------------------------</a>
<a name="ln609"> </a>
<a name="ln610">Fraction Staff::currentKeyTick(const Fraction&amp; tick) const</a>
<a name="ln611">      {</a>
<a name="ln612">      return Fraction::fromTicks(_keys.currentKeyTick(tick.ticks()));</a>
<a name="ln613">      }</a>
<a name="ln614"> </a>
<a name="ln615">//---------------------------------------------------------</a>
<a name="ln616">//   write</a>
<a name="ln617">//---------------------------------------------------------</a>
<a name="ln618"> </a>
<a name="ln619">void Staff::write(XmlWriter&amp; xml) const</a>
<a name="ln620">      {</a>
<a name="ln621">      int idx = this-&gt;idx();</a>
<a name="ln622">      xml.stag(this, QString(&quot;id=\&quot;%1\&quot;&quot;).arg(idx + 1));</a>
<a name="ln623">      if (links()) {</a>
<a name="ln624">            Score* s = masterScore();</a>
<a name="ln625">            for (auto le : *links()) {</a>
<a name="ln626">                  Staff* staff = toStaff(le);</a>
<a name="ln627">                  if ((staff-&gt;score() == s) &amp;&amp; (staff != this))</a>
<a name="ln628">                        xml.tag(&quot;linkedTo&quot;, staff-&gt;idx() + 1);</a>
<a name="ln629">                  }</a>
<a name="ln630">            }</a>
<a name="ln631"> </a>
<a name="ln632">      // for copy/paste we need to know the actual transposition</a>
<a name="ln633">      if (xml.clipboardmode()) {</a>
<a name="ln634">            Interval v = part()-&gt;instrument()-&gt;transpose(); // TODO: tick?</a>
<a name="ln635">            if (v.diatonic)</a>
<a name="ln636">                  xml.tag(&quot;transposeDiatonic&quot;, v.diatonic);</a>
<a name="ln637">            if (v.chromatic)</a>
<a name="ln638">                  xml.tag(&quot;transposeChromatic&quot;, v.chromatic);</a>
<a name="ln639">            }</a>
<a name="ln640"> </a>
<a name="ln641">      staffType(Fraction(0,1))-&gt;write(xml);</a>
<a name="ln642">      ClefTypeList ct = _defaultClefType;</a>
<a name="ln643">      if (ct._concertClef == ct._transposingClef) {</a>
<a name="ln644">            if (ct._concertClef != ClefType::G)</a>
<a name="ln645">                  xml.tag(&quot;defaultClef&quot;, ClefInfo::tag(ct._concertClef));</a>
<a name="ln646">            }</a>
<a name="ln647">      else {</a>
<a name="ln648">            xml.tag(&quot;defaultConcertClef&quot;, ClefInfo::tag(ct._concertClef));</a>
<a name="ln649">            xml.tag(&quot;defaultTransposingClef&quot;, ClefInfo::tag(ct._transposingClef));</a>
<a name="ln650">            }</a>
<a name="ln651"> </a>
<a name="ln652">      if (invisible())</a>
<a name="ln653">            xml.tag(&quot;invisible&quot;, invisible());</a>
<a name="ln654">      if (hideWhenEmpty() != HideMode::AUTO)</a>
<a name="ln655">            xml.tag(&quot;hideWhenEmpty&quot;, int(hideWhenEmpty()));</a>
<a name="ln656">      if (cutaway())</a>
<a name="ln657">            xml.tag(&quot;cutaway&quot;, cutaway());</a>
<a name="ln658">      if (showIfEmpty())</a>
<a name="ln659">            xml.tag(&quot;showIfSystemEmpty&quot;, showIfEmpty());</a>
<a name="ln660">      if (_hideSystemBarLine)</a>
<a name="ln661">            xml.tag(&quot;hideSystemBarLine&quot;, _hideSystemBarLine);</a>
<a name="ln662"> </a>
<a name="ln663">      for (const BracketItem* i : _brackets) {</a>
<a name="ln664">            BracketType a = i-&gt;bracketType();</a>
<a name="ln665">            int b = i-&gt;bracketSpan();</a>
<a name="ln666">            int c = i-&gt;column();</a>
<a name="ln667">            if (a != BracketType::NO_BRACKET || b &gt; 0)</a>
<a name="ln668">                  xml.tagE(QString(&quot;bracket type=\&quot;%1\&quot; span=\&quot;%2\&quot; col=\&quot;%3\&quot;&quot;).arg(static_cast&lt;int&gt;(a)).arg(b).arg(c));</a>
<a name="ln669">            }</a>
<a name="ln670"> </a>
<a name="ln671">      writeProperty(xml, Pid::STAFF_BARLINE_SPAN);</a>
<a name="ln672">      writeProperty(xml, Pid::STAFF_BARLINE_SPAN_FROM);</a>
<a name="ln673">      writeProperty(xml, Pid::STAFF_BARLINE_SPAN_TO);</a>
<a name="ln674">      writeProperty(xml, Pid::STAFF_USERDIST);</a>
<a name="ln675">      writeProperty(xml, Pid::COLOR);</a>
<a name="ln676">      writeProperty(xml, Pid::PLAYBACK_VOICE1);</a>
<a name="ln677">      writeProperty(xml, Pid::PLAYBACK_VOICE2);</a>
<a name="ln678">      writeProperty(xml, Pid::PLAYBACK_VOICE3);</a>
<a name="ln679">      writeProperty(xml, Pid::PLAYBACK_VOICE4);</a>
<a name="ln680">      xml.etag();</a>
<a name="ln681">      }</a>
<a name="ln682"> </a>
<a name="ln683">//---------------------------------------------------------</a>
<a name="ln684">//   read</a>
<a name="ln685">//---------------------------------------------------------</a>
<a name="ln686"> </a>
<a name="ln687">void Staff::read(XmlReader&amp; e)</a>
<a name="ln688">      {</a>
<a name="ln689">      while (e.readNextStartElement()) {</a>
<a name="ln690">            if (!readProperties(e))</a>
<a name="ln691">                  e.unknown();</a>
<a name="ln692">            }</a>
<a name="ln693">      }</a>
<a name="ln694"> </a>
<a name="ln695">//---------------------------------------------------------</a>
<a name="ln696">//   readProperties</a>
<a name="ln697">//---------------------------------------------------------</a>
<a name="ln698"> </a>
<a name="ln699">bool Staff::readProperties(XmlReader&amp; e)</a>
<a name="ln700">      {</a>
<a name="ln701">      const QStringRef&amp; tag(e.name());</a>
<a name="ln702">      if (tag == &quot;StaffType&quot;) {</a>
<a name="ln703">            StaffType st;</a>
<a name="ln704">            st.read(e);</a>
<a name="ln705">            setStaffType(Fraction(0,1), st);</a>
<a name="ln706">            }</a>
<a name="ln707">      else if (tag == &quot;defaultClef&quot;) {           // sets both default transposing and concert clef</a>
<a name="ln708">            QString val(e.readElementText());</a>
<a name="ln709">            ClefType ct = Clef::clefType(val);</a>
<a name="ln710">            setDefaultClefType(ClefTypeList(ct, ct));</a>
<a name="ln711">            }</a>
<a name="ln712">      else if (tag == &quot;defaultConcertClef&quot;) {</a>
<a name="ln713">            QString val(e.readElementText());</a>
<a name="ln714">            setDefaultClefType(ClefTypeList(Clef::clefType(val), defaultClefType()._transposingClef));</a>
<a name="ln715">            }</a>
<a name="ln716">      else if (tag == &quot;defaultTransposingClef&quot;) {</a>
<a name="ln717">            QString val(e.readElementText());</a>
<a name="ln718">            setDefaultClefType(ClefTypeList(defaultClefType()._concertClef, Clef::clefType(val)));</a>
<a name="ln719">            }</a>
<a name="ln720">      else if (tag == &quot;small&quot;)                  // obsolete</a>
<a name="ln721">            setSmall(Fraction(0,1), e.readInt());</a>
<a name="ln722">      else if (tag == &quot;invisible&quot;)</a>
<a name="ln723">            setInvisible(e.readInt());</a>
<a name="ln724">      else if (tag == &quot;hideWhenEmpty&quot;)</a>
<a name="ln725">            setHideWhenEmpty(HideMode(e.readInt()));</a>
<a name="ln726">      else if (tag == &quot;cutaway&quot;)</a>
<a name="ln727">            setCutaway(e.readInt());</a>
<a name="ln728">      else if (tag == &quot;showIfSystemEmpty&quot;)</a>
<a name="ln729">            setShowIfEmpty(e.readInt());</a>
<a name="ln730">      else if (tag == &quot;hideSystemBarLine&quot;)</a>
<a name="ln731">            _hideSystemBarLine = e.readInt();</a>
<a name="ln732">      else if (tag == &quot;keylist&quot;)</a>
<a name="ln733">            _keys.read(e, score());</a>
<a name="ln734">      else if (tag == &quot;bracket&quot;) {</a>
<a name="ln735">            int col = e.intAttribute(&quot;col&quot;, -1);</a>
<a name="ln736">            if (col == -1)</a>
<a name="ln737">                  col = _brackets.size();</a>
<a name="ln738">            setBracketType(col, BracketType(e.intAttribute(&quot;type&quot;, -1)));</a>
<a name="ln739">            setBracketSpan(col, e.intAttribute(&quot;span&quot;, 0));</a>
<a name="ln740">            e.readNext();</a>
<a name="ln741">            }</a>
<a name="ln742">      else if (tag == &quot;barLineSpan&quot;)</a>
<a name="ln743">            _barLineSpan = e.readInt();</a>
<a name="ln744">      else if (tag == &quot;barLineSpanFrom&quot;)</a>
<a name="ln745">            _barLineFrom = e.readInt();</a>
<a name="ln746">      else if (tag == &quot;barLineSpanTo&quot;)</a>
<a name="ln747">            _barLineTo = e.readInt();</a>
<a name="ln748">      else if (tag == &quot;distOffset&quot;)</a>
<a name="ln749">            _userDist = e.readDouble() * score()-&gt;spatium();</a>
<a name="ln750">      else if (tag == &quot;mag&quot;)</a>
<a name="ln751">            /*_userMag =*/ e.readDouble(0.1, 10.0);</a>
<a name="ln752">      else if (tag == &quot;linkedTo&quot;) {</a>
<a name="ln753">            int v = e.readInt() - 1;</a>
<a name="ln754">            Staff* st = masterScore()-&gt;staff(v);</a>
<a name="ln755">            if (_links) {</a>
<a name="ln756">                  qDebug(&quot;Staff::readProperties: multiple &lt;linkedTo&gt; tags&quot;);</a>
<a name="ln757">                  if (!st || isLinked(st)) // maybe we don't need actually to relink...</a>
<a name="ln758">                        return true;</a>
<a name="ln759">                  // not using unlink() here as it may delete _links</a>
<a name="ln760">                  // a pointer to which is stored also in XmlReader.</a>
<a name="ln761">                  _links-&gt;removeOne(this);</a>
<a name="ln762">                  _links = nullptr;</a>
<a name="ln763">                  }</a>
<a name="ln764">            if (st &amp;&amp; st != this)</a>
<a name="ln765">                  linkTo(st);</a>
<a name="ln766">            else if (!score()-&gt;isMaster() &amp;&amp; !st) {</a>
<a name="ln767">                  // if it is a master score it is OK not to find</a>
<a name="ln768">                  // a staff which is going after the current one.</a>
<a name="ln769">                  qDebug(&quot;staff %d not found in parent&quot;, v);</a>
<a name="ln770">                  }</a>
<a name="ln771">            }</a>
<a name="ln772">      else if (tag == &quot;color&quot;)</a>
<a name="ln773">            _color = e.readColor();</a>
<a name="ln774">      else if (tag == &quot;transposeDiatonic&quot;)</a>
<a name="ln775">            e.setTransposeDiatonic(e.readInt());</a>
<a name="ln776">      else if (tag == &quot;transposeChromatic&quot;)</a>
<a name="ln777">            e.setTransposeChromatic(e.readInt());</a>
<a name="ln778">      else if (tag == &quot;playbackVoice1&quot;)</a>
<a name="ln779">            setPlaybackVoice(0, e.readInt());</a>
<a name="ln780">      else if (tag == &quot;playbackVoice2&quot;)</a>
<a name="ln781">            setPlaybackVoice(1, e.readInt());</a>
<a name="ln782">      else if (tag == &quot;playbackVoice3&quot;)</a>
<a name="ln783">            setPlaybackVoice(2, e.readInt());</a>
<a name="ln784">      else if (tag == &quot;playbackVoice4&quot;)</a>
<a name="ln785">            setPlaybackVoice(3, e.readInt());</a>
<a name="ln786">      else</a>
<a name="ln787">            return false;</a>
<a name="ln788">      return true;</a>
<a name="ln789">      }</a>
<a name="ln790"> </a>
<a name="ln791">//---------------------------------------------------------</a>
<a name="ln792">//   height</a>
<a name="ln793">//---------------------------------------------------------</a>
<a name="ln794"> </a>
<a name="ln795">qreal Staff::height() const</a>
<a name="ln796">      {</a>
<a name="ln797">      Fraction tick = Fraction(0,1);     // TODO</a>
<a name="ln798">//      return (lines(tick) == 1 ? 2 : lines(tick)-1) * spatium(tick) * staffType(tick)-&gt;lineDistance().val();</a>
<a name="ln799">      return (lines(tick)-1) * spatium(tick) * staffType(tick)-&gt;lineDistance().val();</a>
<a name="ln800">      }</a>
<a name="ln801"> </a>
<a name="ln802">//---------------------------------------------------------</a>
<a name="ln803">//   spatium</a>
<a name="ln804">//---------------------------------------------------------</a>
<a name="ln805"> </a>
<a name="ln806">qreal Staff::spatium(const Fraction&amp; tick) const</a>
<a name="ln807">      {</a>
<a name="ln808">      return score()-&gt;spatium() * mag(tick);</a>
<a name="ln809">      }</a>
<a name="ln810"> </a>
<a name="ln811">//---------------------------------------------------------</a>
<a name="ln812">//   mag</a>
<a name="ln813">//---------------------------------------------------------</a>
<a name="ln814"> </a>
<a name="ln815">qreal Staff::mag(const Fraction&amp; tick) const</a>
<a name="ln816">      {</a>
<a name="ln817">      return (small(tick) ? score()-&gt;styleD(Sid::smallStaffMag) : 1.0) * userMag(tick);</a>
<a name="ln818">      }</a>
<a name="ln819"> </a>
<a name="ln820">//---------------------------------------------------------</a>
<a name="ln821">//   userMag</a>
<a name="ln822">//---------------------------------------------------------</a>
<a name="ln823"> </a>
<a name="ln824">qreal Staff::userMag(const Fraction&amp; tick) const</a>
<a name="ln825">      {</a>
<a name="ln826">      return staffType(tick)-&gt;userMag();</a>
<a name="ln827">      }</a>
<a name="ln828"> </a>
<a name="ln829">//---------------------------------------------------------</a>
<a name="ln830">//   setUserMag</a>
<a name="ln831">//---------------------------------------------------------</a>
<a name="ln832"> </a>
<a name="ln833">void Staff::setUserMag(const Fraction&amp; tick, qreal m)</a>
<a name="ln834">      {</a>
<a name="ln835">      staffType(tick)-&gt;setUserMag(m);</a>
<a name="ln836">      }</a>
<a name="ln837"> </a>
<a name="ln838">//---------------------------------------------------------</a>
<a name="ln839">//   small</a>
<a name="ln840">//---------------------------------------------------------</a>
<a name="ln841"> </a>
<a name="ln842">bool Staff::small(const Fraction&amp; tick) const</a>
<a name="ln843">      {</a>
<a name="ln844">      return staffType(tick)-&gt;small();</a>
<a name="ln845">      }</a>
<a name="ln846"> </a>
<a name="ln847">//---------------------------------------------------------</a>
<a name="ln848">//   setSmall</a>
<a name="ln849">//---------------------------------------------------------</a>
<a name="ln850"> </a>
<a name="ln851">void Staff::setSmall(const Fraction&amp; tick, bool val)</a>
<a name="ln852">      {</a>
<a name="ln853">      staffType(tick)-&gt;setSmall(val);</a>
<a name="ln854">      }</a>
<a name="ln855"> </a>
<a name="ln856">//---------------------------------------------------------</a>
<a name="ln857">//   swing</a>
<a name="ln858">//---------------------------------------------------------</a>
<a name="ln859"> </a>
<a name="ln860">SwingParameters Staff::swing(const Fraction&amp; tick) const</a>
<a name="ln861">      {</a>
<a name="ln862">      SwingParameters sp;</a>
<a name="ln863">      int swingUnit = 0;</a>
<a name="ln864">      QString unit = score()-&gt;styleSt(Sid::swingUnit);</a>
<a name="ln865">      int swingRatio = score()-&gt;styleI(Sid::swingRatio);</a>
<a name="ln866">      if (unit == TDuration(TDuration::DurationType::V_EIGHTH).name())</a>
<a name="ln867">            swingUnit = MScore::division / 2;</a>
<a name="ln868">      else if (unit == TDuration(TDuration::DurationType::V_16TH).name())</a>
<a name="ln869">            swingUnit = MScore::division / 4;</a>
<a name="ln870">      else if (unit == TDuration(TDuration::DurationType::V_ZERO).name())</a>
<a name="ln871">            swingUnit = 0;</a>
<a name="ln872">      sp.swingRatio = swingRatio;</a>
<a name="ln873">      sp.swingUnit = swingUnit;</a>
<a name="ln874">      if (_swingList.empty())</a>
<a name="ln875">            return sp;</a>
<a name="ln876">      QMap&lt;int, SwingParameters&gt;::const_iterator i = _swingList.upperBound(tick.ticks());</a>
<a name="ln877">      if (i == _swingList.begin())</a>
<a name="ln878">            return sp;</a>
<a name="ln879">      --i;</a>
<a name="ln880">      return i.value();</a>
<a name="ln881">      }</a>
<a name="ln882"> </a>
<a name="ln883">//---------------------------------------------------------</a>
<a name="ln884">//   capo</a>
<a name="ln885">//---------------------------------------------------------</a>
<a name="ln886"> </a>
<a name="ln887">int Staff::capo(const Fraction&amp; tick) const</a>
<a name="ln888">      {</a>
<a name="ln889">      if (_capoList.empty())</a>
<a name="ln890">            return 0;</a>
<a name="ln891">      QMap&lt;int, int&gt;::const_iterator i = _capoList.upperBound(tick.ticks());</a>
<a name="ln892">      if (i == _capoList.begin())</a>
<a name="ln893">            return 0;</a>
<a name="ln894">      --i;</a>
<a name="ln895">      return i.value();</a>
<a name="ln896">      }</a>
<a name="ln897"> </a>
<a name="ln898">//---------------------------------------------------------</a>
<a name="ln899">//   channel</a>
<a name="ln900">//---------------------------------------------------------</a>
<a name="ln901"> </a>
<a name="ln902">int Staff::channel(const Fraction&amp; tick,  int voice) const</a>
<a name="ln903">      {</a>
<a name="ln904">      if (_channelList[voice].empty())</a>
<a name="ln905">            return 0;</a>
<a name="ln906">      QMap&lt;int, int&gt;::const_iterator i = _channelList[voice].upperBound(tick.ticks());</a>
<a name="ln907">      if (i == _channelList[voice].begin())</a>
<a name="ln908">            return 0;</a>
<a name="ln909">      --i;</a>
<a name="ln910">      return i.value();</a>
<a name="ln911">      }</a>
<a name="ln912"> </a>
<a name="ln913">//---------------------------------------------------------</a>
<a name="ln914">//   middleLine</a>
<a name="ln915">//    returns logical line number of middle staff line</a>
<a name="ln916">//---------------------------------------------------------</a>
<a name="ln917"> </a>
<a name="ln918">int Staff::middleLine(const Fraction&amp; tick) const</a>
<a name="ln919">      {</a>
<a name="ln920">      return lines(tick) - 1;</a>
<a name="ln921">      }</a>
<a name="ln922"> </a>
<a name="ln923">//---------------------------------------------------------</a>
<a name="ln924">//   bottomLine</a>
<a name="ln925">//    returns logical line number of bottom staff line</a>
<a name="ln926">//---------------------------------------------------------</a>
<a name="ln927"> </a>
<a name="ln928">int Staff::bottomLine(const Fraction&amp; tick) const</a>
<a name="ln929">      {</a>
<a name="ln930">      return (lines(tick) - 1) * 2;</a>
<a name="ln931">      }</a>
<a name="ln932"> </a>
<a name="ln933">//---------------------------------------------------------</a>
<a name="ln934">//   stemless</a>
<a name="ln935">//---------------------------------------------------------</a>
<a name="ln936"> </a>
<a name="ln937">bool Staff::stemless(const Fraction&amp; tick) const</a>
<a name="ln938">      {</a>
<a name="ln939">      return staffType(tick)-&gt;stemless();</a>
<a name="ln940">      }</a>
<a name="ln941"> </a>
<a name="ln942">//---------------------------------------------------------</a>
<a name="ln943">//   setSlashStyle</a>
<a name="ln944">//---------------------------------------------------------</a>
<a name="ln945"> </a>
<a name="ln946">void Staff::setSlashStyle(const Fraction&amp; tick, bool val)</a>
<a name="ln947">      {</a>
<a name="ln948">      staffType(tick)-&gt;setStemless(val);</a>
<a name="ln949">      }</a>
<a name="ln950"> </a>
<a name="ln951">//---------------------------------------------------------</a>
<a name="ln952">//   primaryStaff</a>
<a name="ln953">///   if there are linked staves, the primary staff is</a>
<a name="ln954">///   the one who is played back and it's not a tab staff</a>
<a name="ln955">///   because we don't have enough information  to play</a>
<a name="ln956">///   e.g ornaments. NOTE: it's not necessarily the top staff!</a>
<a name="ln957">//---------------------------------------------------------</a>
<a name="ln958"> </a>
<a name="ln959">bool Staff::primaryStaff() const</a>
<a name="ln960">      {</a>
<a name="ln961">      if (!_links)</a>
<a name="ln962">            return true;</a>
<a name="ln963">      QList&lt;Staff*&gt; s;</a>
<a name="ln964">      QList&lt;Staff*&gt; ss;</a>
<a name="ln965">      for (auto e : *_links) {</a>
<a name="ln966">            Staff* staff = toStaff(e);</a>
<a name="ln967">            if (staff-&gt;score() == score()) {</a>
<a name="ln968">                  s.append(staff);</a>
<a name="ln969">                  if (!staff-&gt;isTabStaff(Fraction(0,1)))</a>
<a name="ln970">                        ss.append(staff);</a>
<a name="ln971">                  }</a>
<a name="ln972">            }</a>
<a name="ln973">      if (s.size() == 1) // the linked staves are in different scores</a>
<a name="ln974">      	return s.front() == this;</a>
<a name="ln975">      else // return a non tab linked staff in this score</a>
<a name="ln976">      	return ss.front() == this;</a>
<a name="ln977">      }</a>
<a name="ln978"> </a>
<a name="ln979">//---------------------------------------------------------</a>
<a name="ln980">//   staffType</a>
<a name="ln981">//---------------------------------------------------------</a>
<a name="ln982"> </a>
<a name="ln983">const StaffType* Staff::staffType(const Fraction&amp; tick) const</a>
<a name="ln984">      {</a>
<a name="ln985">      return &amp;_staffTypeList.staffType(tick);</a>
<a name="ln986">      }</a>
<a name="ln987"> </a>
<a name="ln988">const StaffType* Staff::constStaffType(const Fraction&amp; tick) const</a>
<a name="ln989">      {</a>
<a name="ln990">      return &amp;_staffTypeList.staffType(tick);</a>
<a name="ln991">      }</a>
<a name="ln992"> </a>
<a name="ln993">StaffType* Staff::staffType(const Fraction&amp; tick)</a>
<a name="ln994">      {</a>
<a name="ln995">      return &amp;_staffTypeList.staffType(tick);</a>
<a name="ln996">      }</a>
<a name="ln997"> </a>
<a name="ln998">//---------------------------------------------------------</a>
<a name="ln999">//   staffTypeListChanged</a>
<a name="ln1000">//    Signal that the staffTypeList has changed at</a>
<a name="ln1001">//    position tick. Update layout range.</a>
<a name="ln1002">//---------------------------------------------------------</a>
<a name="ln1003"> </a>
<a name="ln1004">void Staff::staffTypeListChanged(const Fraction&amp; tick)</a>
<a name="ln1005">      {</a>
<a name="ln1006">      triggerLayout(tick);</a>
<a name="ln1007">      auto i = _staffTypeList.find(tick.ticks());</a>
<a name="ln1008">      if (i == _staffTypeList.end()) {</a>
<a name="ln1009">            triggerLayout();</a>
<a name="ln1010">            }</a>
<a name="ln1011">      else {</a>
<a name="ln1012">            ++i;</a>
<a name="ln1013">            if (i != _staffTypeList.end())</a>
<a name="ln1014">                  triggerLayout(Fraction::fromTicks(i-&gt;first));</a>
<a name="ln1015">            else if (score()-&gt;lastMeasure())</a>
<a name="ln1016">                  triggerLayout(score()-&gt;lastMeasure()-&gt;endTick());</a>
<a name="ln1017">            }</a>
<a name="ln1018">      }</a>
<a name="ln1019"> </a>
<a name="ln1020">//---------------------------------------------------------</a>
<a name="ln1021">//   setStaffType</a>
<a name="ln1022">//---------------------------------------------------------</a>
<a name="ln1023"> </a>
<a name="ln1024">StaffType* Staff::setStaffType(const Fraction&amp; tick, const StaffType&amp; nst)</a>
<a name="ln1025">      {</a>
<a name="ln1026">      return _staffTypeList.setStaffType(tick, nst);</a>
<a name="ln1027">      }</a>
<a name="ln1028"> </a>
<a name="ln1029">//---------------------------------------------------------</a>
<a name="ln1030">//   setStaffType</a>
<a name="ln1031">//---------------------------------------------------------</a>
<a name="ln1032"> </a>
<a name="ln1033">void Staff::removeStaffType(const Fraction&amp; tick)</a>
<a name="ln1034">      {</a>
<a name="ln1035">      auto i = _staffTypeList.find(tick.ticks());</a>
<a name="ln1036">      if (i == _staffTypeList.end())</a>
<a name="ln1037">            return;</a>
<a name="ln1038">      qreal old = spatium(tick);</a>
<a name="ln1039">      _staffTypeList.erase(i);</a>
<a name="ln1040">      localSpatiumChanged(old, spatium(tick), tick);</a>
<a name="ln1041">      staffTypeListChanged(tick);</a>
<a name="ln1042">      }</a>
<a name="ln1043"> </a>
<a name="ln1044">//---------------------------------------------------------</a>
<a name="ln1045">//   init</a>
<a name="ln1046">//---------------------------------------------------------</a>
<a name="ln1047"> </a>
<a name="ln1048">void Staff::init(const InstrumentTemplate* t, const StaffType* staffType, int cidx)</a>
<a name="ln1049">      {</a>
<a name="ln1050">      // set staff-type-independent parameters</a>
<a name="ln1051">      const StaffType* pst = staffType ? staffType : t-&gt;staffTypePreset;</a>
<a name="ln1052">      if (!pst)</a>
<a name="ln1053">            pst = StaffType::getDefaultPreset(t-&gt;staffGroup);</a>
<a name="ln1054"> </a>
<a name="ln1055">      setStaffType(Fraction(0,1), *pst);</a>
<a name="ln1056">      if (cidx &gt;= MAX_STAVES) {</a>
<a name="ln1057">            setSmall(Fraction(0,1), false);</a>
<a name="ln1058">            }</a>
<a name="ln1059">      else {</a>
<a name="ln1060">            setSmall(Fraction(0,1),       t-&gt;smallStaff[cidx]);</a>
<a name="ln1061">            setBracketType(0, t-&gt;bracket[cidx]);</a>
<a name="ln1062">            setBracketSpan(0, t-&gt;bracketSpan[cidx]);</a>
<a name="ln1063">            setBarLineSpan(t-&gt;barlineSpan[cidx]);</a>
<a name="ln1064">            }</a>
<a name="ln1065">      setDefaultClefType(t-&gt;clefType(cidx));</a>
<a name="ln1066">      }</a>
<a name="ln1067"> </a>
<a name="ln1068">//---------------------------------------------------------</a>
<a name="ln1069">//   init</a>
<a name="ln1070">//---------------------------------------------------------</a>
<a name="ln1071"> </a>
<a name="ln1072">void Staff::init(const Staff* s)</a>
<a name="ln1073">      {</a>
<a name="ln1074">      _staffTypeList     = s-&gt;_staffTypeList;</a>
<a name="ln1075">      setDefaultClefType(s-&gt;defaultClefType());</a>
<a name="ln1076">      for (BracketItem* i : s-&gt;_brackets){</a>
<a name="ln1077">            BracketItem* ni = new BracketItem(*i);</a>
<a name="ln1078">            ni-&gt;setScore(score());</a>
<a name="ln1079">            ni-&gt;setStaff(this);</a>
<a name="ln1080">            _brackets.push_back(ni);</a>
<a name="ln1081">            }</a>
<a name="ln1082">      _barLineSpan       = s-&gt;_barLineSpan;</a>
<a name="ln1083">      _barLineFrom       = s-&gt;_barLineFrom;</a>
<a name="ln1084">      _barLineTo         = s-&gt;_barLineTo;</a>
<a name="ln1085">      _invisible         = s-&gt;_invisible;</a>
<a name="ln1086">      _hideWhenEmpty     = s-&gt;_hideWhenEmpty;</a>
<a name="ln1087">      _cutaway           = s-&gt;_cutaway;</a>
<a name="ln1088">      _showIfEmpty       = s-&gt;_showIfEmpty;</a>
<a name="ln1089">      _hideSystemBarLine = s-&gt;_hideSystemBarLine;</a>
<a name="ln1090">      _color             = s-&gt;_color;</a>
<a name="ln1091">      _userDist          = s-&gt;_userDist;</a>
<a name="ln1092">      }</a>
<a name="ln1093"> </a>
<a name="ln1094">//---------------------------------------------------------</a>
<a name="ln1095">//   initFromStaffType</a>
<a name="ln1096">//---------------------------------------------------------</a>
<a name="ln1097"> </a>
<a name="ln1098">void Staff::initFromStaffType(const StaffType* staffType)</a>
<a name="ln1099">      {</a>
<a name="ln1100">      // get staff type if given (if none, get default preset for default staff group)</a>
<a name="ln1101">      if (!staffType)</a>
<a name="ln1102">            staffType = StaffType::getDefaultPreset(StaffGroup::STANDARD);</a>
<a name="ln1103"> </a>
<a name="ln1104">      // use selected staff type</a>
<a name="ln1105">      setStaffType(Fraction(0,1), *staffType);</a>
<a name="ln1106">      }</a>
<a name="ln1107"> </a>
<a name="ln1108">//---------------------------------------------------------</a>
<a name="ln1109">//   spatiumChanged</a>
<a name="ln1110">//---------------------------------------------------------</a>
<a name="ln1111"> </a>
<a name="ln1112">void Staff::spatiumChanged(qreal oldValue, qreal newValue)</a>
<a name="ln1113">      {</a>
<a name="ln1114">      _userDist = (_userDist / oldValue) * newValue;</a>
<a name="ln1115">      }</a>
<a name="ln1116"> </a>
<a name="ln1117">//---------------------------------------------------------</a>
<a name="ln1118">//   show</a>
<a name="ln1119">//---------------------------------------------------------</a>
<a name="ln1120"> </a>
<a name="ln1121">bool Staff::show() const</a>
<a name="ln1122">      {</a>
<a name="ln1123">      return _part-&gt;show();</a>
<a name="ln1124">      }</a>
<a name="ln1125"> </a>
<a name="ln1126">//---------------------------------------------------------</a>
<a name="ln1127">//   genKeySig</a>
<a name="ln1128">//---------------------------------------------------------</a>
<a name="ln1129"> </a>
<a name="ln1130">bool Staff::genKeySig()</a>
<a name="ln1131">      {</a>
<a name="ln1132">      if (constStaffType(Fraction(0,1))-&gt;group() == StaffGroup::TAB)</a>
<a name="ln1133">            return false;</a>
<a name="ln1134">      else</a>
<a name="ln1135">            return constStaffType(Fraction(0,1))-&gt;genKeysig();</a>
<a name="ln1136">      }</a>
<a name="ln1137"> </a>
<a name="ln1138">//---------------------------------------------------------</a>
<a name="ln1139">//   showLedgerLines</a>
<a name="ln1140">//---------------------------------------------------------</a>
<a name="ln1141"> </a>
<a name="ln1142">bool Staff::showLedgerLines(const Fraction&amp; tick) const</a>
<a name="ln1143">      {</a>
<a name="ln1144">      return staffType(tick)-&gt;showLedgerLines();</a>
<a name="ln1145">      }</a>
<a name="ln1146"> </a>
<a name="ln1147">//---------------------------------------------------------</a>
<a name="ln1148">//   updateOttava</a>
<a name="ln1149">//---------------------------------------------------------</a>
<a name="ln1150"> </a>
<a name="ln1151">void Staff::updateOttava()</a>
<a name="ln1152">      {</a>
<a name="ln1153">      int staffIdx = idx();</a>
<a name="ln1154">      _pitchOffsets.clear();</a>
<a name="ln1155">      for (auto i : score()-&gt;spanner()) {</a>
<a name="ln1156">            const Spanner* s = i.second;</a>
<a name="ln1157">            if (s-&gt;type() == ElementType::OTTAVA &amp;&amp; s-&gt;staffIdx() == staffIdx) {</a>
<a name="ln1158">                  const Ottava* o = static_cast&lt;const Ottava*&gt;(s);</a>
<a name="ln1159">                  _pitchOffsets.setPitchOffset(o-&gt;tick().ticks(), o-&gt;pitchShift());</a>
<a name="ln1160">                  _pitchOffsets.setPitchOffset(o-&gt;tick2().ticks(), 0);</a>
<a name="ln1161">                  }</a>
<a name="ln1162">            }</a>
<a name="ln1163">      }</a>
<a name="ln1164"> </a>
<a name="ln1165">//---------------------------------------------------------</a>
<a name="ln1166">//   undoSetColor</a>
<a name="ln1167">//---------------------------------------------------------</a>
<a name="ln1168"> </a>
<a name="ln1169">void Staff::undoSetColor(const QColor&amp; /*val*/)</a>
<a name="ln1170">      {</a>
<a name="ln1171">//      undoChangeProperty(Pid::COLOR, val);</a>
<a name="ln1172">      }</a>
<a name="ln1173"> </a>
<a name="ln1174">//---------------------------------------------------------</a>
<a name="ln1175">//   insertTime</a>
<a name="ln1176">//---------------------------------------------------------</a>
<a name="ln1177"> </a>
<a name="ln1178">void Staff::insertTime(const Fraction&amp; tick, const Fraction&amp; len)</a>
<a name="ln1179">      {</a>
<a name="ln1180">      if (len.isZero())</a>
<a name="ln1181">            return;</a>
<a name="ln1182"> </a>
<a name="ln1183">      // move all keys and clefs &gt;= tick</a>
<a name="ln1184"> </a>
<a name="ln1185">      if (len &lt; Fraction(0,1)) {</a>
<a name="ln1186">            // remove entries between tickpos &gt;= tick and tickpos &lt; (tick+len)</a>
<a name="ln1187">            _keys.erase(_keys.lower_bound(tick.ticks()), _keys.lower_bound((tick - len).ticks()));</a>
<a name="ln1188">            clefs.erase(clefs.lower_bound(tick.ticks()), clefs.lower_bound((tick - len).ticks()));</a>
<a name="ln1189">            }</a>
<a name="ln1190"> </a>
<a name="ln1191">      KeyList kl2;</a>
<a name="ln1192">      for (auto i = _keys.lower_bound(tick.ticks()); i != _keys.end();) {</a>
<a name="ln1193">            KeySigEvent kse = i-&gt;second;</a>
<a name="ln1194">            Fraction t = Fraction::fromTicks(i-&gt;first);</a>
<a name="ln1195">            _keys.erase(i++);</a>
<a name="ln1196">            kl2[(t + len).ticks()] = kse;</a>
<a name="ln1197">            }</a>
<a name="ln1198">      _keys.insert(kl2.begin(), kl2.end());</a>
<a name="ln1199"> </a>
<a name="ln1200">      // check if there is a clef at the end of measure</a>
<a name="ln1201">      // before tick</a>
<a name="ln1202">      Clef* clef = 0;</a>
<a name="ln1203">      Measure* m = score()-&gt;tick2measure(tick);</a>
<a name="ln1204">      if (m &amp;&amp; (m-&gt;tick() == tick) &amp;&amp; (m-&gt;prevMeasure())) {</a>
<a name="ln1205">            m = m-&gt;prevMeasure();</a>
<a name="ln1206">            Segment* s = m-&gt;findSegment(SegmentType::Clef, tick);</a>
<a name="ln1207">            if (s) {</a>
<a name="ln1208">                  int track = idx() * VOICES;</a>
<a name="ln1209">                  clef = toClef(s-&gt;element(track));</a>
<a name="ln1210">                  }</a>
<a name="ln1211">            }</a>
<a name="ln1212"> </a>
<a name="ln1213">      ClefList cl2;</a>
<a name="ln1214">      for (auto i = clefs.lower_bound(tick.ticks()); i != clefs.end();) {</a>
<a name="ln1215">            ClefTypeList ctl = i-&gt;second;</a>
<a name="ln1216">            Fraction t = Fraction::fromTicks(i-&gt;first);</a>
<a name="ln1217">            if (clef &amp;&amp; tick == t) {</a>
<a name="ln1218">                  ++i;</a>
<a name="ln1219">                  continue;</a>
<a name="ln1220">                  }</a>
<a name="ln1221">            clefs.erase(i++);</a>
<a name="ln1222">            cl2.setClef((t + len).ticks(), ctl);</a>
<a name="ln1223">            }</a>
<a name="ln1224">      clefs.insert(cl2.begin(), cl2.end());</a>
<a name="ln1225"> </a>
<a name="ln1226">      // check if there is a clef at the end of measure</a>
<a name="ln1227">      // before tick: do not remove from clefs list</a>
<a name="ln1228"> </a>
<a name="ln1229">      if (clef)</a>
<a name="ln1230">            setClef(clef);</a>
<a name="ln1231"> </a>
<a name="ln1232">      updateOttava();</a>
<a name="ln1233">      DUMP_CLEFS(&quot;  insertTime&quot;);</a>
<a name="ln1234">      }</a>
<a name="ln1235"> </a>
<a name="ln1236">//---------------------------------------------------------</a>
<a name="ln1237">//   staffList</a>
<a name="ln1238">//    return list of linked staves</a>
<a name="ln1239">//---------------------------------------------------------</a>
<a name="ln1240"> </a>
<a name="ln1241">QList&lt;Staff*&gt; Staff::staffList() const</a>
<a name="ln1242">      {</a>
<a name="ln1243">      QList&lt;Staff*&gt; staffList;</a>
<a name="ln1244">      if (_links) {</a>
<a name="ln1245">            for (ScoreElement* e : *_links)</a>
<a name="ln1246">                  staffList.append(toStaff(e));</a>
<a name="ln1247">//            staffList = _linkedStaves-&gt;staves();</a>
<a name="ln1248">            }</a>
<a name="ln1249">      else</a>
<a name="ln1250">            staffList.append(const_cast&lt;Staff*&gt;(this));</a>
<a name="ln1251">      return staffList;</a>
<a name="ln1252">      }</a>
<a name="ln1253"> </a>
<a name="ln1254">//---------------------------------------------------------</a>
<a name="ln1255">//   rstaff</a>
<a name="ln1256">//---------------------------------------------------------</a>
<a name="ln1257"> </a>
<a name="ln1258">int Staff::rstaff() const</a>
<a name="ln1259">      {</a>
<a name="ln1260">      return _part-&gt;staves()-&gt;indexOf((Staff*)this, 0);</a>
<a name="ln1261">      }</a>
<a name="ln1262"> </a>
<a name="ln1263">//---------------------------------------------------------</a>
<a name="ln1264">//   isTop</a>
<a name="ln1265">//---------------------------------------------------------</a>
<a name="ln1266"> </a>
<a name="ln1267">bool Staff::isTop() const</a>
<a name="ln1268">      {</a>
<a name="ln1269">      return _part-&gt;staves()-&gt;front() == this;</a>
<a name="ln1270">      }</a>
<a name="ln1271"> </a>
<a name="ln1272">//---------------------------------------------------------</a>
<a name="ln1273">//   getProperty</a>
<a name="ln1274">//---------------------------------------------------------</a>
<a name="ln1275"> </a>
<a name="ln1276">QVariant Staff::getProperty(Pid id) const</a>
<a name="ln1277">      {</a>
<a name="ln1278">      switch (id) {</a>
<a name="ln1279">            case Pid::SMALL:</a>
<a name="ln1280">                  return small(Fraction(0,1));</a>
<a name="ln1281">            case Pid::MAG:</a>
<a name="ln1282">                  return userMag(Fraction(0,1));</a>
<a name="ln1283">            case Pid::COLOR:</a>
<a name="ln1284">                  return color();</a>
<a name="ln1285">            case Pid::PLAYBACK_VOICE1:</a>
<a name="ln1286">                  return playbackVoice(0);</a>
<a name="ln1287">            case Pid::PLAYBACK_VOICE2:</a>
<a name="ln1288">                  return playbackVoice(1);</a>
<a name="ln1289">            case Pid::PLAYBACK_VOICE3:</a>
<a name="ln1290">                  return playbackVoice(2);</a>
<a name="ln1291">            case Pid::PLAYBACK_VOICE4:</a>
<a name="ln1292">                  return playbackVoice(3);</a>
<a name="ln1293">            case Pid::STAFF_BARLINE_SPAN:</a>
<a name="ln1294">                  return barLineSpan();</a>
<a name="ln1295">            case Pid::STAFF_BARLINE_SPAN_FROM:</a>
<a name="ln1296">                  return barLineFrom();</a>
<a name="ln1297">            case Pid::STAFF_BARLINE_SPAN_TO:</a>
<a name="ln1298">                  return barLineTo();</a>
<a name="ln1299">            case Pid::STAFF_USERDIST:</a>
<a name="ln1300">                  return userDist();</a>
<a name="ln1301">            case Pid::GENERATED:</a>
<a name="ln1302">                  return false;</a>
<a name="ln1303">            default:</a>
<a name="ln1304">                  qDebug(&quot;unhandled id &lt;%s&gt;&quot;, propertyName(id));</a>
<a name="ln1305">                  return QVariant();</a>
<a name="ln1306">            }</a>
<a name="ln1307">      }</a>
<a name="ln1308"> </a>
<a name="ln1309">//---------------------------------------------------------</a>
<a name="ln1310">//   setProperty</a>
<a name="ln1311">//---------------------------------------------------------</a>
<a name="ln1312"> </a>
<a name="ln1313">bool Staff::setProperty(Pid id, const QVariant&amp; v)</a>
<a name="ln1314">      {</a>
<a name="ln1315">      switch (id) {</a>
<a name="ln1316">            case Pid::SMALL: {</a>
<a name="ln1317">                  qreal _spatium = spatium(Fraction(0,1));</a>
<a name="ln1318">                  setSmall(Fraction(0,1), v.toBool());</a>
<a name="ln1319">                  localSpatiumChanged(_spatium, spatium(Fraction(0,1)), Fraction(0, 1));</a>
<a name="ln1320">                  break;</a>
<a name="ln1321">                  }</a>
<a name="ln1322">            case Pid::MAG: {</a>
<a name="ln1323">                  qreal _spatium = spatium(Fraction(0,1));</a>
<a name="ln1324">                  setUserMag(Fraction(0,1), v.toReal());</a>
<a name="ln1325">                  localSpatiumChanged(_spatium, spatium(Fraction(0,1)), Fraction(0, 1));</a>
<a name="ln1326">                  }</a>
<a name="ln1327">                  break;</a>
<a name="ln1328">            case Pid::COLOR:</a>
<a name="ln1329">                  setColor(v.value&lt;QColor&gt;());</a>
<a name="ln1330">                  break;</a>
<a name="ln1331">            case Pid::PLAYBACK_VOICE1:</a>
<a name="ln1332">                  setPlaybackVoice(0, v.toBool());</a>
<a name="ln1333">                  break;</a>
<a name="ln1334">            case Pid::PLAYBACK_VOICE2:</a>
<a name="ln1335">                  setPlaybackVoice(1, v.toBool());</a>
<a name="ln1336">                  break;</a>
<a name="ln1337">            case Pid::PLAYBACK_VOICE3:</a>
<a name="ln1338">                  setPlaybackVoice(2, v.toBool());</a>
<a name="ln1339">                  break;</a>
<a name="ln1340">            case Pid::PLAYBACK_VOICE4:</a>
<a name="ln1341">                  setPlaybackVoice(3, v.toBool());</a>
<a name="ln1342">                  break;</a>
<a name="ln1343">            case Pid::STAFF_BARLINE_SPAN: {</a>
<a name="ln1344">                  setBarLineSpan(v.toInt());</a>
<a name="ln1345">                  // update non-generated barlines</a>
<a name="ln1346">                  int track = idx() * VOICES;</a>
<a name="ln1347">                  std::vector&lt;Element*&gt; blList;</a>
<a name="ln1348">                  for (Measure* m = score()-&gt;firstMeasure(); m; m = m-&gt;nextMeasure()) {</a>
<a name="ln1349">                        Segment* s = m-&gt;getSegmentR(SegmentType::EndBarLine, m-&gt;ticks());</a>
<a name="ln1350">                        if (s &amp;&amp; s-&gt;element(track))</a>
<a name="ln1351">                              blList.push_back(s-&gt;element(track));</a>
<a name="ln1352">                        if (Measure* mm = m-&gt;mmRest()) {</a>
<a name="ln1353">                              Segment* ss = mm-&gt;getSegmentR(SegmentType::EndBarLine, mm-&gt;ticks());</a>
<a name="ln1354">                              if (ss &amp;&amp; ss-&gt;element(track))</a>
<a name="ln1355">                                    blList.push_back(ss-&gt;element(track));</a>
<a name="ln1356">                              }</a>
<a name="ln1357">                        }</a>
<a name="ln1358">                  for (Element* e : blList) {</a>
<a name="ln1359">                        if (e &amp;&amp; e-&gt;isBarLine() &amp;&amp; !e-&gt;generated())</a>
<a name="ln1360">                              toBarLine(e)-&gt;setSpanStaff(v.toInt());</a>
<a name="ln1361">                        }</a>
<a name="ln1362">                  }</a>
<a name="ln1363">                  break;</a>
<a name="ln1364">            case Pid::STAFF_BARLINE_SPAN_FROM:</a>
<a name="ln1365">                  setBarLineFrom(v.toInt());</a>
<a name="ln1366">                  break;</a>
<a name="ln1367">            case Pid::STAFF_BARLINE_SPAN_TO:</a>
<a name="ln1368">                  setBarLineTo(v.toInt());</a>
<a name="ln1369">                  break;</a>
<a name="ln1370">            case Pid::STAFF_USERDIST:</a>
<a name="ln1371">                  setUserDist(v.toReal());</a>
<a name="ln1372">                  break;</a>
<a name="ln1373">            default:</a>
<a name="ln1374">                  qDebug(&quot;unhandled id &lt;%s&gt;&quot;, propertyName(id));</a>
<a name="ln1375">                  break;</a>
<a name="ln1376">            }</a>
<a name="ln1377">      triggerLayout();</a>
<a name="ln1378">      return true;</a>
<a name="ln1379">      }</a>
<a name="ln1380"> </a>
<a name="ln1381">//---------------------------------------------------------</a>
<a name="ln1382">//   propertyDefault</a>
<a name="ln1383">//---------------------------------------------------------</a>
<a name="ln1384"> </a>
<a name="ln1385">QVariant Staff::propertyDefault(Pid id) const</a>
<a name="ln1386">      {</a>
<a name="ln1387">      switch (id) {</a>
<a name="ln1388">            case Pid::SMALL:</a>
<a name="ln1389">                  return false;</a>
<a name="ln1390">            case Pid::MAG:</a>
<a name="ln1391">                  return 1.0;</a>
<a name="ln1392">            case Pid::COLOR:</a>
<a name="ln1393">                  return QColor(Qt::black);</a>
<a name="ln1394">            case Pid::PLAYBACK_VOICE1:</a>
<a name="ln1395">            case Pid::PLAYBACK_VOICE2:</a>
<a name="ln1396">            case Pid::PLAYBACK_VOICE3:</a>
<a name="ln1397">            case Pid::PLAYBACK_VOICE4:</a>
<a name="ln1398">                  return true;</a>
<a name="ln1399">            case Pid::STAFF_BARLINE_SPAN:</a>
<a name="ln1400">                  return false;</a>
<a name="ln1401">            case Pid::STAFF_BARLINE_SPAN_FROM:</a>
<a name="ln1402">            case Pid::STAFF_BARLINE_SPAN_TO:</a>
<a name="ln1403">                  return 0;</a>
<a name="ln1404">            case Pid::STAFF_USERDIST:</a>
<a name="ln1405">                  return qreal(0.0);</a>
<a name="ln1406">            default:</a>
<a name="ln1407">                  qDebug(&quot;unhandled id &lt;%s&gt;&quot;, propertyName(id));</a>
<a name="ln1408">                  return QVariant();</a>
<a name="ln1409">            }</a>
<a name="ln1410">      }</a>
<a name="ln1411"> </a>
<a name="ln1412">//---------------------------------------------------------</a>
<a name="ln1413">//   localSpatiumChanged</a>
<a name="ln1414">//---------------------------------------------------------</a>
<a name="ln1415"> </a>
<a name="ln1416">void Staff::localSpatiumChanged(double oldVal, double newVal, Fraction tick)</a>
<a name="ln1417">      {</a>
<a name="ln1418">      Fraction etick;</a>
<a name="ln1419">      auto i = _staffTypeList.upper_bound(tick.ticks());</a>
<a name="ln1420">      if (i == _staffTypeList.end())</a>
<a name="ln1421">            etick = score()-&gt;lastSegment()-&gt;tick();</a>
<a name="ln1422">      else</a>
<a name="ln1423">            etick = Fraction::fromTicks(i-&gt;first);</a>
<a name="ln1424">      int staffIdx = idx();</a>
<a name="ln1425">      int startTrack = staffIdx * VOICES;</a>
<a name="ln1426">      int endTrack = startTrack + VOICES;</a>
<a name="ln1427">      for (Segment* s = score()-&gt;tick2rightSegment(tick); s &amp;&amp; s-&gt;tick() &lt; etick; s = s-&gt;next1()) {</a>
<a name="ln1428">            for (Element* e : s-&gt;annotations()) {</a>
<a name="ln1429">                  if (e-&gt;track() &gt;= startTrack &amp;&amp; e-&gt;track() &lt; endTrack)</a>
<a name="ln1430">                        e-&gt;localSpatiumChanged(oldVal, newVal);</a>
<a name="ln1431">                  }</a>
<a name="ln1432">            for (int track = startTrack; track &lt; endTrack; ++track) {</a>
<a name="ln1433">                  if (s-&gt;element(track))</a>
<a name="ln1434">                        s-&gt;element(track)-&gt;localSpatiumChanged(oldVal, newVal);</a>
<a name="ln1435">                  }</a>
<a name="ln1436">            }</a>
<a name="ln1437">      auto spanners = score()-&gt;spannerMap().findContained(tick.ticks(), etick.ticks());</a>
<a name="ln1438">      for (auto interval : spanners) {</a>
<a name="ln1439">            Spanner* spanner = interval.value;</a>
<a name="ln1440">            if (spanner-&gt;staffIdx() == staffIdx) {</a>
<a name="ln1441">                  for (auto k : spanner-&gt;spannerSegments())</a>
<a name="ln1442">                        k-&gt;localSpatiumChanged(oldVal, newVal);</a>
<a name="ln1443">                  }</a>
<a name="ln1444">            }</a>
<a name="ln1445">      }</a>
<a name="ln1446"> </a>
<a name="ln1447">//---------------------------------------------------------</a>
<a name="ln1448">//   isPitchedStaff</a>
<a name="ln1449">//---------------------------------------------------------</a>
<a name="ln1450"> </a>
<a name="ln1451">bool Staff::isPitchedStaff(const Fraction&amp; tick) const</a>
<a name="ln1452">      {</a>
<a name="ln1453">      return staffType(tick)-&gt;group() == StaffGroup::STANDARD;</a>
<a name="ln1454">      }</a>
<a name="ln1455"> </a>
<a name="ln1456">//---------------------------------------------------------</a>
<a name="ln1457">//   isTabStaff</a>
<a name="ln1458">//---------------------------------------------------------</a>
<a name="ln1459"> </a>
<a name="ln1460">bool Staff::isTabStaff(const Fraction&amp; tick) const</a>
<a name="ln1461">      {</a>
<a name="ln1462">      return staffType(tick)-&gt;group() == StaffGroup::TAB;</a>
<a name="ln1463">      }</a>
<a name="ln1464"> </a>
<a name="ln1465">//---------------------------------------------------------</a>
<a name="ln1466">//   isDrumStaff</a>
<a name="ln1467">//---------------------------------------------------------</a>
<a name="ln1468"> </a>
<a name="ln1469">bool Staff::isDrumStaff(const Fraction&amp; tick) const</a>
<a name="ln1470">      {</a>
<a name="ln1471">      return staffType(tick)-&gt;group() == StaffGroup::PERCUSSION;</a>
<a name="ln1472">      }</a>
<a name="ln1473"> </a>
<a name="ln1474">//---------------------------------------------------------</a>
<a name="ln1475">//   lines</a>
<a name="ln1476">//---------------------------------------------------------</a>
<a name="ln1477"> </a>
<a name="ln1478">int Staff::lines(const Fraction&amp; tick) const</a>
<a name="ln1479">      {</a>
<a name="ln1480">      return staffType(tick)-&gt;lines();</a>
<a name="ln1481">      }</a>
<a name="ln1482"> </a>
<a name="ln1483">//---------------------------------------------------------</a>
<a name="ln1484">//   setLines</a>
<a name="ln1485">//---------------------------------------------------------</a>
<a name="ln1486"> </a>
<a name="ln1487">void Staff::setLines(const Fraction&amp; tick, int val)</a>
<a name="ln1488">      {</a>
<a name="ln1489">      staffType(tick)-&gt;setLines(val);</a>
<a name="ln1490">      }</a>
<a name="ln1491"> </a>
<a name="ln1492">//---------------------------------------------------------</a>
<a name="ln1493">//   lineDistance</a>
<a name="ln1494">//    distance between staff lines</a>
<a name="ln1495">//---------------------------------------------------------</a>
<a name="ln1496"> </a>
<a name="ln1497">qreal Staff::lineDistance(const Fraction&amp; tick) const</a>
<a name="ln1498">      {</a>
<a name="ln1499">      return staffType(tick)-&gt;lineDistance().val();</a>
<a name="ln1500">      }</a>
<a name="ln1501"> </a>
<a name="ln1502">}</a>
<a name="ln1503"> </a>

</code></pre>
<div class="balloon" rel="1304"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1374"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="1407"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v618/" target="_blank">V618</a> It's dangerous to call the 'debug' function in such a manner, as the line being passed could contain format specification. The example of the safe code: printf("%s", str);</p></div>
<div class="balloon" rel="8"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1042/" target="_blank">V1042</a> This file is marked with copyleft license, which requires you to open the derived source code.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
