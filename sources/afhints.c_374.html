
<html>
<head>

  <meta http-equiv="Content-Type" content="text/html; charset=US-ASCII" />
  <title>afhints.c</title>

  <link rel="stylesheet" href="../style.css"/>
  <script src="../jquery-3.2.1.min.js"></script>
</head>
<body>

<pre><code class = "cpp">
<a name="ln1">/***************************************************************************/</a>
<a name="ln2">/*                                                                         */</a>
<a name="ln3">/*  afhints.c                                                              */</a>
<a name="ln4">/*                                                                         */</a>
<a name="ln5">/*    Auto-fitter hinting routines (body).                                 */</a>
<a name="ln6">/*                                                                         */</a>
<a name="ln7">/*  Copyright 2003-2015 by                                                 */</a>
<a name="ln8">/*  David Turner, Robert Wilhelm, and Werner Lemberg.                      */</a>
<a name="ln9">/*                                                                         */</a>
<a name="ln10">/*  This file is part of the FreeType project, and may only be used,       */</a>
<a name="ln11">/*  modified, and distributed under the terms of the FreeType project      */</a>
<a name="ln12">/*  license, LICENSE.TXT.  By continuing to use, modify, or distribute     */</a>
<a name="ln13">/*  this file you indicate that you have read the license and              */</a>
<a name="ln14">/*  understand and accept it fully.                                        */</a>
<a name="ln15">/*                                                                         */</a>
<a name="ln16">/***************************************************************************/</a>
<a name="ln17"> </a>
<a name="ln18"> </a>
<a name="ln19">#include &quot;afhints.h&quot;</a>
<a name="ln20">#include &quot;aferrors.h&quot;</a>
<a name="ln21">#include FT_INTERNAL_CALC_H</a>
<a name="ln22">#include FT_INTERNAL_DEBUG_H</a>
<a name="ln23"> </a>
<a name="ln24"> </a>
<a name="ln25">  /*************************************************************************/</a>
<a name="ln26">  /*                                                                       */</a>
<a name="ln27">  /* The macro FT_COMPONENT is used in trace mode.  It is an implicit      */</a>
<a name="ln28">  /* parameter of the FT_TRACE() and FT_ERROR() macros, used to print/log  */</a>
<a name="ln29">  /* messages during execution.                                            */</a>
<a name="ln30">  /*                                                                       */</a>
<a name="ln31">#undef  FT_COMPONENT</a>
<a name="ln32">#define FT_COMPONENT  trace_afhints</a>
<a name="ln33"> </a>
<a name="ln34"> </a>
<a name="ln35">  /* Get new segment for given axis. */</a>
<a name="ln36"> </a>
<a name="ln37">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln38">  af_axis_hints_new_segment( AF_AxisHints  axis,</a>
<a name="ln39">                             FT_Memory     memory,</a>
<a name="ln40">                             AF_Segment   *asegment )</a>
<a name="ln41">  {</a>
<a name="ln42">    FT_Error    error   = FT_Err_Ok;</a>
<a name="ln43">    AF_Segment  segment = NULL;</a>
<a name="ln44"> </a>
<a name="ln45"> </a>
<a name="ln46">    if ( axis-&gt;num_segments &lt; AF_SEGMENTS_EMBEDDED )</a>
<a name="ln47">    {</a>
<a name="ln48">      if ( axis-&gt;segments == NULL )</a>
<a name="ln49">      {</a>
<a name="ln50">        axis-&gt;segments     = axis-&gt;embedded.segments;</a>
<a name="ln51">        axis-&gt;max_segments = AF_SEGMENTS_EMBEDDED;</a>
<a name="ln52">      }</a>
<a name="ln53">    }</a>
<a name="ln54">    else if ( axis-&gt;num_segments &gt;= axis-&gt;max_segments )</a>
<a name="ln55">    {</a>
<a name="ln56">      FT_Int  old_max = axis-&gt;max_segments;</a>
<a name="ln57">      FT_Int  new_max = old_max;</a>
<a name="ln58">      FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *segment ) );</a>
<a name="ln59"> </a>
<a name="ln60"> </a>
<a name="ln61">      if ( old_max &gt;= big_max )</a>
<a name="ln62">      {</a>
<a name="ln63">        error = FT_THROW( Out_Of_Memory );</a>
<a name="ln64">        goto Exit;</a>
<a name="ln65">      }</a>
<a name="ln66"> </a>
<a name="ln67">      new_max += ( new_max &gt;&gt; 2 ) + 4;</a>
<a name="ln68">      if ( new_max &lt; old_max || new_max &gt; big_max )</a>
<a name="ln69">        new_max = big_max;</a>
<a name="ln70"> </a>
<a name="ln71">      if ( axis-&gt;segments == axis-&gt;embedded.segments )</a>
<a name="ln72">      {</a>
<a name="ln73">        if ( FT_NEW_ARRAY( axis-&gt;segments, new_max ) )</a>
<a name="ln74">          goto Exit;</a>
<a name="ln75">        ft_memcpy( axis-&gt;segments, axis-&gt;embedded.segments,</a>
<a name="ln76">                   sizeof ( axis-&gt;embedded.segments ) );</a>
<a name="ln77">      }</a>
<a name="ln78">      else</a>
<a name="ln79">      {</a>
<a name="ln80">        if ( FT_RENEW_ARRAY( axis-&gt;segments, old_max, new_max ) )</a>
<a name="ln81">          goto Exit;</a>
<a name="ln82">      }</a>
<a name="ln83"> </a>
<a name="ln84">      axis-&gt;max_segments = new_max;</a>
<a name="ln85">    }</a>
<a name="ln86"> </a>
<a name="ln87">    segment = axis-&gt;segments + axis-&gt;num_segments++;</a>
<a name="ln88"> </a>
<a name="ln89">  Exit:</a>
<a name="ln90">    *asegment = segment;</a>
<a name="ln91">    return error;</a>
<a name="ln92">  }</a>
<a name="ln93"> </a>
<a name="ln94"> </a>
<a name="ln95">  /* Get new edge for given axis, direction, and position, */</a>
<a name="ln96">  /* without initializing the edge itself.                 */</a>
<a name="ln97"> </a>
<a name="ln98">  FT_LOCAL( FT_Error )</a>
<a name="ln99">  af_axis_hints_new_edge( AF_AxisHints  axis,</a>
<a name="ln100">                          FT_Int        fpos,</a>
<a name="ln101">                          AF_Direction  dir,</a>
<a name="ln102">                          FT_Memory     memory,</a>
<a name="ln103">                          AF_Edge      *anedge )</a>
<a name="ln104">  {</a>
<a name="ln105">    FT_Error  error = FT_Err_Ok;</a>
<a name="ln106">    AF_Edge   edge  = NULL;</a>
<a name="ln107">    AF_Edge   edges;</a>
<a name="ln108"> </a>
<a name="ln109"> </a>
<a name="ln110">    if ( axis-&gt;num_edges &lt; AF_EDGES_EMBEDDED )</a>
<a name="ln111">    {</a>
<a name="ln112">      if ( axis-&gt;edges == NULL )</a>
<a name="ln113">      {</a>
<a name="ln114">        axis-&gt;edges     = axis-&gt;embedded.edges;</a>
<a name="ln115">        axis-&gt;max_edges = AF_EDGES_EMBEDDED;</a>
<a name="ln116">      }</a>
<a name="ln117">    }</a>
<a name="ln118">    else if ( axis-&gt;num_edges &gt;= axis-&gt;max_edges )</a>
<a name="ln119">    {</a>
<a name="ln120">      FT_Int  old_max = axis-&gt;max_edges;</a>
<a name="ln121">      FT_Int  new_max = old_max;</a>
<a name="ln122">      FT_Int  big_max = (FT_Int)( FT_INT_MAX / sizeof ( *edge ) );</a>
<a name="ln123"> </a>
<a name="ln124"> </a>
<a name="ln125">      if ( old_max &gt;= big_max )</a>
<a name="ln126">      {</a>
<a name="ln127">        error = FT_THROW( Out_Of_Memory );</a>
<a name="ln128">        goto Exit;</a>
<a name="ln129">      }</a>
<a name="ln130"> </a>
<a name="ln131">      new_max += ( new_max &gt;&gt; 2 ) + 4;</a>
<a name="ln132">      if ( new_max &lt; old_max || new_max &gt; big_max )</a>
<a name="ln133">        new_max = big_max;</a>
<a name="ln134"> </a>
<a name="ln135">      if ( axis-&gt;edges == axis-&gt;embedded.edges )</a>
<a name="ln136">      {</a>
<a name="ln137">        if ( FT_NEW_ARRAY( axis-&gt;edges, new_max ) )</a>
<a name="ln138">          goto Exit;</a>
<a name="ln139">        ft_memcpy( axis-&gt;edges, axis-&gt;embedded.edges,</a>
<a name="ln140">                   sizeof ( axis-&gt;embedded.edges ) );</a>
<a name="ln141">      }</a>
<a name="ln142">      else</a>
<a name="ln143">      {</a>
<a name="ln144">        if ( FT_RENEW_ARRAY( axis-&gt;edges, old_max, new_max ) )</a>
<a name="ln145">          goto Exit;</a>
<a name="ln146">      }</a>
<a name="ln147"> </a>
<a name="ln148">      axis-&gt;max_edges = new_max;</a>
<a name="ln149">    }</a>
<a name="ln150"> </a>
<a name="ln151">    edges = axis-&gt;edges;</a>
<a name="ln152">    edge  = edges + axis-&gt;num_edges;</a>
<a name="ln153"> </a>
<a name="ln154">    while ( edge &gt; edges )</a>
<a name="ln155">    {</a>
<a name="ln156">      if ( edge[-1].fpos &lt; fpos )</a>
<a name="ln157">        break;</a>
<a name="ln158"> </a>
<a name="ln159">      /* we want the edge with same position and minor direction */</a>
<a name="ln160">      /* to appear before those in the major one in the list     */</a>
<a name="ln161">      if ( edge[-1].fpos == fpos &amp;&amp; dir == axis-&gt;major_dir )</a>
<a name="ln162">        break;</a>
<a name="ln163"> </a>
<a name="ln164">      edge[0] = edge[-1];</a>
<a name="ln165">      edge--;</a>
<a name="ln166">    }</a>
<a name="ln167"> </a>
<a name="ln168">    axis-&gt;num_edges++;</a>
<a name="ln169"> </a>
<a name="ln170">  Exit:</a>
<a name="ln171">    *anedge = edge;</a>
<a name="ln172">    return error;</a>
<a name="ln173">  }</a>
<a name="ln174"> </a>
<a name="ln175"> </a>
<a name="ln176">#ifdef FT_DEBUG_AUTOFIT</a>
<a name="ln177"> </a>
<a name="ln178">#include FT_CONFIG_STANDARD_LIBRARY_H</a>
<a name="ln179"> </a>
<a name="ln180">  /* The dump functions are used in the `ftgrid' demo program, too. */</a>
<a name="ln181">#define AF_DUMP( varformat )          \</a>
<a name="ln182">          do                          \</a>
<a name="ln183">          {                           \</a>
<a name="ln184">            if ( to_stdout )          \</a>
<a name="ln185">              printf varformat;       \</a>
<a name="ln186">            else                      \</a>
<a name="ln187">              FT_TRACE7( varformat ); \</a>
<a name="ln188">          } while ( 0 )</a>
<a name="ln189"> </a>
<a name="ln190"> </a>
<a name="ln191">  static const char*</a>
<a name="ln192">  af_dir_str( AF_Direction  dir )</a>
<a name="ln193">  {</a>
<a name="ln194">    const char*  result;</a>
<a name="ln195"> </a>
<a name="ln196"> </a>
<a name="ln197">    switch ( dir )</a>
<a name="ln198">    {</a>
<a name="ln199">    case AF_DIR_UP:</a>
<a name="ln200">      result = &quot;up&quot;;</a>
<a name="ln201">      break;</a>
<a name="ln202">    case AF_DIR_DOWN:</a>
<a name="ln203">      result = &quot;down&quot;;</a>
<a name="ln204">      break;</a>
<a name="ln205">    case AF_DIR_LEFT:</a>
<a name="ln206">      result = &quot;left&quot;;</a>
<a name="ln207">      break;</a>
<a name="ln208">    case AF_DIR_RIGHT:</a>
<a name="ln209">      result = &quot;right&quot;;</a>
<a name="ln210">      break;</a>
<a name="ln211">    default:</a>
<a name="ln212">      result = &quot;none&quot;;</a>
<a name="ln213">    }</a>
<a name="ln214"> </a>
<a name="ln215">    return result;</a>
<a name="ln216">  }</a>
<a name="ln217"> </a>
<a name="ln218"> </a>
<a name="ln219">#define AF_INDEX_NUM( ptr, base )  (int)( (ptr) ? ( (ptr) - (base) ) : -1 )</a>
<a name="ln220"> </a>
<a name="ln221"> </a>
<a name="ln222">#ifdef __cplusplus</a>
<a name="ln223">  extern &quot;C&quot; {</a>
<a name="ln224">#endif</a>
<a name="ln225">  void</a>
<a name="ln226">  af_glyph_hints_dump_points( AF_GlyphHints  hints,</a>
<a name="ln227">                              FT_Bool        to_stdout )</a>
<a name="ln228">  {</a>
<a name="ln229">    AF_Point  points = hints-&gt;points;</a>
<a name="ln230">    AF_Point  limit  = points + hints-&gt;num_points;</a>
<a name="ln231">    AF_Point  point;</a>
<a name="ln232"> </a>
<a name="ln233"> </a>
<a name="ln234">    AF_DUMP(( &quot;Table of points:\n&quot; ));</a>
<a name="ln235"> </a>
<a name="ln236">    if ( hints-&gt;num_points )</a>
<a name="ln237">      AF_DUMP(( &quot;  [ index |  xorg |  yorg | xscale | yscale&quot;</a>
<a name="ln238">                &quot; |  xfit |  yfit |  flags ]\n&quot; ));</a>
<a name="ln239">    else</a>
<a name="ln240">      AF_DUMP(( &quot;  (none)\n&quot; ));</a>
<a name="ln241"> </a>
<a name="ln242">    for ( point = points; point &lt; limit; point++ )</a>
<a name="ln243">      AF_DUMP(( &quot;  [ %5d | %5d | %5d | %6.2f | %6.2f&quot;</a>
<a name="ln244">                &quot; | %5.2f | %5.2f | %c ]\n&quot;,</a>
<a name="ln245">                AF_INDEX_NUM( point, points ),</a>
<a name="ln246">                point-&gt;fx,</a>
<a name="ln247">                point-&gt;fy,</a>
<a name="ln248">                point-&gt;ox / 64.0,</a>
<a name="ln249">                point-&gt;oy / 64.0,</a>
<a name="ln250">                point-&gt;x / 64.0,</a>
<a name="ln251">                point-&gt;y / 64.0,</a>
<a name="ln252">                ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION ) ? 'w' : ' '));</a>
<a name="ln253">    AF_DUMP(( &quot;\n&quot; ));</a>
<a name="ln254">  }</a>
<a name="ln255">#ifdef __cplusplus</a>
<a name="ln256">  }</a>
<a name="ln257">#endif</a>
<a name="ln258"> </a>
<a name="ln259"> </a>
<a name="ln260">  static const char*</a>
<a name="ln261">  af_edge_flags_to_string( FT_UInt  flags )</a>
<a name="ln262">  {</a>
<a name="ln263">    static char  temp[32];</a>
<a name="ln264">    int          pos = 0;</a>
<a name="ln265"> </a>
<a name="ln266"> </a>
<a name="ln267">    if ( flags &amp; AF_EDGE_ROUND )</a>
<a name="ln268">    {</a>
<a name="ln269">      ft_memcpy( temp + pos, &quot;round&quot;, 5 );</a>
<a name="ln270">      pos += 5;</a>
<a name="ln271">    }</a>
<a name="ln272">    if ( flags &amp; AF_EDGE_SERIF )</a>
<a name="ln273">    {</a>
<a name="ln274">      if ( pos &gt; 0 )</a>
<a name="ln275">        temp[pos++] = ' ';</a>
<a name="ln276">      ft_memcpy( temp + pos, &quot;serif&quot;, 5 );</a>
<a name="ln277">      pos += 5;</a>
<a name="ln278">    }</a>
<a name="ln279">    if ( pos == 0 )</a>
<a name="ln280">      return &quot;normal&quot;;</a>
<a name="ln281"> </a>
<a name="ln282">    temp[pos] = '\0';</a>
<a name="ln283"> </a>
<a name="ln284">    return temp;</a>
<a name="ln285">  }</a>
<a name="ln286"> </a>
<a name="ln287"> </a>
<a name="ln288">  /* Dump the array of linked segments. */</a>
<a name="ln289"> </a>
<a name="ln290">#ifdef __cplusplus</a>
<a name="ln291">  extern &quot;C&quot; {</a>
<a name="ln292">#endif</a>
<a name="ln293">  void</a>
<a name="ln294">  af_glyph_hints_dump_segments( AF_GlyphHints  hints,</a>
<a name="ln295">                                FT_Bool        to_stdout )</a>
<a name="ln296">  {</a>
<a name="ln297">    FT_Int  dimension;</a>
<a name="ln298"> </a>
<a name="ln299"> </a>
<a name="ln300">    for ( dimension = 1; dimension &gt;= 0; dimension-- )</a>
<a name="ln301">    {</a>
<a name="ln302">      AF_AxisHints  axis     = &amp;hints-&gt;axis[dimension];</a>
<a name="ln303">      AF_Point      points   = hints-&gt;points;</a>
<a name="ln304">      AF_Edge       edges    = axis-&gt;edges;</a>
<a name="ln305">      AF_Segment    segments = axis-&gt;segments;</a>
<a name="ln306">      AF_Segment    limit    = segments + axis-&gt;num_segments;</a>
<a name="ln307">      AF_Segment    seg;</a>
<a name="ln308"> </a>
<a name="ln309"> </a>
<a name="ln310">      AF_DUMP(( &quot;Table of %s segments:\n&quot;,</a>
<a name="ln311">                dimension == AF_DIMENSION_HORZ ? &quot;vertical&quot;</a>
<a name="ln312">                                               : &quot;horizontal&quot; ));</a>
<a name="ln313">      if ( axis-&gt;num_segments )</a>
<a name="ln314">        AF_DUMP(( &quot;  [ index |  pos  |  dir  | from&quot;</a>
<a name="ln315">                  &quot; |  to  | link | serif | edge&quot;</a>
<a name="ln316">                  &quot; | height | extra |    flags    ]\n&quot; ));</a>
<a name="ln317">      else</a>
<a name="ln318">        AF_DUMP(( &quot;  (none)\n&quot; ));</a>
<a name="ln319"> </a>
<a name="ln320">      for ( seg = segments; seg &lt; limit; seg++ )</a>
<a name="ln321">        AF_DUMP(( &quot;  [ %5d | %5.2g | %5s | %4d&quot;</a>
<a name="ln322">                  &quot; | %4d | %4d | %5d | %4d&quot;</a>
<a name="ln323">                  &quot; | %6d | %5d | %11s ]\n&quot;,</a>
<a name="ln324">                  AF_INDEX_NUM( seg, segments ),</a>
<a name="ln325">                  dimension == AF_DIMENSION_HORZ</a>
<a name="ln326">                               ? (int)seg-&gt;first-&gt;ox / 64.0</a>
<a name="ln327">                               : (int)seg-&gt;first-&gt;oy / 64.0,</a>
<a name="ln328">                  af_dir_str( (AF_Direction)seg-&gt;dir ),</a>
<a name="ln329">                  AF_INDEX_NUM( seg-&gt;first, points ),</a>
<a name="ln330">                  AF_INDEX_NUM( seg-&gt;last, points ),</a>
<a name="ln331">                  AF_INDEX_NUM( seg-&gt;link, segments ),</a>
<a name="ln332">                  AF_INDEX_NUM( seg-&gt;serif, segments ),</a>
<a name="ln333">                  AF_INDEX_NUM( seg-&gt;edge, edges ),</a>
<a name="ln334">                  seg-&gt;height,</a>
<a name="ln335">                  seg-&gt;height - ( seg-&gt;max_coord - seg-&gt;min_coord ),</a>
<a name="ln336">                  af_edge_flags_to_string( seg-&gt;flags ) ));</a>
<a name="ln337">      AF_DUMP(( &quot;\n&quot; ));</a>
<a name="ln338">    }</a>
<a name="ln339">  }</a>
<a name="ln340">#ifdef __cplusplus</a>
<a name="ln341">  }</a>
<a name="ln342">#endif</a>
<a name="ln343"> </a>
<a name="ln344"> </a>
<a name="ln345">  /* Fetch number of segments. */</a>
<a name="ln346"> </a>
<a name="ln347">#ifdef __cplusplus</a>
<a name="ln348">  extern &quot;C&quot; {</a>
<a name="ln349">#endif</a>
<a name="ln350">  FT_Error</a>
<a name="ln351">  af_glyph_hints_get_num_segments( AF_GlyphHints  hints,</a>
<a name="ln352">                                   FT_Int         dimension,</a>
<a name="ln353">                                   FT_Int*        num_segments )</a>
<a name="ln354">  {</a>
<a name="ln355">    AF_Dimension  dim;</a>
<a name="ln356">    AF_AxisHints  axis;</a>
<a name="ln357"> </a>
<a name="ln358"> </a>
<a name="ln359">    dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;</a>
<a name="ln360"> </a>
<a name="ln361">    axis          = &amp;hints-&gt;axis[dim];</a>
<a name="ln362">    *num_segments = axis-&gt;num_segments;</a>
<a name="ln363"> </a>
<a name="ln364">    return FT_Err_Ok;</a>
<a name="ln365">  }</a>
<a name="ln366">#ifdef __cplusplus</a>
<a name="ln367">  }</a>
<a name="ln368">#endif</a>
<a name="ln369"> </a>
<a name="ln370"> </a>
<a name="ln371">  /* Fetch offset of segments into user supplied offset array. */</a>
<a name="ln372"> </a>
<a name="ln373">#ifdef __cplusplus</a>
<a name="ln374">  extern &quot;C&quot; {</a>
<a name="ln375">#endif</a>
<a name="ln376">  FT_Error</a>
<a name="ln377">  af_glyph_hints_get_segment_offset( AF_GlyphHints  hints,</a>
<a name="ln378">                                     FT_Int         dimension,</a>
<a name="ln379">                                     FT_Int         idx,</a>
<a name="ln380">                                     FT_Pos        *offset,</a>
<a name="ln381">                                     FT_Bool       *is_blue,</a>
<a name="ln382">                                     FT_Pos        *blue_offset )</a>
<a name="ln383">  {</a>
<a name="ln384">    AF_Dimension  dim;</a>
<a name="ln385">    AF_AxisHints  axis;</a>
<a name="ln386">    AF_Segment    seg;</a>
<a name="ln387"> </a>
<a name="ln388"> </a>
<a name="ln389">    if ( !offset )</a>
<a name="ln390">      return FT_THROW( Invalid_Argument );</a>
<a name="ln391"> </a>
<a name="ln392">    dim = ( dimension == 0 ) ? AF_DIMENSION_HORZ : AF_DIMENSION_VERT;</a>
<a name="ln393"> </a>
<a name="ln394">    axis = &amp;hints-&gt;axis[dim];</a>
<a name="ln395"> </a>
<a name="ln396">    if ( idx &lt; 0 || idx &gt;= axis-&gt;num_segments )</a>
<a name="ln397">      return FT_THROW( Invalid_Argument );</a>
<a name="ln398"> </a>
<a name="ln399">    seg      = &amp;axis-&gt;segments[idx];</a>
<a name="ln400">    *offset  = ( dim == AF_DIMENSION_HORZ ) ? seg-&gt;first-&gt;ox</a>
<a name="ln401">                                            : seg-&gt;first-&gt;oy;</a>
<a name="ln402">    if ( seg-&gt;edge )</a>
<a name="ln403">      *is_blue = (FT_Bool)( seg-&gt;edge-&gt;blue_edge != 0 );</a>
<a name="ln404">    else</a>
<a name="ln405">      *is_blue = FALSE;</a>
<a name="ln406"> </a>
<a name="ln407">    if ( *is_blue )</a>
<a name="ln408">      *blue_offset = seg-&gt;edge-&gt;blue_edge-&gt;cur;</a>
<a name="ln409">    else</a>
<a name="ln410">      *blue_offset = 0;</a>
<a name="ln411"> </a>
<a name="ln412">    return FT_Err_Ok;</a>
<a name="ln413">  }</a>
<a name="ln414">#ifdef __cplusplus</a>
<a name="ln415">  }</a>
<a name="ln416">#endif</a>
<a name="ln417"> </a>
<a name="ln418"> </a>
<a name="ln419">  /* Dump the array of linked edges. */</a>
<a name="ln420"> </a>
<a name="ln421">#ifdef __cplusplus</a>
<a name="ln422">  extern &quot;C&quot; {</a>
<a name="ln423">#endif</a>
<a name="ln424">  void</a>
<a name="ln425">  af_glyph_hints_dump_edges( AF_GlyphHints  hints,</a>
<a name="ln426">                             FT_Bool        to_stdout )</a>
<a name="ln427">  {</a>
<a name="ln428">    FT_Int  dimension;</a>
<a name="ln429"> </a>
<a name="ln430"> </a>
<a name="ln431">    for ( dimension = 1; dimension &gt;= 0; dimension-- )</a>
<a name="ln432">    {</a>
<a name="ln433">      AF_AxisHints  axis  = &amp;hints-&gt;axis[dimension];</a>
<a name="ln434">      AF_Edge       edges = axis-&gt;edges;</a>
<a name="ln435">      AF_Edge       limit = edges + axis-&gt;num_edges;</a>
<a name="ln436">      AF_Edge       edge;</a>
<a name="ln437"> </a>
<a name="ln438"> </a>
<a name="ln439">      /*</a>
<a name="ln440">       *  note: AF_DIMENSION_HORZ corresponds to _vertical_ edges</a>
<a name="ln441">       *        since they have a constant X coordinate.</a>
<a name="ln442">       */</a>
<a name="ln443">      AF_DUMP(( &quot;Table of %s edges:\n&quot;,</a>
<a name="ln444">                dimension == AF_DIMENSION_HORZ ? &quot;vertical&quot;</a>
<a name="ln445">                                               : &quot;horizontal&quot; ));</a>
<a name="ln446">      if ( axis-&gt;num_edges )</a>
<a name="ln447">        AF_DUMP(( &quot;  [ index |  pos  |  dir  | link&quot;</a>
<a name="ln448">                  &quot; | serif | blue | opos  |  pos  |    flags    ]\n&quot; ));</a>
<a name="ln449">      else</a>
<a name="ln450">        AF_DUMP(( &quot;  (none)\n&quot; ));</a>
<a name="ln451"> </a>
<a name="ln452">      for ( edge = edges; edge &lt; limit; edge++ )</a>
<a name="ln453">        AF_DUMP(( &quot;  [ %5d | %5.2g | %5s | %4d&quot;</a>
<a name="ln454">                  &quot; | %5d |   %c  | %5.2f | %5.2f | %11s ]\n&quot;,</a>
<a name="ln455">                  AF_INDEX_NUM( edge, edges ),</a>
<a name="ln456">                  (int)edge-&gt;opos / 64.0,</a>
<a name="ln457">                  af_dir_str( (AF_Direction)edge-&gt;dir ),</a>
<a name="ln458">                  AF_INDEX_NUM( edge-&gt;link, edges ),</a>
<a name="ln459">                  AF_INDEX_NUM( edge-&gt;serif, edges ),</a>
<a name="ln460">                  edge-&gt;blue_edge ? 'y' : 'n',</a>
<a name="ln461">                  edge-&gt;opos / 64.0,</a>
<a name="ln462">                  edge-&gt;pos / 64.0,</a>
<a name="ln463">                  af_edge_flags_to_string( edge-&gt;flags ) ));</a>
<a name="ln464">      AF_DUMP(( &quot;\n&quot; ));</a>
<a name="ln465">    }</a>
<a name="ln466">  }</a>
<a name="ln467">#ifdef __cplusplus</a>
<a name="ln468">  }</a>
<a name="ln469">#endif</a>
<a name="ln470"> </a>
<a name="ln471">#undef AF_DUMP</a>
<a name="ln472"> </a>
<a name="ln473">#endif /* !FT_DEBUG_AUTOFIT */</a>
<a name="ln474"> </a>
<a name="ln475"> </a>
<a name="ln476">  /* Compute the direction value of a given vector. */</a>
<a name="ln477"> </a>
<a name="ln478">  FT_LOCAL_DEF( AF_Direction )</a>
<a name="ln479">  af_direction_compute( FT_Pos  dx,</a>
<a name="ln480">                        FT_Pos  dy )</a>
<a name="ln481">  {</a>
<a name="ln482">    FT_Pos        ll, ss;  /* long and short arm lengths */</a>
<a name="ln483">    AF_Direction  dir;     /* candidate direction        */</a>
<a name="ln484"> </a>
<a name="ln485"> </a>
<a name="ln486">    if ( dy &gt;= dx )</a>
<a name="ln487">    {</a>
<a name="ln488">      if ( dy &gt;= -dx )</a>
<a name="ln489">      {</a>
<a name="ln490">        dir = AF_DIR_UP;</a>
<a name="ln491">        ll  = dy;</a>
<a name="ln492">        ss  = dx;</a>
<a name="ln493">      }</a>
<a name="ln494">      else</a>
<a name="ln495">      {</a>
<a name="ln496">        dir = AF_DIR_LEFT;</a>
<a name="ln497">        ll  = -dx;</a>
<a name="ln498">        ss  = dy;</a>
<a name="ln499">      }</a>
<a name="ln500">    }</a>
<a name="ln501">    else /* dy &lt; dx */</a>
<a name="ln502">    {</a>
<a name="ln503">      if ( dy &gt;= -dx )</a>
<a name="ln504">      {</a>
<a name="ln505">        dir = AF_DIR_RIGHT;</a>
<a name="ln506">        ll  = dx;</a>
<a name="ln507">        ss  = dy;</a>
<a name="ln508">      }</a>
<a name="ln509">      else</a>
<a name="ln510">      {</a>
<a name="ln511">        dir = AF_DIR_DOWN;</a>
<a name="ln512">        ll  = -dy;</a>
<a name="ln513">        ss  = dx;</a>
<a name="ln514">      }</a>
<a name="ln515">    }</a>
<a name="ln516"> </a>
<a name="ln517">    /* return no direction if arm lengths do not differ enough       */</a>
<a name="ln518">    /* (value 14 is heuristic, corresponding to approx. 4.1 degrees) */</a>
<a name="ln519">    /* the long arm is never negative                                */</a>
<a name="ln520">    if ( ll &lt;= 14 * FT_ABS( ss ) )</a>
<a name="ln521">      dir = AF_DIR_NONE;</a>
<a name="ln522"> </a>
<a name="ln523">    return dir;</a>
<a name="ln524">  }</a>
<a name="ln525"> </a>
<a name="ln526"> </a>
<a name="ln527">  FT_LOCAL_DEF( void )</a>
<a name="ln528">  af_glyph_hints_init( AF_GlyphHints  hints,</a>
<a name="ln529">                       FT_Memory      memory )</a>
<a name="ln530">  {</a>
<a name="ln531">    /* no need to initialize the embedded items */</a>
<a name="ln532">    FT_MEM_ZERO( hints, sizeof ( *hints ) - sizeof ( hints-&gt;embedded ) );</a>
<a name="ln533">    hints-&gt;memory = memory;</a>
<a name="ln534">  }</a>
<a name="ln535"> </a>
<a name="ln536"> </a>
<a name="ln537">  FT_LOCAL_DEF( void )</a>
<a name="ln538">  af_glyph_hints_done( AF_GlyphHints  hints )</a>
<a name="ln539">  {</a>
<a name="ln540">    FT_Memory  memory;</a>
<a name="ln541">    int        dim;</a>
<a name="ln542"> </a>
<a name="ln543"> </a>
<a name="ln544">    if ( !( hints &amp;&amp; hints-&gt;memory ) )</a>
<a name="ln545">      return;</a>
<a name="ln546"> </a>
<a name="ln547">    memory = hints-&gt;memory;</a>
<a name="ln548"> </a>
<a name="ln549">    /*</a>
<a name="ln550">     *  note that we don't need to free the segment and edge</a>
<a name="ln551">     *  buffers since they are really within the hints-&gt;points array</a>
<a name="ln552">     */</a>
<a name="ln553">    for ( dim = 0; dim &lt; AF_DIMENSION_MAX; dim++ )</a>
<a name="ln554">    {</a>
<a name="ln555">      AF_AxisHints  axis = &amp;hints-&gt;axis[dim];</a>
<a name="ln556"> </a>
<a name="ln557"> </a>
<a name="ln558">      axis-&gt;num_segments = 0;</a>
<a name="ln559">      axis-&gt;max_segments = 0;</a>
<a name="ln560">      if ( axis-&gt;segments != axis-&gt;embedded.segments )</a>
<a name="ln561">        FT_FREE( axis-&gt;segments );</a>
<a name="ln562"> </a>
<a name="ln563">      axis-&gt;num_edges = 0;</a>
<a name="ln564">      axis-&gt;max_edges = 0;</a>
<a name="ln565">      if ( axis-&gt;edges != axis-&gt;embedded.edges )</a>
<a name="ln566">        FT_FREE( axis-&gt;edges );</a>
<a name="ln567">    }</a>
<a name="ln568"> </a>
<a name="ln569">    if ( hints-&gt;contours != hints-&gt;embedded.contours )</a>
<a name="ln570">      FT_FREE( hints-&gt;contours );</a>
<a name="ln571">    hints-&gt;max_contours = 0;</a>
<a name="ln572">    hints-&gt;num_contours = 0;</a>
<a name="ln573"> </a>
<a name="ln574">    if ( hints-&gt;points != hints-&gt;embedded.points )</a>
<a name="ln575">      FT_FREE( hints-&gt;points );</a>
<a name="ln576">    hints-&gt;max_points = 0;</a>
<a name="ln577">    hints-&gt;num_points = 0;</a>
<a name="ln578"> </a>
<a name="ln579">    hints-&gt;memory = NULL;</a>
<a name="ln580">  }</a>
<a name="ln581"> </a>
<a name="ln582"> </a>
<a name="ln583">  /* Reset metrics. */</a>
<a name="ln584"> </a>
<a name="ln585">  FT_LOCAL_DEF( void )</a>
<a name="ln586">  af_glyph_hints_rescale( AF_GlyphHints    hints,</a>
<a name="ln587">                          AF_StyleMetrics  metrics )</a>
<a name="ln588">  {</a>
<a name="ln589">    hints-&gt;metrics      = metrics;</a>
<a name="ln590">    hints-&gt;scaler_flags = metrics-&gt;scaler.flags;</a>
<a name="ln591">  }</a>
<a name="ln592"> </a>
<a name="ln593"> </a>
<a name="ln594">  /* Recompute all AF_Point in AF_GlyphHints from the definitions */</a>
<a name="ln595">  /* in a source outline.                                         */</a>
<a name="ln596"> </a>
<a name="ln597">  FT_LOCAL_DEF( FT_Error )</a>
<a name="ln598">  af_glyph_hints_reload( AF_GlyphHints  hints,</a>
<a name="ln599">                         FT_Outline*    outline )</a>
<a name="ln600">  {</a>
<a name="ln601">    FT_Error   error   = FT_Err_Ok;</a>
<a name="ln602">    AF_Point   points;</a>
<a name="ln603">    FT_UInt    old_max, new_max;</a>
<a name="ln604">    FT_Fixed   x_scale = hints-&gt;x_scale;</a>
<a name="ln605">    FT_Fixed   y_scale = hints-&gt;y_scale;</a>
<a name="ln606">    FT_Pos     x_delta = hints-&gt;x_delta;</a>
<a name="ln607">    FT_Pos     y_delta = hints-&gt;y_delta;</a>
<a name="ln608">    FT_Memory  memory  = hints-&gt;memory;</a>
<a name="ln609"> </a>
<a name="ln610"> </a>
<a name="ln611">    hints-&gt;num_points   = 0;</a>
<a name="ln612">    hints-&gt;num_contours = 0;</a>
<a name="ln613"> </a>
<a name="ln614">    hints-&gt;axis[0].num_segments = 0;</a>
<a name="ln615">    hints-&gt;axis[0].num_edges    = 0;</a>
<a name="ln616">    hints-&gt;axis[1].num_segments = 0;</a>
<a name="ln617">    hints-&gt;axis[1].num_edges    = 0;</a>
<a name="ln618"> </a>
<a name="ln619">    /* first of all, reallocate the contours array if necessary */</a>
<a name="ln620">    new_max = (FT_UInt)outline-&gt;n_contours;</a>
<a name="ln621">    old_max = (FT_UInt)hints-&gt;max_contours;</a>
<a name="ln622"> </a>
<a name="ln623">    if ( new_max &lt;= AF_CONTOURS_EMBEDDED )</a>
<a name="ln624">    {</a>
<a name="ln625">      if ( hints-&gt;contours == NULL )</a>
<a name="ln626">      {</a>
<a name="ln627">        hints-&gt;contours     = hints-&gt;embedded.contours;</a>
<a name="ln628">        hints-&gt;max_contours = AF_CONTOURS_EMBEDDED;</a>
<a name="ln629">      }</a>
<a name="ln630">    }</a>
<a name="ln631">    else if ( new_max &gt; old_max )</a>
<a name="ln632">    {</a>
<a name="ln633">      if ( hints-&gt;contours == hints-&gt;embedded.contours )</a>
<a name="ln634">        hints-&gt;contours = NULL;</a>
<a name="ln635"> </a>
<a name="ln636">      new_max = ( new_max + 3 ) &amp; ~3U; /* round up to a multiple of 4 */</a>
<a name="ln637"> </a>
<a name="ln638">      if ( FT_RENEW_ARRAY( hints-&gt;contours, old_max, new_max ) )</a>
<a name="ln639">        goto Exit;</a>
<a name="ln640"> </a>
<a name="ln641">      hints-&gt;max_contours = (FT_Int)new_max;</a>
<a name="ln642">    }</a>
<a name="ln643"> </a>
<a name="ln644">    /*</a>
<a name="ln645">     *  then reallocate the points arrays if necessary --</a>
<a name="ln646">     *  note that we reserve two additional point positions, used to</a>
<a name="ln647">     *  hint metrics appropriately</a>
<a name="ln648">     */</a>
<a name="ln649">    new_max = (FT_UInt)( outline-&gt;n_points + 2 );</a>
<a name="ln650">    old_max = (FT_UInt)hints-&gt;max_points;</a>
<a name="ln651"> </a>
<a name="ln652">    if ( new_max &lt;= AF_POINTS_EMBEDDED )</a>
<a name="ln653">    {</a>
<a name="ln654">      if ( hints-&gt;points == NULL )</a>
<a name="ln655">      {</a>
<a name="ln656">        hints-&gt;points     = hints-&gt;embedded.points;</a>
<a name="ln657">        hints-&gt;max_points = AF_POINTS_EMBEDDED;</a>
<a name="ln658">      }</a>
<a name="ln659">    }</a>
<a name="ln660">    else if ( new_max &gt; old_max )</a>
<a name="ln661">    {</a>
<a name="ln662">      if ( hints-&gt;points == hints-&gt;embedded.points )</a>
<a name="ln663">        hints-&gt;points = NULL;</a>
<a name="ln664"> </a>
<a name="ln665">      new_max = ( new_max + 2 + 7 ) &amp; ~7U; /* round up to a multiple of 8 */</a>
<a name="ln666"> </a>
<a name="ln667">      if ( FT_RENEW_ARRAY( hints-&gt;points, old_max, new_max ) )</a>
<a name="ln668">        goto Exit;</a>
<a name="ln669"> </a>
<a name="ln670">      hints-&gt;max_points = (FT_Int)new_max;</a>
<a name="ln671">    }</a>
<a name="ln672"> </a>
<a name="ln673">    hints-&gt;num_points   = outline-&gt;n_points;</a>
<a name="ln674">    hints-&gt;num_contours = outline-&gt;n_contours;</a>
<a name="ln675"> </a>
<a name="ln676">    /* We can't rely on the value of `FT_Outline.flags' to know the fill   */</a>
<a name="ln677">    /* direction used for a glyph, given that some fonts are broken (e.g., */</a>
<a name="ln678">    /* the Arphic ones).  We thus recompute it each time we need to.       */</a>
<a name="ln679">    /*                                                                     */</a>
<a name="ln680">    hints-&gt;axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_UP;</a>
<a name="ln681">    hints-&gt;axis[AF_DIMENSION_VERT].major_dir = AF_DIR_LEFT;</a>
<a name="ln682"> </a>
<a name="ln683">    if ( FT_Outline_Get_Orientation( outline ) == FT_ORIENTATION_POSTSCRIPT )</a>
<a name="ln684">    {</a>
<a name="ln685">      hints-&gt;axis[AF_DIMENSION_HORZ].major_dir = AF_DIR_DOWN;</a>
<a name="ln686">      hints-&gt;axis[AF_DIMENSION_VERT].major_dir = AF_DIR_RIGHT;</a>
<a name="ln687">    }</a>
<a name="ln688"> </a>
<a name="ln689">    hints-&gt;x_scale = x_scale;</a>
<a name="ln690">    hints-&gt;y_scale = y_scale;</a>
<a name="ln691">    hints-&gt;x_delta = x_delta;</a>
<a name="ln692">    hints-&gt;y_delta = y_delta;</a>
<a name="ln693"> </a>
<a name="ln694">    hints-&gt;xmin_delta = 0;</a>
<a name="ln695">    hints-&gt;xmax_delta = 0;</a>
<a name="ln696"> </a>
<a name="ln697">    points = hints-&gt;points;</a>
<a name="ln698">    if ( hints-&gt;num_points == 0 )</a>
<a name="ln699">      goto Exit;</a>
<a name="ln700"> </a>
<a name="ln701">    {</a>
<a name="ln702">      AF_Point  point;</a>
<a name="ln703">      AF_Point  point_limit = points + hints-&gt;num_points;</a>
<a name="ln704"> </a>
<a name="ln705"> </a>
<a name="ln706">      /* compute coordinates &amp; Bezier flags, next and prev */</a>
<a name="ln707">      {</a>
<a name="ln708">        FT_Vector*  vec           = outline-&gt;points;</a>
<a name="ln709">        char*       tag           = outline-&gt;tags;</a>
<a name="ln710">        AF_Point    end           = points + outline-&gt;contours[0];</a>
<a name="ln711">        AF_Point    prev          = end;</a>
<a name="ln712">        FT_Int      contour_index = 0;</a>
<a name="ln713"> </a>
<a name="ln714"> </a>
<a name="ln715">        for ( point = points; point &lt; point_limit; point++, vec++, tag++ )</a>
<a name="ln716">        {</a>
<a name="ln717">          point-&gt;in_dir  = (FT_Char)AF_DIR_NONE;</a>
<a name="ln718">          point-&gt;out_dir = (FT_Char)AF_DIR_NONE;</a>
<a name="ln719"> </a>
<a name="ln720">          point-&gt;fx = (FT_Short)vec-&gt;x;</a>
<a name="ln721">          point-&gt;fy = (FT_Short)vec-&gt;y;</a>
<a name="ln722">          point-&gt;ox = point-&gt;x = FT_MulFix( vec-&gt;x, x_scale ) + x_delta;</a>
<a name="ln723">          point-&gt;oy = point-&gt;y = FT_MulFix( vec-&gt;y, y_scale ) + y_delta;</a>
<a name="ln724"> </a>
<a name="ln725">          switch ( FT_CURVE_TAG( *tag ) )</a>
<a name="ln726">          {</a>
<a name="ln727">          case FT_CURVE_TAG_CONIC:</a>
<a name="ln728">            point-&gt;flags = AF_FLAG_CONIC;</a>
<a name="ln729">            break;</a>
<a name="ln730">          case FT_CURVE_TAG_CUBIC:</a>
<a name="ln731">            point-&gt;flags = AF_FLAG_CUBIC;</a>
<a name="ln732">            break;</a>
<a name="ln733">          default:</a>
<a name="ln734">            point-&gt;flags = AF_FLAG_NONE;</a>
<a name="ln735">          }</a>
<a name="ln736"> </a>
<a name="ln737">          point-&gt;prev = prev;</a>
<a name="ln738">          prev-&gt;next  = point;</a>
<a name="ln739">          prev        = point;</a>
<a name="ln740"> </a>
<a name="ln741">          if ( point == end )</a>
<a name="ln742">          {</a>
<a name="ln743">            if ( ++contour_index &lt; outline-&gt;n_contours )</a>
<a name="ln744">            {</a>
<a name="ln745">              end  = points + outline-&gt;contours[contour_index];</a>
<a name="ln746">              prev = end;</a>
<a name="ln747">            }</a>
<a name="ln748">          }</a>
<a name="ln749">        }</a>
<a name="ln750">      }</a>
<a name="ln751"> </a>
<a name="ln752">      /* set up the contours array */</a>
<a name="ln753">      {</a>
<a name="ln754">        AF_Point*  contour       = hints-&gt;contours;</a>
<a name="ln755">        AF_Point*  contour_limit = contour + hints-&gt;num_contours;</a>
<a name="ln756">        short*     end           = outline-&gt;contours;</a>
<a name="ln757">        short      idx           = 0;</a>
<a name="ln758"> </a>
<a name="ln759"> </a>
<a name="ln760">        for ( ; contour &lt; contour_limit; contour++, end++ )</a>
<a name="ln761">        {</a>
<a name="ln762">          contour[0] = points + idx;</a>
<a name="ln763">          idx        = (short)( end[0] + 1 );</a>
<a name="ln764">        }</a>
<a name="ln765">      }</a>
<a name="ln766"> </a>
<a name="ln767">      {</a>
<a name="ln768">        /*</a>
<a name="ln769">         *  Compute directions of `in' and `out' vectors.</a>
<a name="ln770">         *</a>
<a name="ln771">         *  Note that distances between points that are very near to each</a>
<a name="ln772">         *  other are accumulated.  In other words, the auto-hinter</a>
<a name="ln773">         *  prepends the small vectors between near points to the first</a>
<a name="ln774">         *  non-near vector.  All intermediate points are tagged as</a>
<a name="ln775">         *  weak; the directions are adjusted also to be equal to the</a>
<a name="ln776">         *  accumulated one.</a>
<a name="ln777">         */</a>
<a name="ln778"> </a>
<a name="ln779">        /* value 20 in `near_limit' is heuristic */</a>
<a name="ln780">        FT_UInt  units_per_em = hints-&gt;metrics-&gt;scaler.face-&gt;units_per_EM;</a>
<a name="ln781">        FT_Int   near_limit   = 20 * units_per_em / 2048;</a>
<a name="ln782">        FT_Int   near_limit2  = 2 * near_limit - 1;</a>
<a name="ln783"> </a>
<a name="ln784">        AF_Point*  contour;</a>
<a name="ln785">        AF_Point*  contour_limit = hints-&gt;contours + hints-&gt;num_contours;</a>
<a name="ln786"> </a>
<a name="ln787"> </a>
<a name="ln788">        for ( contour = hints-&gt;contours; contour &lt; contour_limit; contour++ )</a>
<a name="ln789">        {</a>
<a name="ln790">          AF_Point  first = *contour;</a>
<a name="ln791">          AF_Point  next, prev, curr;</a>
<a name="ln792"> </a>
<a name="ln793">          FT_Pos  out_x, out_y;</a>
<a name="ln794"> </a>
<a name="ln795"> </a>
<a name="ln796">          /* since the first point of a contour could be part of a */</a>
<a name="ln797">          /* series of near points, go backwards to find the first */</a>
<a name="ln798">          /* non-near point and adjust `first'                     */</a>
<a name="ln799"> </a>
<a name="ln800">          point = first;</a>
<a name="ln801">          prev  = first-&gt;prev;</a>
<a name="ln802"> </a>
<a name="ln803">          while ( prev != first )</a>
<a name="ln804">          {</a>
<a name="ln805">            out_x = point-&gt;fx - prev-&gt;fx;</a>
<a name="ln806">            out_y = point-&gt;fy - prev-&gt;fy;</a>
<a name="ln807"> </a>
<a name="ln808">            /*</a>
<a name="ln809">             *  We use Taxicab metrics to measure the vector length.</a>
<a name="ln810">             *</a>
<a name="ln811">             *  Note that the accumulated distances so far could have the</a>
<a name="ln812">             *  opposite direction of the distance measured here.  For this</a>
<a name="ln813">             *  reason we use `near_limit2' for the comparison to get a</a>
<a name="ln814">             *  non-near point even in the worst case.</a>
<a name="ln815">             */</a>
<a name="ln816">            if ( FT_ABS( out_x ) + FT_ABS( out_y ) &gt;= near_limit2 )</a>
<a name="ln817">              break;</a>
<a name="ln818"> </a>
<a name="ln819">            point = prev;</a>
<a name="ln820">            prev  = prev-&gt;prev;</a>
<a name="ln821">          }</a>
<a name="ln822"> </a>
<a name="ln823">          /* adjust first point */</a>
<a name="ln824">          first = point;</a>
<a name="ln825"> </a>
<a name="ln826">          /* now loop over all points of the contour to get */</a>
<a name="ln827">          /* `in' and `out' vector directions               */</a>
<a name="ln828"> </a>
<a name="ln829">          curr  = first;</a>
<a name="ln830"> </a>
<a name="ln831">          /*</a>
<a name="ln832">           *  We abuse the `u' and `v' fields to store index deltas to the</a>
<a name="ln833">           *  next and previous non-near point, respectively.</a>
<a name="ln834">           *</a>
<a name="ln835">           *  To avoid problems with not having non-near points, we point to</a>
<a name="ln836">           *  `first' by default as the next non-near point.</a>
<a name="ln837">           *</a>
<a name="ln838">           */</a>
<a name="ln839">          curr-&gt;u  = (FT_Pos)( first - curr );</a>
<a name="ln840">          first-&gt;v = -curr-&gt;u;</a>
<a name="ln841"> </a>
<a name="ln842">          out_x = 0;</a>
<a name="ln843">          out_y = 0;</a>
<a name="ln844"> </a>
<a name="ln845">          next = first;</a>
<a name="ln846">          do</a>
<a name="ln847">          {</a>
<a name="ln848">            AF_Direction  out_dir;</a>
<a name="ln849"> </a>
<a name="ln850"> </a>
<a name="ln851">            point = next;</a>
<a name="ln852">            next = point-&gt;next;</a>
<a name="ln853"> </a>
<a name="ln854">            out_x += next-&gt;fx - point-&gt;fx;</a>
<a name="ln855">            out_y += next-&gt;fy - point-&gt;fy;</a>
<a name="ln856"> </a>
<a name="ln857">            if ( FT_ABS( out_x ) + FT_ABS( out_y ) &lt; near_limit )</a>
<a name="ln858">            {</a>
<a name="ln859">              next-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;</a>
<a name="ln860">              continue;</a>
<a name="ln861">            }</a>
<a name="ln862"> </a>
<a name="ln863">            curr-&gt;u = (FT_Pos)( next - curr );</a>
<a name="ln864">            next-&gt;v = -curr-&gt;u;</a>
<a name="ln865"> </a>
<a name="ln866">            out_dir = af_direction_compute( out_x, out_y );</a>
<a name="ln867"> </a>
<a name="ln868">            /* adjust directions for all points inbetween; */</a>
<a name="ln869">            /* the loop also updates position of `curr'    */</a>
<a name="ln870">            curr-&gt;out_dir = (FT_Char)out_dir;</a>
<a name="ln871">            for ( curr = curr-&gt;next; curr != next; curr = curr-&gt;next )</a>
<a name="ln872">            {</a>
<a name="ln873">              curr-&gt;in_dir  = (FT_Char)out_dir;</a>
<a name="ln874">              curr-&gt;out_dir = (FT_Char)out_dir;</a>
<a name="ln875">            }</a>
<a name="ln876">            next-&gt;in_dir = (FT_Char)out_dir;</a>
<a name="ln877"> </a>
<a name="ln878">            curr-&gt;u  = (FT_Pos)( first - curr );</a>
<a name="ln879">            first-&gt;v = -curr-&gt;u;</a>
<a name="ln880"> </a>
<a name="ln881">            out_x = 0;</a>
<a name="ln882">            out_y = 0;</a>
<a name="ln883"> </a>
<a name="ln884">          } while ( next != first );</a>
<a name="ln885">        }</a>
<a name="ln886"> </a>
<a name="ln887">        /*</a>
<a name="ln888">         *  The next step is to `simplify' an outline's topology so that we</a>
<a name="ln889">         *  can identify local extrema more reliably: A series of</a>
<a name="ln890">         *  non-horizontal or non-vertical vectors pointing into the same</a>
<a name="ln891">         *  quadrant are handled as a single, long vector.  From a</a>
<a name="ln892">         *  topological point of the view, the intermediate points are of no</a>
<a name="ln893">         *  interest and thus tagged as weak.</a>
<a name="ln894">         */</a>
<a name="ln895"> </a>
<a name="ln896">        for ( point = points; point &lt; point_limit; point++ )</a>
<a name="ln897">        {</a>
<a name="ln898">          if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )</a>
<a name="ln899">            continue;</a>
<a name="ln900"> </a>
<a name="ln901">          if ( point-&gt;in_dir  == AF_DIR_NONE &amp;&amp;</a>
<a name="ln902">               point-&gt;out_dir == AF_DIR_NONE )</a>
<a name="ln903">          {</a>
<a name="ln904">            /* check whether both vectors point into the same quadrant */</a>
<a name="ln905"> </a>
<a name="ln906">            FT_Pos  in_x, in_y;</a>
<a name="ln907">            FT_Pos  out_x, out_y;</a>
<a name="ln908"> </a>
<a name="ln909">            AF_Point  next_u = point + point-&gt;u;</a>
<a name="ln910">            AF_Point  prev_v = point + point-&gt;v;</a>
<a name="ln911"> </a>
<a name="ln912"> </a>
<a name="ln913">            in_x = point-&gt;fx - prev_v-&gt;fx;</a>
<a name="ln914">            in_y = point-&gt;fy - prev_v-&gt;fy;</a>
<a name="ln915"> </a>
<a name="ln916">            out_x = next_u-&gt;fx - point-&gt;fx;</a>
<a name="ln917">            out_y = next_u-&gt;fy - point-&gt;fy;</a>
<a name="ln918"> </a>
<a name="ln919">            if ( ( in_x ^ out_x ) &gt;= 0 &amp;&amp; ( in_y ^ out_y ) &gt;= 0 )</a>
<a name="ln920">            {</a>
<a name="ln921">              /* yes, so tag current point as weak */</a>
<a name="ln922">              /* and update index deltas           */</a>
<a name="ln923"> </a>
<a name="ln924">              point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;</a>
<a name="ln925"> </a>
<a name="ln926">              prev_v-&gt;u = (FT_Pos)( next_u - prev_v );</a>
<a name="ln927">              next_u-&gt;v = -prev_v-&gt;u;</a>
<a name="ln928">            }</a>
<a name="ln929">          }</a>
<a name="ln930">        }</a>
<a name="ln931"> </a>
<a name="ln932">        /*</a>
<a name="ln933">         *  Finally, check for remaining weak points.  Everything else not</a>
<a name="ln934">         *  collected in edges so far is then implicitly classified as strong</a>
<a name="ln935">         *  points.</a>
<a name="ln936">         */</a>
<a name="ln937"> </a>
<a name="ln938">        for ( point = points; point &lt; point_limit; point++ )</a>
<a name="ln939">        {</a>
<a name="ln940">          if ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION )</a>
<a name="ln941">            continue;</a>
<a name="ln942"> </a>
<a name="ln943">          if ( point-&gt;flags &amp; AF_FLAG_CONTROL )</a>
<a name="ln944">          {</a>
<a name="ln945">            /* control points are always weak */</a>
<a name="ln946">          Is_Weak_Point:</a>
<a name="ln947">            point-&gt;flags |= AF_FLAG_WEAK_INTERPOLATION;</a>
<a name="ln948">          }</a>
<a name="ln949">          else if ( point-&gt;out_dir == point-&gt;in_dir )</a>
<a name="ln950">          {</a>
<a name="ln951">            if ( point-&gt;out_dir != AF_DIR_NONE )</a>
<a name="ln952">            {</a>
<a name="ln953">              /* current point lies on a horizontal or          */</a>
<a name="ln954">              /* vertical segment (but doesn't start or end it) */</a>
<a name="ln955">              goto Is_Weak_Point;</a>
<a name="ln956">            }</a>
<a name="ln957"> </a>
<a name="ln958">            {</a>
<a name="ln959">              AF_Point  next_u = point + point-&gt;u;</a>
<a name="ln960">              AF_Point  prev_v = point + point-&gt;v;</a>
<a name="ln961"> </a>
<a name="ln962"> </a>
<a name="ln963">              if ( ft_corner_is_flat( point-&gt;fx  - prev_v-&gt;fx,</a>
<a name="ln964">                                      point-&gt;fy  - prev_v-&gt;fy,</a>
<a name="ln965">                                      next_u-&gt;fx - point-&gt;fx,</a>
<a name="ln966">                                      next_u-&gt;fy - point-&gt;fy ) )</a>
<a name="ln967">              {</a>
<a name="ln968">                /* either the `in' or the `out' vector is much more  */</a>
<a name="ln969">                /* dominant than the other one, so tag current point */</a>
<a name="ln970">                /* as weak and update index deltas                   */</a>
<a name="ln971"> </a>
<a name="ln972">                prev_v-&gt;u = (FT_Pos)( next_u - prev_v );</a>
<a name="ln973">                next_u-&gt;v = -prev_v-&gt;u;</a>
<a name="ln974"> </a>
<a name="ln975">                goto Is_Weak_Point;</a>
<a name="ln976">              }</a>
<a name="ln977">            }</a>
<a name="ln978">          }</a>
<a name="ln979">          else if ( point-&gt;in_dir == -point-&gt;out_dir )</a>
<a name="ln980">          {</a>
<a name="ln981">            /* current point forms a spike */</a>
<a name="ln982">            goto Is_Weak_Point;</a>
<a name="ln983">          }</a>
<a name="ln984">        }</a>
<a name="ln985">      }</a>
<a name="ln986">    }</a>
<a name="ln987"> </a>
<a name="ln988">  Exit:</a>
<a name="ln989">    return error;</a>
<a name="ln990">  }</a>
<a name="ln991"> </a>
<a name="ln992"> </a>
<a name="ln993">  /* Store the hinted outline in an FT_Outline structure. */</a>
<a name="ln994"> </a>
<a name="ln995">  FT_LOCAL_DEF( void )</a>
<a name="ln996">  af_glyph_hints_save( AF_GlyphHints  hints,</a>
<a name="ln997">                       FT_Outline*    outline )</a>
<a name="ln998">  {</a>
<a name="ln999">    AF_Point    point = hints-&gt;points;</a>
<a name="ln1000">    AF_Point    limit = point + hints-&gt;num_points;</a>
<a name="ln1001">    FT_Vector*  vec   = outline-&gt;points;</a>
<a name="ln1002">    char*       tag   = outline-&gt;tags;</a>
<a name="ln1003"> </a>
<a name="ln1004"> </a>
<a name="ln1005">    for ( ; point &lt; limit; point++, vec++, tag++ )</a>
<a name="ln1006">    {</a>
<a name="ln1007">      vec-&gt;x = point-&gt;x;</a>
<a name="ln1008">      vec-&gt;y = point-&gt;y;</a>
<a name="ln1009"> </a>
<a name="ln1010">      if ( point-&gt;flags &amp; AF_FLAG_CONIC )</a>
<a name="ln1011">        tag[0] = FT_CURVE_TAG_CONIC;</a>
<a name="ln1012">      else if ( point-&gt;flags &amp; AF_FLAG_CUBIC )</a>
<a name="ln1013">        tag[0] = FT_CURVE_TAG_CUBIC;</a>
<a name="ln1014">      else</a>
<a name="ln1015">        tag[0] = FT_CURVE_TAG_ON;</a>
<a name="ln1016">    }</a>
<a name="ln1017">  }</a>
<a name="ln1018"> </a>
<a name="ln1019"> </a>
<a name="ln1020">  /****************************************************************</a>
<a name="ln1021">   *</a>
<a name="ln1022">   *                     EDGE POINT GRID-FITTING</a>
<a name="ln1023">   *</a>
<a name="ln1024">   ****************************************************************/</a>
<a name="ln1025"> </a>
<a name="ln1026"> </a>
<a name="ln1027">  /* Align all points of an edge to the same coordinate value, */</a>
<a name="ln1028">  /* either horizontally or vertically.                        */</a>
<a name="ln1029"> </a>
<a name="ln1030">  FT_LOCAL_DEF( void )</a>
<a name="ln1031">  af_glyph_hints_align_edge_points( AF_GlyphHints  hints,</a>
<a name="ln1032">                                    AF_Dimension   dim )</a>
<a name="ln1033">  {</a>
<a name="ln1034">    AF_AxisHints  axis          = &amp; hints-&gt;axis[dim];</a>
<a name="ln1035">    AF_Segment    segments      = axis-&gt;segments;</a>
<a name="ln1036">    AF_Segment    segment_limit = segments + axis-&gt;num_segments;</a>
<a name="ln1037">    AF_Segment    seg;</a>
<a name="ln1038"> </a>
<a name="ln1039"> </a>
<a name="ln1040">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln1041">    {</a>
<a name="ln1042">      for ( seg = segments; seg &lt; segment_limit; seg++ )</a>
<a name="ln1043">      {</a>
<a name="ln1044">        AF_Edge   edge = seg-&gt;edge;</a>
<a name="ln1045">        AF_Point  point, first, last;</a>
<a name="ln1046"> </a>
<a name="ln1047"> </a>
<a name="ln1048">        if ( edge == NULL )</a>
<a name="ln1049">          continue;</a>
<a name="ln1050"> </a>
<a name="ln1051">        first = seg-&gt;first;</a>
<a name="ln1052">        last  = seg-&gt;last;</a>
<a name="ln1053">        point = first;</a>
<a name="ln1054">        for (;;)</a>
<a name="ln1055">        {</a>
<a name="ln1056">          point-&gt;x      = edge-&gt;pos;</a>
<a name="ln1057">          point-&gt;flags |= AF_FLAG_TOUCH_X;</a>
<a name="ln1058"> </a>
<a name="ln1059">          if ( point == last )</a>
<a name="ln1060">            break;</a>
<a name="ln1061"> </a>
<a name="ln1062">          point = point-&gt;next;</a>
<a name="ln1063">        }</a>
<a name="ln1064">      }</a>
<a name="ln1065">    }</a>
<a name="ln1066">    else</a>
<a name="ln1067">    {</a>
<a name="ln1068">      for ( seg = segments; seg &lt; segment_limit; seg++ )</a>
<a name="ln1069">      {</a>
<a name="ln1070">        AF_Edge   edge = seg-&gt;edge;</a>
<a name="ln1071">        AF_Point  point, first, last;</a>
<a name="ln1072"> </a>
<a name="ln1073"> </a>
<a name="ln1074">        if ( edge == NULL )</a>
<a name="ln1075">          continue;</a>
<a name="ln1076"> </a>
<a name="ln1077">        first = seg-&gt;first;</a>
<a name="ln1078">        last  = seg-&gt;last;</a>
<a name="ln1079">        point = first;</a>
<a name="ln1080">        for (;;)</a>
<a name="ln1081">        {</a>
<a name="ln1082">          point-&gt;y      = edge-&gt;pos;</a>
<a name="ln1083">          point-&gt;flags |= AF_FLAG_TOUCH_Y;</a>
<a name="ln1084"> </a>
<a name="ln1085">          if ( point == last )</a>
<a name="ln1086">            break;</a>
<a name="ln1087"> </a>
<a name="ln1088">          point = point-&gt;next;</a>
<a name="ln1089">        }</a>
<a name="ln1090">      }</a>
<a name="ln1091">    }</a>
<a name="ln1092">  }</a>
<a name="ln1093"> </a>
<a name="ln1094"> </a>
<a name="ln1095">  /****************************************************************</a>
<a name="ln1096">   *</a>
<a name="ln1097">   *                    STRONG POINT INTERPOLATION</a>
<a name="ln1098">   *</a>
<a name="ln1099">   ****************************************************************/</a>
<a name="ln1100"> </a>
<a name="ln1101"> </a>
<a name="ln1102">  /* Hint the strong points -- this is equivalent to the TrueType `IP' */</a>
<a name="ln1103">  /* hinting instruction.                                              */</a>
<a name="ln1104"> </a>
<a name="ln1105">  FT_LOCAL_DEF( void )</a>
<a name="ln1106">  af_glyph_hints_align_strong_points( AF_GlyphHints  hints,</a>
<a name="ln1107">                                      AF_Dimension   dim )</a>
<a name="ln1108">  {</a>
<a name="ln1109">    AF_Point      points      = hints-&gt;points;</a>
<a name="ln1110">    AF_Point      point_limit = points + hints-&gt;num_points;</a>
<a name="ln1111">    AF_AxisHints  axis        = &amp;hints-&gt;axis[dim];</a>
<a name="ln1112">    AF_Edge       edges       = axis-&gt;edges;</a>
<a name="ln1113">    AF_Edge       edge_limit  = edges + axis-&gt;num_edges;</a>
<a name="ln1114">    FT_UInt       touch_flag;</a>
<a name="ln1115"> </a>
<a name="ln1116"> </a>
<a name="ln1117">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln1118">      touch_flag = AF_FLAG_TOUCH_X;</a>
<a name="ln1119">    else</a>
<a name="ln1120">      touch_flag  = AF_FLAG_TOUCH_Y;</a>
<a name="ln1121"> </a>
<a name="ln1122">    if ( edges &lt; edge_limit )</a>
<a name="ln1123">    {</a>
<a name="ln1124">      AF_Point  point;</a>
<a name="ln1125">      AF_Edge   edge;</a>
<a name="ln1126"> </a>
<a name="ln1127"> </a>
<a name="ln1128">      for ( point = points; point &lt; point_limit; point++ )</a>
<a name="ln1129">      {</a>
<a name="ln1130">        FT_Pos  u, ou, fu;  /* point position */</a>
<a name="ln1131">        FT_Pos  delta;</a>
<a name="ln1132"> </a>
<a name="ln1133"> </a>
<a name="ln1134">        if ( point-&gt;flags &amp; touch_flag )</a>
<a name="ln1135">          continue;</a>
<a name="ln1136"> </a>
<a name="ln1137">        /* if this point is candidate to weak interpolation, we       */</a>
<a name="ln1138">        /* interpolate it after all strong points have been processed */</a>
<a name="ln1139"> </a>
<a name="ln1140">        if ( ( point-&gt;flags &amp; AF_FLAG_WEAK_INTERPOLATION ) )</a>
<a name="ln1141">          continue;</a>
<a name="ln1142"> </a>
<a name="ln1143">        if ( dim == AF_DIMENSION_VERT )</a>
<a name="ln1144">        {</a>
<a name="ln1145">          u  = point-&gt;fy;</a>
<a name="ln1146">          ou = point-&gt;oy;</a>
<a name="ln1147">        }</a>
<a name="ln1148">        else</a>
<a name="ln1149">        {</a>
<a name="ln1150">          u  = point-&gt;fx;</a>
<a name="ln1151">          ou = point-&gt;ox;</a>
<a name="ln1152">        }</a>
<a name="ln1153"> </a>
<a name="ln1154">        fu = u;</a>
<a name="ln1155"> </a>
<a name="ln1156">        /* is the point before the first edge? */</a>
<a name="ln1157">        edge  = edges;</a>
<a name="ln1158">        delta = edge-&gt;fpos - u;</a>
<a name="ln1159">        if ( delta &gt;= 0 )</a>
<a name="ln1160">        {</a>
<a name="ln1161">          u = edge-&gt;pos - ( edge-&gt;opos - ou );</a>
<a name="ln1162">          goto Store_Point;</a>
<a name="ln1163">        }</a>
<a name="ln1164"> </a>
<a name="ln1165">        /* is the point after the last edge? */</a>
<a name="ln1166">        edge  = edge_limit - 1;</a>
<a name="ln1167">        delta = u - edge-&gt;fpos;</a>
<a name="ln1168">        if ( delta &gt;= 0 )</a>
<a name="ln1169">        {</a>
<a name="ln1170">          u = edge-&gt;pos + ( ou - edge-&gt;opos );</a>
<a name="ln1171">          goto Store_Point;</a>
<a name="ln1172">        }</a>
<a name="ln1173"> </a>
<a name="ln1174">        {</a>
<a name="ln1175">          FT_PtrDist  min, max, mid;</a>
<a name="ln1176">          FT_Pos      fpos;</a>
<a name="ln1177"> </a>
<a name="ln1178"> </a>
<a name="ln1179">          /* find enclosing edges */</a>
<a name="ln1180">          min = 0;</a>
<a name="ln1181">          max = edge_limit - edges;</a>
<a name="ln1182"> </a>
<a name="ln1183">#if 1</a>
<a name="ln1184">          /* for a small number of edges, a linear search is better */</a>
<a name="ln1185">          if ( max &lt;= 8 )</a>
<a name="ln1186">          {</a>
<a name="ln1187">            FT_PtrDist  nn;</a>
<a name="ln1188"> </a>
<a name="ln1189"> </a>
<a name="ln1190">            for ( nn = 0; nn &lt; max; nn++ )</a>
<a name="ln1191">              if ( edges[nn].fpos &gt;= u )</a>
<a name="ln1192">                break;</a>
<a name="ln1193"> </a>
<a name="ln1194">            if ( edges[nn].fpos == u )</a>
<a name="ln1195">            {</a>
<a name="ln1196">              u = edges[nn].pos;</a>
<a name="ln1197">              goto Store_Point;</a>
<a name="ln1198">            }</a>
<a name="ln1199">            min = nn;</a>
<a name="ln1200">          }</a>
<a name="ln1201">          else</a>
<a name="ln1202">#endif</a>
<a name="ln1203">          while ( min &lt; max )</a>
<a name="ln1204">          {</a>
<a name="ln1205">            mid  = ( max + min ) &gt;&gt; 1;</a>
<a name="ln1206">            edge = edges + mid;</a>
<a name="ln1207">            fpos = edge-&gt;fpos;</a>
<a name="ln1208"> </a>
<a name="ln1209">            if ( u &lt; fpos )</a>
<a name="ln1210">              max = mid;</a>
<a name="ln1211">            else if ( u &gt; fpos )</a>
<a name="ln1212">              min = mid + 1;</a>
<a name="ln1213">            else</a>
<a name="ln1214">            {</a>
<a name="ln1215">              /* we are on the edge */</a>
<a name="ln1216">              u = edge-&gt;pos;</a>
<a name="ln1217">              goto Store_Point;</a>
<a name="ln1218">            }</a>
<a name="ln1219">          }</a>
<a name="ln1220"> </a>
<a name="ln1221">          /* point is not on an edge */</a>
<a name="ln1222">          {</a>
<a name="ln1223">            AF_Edge  before = edges + min - 1;</a>
<a name="ln1224">            AF_Edge  after  = edges + min + 0;</a>
<a name="ln1225"> </a>
<a name="ln1226"> </a>
<a name="ln1227">            /* assert( before &amp;&amp; after &amp;&amp; before != after ) */</a>
<a name="ln1228">            if ( before-&gt;scale == 0 )</a>
<a name="ln1229">              before-&gt;scale = FT_DivFix( after-&gt;pos - before-&gt;pos,</a>
<a name="ln1230">                                         after-&gt;fpos - before-&gt;fpos );</a>
<a name="ln1231"> </a>
<a name="ln1232">            u = before-&gt;pos + FT_MulFix( fu - before-&gt;fpos,</a>
<a name="ln1233">                                         before-&gt;scale );</a>
<a name="ln1234">          }</a>
<a name="ln1235">        }</a>
<a name="ln1236"> </a>
<a name="ln1237">      Store_Point:</a>
<a name="ln1238">        /* save the point position */</a>
<a name="ln1239">        if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln1240">          point-&gt;x = u;</a>
<a name="ln1241">        else</a>
<a name="ln1242">          point-&gt;y = u;</a>
<a name="ln1243"> </a>
<a name="ln1244">        point-&gt;flags |= touch_flag;</a>
<a name="ln1245">      }</a>
<a name="ln1246">    }</a>
<a name="ln1247">  }</a>
<a name="ln1248"> </a>
<a name="ln1249"> </a>
<a name="ln1250">  /****************************************************************</a>
<a name="ln1251">   *</a>
<a name="ln1252">   *                    WEAK POINT INTERPOLATION</a>
<a name="ln1253">   *</a>
<a name="ln1254">   ****************************************************************/</a>
<a name="ln1255"> </a>
<a name="ln1256"> </a>
<a name="ln1257">  /* Shift the original coordinates of all points between `p1' and */</a>
<a name="ln1258">  /* `p2' to get hinted coordinates, using the same difference as  */</a>
<a name="ln1259">  /* given by `ref'.                                               */</a>
<a name="ln1260"> </a>
<a name="ln1261">  static void</a>
<a name="ln1262">  af_iup_shift( AF_Point  p1,</a>
<a name="ln1263">                AF_Point  p2,</a>
<a name="ln1264">                AF_Point  ref )</a>
<a name="ln1265">  {</a>
<a name="ln1266">    AF_Point  p;</a>
<a name="ln1267">    FT_Pos    delta = ref-&gt;u - ref-&gt;v;</a>
<a name="ln1268"> </a>
<a name="ln1269"> </a>
<a name="ln1270">    if ( delta == 0 )</a>
<a name="ln1271">      return;</a>
<a name="ln1272"> </a>
<a name="ln1273">    for ( p = p1; p &lt; ref; p++ )</a>
<a name="ln1274">      p-&gt;u = p-&gt;v + delta;</a>
<a name="ln1275"> </a>
<a name="ln1276">    for ( p = ref + 1; p &lt;= p2; p++ )</a>
<a name="ln1277">      p-&gt;u = p-&gt;v + delta;</a>
<a name="ln1278">  }</a>
<a name="ln1279"> </a>
<a name="ln1280"> </a>
<a name="ln1281">  /* Interpolate the original coordinates of all points between `p1' and  */</a>
<a name="ln1282">  /* `p2' to get hinted coordinates, using `ref1' and `ref2' as the       */</a>
<a name="ln1283">  /* reference points.  The `u' and `v' members are the current and       */</a>
<a name="ln1284">  /* original coordinate values, respectively.                            */</a>
<a name="ln1285">  /*                                                                      */</a>
<a name="ln1286">  /* Details can be found in the TrueType bytecode specification.         */</a>
<a name="ln1287"> </a>
<a name="ln1288">  static void</a>
<a name="ln1289">  af_iup_interp( AF_Point  p1,</a>
<a name="ln1290">                 AF_Point  p2,</a>
<a name="ln1291">                 AF_Point  ref1,</a>
<a name="ln1292">                 AF_Point  ref2 )</a>
<a name="ln1293">  {</a>
<a name="ln1294">    AF_Point  p;</a>
<a name="ln1295">    FT_Pos    u, v1, v2, u1, u2, d1, d2;</a>
<a name="ln1296"> </a>
<a name="ln1297"> </a>
<a name="ln1298">    if ( p1 &gt; p2 )</a>
<a name="ln1299">      return;</a>
<a name="ln1300"> </a>
<a name="ln1301">    if ( ref1-&gt;v &gt; ref2-&gt;v )</a>
<a name="ln1302">    {</a>
<a name="ln1303">      p    = ref1;</a>
<a name="ln1304">      ref1 = ref2;</a>
<a name="ln1305">      ref2 = p;</a>
<a name="ln1306">    }</a>
<a name="ln1307"> </a>
<a name="ln1308">    v1 = ref1-&gt;v;</a>
<a name="ln1309">    v2 = ref2-&gt;v;</a>
<a name="ln1310">    u1 = ref1-&gt;u;</a>
<a name="ln1311">    u2 = ref2-&gt;u;</a>
<a name="ln1312">    d1 = u1 - v1;</a>
<a name="ln1313">    d2 = u2 - v2;</a>
<a name="ln1314"> </a>
<a name="ln1315">    if ( u1 == u2 || v1 == v2 )</a>
<a name="ln1316">    {</a>
<a name="ln1317">      for ( p = p1; p &lt;= p2; p++ )</a>
<a name="ln1318">      {</a>
<a name="ln1319">        u = p-&gt;v;</a>
<a name="ln1320"> </a>
<a name="ln1321">        if ( u &lt;= v1 )</a>
<a name="ln1322">          u += d1;</a>
<a name="ln1323">        else if ( u &gt;= v2 )</a>
<a name="ln1324">          u += d2;</a>
<a name="ln1325">        else</a>
<a name="ln1326">          u = u1;</a>
<a name="ln1327"> </a>
<a name="ln1328">        p-&gt;u = u;</a>
<a name="ln1329">      }</a>
<a name="ln1330">    }</a>
<a name="ln1331">    else</a>
<a name="ln1332">    {</a>
<a name="ln1333">      FT_Fixed  scale = FT_DivFix( u2 - u1, v2 - v1 );</a>
<a name="ln1334"> </a>
<a name="ln1335"> </a>
<a name="ln1336">      for ( p = p1; p &lt;= p2; p++ )</a>
<a name="ln1337">      {</a>
<a name="ln1338">        u = p-&gt;v;</a>
<a name="ln1339"> </a>
<a name="ln1340">        if ( u &lt;= v1 )</a>
<a name="ln1341">          u += d1;</a>
<a name="ln1342">        else if ( u &gt;= v2 )</a>
<a name="ln1343">          u += d2;</a>
<a name="ln1344">        else</a>
<a name="ln1345">          u = u1 + FT_MulFix( u - v1, scale );</a>
<a name="ln1346"> </a>
<a name="ln1347">        p-&gt;u = u;</a>
<a name="ln1348">      }</a>
<a name="ln1349">    }</a>
<a name="ln1350">  }</a>
<a name="ln1351"> </a>
<a name="ln1352"> </a>
<a name="ln1353">  /* Hint the weak points -- this is equivalent to the TrueType `IUP' */</a>
<a name="ln1354">  /* hinting instruction.                                             */</a>
<a name="ln1355"> </a>
<a name="ln1356">  FT_LOCAL_DEF( void )</a>
<a name="ln1357">  af_glyph_hints_align_weak_points( AF_GlyphHints  hints,</a>
<a name="ln1358">                                    AF_Dimension   dim )</a>
<a name="ln1359">  {</a>
<a name="ln1360">    AF_Point   points        = hints-&gt;points;</a>
<a name="ln1361">    AF_Point   point_limit   = points + hints-&gt;num_points;</a>
<a name="ln1362">    AF_Point*  contour       = hints-&gt;contours;</a>
<a name="ln1363">    AF_Point*  contour_limit = contour + hints-&gt;num_contours;</a>
<a name="ln1364">    FT_UInt    touch_flag;</a>
<a name="ln1365">    AF_Point   point;</a>
<a name="ln1366">    AF_Point   end_point;</a>
<a name="ln1367">    AF_Point   first_point;</a>
<a name="ln1368"> </a>
<a name="ln1369"> </a>
<a name="ln1370">    /* PASS 1: Move segment points to edge positions */</a>
<a name="ln1371"> </a>
<a name="ln1372">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln1373">    {</a>
<a name="ln1374">      touch_flag = AF_FLAG_TOUCH_X;</a>
<a name="ln1375"> </a>
<a name="ln1376">      for ( point = points; point &lt; point_limit; point++ )</a>
<a name="ln1377">      {</a>
<a name="ln1378">        point-&gt;u = point-&gt;x;</a>
<a name="ln1379">        point-&gt;v = point-&gt;ox;</a>
<a name="ln1380">      }</a>
<a name="ln1381">    }</a>
<a name="ln1382">    else</a>
<a name="ln1383">    {</a>
<a name="ln1384">      touch_flag = AF_FLAG_TOUCH_Y;</a>
<a name="ln1385"> </a>
<a name="ln1386">      for ( point = points; point &lt; point_limit; point++ )</a>
<a name="ln1387">      {</a>
<a name="ln1388">        point-&gt;u = point-&gt;y;</a>
<a name="ln1389">        point-&gt;v = point-&gt;oy;</a>
<a name="ln1390">      }</a>
<a name="ln1391">    }</a>
<a name="ln1392"> </a>
<a name="ln1393">    for ( ; contour &lt; contour_limit; contour++ )</a>
<a name="ln1394">    {</a>
<a name="ln1395">      AF_Point  first_touched, last_touched;</a>
<a name="ln1396"> </a>
<a name="ln1397"> </a>
<a name="ln1398">      point       = *contour;</a>
<a name="ln1399">      end_point   = point-&gt;prev;</a>
<a name="ln1400">      first_point = point;</a>
<a name="ln1401"> </a>
<a name="ln1402">      /* find first touched point */</a>
<a name="ln1403">      for (;;)</a>
<a name="ln1404">      {</a>
<a name="ln1405">        if ( point &gt; end_point )  /* no touched point in contour */</a>
<a name="ln1406">          goto NextContour;</a>
<a name="ln1407"> </a>
<a name="ln1408">        if ( point-&gt;flags &amp; touch_flag )</a>
<a name="ln1409">          break;</a>
<a name="ln1410"> </a>
<a name="ln1411">        point++;</a>
<a name="ln1412">      }</a>
<a name="ln1413"> </a>
<a name="ln1414">      first_touched = point;</a>
<a name="ln1415"> </a>
<a name="ln1416">      for (;;)</a>
<a name="ln1417">      {</a>
<a name="ln1418">        FT_ASSERT( point &lt;= end_point                 &amp;&amp;</a>
<a name="ln1419">                   ( point-&gt;flags &amp; touch_flag ) != 0 );</a>
<a name="ln1420"> </a>
<a name="ln1421">        /* skip any touched neighbours */</a>
<a name="ln1422">        while ( point &lt; end_point                    &amp;&amp;</a>
<a name="ln1423">                ( point[1].flags &amp; touch_flag ) != 0 )</a>
<a name="ln1424">          point++;</a>
<a name="ln1425"> </a>
<a name="ln1426">        last_touched = point;</a>
<a name="ln1427"> </a>
<a name="ln1428">        /* find the next touched point, if any */</a>
<a name="ln1429">        point++;</a>
<a name="ln1430">        for (;;)</a>
<a name="ln1431">        {</a>
<a name="ln1432">          if ( point &gt; end_point )</a>
<a name="ln1433">            goto EndContour;</a>
<a name="ln1434"> </a>
<a name="ln1435">          if ( ( point-&gt;flags &amp; touch_flag ) != 0 )</a>
<a name="ln1436">            break;</a>
<a name="ln1437"> </a>
<a name="ln1438">          point++;</a>
<a name="ln1439">        }</a>
<a name="ln1440"> </a>
<a name="ln1441">        /* interpolate between last_touched and point */</a>
<a name="ln1442">        af_iup_interp( last_touched + 1, point - 1,</a>
<a name="ln1443">                       last_touched, point );</a>
<a name="ln1444">      }</a>
<a name="ln1445"> </a>
<a name="ln1446">    EndContour:</a>
<a name="ln1447">      /* special case: only one point was touched */</a>
<a name="ln1448">      if ( last_touched == first_touched )</a>
<a name="ln1449">        af_iup_shift( first_point, end_point, first_touched );</a>
<a name="ln1450"> </a>
<a name="ln1451">      else /* interpolate the last part */</a>
<a name="ln1452">      {</a>
<a name="ln1453">        if ( last_touched &lt; end_point )</a>
<a name="ln1454">          af_iup_interp( last_touched + 1, end_point,</a>
<a name="ln1455">                         last_touched, first_touched );</a>
<a name="ln1456"> </a>
<a name="ln1457">        if ( first_touched &gt; points )</a>
<a name="ln1458">          af_iup_interp( first_point, first_touched - 1,</a>
<a name="ln1459">                         last_touched, first_touched );</a>
<a name="ln1460">      }</a>
<a name="ln1461"> </a>
<a name="ln1462">    NextContour:</a>
<a name="ln1463">      ;</a>
<a name="ln1464">    }</a>
<a name="ln1465"> </a>
<a name="ln1466">    /* now save the interpolated values back to x/y */</a>
<a name="ln1467">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln1468">    {</a>
<a name="ln1469">      for ( point = points; point &lt; point_limit; point++ )</a>
<a name="ln1470">        point-&gt;x = point-&gt;u;</a>
<a name="ln1471">    }</a>
<a name="ln1472">    else</a>
<a name="ln1473">    {</a>
<a name="ln1474">      for ( point = points; point &lt; point_limit; point++ )</a>
<a name="ln1475">        point-&gt;y = point-&gt;u;</a>
<a name="ln1476">    }</a>
<a name="ln1477">  }</a>
<a name="ln1478"> </a>
<a name="ln1479"> </a>
<a name="ln1480">#ifdef AF_CONFIG_OPTION_USE_WARPER</a>
<a name="ln1481"> </a>
<a name="ln1482">  /* Apply (small) warp scale and warp delta for given dimension. */</a>
<a name="ln1483"> </a>
<a name="ln1484">  FT_LOCAL_DEF( void )</a>
<a name="ln1485">  af_glyph_hints_scale_dim( AF_GlyphHints  hints,</a>
<a name="ln1486">                            AF_Dimension   dim,</a>
<a name="ln1487">                            FT_Fixed       scale,</a>
<a name="ln1488">                            FT_Pos         delta )</a>
<a name="ln1489">  {</a>
<a name="ln1490">    AF_Point  points       = hints-&gt;points;</a>
<a name="ln1491">    AF_Point  points_limit = points + hints-&gt;num_points;</a>
<a name="ln1492">    AF_Point  point;</a>
<a name="ln1493"> </a>
<a name="ln1494"> </a>
<a name="ln1495">    if ( dim == AF_DIMENSION_HORZ )</a>
<a name="ln1496">    {</a>
<a name="ln1497">      for ( point = points; point &lt; points_limit; point++ )</a>
<a name="ln1498">        point-&gt;x = FT_MulFix( point-&gt;fx, scale ) + delta;</a>
<a name="ln1499">    }</a>
<a name="ln1500">    else</a>
<a name="ln1501">    {</a>
<a name="ln1502">      for ( point = points; point &lt; points_limit; point++ )</a>
<a name="ln1503">        point-&gt;y = FT_MulFix( point-&gt;fy, scale ) + delta;</a>
<a name="ln1504">    }</a>
<a name="ln1505">  }</a>
<a name="ln1506"> </a>
<a name="ln1507">#endif /* AF_CONFIG_OPTION_USE_WARPER */</a>
<a name="ln1508"> </a>
<a name="ln1509">/* END */</a>

</code></pre>
<div class="balloon" rel="532"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v512/" target="_blank">V512</a> A call of the '__builtin___memset_chk' function will lead to underflow of the buffer 'hints'.</p></div>
<div class="balloon" rel="689"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'hints->x_scale' variable was assigned the same value.</p></div>
<div class="balloon" rel="690"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'hints->y_scale' variable was assigned the same value.</p></div>
<div class="balloon" rel="691"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'hints->x_delta' variable was assigned the same value.</p></div>
<div class="balloon" rel="692"><p><span style="font-size:18px">&uarr;</span> <a href="https://www.viva64.com/en/w/v1048/" target="_blank">V1048</a> The 'hints->y_delta' variable was assigned the same value.</p></div>

<link rel="stylesheet" href="highlight.css">
<script src="highlight.pack.js"></script>
<script src="highlightjs-line-numbers.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
<script>hljs.initLineNumbersOnLoad();</script>
<script>
  $(document).ready(function() {
      $('.balloon').each(function () {
          var bl = $(this);
          var line = bl.attr('rel');
          var text = $('a[name="ln'+line+'"]').text();

          var space_count = 0;
          for(var i = 0; i<text.length; i++){
              var char = text[i];
              if((char !== ' ')&&(char !== '\t'))break;
              if(char === '\t')space_count++;
              space_count++;
          }

          bl.css('margin-left', space_count*8);
          $('a[name="ln'+line+'"]').after(bl);
      });

      window.location = window.location;
  });
</script>
</body>
</html>
